Projet : File2knowledge version 1.0.0

Ce projet propose une mise en œuvre concrète du point de terminaison v1/responses de l’API OpenAI, en exploitant notamment les fonctionnalités file_search et les magasins vectoriels. L’objectif est de démontrer comment ces outils permettent une exploitation plus fine et pertinente des fichiers, en enrichissant leur surface sémantique. L’indexation vectorielle améliore considérablement la capacité à explorer, relier et interroger le contenu, en offrant des réponses plus contextualisées et informatives.

L’application illustre cet enrichissement par une interrogation intelligente des fichiers disponibles, qu’il s’agisse de documentation technique, de code source ou d’autres formats. Elle s’appuie sur cette architecture sémantique pour maximiser la compréhension et la réutilisation des informations.

Ce projet s’adresse aux développeurs Delphi souhaitant intégrer les capacités de l’API OpenAI dans leurs applications. Il repose sur DelphiGenAI, mais également sur l’ensemble des autres wrappers Delphi que j’ai développés et publiés sur GitHub. Tous les fichiers nécessaires — qu’ils soient Markdown, sources Delphi, exemples d’utilisation ou ressources associées — sont fournis afin de permettre une prise en main progressive et adaptée aux besoins de chacun.

Ce projet est avant tout didactique. Il n’a pas vocation à concurrencer les solutions professionnelles, mais s’inscrit dans une démarche personnelle de partage, d’expérimentation et de plaisir de coder.


## La partie bas niveau - situé dans le dossier 'source' du projet.

Cette partie contient:

1. Les managers : 
- Manager.Async.Promise.pas
- Manager.FileUploadID.Controler.pas
- Manager.Intf.pas
- Manager.IoC.pas
- Manager.TemplateProvider.pas
- Manager.Types.pas
- Manager.Utf8Mapping.pas
- Manager.WebServices.pas
- Model.VectorResource.pas

2. Le système pour manager le format JSON (serailisation/désérialisation des propriétés d'une classe)
- JSON.Resource.Lists.pas
- JSON.Resource.pas

3. Le service pour gérer le démarrage de l'application
- Startup.Context.pas
- Startup.Service.pas

4. Des helpers 
- UserSettings.Persistence.pas
- Helper.FileUploadID.Dictionary.pas
- Helper.UserSettings.pas


5. La gestion des UserSettings ainsi que la gestion des sessions de conversation (ChatTurn/ChatSession/ChatSessionList) 
- Model.VectorResource.pas
- ChatSession.Controller.pas

### Code source de ces unités:


unit ChatSession.Controller;

(*
  Unit: ChatSession.Controller

  Purpose:
    This unit provides the infrastructure for managing chat sessions, including persistence and
    chaining of exchanges (prompts/responses) with direct support for JSON formatting.
    It centralizes the creation, modification, and saving of chat sessions, allowing an artificial
    intelligence application or a user assistant to keep conversation history in a structured form.

  Technical details:
    - Based on TJSONResource inheritance, it benefits from automated JSON serialization/deserialization via RTTI.
    - Uses a "chainable" pattern (TJSONChain) to dynamically apply modifications to session or chat turn
      properties (prompt/response).
    - Offers clear structures for a session (TChatSession), a turn (TChatTurn), a list of sessions
      (TChatSessionList), as well as centralized access through the IPersistentChat interface.
    - Supports editing metadata (title, timestamps) and provides helpers for renaming, deleting, or saving sessions.
    - Easily extendable by adding properties, which can be managed through RTTI manipulation
      (no need to write new setters for each field).

  Dependencies:
    - Unit JSON.Resource: provides the base (TJSONResource), JSON file handling, and RTTI chaining (TJSONChain).
    - REST.Json, REST.Json.Types, REST.JsonReflect: used for object<->JSON conversion.
    - System.Generics.Collections: for typed lists.
    - System.IOUtils: for physical JSON file management.
    - GenAI, GenAI.Types: for possible integration with AI modules or generation models (project-specific).
    - JSON.Resource.Lists: for advanced support of serializable collections.

  Getting started:
    - Instantiate or use TPersistentChat (or the IPersistentChat interface) to manage sessions and turns.
    - All data access and modifications can be performed through the chain (.Chain.Apply(...)), or directly
      via public properties for simple access.
    - Save and load using SaveToFile/LoadFromFile methods, or transparently via the TJSONResource structure.

  This unit is designed to let any developer persist and manipulate chat histories easily,
  regardless of the target business layer (bot, assistant, support, etc.).

*)

interface

uses
  System.SysUtils, System.Classes, System.Generics.Collections, System.IOUtils,
  REST.Json, REST.Json.Types, System.JSON, REST.JsonReflect,
  GenAI, GenAI.Types, JSON.Resource, JSON.Resource.Lists;

type
  /// <summary>
  /// A record providing static property name constants used for JSON serialization keys
  /// and chained RTTI property access within chat session and turn objects.
  /// </summary>
  /// <remarks>
  /// <para>
  /// - These string constants correspond to the property names of chat session and turn data
  /// such as Id, Title, CreatedAt, ModifiedAt, Prompt, Response, Storage flags, and various
  /// JSON encoded fields (JsonPrompt, JsonResponse, JsonFileSearch, JsonWebSearch, JsonFunctionCall).
  /// </para>
  /// <para>
  /// - This record facilitates consistent use of property names across the application, avoiding
  /// hardcoded literals and enabling fluent "chain" property mutation via RTTI.
  /// </para>
  /// </remarks>
  TChatSessionProp = record
    class function Data: string; static; inline;
    class function CreatedAt: string; static; inline;
    class function ModifiedAt: string; static; inline;
    class function Title: string; static; inline;
    class function Id: string; static; inline;
    class function Storage: string; static; inline;
    class function Prompt: string; static; inline;
    class function Response: string; static; inline;
    class function FileSearch: string; static; inline;
    class function WebSearch: string; static; inline;
    class function Reasoning: string; static; inline;
    class function JsonPrompt: string; static; inline;
    class function JsonResponse: string; static; inline;
    class function JsonFileSearch: string; static; inline;
    class function JsonWebSearch: string; static; inline;
    class function JsonFunctionCall: string; static; inline;
  end;

  /// <summary>
  /// Represents a single turn or exchange in a chat session, containing
  /// the prompt (user input), response (AI output), and related metadata.
  /// </summary>
  /// <remarks>
  /// Inherits from TJSONResource to support automatic JSON serialization and deserialization.
  /// Stores unique identifier, flags for persistence, raw and JSON-encoded prompt and response,
  /// as well as JSON search results and function call data associated with the turn.
  /// This class serves as the fundamental data unit for storing user-AI interactions.
  /// </remarks>
  TChatTurn = class(TJSONResource)
  strict private
    FId: string;
    FStorage: boolean;
    FPrompt: string;
    FResponse: string;
    FFileSearch: string;
    FWebSearch: string;
    FReasoning: string;
    FJsonPrompt: string;
    FJsonResponse: string;
    FJsonFileSearch: string;
    FJsonWebSearch: string;
    FJsonFunctionCall: string;
  public
    ///<summary> Unique identifier of the chat turn. </summary>
    property Id: string read FId write FId;
    ///<summary> Indicates whether this turn should be stored persistently. </summary>
    property Storage: boolean read FStorage write FStorage;
    ///<summary> Text of the user's prompt or question. </summary>
    property Prompt: string read FPrompt write FPrompt;
    ///<summary> Text of the AI's response to the prompt. </summary>
    property Response: string read FResponse write FResponse;
    ///<summary> Text of the AI's response to the FileSearch text. </summary>
    property FileSearch: string read FFileSearch write FFileSearch;
    ///<summary> Text of the AI's response to the WebSearch text. </summary>
    property WebSearch: string read FWebSearch write FWebSearch;
    ///<summary> Text of the AI's response to the reasoning text. </summary>
    property Reasoning: string read FReasoning write FReasoning;
    ///<summary> JSON-formatted detailed data about the prompt. </summary>
    property JsonPrompt: string read FJsonPrompt write FJsonPrompt;
    ///<summary> JSON-formatted detailed data about the response. </summary>
    property JsonResponse: string read FJsonResponse write FJsonResponse;
    ///<summary> JSON string representing file search results related to this turn. </summary>
    property JsonFileSearch: string read FJsonFileSearch write FJsonFileSearch;
    ///<summary> JSON string representing web search results related to this turn. </summary>
    property JsonWebSearch: string read FJsonWebSearch write FJsonWebSearch;
    ///<summary> JSON string containing function call information from AI output. </summary>
    property JsonFunctionCall: string read FJsonFunctionCall write FJsonFunctionCall;
  end;

  /// <summary>
  /// Represents a chat session containing multiple chat turns (exchanges),
  /// with editable metadata such as title, creation, and modification timestamps.
  /// </summary>
  /// <remarks>
  /// <para>
  /// Inherits from TJSONListParams with TChatTurn items to facilitate JSON serialization
  /// and deserialization of the entire session along with its constituent turns.
  /// </para>
  /// <para>
  /// Provides chainable methods for fluent setting of properties like Title, CreatedAt,
  /// and ModifiedAt. Supports saving the current chat session state persistently.
  /// </para>
  /// This class acts as the container for a full conversation history and its management.
  /// </remarks>
  TChatSession = class(TJSONListParams<TChatSession, TChatTurn>)
  strict private
    FCreatedAt: Int64;
    FModifiedAt: Int64;
    FTitle: string;
  public
    ///<summary> Sets the Title property and returns the current instance for chaining. </summary>
    ///<param name="Value"> The new title of the chat session. </param>
    function ApplyTitle(const Value: string): TChatSession;
    ///<summary> Sets the CreatedAt timestamp and returns the current instance for chaining. </summary>
    ///<param name="Value"> The creation timestamp in Int64 format. </param>
    function ApplyCreatedAt(const Value: Int64): TChatSession;
    ///<summary> Sets the ModifiedAt timestamp and returns the current instance for chaining. </summary>
    ///<param name="Value"> The modification timestamp in Int64 format. </param>
    function ApplyModifiedAt(const Value: Int64): TChatSession;
    /// <summary>
    /// Returns ChatTurn count
    /// </summary>
    function Count: Integer;
    ///<summary> Saves the current chat session's state persistently. </summary>
    ///<returns> The current instance for method chaining. </returns>
    function SaveCurrentChat: TChatSession;
    ///<summary> Timestamp indicating when the session was created. </summary>
    property CreatedAt: Int64 read FCreatedAt write FCreatedAt;
    ///<summary> Timestamp indicating the last modification date of the session. </summary>
    property ModifiedAt: Int64 read FModifiedAt write FModifiedAt;
    ///<summary>T he title of the chat session, typically user-editable. </summary>
    property Title: string read FTitle write FTitle;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a list of chat sessions, managing multiple conversations.
  /// </summary>
  /// <remarks>
  /// Inherits from TJSONListParams specialized for handling TChatSession objects.
  /// Provides singleton access via the Instance method, enabling centralized management
  /// of all chat sessions.
  /// Supports loading and reloading from JSON files with Reload, and saving data to disk.
  /// Offers operations such as Delete and Rename to manage chat sessions by item or index.
  /// Ensures persistence of chat session data with automatic JSON serialization.
  /// </remarks>
  TChatSessionList = class(TJSONListParams<TChatSessionList, TChatSession>)
  strict private
    /// <summary>
    /// Internal singleton instance.
    /// </summary>
    class var FInstance: TChatSessionList;
  public
    /// <summary>
    /// Gets the singleton instance of the chat session list.
    /// Loads the list from default JSON file if necessary.
    /// </summary>
    class function Instance: TChatSessionList; static;
    /// <summary>
    /// Reloads the chat session list from the specified JSON file or default file if omitted.
    /// Frees the previous instance and reloads it from storage.
    /// </summary>
    /// <param name="FileName">Optional JSON file name to load from.</param>
    /// <returns>The reloaded singleton instance.</returns>
    class function Reload(const FileName: string = ''): TChatSessionList; static;
    /// <summary>
    /// Returns the default JSON file name used for storing the chat sessions.
    /// </summary>
    class function JsonFileName: string;
    /// <summary>
    /// Deletes a chat session item.
    /// Calls the provided callback procedure for each stored chat turn's ID before deletion.
    /// </summary>
    /// <param name="Item">The chat session object to delete.</param>
    /// <param name="ParamProc">A callback procedure receiving each stored chat turn ID.</param>
    /// <returns>The chat session list instance for chaining.</returns>
    function Delete(const Item: TObject; ParamProc: TProc<string>): TChatSessionList; overload;
    /// <summary>
    /// Renames a chat session by its index in the list.
    /// Changes the session's title to the specified new title.
    /// </summary>
    /// <param name="Index">The index of the chat session to rename.</param>
    /// <param name="NewTitle">The new title to assign.</param>
    /// <returns>The chat session list instance for chaining.</returns>
    function Rename(const Index: Integer; NewTitle: string): TChatSessionList; overload;
    /// <summary>
    /// Renames a chat session given its object instance.
    /// Changes the session's title to the specified new title.
    /// </summary>
    /// <param name="Item">The chat session object to rename.</param>
    /// <param name="NewTitle">The new title to assign.</param>
    /// <returns>The chat session list instance for chaining.</returns>
    function Rename(const Item: TObject; NewTitle: string): TChatSessionList; overload;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Interface for managing persistent chat sessions and prompts.
  /// </summary>
  /// <remarks>
  /// <para>
  /// This interface provides methods and properties to handle the lifecycle of chat sessions,
  /// including adding new chats and prompts, loading and saving chat data from/to files,
  /// and clearing the current chat state. It abstracts access to a collection of chat sessions
  /// and allows setting or retrieving the current chat session and prompt.
  /// </para>
  /// <para>
  /// Typical usage involves managing chat histories with persistence, enabling features like
  /// session switching, prompt additions, and file-based storage for conversation history.
  /// </para>
  /// </remarks>
  IPersistentChat = interface
    ['{7278ECC9-D702-4EC3-88E6-54B97732B7F5}']
    procedure SetCurrentChat(const Value: TChatSession);
    function GetData: TChatSessionList;
    function GetCurrentChat: TChatSession;
    function GetCurrentPrompt: TChatTurn;
    /// <summary>
    /// Adds a new chat session to the collection and sets it as current.
    /// </summary>
    /// <returns>The newly created TChatSession instance.</returns>
    function AddChat: TChatSession;

    /// <summary>
    /// Adds a new prompt (turn) to the current chat session.
    /// If no current chat exists, one is created automatically.
    /// </summary>
    /// <returns> The newly created TChatTurn instance representing the prompt.</returns>
    function AddPrompt: TChatTurn;

    /// <summary>
    /// Loads chat session data from a JSON file.
    /// </summary>
    /// <param name="FileName">Optional file name to load from. If empty, uses default storage.</param>
    /// <returns> Result of the load operation as a string, typically a status or file path.</returns>
    function LoadFromFile(FileName: string = ''): string;

    /// <summary>
    /// Returns session count
    /// </summary>
    function Count: Integer;

    /// <summary>
    /// Saves the current chat session data to a JSON file.
    /// </summary>
    /// <param name="FileName"> Optional file name to save to. If empty, uses default storage.</param>
    procedure SaveToFile(FileName: string = '');

    /// <summary>
    /// Clears the current chat and prompt references, effectively resetting the chat state.
    /// </summary>
    procedure Clear;

    /// <summary>
    /// Gets the full collection of chat sessions.
    /// </summary>
    property Data: TChatSessionList read GetData;

    /// <summary>
    /// Gets or sets the current active chat session.
    /// </summary>
    property CurrentChat: TChatSession read GetCurrentChat write SetCurrentChat;

    /// <summary>
    /// Gets the current prompt (turn) within the active chat session.
    /// </summary>
    property CurrentPrompt: TChatTurn read GetCurrentPrompt;
  end;

  TPersistentChat = class(TInterfacedObject, IPersistentChat)
  private
    FData: TChatSessionList;
    FCurrentChat: TChatSession;
    FCurrentPrompt: TChatTurn;
    function GetData: TChatSessionList;
    function GetCurrentChat: TChatSession;
    function GetCurrentPrompt: TChatTurn;
    procedure SetCurrentChat(const Value: TChatSession);
  public
    function AddChat: TChatSession;
    function AddPrompt: TChatTurn;
    function LoadFromFile(FileName: string = ''): string;
    procedure SaveToFile(FileName: string = '');
    procedure Clear;
    function Count: Integer;
    property Data: TChatSessionList read GetData;
    property CurrentChat: TChatSession read GetCurrentChat write SetCurrentChat;
    property CurrentPrompt: TChatTurn read GetCurrentPrompt;
    constructor Create;
    destructor Destroy; override;
  end;

implementation

uses
  Manager.Intf;

{ TPersistentChat }

function TPersistentChat.AddChat: TChatSession;
begin
  Result := FData.AddItem;
  FCurrentChat := Result;
end;

function TPersistentChat.AddPrompt: TChatTurn;
begin
  if not Assigned(FCurrentChat) then
    FCurrentChat := FData.AddItem;
  FCurrentPrompt := FCurrentChat.AddItem;
  Result := FCurrentPrompt;
end;

procedure TPersistentChat.Clear;
begin
  FCurrentChat := nil;
  FCurrentPrompt := nil;
end;

function TPersistentChat.Count: Integer;
begin
  Result := Length(Data.Data);
end;

constructor TPersistentChat.Create;
begin
  inherited Create;
  FData := TChatSessionList.ReLoad;
end;

destructor TPersistentChat.Destroy;
begin
  FData.Free;
  inherited;
end;

function TPersistentChat.GetCurrentChat: TChatSession;
begin
  Result := FCurrentChat;
end;

function TPersistentChat.GetCurrentPrompt: TChatTurn;
begin
  Result := FCurrentPrompt;
end;

function TPersistentChat.GetData: TChatSessionList;
begin
  Result := FData;
end;

function TPersistentChat.LoadFromFile(FileName: string): string;
begin
  FData := TChatSessionList.Reload(FileName);
end;

procedure TPersistentChat.SaveToFile(FileName: string);
begin
  FData.Save(FileName);
end;

procedure TPersistentChat.SetCurrentChat(const Value: TChatSession);
begin
  FCurrentChat := Value;
end;

{ TChatSession }

function TChatSession.ApplyCreatedAt(const Value: Int64): TChatSession;
begin
  CreatedAt := Value;
  Result := Self;
end;

function TChatSession.ApplyModifiedAt(const Value: Int64): TChatSession;
begin
  ModifiedAt := Value;
  Result := Self;
end;

function TChatSession.ApplyTitle(const Value: string): TChatSession;
begin
  Title := Value;
  Result := Self;
end;

function TChatSession.Count: Integer;
begin
  Result := Length(Data);
end;

destructor TChatSession.Destroy;
begin
  Clear;
  inherited;
end;

function TChatSession.SaveCurrentChat: TChatSession;
begin
  if Assigned(PersistentChat) and Assigned(PersistentChat.CurrentChat) then
    PersistentChat.CurrentChat.Save;
  Result := Self;
end;

{ TChatSessionList }

function TChatSessionList.Delete(const Item: TObject;
  ParamProc: TProc<string>): TChatSessionList;
begin
  var Buffer := TChatSession(Item);

  for var Value in Buffer.Data do
    if Value.Storage and Assigned(ParamProc) then
      ParamProc(Value.Id);

  Result := inherited Delete(Item);
end;

destructor TChatSessionList.Destroy;
begin
  Clear;
  inherited;
end;

class function TChatSessionList.Instance: TChatSessionList;
begin
  if not Assigned(FInstance) then
    FInstance := TChatSessionList.Load as TChatSessionList;
  Result := FInstance;
end;

class function TChatSessionList.JsonFileName: string;
begin
  Result := DefaultFileName;
end;

class function TChatSessionList.Reload(
  const FileName: string): TChatSessionList;
begin
  FInstance.Free;
  FInstance := TChatSessionList.Load(FileName) as TChatSessionList;
  Result := FInstance;
end;

function TChatSessionList.Rename(const Item: TObject;
  NewTitle: string): TChatSessionList;
begin
  Result := Rename(ItemCheck(Item).IndexOf(Item), NewTitle);
end;

function TChatSessionList.Rename(const Index: Integer;
  NewTitle: string): TChatSessionList;
begin
  if index > -1 then
    begin
      EnsureIndex(Index).Data[Index].Chain.Apply('title', NewTitle);
    end;
  Result := Self;
end;

{ TChatSessionProp }

class function TChatSessionProp.CreatedAt: string;
begin
  Result := 'createdAt';
end;

class function TChatSessionProp.Data: string;
begin
  Result := 'data';
end;

class function TChatSessionProp.FileSearch: string;
begin
  Result := 'fileSearch';
end;

class function TChatSessionProp.Id: string;
begin
  Result := 'id';
end;

class function TChatSessionProp.JsonFileSearch: string;
begin
  Result := 'jsonFileSearch';
end;

class function TChatSessionProp.JsonFunctionCall: string;
begin
  Result := 'jsonFunctionCall';
end;

class function TChatSessionProp.JsonPrompt: string;
begin
  Result := 'jsonPrompt';
end;

class function TChatSessionProp.JsonResponse: string;
begin
  Result := 'jsonResponse';
end;

class function TChatSessionProp.JsonWebSearch: string;
begin
  Result := 'jsonWebSearch';
end;

class function TChatSessionProp.ModifiedAt: string;
begin
  Result := 'modifiedAt';
end;

class function TChatSessionProp.Prompt: string;
begin
  Result := 'prompt';
end;

class function TChatSessionProp.Reasoning: string;
begin
  Result := 'reasoning';
end;

class function TChatSessionProp.Response: string;
begin
  Result := 'response';
end;

class function TChatSessionProp.Storage: string;
begin
  Result := 'storage';
end;

class function TChatSessionProp.Title: string;
begin
  Result := 'title';
end;

class function TChatSessionProp.WebSearch: string;
begin
  Result := 'webSearch';
end;

end.

unit Helper.FileUploadID.Dictionary;

(*
  Unit: Helper.FileUploadID.Dictionary

  Purpose:
    Provides robust and verifiable encapsulation for managing associations between filenames and FileUploadIds,
    which is essential for the effective and consistent handling of files linked to vector stores in the File2knowledgeAI project.

  Key roles and concerns:
    - Proactive duplicate detection (with a dedicated exception), ensuring data structure reliability both client- and server-side.
    - Atomic operations on typed dictionaries (add, remove, synchronized initialization), facilitating synchronization
      with OpenAI and the user interface.
    - Lays the groundwork for “snapshot” file comparison, enabling validation, persistence, and transactional rollback/restoration
      when UI-side modifications occur.

  Project context:
    - Designed for close use with Manager.FileUploadID.Controler and UI.VectorResourceEditor.VCL.
    - Documented and architected for quick onboarding by developers of all levels, while remaining extensible
      for enterprise needs (e.g., locking, async operations, rollback, etc.).
    - Extensible structure allowing for future validation logic or additional dictionary manipulation methods if necessary.
*)


interface

uses
  System.Generics.Collections, System.SysUtils;

type
  EStringArrayDuplicateItem  = class(Exception);
  EFileUploadDictionaryMissing  = class(Exception);

  TArrayString = record
  public
    class procedure DuplicateExists(const Values: TArray<string>); static;
  end;

  /// <summary>
  /// Encapsulates a typed dictionary mapping file names to FileUploadIds,
  /// providing safe, atomic operations for file management within the File2knowledgeAI application.
  /// </summary>
  /// <remarks>
  /// Enables initialization, addition, removal, and retrieval of file-to-id associations,
  /// with built-in duplicate detection and validation for consistent client/server synchronization.
  /// Designed for integration with higher-level controllers and UI components managing file attachments
  /// and vector store operations.
  /// </remarks>
  TFileUploadIdDictionary = record
  private
    FDictionary: TDictionary<string, string>;
  public
    constructor Create(const ADictionary: TDictionary<string, string>);

    /// <summary>
    /// Initializes the dictionary contents from provided parallel arrays of file names and FileUploadIds.
    /// </summary>
    /// <param name="FileNames">The array of file names.</param>
    /// <param name="FileUploadIds">The array of corresponding FileUploadIds.</param>
    /// <returns>The updated TFileUploadIdDictionary instance.</returns>
    function Initialize(const FileNames: TArray<string>; const FileUploadIds: TArray<string>): TFileUploadIdDictionary;

    /// <summary>
    /// Adds or updates an entry in the dictionary, associating a file name with a FileUploadId.
    /// Optionally executes a callback after completion.
    /// </summary>
    /// <param name="FileName">The name of the file to add or update.</param>
    /// <param name="FileUploadId">The FileUploadId to associate with the file.</param>
    /// <param name="Proc">Optional callback procedure to execute after the operation.</param>
    /// <returns>The updated TFileUploadIdDictionary instance.</returns>
    function AddOrSetValue(const FileName: string; const FileUploadId: string; Proc: TProc = nil): TFileUploadIdDictionary;

    /// <summary>
    /// Removes an entry from the dictionary by file name.
    /// Optionally executes a callback after removal.
    /// </summary>
    /// <param name="FileName">The name of the file to remove.</param>
    /// <param name="Proc">Optional callback procedure to execute after the operation.</param>
    /// <returns>The updated TFileUploadIdDictionary instance.</returns>
    function Remove(const FileName: string; Proc: TProc = nil): TFileUploadIdDictionary;

    /// <summary>
    /// Retrieves the internal dictionary of file-to-FileUploadId mappings.
    /// </summary>
    /// <returns>The managed TDictionary instance.</returns>
    function Dictionary: TDictionary<string, string>;
  end;

  /// <summary>
  /// Provides comparison and synchronization logic between two dictionaries representing file-to-FileUploadId mappings,
  /// supporting transactional change detection, validation, and restoration in the File2knowledgeAI project.
  /// </summary>
  /// <remarks>
  /// Designed to facilitate snapshot/draft diffing, cleanup of lost or detached items, and callback-driven operations
  /// for deletion, validation, or rollback scenarios. Intended for internal use by controller and UI classes when
  /// managing file attachments or persisting changes to vector resource metadata.
  /// </remarks>
  TDictionaryContentComparison = record
  private
    FSnapshot: TDictionary<string, string>;
    FDraft: TDictionary<string, string>;
    procedure HandleLostItem(const FileName, FileUploadId: string; Proc: TProc<string, string>);
  public
    constructor Create(const ASnapshot, ADraft: TDictionary<string, string>);

    /// <summary>
    /// Iterates over the snapshot dictionary, calling the given procedure for each item that is missing or mismatched in the draft.
    /// </summary>
    /// <param name="Proc">A callback taking (FileName, FileUploadId) to execute for each lost or detached association.</param>
    /// <returns>The current TDictionaryContentComparison instance for chaining.</returns>
    function Apply(Proc: TProc<string, string>): TDictionaryContentComparison;

    /// <summary>
    /// Applies a visual or validation-oriented callback to allow UI components or external handlers to update in response to restoration.
    /// </summary>
    /// <param name="Proc">A callback procedure with no parameters to execute after restoration.</param>
    /// <returns>The current TDictionaryContentComparison instance for chaining.</returns>
    function Restore(Proc: TProc): TDictionaryContentComparison;

    /// <summary>
    /// Returns the validated draft dictionary, representing the current synchronized state after changes and checks.
    /// </summary>
    /// <returns>The draft dictionary containing file-to-FileUploadId mappings.</returns>
    function DraftValidated: TDictionary<string, string>;
  end;

implementation

{ TFileUploadIdDictionary }

function TFileUploadIdDictionary.AddOrSetValue(const FileName,
  FileUploadId: string; Proc: TProc): TFileUploadIdDictionary;
begin
  FDictionary.AddOrSetValue(FileName, FileUploadId);
  Result := Self;
  if Assigned(Proc) then
    Proc();
end;

constructor TFileUploadIdDictionary.Create(
  const ADictionary: TDictionary<string, string>);
begin
  if not Assigned(ADictionary) then
    raise EFileUploadDictionaryMissing .Create('ADictionary cannot be nil');
  Self.FDictionary := ADictionary;
end;

function TFileUploadIdDictionary.Remove(
  const FileName: string; Proc: TProc): TFileUploadIdDictionary;
begin
  FDictionary.Remove(FileName);
  Result := Self;
  if Assigned(Proc) then
    Proc();
end;

function TFileUploadIdDictionary.Dictionary: TDictionary<string, string>;
begin
  Result := FDictionary;
end;

function TFileUploadIdDictionary.Initialize(const FileNames,
  FileUploadIds: TArray<string>): TFileUploadIdDictionary;
{--- The FileNames and FileUploadIds lists have no duplicates because they are retrieved from OpenAI's DashBoard. }
begin
  {--- We still check for the existence of duplicates with an exception lebe detected }
  TArrayString.DuplicateExists(FileNames);
  TArrayString.DuplicateExists(FileUploadIds);

  FDictionary.Clear;

  {--- We guarantee a consistent list }
  var CountFile := Length(FileNames);
  var CountIds := Length(FileUploadIds);
  for var i := 0 to CountFile - 1 do
    begin
      if i < CountIds then
        AddOrSetValue(FileNames[i], FileUploadIds[i])
      else
        AddOrSetValue(FileNames[i], EmptyStr)
    end;
  Result := Self;
end;

{ TArrayString }

class procedure TArrayString.DuplicateExists(
  const Values: TArray<string>);
var
  Seen: TDictionary<string, Boolean>;
begin
  Seen := TDictionary<string, Boolean>.Create;
  try
    for var Value in Values do
      begin
        if Seen.ContainsKey(Value) then
          begin
            raise EStringArrayDuplicateItem .CreateFmt('Duplicate item : "%s"', [Value]);
          end
        else
          Seen.Add(Value, True);
      end;
  finally
    Seen.Free;
  end;
end;

{ TDictionaryContentComparison }

function TDictionaryContentComparison.Apply(
  Proc: TProc<string, string>): TDictionaryContentComparison;
begin
  for var Pair in FSnapshot do
    HandleLostItem(Pair.Key, Pair.Value, Proc);
  Result := Self;
end;

constructor TDictionaryContentComparison.Create(const ASnapshot,
  ADraft: TDictionary<string, string>);
begin
  FSnapshot := ASnapshot;
  FDraft := ADraft;
end;

function TDictionaryContentComparison.DraftValidated: TDictionary<string, string>;
begin
  Result := FDraft;
end;

procedure TDictionaryContentComparison.HandleLostItem(const FileName, FileUploadId: string;
  Proc: TProc<string, string>);
var
  Value: string;
begin
  if FDraft.TryGetValue(FileName, Value) then
    begin
      if Value.Trim.IsEmpty then
        FDraft[FileName] := FileUploadId
    end
  else
    begin
      {--- If FileUploadId is not empty, invoke the Proc method (fully asynchronous,
           fire-and-forget) to delete the corresponding file on the server.
      }
      if Assigned(Proc) then
        try
          Proc(FileName, FileUploadId);
        except
        end;
    end;
end;

function TDictionaryContentComparison.Restore(
  Proc: TProc): TDictionaryContentComparison;
begin
  Result := Self;
  {--- La métdode proc (fire-and forget) ne fera que mettre à jour un composant visuel }
  if Assigned(Proc) then
    Proc();
end;

end.

unit Helper.UserSettings;

(*
  Unit: Helper.UserSettings

  Purpose:
    Provides centralized helpers and metadata for user settings types and enums
    used throughout the application (such as AI model types, proficiency levels, intensities, summaries, and timeouts).
    This unit encapsulates string conversions, default values, option lists, and utility operations—
    supporting clear, maintainable, and scalable settings logic for both UI and backend.

  Technical details:
    - Defines and extends key enums with helper records for display, parsing, indexing, and defaults (e.g., `TModelTypeHelper`, `TProficiencyLevelHelper`).
    - Aggregates name arrays, default selections, icon representations, and provides methods for retrieving allowed values and string conversions.
    - Includes a dedicated `TModelCosts` class for model token cost calculation and formatted output.
    - Supports settings logic extension uniformly, from adding new options to managing localized labels or costs.

  Usage:
    - Use enum helpers for clean conversion and UI rendering logic (e.g., for ComboBox population, settings serialization, etc.).
    - Query model costs, allowed values, or icons via the provided helper methods.
    - Extend user settings simply by updating these helpers, reducing code duplication across the codebase.

  This unit helps ensure a single source of truth for user settings metadata, decoupling display and logic,
  and fostering extensibility throughout the application.
*)


interface

uses
  System.SysUtils, System.Classes, System.Generics.Collections;

type
  TModelType = (mtSearch, mtReasoning);

  TModelTypeHelper = record helper for TModelType
  private
    const
      ModelNames: array[TModelType] of TArray<string> = (
        {--- mtSearch }
        ['gpt-4o', 'gpt-4o-mini', 'gpt-4.1', 'gpt-4.1-mini', 'gpt-4.1-nano'],
        {--- mtReasoning }
        ['o1', 'o1-pro', 'o3', 'o3-mini', 'o4-mini']
      );

      DefaultModels: array[TModelType] of string = (
        {--- mtSearch }
        'gpt-4.1-mini',
        {--- mtReasoning }
        'o4-mini'
      );

  public
    function GetModelNames: TArray<string>;
    function GetDefaultModel: string;
    function IndexOfModel(const ModelName: string): Integer;
  end;

  TProficiencyLevel = (plJunior, plIntermediate, plSenior, plLeadDev, plArchitect);

  TProficiencyLevelHelper = record helper for TProficiencyLevel
  private
    const
      Names: array[TProficiencyLevel] of string = (
        'Delphi Dev – Junior',
        'Delphi Dev – Intermediate',
        'Delphi Dev – Senior',
        'Lead Dev Delphi',
        'Delphi Software Architect'
      );

      Icons: array[TProficiencyLevel] of string = (
        '', '', '', '', ''
      );

      DefaultLevel = plIntermediate;
  public
    function ToString: string;
    function ToIcon: string;
    class function FromIndex(Index: Integer): TProficiencyLevel; static;
    class function Default: TProficiencyLevel; static;
    class function Count: Integer; static;
    class function AllIcons: string; static;
  end;

  TModelCosts = class
  private
    FCosts: TDictionary<Integer, TArray<string>>;
    const TOKEN_COST_PATTERN = 'Per 1M tokens Input: %s output: %s';
  public
    constructor Create;
    destructor Destroy; override;
    function GetCost(ModelType: TModelType; Index: Integer): string;
  end;

  TIntensity = (iyLow, iyMedium, iyHigh);

  TIntensityHelper = record Helper for TIntensity
  private
    const
      Intensities : array[TIntensity] of string = (
        'Low', 'Medium', 'High'
      );
     DefaultIntensity = iyMedium;
  public
    function ToString: string;
    class function Default: TIntensity; static;
    class function FromIndex(Index: Integer): TIntensity; static;
    class function Count: Integer; static;
    class function AllIntensities: string; static;
  end;

  TSummary = (syNone, syDetailed);

  TSummaryHelper = record Helper for TSummary
  private
    const
      Summaries : array[TSummary] of string = (
        'None', 'Detailed'
      );
      DefaultSummary = syNone;
  public
    function ToString: string;
    class function Default: TSummary; static;
    class function FromIndex(Index: Integer): TSummary; static;
    class function Count: Integer; static;
    class function AllSummaries: string; static;
  end;

  TTimeOut = (t30s, t60s, t5m, t10m, t20m, t30m, t60m, t5h, t12h, t24h);

  TTimeOutHelper = record Helper for TTimeOut
  private
    const
      TimeOuts : array[TTimeOut] of string = (
        '30 seconds' , '60 seconds' ,
        '5 minutes' , '10 minutes' , '20 minutes' , '30 minutes' , '60 minutes' ,
        '5 hours' , '12 hours' , '24 hours'
      );

      Timeoutms : array[TTimeOut] of Cardinal = (
        30000, 60000,
        300000, 600000, 1200000, 1800000, 3600000,
        18000000, 43200000, 86400000
      );

      DefaultTimeOut = t30s;
  public
    function ToString: string;
    function ToMilliseconds: Cardinal;
    class function Default: TTimeOut; static;
    class function FromIndex(Index: Integer): TTimeOut; static;
    class function TextToCardinal(const Text: string): Cardinal; static;
    class function Count: Integer; static;
    class function AllTimeOuts: string; static;
  end;

implementation

{ TModelTypeHelper }

function TModelTypeHelper.GetDefaultModel: string;
begin
  Result := DefaultModels[Self];
end;

function TModelTypeHelper.GetModelNames: TArray<string>;
begin
  Result := ModelNames[Self];
end;

function TModelTypeHelper.IndexOfModel(const ModelName: string): Integer;
begin
  Result := TArray.IndexOf<string>(ModelNames[Self], ModelName);
end;

{ TProficiencyLevelHelper }

class function TProficiencyLevelHelper.AllIcons: string;
begin
  Result := String.Join(#10, Icons);
end;

class function TProficiencyLevelHelper.Count: Integer;
begin
  Result := Length(Names);
end;

class function TProficiencyLevelHelper.Default: TProficiencyLevel;
begin
  Result := DefaultLevel;
end;

class function TProficiencyLevelHelper.FromIndex(
  Index: Integer): TProficiencyLevel;
begin
  if (Index >= 0) and (Index < Count) then
    Result := TProficiencyLevel(Index)
  else
    Result := Default;
end;

function TProficiencyLevelHelper.ToIcon: string;
begin
  Result := Icons[Self];
end;

function TProficiencyLevelHelper.ToString: string;
begin
  Result := Names[Self];
end;

{ TModelCosts }

constructor TModelCosts.Create;
begin
  FCosts := TDictionary<Integer, TArray<string>>.Create;

  {--- Costs of research models }
  FCosts.Add(Ord(mtSearch) * 1000 + 0, ['$2.50', '$10.00']);
  FCosts.Add(Ord(mtSearch) * 1000 + 1, ['$0.15', '$0.60']);
  FCosts.Add(Ord(mtSearch) * 1000 + 2, ['$2.00', '$8.00']);
  FCosts.Add(Ord(mtSearch) * 1000 + 3, ['$0.40', '$1.60']);
  FCosts.Add(Ord(mtSearch) * 1000 + 4, ['$0.10', '$0.40']);

  {--- Costs of reasoning models }
  FCosts.Add(Ord(mtReasoning) * 1000 + 0, ['$15.00', '$60.00']);
  FCosts.Add(Ord(mtReasoning) * 1000 + 1, ['$150.00', '$600.00']);
  FCosts.Add(Ord(mtReasoning) * 1000 + 2, ['$10.00', '$40.00']);
  FCosts.Add(Ord(mtReasoning) * 1000 + 3, ['$1.10', '$4.40']);
  FCosts.Add(Ord(mtReasoning) * 1000 + 4, ['$1.10', '$4.40']);
end;

destructor TModelCosts.Destroy;
begin
  FCosts.Free;
  inherited;
end;

function TModelCosts.GetCost(ModelType: TModelType; Index: Integer): string;
var
  CostValues: TArray<string>;
begin
  var Key := Ord(ModelType) * 1000 + Index;
  if FCosts.TryGetValue(Key, CostValues) then
    begin
      if Length(CostValues) = 2 then
        Result := Format(TOKEN_COST_PATTERN, [CostValues[0], CostValues[1]])
      else
        Result := 'Invalid Cost Format';
    end
  else
    Result := 'Unknown Cost';
end;

{ TIntensityHelper }

class function TIntensityHelper.AllIntensities: string;
begin
  Result := String.Join(#10, Intensities);
end;

class function TIntensityHelper.Count: Integer;
begin
  Result := Length(Intensities);
end;

class function TIntensityHelper.Default: TIntensity;
begin
  Result := DefaultIntensity;
end;

class function TIntensityHelper.FromIndex(Index: Integer): TIntensity;
begin
  if (Index >= 0) and (Index < Count) then
    Result := TIntensity(Index)
  else
    Result := Default;
end;

function TIntensityHelper.ToString: string;
begin
  Result := Intensities[Self];
end;

{ TSummaryHelper }

class function TSummaryHelper.AllSummaries: string;
begin
  Result := string.Join(#10, Summaries);
end;

class function TSummaryHelper.Count: Integer;
begin
  Result := Length(Summaries);
end;

class function TSummaryHelper.Default: TSummary;
begin
  Result := DefaultSummary;
end;

class function TSummaryHelper.FromIndex(Index: Integer): TSummary;
begin
  if (Index >= 0) and (Index < Count) then
    Result := TSummary(Index)
  else
    Result := Default;
end;

function TSummaryHelper.ToString: string;
begin
  Result := Summaries[Self];
end;

{ TTimeOutHelper }

class function TTimeOutHelper.AllTimeOuts: string;
begin
  Result := string.Join(#10, TimeOuts);
end;

class function TTimeOutHelper.Count: Integer;
begin
  Result := Length(TimeOuts);
end;

class function TTimeOutHelper.Default: TTimeOut;
begin
  Result := DefaultTimeOut;
end;

class function TTimeOutHelper.FromIndex(Index: Integer): TTimeOut;
begin
  if (Index >= 0) and (Index < Count) then
    Result := TTimeOut(Index)
  else
    Result := Default;
end;

class function TTimeOutHelper.TextToCardinal(const Text: string): Cardinal;
begin
  var NormalizedText := Text.Trim.ToLower;
  for var index := ord(Low(TTimeOut)) to Ord(High(TTimeOut)) do
    if TimeOuts[TTimeOut(index)].Trim.ToLower = NormalizedText then
      Exit(TTimeOut(index).ToMilliseconds);
  raise Exception.CreateFmt('"%s" is not a correct timeout format', [Text]);
end;

function TTimeOutHelper.ToMilliseconds: Cardinal;
begin
  Result := Timeoutms[Self];
end;

function TTimeOutHelper.ToString: string;
begin
  Result := TimeOuts[Self];
end;

end.

unit JSON.Resource.Lists;

interface

uses
  System.SysUtils, System.Classes, System.Generics.Collections, System.JSON,
  GenAI, GenAI.Types, JSON.Resource;

type
  EIndexOutOfBounds = class(EArgumentOutOfRangeException);
  EArgumentNil = class(EArgumentNilException);

  TJSONListParams<T: class; U: class, constructor> = class abstract(TJSONResource)
  private
    FData: TArray<U>;
  protected
    function EnsureIndex(const Index: Integer): T;
    function IndexOf(const Item: TObject): Integer;
    function ItemCheck(const Item: TObject): T;
  public
    function AddItem: U; virtual;
    function Clear: T;
    function Delete(const Index: Integer): T; overload;
    function Delete(const Item: TObject): T; overload; virtual;
    function WithData(const Value: TArray<U>): T; overload;
    function WithData(const Value: TArray<TFactory<U>>): T; overload;
    property Data: TArray<U> read FData write FData;
  end;

implementation

{ TDataList<T, U> }

function TJSONListParams<T, U>.AddItem: U;
begin
  Result := U.Create;
  FData := FData + [Result];
end;

function TJSONListParams<T, U>.Clear: T;
begin
  for var Item in FData do
    Item.Free;
  FData := [];
  Result := Self as T;
end;

function TJSONListParams<T, U>.Delete(const Item: TObject): T;
begin
  ItemCheck(Item);
  Result := Delete(IndexOf(Item));
end;

function TJSONListParams<T, U>.Delete(const Index: Integer): T;
begin
  if index < 0 then
    Exit(Self as T);

  EnsureIndex(Index);
  var FList := TList<U>.Create(Data);
  try
    FList[Index].Free;
    FList.Delete(Index);
    Data := FList.ToArray;
  finally
     FList.Free;
  end;
  Result := Self as T;
end;

function TJSONListParams<T, U>.EnsureIndex(const Index: Integer): T;
begin
  if Index >= Length(Data) then
    raise EIndexOutOfBounds.CreateFmt(
      'JSONList: index %d out of bounds [0..%d]', [Index, Length(Data)-1]);
  Result := Self as T;
end;

function TJSONListParams<T, U>.IndexOf(const Item: TObject): Integer;
begin
  for Result := 0 to High(FData) do
    if Pointer(FData[Result]) = Pointer(Item) then
      Exit;
  Result := -1;
end;

function TJSONListParams<T, U>.ItemCheck(const Item: TObject): T;
begin
  if not (Item is U) then
    raise EArgumentNil.CreateFmt(
            'Class %s not supported', [Item.ClassName]);
  Result := Self as T;
end;

function TJSONListParams<T, U>.WithData(const Value: TArray<TFactory<U>>): T;
begin
  for var i := Low(FData) to High(FData) do
    FData[i].Free;
  SetLength(FData, Length(Value));
  for var i := 0 to High(Value) do
    FData[i] := Value[i]();
  Result := Self as T;
end;

function TJSONListParams<T, U>.WithData(const Value: TArray<U>): T;
begin
  for var i := Low(FData) to High(FData) do
    FData[i].Free;
  FData := [];
  FData := Value;
  Result := Self as T;
end;

end.

unit JSON.Resource;

(*
  Unit: JSON.Resource

  Purpose:
    This unit provides shared infrastructure for automated JSON serialization and deserialization of
    Delphi objects by leveraging RTTI (Run-Time Type Information).
    It abstracts the loading/saving of objects to and from JSON files, allowing any descendant class to
    be persisted with minimal boilerplate.
    The unit also introduces a “chainable” mechanism that enables dynamic and fluent runtime modification
    of any object’s public properties by property path.

  Technical details:
    - TJSONResource: Base class for any object that should support JSON persistence. It provides methods
      for saving (`Save`) and loading (`Load`) objects directly from/to JSON files, with
      intelligent default filename detection.
    - TJSONChain: Record that enables fluent property mutation via RTTI ("chainable set"), making it
      easy to modify properties dynamically at runtime, including nested and array types.
    - TJSONResourceHelper: Class helper that attaches `Chain` behavior seamlessly to any
      TJSONResource descendant.
    - All loading/writing leverages REST.Json for conversion, and System.Rtti for dynamic property
      setting, supporting camel case and both fields and public properties.
    - Throws explicit exceptions for invalid or corrupt JSON files to prevent silent data loss.

  Dependencies:
    - REST.Json, REST.Json.Types: For Delphi’s official object/JSON marshalling.
    - System.Rtti: To apply dynamic property changes and deep property paths at runtime.
    - System.JSON: Core Delphi JSON object support.
    - System.IOUtils, System.SysUtils: For file and string operations.

  Getting started:
    - Inherit from TJSONResource to make any class persistable as JSON.
    - Use the `Load` and `Save` class/methods to deserialize or serialize the object state.
    - Use `.Chain.Apply('PropertyPath', Value)` for runtime dynamic property changes on any
      TJSONResource instance, enabling fluent updates and reducing setter boilerplate.
    - DefaultFileName gives each class its own default JSON file name based on class name.

  This unit streamlines, unifies, and secures JSON object persistence for Delphi business objects,
  making it rapid and reliable to store, modify, or restore object graphs in modern cross-platform
  applications.

*)

interface

uses
  System.SysUtils, System.IOUtils, System.JSON, System.Rtti, REST.Json;

type
  TFactory<T> = reference to function: T;
  TJSONResourceClass = class of TJSONResource;

  TJSONResource = class
  public
    constructor Create; virtual;
    class function DefaultFileName: string; virtual;
    class function Load(const FileName: string = ''): TJSONResource; virtual;
    procedure Save(const FileName: string = '');
  end;

  TJSONChain = record
  private
    FInstance: TJSONResource;
    procedure SetPropByPath(const APropPath: string; const AValue: TValue);
  public
    class function FromInstance(AInstance: TJSONResource): TJSONChain; static;
    function Apply(const APropPath: string; const AValue: TValue): TJSONChain; overload;
    function Apply<T>(const APropPath: string; const AValue: T): TJSONChain; overload;
    function Apply<T>(const APropPath: string; const AValue: array of T): TJSONChain; overload;
    function Apply<T>(const APropPath: string; const AValue: array of TFactory<T>): TJSONChain; overload;
    function Save(const AFileName: string = ''): TJSONChain;
    property Instance: TJSONResource read FInstance;
  end;

  TJSONResourceHelper = class helper for TJSONResource
  public
    function Chain: TJSONChain;
  end;

implementation

{ TJSONResource }

constructor TJSONResource.Create;
begin
  inherited Create;

end;

class function TJSONResource.DefaultFileName: string;
begin
  {--- Take the name of the class without its T prefix }
  Result := ClassName.Substring(1) + '.json';
end;

class function TJSONResource.Load(const FileName: string): TJSONResource;
var
  LFileName: string;
  Raw: string;
  LJSONObject: TJSONObject;
begin
  LFileName := FileName;
  if LFileName = EmptyStr then
    LFileName := DefaultFileName;

  if not TFile.Exists(LFileName) then
    {--- if no file then returns a blank instance }
    Exit(TJSONResourceClass(Self).Create);

  Raw := TFile.ReadAllText(LFileName, TEncoding.UTF8);

  {--- Parse into TJSONObject }
  LJSONObject := TJSONObject.ParseJSONValue(Raw) as TJSONObject;
  if LJSONObject = nil then
    raise Exception.CreateFmt('Invalid JSON in %s', [LFileName]);

  try
    {--- Creates the instance of the correct type (Self = calling metaclass) }
    Result := TJSONResourceClass(Self).Create;

    {--- and finally, let RTTI fill in Result }
    TJson.JsonToObject(Result, LJSONObject,
      {--- Maybe open to more properties }
      [joSerialFields, joSerialPublicProps, joIndentCaseCamel]);

  finally
    LJSONObject.Free;
  end;
end;

procedure TJSONResource.Save(const FileName: string);
var
  LFileName: string;
  JsonValue: TJSONValue;
  Formatted: string;
begin
  LFileName := FileName;
  if LFileName = EmptyStr then
    LFileName := DefaultFileName;

  JsonValue := TJson.ObjectToJsonObject(Self,
    [joSerialFields, joSerialPublicProps, joIndentCaseCamel]);
  try
    {--- Pretty formated }
    Formatted := JsonValue.Format(2);
    TFile.WriteAllText(LFileName, Formatted, TEncoding.UTF8);
  finally
    JsonValue.Free;
  end;
end;

{ TJSONChain }

{$REGION 'TJSONChain'}

function TJSONChain.Apply<T>(const APropPath: string;
  const AValue: array of T): TJSONChain;
var
  Data: TArray<T>;
begin
  SetLength(Data, Length(AValue));
  for var i := 0 to High(AValue) do
    Data[i] := AValue[i];
  Result := Apply(APropPath, TValue.From<TArray<T>>(Data));
end;

function TJSONChain.Apply<T>(const APropPath: string;
  const AValue: array of TFactory<T>): TJSONChain;
var
  Data: TArray<T>;
begin
  SetLength(Data, Length(AValue));
  for var i := 0 to High(AValue) do
    Data[i] := AValue[i]();
  Result := Apply(APropPath, TValue.From<TArray<T>>(Data));
end;

function TJSONChain.Apply<T>(const APropPath: string;
  const AValue: T): TJSONChain;
begin
  Result := Apply(APropPath, TValue.From<T>(AValue));
end;

function TJSONChain.Apply(const APropPath: string; const AValue: TValue): TJSONChain;
begin
  Result := Self;
  SetPropByPath(APropPath, AValue);
end;

class function TJSONChain.FromInstance(AInstance: TJSONResource): TJSONChain;
begin
  Result.FInstance := AInstance;
end;

function TJSONChain.Save(const AFileName: string): TJSONChain;
begin
  FInstance.Save(AFileName);
  Result := Self;
end;

procedure TJSONChain.SetPropByPath(const APropPath: string; const AValue: TValue);
var
  Ctx: TRttiContext;
  RTTIType: TRttiType;
  Prop: TRttiProperty;
  Parts: TArray<string>;
  CurrentObj: TObject;
  Last: Integer;
begin
  Parts := APropPath.Split(['.']);
  Last := High(Parts);
  CurrentObj := FInstance;

  {--- Go down to the penultimate part }
  for var i := 0 to Last - 1 do
  begin
    RTTIType := Ctx.GetType(CurrentObj.ClassType);
    Prop := RTTIType.GetProperty(Parts[i]);
    if not Assigned(Prop) then
      raise Exception.CreateFmt('Property "%s" not found on %s',
        [Parts[i], CurrentObj.ClassName]);
    CurrentObj := Prop.GetValue(CurrentObj).AsObject;
    if CurrentObj = nil then
      raise Exception.CreateFmt('The sub-property "%s" is NIL', [Parts[i]]);
  end;

  {--- Affect the last part }
  RTTIType := Ctx.GetType(CurrentObj.ClassType);
  Prop := RTTIType.GetProperty(Parts[Last]);
  if not Assigned(Prop) then
    raise Exception.CreateFmt('Property "%s" not found on %s',
      [Parts[Last], CurrentObj.ClassName]);
  Prop.SetValue(CurrentObj, AValue);
end;

{$ENDREGION}

{$REGION 'TJSONResourceHelper'}

function TJSONResourceHelper.Chain: TJSONChain;
begin
  {--- Returns a TJSONChain “attached” to Self }
  Result := TJSONChain.FromInstance(Self);
end;

{$ENDREGION}

end.

unit Manager.Async.Promise;

(*******************************************************************************

      Unit providing a generic implementation of Promises for handling
      asynchronous operations in Delphi.

      The ASync.Promise unit enables structured handling of asynchronous
      tasks using Promises, allowing for a clean and readable
      asynchronous programming model similar to JavaScript Promises.

      Primary components include:

        - TPromise<T>: A generic class representing a promise that can be
          resolved or rejected asynchronously.
        - TPromiseState: An enumeration indicating the state of a promise
          (Pending, Fulfilled, or Rejected).
        - TPromiseRegistry: An internal registry that tracks all pending
          promises to prevent premature destruction.
        - Chained methods for structured handling:
          - &Then<T>: Chains operations to execute after a promise resolves.
          - &Catch: Handles errors occurring within a promise chain.

      These abstractions allow a structured and reusable way to manage
      asynchronous execution without deeply nested callbacks, facilitating
      a cleaner approach to asynchronous programming in Delphi.

  Example Usage:

  ```delphi
  procedure ExampleAsyncProcess;
  begin
    var Promise := TPromise<string>.Create(
      procedure(Resolve: TProc<string>; Reject: TProc<Exception>)
      begin
        TTask.Run(
        procedure()
        begin
          TThread.Queue(nil,
            procedure
            begin
              Sleep(2000); // Simulating asynchronous work
              if Random(2) = 0 then
                Resolve('Operation Successful')
              else
                Reject(Exception.Create('Operation Failed'));
            end)
        end)
      end);

    Promise
      .&Then(
        procedure(Value: string)
        begin
          ShowMessage('Success: ' + Value);
        end)
      .&Catch(
        procedure(E: Exception)
        begin
          ShowMessage('Error: ' + E.Message);
        end);
  end;
  ```

      The unit is designed to work seamlessly with other asynchronous
      programming modules, making it a powerful addition to any Delphi
      application requiring structured async execution.

*******************************************************************************)

interface

uses
  System.SysUtils, System.Generics.Collections, System.Classes, System.Threading;

type
  /// <summary>
  /// Represents the state of a Promise.
  /// </summary>
  TPromiseState = (
    /// <summary>
    /// The promise is pending and has not yet been resolved or rejected.
    /// </summary>
    psPending,
    /// <summary>
    /// The promise has been fulfilled with a value.
    /// </summary>
    psFulfilled,
    /// <summary>
    /// The promise has been rejected due to an error.
    /// </summary>
    psRejected
  );

  /// <summary>
  /// Abstract base class for promise implementations.
  /// </summary>
  /// <remarks>
  /// Provides a common interface for retrieving the current state
  /// of a promise. All concrete promise types must implement
  /// <see cref="GetState"/> to indicate whether they are pending,
  /// fulfilled, or rejected.
  /// </remarks>
  TPromiseBase = class abstract
  strict protected
    /// <summary>
    /// Returns the current state of the promise.
    /// </summary>
    /// <returns>
    /// A <see cref="TPromiseState"/> value indicating whether the
    /// promise is pending, fulfilled, or rejected.
    /// </returns>
    function GetState: TPromiseState; virtual; abstract;
  public
    /// <summary>
    /// Read-only property exposing the promise’s current state.
    /// </summary>
    /// <value>
    /// The <see cref="TPromiseState"/> of the promise.
    /// </value>
    property State: TPromiseState read GetState;
  end;

  /// <summary>
  /// A generic class that represents an asynchronous operation that may complete in the future.
  /// </summary>
  /// <typeparam name="T">The type of the value that the promise resolves with.</typeparam>
  TPromise<T> = class(TPromiseBase)
  public
    type
      /// <summary>
      /// Defines the executor procedure for a promise, providing callbacks
      /// to signal fulfillment or rejection of the asynchronous operation.
      /// </summary>
      /// <param name="Resolve">
      /// A callback that accepts a value of type T and transitions the promise
      /// into the fulfilled state with that value.
      /// </param>
      /// <param name="Reject">
      /// A callback that accepts an Exception and transitions the promise
      /// into the rejected state with that error.
      /// </param>
      TExecutor = reference to procedure(Resolve: TProc<T>; Reject: TProc<Exception>);
  private
    FState: TPromiseState;
    FValue: T;
    FError: Exception;
    FThenHandlers: TList<TProc<T>>;
    FCatchHandlers: TList<TProc<Exception>>;
    FHandlerLock: TObject;

    class function CloneException(E: Exception): Exception; static;

    /// <summary>
    /// Resolves the promise with a given value.
    /// </summary>
    /// <param name="AValue">The value to resolve the promise with.</param>
    procedure Resolve(const AValue: T);

    /// <summary>
    /// Rejects the promise with a given error.
    /// </summary>
    /// <param name="AError">The exception that caused the rejection.</param>
    procedure Reject(AError: Exception);

  strict protected
    /// <summary>
    /// Returns the current state of the promise.
    /// </summary>
    /// <returns>
    /// A <see cref="TPromiseState"/> value indicating whether the
    /// promise is pending, fulfilled, or rejected.
    /// </returns>
    function GetState: TPromiseState; override;

  public
    /// <summary>
    /// Initializes a new instance of the <see cref="TPromise{T}"/> class and starts the asynchronous operation.
    /// </summary>
    /// <param name="AExecutor">The executor function that starts the asynchronous task.</param>
    constructor Create(AExecutor: TExecutor);

    /// <summary>
    /// Destroys the promise instance and releases any associated resources.
    /// </summary>
    destructor Destroy; override;

    /// <summary>
    /// Attaches a fulfillment callback that is executed when the promise is resolved.
    /// </summary>
    /// <param name="AOnFulfill">A callback function executed upon fulfillment.</param>
    /// <returns>A new promise to allow method chaining.</returns>
    function &Then(AOnFulfill: TProc): TPromise<T>; overload;

    /// <summary>
    /// Attaches a fulfillment callback that receives the resolved value.
    /// </summary>
    /// <param name="AOnFulfill">A callback function that receives the resolved value.</param>
    /// <returns>A new promise to allow method chaining.</returns>
    function &Then(AOnFulfill: TProc<T>): TPromise<T>; overload;

    /// <summary>
    /// Attaches a fulfillment callback that returns a transformed value of a different type.
    /// </summary>
    /// <typeparam name="TResult">The type of the transformed result.</typeparam>
    /// <param name="AOnFulfill">A function that produces the transformed result.</param>
    /// <returns>A new promise that resolves with the transformed value.</returns>
    function &Then<TResult>(AOnFulfill: TFunc<TResult>): TPromise<TResult>; overload;

    /// <summary>
    /// Attaches a fulfillment callback that returns another promise of a different type.
    /// </summary>
    /// <typeparam name="TResult">The type of the new promise’s result.</typeparam>
    /// <param name="AOnFulfill">A function that returns a new promise.</param>
    /// <returns>A new promise that resolves with the value of the returned promise.</returns>
    function &Then<TResult>(AOnFulfill: TFunc<T, TPromise<TResult>>): TPromise<TResult>; overload;

    /// <summary>
    /// Attaches a fulfillment callback that returns another promise of the same type.
    /// </summary>
    /// <param name="AOnFulfill">A function that returns a new promise of the same type.</param>
    /// <returns>A new promise that resolves with the value of the returned promise.</returns>
    function &Then(AOnFulfill: TFunc<T, TPromise<T>>): TPromise<T>; overload;

    /// <summary>
    /// Attaches a fulfillment callback that transforms the resolved value into another type.
    /// </summary>
    /// <typeparam name="TResult">The type of the transformed value.</typeparam>
    /// <param name="AOnFulfill">A function that transforms the resolved value.</param>
    /// <returns>A new promise that resolves with the transformed value.</returns>
    function &Then<TResult>(AOnFulfill: TFunc<T, TResult>): TPromise<TResult>; overload;

    /// <summary>
    /// Attaches a rejection callback to handle errors if the promise is rejected.
    /// </summary>
    /// <param name="AOnReject">A callback function that handles the error.</param>
    /// <returns>A new promise to allow method chaining.</returns>
    function &Catch(AOnReject: TProc<Exception>): TPromise<T>;

    class function Resolved(const AValue: T; Proc: TProc = nil): TPromise<T>;

    class function Rejected(AError: Exception; Proc: TProc = nil): TPromise<T>;

  end;

  /// <summary>
  /// Maintains a global registry of all pending promises, ensuring they
  /// are kept alive until they are fulfilled or rejected.
  /// </summary>
  /// <remarks>
  /// This sealed class provides thread-safe methods to add and remove
  /// promises from the registry, as well as a manual cleanup routine
  /// to prune completed promises.  It is used internally by
  /// <see cref="TPromise{T}"/> to prevent premature destruction of
  /// promises that are still pending.
  /// </remarks>
  TPromiseRegistry = class sealed
  strict private
    class var FList : TObjectList<TObject>;
    class var FLock : TObject;
  public
    /// <summary>
    /// Initializes the promise registry and its internal lock.
    /// </summary>
    class constructor Create;

    /// <summary>
    /// Releases all resources held by the promise registry.
    /// </summary>
    class destructor  Destroy;

    /// <summary>
    /// Adds a promise instance to the registry, preventing it
    /// from being freed until it transitions out of the pending state.
    /// </summary>
    /// <param name="APromise">
    /// The promise instance to register.
    /// </param>
    class procedure Add(APromise: TObject);

    /// <summary>
    /// Removes a promise instance from the registry, allowing it
    /// to be freed if it is no longer referenced elsewhere.
    /// </summary>
    /// <param name="APromise">
    /// The promise instance to unregister.
    /// </param>
    class procedure Remove(APromise: TObject);

    /// <summary>
    /// Scans the registry and deletes any promises that are no longer
    /// pending (i.e., fulfilled or rejected), releasing their memory.
    /// </summary>
    /// <remarks>
    /// This method can be called manually if you need to force
    /// cleanup of completed promises before their <see cref="TPromise{T}"/>
    /// callbacks are all delivered.
    /// </remarks>
    class procedure Cleanup;

    /// <summary>
    /// Removes and frees all promises in the registry, regardless of their state.
    /// </summary>
    /// <remarks>
    /// Acquires the internal lock to ensure thread safety, then iterates through
    /// the list of registered promises and deletes each one.  This will release
    /// both pending and completed promises from memory.  Use with caution, as
    /// any still-pending promises will be destroyed immediately.
    /// </remarks>
    class procedure Clear;
  end;

implementation

{ TPromise<T> }

class function TPromise<T>.CloneException(E: Exception): Exception;
var
  ExClass: ExceptClass ;
begin
  ExClass := ExceptClass(E.ClassType);
  Result := ExClass.Create(E.Message);
end;

constructor TPromise<T>.Create(AExecutor: TExecutor);
begin
  inherited Create;
  FHandlerLock := TObject.Create;
  FState := psPending;
  TPromiseRegistry.Add(Self);
  FThenHandlers := TList<TProc<T>>.Create;
  FCatchHandlers := TList<TProc<Exception>>.Create;
  try
    {--- The executor function that starts the asynchronous task. }
    AExecutor(
      procedure(AValue: T)
      begin
        Self.Resolve(AValue);
      end,

      {--- OnReject — clone then free the original }
      procedure(E: Exception)
      begin
        var Cloned := CloneException(E);
        {--- releases the original exception }
        E.Free;
        Self.Reject(Cloned);
      end
    );
  except
    on E: Exception do
    begin
      var Cloned := CloneException(E);
      {--- E.Free; Do not release E here because Delphi takes care of it }
      Reject(Cloned);
    end;
  end;
end;

destructor TPromise<T>.Destroy;
begin
  if Assigned(FError) then
    FError.Free;
  FThenHandlers.Free;
  FCatchHandlers.Free;
  FHandlerLock.Free;
  inherited;
end;

function TPromise<T>.GetState: TPromiseState;
begin
  Result := FState;
end;

class function TPromise<T>.Rejected(AError: Exception; Proc: TProc): TPromise<T>;
begin
  Result := TPromise<T>.Create(
    procedure(Resolve: TProc<T>; Reject: TProc<Exception>)
    begin
      TTask.Run(
        procedure()
        begin
          TThread.Queue(nil,
            procedure
            begin
              if Assigned(Proc) then
                Proc();
              Reject(AError);
            end)
        end)
    end);
end;

procedure TPromise<T>.Resolve(const AValue: T);
var
  Handlers: TArray<TProc<T>>;
  Handler: TProc<T>;
begin
  if FState <> psPending then
    Exit;

  FState := psFulfilled;
  FValue := AValue;

  {--- Copy the locked callback list }
  TMonitor.Enter(FHandlerLock);
  try
    Handlers := FThenHandlers.ToArray;
  finally
    TMonitor.Exit(FHandlerLock);
  end;

  {--- Asynchronously call all “then” callbacks }
  for Handler in Handlers do
    TThread.Queue(nil,
      procedure
      begin
        Handler(FValue);
      end);

  {--- Empty locked lists }
  TMonitor.Enter(FHandlerLock);
  try
    FThenHandlers.Clear;
    FCatchHandlers.Clear;
  finally
    TMonitor.Exit(FHandlerLock);
  end;

  {--- Safe destruction because we are out of the register }
  TPromiseRegistry.Remove(Self);
end;

class function TPromise<T>.Resolved(const AValue: T; Proc: TProc): TPromise<T>;
begin
  Result := TPromise<T>.Create(
    procedure(Resolve: TProc<T>; Reject: TProc<Exception>)
    begin
      TTask.Run(
        procedure()
        begin
          TThread.Queue(nil,
            procedure
            begin
              if Assigned(Proc) then
                Proc();
              Resolve(AValue);
            end)
        end)
    end);
end;

procedure TPromise<T>.Reject(AError: Exception);
var
  Handlers: TArray<TProc<Exception>>;
  Handler: TProc<Exception>;
begin
  if FState <> psPending then
    begin
      AError.Free;
      Exit;
    end;

  FState := psRejected;
  FError := AError;

  {--- Copy the locked callback list }
  TMonitor.Enter(FHandlerLock);
  try
    Handlers := FCatchHandlers.ToArray;
  finally
    TMonitor.Exit(FHandlerLock);
  end;

  {--- Call all “catch” callbacks }
  for Handler in Handlers do
    TThread.Queue(nil,
      procedure
      begin
        Handler(FError);
      end);

  {--- Empty locked lists }
  TMonitor.Enter(FHandlerLock);
  try
    FThenHandlers.Clear;
    FCatchHandlers.Clear;
  finally
    TMonitor.Exit(FHandlerLock);
  end;

  {--- Safe destruction because we are out of the register }
  TPromiseRegistry.Remove(Self);
end;

function TPromise<T>.&Then(AOnFulfill: TProc<T>): TPromise<T>;
begin
  {--- Version without transformation: we wrap the procedure in a function which returns the unchanged value }
  Result := &Then<T>(
    function(Value: T): T
    begin
      AOnFulfill(Value);
      Result := Value;
    end);
end;

function TPromise<T>.&Then<TResult>(AOnFulfill: TFunc<T, TResult>): TPromise<TResult>;
begin
  {--- Creation of a new promise that will be resolved when this one is resolved }
  Result := TPromise<TResult>.Create(
    procedure(Resolve: TProc<TResult>; Reject: TProc<Exception>)
    begin
      if FState = psFulfilled then
        begin
          try
            Resolve(AOnFulfill(FValue));
          except
            on E: Exception do
              Reject(CloneException(E));
          end;
        end
      else
      if FState = psRejected then
        begin
          Reject(CloneException(FError))
        end
      else
        begin
          {--- If the operation is not yet complete, we add callbacks for chaining }
          TMonitor.Enter(FHandlerLock);
          try
            FThenHandlers.Add(
              procedure(Value: T)
              begin
                try
                  Resolve(AOnFulfill(Value));
                except
                  on E: Exception do
                    Reject(CloneException(E));
                end;
              end);
            FCatchHandlers.Add(
              procedure(E: Exception)
              begin
                Reject(CloneException(E));
              end);
          finally
            TMonitor.Exit(FHandlerLock);
          end;
        end;
    end);
end;

function TPromise<T>.&Then(AOnFulfill: TFunc<T, TPromise<T>>): TPromise<T>;
begin
  Result := TPromise<T>.Create(
    procedure(Resolve: TProc<T>; Reject: TProc<Exception>)
    begin
      if FState = psFulfilled then
        begin
          try
            AOnFulfill(FValue)
              .&Then(
                procedure(NewValue: T)
                begin
                  Resolve(NewValue);
                end)
              .&Catch(
                procedure(E: Exception)
                begin
                  Reject(CloneException(E));
                end);
          except
            on E: Exception do
              Reject(CloneException(E));
          end;
        end
      else
      if FState = psRejected then
        begin
          Reject(CloneException(FError))
        end
      else
        begin
          TMonitor.Enter(FHandlerLock);
          try
            FThenHandlers.Add(
              procedure(Value: T)
              begin
                try
                  AOnFulfill(Value)
                    .&Then(
                      procedure(NewValue: T)
                      begin
                        Resolve(NewValue);
                      end)
                    .&Catch(
                    procedure(E: Exception)
                    begin
                      Reject(CloneException(E));
                    end);
                except
                  on E: Exception do
                    Reject(CloneException(E));
                end;
              end);
            FCatchHandlers.Add(
              procedure(E: Exception)
              begin
                Reject(CloneException(E));
              end);
          finally
            TMonitor.Exit(FHandlerLock);
          end;
        end;
    end);
end;

function TPromise<T>.&Then<TResult>(
  AOnFulfill: TFunc<TResult>): TPromise<TResult>;
begin
  Result := TPromise<TResult>.Create(
    procedure(Resolve: TProc<TResult>; Reject: TProc<Exception>)
    begin
      if FState = psFulfilled then
        begin
          try
            {--- Call the action without parameters and resolve with the result }
            Resolve(AOnFulfill());
          except
            on E: Exception do
              Reject(CloneException(E));
          end;
        end
    else
    if FState = psRejected then
      begin
        Reject(CloneException(FError));
      end
    else
      begin
        {--- If the promise is pending, we add callbacks }
        TMonitor.Enter(FHandlerLock);
        try
          FThenHandlers.Add(
            procedure(Value: T)
            begin
              try
                Resolve(AOnFulfill());
              except
                on E: Exception do
                  Reject(CloneException(E));
              end;
            end);
          FCatchHandlers.Add(
            procedure(E: Exception)
            begin
              Reject(CloneException(E));
            end);
        finally
          TMonitor.Exit(FHandlerLock);
        end;
      end;
    end);
end;

function TPromise<T>.&Then<TResult>(
  AOnFulfill: TFunc<T, TPromise<TResult>>): TPromise<TResult>;
begin
  Result := TPromise<TResult>.Create(
    procedure(Resolve: TProc<TResult>; Reject: TProc<Exception>)
    begin
      if FState = psFulfilled then
        begin
          try
            AOnFulfill(FValue)
              .&Then(
                procedure(NewValue: TResult)
                begin
                  Resolve(NewValue);
                end)
              .&Catch(
                procedure(E: Exception)
                begin
                  Reject(CloneException(E));
                end);
          except
            on E: Exception do
              Reject(CloneException(E));
          end;
        end
      else
      if FState = psRejected then
        begin
          Reject(CloneException(FError));
        end
      else
        begin
          TMonitor.Enter(FHandlerLock);
          try
            FThenHandlers.Add(
              procedure(Value: T)
              begin
                try
                  AOnFulfill(Value)
                    .&Then(
                      procedure(NewValue: TResult)
                      begin
                        Resolve(NewValue);
                      end)
                    .&Catch(
                      procedure(E: Exception)
                      begin
                        Reject(CloneException(E));
                      end);
                except
                  on E: Exception do
                    Reject(CloneException(E));
                end;
              end);
            FCatchHandlers.Add(
              procedure(E: Exception)
              begin
                Reject(CloneException(E));
              end);
          finally
            TMonitor.Exit(FHandlerLock);
          end;
        end;
    end);
end;

function TPromise<T>.&Then(AOnFulfill: TProc): TPromise<T>;
begin
  Result := TPromise<T>.Create(
    procedure(Resolve: TProc<T>; Reject: TProc<Exception>)
    begin
      if FState = psFulfilled then
        begin
          try
            {--- Calling the action without parameters }
            AOnFulfill();
            {--- Pass the initial value after the action is executed }
            Resolve(FValue);
          except
            on E: Exception do
              Reject(CloneException(E));
          end;
        end
      else
      if FState = psRejected then
        begin
          Reject(CloneException(FError))
        end
      else
        begin
          {--- If the operation is not yet completed, add callbacks for chaining }
          TMonitor.Enter(FHandlerLock);
          try
            FThenHandlers.Add(
              procedure(Value: T)
              begin
                try
                  AOnFulfill();
                  Resolve(Value);
                except
                  on E: Exception do
                    Reject(CloneException(E));
                end;
              end);
            FCatchHandlers.Add(
              procedure(E: Exception)
              begin
                Reject(CloneException(E));
              end);
          finally
            TMonitor.Exit(FHandlerLock);
          end;
        end;
    end);
end;

function TPromise<T>.&Catch(AOnReject: TProc<Exception>): TPromise<T>;
begin
  {--- Create a new promise that passes the value or handles the error with AOnReject }
  Result := TPromise<T>.Create(
    procedure(Resolve: TProc<T>; Reject: TProc<Exception>)
    begin
      if FState = psFulfilled then
        begin
          Resolve(FValue);
        end
      else
      if FState = psRejected then
        begin
          AOnReject(FError);
          Reject(CloneException(FError));
        end
      else
        begin
          TMonitor.Enter(FHandlerLock);
          try
            FThenHandlers.Add(
              procedure(Value: T)
              begin
                Resolve(Value);
              end);
            FCatchHandlers.Add(
              procedure(E: Exception)
              begin
                AOnReject(E);
                Reject(CloneException(E));
              end);
          finally
            TMonitor.Exit(FHandlerLock);
          end;
        end;
    end);
end;

{ TPromiseRegistry }

class procedure TPromiseRegistry.Add(APromise: TObject);
begin
  TMonitor.Enter(FLock);
  try
    FList.Add(APromise);
  finally
    TMonitor.Exit(FLock);
  end;
end;

class procedure TPromiseRegistry.Cleanup;
begin
  TMonitor.Enter(FLock);
  try
    for var I := FList.Count - 1 downto 0 do
      {--- Remove the promise from the list as soon as it moves to the final state. }
      if TObject(FList[I]) is TPromiseBase then
        with TPromiseBase(FList[I]) do
          if State <> psPending then
            {--- releases the object }
            FList.Delete(I);
  finally
    TMonitor.Exit(FLock);
  end;
end;

class procedure TPromiseRegistry.Clear;
begin
  TMonitor.Enter(FLock);
  try
    for var I := FList.Count - 1 downto 0 do
      {--- Remove the promise from the list as soon as it moves to the final state. }
      if TObject(FList[I]) is TPromiseBase then
        with TPromiseBase(FList[I]) do
            {--- releases the object }
            FList.Delete(I);
  finally
    TMonitor.Exit(FLock);
  end;
end;

class constructor TPromiseRegistry.Create;
begin
  {--- simple critical section }
  FLock := TObject.Create;

  {--- OwnsObjects = True }
  FList := TObjectList<TObject>.Create(True);
end;

class destructor TPromiseRegistry.Destroy;
begin
  FList.Free;
  FLock.Free;
end;

class procedure TPromiseRegistry.Remove(APromise: TObject);
begin
  TMonitor.Enter(FLock);
  try
    {--- releases the object }
    var Index := FList.IndexOf(APromise);
    if Index >= 0 then
      FList.Delete(Index);
  finally
    TMonitor.Exit(FLock);
  end;
end;

initialization
finalization
  {--- Delete pending promises }
  TPromiseRegistry.Clear;
end.

unit Manager.FileUploadID.Controler;

(*
  Unit: Manager.FileUploadID.Controler

  Purpose:
    Acts as the central manager for all file-to-FileUploadId mappings in the File2knowledgeAI application, coordinating
    UI actions and business logic with persistent vector resource data and server APIs.

  Key roles and responsibilities:
    - Orchestrates the life cycle of file attachments: adding, deleting, and validating synchronization between
      UI state, client-side drafts, and OpenAI-managed vector stores.
    - Maintains reliable “snapshot” and “draft” dictionaries, enabling transactional updates, rollback, and consistency checks.
    - Provides a single point of coordination between the UI.VectorResourceEditor.VCL and lower-level helper
      units for file and dictionary operations.

  Project context:
    - Designed for integration with Helper.FileUploadID.Dictionary and the main vector resource editor UI, ensuring
      maintainability and transparency during prototyping and demos.
    - Clearly documented and organized to support direct onboarding of developers at any level, with clear upgrade paths for
      scaling to more advanced enterprise needs (transaction management, async operations, etc.).
    - Easily extendable for further functionalities such as multi-user synchronization, batch operations, or enhanced
      error handling.
*)


interface

uses
  System.SysUtils, System.Generics.Collections, Model.VectorResource, Helper.FileUploadID.Dictionary,
  Manager.Intf;

type
  /// <summary>
  /// Central controller for managing associations between file names and FileUploadIds
  /// within the File2knowledgeAI project.
  /// </summary>
  /// <remarks>
  /// This class coordinates file attachment management and state transitions, enabling
  /// the UI to add, remove, and validate files associated with vector resources.
  /// It maintains separate “snapshot” and “draft” dictionaries for transactional safety,
  /// integrates with helper units for dictionary operations, and ensures consistency
  /// between client- and server-side data.
  /// <para>
  /// * Intended for use with Helper.FileUploadID.Dictionary and UI.VectorResourceEditor.VCL.
  /// </para>
  /// </remarks>
  TFileUploadIdController = class(TInterfacedObject, IFileUploadIdController)
  private
    FSnapShot: TDictionary<string, string>;
    FDraft: TDictionary<string, string>;
  public
    constructor Create;
    destructor Destroy; override;
    /// <summary>
    /// Initializes both the snapshot and draft dictionaries with current file names and associated FileUploadIds.
    /// </summary>
    /// <remarks>
    /// Should be called whenever there is a need to synchronize the controller's state with
    /// the persistent data store or to reset after external changes.
    /// </remarks>
    procedure InitDictionaries;

    /// <summary>
    /// Persists the changes made to file and FileUploadId mappings by comparing the snapshot and draft dictionaries.
    /// </summary>
    /// <remarks>
    /// This method applies additions and deletions, and updates the persistent vector resource data accordingly.
    /// May also trigger removal of files from OpenAI vector stores as appropriate.
    /// </remarks>
    procedure SaveChanges;

    /// <summary>
    /// Adds a new file to the draft dictionary, associating it with an (optional) FileUploadId.
    /// </summary>
    /// <param name="FileName">The name of the file to add.</param>
    /// <param name="Proc">A callback procedure to execute after addition (can be <c>nil</c>).</param>
    procedure AddFile(const FileName: string; Proc: TProc);

    /// <summary>
    /// Removes a file from the draft dictionary.
    /// </summary>
    /// <param name="FileName">The name of the file to remove.</param>
    /// <param name="Proc">A callback procedure to execute after removal (can be <c>nil</c>).</param>
    procedure DeleteFile(const FileName: string; Proc: TProc);

    /// <summary>
    /// Gets the number of files currently in the draft dictionary.
    /// </summary>
    /// <returns>The count of files being tracked in the draft state.</returns>
    function DraftCount: Integer;
  end;

implementation

{ TFileUploadIdController }

procedure TFileUploadIdController.AddFile(const FileName: string;
  Proc: TProc);
begin
  FDraft := TFileUploadIdDictionary
    .Create(FDraft)
    .AddOrSetValue(FileName, EmptyStr, Proc)
    .Dictionary;
end;

constructor TFileUploadIdController.Create;
begin
  inherited Create;
  FSnapShot := TDictionary<string, string>.Create;
  FDraft := TDictionary<string, string>.Create;
end;

procedure TFileUploadIdController.DeleteFile(const FileName: string;
  Proc: TProc);
begin
  FDraft := TFileUploadIdDictionary
    .Create(FDraft)
    .Remove(FileName, Proc)
    .Dictionary;
end;

destructor TFileUploadIdController.Destroy;
begin
  FSnapShot.Free;
  FDraft.Free;
  inherited;
end;

function TFileUploadIdController.DraftCount: Integer;
begin
  Result := FDraft.Count;
end;

procedure TFileUploadIdController.InitDictionaries;
begin
  FSnapShot := TFileUploadIdDictionary
    .Create(FSnapShot)
    .Initialize(FileStoreManager.Files, FileStoreManager.FileUploadIds)
    .Dictionary;

  FDraft := TFileUploadIdDictionary
    .Create(FDraft)
    .Initialize(FileStoreManager.Files, FileStoreManager.FileUploadIds)
    .Dictionary;
end;

procedure TFileUploadIdController.SaveChanges;
begin
  var Resources := TVectorResourceList(FileStoreManager.Resources);
  var ItemIndex := FileStoreManager.ItemIndex;
  FDraft := TDictionaryContentComparison
    .Create(FSnapShot, FDraft)
    .Apply(
      procedure (FileName: string; FileUploadId: string)
      begin
        if not FileUploadId.IsEmpty then
        begin
          OpenAI.DeleteVectorStoreFile(Resources.Data[ItemIndex].VectorStoreId, FileUploadId);
          OpenAI.DeleteFile(FileUploadId);
        end;
      end)
    .DraftValidated;

  Resources.Data[ItemIndex].Files := FDraft.Keys.ToArray;
  Resources.Data[ItemIndex].FileUploadId := FDraft.Values.ToArray;
end;

end.


unit Manager.Intf;

(*
  Unit: Manager.Intf

  Purpose:
    Defines the set of core interfaces for orchestration, presentation, and management of interactions
    within the File2knowledgeAI architecture. This unit centralizes the contracts for persistence,
    display, prompt management, and advanced handling of resources associated with the
    OpenAI v1/responses endpoint.

  Architecture and Design:
    - Groups interfaces governing prompt editing, conversational display (chat UI, reasoning),
      asynchronous operation management, file and vector handling via OpenAI, as well as
      persistence and navigation of conversation history.
    - Applies OpenAI/GenAI best practices regarding traceability, UI/business logic decoupling,
      reactive programming patterns (Promises), and modularity for scalable robustness.
    - Centralizes domain contracts essential for conversation chaining,
      state tracking (via ResponseId tracking), and comprehensive resource lifecycle control,
      ensuring tight orchestration around the v1/responses workflow.

  Usage:
    - Implement these interfaces to inject services and controllers into the main application (IoC/DI).
    - Enables agile asynchronous flows (prompts, reasoning, file management),
      aligned with the robustness and maintainability requirements of modern GenAI solutions.

  Context:
    This unit is at the core of File2knowledgeAI, ensuring compliance with best practices
    for prompt chaining, advanced vector resource management, and integration
    with the OpenAI v1/responses endpoint. Essential for building traceable,
    persistent, and easily testable conversational applications.

  Conventions follow the File2knowledgeAI project and OpenAI v1/responses standards.
*)

interface

uses
  System.SysUtils, System.Classes, Manager.Async.Promise, Manager.Types, ChatSession.Controller;

type
  /// <summary>
  /// Defines a contract for presenting user alerts and dialogs in applications.
  /// </summary>
  /// <remarks>
  /// <para>
  /// The <c>IAlertService</c> interface standardizes the core methods required to notify users of errors,
  /// information, warnings, and to request confirmation via modal dialogs. Implementations allow for
  /// decoupling user interface alert logic from business logic, improving maintainability and testability.
  /// </para>
  /// <para>
  /// Typical usage involves calling the appropriate method to display a message or prompt. The dialog
  /// appearance and interaction specifics (e.g., button arrangement, icons) are determined by the concrete
  /// implementation of the interface.
  /// </para>
  /// </remarks>
  IAlertService = interface
    ['{C4A2BF3D-F124-4E10-B910-A038C4C74AA1}']
    /// <summary>
    /// Displays an error message dialog with an "OK" button.
    /// </summary>
    /// <param name="Msg">
    /// The error message to display.
    /// </param>
    procedure ShowError(const Msg: string);

    /// <summary>
    /// Displays an informational message dialog with an "OK" button.
    /// </summary>
    /// <param name="Msg">
    /// The informational message to display.
    /// </param>
    procedure ShowInformation(const Msg: string);

    /// <summary>
    /// Displays a warning dialog with an "OK" button.
    /// </summary>
    /// <param name="Msg">
    /// The warning message to display.
    /// </param>
    procedure ShowWarning(const Msg: string);

    /// <summary>
    /// Shows a confirmation dialog (Yes/No) and returns the user's selection.
    /// </summary>
    /// <param name="Msg">
    /// The confirmation message to display.
    /// </param>
    /// <returns>
    /// <c>mrYes</c> if the user selects Yes; <c>mrNo</c> if No is selected.
    /// </returns>
    function ShowConfirmation(const Msg: string): Integer;
  end;

  /// <summary>
  /// Defines the contract for template management and retrieval in the File2knowledgeAI architecture.
  /// </summary>
  /// <remarks>
  /// <para>
  /// The <c>ITemplateProvider</c> interface centralizes logic for loading and accessing HTML and JavaScript
  /// templates required by the <c>v1/responses</c> endpoint demo workflow. It supports both
  /// auto-reloading for agile development and one-time loading modes more suitable for production,
  /// in addition to offering full control over the directory path used for template discovery.
  /// </para>
  /// <para>
  /// Implementations of this interface should facilitate seamless switching between on-the-fly updates
  /// and in-memory caching, enabling performance optimization or rapid iteration as needed.
  /// </para>
  /// <para>
  /// Template types exposed include initial HTML rendering, JavaScript for displaying responses,
  /// user prompt input, and system reasoning logic.
  /// </para>
  /// </remarks>
  ITemplateProvider = interface
    ['{3DE4085F-1AE3-4C4D-93D3-BA7130FF5C96}']
    function GetInitialHtml: string;
    function GetDisplayTemplate: string;
    function GetReasoningTemplate: string;
    function GetPromptTemplate: string;

    /// <summary>
    /// Enables automatic reloading of template files from the specified directory on each access.
    /// This is recommended for development or rapid prototyping, as it reflects any changes to the template files immediately.
    /// </summary>
    /// <param name="APath">
    /// Optional path to the directory containing template files. If empty, uses the default template path.
    /// </param>
    procedure TemplateAllwaysReloading(const APath: string = '');

    /// <summary>
    /// Disables automatic reloading, causing all template files to be loaded only once and cached in memory.
    /// This improves performance and stability for production use, but changes to template files require an application restart.
    /// </summary>
    procedure TemplateNeverReloading;

    /// <summary>
    /// Sets the directory path where template files are located.
    /// </summary>
    /// <param name="Value">
    /// The file system path to use for loading template files.
    /// </param>
    procedure SetTemplatePath(const Value: string);

    /// <summary>
    /// Gets the HTML template used for initial page rendering.
    /// </summary>
    /// <returns>
    /// The content of the initial HTML template.
    /// </returns>
    property InitialHtml: string read GetInitialHtml;

    /// <summary>
    /// Gets the JavaScript template used to display OpenAI responses.
    /// </summary>
    /// <returns>
    /// The content of the response display JavaScript template.
    /// </returns>
    property DisplayTemplate: string read GetDisplayTemplate;

    /// <summary>
    /// Gets the JavaScript template used for system reasoning and asynchronous operations.
    /// </summary>
    /// <returns>
    /// The content of the reasoning JavaScript template.
    /// </returns>
    property ReasoningTemplate: string read GetReasoningTemplate;

    /// <summary>
    /// Gets the JavaScript template used for user prompt input.
    /// </summary>
    /// <returns>
    /// The content of the prompt JavaScript template.
    /// </returns>
    property PromptTemplate: string read GetPromptTemplate;
  end;

  /// <summary>
  /// Defines the contract for a chat display component capable of rendering markdown output, user prompts,
  /// and dynamic UI elements for conversational AI interactions in a Delphi VCL application.
  /// </summary>
  /// <remarks>
  /// <para>
  /// The <c>IDisplayer</c> interface exposes a set of methods and properties to enable flexible and interactive
  /// chat user interfaces. It supports rendering markdown and prompt bubbles, managing chat history and prompt counts,
  /// handling visual updates, and displaying reasoning states (such as AI response loading indicators).
  /// </para>
  /// <para>
  /// Implementations of this interface are designed to work seamlessly with modern browser engines like Edge (WebView2)
  /// and to integrate into the File2knowledgeAI conversation pipeline or similar chat solutions.
  /// </para>
  /// </remarks>
  IDisplayer = interface
    ['{D7D47290-0C2F-4A8B-9A54-12EAC9C47387}']
    function GetPromptCount: Integer;

    /// <summary>
    /// Appends the specified text as markdown to the chat display stream.
    /// </summary>
    /// <param name="AText">
    /// The markdown-formatted text to display in the chat interface.
    /// </param>
    /// <returns>
    /// The updated content of the internal display stream.
    /// </returns>
    function Display(const AText: string): string;

    /// <summary>
    /// Appends a flow of markdown text to the display stream, optionally auto-scrolling to the end.
    /// </summary>
    /// <param name="AText">
    /// The markdown-formatted text to append.
    /// </param>
    /// <param name="Scroll">
    /// If True, the display scrolls to after the end; otherwise, it does not scroll. Default is False.
    /// </param>
    /// <returns>
    /// The updated content of the internal display stream.
    /// </returns>
    function DisplayStream(const AText: string; Scroll: Boolean = False): string;

    /// <summary>
    /// Injects a new user prompt bubble into the chat display.
    /// </summary>
    /// <param name="AText">
    /// The user's prompt to be visually represented in the chat UI.
    /// </param>
    procedure Prompt(const AText: string);

    /// <summary>
    /// Scrolls the chat display to the end of the conversation history.
    /// </summary>
    /// <param name="Smooth">
    /// If True, scrolling is animated smoothly; otherwise, it scrolls instantly. Default is False.
    /// </param>
    procedure ScrollToEnd(Smooth: Boolean = False); overload;

    /// <summary>
    /// Scrolls the chat display to a position after the last entry and adds free space.
    /// </summary>
    /// <param name="SizeAfter">
    /// The vertical space in pixels to add after the last chat bubble.
    /// </param>
    /// <param name="Smooth">
    /// If True, performs a smooth animated scroll. Default is True.
    /// </param>
    procedure ScrollToAfterEnd(SizeAfter: Integer; Smooth: Boolean = True); overload;

    /// <summary>
    /// Scrolls to the top of the chat display.
    /// </summary>
    procedure ScrollToTop;

    /// <summary>
    /// Clears the chat history and display content.
    /// </summary>
    procedure Clear;

    /// <summary>
    /// Suspends redrawing of the chat control for batch updates.
    /// </summary>
    procedure BeginUpdateControl;

    /// <summary>
    /// Resumes redrawing of the chat control after batch updates.
    /// </summary>
    procedure EndUpdateControl;

    /// <summary>
    /// Makes the chat display visible.
    /// </summary>
    procedure Show;

    /// <summary>
    /// Hides the chat display from view.
    /// </summary>
    procedure Hide;

    /// <summary>
    /// Displays the reasoning or loading indicator panel in the chat interface, typically used to show
    /// that an AI response is being generated.
    /// </summary>
    procedure ShowReasoning;

    /// <summary>
    /// Hides the reasoning or loading indicator panel from the chat interface, removing any related UI elements.
    /// </summary>
    procedure HideReasoning;

    /// <summary>
    /// Gets or sets the current count of user prompts displayed in the chat.
    /// </summary>
    property PromptCount: Integer read GetPromptCount;
  end;

  /// <summary>
  /// Provides a standardized contract for displaying and managing annotation text output
  /// in Delphi VCL TMemo-based components.
  /// </summary>
  /// <remarks>
  /// <para>
  /// The <c>IAnnotationsDisplayer</c> interface encapsulates methods required to append, stream, and
  /// clear multi-line or block text within a TMemo control. It ensures consistent behavior for
  /// text display, live stream updates, and scroll management in logging, annotation, or chat
  /// scenarios.
  /// </para>
  /// <para>
  /// Typical implementations are designed to support both line-wise display and streaming (partial)
  /// updates, handle multiple newline conventions, and give control over scroll position after updates.
  /// This interface is ideally used to decouple annotation or log presentation logic from UI layers,
  /// improving testability and maintainability.
  /// </para>
  /// </remarks>
  IAnnotationsDisplayer = interface
    ['{3D916867-C036-4530-A708-5BBB89B4DB7B}']
    function GetText: string;

    /// <summary>
    /// Appends the provided text to the associated <see cref="TMemo"/> control, splitting it into lines as needed.
    /// Automatically scrolls to the latest entry.
    /// </summary>
    /// <param name="AText"> The text to display. Each line break will result in a new line in the memo. </param
    procedure Display(const AText: string);

    /// <summary>
    /// Streams raw or pre-formatted text directly into the associated <see cref="TMemo"/> control. Suitable for live updates or appending blocks of text.
    /// Handles both '\n' and line break characters for consistent display.
    /// </summary>
    /// <param name="AText">The raw or formatted text to append to the memo.</param>
    procedure DisplayStream(const AText: string);

    /// <summary>
    /// Clears all text from the associated <see cref="TMemo"/> control, removing all lines.
    /// </summary>
    procedure Clear;

    /// <summary>
    /// Scrolls the memo to the last line, bringing the most recent content into view.
    /// </summary>
    procedure ScrollToEnd;

    /// <summary>
    /// Scrolls the memo to the first line, bringing the earliest content into view.
    /// </summary>
    procedure ScrollToTop;

    /// <summary>
    /// Determines whether the memo is currently empty.
    /// </summary>
    /// <returns>True if there is no text in the memo; otherwise, False.</returns>
    function IsEmpty: Boolean;

    /// <summary>
    /// Retrieves the full text from the associated <see cref="TMemo"/> control as a single string.
    /// </summary>
    property Text: string read GetText;
  end;

  /// <summary>
  /// Defines an interface for managing prompt editing, validation, and asynchronous submission
  /// in an AI-powered application. Implementations should provide mechanisms for text handling,
  /// focus control, and clearing the prompt input, supporting seamless user interaction within the UI.
  /// </summary>
  /// <remarks>
  /// The <c>IServicePrompt</c> interface abstracts the contract for prompt management.
  /// It is suitable for use in both visual and non-visual components where textual user input
  /// is edited, validated, and possibly submitted for AI processing. Implementing classes should
  /// support property persistence and clear/reusable interaction patterns.
  /// </remarks>
  IServicePrompt = interface
    ['{82358F03-34FB-4717-AD02-7365C072207B}']
    function GetText: string;
    procedure SetText(const Value: string);

    ///<summary>
    /// Sets focus to the prompt editor control.
    ///</summary>
    procedure SetFocus;

    ///<summary>
    /// Clears the current prompt text from the editor.
    /// </summary>
    procedure Clear;

    ///<summary>
    /// Gets or sets the prompt text.
    ///</summary>
    property Text: string read GetText write SetText;
  end;

  /// <summary>
  /// Provides an interface for canceling asynchronous operations.
  /// </summary>
  /// <remarks>
  /// <para>
  /// The <c>ICancellation</c> interface defines methods for managing the cancellation state of an
  /// ongoing operation. It allows a client to request cancellation, verify if an operation has been canceled,
  /// and reset the cancellation state for reuse.
  /// </para>
  /// <para>
  /// Implementations of this interface enable graceful interruption of long-running or streaming tasks,
  /// ensuring that resources can be released properly when an operation is aborted.
  /// </para>
  /// </remarks>
  ICancellation = interface
    ['{010DE493-1C25-4CF7-8B78-045E26060EAA}']
    /// <summary>
    /// Marks the cancellation as requested, restores the original button caption and click handler.
    /// </summary>
    procedure Cancel;

    /// <summary>
    /// Returns True if a cancellation has been requested; otherwise, returns False.
    /// </summary>
    /// <returns>
    /// True if the user has triggered the cancellation action, otherwise False.
    /// </returns>
    function IsCancelled: Boolean;

    /// <summary>
    /// Prepares the managed button for cancellation use by saving its state,
    /// updating the caption to a cancel glyph, and assigning the cancellation handler.
    /// </summary>
    procedure Reset;
  end;

  /// <summary>
  /// Defines the contract for animated left panel controls within a Delphi VCL application,
  /// supporting panel state management, content navigation, and resource entry workflows.
  /// </summary>
  /// <remarks>
  /// <para>
  /// The <c>ILeftPanelControl</c> interface specifies the core functionalities required for
  /// interactive, stateful workspace or navigation panels used in File2knowledgeAI-based applications.
  /// Implementations should enable smooth toggling, asynchronous UI updates, and dynamic resource management,
  /// in line with modern UX standards and OpenAI best practices for resource/session organization.
  /// </para>
  /// </remarks>
  ILeftPanelControl = interface
    ['{6EE300FC-FE89-4588-9B19-BF01D56A7A0C}']
    /// <summary>
    /// Handles panel switch events, toggling the panel between opened and closed states.
    /// </summary>
    /// <param name="Sender">The object that initiated the switch operation (typically a button).</param>
    procedure HandleSwitch(Sender: TObject);

    /// <summary>
    /// Handles creation of a new conversation/resource entry in the panel.
    /// Resets any persistent or selection state and prepares the workspace for a fresh entry.
    /// </summary>
    /// <param name="Sender">The control or component that triggered the new entry action.</param>
    procedure HandleNew(Sender: TObject);

    /// <summary>
    /// Refreshes the contents of the left panel,
    /// repopulating its scroll box with the latest resource containers and updating their states.
    /// </summary>
    procedure Refresh;

    /// <summary>
    /// Selects the resource container by its index in the scroll box,
    /// triggering selection logic and highlighting for navigation or operation.
    /// </summary>
    /// <param name="AIndex">The index of the container to select.</param>
    procedure ItemSelect(const AIndex: Integer);
  end;

  /// <summary>
  /// IAIInteractionManager defines a contract for executing prompts and managing file/vector store interactions with the OpenAI/GenAI APIs.
  /// </summary>
  /// <remarks>
  /// This interface abstracts the full lifecycle of prompt execution, covering both streamed (real-time) and silent (background) scenarios,
  /// as well as advanced operations for file and vector store management. Its methods enable integration with OpenAI's latest endpoint
  /// (v1/responses), supporting operations such as prompt submission, file uploads, vector store linking, and deletion of entities
  /// (responses, files, vector stores, and associations).
  /// <para>
  /// - The design ensures asynchronous operation through promises, promoting responsive and non-blocking workflows in Delphi applications.
  /// Implementations should be stateless or singleton, injectable via IoC/DI, and focused on best practices for modularity, testability, and decoupling.
  /// </para>
  /// </remarks>
  IAIInteractionManager = interface
    ['{AF0A6D31-0942-42A8-BCAC-225AB375DCDE}']
    /// <summary>
    /// Executes a prompt using the default (streamed) execution engine.
    /// This method sends the prompt to OpenAI, streams back the AI response in real-time,
    /// and coordinates UI updates and session storage as configured.
    /// </summary>
    /// <param name="Prompt">
    /// The user's prompt or question to send to OpenAI.
    /// </param>
    /// <returns>
    /// A promise (TPromise&lt;string&gt;) which resolves to the AI response text,
    /// or is rejected upon error or cancellation.
    /// </returns>
    function Execute(const Prompt: string): TPromise<string>;

    /// <summary>
    /// Executes a prompt in "silent" mode, without real-time streaming or UI updates.
    /// This is intended for background queries, system tasks, or non-interactive batch scenarios.
    /// </summary>
    /// <param name="Prompt">
    /// The user's prompt to send to OpenAI.
    /// </param>
    /// <param name="Instructions">
    /// System instructions to provide context or modify the behavior of the AI assistant.
    /// </param>
    /// <returns>
    /// A promise (TPromise&lt;string&gt;) which resolves to the complete AI response text.
    /// </returns>
    function ExecuteSilently(const Prompt, Instructions: string): TPromise<string>;

    /// <summary>
    /// Ensures a file is present in OpenAI storage and is linked to a vector store.
    /// Handles upload if needed, vector store creation if required, and the association/link.
    /// </summary>
    /// <param name="FileName">
    /// Path to the local file to upload, if necessary.
    /// </param>
    /// <param name="FileId">
    /// The OpenAI file identifier (if known or empty if new upload is needed).
    /// </param>
    /// <param name="VectorStoreId">
    /// The vector store identifier (if known or empty to create a new one).
    /// </param>
    /// <returns>
    /// A promise (TPromise&lt;string&gt;) which resolves with concatenated VectorStoreId and FileId,
    /// or is rejected on error.
    /// </returns>
    function EnsureVectorStoreFileLinked(const FileName: string; const FileId: string;
      const VectorStoreId: string): TPromise<string>;

    /// <summary>
    /// Deletes a response from the OpenAI backend.
    /// </summary>
    /// <param name="ResponseId">
    /// Unique identifier of the response to be deleted.
    /// </param>
    /// <returns>
    /// A promise (TPromise&lt;string&gt;) that resolves to a confirmation message upon successful deletion,
    /// or is rejected if an error occurs.
    /// </returns>
    function DeleteResponse(ResponseId: string): TPromise<string>;

    /// <summary>
    /// Deletes the association between a file and a vector store.
    /// </summary>
    /// <param name="VectorStoreId">
    /// The identifier of the target vector store.
    /// </param>
    /// <param name="FileId">
    /// The identifier of the file to be unlinked from the vector store.
    /// </param>
    /// <returns>
    /// A promise (TPromise&lt;string&gt;) that resolves to a confirmation message if successful,
    /// or is rejected if an error occurs.
    /// </returns>
    function DeleteVectorStore(const VectorStoreId, FileId: string): TPromise<string>;

    /// <summary>
    /// Removes a vector store from the OpenAI backend.
    /// </summary>
    /// <param name="VectorStoreId">
    /// Unique identifier of the vector store to remove.
    /// </param>
    /// <returns>
    /// A promise (TPromise&lt;string&gt;) that resolves to a confirmation message upon successful removal,
    /// or is rejected if an error occurs.
    /// </returns>
    function RemoveVectorStore(const VectorStoreId: string): TPromise<string>;

    /// <summary>
    /// Deletes a file from the OpenAI backend file store.
    /// </summary>
    /// <param name="FileId">
    /// Identifier of the file to delete.
    /// </param>
    /// <returns>
    /// A promise (TPromise&lt;string&gt;) that resolves to a confirmation message upon successful deletion,
    /// or is rejected if an error occurs.
    /// </returns>
    function DeleteFile(FileId: string): TPromise<string>;

    /// <summary>
    /// Deletes a file that is linked to a vector store.
    /// </summary>
    /// <param name="VectorStoreId">
    /// The identifier of the vector store containing the file.
    /// </param>
    /// <param name="FileId">
    /// The identifier of the file to delete from the vector store.
    /// </param>
    /// <returns>
    /// A promise (TPromise&lt;string&gt;) that resolves to a confirmation message upon successful deletion,
    /// or is rejected if an error occurs.
    /// </returns>
    function DeleteVectorStoreFile(const VectorStoreId, FileId: string): TPromise<string>;
  end;

  /// <summary>
  /// Defines the contract for a page selector component in Delphi VCL applications,
  /// enabling programmatic activation and retrieval of application pages through
  /// a unified interface.
  /// </summary>
  /// <remarks>
  /// <para>
  /// Implementations of <c>ISelector</c> allow clients to activate specific application pages,
  /// synchronize user interface controls such as ComboBox and PageControl,
  /// and query or update the currently active page.
  /// </para>
  /// <para>
  /// This interface is designed to promote separation of page navigation logic from UI implementation,
  /// and supports extensibility for multi-page, modular applications.
  /// </para>
  /// </remarks>
  ISelector = interface
    ['{265B784D-6279-48A3-A3D3-2FB3B3902DFD}']
    function GetActivePage: TPageSelector;
    /// <summary>
    /// Displays and activates the specified page in the selector.
    /// Synchronizes the ComboBox selection, PageControl tab, and Label to reflect the chosen page.
    /// </summary>
    /// <param name="Page">
    /// The <see cref="Manager.Types.TPageSelector"/> value identifying the page to show.
    /// </param>
    procedure ShowPage(const Page: TPageSelector);

    /// <summary>
    /// Gets or sets the currently active page in the selector.
    /// </summary>
    /// <remarks>
    /// Setting this property changes the UI to reflect the active page,
    /// updating the ComboBox, PageControl, and Label accordingly.
    /// </remarks>
    property ActivePage: TPageSelector read GetActivePage write ShowPage;
  end;

  /// <summary>
  /// Provides a standardized contract for managing AI vector resource lists and file-based persistence in
  /// VCL applications.
  /// </summary>
  /// <remarks>
  /// <para>
  /// - The <c>IAppFileStoreManager</c> interface defines methods and properties necessary for loading,
  /// saving, and updating vector resource definitions, as well as managing files and vector store
  /// identifiers associated with each resource. It centralizes business logic for working with resources,
  /// making it easier to maintain, extend, and test resource management code. Implementations of this
  /// interface abstract away interaction with JSON files and UI components, so that business and presentation
  /// logic remain decoupled.
  /// </para>
  /// <para>
  /// - Key responsibilities include the loading of persistent data from disk, attaching vector resource items
  /// to visual container components, synchronizing selection state, updating and persisting resource
  /// attributes, and tracking resource file associations. The interface also exposes methods for advanced
  /// operations such as pinging vector stores, method-chained configuration, and file lifecycle actions,
  /// which all facilitate fluid user experience and robust persistence according to best practices.
  /// </para>
  /// <para>
  /// - IAppFileStoreManager should be used as the foundation for VCL-aware classes orchestrating data, UI, and
  /// file persistence for AI resource lists. This interface enhances scalability and reliability when
  /// integrating new resource providers, data formats, or storage mechanisms in a GenAI VCL application
  /// context.
  /// </para>
  /// </remarks>
  IAppFileStoreManager = interface
    ['{9D25981C-26B4-4B26-8017-9FFA0B542B2F}']
    function GetItemIndex: Integer;
    procedure SetItemIndex(const Value: Integer);
    function GetVectorStore: string;
    procedure SetVectorStore(const Value: string);
    function GetImagePath: string;
    function GetName: string;
    function GetDescription: string;
    function GetGitHub: string;
    function GetGetit: string;
    function GetFiles: TArray<string>;
    function GetUploadIds: TArray<string>;
    function GetResources: TObject;
    procedure SetName(const Value: string);

    /// <summary>
    /// Initializes the resource manager with default values and updates the current resource state.
    /// </summary>
    /// <returns>
    /// Returns the current instance to support method chaining.
    /// </returns>
    function DefaultValues: IAppFileStoreManager;

    /// <summary>
    /// Loads resource values from persistent storage and updates the current resource state.
    /// </summary>
    /// <returns>
    /// Returns the current instance to support method chaining.
    /// </returns>
    function LoadValues: IAppFileStoreManager;

    /// <summary>
    /// Attaches resource containers to the specified VCL component, optionally binding a click event handler for resource selection.
    /// </summary>
    /// <param name="Value">
    /// The VCL component (such as a TScrollBox) to which resources will be attached.
    /// </param>
    /// <param name="OnClickProc">
    /// Optional procedure to invoke when a resource container is selected.
    /// </param>
    /// <returns>
    /// Returns the current instance to support method chaining.
    /// </returns>
    function AttachTo(const Value: TComponent; const OnClickProc: TProc<TObject> = nil): IAppFileStoreManager;

    /// <summary>
    /// Determines if the persistent JSON storage file for resources exists on disk.
    /// </summary>
    /// <returns>
    /// True if the JSON file exists; otherwise, False.
    /// </returns>
    function JSONExists: Boolean;

    /// <summary>
    /// Reloads the resource list from persistent storage.
    /// </summary>
    procedure Reload;

    /// <summary>
    /// Saves the current resource list to persistent storage.
    /// </summary>
    /// <param name="FileName">
    /// Optional file name to use for saving. If blank, the default file is used.
    /// </param>
    procedure SaveToFile(FileName: string = '');

    /// <summary>
    /// Adds a file to the currently selected resource's file list.
    /// </summary>
    /// <param name="FileName">
    /// The name or path of the file to add.
    /// </param>
    procedure AddFile(const FileName: string);

    /// <summary>
    /// Deletes the file pair at the specified index from the currently selected resource.
    /// </summary>
    /// <param name="index">
    /// The zero-based index of the file pair to delete.
    /// </param>
    procedure DeleteFile(index: Integer);

    /// <summary>
    /// Updates the state for the currently selected resource by re-linking it with the vector store and persisting changes.
    /// </summary>
    procedure UpdateCurrent;

    /// <summary>
    /// Pings the selected vector store by ensuring that the associated files are linked and valid.
    /// </summary>
    /// <returns>
    /// Returns a promise containing the vector store identifier string.
    /// </returns>
    function PingVectorStore: TPromise<string>;

    /// <summary>
    /// Gets or sets the index of the currently selected resource item.
    /// </summary>
    property ItemIndex: Integer read GetItemIndex write SetItemIndex;

    /// <summary>
    /// Gets the image path associated with the currently selected resource.
    /// </summary>
    property ImagePath: string read GetImagePath;

    /// <summary>
    /// Gets or sets the name of the currently selected resource.
    /// </summary>
    property Name: string read GetName write SetName;

    /// <summary>
    /// Gets the description of the currently selected resource.
    /// </summary>
    property Description: string read GetDescription;

    /// <summary>
    /// Gets the GitHub URL associated with the currently selected resource.
    /// </summary>
    property GitHub: string read GetGitHub;

    /// <summary>
    /// Gets the GetIt URL associated with the currently selected resource.
    /// </summary>
    property Getit: string read GetGetit;

    /// <summary>
    /// Gets the list of file paths associated with the currently selected resource.
    /// </summary>
    property Files: TArray<string> read GetFiles;

    /// <summary>
    /// Gets the list of file upload identifiers for the currently selected resource.
    /// </summary>
    property FileUploadIds: TArray<string> read GetUploadIds;

    /// <summary>
    /// Gets the resources object representing the complete resource list.
    /// </summary>
    property Resources: TObject read GetResources;

    /// <summary>
    /// Gets or sets the vector store identifier for the selected resource.
    /// </summary>
    property VectorStore: string read GetVectorStore write SetVectorStore;
  end;

  /// <summary>
  /// Defines the contract for a visual and interactive chat session history view component
  /// in the File2knowledgeAI application.
  /// </summary>
  /// <remarks>
  /// <para>
  /// The <c>IChatSessionHistoryView</c> interface declares the essential operations needed to
  /// present and manage historical multi-turn chat conversations in a user interface.
  /// This includes full reload and refresh capabilities, visual repaints of current sessions,
  /// and support for showing contextual annotations tied to each conversation round.
  /// </para>
  /// <para>
  /// Implementations of this interface handle user-driven updates to the chat history UI,
  /// synchronize with persistent storage layers, and ensure continuity of conversational state.
  /// It plays a central role in providing a seamless, user-friendly experience when navigating
  /// and administrating historical chat data, fully aligned with OpenAI and File2knowledgeAI best practices.
  /// </para>
  /// </remarks>
  IChatSessionHistoryView = interface
    ['{1548AE2E-891D-4C60-9F2E-B2153D861D06}']
    /// <summary>
    /// Fully refreshes the display by reloading all chat session history from the persistent store and updating the ListView.
    /// </summary>
    /// <param name="Sender">The caller or event originator.</param>
    procedure FullRefresh(Sender: TObject);

    /// <summary>
    /// Refreshes the ListView to reflect the current state of the chat session history without reloading from the persistent store.
    /// </summary>
    /// <param name="Sender">The caller or event originator.</param>
    procedure Refresh(Sender: TObject);

    /// <summary>
    /// Repaints all UI elements for the currently selected chat session, optionally invoking specialized rendering for each turn in the conversation.
    /// </summary>
    /// <param name="Sender">The caller or event originator.</param>
    procedure Repaint(Sender: TObject);

    /// <summary>
    /// Updates the specified annotation display component with new text and scrolls to the top.
    /// </summary>
    /// <param name="Annotation">The component responsible for displaying annotations.</param>
    /// <param name="Text">The annotation text to display.</param>
    procedure UpdateAnnotation(const Annotation: IAnnotationsDisplayer; const Text: string);
  end;

  /// <summary>
  /// Interface for tracking OpenAI response IDs to enable conversation chaining using the v1/responses endpoint.
  /// </summary>
  /// <remarks>
  /// <para>
  /// The <c>IOpenAIChatTracking</c> interface defines the contract for components that manage a set of unique response
  /// identifiers (IDs) received from calls to the OpenAI v1/responses endpoint. These IDs are essential for linking user requests
  /// to corresponding responses in persistent, multi-turn conversations.
  /// </para>
  /// <para>
  /// This interface provides methods to add new response IDs, remove them, clear the entire set, and cancel the last operation,
  /// with special focus on supporting robust conversation history and state management for chaining purposes.
  /// </para>
  /// <para>
  /// Implementations of <c>IOpenAIChatTracking</c> make it possible to centralize control of response ID lifecycles,
  /// facilitating traceability, cleanup, and efficient chaining of prompts and responses according to File2knowledgeAI best practices.
  /// </para>
  /// </remarks>
  IOpenAIChatTracking = interface
    ['{3D2883AA-12B8-461C-B1AF-E98B5C18F523}']
    function GetLastId: string;
    /// <summary>
    /// Adds a new ID to the tracking list if it is not empty or already present.
    /// Updates the last tracked ID.
    /// </summary>
    /// <param name="Value">
    /// The unique identifier to add.
    /// </param>
    procedure Add(const Value: string);

    /// <summary>
    /// Deletes the specified ID from tracking by invoking the assigned delete procedure.
    /// </summary>
    /// <param name="Value">
    /// The unique identifier to delete.
    /// </param>
    procedure Delete(const Value: string);

    /// <summary>
    /// Removes all IDs from the tracking list and clears the last tracked ID.
    /// Invokes the assigned delete procedure for each removed ID.
    /// </summary>
    procedure Clear;

    /// <summary>
    /// Cancels the most recent tracking operation and reverts the last tracked ID to the previous one.
    /// If there was only one or no ID tracked, the last ID will be set to an empty string.
    /// </summary>
    procedure Cancel;

    /// <summary>
    /// Gets the last tracked unique identifier.
    /// </summary>
    property LastId: string read GetLastId;
  end;

  /// <summary>
  /// Defines the contract for a prompt selector component in Delphi VCL applications.
  /// </summary>
  /// <remarks>
  /// <para>
  /// Provides an interface for managing navigation and interaction with a collection of prompts within a user interface.
  /// Implementations should supply visual navigation (show/hide capability and index management) along with synchronization to any underlying data source.
  /// </para>
  /// <para>
  /// Designed for use in scenarios where prompts or history items must be browsed and selected by the end-user, with direct integration into VCL forms or panels.
  /// </para>
  /// </remarks>
  IPromptSelector = interface
    ['{D26054D6-D07E-49B8-9ADB-2485D2727296}']
    procedure SetItemIndex(const Value: Integer);
    function GetItemIndex: Integer;
    /// <summary>
    /// Updates the prompt selector UI to reflect current application state.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Refreshes the display, sets the item count and current index,
    /// and updates all related visual elements according to the prompt data.
    /// </para>
    /// </remarks>
    procedure Update;

    /// <summary>
    /// Hides the prompt selector panel from the user interface.
    /// </summary>
    procedure Hide;

    /// <summary>
    /// Shows the prompt selector panel in the user interface.
    /// </summary>
    procedure Show;

    /// <summary>
    /// Gets or sets the currently selected prompt index.
    /// </summary>
    /// <returns>
    /// The zero-based index of the currently selected prompt.
    /// </returns>
    property ItemIndex: Integer read GetItemIndex write SetItemIndex;
  end;

  /// <summary>
  /// Defines the contract for managing the persistence of application user settings.
  /// </summary>
  /// <remarks>
  /// The <c>IIniSettings</c> interface abstracts the operations required to load, save, and reload user settings,
  /// providing unified access to a settings object and supporting file-based serialization.
  /// </remarks>
  IIniSettings = interface
    ['{9FF3D2AC-CB9E-41A7-826B-08797AB4F1EC}']
    function GetSettings: TObject;

    /// <summary>
    /// Reloads the user settings from persistent storage.
    /// </summary>
    /// <remarks>
    /// This method replaces the current settings with those loaded from disk.
    /// Typically used to re-synchronize in-memory settings with external changes.
    /// </remarks>
    procedure Reload;

    /// <summary>
    /// Loads settings from the specified file.
    /// </summary>
    /// <param name="FileName">
    /// The file path of the configuration file to load. If empty, the default settings file is used.
    /// </param>
    /// <returns>
    /// Returns the file path used for loading, or an empty string if the operation fails.
    /// </returns>
    function LoadFromFile(FileName: string = ''): string;

    /// <summary>
    /// Saves the current settings to the specified file.
    /// </summary>
    /// <param name="FileName">
    /// The file path where the configuration should be saved. If empty, the default file is used.
    /// </param>
    procedure SaveToFile(FileName: string = '');

    /// <summary>
    /// Gets the settings object being managed.
    /// </summary>
    /// <returns>
    /// Returns the current settings instance as a <c>TObject</c>.
    /// </returns>
    property Settings: TObject read GetSettings;
  end;

  /// <summary>
  /// Interface for advanced user settings management in the File2knowledgeAI VCL application.
  /// </summary>
  /// <remarks>
  /// <para>
  /// <c>ISettings</c> provides a standardized contract for accessing, updating, and synchronizing
  /// user application's preferences, including AI provider keys, proficiency, search and reasoning models,
  /// and contextual search options. Implementations of this interface coordinate persistent settings
  /// with UI controls, ensuring robust, centralized user configuration management.
  /// </para>
  /// <para>
  /// Key features exposed include programmatic prompting for missing information (such as API keys),
  /// two-way updates between user interface and underlying settings data, as well as
  /// retrieval of values for runtime or business logic use. The interface supports scalable extension for new
  /// preference domains or UI surfaces with minimal code changes, following modern architectural practices
  /// in Delphi VCL projects.
  /// </para>
  /// </remarks>
  ISettings = interface
    ['{E5EB0825-72A4-4F31-8C7E-3B470E83EAE9}']
    /// <summary>
    /// Prompts the user to enter their OpenAI API key if it is not already set.
    /// <para>
    /// If no API key is present, displays a dialog for user input,
    /// saves the entered key to persistent settings, and updates the application state accordingly.
    /// </para>
    /// </summary>
    procedure InputAPIKey;

    /// <summary>
    /// Synchronizes the UI controls with the current persistent user settings.
    /// <para>
    /// Updates all UI elements to reflect values from the persistent settings model,
    /// applies display updates (such as model costs), and ensures all modifications are saved.
    /// </para>
    /// </summary>
    procedure Update;

    /// <summary>
    /// Returns the textual representation of the currently selected user proficiency level.
    /// <para>
    /// Retrieves the current selection from the proficiency ComboBox and
    /// converts it to its display string using the helper for proficiency levels.
    /// </para>
    /// </summary>
    function ProficiencyToString: string;

    /// <summary>
    /// Gets the user's screen name as displayed in the application's UI.
    /// <para>
    /// Returns the value of the preference name loaded from the settings model.
    /// </para>
    /// </summary>
    function UserScreenName: string;

    /// <summary>
    /// Returns the identifier of the currently selected search model.
    /// <para>
    /// Gets the search model chosen in the UI or persisted in the user settings.
    /// </para>
    /// </summary>
    function SearchModel: string;

    /// <summary>
    /// Returns the identifier of the currently selected reasoning model.
    /// <para>
    /// Gets the reasoning model chosen in the UI or persisted in the user settings.
    /// </para>
    /// </summary>
    function ReasoningModel: string;

    /// <summary>
    /// Returns the currently stored OpenAI API key.
    /// <para>
    /// Provides access to the API key stored in the settings, without prompting the user.
    /// </para>
    /// </summary>
    function APIKey: string;

    /// <summary>
    /// Gets the selected value for reasoning effort.
    /// </summary>
    /// <returns>
    /// The current reasoning effort value from settings.
    /// </returns>
    function ReasoningEffort: string;

    /// <summary>
    /// Gets the selected value for reasoning summary.
    /// </summary>
    /// <returns>
    /// The current reasoning summary value from settings.
    /// </returns>
    function ReasoningSummary: string;

    /// <summary>
    /// Gets the configured web search context size.
    /// </summary>
    /// <returns>
    /// The current web context size from settings.
    /// </returns>
    function WebContextSize: string;

    /// <summary>
    /// Gets the timeout configuration for user operations.
    /// </summary>
    /// <returns>
    /// The current timeout value from settings.
    /// </returns>
    function TimeOut: string;

    /// <summary>
    /// Gets the configured country string.
    /// </summary>
    /// <returns>
    /// The country value from user settings.
    /// </returns>
    function Country: string;

    /// <summary>
    /// Gets the configured city string.
    /// </summary>
    /// <returns>
    /// The city value from user settings.
    /// </returns>
    function City: string;

    /// <summary>
    /// Indicates if a summary is to be used for the current user configuration.
    /// </summary>
    /// <returns>
    /// True if the summary is enabled; otherwise, False.
    /// </returns>
    function UseSummary: Boolean;
  end;

  /// <summary>
  /// Interface for managing and switching the main feature modes (Web Search, File Search Disable, Reasoning)
  /// in the File2knowledgeAI application.
  /// </summary>
  /// <remarks>
  /// <para>
  /// <c>IServiceFeatureSelector</c> defines methods to programmatically toggle the primary modes used for search and
  /// reasoning features. Implementations of this interface ensure consistent state management and provide the
  /// capability to synchronize UI elements (such as toggle buttons or labels) with internal feature logic.
  /// </para>
  /// <para>
  /// This interface is intended to standardize the way in which the application activates, deactivates, or combines
  /// its core functional features at runtime, facilitating both user-driven and code-driven feature changes.
  /// </para>
  /// </remarks>
  IServiceFeatureSelector = interface
    ['{C9E6967B-D4A0-4032-9047-D10F4938A2A5}']
    function GetFeatureModes: TFeatureModes;
    /// <summary>
    /// Programmatically toggles the Web Search mode, updating both internal state and UI accordingly.
    /// </summary>
    procedure SwitchWebSearch;

    /// <summary>
    /// Programmatically toggles the File Search feature disable mode, updating internal state and the UI.
    /// </summary>
    procedure SwitchDisableFileSearch;

    /// <summary>
    /// Programmatically toggles the Reasoning mode, enforcing the required disabling of Web Search and updating the UI.
    /// </summary>
    procedure SwitchReasoning;

    /// <summary>
    /// Gets the current combination of feature modes (Web Search, File Search Disabled, Reasoning)
    /// as reflected by the UI state of the corresponding buttons.
    /// </summary>
    property FeatureModes: TFeatureModes read GetFeatureModes;
  end;

  /// <summary>
  /// Interface for resource editor components providing methods to manage and synchronize
  /// vector resource data and related UI controls in the File2knowledgeAI application.
  /// </summary>
  /// <remarks>
  /// Implementations of this interface are responsible for refreshing the editor view and
  /// re-initializing any file attachments or metadata displayed in the UI.
  /// Typical use cases include updating the visible state after data changes or file operations,
  /// and ensuring consistent synchronization between persistent data and user interface components.
  /// </remarks>
  IVectorResourceEditor = interface
    ['{A27DA244-00A9-42C1-8131-E25A1C218F13}']
    /// <summary>
    /// Reloads vector resource data into the UI controls and re-initializes the file management context.
    /// </summary>
    procedure Refresh;
  end;

  /// <summary>
  /// Central controller for managing associations between file names and FileUploadIds
  /// within the File2knowledgeAI project.
  /// </summary>
  /// <remarks>
  /// This class coordinates file attachment management and state transitions, enabling
  /// the UI to add, remove, and validate files associated with vector resources.
  /// It maintains separate “snapshot” and “draft” dictionaries for transactional safety,
  /// integrates with helper units for dictionary operations, and ensures consistency
  /// between client- and server-side data.
  /// <para>
  /// * Intended for use with Helper.FileUploadID.Dictionary and UI.VectorResourceEditor.VCL.
  /// </para>
  /// </remarks>
  IFileUploadIdController = interface
    ['{BD051725-EEA5-47CB-8F00-A717F8C477FD}']
    /// <summary>
    /// Initializes both the snapshot and draft dictionaries with current file names and associated FileUploadIds.
    /// </summary>
    /// <remarks>
    /// Should be called whenever there is a need to synchronize the controller's state with
    /// the persistent data store or to reset after external changes.
    /// </remarks>
    procedure InitDictionaries;
    /// <summary>
    /// Persists the changes made to file and FileUploadId mappings by comparing the snapshot and draft dictionaries.
    /// </summary>
    /// <remarks>
    /// This method applies additions and deletions, and updates the persistent vector resource data accordingly.
    /// May also trigger removal of files from OpenAI vector stores as appropriate.
    /// </remarks>
    procedure SaveChanges;

    /// <summary>
    /// Adds a new file to the draft dictionary, associating it with an (optional) FileUploadId.
    /// </summary>
    /// <param name="FileName">The name of the file to add.</param>
    /// <param name="Proc">A callback procedure to execute after addition (can be <c>nil</c>).</param>
    procedure AddFile(const FileName: string; Proc: TProc);

    /// <summary>
    /// Removes a file from the draft dictionary.
    /// </summary>
    /// <param name="FileName">The name of the file to remove.</param>
    /// <param name="Proc">A callback procedure to execute after removal (can be <c>nil</c>).</param>
    procedure DeleteFile(const FileName: string; Proc: TProc);

    /// <summary>
    /// Gets the number of files currently in the draft dictionary.
    /// </summary>
    /// <returns>The count of files being tracked in the draft state.</returns>
    function DraftCount: Integer;
  end;

  {--- Internal For Provider OpenAI }

  IPromptExecutionEngine = interface
    ['{7434A3D6-0DDC-4EB8-BFF6-8984A49FF6AF}']
    function Execute(const Prompt: string): TPromise<string>;
  end;

  IVectorStoreManager = interface
    ['{82FB52F6-F574-45D0-9EF1-8FD048B3DE97}']
    {--- Vector store }
    function EnsureVectorStoreId(const VectorStoreId: string): TPromise<string>;

    {--- Vector store file }
    function EnsureVectorStoreFileId(const VectorStoreId, FileId: string): TPromise<string>;
    function DeleteVectorStoreFile(const VectorStoreId, FileId: string): TPromise<string>;
    function DeleteVectorStore(const VectorStoreId: string): TPromise<string>;
  end;

  IFileStoreManager = interface
    ['{89695EFE-D587-4322-9A79-3D7657A451FE}']
    function CheckFileUploaded(const FileName, Id: string): TPromise<string>;
    function UploadFileAsync(const FileName: string): TPromise<string>;
    function EnsureFileId(const FileName: string; const Id: string): TPromise<string>;
  end;

  ISystemPromptBuilder = interface
    ['{F4C1A33D-A004-4D63-8532-E320731E1082}']
    function BuildSystemPrompt: string;
  end;

  {--- Startup services }

  /// <summary>
  /// Defines the contract for accessing key services and procedures required during application startup in the File2knowledgeAI architecture.
  /// </summary>
  /// <remarks>
  /// <para>
  /// The <c>IStartupContext</c> interface standardizes dependency access for form presentation, prompt services, display management,
  /// layout resizing, and startup error handling. Implementations of this interface provide a consistent, testable, and flexible
  /// mechanism for managing startup workflow elements in modular applications.
  /// </para>
  /// <para>
  /// Its primary purpose is to streamline initialization logic, promote clean architecture, and facilitate the injection of
  /// critical startup dependencies throughout the File2knowledgeAI project.
  /// </para>
  /// </remarks>
  IStartupContext = interface
    ['{DB8C48AF-40D5-472D-A893-86D1FB0B36E0}']
    /// <summary>
    /// Gets the displayer interface used for UI output during startup.
    /// </summary>
    function GetDisplayer: IDisplayer;

    /// <summary>
    /// Gets the service prompt interface responsible for user prompts and startup interactions.
    /// </summary>
    function GetServicePrompt: IServicePrompt;

    /// <summary>
    /// Gets the procedure reference for layout or window resizing operations at startup.
    /// </summary>
    function GetResizeProc: TProc;

    /// <summary>
    /// Gets the procedure reference used to launch or display the main application form.
    /// </summary>
    function GetFormPresenter: TProc;

    /// <summary>
    /// Gets the procedure reference for handling and displaying errors during startup.
    /// </summary>
    function GetOnError: TProc;
  end;

  /// <summary>
  /// Defines a contract for startup services responsible for executing the coordinated
  /// initialization sequence of the File2knowledgeAI application or its modules.
  /// </summary>
  /// <remarks>
  /// <para>
  /// <c>IStartupService</c> encapsulates the startup workflow, ensuring that all required
  /// user interface and system initialization procedures are orchestrated efficiently during application launch.
  /// </para>
  /// <para>
  /// Implementations typically handle UI clearing, main form presentation, environment checks,
  /// user notifications for missing dependencies, error handling upon initialization failures,
  /// session history refresh, focus assignment to service prompts, and layout resizing.
  /// All operations should run asynchronously on the main thread to avoid blocking the user interface.
  /// </para>
  /// </remarks>
  IStartupService = interface
    ['{383FC689-F896-470E-8E56-2F4296953541}']
    /// <summary>
    /// Executes the coordinated startup sequence for the application or module.
    /// </summary>
    /// <remarks>
    /// This method clears the interface, displays the main form, checks for mandatory runtime libraries,
    /// shows user alerts for missing resources, triggers error handling callbacks if needed, refreshes the session
    /// history view, sets focus on the service prompt, and performs dynamic resizing. All operations are queued
    /// asynchronously on the main thread to avoid blocking the UI.
    /// </remarks>
    procedure Run;
  end;

var
  /// <summary>
  /// Provides cancellation control for ongoing asynchronous operations.
  /// </summary>
  Cancellation: ICancellation;

  /// <summary>
  /// Provides an implementation of <c>IDisplayer</c> for rendering chat and AI conversational output
  /// using Edge (WebView2) as the display engine within Delphi VCL applications.
  /// </summary>
  /// <remarks>
  /// <para>
  /// <c>EdgeDisplayer</c> enables rich, styled markdown, prompt bubbles, and dynamic UI elements for interactive chat interfaces,
  /// leveraging the flexibility of modern HTML/CSS/JavaScript via the integrated Edge browser component.
  /// </para>
  /// <para>
  /// It acts as the main bridge between the conversational logic and the user, supporting real-time updates,
  /// scrolling, reasoning state UI, and prompt injection—all managed seamlessly within the WebView2 context.
  /// </para>
  /// <para>
  /// This variable forms the standard concrete implementation of <c>IDisplayer</c>
  /// for the File2knowledgeAI application's chat interface.
  /// </para>
  /// </remarks>
  EdgeDisplayer: IDisplayer;

  /// <summary>
  /// Provides a concrete implementation of <c>ITemplateProvider</c> used for managing and supplying
  /// HTML and JavaScript templates in the File2knowledgeAI application.
  /// </summary>
  /// <remarks>
  /// <para>
  /// <c>TemplateProvider</c> acts as the central access point for retrieving UI templates used with the
  /// <c>v1/responses</c> endpoint, including those for initial page rendering, displaying AI responses,
  /// reasoning operations, and user prompt input.
  /// </para>
  /// <para>
  /// By exposing an <c>ITemplateProvider</c> implementation, this variable facilitates template
  /// management, switching between development and production loading modes, and enables consistent
  /// template access throughout the application.
  /// </para>
  /// </remarks>
  TemplateProvider: ITemplateProvider;

  /// <summary>
  /// An implementation of <c>IAnnotationsDisplayer</c> for rendering annotation or file search results
  /// in a TMemo-based VCL component. Used as the primary text output interface in File2knowledgeAI
  /// file search scenarios.
  /// </summary>
  FileSearchDisplayer: IAnnotationsDisplayer;

  /// <summary>
  /// An implementation of <c>IAnnotationsDisplayer</c> designed to present web search output,
  /// live streaming results, or retrieved web content using a TMemo-based VCL component.
  /// Facilitates clear, scrollable display of web-derived annotation or QA text.
  /// </summary>
  WebSearchDisplayer: IAnnotationsDisplayer;

  /// <summary>
  /// An implementation of <c>IAnnotationsDisplayer</c> for outputting AI reasoning,
  /// analysis steps, or justification logs using a TMemo-based VCL component.
  /// Ensures that AI-generated reasoning is rendered clearly and can be easily reviewed in the UI.
  /// </summary>
  ReasoningDisplayer: IAnnotationsDisplayer;

  /// <summary>
  /// IAIInteractionManager defines a contract for executing prompts and managing file/vector store interactions with the OpenAI/GenAI APIs.
  /// </summary>
  /// <remarks>
  /// This interface abstracts the full lifecycle of prompt execution, covering both streamed (real-time) and silent (background) scenarios,
  /// as well as advanced operations for file and vector store management. Its methods enable integration with OpenAI's latest endpoint
  /// (v1/responses), supporting operations such as prompt submission, file uploads, vector store linking, and deletion of entities
  /// (responses, files, vector stores, and associations).
  /// <para>
  /// - The design ensures asynchronous operation through promises, promoting responsive and non-blocking workflows in Delphi applications.
  /// Implementations should be stateless or singleton, injectable via IoC/DI, and focused on best practices for modularity, testability, and decoupling.
  /// </para>
  /// </remarks>
  OpenAI: IAIInteractionManager;

  /// <summary>
  /// Defines an interface for managing prompt editing, validation, and asynchronous submission
  /// in an AI-powered application. Implementations should provide mechanisms for text handling,
  /// focus control, and clearing the prompt input, supporting seamless user interaction within the UI.
  /// </summary>
  /// <remarks>
  /// The <c>IServicePrompt</c> interface abstracts the contract for prompt management.
  /// It is suitable for use in both visual and non-visual components where textual user input
  /// is edited, validated, and possibly submitted for AI processing. Implementing classes should
  /// support property persistence and clear/reusable interaction patterns.
  /// </remarks>
  ServicePrompt: IServicePrompt;

  /// <summary>
  /// Defines the contract for a page selector component in Delphi VCL applications,
  /// enabling programmatic activation and retrieval of application pages through
  /// a unified interface.
  /// </summary>
  /// <remarks>
  /// <para>
  /// Implementations of <c>ISelector</c> allow clients to activate specific application pages,
  /// synchronize user interface controls such as ComboBox and PageControl,
  /// and query or update the currently active page.
  /// </para>
  /// <para>
  /// This interface is designed to promote separation of page navigation logic from UI implementation,
  /// and supports extensibility for multi-page, modular applications.
  /// </para>
  /// </remarks>
  Selector: ISelector;

  /// <summary>
  /// Defines the contract for animated left panel controls within a Delphi VCL application,
  /// supporting panel state management, content navigation, and resource entry workflows.
  /// </summary>
  /// <remarks>
  /// <para>
  /// The <c>ILeftPanelControl</c> interface specifies the core functionalities required for
  /// interactive, stateful workspace or navigation panels used in File2knowledgeAI-based applications.
  /// Implementations should enable smooth toggling, asynchronous UI updates, and dynamic resource management,
  /// in line with modern UX standards and OpenAI best practices for resource/session organization.
  /// </para>
  /// </remarks>
  LeftPanelControl: ILeftPanelControl;

  /// <summary>
  /// Provides a standardized contract for managing AI vector resource lists and file-based persistence in
  /// VCL applications.
  /// </summary>
  /// <remarks>
  /// <para>
  /// - The <c>IAppFileStoreManager</c> interface defines methods and properties necessary for loading,
  /// saving, and updating vector resource definitions, as well as managing files and vector store
  /// identifiers associated with each resource. It centralizes business logic for working with resources,
  /// making it easier to maintain, extend, and test resource management code. Implementations of this
  /// interface abstract away interaction with JSON files and UI components, so that business and presentation
  /// logic remain decoupled.
  /// </para>
  /// <para>
  /// - Key responsibilities include the loading of persistent data from disk, attaching vector resource items
  /// to visual container components, synchronizing selection state, updating and persisting resource
  /// attributes, and tracking resource file associations. The interface also exposes methods for advanced
  /// operations such as pinging vector stores, method-chained configuration, and file lifecycle actions,
  /// which all facilitate fluid user experience and robust persistence according to best practices.
  /// </para>
  /// <para>
  /// - IAppFileStoreManager should be used as the foundation for VCL-aware classes orchestrating data, UI, and
  /// file persistence for AI resource lists. This interface enhances scalability and reliability when
  /// integrating new resource providers, data formats, or storage mechanisms in a GenAI VCL application
  /// context.
  /// </para>
  /// </remarks>
  FileStoreManager: IAppFileStoreManager;

  /// <summary>
  /// Defines a contract for presenting user alerts and dialogs in applications.
  /// </summary>
  /// <remarks>
  /// <para>
  /// The <c>IAlertService</c> interface standardizes the core methods required to notify users of errors,
  /// information, warnings, and to request confirmation via modal dialogs. Implementations allow for
  /// decoupling user interface alert logic from business logic, improving maintainability and testability.
  /// </para>
  /// <para>
  /// Typical usage involves calling the appropriate method to display a message or prompt. The dialog
  /// appearance and interaction specifics (e.g., button arrangement, icons) are determined by the concrete
  /// implementation of the interface.
  /// </para>
  /// </remarks>
  AlertService: IAlertService;

  /// <summary>
  /// Interface for managing persistent chat sessions and prompts.
  /// </summary>
  /// <remarks>
  /// <para>
  /// This interface provides methods and properties to handle the lifecycle of chat sessions,
  /// including adding new chats and prompts, loading and saving chat data from/to files,
  /// and clearing the current chat state. It abstracts access to a collection of chat sessions
  /// and allows setting or retrieving the current chat session and prompt.
  /// </para>
  /// <para>
  /// Typical usage involves managing chat histories with persistence, enabling features like
  /// session switching, prompt additions, and file-based storage for conversation history.
  /// </para>
  /// </remarks>
  PersistentChat: IPersistentChat;

  /// <summary>
  /// Defines the contract for a visual and interactive chat session history view component
  /// in the File2knowledgeAI application.
  /// </summary>
  /// <remarks>
  /// <para>
  /// The <c>IChatSessionHistoryView</c> interface declares the essential operations needed to
  /// present and manage historical multi-turn chat conversations in a user interface.
  /// This includes full reload and refresh capabilities, visual repaints of current sessions,
  /// and support for showing contextual annotations tied to each conversation round.
  /// </para>
  /// <para>
  /// Implementations of this interface handle user-driven updates to the chat history UI,
  /// synchronize with persistent storage layers, and ensure continuity of conversational state.
  /// It plays a central role in providing a seamless, user-friendly experience when navigating
  /// and administrating historical chat data, fully aligned with OpenAI and File2knowledgeAI best practices.
  /// </para>
  /// </remarks>
  ChatSessionHistoryView: IChatSessionHistoryView;

  /// <summary>
  /// Interface for tracking OpenAI response IDs to enable conversation chaining using the v1/responses endpoint.
  /// </summary>
  /// <remarks>
  /// <para>
  /// The <c>IOpenAIChatTracking</c> interface defines the contract for components that manage a set of unique response
  /// identifiers (IDs) received from calls to the OpenAI v1/responses endpoint. These IDs are essential for linking user requests
  /// to corresponding responses in persistent, multi-turn conversations.
  /// </para>
  /// <para>
  /// This interface provides methods to add new response IDs, remove them, clear the entire set, and cancel the last operation,
  /// with special focus on supporting robust conversation history and state management for chaining purposes.
  /// </para>
  /// <para>
  /// Implementations of <c>IOpenAIChatTracking</c> make it possible to centralize control of response ID lifecycles,
  /// facilitating traceability, cleanup, and efficient chaining of prompts and responses according to File2knowledgeAI best practices.
  /// </para>
  /// </remarks>
  ResponseTracking: IOpenAIChatTracking;

  /// <summary>
  /// Defines the contract for a prompt selector component in Delphi VCL applications.
  /// </summary>
  /// <remarks>
  /// <para>
  /// Provides an interface for managing navigation and interaction with a collection of prompts within a user interface.
  /// Implementations should supply visual navigation (show/hide capability and index management) along with synchronization to any underlying data source.
  /// </para>
  /// <para>
  /// Designed for use in scenarios where prompts or history items must be browsed and selected by the end-user, with direct integration into VCL forms or panels.
  /// </para>
  /// </remarks>
  PromptSelector: IPromptSelector;

  /// <summary>
  /// Defines the contract for managing the persistence of application user settings.
  /// </summary>
  /// <remarks>
  /// The <c>IIniSettings</c> interface abstracts the operations required to load, save, and reload user settings,
  /// providing unified access to a settings object and supporting file-based serialization.
  /// </remarks>
  IniSettings: IIniSettings;

  /// <summary>
  /// Interface for advanced user settings management in the File2knowledgeAI VCL application.
  /// </summary>
  /// <remarks>
  /// <para>
  /// <c>ISettings</c> provides a standardized contract for accessing, updating, and synchronizing
  /// user application's preferences, including AI provider keys, proficiency, search and reasoning models,
  /// and contextual search options. Implementations of this interface coordinate persistent settings
  /// with UI controls, ensuring robust, centralized user configuration management.
  /// </para>
  /// <para>
  /// Key features exposed include programmatic prompting for missing information (such as API keys),
  /// two-way updates between user interface and underlying settings data, as well as
  /// retrieval of values for runtime or business logic use. The interface supports scalable extension for new
  /// preference domains or UI surfaces with minimal code changes, following modern architectural practices
  /// in Delphi VCL projects.
  /// </para>
  /// </remarks>
  Settings: ISettings;

  /// <summary>
  /// Interface for managing and switching the main feature modes (Web Search, File Search Disable, Reasoning)
  /// in the File2knowledgeAI application.
  /// </summary>
  /// <remarks>
  /// <para>
  /// <c>IServiceFeatureSelector</c> defines methods to programmatically toggle the primary modes used for search and
  /// reasoning features. Implementations of this interface ensure consistent state management and provide the
  /// capability to synchronize UI elements (such as toggle buttons or labels) with internal feature logic.
  /// </para>
  /// <para>
  /// This interface is intended to standardize the way in which the application activates, deactivates, or combines
  /// its core functional features at runtime, facilitating both user-driven and code-driven feature changes.
  /// </para>
  /// </remarks>
  ServiceFeatureSelector: IServiceFeatureSelector;

  /// <summary>
  /// Interface for resource editor components providing methods to manage and synchronize
  /// vector resource data and related UI controls in the File2knowledgeAI application.
  /// </summary>
  /// <remarks>
  /// Implementations of this interface are responsible for refreshing the editor view and
  /// re-initializing any file attachments or metadata displayed in the UI.
  /// Typical use cases include updating the visible state after data changes or file operations,
  /// and ensuring consistent synchronization between persistent data and user interface components.
  /// </remarks>
  VectorResourceEditor: IVectorResourceEditor;

  /// <summary>
  /// Central controller for managing associations between file names and FileUploadIds
  /// within the File2knowledgeAI project.
  /// </summary>
  /// <remarks>
  /// This class coordinates file attachment management and state transitions, enabling
  /// the UI to add, remove, and validate files associated with vector resources.
  /// It maintains separate “snapshot” and “draft” dictionaries for transactional safety,
  /// integrates with helper units for dictionary operations, and ensures consistency
  /// between client- and server-side data.
  /// <para>
  /// * Intended for use with Helper.FileUploadID.Dictionary and UI.VectorResourceEditor.VCL.
  /// </para>
  /// </remarks>
  FileUploadIdController: IFileUploadIdController;

implementation

end.

/// <summary>
/// The <c>Manager.IoC</c> unit implements a basic Inversion of Control (IoC) container that
/// provides dependency injection capabilities for Delphi applications.
/// </summary>
/// <remarks>
/// <para>
/// This unit defines key components for managing dependency registrations and resolutions:
/// </para>
/// <para>
/// - <c>TLifetime</c>: An enumeration that specifies whether an instance should be created as a transient object
/// or maintained as a singleton throughout the application's lifetime.
/// </para>
/// <para>
/// - <c>TRegistrationInfo</c>: A record that stores registration details for a type, including the factory method,
/// the instance (for singletons), and the lifetime setting.
/// </para>
/// <para>
/// - <c>TIoCContainer</c>: The main container class that maintains a registry of dependencies and provides methods
/// to register and resolve interface implementations based on their type and an optional identifier.
/// </para>
/// <para>
/// This IoC container enables decoupled and modular design by allowing objects to be instantiated and managed
/// at runtime. It supports both transient and singleton lifetimes, facilitating flexible dependency management
/// across the application.
/// </para>
/// </remarks>
unit Manager.IoC;

interface

uses
  System.SysUtils, System.Classes, System.TypInfo, System.Generics.Collections;

type
  /// <summary>
  /// Definition of the lifecycle.
  /// </summary>
  TLifetime = (
    /// <summary>
    /// Instances can be recreated if needed.
    /// </summary>
    Transient,
    /// <summary>
    /// Remains constant throughout the application.
    /// </summary>
    Singleton
  );

  /// <summary>
  /// Storage structure for a registration record.
  /// </summary>
  TRegistrationInfo = record
    Instance: IInterface;               // For singletons
    FactoryMethod: TFunc<IInterface>;   // Function returning an interface
    Lifetime: TLifetime;
  end;

  /// <summary>
  /// The <c>TIoCContainer</c> class implements a simple Inversion of Control (IoC) container
  /// for managing dependency registrations and resolutions in Delphi applications.
  /// </summary>
  /// <remarks>
  /// <para>
  /// TIoCContainer maintains an internal registry that maps interface types (optionally keyed
  /// by a name) to registration records containing factory methods and lifetime settings. This allows
  /// for flexible creation and management of object instances at runtime.
  /// </para>
  /// <para>
  /// The container supports two lifetimes:
  /// <c>Transient</c>: A new instance is created every time the dependency is resolved.
  /// <c>Singleton</c>: A single instance is created and shared throughout the application's lifetime.
  /// </para>
  /// <para>
  /// Use the <c>RegisterType</c> methods to register a dependency, and the <c>Resolve</c> method to retrieve
  /// an instance of a registered dependency.
  /// </para>
  /// </remarks>
  TIoCContainer = class
  private
    // Using a key of type string combining the interface name and an optional identifier
    FRegistry: TDictionary<string, TRegistrationInfo>;
    /// <summary>
    /// Generates a unique registration key for the given interface type and an optional identifier.
    /// </summary>
    /// <typeparam name="T">
    /// The interface type for which the key is generated.
    /// </typeparam>
    /// <param name="AName">
    /// An optional name to differentiate multiple registrations of the same interface.
    /// </param>
    /// <returns>
    /// A string representing the unique key for the registration.
    /// </returns>
    function GetRegistrationKey<T>(const AName: string): string;
  public
    constructor Create;
    destructor Destroy; override;
    /// <summary>
    /// Registers a dependency for the interface type T using a factory lambda function.
    /// </summary>
    /// <typeparam name="T">
    /// The interface type to register.
    /// </typeparam>
    /// <param name="AName">
    /// An optional identifier to differentiate multiple registrations for the same interface.
    /// </param>
    /// <param name="AFactory">
    /// A lambda function that creates and returns an instance of type T.
    /// </param>
    /// <param name="ALifetime">
    /// Specifies the lifetime of the instance; use <c>Transient</c> for a new instance on each resolve,
    /// or <c>Singleton</c> to share a single instance.
    /// </param>
    procedure RegisterType<T: IInterface>(const AName: string; AFactory: TFunc<T>; ALifetime: TLifetime = TLifetime.Transient); overload;
    /// <summary>
    /// Registers a dependency for the interface type T using a factory lambda function.
    /// This overload does not require an identifier.
    /// </summary>
    /// <typeparam name="T">
    /// The interface type to register.
    /// </typeparam>
    /// <param name="AFactory">
    /// A lambda function that creates and returns an instance of type T.
    /// </param>
    /// <param name="ALifetime">
    /// Specifies the lifetime of the instance; use <c>Transient</c> for a new instance on each resolve,
    /// or <c>Singleton</c> to share a single instance.
    /// </param>
    procedure RegisterType<T: IInterface>(AFactory: TFunc<T>; ALifetime: TLifetime = TLifetime.Transient); overload;
    /// <summary>
    /// Resolves an instance of the registered interface type T.
    /// </summary>
    /// <typeparam name="T">
    /// The interface type to resolve.
    /// </typeparam>
    /// <param name="AName">
    /// An optional identifier that must match the one used during registration.
    /// </param>
    /// <returns>
    /// An instance of type T. If the dependency was registered as a singleton, the same instance is returned
    /// on subsequent calls. For transient registrations, a new instance is created.
    /// </returns>
    function Resolve<T: IInterface>(const AName: string = ''): T;
  end;

var
  /// <summary>
  /// A global instance of the <c>TIoCContainer</c> used for dependency injection across the application.
  /// </summary>
  /// <remarks>
  /// This variable holds the container that manages registrations and resolutions of dependencies.
  /// It is instantiated during application initialization and released during finalization,
  /// ensuring that all registered services are available throughout the application's lifetime.
  /// </remarks>
  IoC: TIoCContainer;

implementation

{ TIoCContainer }

constructor TIoCContainer.Create;
begin
  inherited Create;
  FRegistry := TDictionary<string, TRegistrationInfo>.Create;
end;

destructor TIoCContainer.Destroy;
begin
  FRegistry.Free;
  inherited;
end;

function TIoCContainer.GetRegistrationKey<T>(const AName: string): string;
begin
  Result := GetTypeName(TypeInfo(T));
  if not AName.Trim.IsEmpty then
    Result := Result + '|' + AName;
end;

procedure TIoCContainer.RegisterType<T>(const AName: string; AFactory: TFunc<T>; ALifetime: TLifetime);
var
  RegistrationKey: string;
  Registration: TRegistrationInfo;
begin
  RegistrationKey := GetRegistrationKey<T>(AName);

  Registration.Lifetime := ALifetime;
  Registration.Instance := nil;
  {--- Wrapping the lambda to return an IInterface }
  Registration.FactoryMethod := function: IInterface
  begin
    Result := AFactory();
  end;

  FRegistry.Add(RegistrationKey, Registration);
end;

procedure TIoCContainer.RegisterType<T>(AFactory: TFunc<T>;
  ALifetime: TLifetime);
begin
  RegisterType<T>(EmptyStr, AFactory, ALifetime);
end;

function TIoCContainer.Resolve<T>(const AName: string): T;
var
  RegistrationKey: string;
  Registration: TRegistrationInfo;
  Intf: IInterface;
begin
  RegistrationKey := GetRegistrationKey<T>(AName);

  if not FRegistry.TryGetValue(RegistrationKey, Registration) then
    raise Exception.CreateFmt('Type %s not registered in the IoC container with the name "%s"', [GetTypeName(TypeInfo(T)), AName]);

  case Registration.Lifetime of
    TLifetime.Singleton:
      begin
        if Registration.Instance = nil then
        begin
          Registration.Instance := Registration.FactoryMethod();
          {--- Update the record in the dictionary }
          FRegistry[RegistrationKey] := Registration;
        end;
        Intf := Registration.Instance;
      end;
    TLifetime.Transient:
      Intf := Registration.FactoryMethod();
  end;

  {--- Convert to type T (ensures the object supports the interface) }
  Result := T(Intf);
end;

initialization
  IoC := TIoCContainer.Create;
finalization
  IoC.Free;
end.

unit Manager.TemplateProvider;

(*
  DESIGN NOTE:
  ============

  This component dynamically manages template loading for the v1/responses endpoint demo.
  - The "AlwaysReloading" mode (see TemplateAllwaysReloading) is ideal during development:
    it reloads template files on every access, making quick iterations easy without restarting the app.
  - The "NeverReloading" mode (see TemplateNeverReloading) is intended for a more typical/stable use,
    where files are loaded just once for performance.

  No advanced caching logic here—this is intentional:
  goal = clarity & simplicity for the community.

*)

interface

uses
  System.SysUtils, System.IOUtils, Manager.Intf;

const
  TEMPLATE_PATH = '..\..\template';

type
  TTemplateType = (main_html, js_response, js_prompt, js_waitfor);

  TTemplateTypeHelper = record Helper for TTemplateType
  private
    const
      FileNames: array[TTemplateType] of string = (
        'InitialHtml.htm',
        'DisplayTemplate.js',
        'PromptTemplate.js',
        'ReasoningTemplate.js'
      );
  public
    function ToString: string;
  end;

  TEdgeInjection = class(TInterfacedObject, ITemplateProvider)
  private
    FInitialHtml: string;
    FDisplayTemplate: string;
    FReasoningTemplate: string;
    FPromptTemplate: string;
    FAlwaysReloading: Boolean;
    FPath: string;
    function LoadTemplate(const FileName: string): string;
    procedure InitializeTemplates;
    function GetInitialHtml: string;
    function GetDisplayTemplate: string;
    function GetReasoningTemplate: string;
    function GetPromptTemplate: string;
    function GetPath(const Path: string; const BaseDir: string = ''): string;
  public
    constructor Create;

    /// <summary>
    /// Enables automatic reloading of template files from the specified directory on each access.
    /// This is recommended for development or rapid prototyping, as it reflects any changes to the template files immediately.
    /// </summary>
    /// <param name="APath">
    /// Optional path to the directory containing template files. If empty, uses the default template path.
    /// </param>
    procedure TemplateAllwaysReloading(const APath: string = '');

    /// <summary>
    /// Disables automatic reloading, causing all template files to be loaded only once and cached in memory.
    /// This improves performance and stability for production use, but changes to template files require an application restart.
    /// </summary>
    procedure TemplateNeverReloading;

    /// <summary>
    /// Sets the directory path where template files are located.
    /// </summary>
    /// <param name="Value">
    /// The file system path to use for loading template files.
    /// </param>
    procedure SetTemplatePath(const Value: string);

    /// <summary>
    /// Gets the HTML template used for initial page rendering.
    /// </summary>
    /// <returns>
    /// The content of the initial HTML template.
    /// </returns>
    property InitialHtml: string read GetInitialHtml;

    /// <summary>
    /// Gets the JavaScript template used to display OpenAI responses.
    /// </summary>
    /// <returns>
    /// The content of the response display JavaScript template.
    /// </returns>
    property DisplayTemplate: string read GetDisplayTemplate;

    /// <summary>
    /// Gets the JavaScript template used for system reasoning and asynchronous operations.
    /// </summary>
    /// <returns>
    /// The content of the reasoning JavaScript template.
    /// </returns>
    property ReasoningTemplate: string read GetReasoningTemplate;

    /// <summary>
    /// Gets the JavaScript template used for user prompt input.
    /// </summary>
    /// <returns>
    /// The content of the prompt JavaScript template.
    /// </returns>
    property PromptTemplate: string read GetPromptTemplate;
  end;

implementation

{ TEdgeInjection }

constructor TEdgeInjection.Create;
begin
  inherited Create;
  FPath := TEMPLATE_PATH;
  FAlwaysReloading := False;
  InitializeTemplates;
end;

function TEdgeInjection.GetDisplayTemplate: string;
begin
  if FAlwaysReloading then
    FDisplayTemplate := LoadTemplate(js_response.ToString);
  Result := FDisplayTemplate;
end;

function TEdgeInjection.GetInitialHtml: string;
begin
  if FAlwaysReloading then
    FInitialHtml := LoadTemplate(main_html.ToString);
  Result := FInitialHtml;
end;

function TEdgeInjection.GetPath(const Path, BaseDir: string): string;
begin
  if TPath.IsPathRooted(Path) then
    Result := Path
  else
    if not BaseDir.Trim.IsEmpty then
      Result := TPath.GetFullPath(TPath.Combine(BaseDir, Path))
    else
      Result := TPath.GetFullPath(Path);
end;

function TEdgeInjection.GetPromptTemplate: string;
begin
  if FAlwaysReloading then
    FPromptTemplate := LoadTemplate(js_prompt.ToString);
  Result := FPromptTemplate;
end;

function TEdgeInjection.GetReasoningTemplate: string;
begin
  if FAlwaysReloading then
    FReasoningTemplate := LoadTemplate(js_waitfor.ToString);
  Result := FReasoningTemplate;
end;

procedure TEdgeInjection.InitializeTemplates;
begin
  FInitialHtml := LoadTemplate(main_html.ToString);
  FDisplayTemplate := LoadTemplate(js_response.ToString);
  FPromptTemplate := LoadTemplate(js_prompt.ToString);
  FReasoningTemplate := LoadTemplate(js_waitfor.ToString);
end;

function TEdgeInjection.LoadTemplate(const FileName: string): string;
begin
  var GetHtmlPath := TPath.Combine(GetPath(FPath), FileName);
  if TFile.Exists(GetHtmlPath) then
    Result := TFile.ReadAllText(GetHtmlPath, TEncoding.UTF8)
  else
    raise Exception.CreateFmt('The template file was not found : %s', [GetHtmlPath]);
end;

procedure TEdgeInjection.SetTemplatePath(const Value: string);
begin
  FPath := Value;
end;

procedure TEdgeInjection.TemplateAllwaysReloading(const APath: string);
begin
  {--- Enable lazy loading - do not reload all models here as this would penalize performance }
  if not APath.Trim.IsEmpty then
    FPath := APath;
  FAlwaysReloading := True;
end;

procedure TEdgeInjection.TemplateNeverReloading;
begin
  FAlwaysReloading := False;
end;

{ TTemplateTypeHelper }

function TTemplateTypeHelper.ToString: string;
begin
  Result := FileNames[Self];
end;

end.

unit Manager.Types;

interface

uses
  System.SysUtils, System.StrUtils;

type
  TFeatureType = (sf_webSearch, sf_fileSearchDisabled, sf_reasoning);
  TFeatureModes = set of TFeatureType;

  TPageSelector = (psHistoric, psFileSearch, psWebSearch, psReasoning, psVectorFile, psSettings);

  TPageSelectorHelper = record Helper for TPageSelector
  private
    const
      Names: array[TPageSelector] of string = (
        'Chat History',
        'File Search',
        'Web Search',
        'Reasoning',
        'Vector File',
        'Settings'
      );

      Icons: array[TPageSelector] of string = (
        '', '', '', '', '', ''
      );

      DefaultPage = psHistoric;
  public
    constructor Create(const Value: string);
    function ToString: string;
    function ToIcon: string;
    function IndexOf: Integer;
    class function FromIndex(Index: Integer): TPageSelector; static;
    class function FromText(Value: string): TPageSelector; static;
    class function FromIcon(Value: string): TPageSelector; static;
    class function IconToPage(const Value: string): TPageSelector; static;
    class function Default: TPageSelector; static;
    class function Count: Integer; static;
    class function AllIcons: string; static;
  end;

const
  ResponsesPages = [psFileSearch, psWebSearch, psReasoning];

implementation


{ TPageSelectorHelper }

class function TPageSelectorHelper.AllIcons: string;
begin
  Result := String.Join(#10, Icons);
end;

class function TPageSelectorHelper.Count: Integer;
begin
  Result := Length(Names);
end;

constructor TPageSelectorHelper.Create(const Value: string);
begin
  var index := IndexStr(Value.ToLower, string.Join(#10, Names).ToLower.Split([#10]));
  if index = -1 then
    raise Exception.CreateFmt('Page Selector: "%s" page not found', [Value]);

  Self := TPageSelector(index);
end;

class function TPageSelectorHelper.Default: TPageSelector;
begin
  Result := DefaultPage;
end;

class function TPageSelectorHelper.FromIcon(Value: string): TPageSelector;
begin
  var Index := IndexStr(Value, Icons);
  if Index = -1 then
    raise Exception.CreateFmt('Page "%s" not found', [Value]);
  Result := FromIndex(Index);
end;

class function TPageSelectorHelper.FromIndex(Index: Integer): TPageSelector;
begin
  if (Index >= 0) and (Index < Count) then
    Result := TPageSelector(Index)
  else
    Result := Default;
end;

class function TPageSelectorHelper.FromText(Value: string): TPageSelector;
begin
  var Index := IndexStr(Value, Names);
  if Index = -1 then
    raise Exception.CreateFmt('Page "%s" not found', [Value]);
  Result := FromIndex(Index);
end;

class function TPageSelectorHelper.IconToPage(
  const Value: string): TPageSelector;
begin
  for var index := Ord(Low(TPageSelector)) to Ord(High(TPageSelector)) do
    if Icons[TPageSelector(index)] = Value then
      Exit(TPageSelector(index));
  raise EArgumentException.CreateFmt('Unknown icon "%s"', [Value]);
end;

function TPageSelectorHelper.IndexOf: Integer;
begin
  Result := Integer(Self);
end;

function TPageSelectorHelper.ToIcon: string;
begin
  Result := Icons[Self];
end;

function TPageSelectorHelper.ToString: string;
begin
  Result := Names[Self];
end;

end.

unit Manager.Utf8Mapping;

interface

uses
  Winapi.Windows, System.SysUtils, System.Classes, System.Character, System.RegularExpressions,
  System.NetEncoding;

type
  TUtf8Mapping = record
    class function CleanTextAsUTF8(const Value: string): string; static;
  end;

implementation

{ TUtf8Mapping }

class function TUtf8Mapping.CleanTextAsUTF8(const Value: string): string;
var
  i: Integer;
  c: Char;
begin
  {--- Replace NBSP (U+00A0) with a normal space }
  Result := StringReplace(Value, #$00A0, ' ', [rfReplaceAll]);

  {--- Removal of control characters (< U+0020, except #9/#10/#13) }
  Result := TRegEx.Replace(Result,
       '[\x00-\x08\x0B-\x0C\x0E-\x1F]', '', [roCompiled]);

  {--- Removes isolated surrogates and unicode noncharacters}
  var San := '';
  for i := 1 to Length(Result) do
    begin
      c := Result[i];
      {--- isolated surrogates }
      if (Ord(c) >= $D800) and (Ord(c) <= $DFFF) then Continue;
      {--- unicode noncharacters }
      if (Ord(c) = $FFFE) or (Ord(c) = $FFFF) then Continue;
      San := San + c;
    end;

  Result := San;
end;

end.

unit Manager.WebServices;

interface

uses
  Winapi.Windows, Winapi.ShellAPI, System.SysUtils;

type
  TWebUrlManager = record
  public
    class procedure Open(const Url: string); static;
  end;

implementation

{ TWebUrlManager }

class procedure TWebUrlManager.Open(const Url: string);
begin
  if not Url.Trim.IsEmpty then
    ShellExecute(0, 'open', PChar(URL), nil, nil, SW_SHOWNORMAL);
end;

end.

unit Model.VectorResource;

interface

uses
  System.SysUtils, System.Classes, System.JSON, System.Generics.Collections, System.NetEncoding,
  REST.Json.Types,
  GenAI, GenAI.Types, JSON.Resource;

type
  TVectorResourceItem = class
  strict private
    FImage: string;
    FDescription: string;
    FName: string;
    FInstructions: string;
    FFiles: TArray<string>;
    FGithub: string;
    FGetit: string;
    FFileUploadId: TArray<string>;
    FVectorStoreId: string;
  public
    class function Delete(var Arr: TArray<string>; index: NativeInt): Boolean;
    function GetImageStream: TStream;
    function GetFileContent(const Index: Integer): string;
    procedure DeleteFile(index: NativeInt);
    procedure DeleteFileUploadId(index: NativeInt);
    procedure DeleteFilePair(index: NativeInt);
    property Image: string read FImage write FImage;
    property Description: string read FDescription write FDescription;
    property Name: string read FName write FName;
    property Instructions: string read FInstructions write FInstructions;
    property Files: TArray<string> read FFiles write FFiles;
    property Github: string read FGithub write FGithub;
    property Getit: string read FGetit write FGetit;
    property FileUploadId: TArray<string> read FFileUploadId write FFileUploadId;
    property VectorStoreId: string read FVectorStoreId write FVectorStoreId;
  end;

  TVectorResourceList = class(TJSONResource)
  strict private
    FItemIndex: Integer;
    FData: TArray<TVectorResourceItem>;
    class var FInstance: TVectorResourceList;
  public
    procedure Clear;
    property ItemIndex: Integer read FItemIndex write FItemIndex;
    property Data: TArray<TVectorResourceItem> read FData write FData;
    class function Instance: TVectorResourceList; static;
    class function Reload(const FileName: string = ''): TVectorResourceList; static;
    destructor Destroy; override;
  end;

  TVectorResourceListProp = record
    class function ItemIndex: string; static; inline;
    class function Name: string; static; inline;
    class function Data: string; static; inline;
   end;

implementation

uses
  GenAI.Httpx, GenAI.NetEncoding.Base64, System.Net.HttpClient, System.IOUtils;

{ TVectorResourceItem }

class function TVectorResourceItem.Delete(var Arr: TArray<string>;
  index: NativeInt): Boolean;
begin
  if (Cardinal(Index) < Cardinal(Length(Arr))) then
    begin
      System.Delete(Arr, Index, 1);
      Exit(True);
    end;
  Result := False;
end;

procedure TVectorResourceItem.DeleteFile(index: NativeInt);
begin
  Delete(FFiles, index);
end;

procedure TVectorResourceItem.DeleteFilePair(index: NativeInt);
begin
  DeleteFileUploadId(index);
  DeleteFile(index);
end;

procedure TVectorResourceItem.DeleteFileUploadId(index: NativeInt);
begin
  Delete(FFileUploadId, index);
end;

function TVectorResourceItem.GetFileContent(const Index: Integer): string;
var
  Base64Text: string;
begin
  if (Index < 0) or (Index >= Length(FFiles)) then
    raise Exception.CreateFmt('Files(%s): Index out of bounds', [Index]);

  var FileName := Files[Index];

  if FileName.Trim.IsEmpty or not FileExists(FileName) then
    Exit('');

  {--- Retrieve raw text as Base64 }
  if FileName.Trim.ToLower.StartsWith('http') then
    Base64Text := Thttpx.LoadDataToBase64(Files[Index])
  else
    Base64Text := GenAI.NetEncoding.Base64.EncodeBase64(FileName);

  {--- Decode and convert to UTF-8 }
  Result := TEncoding.UTF8.GetString( TNetEncoding.Base64String.DecodeStringToBytes(Base64Text) );
end;

function TVectorResourceItem.GetImageStream: TStream;
var
  Base64Text: string;
begin
  if FImage.Trim.IsEmpty or not FileExists(FImage) then
    Exit(nil);

  {--- Consistently get a Base-64 string, without direct I/O }
  if FImage.StartsWith('http', True) then
    Base64Text := THttpx.LoadDataToBase64(FImage)
  else
  if TFile.Exists(FImage) then
    Base64Text := GenAI.NetEncoding.Base64.EncodeBase64(FImage)
  else
    Base64Text := FImage;

  {--- Convert Base-64 -> memory stream (business layer) }
  Result := TMemoryStream.Create;
  try
    DecodeBase64ToStream(Base64Text, Result);
    Result.Position := 0;
  except
    Result.Free;
    raise;
  end;
end;

{ TVectorResourceList }

procedure TVectorResourceList.Clear;
begin
  for var Item in Data do
    Item.Free;
  FItemIndex := -1;
  FData := [];
end;

destructor TVectorResourceList.Destroy;
begin
  Clear;
  inherited;
end;

class function TVectorResourceList.Instance: TVectorResourceList;
begin
  if not Assigned(FInstance) then
    FInstance := TVectorResourceList.Load as TVectorResourceList;
  Result := FInstance;
end;

class function TVectorResourceList.Reload(
  const FileName: string): TVectorResourceList;
begin
  FInstance.Free;
  FInstance := TVectorResourceList.Load(FileName) as TVectorResourceList;
  Result := FInstance;
end;

{ TVectorResourceListProp }

class function TVectorResourceListProp.Data: string;
begin
  Result := 'data';
end;

class function TVectorResourceListProp.ItemIndex: string;
begin
  Result := 'itemIndex';
end;

class function TVectorResourceListProp.Name: string;
begin
  Result := 'name';
end;

end.

unit Startup.Context;

(*
  Unit: Startup.Context

  Purpose:
    Provides a centralized and structured initialization context for application startup in the File2knowledgeAI project.
    Encapsulates core interfaces and procedures such as user interface display, service prompts, resizing logic,
    form presentation, and error handling. Enables configuration-driven bootstrapping and supports
    dependency injection for all key startup services.

  Architecture and Design:
    - Exposes the TStartupContext class, which aggregates interfaces and callbacks required during startup.
    - Supports clean separation of startup concerns and enhances testability by allowing granular injection of dependencies.
    - Promotes flexibility and modularity for customizing application bootstrapping logic.

  Usage:
    - Instantiate TStartupContext with required interfaces and procedures when launching application services or forms.
    - Access provided methods to retrieve associated startup dependencies for use throughout the application initialization process.

  Context:
    Intended for use within modules and components that require well-structured and maintainable startup workflows,
    particularly where reuse and customization of initialization logic are priorities in the File2knowledgeAI ecosystem.

  Conventions follow File2knowledgeAI best practices for modular design, maintainability, and clear documentation.
*)

interface

uses
  Manager.Intf, System.SysUtils;

type
  /// <summary>
  /// Provides the initialization context for application startup in the File2knowledgeAI architecture.
  /// </summary>
  /// <remarks>
  /// <para>
  /// - <c>TStartupContext</c> centralizes key interfaces and procedures required during the application startup phase.
  /// It enables configuration-driven bootstrapping by encapsulating dependencies needed to present forms, handle errors,
  /// service prompts, display UI components, and perform layout resizing operations.
  /// </para>
  /// <para>
  /// - This class supports dependency injection for core startup activities, ensuring a clean separation of concerns and
  /// enhanced testability of startup workflows. It is designed for flexibility, allowing custom startup behavior by
  /// providing implementations of the interfaces and procedures through its constructor.
  /// </para>
  /// <para>
  /// - Typical usage involves creating an instance of <c>TStartupContext</c> with appropriate interface and callback
  /// parameters when initializing forms or services in File2knowledgeAI modules.
  /// </para>
  /// </remarks>
  /// <param name="ADisplayer">The displayer interface for UI output handling.</param>
  /// <param name="AServicePrompt">The interface responsible for prompting user actions or services at startup.</param>
  /// <param name="AResizeProc">A procedure to execute dynamic window or layout resizing.</param>
  /// <param name="AFormPresenter">A procedure delegate to launch or display the main application form.</param>
  /// <param name="AOnError">A procedure to handle and display errors encountered during startup.</param>
  TStartupContext = class(TInterfacedObject, IStartupContext)
  private
    FDisplayer : IDisplayer;
    FServicePrompt : IServicePrompt;
    FResizeProc : TProc;
    FFormPresenter : TProc;
    FOnError: TProc;
    function GetDisplayer: IDisplayer;
    function GetServicePrompt: IServicePrompt;
    function GetResizeProc: TProc;
    function GetFormPresenter: TProc;
    function GetOnError: TProc;
  public
    /// <summary>
    /// Initializes a new instance of the <c>TStartupContext</c> class with specified service interfaces and startup procedures.
    /// </summary>
    /// <param name="ADisplayer">Provides the user interface display logic at application startup.</param>
    /// <param name="AServicePrompt">Supplies prompt and user interaction capabilities for initial service operations.</param>
    /// <param name="AResizeProc">A procedure reference for handling dynamic layout or window resizing during startup.</param>
    /// <param name="AFormPresenter">A procedure for presenting or launching the main application form.</param>
    /// <param name="AOnError">A procedure reference responsible for error notification and handling at startup.</param>
    /// <remarks>
    /// Use this constructor to inject all required dependencies and customizable procedures needed for the application's startup workflow. This enables flexible initialization, unit testing, and clear separation of startup responsibilities within the File2knowledgeAI project.
    /// </remarks>
    constructor Create(const ADisplayer: IDisplayer;
      const AServicePrompt: IServicePrompt; const AResizeProc: TProc;
      const AFormPresenter: TProc; const AOnError: TProc);
  end;

implementation

{ TStartupContext }

constructor TStartupContext.Create(const ADisplayer: IDisplayer;
  const AServicePrompt: IServicePrompt; const AResizeProc: TProc;
  const AFormPresenter: TProc; const AOnError: TProc);
begin
  inherited Create;
  FDisplayer := ADisplayer;
  FServicePrompt := AServicePrompt;
  FResizeProc := AResizeProc;
  FFormPresenter := AFormPresenter;
  FOnError := AOnError;
end;

function TStartupContext.GetDisplayer: IDisplayer;
begin
  Result := FDisplayer;
end;

function TStartupContext.GetFormPresenter: TProc;
begin
  Result := FFormPresenter;
end;

function TStartupContext.GetOnError: TProc;
begin
  Result := FOnError;
end;

function TStartupContext.GetResizeProc: TProc;
begin
  Result := FResizeProc;
end;

function TStartupContext.GetServicePrompt: IServicePrompt;
begin
  Result := FServicePrompt;
end;

end.


unit Startup.Service;

(*
  Unit: Startup.Service

  Purpose:
    Implements the startup orchestration logic for the File2knowledgeAI application.
    Encapsulates procedures required to initialize UI components, verify system prerequisites,
    handle user notifications, and activate interactive services during the application launch phase.

  Architecture and Design:
    - Exposes the TStartupService class, which manages the asynchronous startup
      sequence via the injected IStartupContext interface.
    - Promotes modular startup flows by separating orchestration logic from UI/component
      details, supporting clean dependency injection and testability.
    - Coordinates interface clearing, form presenting, dependency checks, user alerts,
      error handling, and service prompt focus in accordance with File2knowledgeAI best practices.

  Usage:
    - Instantiate TStartupService with a configured IStartupContext instance at application launch.
    - Call Run to perform the full application startup sequence, including error notifications and
      responsive UI setup.

  Context:
    Designed for use in File2knowledgeAI modules/components requiring reliable, maintainable,
    and extensible startup workflows. Follows clear modular design and documentation conventions
    throughout the codebase.
*)

interface

uses
  System.Threading, System.SysUtils, System.Classes, System.IOUtils, Winapi.Windows,
  Manager.Intf, Startup.Context;

const
  DLL_ISSUE =
    'To ensure full support for the Edge browser, please copy the "WebView2Loader.dll" file into the executable''s directory.'+ sLineBreak +
    'You can find this file in the project''s DLL folder.';

type
  /// <summary>
  /// Implements the startup workflow for services in the File2knowledgeAI application architecture.
  /// </summary>
  /// <remarks>
  /// <para>
  /// <c>TStartupService</c> coordinates application bootstrapping by using the provided startup context. It manages
  /// UI clearing and presentation, essential resource checks, user notifications, form displaying, error handling, and
  /// service prompt initialization in an asynchronous manner.
  /// </para>
  /// <para>
  /// The class leverages dependency injection through the injected <see cref="IStartupContext"/> interface, ensuring
  /// a clear separation of concerns and improved testability.
  /// </para>
  /// <para>
  /// Typical usage involves instantiating <c>TStartupService</c> with a preconfigured <see cref="IStartupContext"/> and then
  /// invoking <see cref="Run"/> to initialize forms, check runtime prerequisites, and prepare the application interface
  /// for user interaction during startup.
  /// </para>
  /// </remarks>
  TStartupService = class(TInterfacedObject, IStartupService)
  strict private
    FContext: IStartupContext;
  public
    /// <summary>
    /// Initializes a new instance of the <c>TStartupService</c> class with the supplied startup context.
    /// </summary>
    /// <param name="AContext">An instance of <see cref="IStartupContext"/> providing interfaces and procedures
    /// required for structured application startup.</param>
    constructor Create(const AContext: IStartupContext);

    /// <summary>
    /// Executes the coordinated startup sequence for the application or module.
    /// </summary>
    /// <remarks>
    /// This method clears the interface, displays the main form, checks for mandatory runtime libraries,
    /// shows user alerts for missing resources, triggers error handling callbacks if needed, refreshes the session
    /// history view, sets focus on the service prompt, and performs dynamic resizing. All operations are queued
    /// asynchronously on the main thread to avoid blocking the UI.
    /// </remarks>
    procedure Run;
  end;

implementation

{ TStartupService }

constructor TStartupService.Create(const AContext: IStartupContext);
begin
  inherited Create;
  FContext := AContext;
end;

procedure TStartupService.Run;
begin
  TTask.Run(
    procedure()
    begin
      Sleep(800);
      TThread.Queue(nil,
        procedure
        begin
          FContext.GetDisplayer.Clear;
          var AlphablendProc := FContext.GetFormPresenter;
          if Assigned(AlphablendProc) then
            AlphablendProc();
          if not FileExists('WebView2Loader.dll') then
            begin
              AlertService.ShowWarning(DLL_ISSUE);
              var TerminateProc := FContext.GetOnError;
              if Assigned(TerminateProc) then
                TerminateProc();
            end;
          ChatSessionHistoryView.FullRefresh(nil);
          FContext.GetServicePrompt.SetFocus;
          var ResizeProc := FContext.GetResizeProc();
          if Assigned(ResizeProc) then
            ResizeProc();
        end);
    end);
end;

end.


unit UserSettings.Persistence;

(*
  Unit: UserSettings.Persistence

  Purpose:
    Implements persistent storage, loading, and management of user-specific application settings.
    This unit encapsulates all logic for serializing, deserializing, and versioning user preferences,
    supporting robust profile management, profile switching, and reliable round-tripping to JSON-based storage.

  Description:
    - Defines the <c>TSettings</c> class for structured user configuration with complete property mapping.
    - Supplies <c>TSettingsProp</c>, centralizing property name access for all user settings fields.
    - Provides the <c>TIniSettings</c> class and <c>IIniSettings</c> interface to unify loading, saving, and file management.
    - Leverages JSON serialization for portability, human-readability, and backward compatibility.
    - Supports fluent-style manipulation and chained updates to settings, promoting concise and expressive persistence operations.

  Design Notes:
    - Follows the single-responsibility principle with a clear focus on configuration persistence.
    - Separates storage logic from UI binding and business rules for maintainability.
    - Easily extendable for new configuration needs and model evolution.

  Dependencies:
    - Relies on System.JSON and REST.Json for data conversion.
    - Intended to be used by higher-level modules that orchestrate user experience and interface logic.

  Usage:
    Instantiate or resolve an <c>IIniSettings</c> implementation for your persistence needs,
    and interact fluently with the <c>TSettings</c> object to load, query, modify, or save user configuration.
*)

interface

uses
  System.SysUtils, System.Classes, System.JSON, REST.Json.Types, REST.Json,
  Manager.Intf, JSON.Resource;

type
  /// <summary>
  /// Encapsulates all persistent application user settings and provides JSON serialization functionality.
  /// </summary>
  /// <remarks>
  /// <c>TSettings</c> contains all configurable end-user properties such as proficiency, model selection,
  /// API key, identity, and localization details.
  /// The class leverages its <c>TJSONResource</c> ancestor to support serialization and deserialization
  /// from JSON, enabling persistent storage and retrieval of user settings.
  /// <para>
  /// Designed as a singleton, this class ensures a single, consistent settings instance is used
  /// throughout the application. It also provides static class methods for loading and reloading
  /// settings data from files.
  /// </para>
  /// </remarks>
  TSettings = class(TJSONResource)
  strict private
    FProficiency: string;
    FPreferenceName: string;
    FApiKey: string;
    FSearchModel: string;
    FReasoningModel: string;
    FReasoningEffort: string;
    FReasoningSummary: string;
    FWebContextSize: string;
    FTimeOut: string;
    FCountry: string;
    FCity: string;
    class var FInstance: TSettings;
  public
    property Proficiency: string read FProficiency write FProficiency;
    property PreferenceName: string read FPreferenceName write FPreferenceName;
    property ApiKey: string read FApiKey write FApiKey;
    property SearchModel: string read FSearchModel write FSearchModel;
    property ReasoningModel: string read FReasoningModel write FReasoningModel;
    property ReasoningEffort: string read FReasoningEffort write FReasoningEffort;
    property ReasoningSummary: string read FReasoningSummary write FReasoningSummary;
    property WebContextSize: string read FWebContextSize write FWebContextSize;
    property TimeOut: string read FTimeOut write FTimeOut;
    property Country: string read FCountry write FCountry;
    property City: string read FCity write FCity;
    class function Instance: TSettings; static;
    class function Reload(const FileName: string = ''): TSettings; static;
    class destructor Destroy;
  end;

  /// <summary>
  /// Centralizes property name constants for all user settings fields.
  /// </summary>
  /// <remarks>
  /// <c>TSettingsProp</c> provides a set of static functions that return string keys corresponding
  /// to each configurable user setting (such as proficiency, API key, model selection, etc.).
  /// Using these constants ensures consistent property access across the application,
  /// supports dynamic binding and persistence layers, and reduces the risk of errors due to typos.
  /// <para>
  /// This record is specifically designed to enable fluent data handling by supporting
  /// chained method calls when applying or manipulating settings properties.
  /// </para>
  /// </remarks>
  TSettingsProp = record
    class function Proficiency: string; static; inline;
    class function PreferenceName: string; static; inline;
    class function APIKey: string; static; inline;
    class function SearchModel: string; static; inline;
    class function ReasoningModel: string; static; inline;
    class function ReasoningEffort: string; static; inline;
    class function ReasoningSummary: string; static; inline;
    class function WebContextSize: string; static; inline;
    class function TimeOut: string; static; inline;
    class function Country: string; static; inline;
    class function City: string; static; inline;
  end;

  /// <summary>
  /// Handles the loading, saving, and reloading of user settings from persistent storage.
  /// </summary>
  /// <remarks>
  /// TIniSettings provides a simple interface for reading from and writing to user settings files,
  /// encapsulating the persistent instance of <c>TSettings</c> and supporting serialization to and from files.
  /// </remarks>
  TIniSettings = class(TInterfacedObject, IIniSettings)
  private
    FSettings: TSettings;
    function GetSettings: TObject;
  public
    constructor Create;

    /// <summary>
    /// Reloads the user settings from persistent storage.
    /// </summary>
    /// <remarks>
    /// This method replaces the current settings with those loaded from disk.
    /// Typically used to re-synchronize in-memory settings with external changes.
    /// </remarks>
    procedure Reload;

    /// <summary>
    /// Loads settings from the specified file.
    /// </summary>
    /// <param name="FileName">
    /// The file path of the configuration file to load. If empty, the default settings file is used.
    /// </param>
    /// <returns>
    /// Returns the file path used for loading, or an empty string if the operation fails.
    /// </returns>
    function LoadFromFile(FileName: string = ''): string;

    /// <summary>
    /// Saves the current settings to the specified file.
    /// </summary>
    /// <param name="FileName">
    /// The file path where the configuration should be saved. If empty, the default file is used.
    /// </param>
    procedure SaveToFile(FileName: string = '');

    /// <summary>
    /// Gets the settings object being managed.
    /// </summary>
    /// <returns>
    /// Returns the current settings instance as a <c>TObject</c>.
    /// </returns>
    property Settings: TObject read GetSettings;
  end;

implementation

{ TIniSettings }

constructor TIniSettings.Create;
begin
  inherited Create;
  Reload;
end;

function TIniSettings.GetSettings: TObject;
begin
  Result := FSettings;
end;

function TIniSettings.LoadFromFile(FileName: string): string;
begin
  FSettings := TSettings.Reload;
end;

procedure TIniSettings.Reload;
begin
  FSettings := TSettings.Reload;
end;

procedure TIniSettings.SaveToFile(FileName: string);
begin
  FSettings.Save(FileName);
end;

{ TSettings }

class destructor TSettings.Destroy;
begin
  FInstance.Free;
end;

class function TSettings.Instance: TSettings;
begin
  if not Assigned(FInstance) then
    FInstance := TSettings.Load as TSettings;
  Result := FInstance;
end;

class function TSettings.Reload(const FileName: string): TSettings;
begin
  FInstance.Free;
  FInstance := TSettings.Load(FileName) as TSettings;
  Result := FInstance;
end;

{ TSettingsProp }

class function TSettingsProp.APIKey: string;
begin
  Result := 'apiKey';
end;

class function TSettingsProp.City: string;
begin
  Result := 'city';
end;

class function TSettingsProp.Country: string;
begin
  Result := 'country';
end;

class function TSettingsProp.PreferenceName: string;
begin
  Result := 'preferenceName';
end;

class function TSettingsProp.Proficiency: string;
begin
  Result := 'proficiency';
end;

class function TSettingsProp.ReasoningEffort: string;
begin
  Result := 'reasoningEffort';
end;

class function TSettingsProp.ReasoningModel: string;
begin
  Result := 'reasoningModel';
end;

class function TSettingsProp.ReasoningSummary: string;
begin
  Result := 'reasoningSummary';
end;

class function TSettingsProp.SearchModel: string;
begin
  Result := 'searchModel';
end;

class function TSettingsProp.TimeOut: string;
begin
  Result := 'timeOut';
end;

class function TSettingsProp.WebContextSize: string;
begin
  Result := 'webContextSize';
end;

end.


## Gestion de la VCL et interaction avec l'UI - situé dans le dossier 'VCL' du projet.

Cette partie contient:

1. Des Helpers comme la gestion du scroll avec la souris sur un TScrollBox, la gestion de la couleur de fond d'un composant TEdgeBrowser, la création d'arrondi pour un TPanel la correction de coloration d'un OpenDialog quand un thème VCL est appliqué.
    - Helper.ScrollBoxMouseWheel.VCL.pas
    - Helper.WebView2.VCL.pas
    - Helper.PanelRoundedCorners.VCL.pas
    - Helper.OpenDialog.VCL.pas

2. Des displayer pour gérer l'affichage sur un composant TEdgeBrowser ou un composant TMemo
    - Displayer.Edge.VCL.pas
    - Displayer.Memo.VCL.pas

3. La gestion de l'annulation 
    - CancellationButton.VCL.pas

4. Des interactions métier avec l'UI (VCL)
    - Introducer.UserSettings.VCL.pas
    - UI.AlertService.VCL.pas
    - UI.AnimatedVectorLeftPanel.VCL.pas
    - UI.ChatSession.VCL.pas
    - UI.Container.VCL.pas
    - UI.PageSelector.VCL.pas
    - UI.PromptEditor.VCL.pas
    - UI.PromptSelector.VCL.pas
    - UI.ServiceFeatureSelector.VCL.pas
    - UI.Styles.VCL.pas
    - UI.UserSettings.VCL.pas
    - UI.VectorResourceEditor.VCL.pas
    - UI.VectorResourceManager.VCL.pas

5. Unités ajoutées
    - Helper.ListView.VCL.pas
    - Helper.PopupMenu.VCL.pas

### Le code source de ces unités:

unit CancellationButton.VCL;

(*
  Unit: CancellationButton.VCL

  Purpose:
    This unit implements a simple, reusable VCL component for managing "cancellation" actions in user interfaces.
    The class TCancellationVCL wraps a TButton, providing mechanisms to detect, reset, and visually signal
    a cancellation request (e.g., to halt long-running or background operations).
    It supports toggling between normal and cancellation states, making it easy to add cancellation logic
    to any interactive workflow.

  Technical details:
    - TCancellationVCL implements ICancellation for standardized cancellation detection and signaling.
    - Manages button text and event handler swapping to represent normal vs cancellation states.
    - Stores and restores the original button caption and OnClick event to ensure seamless UI integration.
    - Uses a custom "cancel" glyph (Unicode character) for visual feedback in cancellation mode.
    - The Reset method initializes the cancellation state and prepares the button for use; Cancel
      returns the button to its original state.
    - Tracks the cancellation state via the FCancelled property, accessible via IsCancelled.

  Dependencies:
    - Delphi VCL TButton for user interaction.
    - UI.Styles.VCL for consistent button styling across the application.
    - Manager.Intf for interface-based interaction with broader application components.
    - Standard System.Classes and Controls for event and type definitions.

  Quick start for developers:
    - Instantiate TCancellationVCL, passing a TButton to its constructor.
    - Call Reset to switch the button into cancellation mode; the button will now display a "cancel" icon
      and respond to clicks by invoking Cancel.
    - Use IsCancelled to check from your workflow logic whether cancellation was requested.
    - When finished or aborting, call Cancel to restore the button to its original caption and behavior.

  This unit is intended for easy drop-in cancellation support in Delphi VCL applications,
  promoting clarity, user feedback, and minimal code coupling for cancellation functionality.

*)

interface

uses
  System.Classes, Vcl.StdCtrls, Vcl.Controls, Manager.Intf, UI.Styles.VCL, Vcl.Buttons;

type
  /// <summary>
  /// Provides a reusable VCL component for user-initiated cancellation actions in Delphi applications.
  /// <para>
  /// ____________
  /// </para>
  /// <para>
  /// - TCancellationVCL manages a TSpeedButton for workflow cancellation requests. It implements the ICancellation interface
  /// for standardized cancellation signaling and state detection. This class visually indicates the cancellation state,
  /// manages button caption and handler changes, and ensures original button state restoration upon cancellation or reset.
  /// </para>
  /// <remarks>
  /// <para>
  /// - Integrates seamlessly with VCL applications for interactive or long-running operations requiring cancellation support.<br/>
  /// </para>
  /// <para>
  /// - Uses a standard "cancel" glyph and consistent button styling via UI.Styles.VCL.
  /// </para>
  /// <para>
  /// - Original button caption and OnClick event are preserved and restored after cancellation.
  /// </para>
  /// <para>
  /// - The IsCancelled property allows workflow logic to query cancellation state.
  /// </para>
  /// </remarks>
  /// </summary>
  /// <param name="ACancelButton">
  /// The TSpeedButton instance managed for cancellation actions.
  /// </param>
  /// <seealso cref="ICancellation"/>
  /// <seealso cref="Manager.Intf"/>
  TCancellationVCL = class(TInterfacedObject, ICancellation)
  private
    FCancelButton: TSpeedButton;
    FCancelled: Boolean;
    FOldCaption: string;
    FOldOnclick: TNotiFyEvent;
    procedure DoCancelClick(Sender: TObject);
  public
    /// <summary>
    /// Marks the cancellation as requested, restores the original button caption and click handler.
    /// </summary>
    procedure Cancel;

    /// <summary>
    /// Returns True if a cancellation has been requested; otherwise, returns False.
    /// </summary>
    /// <returns>
    /// True if the user has triggered the cancellation action, otherwise False.
    /// </returns>
    function IsCancelled: Boolean;

    /// <summary>
    /// Prepares the managed button for cancellation use by saving its state,
    /// updating the caption to a cancel glyph, and assigning the cancellation handler.
    /// </summary>
    procedure Reset;

    /// <summary>
    /// Initializes the cancellation handler for the specified TSpeedButton.
    /// </summary>
    /// <param name="ACancelButton">
    /// The TSpeedButton instance to be managed for cancellation.
    /// </param>
    constructor Create(ACancelButton: TSpeedButton);
  end;

implementation

{ TCancellationVCL }

procedure TCancellationVCL.Cancel;
begin
  FCancelled := True;
  FCancelButton.Caption := FOldCaption;
  FCancelButton.OnClick := FOldOnclick;
end;

constructor TCancellationVCL.Create(ACancelButton: TSpeedButton);
begin
  inherited Create;
  FCancelButton := ACancelButton;
  if Assigned(FCancelButton) then
    TAppStyle.ApplyCancellationButtonStyle(FCancelButton)
end;

procedure TCancellationVCL.DoCancelClick(Sender: TObject);
begin
  Cancel;
end;

function TCancellationVCL.IsCancelled: Boolean;
begin
  Result := FCancelled;
end;

procedure TCancellationVCL.Reset;
begin
  FCancelled := False;
  FOldCaption := FCancelButton.Caption;
  FOldOnclick := FCancelButton.OnClick;
  FCancelButton.Caption := '';
  FCancelButton.OnClick := DoCancelClick;
end;

end.

unit Displayer.Edge.VCL;

(*
  Unit: Displayer.Edge.VCL

  Purpose:
    This unit implements a flexible, browser-based display layer for chat and AI interactions in Delphi VCL applications,
    leveraging Microsoft’s Edge (WebView2) component. It enables rich, styled markdown and reasoning output,
    user prompts, and integrates copy-to-clipboard and JSON messaging for code samples and dynamic UI actions.

  Technical details:
    - Provides TEdgeDisplayerVCL, which encapsulates all logic for rendering and interacting with chat UI via a TEdgeBrowser.
    - Supports both appending of markdown (via Display/DisplayStream) and explicit injection of user prompts and reasoning UI elements.
    - Handles HTML/JS string escaping for seamless injection, and allows custom script hooks for extended rendering.
    - Processes incoming WebView2 JSON messages for UI events (such as copy-to-clipboard on code samples).
    - Asynchronous UI/JS updates are handled with event callback registration for navigation, message reception, and browser initialization.
    - Enables visual refresh features (Clear, Show, Hide, ScrollToEnd/Top) and dynamically tracks prompt count for responsive layouts.
    - Employs robust error-handling and initialization logic to synchronize WebView state and avoid rendering out-of-order.
    - Encapsulates HTML and JavaScript template injection (loading, styling, etc.) for maintainable and extensible UI control.
    - Helper (TEscapeHelper) provides static methods for safe HTML and JS escaping.

  Dependencies:
    - TEdgeBrowser (Vcl.Edge, WebView2 API) for browser engine.
    - Manager.Intf, Manager.IoC for business logic integration and dependency handling.
    - Helper.WebView2.VCL for convenience functions around Edge.
    - System.JSON for message parsing, clipboard and standard Delphi IO for text/code interoperability.
    - System.Threading, System.SysUtils, System.Classes for async and file operations.
    - Vcl.Clipbrd for clipboard integration.
    - Standard Delphi units for VCL controls and messaging.

  Quick start for developers:
    - Instantiate TEdgeDisplayerVCL, binding it to a form-placed TEdgeBrowser and (optionally) a resize event.
    - Use Display/DisplayStream to append markdown or feedback, Prompt to inject new user prompts, and Show/Hide/Clear for basic visibility.
    - All rendering and copy events are handled internally; extend or customize by overriding code copy events or injection templates as needed.
    - Wire up the control with other application logic via Manager.Intf for integrated, context-aware chat interfaces.

  This unit enables modern, interactive, and visually rich chat and output panels within Delphi VCL apps,
  leveraging the flexibility of HTML/CSS/JS while tightly integrating with native Delphi data and event flows.

*)

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Classes, System.JSON,
  Winapi.WebView2, Winapi.ActiveX, Vcl.Edge, System.IOUtils,
  Manager.Intf, Manager.IoC, Helper.WebView2.VCL, VCL.Clipbrd;

type
  TCopyActionType = procedure (Lang, Code: string) of object;

  TEscapeHelper = record
  public
    class function EscapeJSString(const S: string): string; static;
    class function EscapeHTML(const S: string): string; static;
  end;

  /// <summary>
  /// Implements a rich, browser-based display layer for chat and AI interactions within Delphi VCL applications.
  /// Leverages Microsoft Edge (WebView2) to provide styled markdown, prompts, reasoning display, clipboard integration,
  /// and dynamic UI actions, all encapsulated for seamless use in modern desktop apps.
  /// </summary>
  /// <remarks>
  /// TEdgeDisplayerVCL is designed for flexible chat and code interaction panels in Delphi VCL.
  /// It enables markdown rendering, user prompt injection, copying code samples, and bidirectional JSON messaging with the browser UI.
  /// The control is event-driven and async-ready, cleanly separating rendering logic from business/data layers and
  /// supporting robust template and event overrides.
  /// </remarks>
  /// <example>
  /// Typical usage:
  /// <code>
  /// var Displayer: TEdgeDisplayerVCL;
  /// Displayer := TEdgeDisplayerVCL.Create(TEdgeBrowserComponent, OnResizeHandler);
  /// Displayer.Display('**Hello!** This is markdown.');
  /// Displayer.Prompt('User typed message');
  /// Displayer.ShowReasoning; // Show AI thinking indicator
  /// Displayer.HideReasoning; // Hide it when done
  /// </code>
  /// </example>
  /// <seealso cref="TEdgeBrowser"/>
  /// <seealso cref="Manager.Intf"/>
  /// <seealso cref="Helper.WebView2.VCL"/>
  /// <seealso cref="TEscapeHelper"/>
  TEdgeDisplayerVCL = class(TInterfacedObject, IDisplayer)
  private
    FBrowser: TEdgeBrowser;
    FInitialNavigation: Boolean;
    FBrowserInitialized: Boolean;
    FStreamContent: string;
    FOnCodeCopied: TCopyActionType;
    FPromptCount: Integer;
    FOnResize: TProc<TObject>;
    FReasoningVisible: Boolean;
    procedure DoNavigationCompleted(Sender: TCustomEdgeBrowser;
      IsSuccess: Boolean; WebErrorStatus: COREWEBVIEW2_WEB_ERROR_STATUS);
    procedure DoWebMessageReceived(Sender: TCustomEdgeBrowser;
      Args: TWebMessageReceivedEventArgs);
    procedure EdgeBrowser1CreateWebViewCompleted(Sender: TCustomEdgeBrowser; AResult: HRESULT);
    procedure SetPromptCount(const Value: Integer);
    function GetPromptCount: Integer;
    function GetHeightAfter(Bias: Integer = 300): Integer;
  protected
    procedure CodeCopyEvent(Lang, Code: string); virtual;
    function ExecuteScript(const Script: string): Boolean;
  public
    /// <summary>
    /// Appends the specified text as markdown to the chat display stream.
    /// </summary>
    /// <param name="AText">
    /// The markdown-formatted text to display in the chat interface.
    /// </param>
    /// <returns>
    /// The updated content of the internal display stream.
    /// </returns>
    function Display(const AText: string): string;

    /// <summary>
    /// Appends a flow of markdown text to the display stream, optionally auto-scrolling to the end.
    /// </summary>
    /// <param name="AText">
    /// The markdown-formatted text to append.
    /// </param>
    /// <param name="Scroll">
    /// If True, the display scrolls to after the end; otherwise, it does not scroll. Default is False.
    /// </param>
    /// <returns>
    /// The updated content of the internal display stream.
    /// </returns>
    function DisplayStream(const AText: string; Scroll: Boolean = False): string;

    /// <summary>
    /// Injects a new user prompt bubble into the chat display.
    /// </summary>
    /// <param name="AText">
    /// The user's prompt to be visually represented in the chat UI.
    /// </param>
    procedure Prompt(const AText: string);

    /// <summary>
    /// Scrolls the chat display to the end of the conversation history.
    /// </summary>
    /// <param name="Smooth">
    /// If True, scrolling is animated smoothly; otherwise, it scrolls instantly. Default is False.
    /// </param>
    procedure ScrollToEnd(Smooth: Boolean = False); overload;

    /// <summary>
    /// Scrolls the chat display to a position after the last entry and adds free space.
    /// </summary>
    /// <param name="SizeAfter">
    /// The vertical space in pixels to add after the last chat bubble.
    /// </param>
    /// <param name="Smooth">
    /// If True, performs a smooth animated scroll. Default is True.
    /// </param>
    procedure ScrollToAfterEnd(SizeAfter: Integer; Smooth: Boolean = True); overload;

    /// <summary>
    /// Scrolls to the top of the chat display.
    /// </summary>
    procedure ScrollToTop;

    /// <summary>
    /// Clears the chat history and display content.
    /// </summary>
    procedure Clear;

    /// <summary>
    /// Suspends redrawing of the chat control for batch updates.
    /// </summary>
    procedure BeginUpdateControl;

    /// <summary>
    /// Resumes redrawing of the chat control after batch updates.
    /// </summary>
    procedure EndUpdateControl;

    /// <summary>
    /// Makes the chat display visible.
    /// </summary>
    procedure Show;

    /// <summary>
    /// Hides the chat display from view.
    /// </summary>
    procedure Hide;

    /// <summary>
    /// Displays the reasoning or loading indicator panel in the chat interface, typically used to show
    /// that an AI response is being generated.
    /// </summary>
    procedure ShowReasoning;

    /// <summary>
    /// Hides the reasoning or loading indicator panel from the chat interface, removing any related UI elements.
    /// </summary>
    procedure HideReasoning;

    /// <summary>
    /// Gets or sets the current count of user prompts displayed in the chat.
    /// </summary>
    property PromptCount: Integer read GetPromptCount write SetPromptCount;

    /// <summary>
    /// Initializes a new instance of the <c>TEdgeDisplayerVCL</c> class, binding it to the Edge browser control.
    /// </summary>
    /// <param name="ABrowser">
    /// The Edge browser control component (TEdgeBrowser) used for display.
    /// </param>
    /// <param name="ResizeEvent">
    /// An optional procedure called when the display is resized.
    /// </param>
    constructor Create(const ABrowser: TEdgeBrowser; const ResizeEvent: TProc<TObject>);
  end;

implementation

{ TEdgeDisplayerVCL }

procedure TEdgeDisplayerVCL.BeginUpdateControl;
begin
  SendMessage(FBrowser.Handle, WM_SETREDRAW, WPARAM(False), 0);
end;

procedure TEdgeDisplayerVCL.Clear;
const
  SPACER_DELETE =
    'var el=document.getElementById("edge-spacer");' +
    'if(el){el.remove();}';
begin
  ExecuteScript(SPACER_DELETE);
  FStreamContent := EmptyStr;
  DisplayStream(EmptyStr);
  ResponseTracking.Clear;
  PromptCount := 0;
  Hide;
end;

procedure TEdgeDisplayerVCL.CodeCopyEvent(Lang, Code: string);
begin
  Clipboard.AsText := Code;
end;

constructor TEdgeDisplayerVCL.Create(const ABrowser: TEdgeBrowser;
  const ResizeEvent: TProc<TObject>);
begin
  inherited Create;
  FBrowser := ABrowser;
  FOnResize := ResizeEvent;
  FInitialNavigation := False;
  FBrowserInitialized := False;
  FReasoningVisible := False;
  FOnCodeCopied := CodeCopyEvent;
  FBrowser.OnNavigationCompleted := DoNavigationCompleted;
  FBrowser.OnWebMessageReceived := DoWebMessageReceived;
  FBrowser.OnCreateWebViewCompleted := EdgeBrowser1CreateWebViewCompleted;
  FBrowser.Navigate('about:blank');
  FBrowser.Visible := False;
end;

function TEdgeDisplayerVCL.Display(const AText: string): string;
begin
  try
    {--- Accumulate the Markdown stream }
    FStreamContent := FStreamContent + AText + sLineBreak + sLineBreak;
    Result := FStreamContent;

    {--- Do nothing until the component is ready }
    if not FBrowserInitialized then
      Exit;

    {--- Prepare and inject the JS script for Markdown rendering and adding buttons }
    ExecuteScript(
      Format(TemplateProvider.DisplayTemplate, [TEscapeHelper.EscapeJSString(FStreamContent)])
    );
    ScrollToEnd(False);
  except
    {--- Temporaire pour contrer l'erreur RSS-391 }
  end;
end;

function TEdgeDisplayerVCL.DisplayStream(const AText: string; Scroll: Boolean): string;
begin
  try
    {--- Accumulates the flow }
    FStreamContent := FStreamContent + AText;
    Result := FStreamContent;

    {--- Injects the script }
    ExecuteScript(
      Format(TemplateProvider.DisplayTemplate, [TEscapeHelper.EscapeJSString(FStreamContent)])
    );
    if Scroll then
      ScrollToAfterEnd(GetHeightAfter(300), False);
  except
    {--- Temporaire pour contrer l'erreur RSS-391 }
  end;
end;

procedure TEdgeDisplayerVCL.ScrollToAfterEnd(SizeAfter: Integer; Smooth: Boolean = True);
const
  FREE_SPACE =
    'var spacer = document.getElementById(''edge-spacer'');' +
    'if (!spacer) {' +
    '  spacer = document.createElement(''div'');' +
    '  spacer.id = ''edge-spacer'';' +
    '  document.body.appendChild(spacer);' +
    '}' +
    'spacer.style.height = ''%dpx'';';
  SCROLL_SMOOTH =
    'setTimeout(() => { window.scrollTo({ top: document.body.scrollHeight, behavior: "smooth" }); }, 0);';
  SCROLL =
    'setTimeout(() => { window.scrollTo({ top: document.body.scrollHeight}); }, 0);';
var
  js: string;
  jsscroll: string;
begin
  if SizeAfter > 0 then
    js := Format(FREE_SPACE, [SizeAfter]);

  if Smooth then
    jsscroll := SCROLL_SMOOTH
  else
    jsscroll := SCROLL;

  if js.IsEmpty then
    js := jsscroll
  else
    js := js + jsscroll;

  ExecuteScript(js);
end;

procedure TEdgeDisplayerVCL.ScrollToEnd(Smooth: Boolean = False);
const
  SPACER_DELETE =
    'var el=document.getElementById("edge-spacer");' +
    'if(el){el.remove();}';
  SCROLL_SMOOTH =
    'setTimeout(() => { window.scrollTo({ top: document.body.scrollHeight, behavior: "smooth" }); }, 0);';
  SCROLL =
    'setTimeout(() => { window.scrollTo({ top: document.body.scrollHeight}); }, 0);';
begin
  if Smooth then
    ExecuteScript(SPACER_DELETE + SCROLL_SMOOTH)
  else
    ExecuteScript(SPACER_DELETE + SCROLL);
end;

procedure TEdgeDisplayerVCL.ScrollToTop;
begin
  ExecuteScript('window.scrollTo(0, 0), , behavior: "smooth";');
end;

procedure TEdgeDisplayerVCL.SetPromptCount(const Value: Integer);
begin
  FPromptCount := Value;
  if Assigned(FOnResize) then
    FOnResize(Self);
end;

procedure TEdgeDisplayerVCL.Show;
begin
  if not FBrowser.Visible then
    FBrowser.Visible := True;
end;

procedure TEdgeDisplayerVCL.ShowReasoning;
begin
  if FReasoningVisible then
    Exit;

  FReasoningVisible := True;
  var cpt := 0;
  if FBrowserInitialized then
    while not ExecuteScript(TemplateProvider.ReasoningTemplate) and (cpt < 15) do
      begin
        Inc(cpt);
      end;
  ScrollToAfterEnd(GetHeightAfter(400), False);
end;

procedure TEdgeDisplayerVCL.DoNavigationCompleted(Sender: TCustomEdgeBrowser;
  IsSuccess: Boolean; WebErrorStatus: COREWEBVIEW2_WEB_ERROR_STATUS);
begin
  if not IsSuccess then Exit;
  if not FInitialNavigation then
  begin
    Sender.NavigateToString(TemplateProvider.InitialHtml);
    FInitialNavigation := True;
    Exit;
  end;
end;

procedure TEdgeDisplayerVCL.DoWebMessageReceived(
  Sender: TCustomEdgeBrowser;
  Args: TWebMessageReceivedEventArgs);
var
  WebArgs: ICoreWebView2WebMessageReceivedEventArgs;
  pMsg: PWideChar;
  rawJson: string;
  jsonVal: TJSONValue;
  jo: TJSONObject;
begin
  {--- Retrieves the interface }
  WebArgs := Args as ICoreWebView2WebMessageReceivedEventArgs;

  {--- Calls the Get_WebMessageAsJson method to get the JSON }
  if WebArgs.Get_WebMessageAsJson(pMsg) <> S_OK then
    Exit;
  try
    rawJson := pMsg;
  finally
    CoTaskMemFree(pMsg);
  end;

  {--- Now we can test the "ready" message }
  if SameText(rawJson, '"ready"') then
  begin
    FBrowserInitialized := True;

    {--- Re-injects accumulated content on backspace }
    if FStreamContent <> '' then
      ExecuteScript(
        Format(TemplateProvider.DisplayTemplate, [TEscapeHelper.EscapeJSString(FStreamContent)]));
    Exit;
  end;

  {--- Treat the object directly }
  jsonVal := TJSONObject.ParseJSONValue(rawJson);
  try
    if (jsonVal is TJSONObject) then
    begin
      jo := jsonVal as TJSONObject;
      if jo.GetValue<string>('event') = 'copy' then
      begin
        if Assigned(FOnCodeCopied) then
          FOnCodeCopied(
            jo.GetValue<string>('lang'),
            jo.GetValue<string>('text')
          );
        Exit;
      end;
    end;
  finally
    jsonVal.Free;
  end;
end;

procedure TEdgeDisplayerVCL.EdgeBrowser1CreateWebViewCompleted(
  Sender: TCustomEdgeBrowser; AResult: HRESULT);
var
  Ctrl2      : ICoreWebView2Controller2;
  BaseCtrl   : ICoreWebView2Controller;
  WebView    : ICoreWebView2;
  Col        : TCOREWEBVIEW2_COLOR;
  js         : WideString;
begin
  if AResult <> S_OK then
    Exit;

  {--- Transparent background at controller level (alpha=0) }
  if (Sender as TEdgeBrowser)
     .ControllerInterface
     .QueryInterface(IID_ICoreWebView2Controller2, Ctrl2) = S_OK then
  begin
    Col.A := 0; Col.R := 0; Col.G := 0; Col.B := 0;
    Ctrl2.put_DefaultBackgroundColor(Col);
  end;

  {--- Gets the ICoreWebView2 interface }
  BaseCtrl := (Sender as TEdgeBrowser).ControllerInterface;
  if BaseCtrl.Get_CoreWebView2(WebView) = S_OK then
  begin
    {--- JS to inject (force CSS background) }
    js :=
      'const s=document.createElement("style");' +
      's.textContent=' +
      '"html,body{background-color:#272727!important;}";' +
      'document.head.appendChild(s);';

    {--- we pass PWideChar(js) and nil to avoid having a callback }
    WebView.AddScriptToExecuteOnDocumentCreated(PWideChar(js), nil);
  end;
end;

procedure TEdgeDisplayerVCL.EndUpdateControl;
begin
  SendMessage(FBrowser.Handle, WM_SETREDRAW, WPARAM(True), 0);
  FBrowser.Invalidate;
  FBrowser.Perform(WM_PAINT, 0, 0);
end;

function TEdgeDisplayerVCL.ExecuteScript(const Script: string): Boolean;
begin
  try
    FBrowser.ExecuteScript(Script);
    Exit(True);
  except
    {--- Silent Exception - To avoid RSS-391 error for unpatched 12.1 }
    Exit(False);
  end;
end;

function TEdgeDisplayerVCL.GetHeightAfter(Bias: Integer): Integer;
begin
  Result := FBrowser.Height (*div 2*) - Bias;
  if Result < 0 then
    Result := 0;
end;

function TEdgeDisplayerVCL.GetPromptCount: Integer;
begin
  Result := FPromptCount;
end;

procedure TEdgeDisplayerVCL.Hide;
begin
  FBrowser.Visible := False;
end;

procedure TEdgeDisplayerVCL.HideReasoning;
const
  LOADING = '<div id="loadingBubble" class="chat-bubble assistant loading">Developing a response</div>';
  Script_js = '(() => { const el = document.getElementById("loadingBubble"); if (el) el.remove(); })();';
begin
  if not FBrowserInitialized or not FReasoningVisible then
    Exit;

  ScrollToAfterEnd(GetHeightAfter(400), False);
  var cpt := 0;
  try
    while not ExecuteScript(Script_js) and (cpt <= 15) do
      begin
        Inc(cpt);
      end;

    FStreamContent := StringReplace(FStreamContent, LOADING, '', [rfReplaceAll, rfIgnoreCase]);
  finally
    FReasoningVisible := False;
  end;
end;

procedure TEdgeDisplayerVCL.Prompt(const AText: string);
begin
  if not FBrowserInitialized then
    {--- the browser is not ready yet }
    Exit;

  PromptCount := PromptCount + 1;

  FStreamContent := FStreamContent + sLineBreak +
    Format('<div class="chat-bubble user" style="white-space:pre-wrap;">%s</div>',
           [TEscapeHelper.EscapeHTML(AText)]) +
    sLineBreak;

  {--- Building and injecting the JS that creates the user bubble }
  ExecuteScript(
    Format(TemplateProvider.PromptTemplate, [TEscapeHelper.EscapeJSString(AText)])
  );
end;

{ TEscapeHelper }

class function TEscapeHelper.EscapeHTML(const S: string): string;
const
  Entities: array[0..4] of array[0..1] of string = (
    ('&', '&amp;'),
    ('<', '&lt;'),
    ('>', '&gt;'),
    ('"', '&quot;'),
    ('''', '&#39;')
  );
var
  i: Integer;
begin
  Result := S;
  for i := Low(Entities) to High(Entities) do
    Result := Result.Replace(Entities[i][0], Entities[i][1], [rfReplaceAll]);
end;

class function TEscapeHelper.EscapeJSString(const S: string): string;
var
  i: Integer;
  c: Char;
begin
  Result := '"';
  for i := 1 to Length(S) do
  begin
    c := S[i];
    case c of
      '"': Result := Result + '\"';
      '\': Result := Result + '\\';
      '/': Result := Result + '\/';
      #8: Result := Result + '\b';
      #9: Result := Result + '\t';
      #10: Result := Result + '\n';
      #11: Result := Result + '\v';
      #12: Result := Result + '\f';
      #13: Result := Result + '\r';
    else
      if (Ord(c) < 32) or (Ord(c) > 126) then
        Result := Result + '\u' + IntToHex(Ord(c), 4)
      else
        Result := Result + c;
    end;
  end;
  Result := Result + '"';
end;

end.


unit Displayer.Memo.VCL;

(*
  Unit: Displayer.Memo.VCL

  Purpose:
    This unit provides a simple, robust mechanism for displaying and streaming text output (such as annotations,
    logs, or chat history) within a Delphi VCL TMemo control. It abstracts display operations for both
    line-oriented and stream-oriented text, supporting smooth user interaction and scroll-to-bottom behaviors.

  Technical details:
    - Implements TMemoDisplayerVCL, adhering to the IAnnotationsDisplayer interface for standardized output logic.
    - Supports two main display modes: `Display` (for splitting and appending lines of text) and
      `DisplayStream` (for raw or formatted streaming/appending of text blocks).
    - Handles common newline and line break formats, ensuring text is appended with proper formatting and readability.
    - Provides automatic scrolling to the bottom or caret after each display for optimal user experience.
    - The Clear method clears all lines in the target TMemo.
    - Construction requires a TMemo instance, which can be styled or managed externally as desired.

  Dependencies:
    - Delphi VCL TMemo (Vcl.StdCtrls) for text display.
    - Manager.Intf for interface-based integration.
    - Standard Delphi system units for string, class, and Windows message handling.

  Quick start for developers:
    - Instantiate TMemoDisplayerVCL with the target TMemo control.
    - Use Display to append (and split) text as new lines; use DisplayStream for raw or streaming inserts.
    - Use Clear to reset the display.
    - No setup or teardown logic required—ideal for lightweight, drop-in annotation or logging panels.

  This unit is designed for clarity and minimalism, making text and annotation display effortless
  in Delphi VCL apps, whether for user interaction, logging, or developer-facing output.

*)

interface

uses
  System.SysUtils, System.Classes, Winapi.Messages, Winapi.Windows, Vcl.StdCtrls,
  Vcl.Controls, Manager.Intf;

type
  /// <summary>
  /// Concrete implementation of <see cref="IAnnotationsDisplayer"/> for Delphi VCL applications,
  /// enabling streamlined display, streaming, and management of text content in a TMemo control.
  /// </summary>
  /// <remarks>
  /// <para>
  /// <c>TMemoDisplayerVCL</c> encapsulates robust logic for appending, streaming, and clearing
  /// annotation, log, or chat text in VCL TMemo components. It handles both line-oriented and raw
  /// streaming input, ensures proper handling of line breaks, and provides built-in methods for
  /// scroll-to-top and scroll-to-end behaviors, greatly enhancing user experience.
  /// </para>
  /// <para>
  /// This class is ideally suited for lightweight annotation panels, logging windows, or any scenario
  /// where clear, formatted, and live-updating text output is required in Delphi VCL applications.
  /// External styling and memo control management are fully supported through dependency injection
  /// of the target TMemo instance.
  /// </para>
  /// </remarks>
  TMemoDisplayerVCL = class(TInterfacedObject, IAnnotationsDisplayer)
  private
    FMemo: TMemo;
    function GetText: string;
  public
    /// <summary>
    /// Appends the provided text to the associated <see cref="TMemo"/> control, splitting it into lines as needed.
    /// Automatically scrolls to the latest entry.
    /// </summary>
    /// <param name="AText"> The text to display. Each line break will result in a new line in the memo. </param
    procedure Display(const AText: string);

    /// <summary>
    /// Streams raw or pre-formatted text directly into the associated <see cref="TMemo"/> control. Suitable for live updates or appending blocks of text.
    /// Handles both '\n' and line break characters for consistent display.
    /// </summary>
    /// <param name="AText">The raw or formatted text to append to the memo.</param>
    procedure DisplayStream(const AText: string);

    /// <summary>
    /// Clears all text from the associated <see cref="TMemo"/> control, removing all lines.
    /// </summary>
    procedure Clear;

    /// <summary>
    /// Scrolls the memo to the last line, bringing the most recent content into view.
    /// </summary>
    procedure ScrollToEnd;

    /// <summary>
    /// Scrolls the memo to the first line, bringing the earliest content into view.
    /// </summary>
    procedure ScrollToTop;

    /// <summary>
    /// Determines whether the memo is currently empty.
    /// </summary>
    /// <returns>True if there is no text in the memo; otherwise, False.</returns>
    function IsEmpty: Boolean;

    /// <summary>
    /// Retrieves the full text from the associated <see cref="TMemo"/> control as a single string.
    /// </summary>
    property Text: string read GetText;

    constructor Create(AMemo: TMemo);
  end;

implementation

{ TMemoDisplayerVCL }

procedure TMemoDisplayerVCL.Clear;
begin
  FMemo.Lines.Clear;
end;

constructor TMemoDisplayerVCL.Create(AMemo: TMemo);
begin
  inherited Create;
  FMemo := AMemo;
end;

procedure TMemoDisplayerVCL.Display(const AText: string);
begin
  if not Assigned(FMemo) then
    Exit;

  FMemo.Lines.BeginUpdate;
  try
    var Lines := AText.Split([sLineBreak, #10]);
    if Length(Lines) > 0 then
      begin
        for var L in Lines do
          FMemo.Lines.Add(L);
      end
    else
      begin
        FMemo.Lines.Add(AText);
      end;
    FMemo.Perform(WM_VSCROLL, SB_BOTTOM, 0);
  finally
    FMemo.Lines.EndUpdate;
  end;
end;

procedure TMemoDisplayerVCL.DisplayStream(const AText: string);
begin
  if not Assigned(FMemo) then
    Exit;

  var Txt := AText;

  Txt := StringReplace(AText, '\n', sLineBreak, [rfReplaceAll]);
  Txt := StringReplace(Txt, #10,  sLineBreak, [rfReplaceAll]);

  FMemo.Lines.BeginUpdate;
  try
    FMemo.SelStart   := FMemo.GetTextLen;
    FMemo.SelLength  := 0;
    FMemo.SelText    := Txt;
  finally
    FMemo.Lines.EndUpdate;
  end;

  FMemo.Perform(EM_SCROLLCARET, 0, 0);
end;

function TMemoDisplayerVCL.GetText: string;
begin
  Result := FMemo.Lines.Text;
end;

function TMemoDisplayerVCL.IsEmpty: Boolean;
begin
  Result := FMemo.Lines.Text.Trim.IsEmpty;
end;

procedure TMemoDisplayerVCL.ScrollToEnd;
begin
  FMemo.Perform(WM_VSCROLL, SB_BOTTOM, 0);
end;

procedure TMemoDisplayerVCL.ScrollToTop;
begin
  FMemo.Perform(WM_VSCROLL, SB_TOP, 0);
end;

end.


unit Helper.ListView.VCL;

interface

uses
  Winapi.Windows,
  System.SysUtils, System.Classes, System.UITypes,
  Vcl.Graphics, Vcl.Controls, Vcl.StdCtrls, Vcl.ExtCtrls, Vcl.ComCtrls,
  Vcl.Dialogs, Vcl.Menus, Vcl.Forms, Manager.Intf;

type
  TListViewHelper = record
  private
    FListView: TListView;
  public
    constructor Create(const Value: TLIstView);
    function Add(const ACaption: string): TListViewHelper;
    function AddColumn(Size: Integer; Caption: string): TListViewHelper;
    function DeleteSelected: TListViewHelper;
    function Initialize: TListViewHelper;
    function ContentRefresh: TListViewHelper;
    function CaptionExists(const S: string): Boolean;
    class function Refresh(const Value: TLIstView): TListViewHelper; static;
  end;

implementation

{ TListViewHelper }

function TListViewHelper.Add(const ACaption: string): TListViewHelper;
begin
  FListView.Items.BeginUpdate;
  try
    var NewItem := FListView.Items.Add;
    NewItem.Caption := ACaption;
    Result := Self;
  finally
    FListView.Items.EndUpdate;
  end;
end;

function TListViewHelper.AddColumn(Size: Integer;
  Caption: string): TListViewHelper;
begin
  var Column := FListView.Columns.Add;
  Column.Width := Size;
  Column.Caption := Caption;
  Result := Self;
end;

function TListViewHelper.Initialize: TListViewHelper;
begin
  FListView.Items.BeginUpdate;
  try
    FListView.Columns.ClearAndResetID;
    FListView.Items.Clear;
    FListView.Columns.Clear;
    AddColumn(550, 'Filename');
    AddColumn(250, 'Upload Id');
    Result := Self;
  finally
    FListView.Items.EndUpdate;
  end;
end;

class function TListViewHelper.Refresh(const Value: TLIstView): TListViewHelper;
begin
  Result := TListViewHelper.Create(Value)
    .Initialize
    .ContentRefresh;
end;

function TListViewHelper.CaptionExists(const S: string): Boolean;
begin
  for var Item in FListView.Items do
    if string.Equals(Item.Caption.Trim.ToLower, S.Trim.ToLower) then
      begin
        FListView.Selected := Item;
        Exit(True);
      end;
  Result := False;
end;

function TListViewHelper.ContentRefresh: TListViewHelper;
begin
  FListView.Items.BeginUpdate;
  try
    FListView.Items.Clear;
    var index := 0;
    for var Item in FileStoreManager.Files do
      begin
        var NewItem := FListView.Items.Add;
        NewItem.Caption := Item;
        if index < Length(FileStoreManager.FileUploadIds) then
          NewItem.SubItems.Add(FileStoreManager.FileUploadIds[index]);
        Inc(index);
      end;
    Result := Self;
  finally
    FListView.Items.EndUpdate;
  end;
end;

constructor TListViewHelper.Create(const Value: TLIstView);
begin
  Self.FListView := Value;
end;

function TListViewHelper.DeleteSelected: TListViewHelper;
begin
  if Assigned(FListView.Selected) then
    FListView.DeleteSelected;
end;

end.

unit Helper.OpenDialog.VCL;

(*

A. Returns a boolean with True if successful.

  1. Only one file is returned

      var FileName := 'D:\2026-developpement\OpenAI_File_Search\logos\GeminiLogo.png';
      var Ok :=
              TOpenDialogHelper.Create(nil)
                .Filter('Network Graphics (*.png)|*.png')
                .InitialDir(ExtractFileDir(FileName))
                .Execute(FileName);
      if Ok then
        ShowMessage(FileName);

  2. Multiple files can be returned - Multiple selection.

      var FileName := 'D:\2026-developpement\OpenAI_File_Search\logos\GeminiLogo.png';
      var Ok :=
              TOpenDialogHelper.Create(nil)
                .Filter('Network Graphics (*.png)|*.png')
                .InitialDir(ExtractFileDir(FileName))  <--- is placed in the file folder
                .Execute(FileName, True);
      if Ok then
          for var Item in FileName.Split([#10]) do
              ShowMessage(Item);

B. Returns a string and -1 on abort. Don't test if the file exists.

   1. A single file returned or the string with -1

      var FileName := 'D:\2026-developpement\OpenAI_File_Search\logos\GeminiLogo.png';
      var FileName1 := TOpenDialogHelper.Create(nil)
                .Filter('Network Graphics (*.png)|*.png')
                .InitialDir(ExtractFileDir(FileName))
                .Execute;
      if FileExists(FileName1) then
        ShowMessage(FileName1);

   2. Returns multiple files or the string -1

      var FileName := 'D:\2026-developpement\OpenAI_File_Search\logos\GeminiLogo.png';
      var FileName1 := TOpenDialogHelper.Create(nil)
              .Filter('Network Graphics (*.png)|*.png')
              .InitialDir(ExtractFileDir(FileName))
              .Execute(True);

      for var Item in FileName1.Split([#10]) do
        if FileExists(Item) then
           ShowMessage(Item);

*)

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.ExtDlgs, Vcl.Themes, System.IOUtils;

type
  TOpenDialogHelper = record
  strict private
    FOpenDialog: TOpenDialog;
  public
    constructor Create(ADialog: TOpenDialog);
    function Filter(const S: string): TOpenDialogHelper; inline;
    function FilterIndex(const Index: Integer): TOpenDialogHelper; inline;
    function DefautExt(const S: string): TOpenDialogHelper; inline;
    function InitialDir(const S: string): TOpenDialogHelper; inline;
    function Execute(var FileName: string; Multi: Boolean = False): Boolean; overload; inline;
    function Execute(Multi: Boolean = False): string; overload; inline;

    property Dialog: TOpenDialog read FOpenDialog;
  end;

implementation

{ TOpenDialogHelper }

constructor TOpenDialogHelper.Create(ADialog: TOpenDialog);
begin
  FOpenDialog := TOpenDialog.Create(nil);
end;

function TOpenDialogHelper.DefautExt(const S: string): TOpenDialogHelper;
begin
  FOpenDialog.DefaultExt := S;
  Result := Self;
end;

function TOpenDialogHelper.Execute(Multi: Boolean): string;
begin
  var SavedHooks := TStyleManager.SystemHooks;
  try
    TStyleManager.SystemHooks := SavedHooks - [shDialogs];
    if Multi then
      FOpenDialog.Options := FOpenDialog.Options + [ofAllowMultiSelect]
    else
      FOpenDialog.Options := FOpenDialog.Options - [ofAllowMultiSelect];
    if FOpenDialog.Execute then
      begin
        if Multi then
          Result := FOpenDialog.Files.Text.Trim
        else
          Result := FOpenDialog.FileName
      end
    else
      Result := '-1';
  finally
    FOpenDialog.Free;
    TStyleManager.SystemHooks := SavedHooks;
  end;
end;

function TOpenDialogHelper.Execute(var FileName: string; Multi: Boolean): Boolean;
begin
  var SavedHooks := TStyleManager.SystemHooks;
  try
    TStyleManager.SystemHooks := SavedHooks - [shDialogs];
    if Multi then
      FOpenDialog.Options := FOpenDialog.Options + [ofAllowMultiSelect]
    else
      FOpenDialog.Options := FOpenDialog.Options - [ofAllowMultiSelect];
    Result := FOpenDialog.Execute;
    if Result then
      begin
        if Multi then
          FileName := FOpenDialog.Files.Text.Trim
        else
          FileName := FOpenDialog.FileName;
      end;
  finally
    FOpenDialog.Free;
    TStyleManager.SystemHooks := SavedHooks;
  end;
end;

function TOpenDialogHelper.Filter(const S: string): TOpenDialogHelper;
begin
  FOpenDialog.Filter := S;
  Result := Self;
end;

function TOpenDialogHelper.FilterIndex(const Index: Integer): TOpenDialogHelper;
begin
  FOpenDialog.FilterIndex := index;
  Result := Self;
end;

function TOpenDialogHelper.InitialDir(const S: string): TOpenDialogHelper;
var
  Path: string;
begin
  if S.StartsWith('..\') then
    Path := TPath.GetFullPath(TPath.Combine(TPath.GetDirectoryName(ParamStr(0)), S))
  else
    Path := TPath.GetDirectoryName(S);
  FOpenDialog.InitialDir := Path;
  Result := Self;
end;

end.

unit Helper.PanelRoundedCorners.VCL;

interface

uses
  Winapi.Windows, Vcl.Controls, Vcl.ExtCtrls, System.SysUtils;

type
  TPanelHelper = class helper for TPanel
  public
    procedure PanelResizeHandler(Sender: TObject);
    procedure SetRoundedCorners(const AX, AY: Integer);
  end;

implementation

{ TPanelHelper }

procedure TPanelHelper.PanelResizeHandler(Sender: TObject);
var
  Panel: TPanel;
  CX, CY: Word;
  Area: HRGN;
begin
  Panel := Sender as TPanel;

  {--- Retrieves the rays stored in Tag (low-word = CX, hi-word = CY) }
  CX := LoWord(Panel.Tag);
  CY := HiWord(Panel.Tag);

  {--- Creates the rounded region at the current size }
  Area := CreateRoundRectRgn(0, 0, Panel.Width + 1, Panel.Height + 1, CX, CY);

  {--- Applies the region to the handle (the control takes ownership of Rgn) }
  SetWindowRgn(Panel.Handle, Area, True);
end;

procedure TPanelHelper.SetRoundedCorners(const AX, AY: Integer);
begin
  {--- Stores CX/CY in Tag so that it can be read later }
  Tag := MakeLong(AX, AY);

  {--- Connect the resize handler }
  OnResize := PanelResizeHandler;

  {--- Force an immediate first application }
  PanelResizeHandler(Self);
end;

end.

unit Helper.PopupMenu.VCL;

interface

uses
  Winapi.Windows,
  System.SysUtils, System.Classes, System.UITypes,
  Vcl.Graphics, Vcl.Controls, Vcl.StdCtrls, Vcl.ExtCtrls, Vcl.ComCtrls,
  Vcl.Dialogs, Vcl.Menus, Vcl.Forms;

type
  TPopupMenuHelper = record
  private
    FPopupMenu: TPopupMenu;
  public
    constructor Create(const Value: TPopupMenu);
    function AddItem(const ACaption, AShortCut: string; AOnClick: TNotifyEvent): TPopupMenuHelper;
    property PopupMenu: TPopupMenu read FPopupMenu;
  end;

implementation

{ TPopupMenuHelper }

function TPopupMenuHelper.AddItem(const ACaption, AShortCut: string;
  AOnClick: TNotifyEvent): TPopupMenuHelper;
begin
  var Item := TMenuItem.Create(FPopupMenu);
  Item.Caption := ACaption;
  Item.ShortCut := TextToShortCut(AShortCut);
  Item.OnClick := AOnClick;
  FPopupMenu.Items.Add(Item);
  Result := Self;
end;

constructor TPopupMenuHelper.Create(const Value: TPopupMenu);
begin
  if not Assigned(Value) then
    Self.FPopupMenu := TPopupMenu.Create(Application)
  else
    Self.FPopupMenu := Value;
end;

end.


unit Helper.ScrollBoxMouseWheel.VCL;

interface

uses
  Winapi.Messages, Winapi.Windows, System.Classes, Vcl.Controls, Vcl.Forms;

type
  TScrollBoxMouseWheelHook = class
  private
    FControl: TScrollBox;
    FOldWindowProc: TWndMethod;
    procedure NewWindowProc(var Msg: TMessage);
  public
    constructor Create(AScrollBox: TScrollBox);
  end;

  TScrollBoxHelper = class helper for TScrollBox
  public
    procedure EnableMouseWheelScroll;
  end;

var
  ScrollBoxHooks: TList;

implementation

{ TScrollBoxMouseWheelHook }

constructor TScrollBoxMouseWheelHook.Create(AScrollBox: TScrollBox);
begin
  inherited Create;
  FControl := AScrollBox;
  FOldWindowProc := AScrollBox.WindowProc;
  AScrollBox.WindowProc := NewWindowProc;
end;

procedure TScrollBoxMouseWheelHook.NewWindowProc(var Msg: TMessage);
var
  Delta: Smallint;
begin
  if Msg.Msg = WM_MOUSEWHEEL then
  begin
    Delta := SmallInt(HIWORD(Msg.WParam));
    FControl.VertScrollBar.Position :=
      FControl.VertScrollBar.Position - Delta div WHEEL_DELTA * FControl.VertScrollBar.Increment * 5;
    Msg.Result := 1;
  end
  else
    FOldWindowProc(Msg);
end;

{ TScrollBoxHelper }

procedure TScrollBoxHelper.EnableMouseWheelScroll;
begin
  if ScrollBoxHooks = nil then
    ScrollBoxHooks := TList.Create;

  ScrollBoxHooks.Add(TScrollBoxMouseWheelHook.Create(Self));
end;

procedure HookDestroy;
var
  Hook: TObject;
begin
  if Assigned(ScrollBoxHooks) then
    begin
      for Hook in ScrollBoxHooks do
        Hook.Free;
      ScrollBoxHooks.Free;
    end;
end;

initialization

finalization
  HookDestroy;
end.

unit Helper.WebView2.VCL;

interface

uses
  Winapi.Windows,
  WebView2;

const
  IID_ICoreWebView2Controller2: TGUID =
    '{C979903E-D4CA-4228-92EB-47EE3FA96EAB}';

type
  (*--- Corresponds exactly to the C++ struct {UINT8 A,R,G,B} *)
  COREWEBVIEW2_COLOR = packed record
    A: BYTE;
    R: BYTE;
    G: BYTE;
    B: BYTE;
  end;
  TCOREWEBVIEW2_COLOR = COREWEBVIEW2_COLOR;

  ICoreWebView2Controller2 = interface(ICoreWebView2Controller)
    ['{C979903E-D4CA-4228-92EB-47EE3FA96EAB}']
    function get_DefaultBackgroundColor(
      out backgroundColor: COREWEBVIEW2_COLOR
    ): HRESULT; stdcall;
    function put_DefaultBackgroundColor(
      backgroundColor: COREWEBVIEW2_COLOR
    ): HRESULT; stdcall;
  end;

implementation

end.

unit Introducer.UserSettings.VCL;

(*
  Unit: Introducer.UserSettings.VCL

  Purpose:
    Provides a structured and type-safe way to aggregate references to relevant VCL controls
    used in the user settings UI. This unit defines the TSettingsIntroducer record, which acts as a container
    for binding UI elements, making initialization and further management of user settings UI logic
    both clean and extensible.

  Technical details:
    - Centralizes references to all settings-related UI controls (ComboBox, Edit, MaskEdit, Label, etc.).
    - Implements a helper record (TSettingsIntroducerHelper) with fluent-style setters for streamlined
      assignment and chaining during form setup.
    - Facilitates clear separation between UI declaration and business logic/controller code, promoting maintainability and reusability.

  Usage:
    - Create and populate a TSettingsIntroducer with relevant controls from your form.
    - Pass it to logic units (such as TSettingsVCL) to link and synchronize the UI without repetitious assignment code.
    - Extend or refactor UI dialogs by updating this introducer, minimizing code changes elsewhere.

*)


interface

uses
  System.SysUtils, System.Classes,
  Vcl.Graphics, Vcl.Controls, Vcl.StdCtrls, Vcl.ExtCtrls, Vcl.ComCtrls, Vcl.Mask,
  Vcl.Forms, Vcl.Dialogs;

type
  TSettingsIntroducer = record
    ScrollBox: TScrollBox;
    Proficiency: TComboBox;
    ProficiencyLabel: TLabel;
    PreferenceName: TMaskEdit;
    APIKey: TMaskEdit;
    SearchModel: TComboBox;
    SearchModelCost: TLabel;
    ReasoningModel: TComboBox;
    ReasoningModelCost: TLabel;
    ReasoningEffort: TComboBox;
    ReasoningSummary: TComboBox;
    WebContextSize: TComboBox;
    TimeOut: TComboBox;
    Country: TMaskEdit;
    City: TMaskEdit;
    class function Empty: TSettingsIntroducer; static;
  end;

  TSettingsIntroducerHelper = record helper for TSettingsIntroducer
    function SetScrollBox(Value: TScrollBox): TSettingsIntroducer; inline;
    function SetProficiency(Value: TComboBox): TSettingsIntroducer; inline;
    function SetProficiencyLabel(Value: TLabel): TSettingsIntroducer; inline;
    function SetPreferenceName(Value: TMaskEdit): TSettingsIntroducer; inline;
    function SetAPIKey(Value: TMaskEdit): TSettingsIntroducer; inline;
    function SetSearchModel(Value: TComboBox): TSettingsIntroducer; inline;
    function SetSearchModelCost(Value: TLabel): TSettingsIntroducer; inline;
    function SetReasoningModel(Value: TComboBox): TSettingsIntroducer; inline;
    function SetReasoningModelCost(Value: TLabel): TSettingsIntroducer; inline;
    function SetReasoningEffort(Value: TComboBox): TSettingsIntroducer; inline;
    function SetReasoningSummary(Value: TComboBox): TSettingsIntroducer; inline;
    function SetWebContextSize(Value: TComboBox): TSettingsIntroducer; inline;
    function SetTimeOut(Value: TComboBox): TSettingsIntroducer; inline;
    function SetCountry(Value: TMaskEdit): TSettingsIntroducer; inline;
    function SetCity(Value: TMaskEdit): TSettingsIntroducer; inline;
  end;

implementation

{ TSettingsIntroducer }

class function TSettingsIntroducer.Empty: TSettingsIntroducer;
begin
  FillChar(Result, SizeOf(Result), 0);
end;

{ TSettingsIntroducerHelper }

function TSettingsIntroducerHelper.SetAPIKey(
  Value: TMaskEdit): TSettingsIntroducer;
begin
  Self.APIKey := Value;
  Result := Self;
end;

function TSettingsIntroducerHelper.SetCity(
  Value: TMaskEdit): TSettingsIntroducer;
begin
  Self.City := Value;
  Result := Self;
end;

function TSettingsIntroducerHelper.SetCountry(
  Value: TMaskEdit): TSettingsIntroducer;
begin
  Self.Country := Value;
  Result := Self;
end;

function TSettingsIntroducerHelper.SetPreferenceName(
  Value: TMaskEdit): TSettingsIntroducer;
begin
  Self.PreferenceName := Value;
  Result := Self;
end;

function TSettingsIntroducerHelper.SetProficiency(
  Value: TComboBox): TSettingsIntroducer;
begin
  Self.Proficiency := Value;
  Result := Self;
end;

function TSettingsIntroducerHelper.SetProficiencyLabel(
  Value: TLabel): TSettingsIntroducer;
begin
  Self.ProficiencyLabel := Value;
  Result := Self;
end;

function TSettingsIntroducerHelper.SetReasoningEffort(
  Value: TComboBox): TSettingsIntroducer;
begin
  Self.ReasoningEffort := Value;
  Result := Self;
end;

function TSettingsIntroducerHelper.SetReasoningModel(
  Value: TComboBox): TSettingsIntroducer;
begin
  Self.ReasoningModel := Value;
  Result := Self;
end;

function TSettingsIntroducerHelper.SetReasoningModelCost(
  Value: TLabel): TSettingsIntroducer;
begin
  Self.ReasoningModelCost := Value;
  Result := Self;
end;

function TSettingsIntroducerHelper.SetReasoningSummary(
  Value: TComboBox): TSettingsIntroducer;
begin
  Self.ReasoningSummary := Value;
  Result := Self;
end;

function TSettingsIntroducerHelper.SetScrollBox(
  Value: TScrollBox): TSettingsIntroducer;
begin
  Self.ScrollBox := Value;
  Result := Self;
end;

function TSettingsIntroducerHelper.SetSearchModel(
  Value: TComboBox): TSettingsIntroducer;
begin
  Self.SearchModel := Value;
  Result := Self;
end;

function TSettingsIntroducerHelper.SetSearchModelCost(
  Value: TLabel): TSettingsIntroducer;
begin
  Self.SearchModelCost := Value;
  Result := Self;
end;

function TSettingsIntroducerHelper.SetTimeOut(
  Value: TComboBox): TSettingsIntroducer;
begin
  Self.TimeOut := Value;
  Result := Self;
end;

function TSettingsIntroducerHelper.SetWebContextSize(
  Value: TComboBox): TSettingsIntroducer;
begin
  Self.WebContextSize := Value;
  Result := Self;
end;

end.


unit UI.AlertService.VCL;

(*
  Unit: UI.AlertService.VCL

  Purpose:
    This unit provides a straightforward alert/warning service for Delphi VCL applications.
    Its goal is to encapsulate user warning display logic, ensuring that all warning messages are presented
    in a consistent, easy-to-maintain way through a single interface.

  Technical details:
    - Defines TAlerteServiceVCL, an implementation of the IAlertService interface.
    - The ShowWarning method uses Delphi's built-in MessageDlg function to present modal warning dialogs.
    - Supports any string message. Called warnings will always use the mtWarning dialog style with a single OK button.
    - Can easily be extended to other alert types (information, error, confirmation) by implementing additional interface methods.

  Dependencies:
    - Delphi VCL Dialogs unit for message display (MessageDlg).
    - Manager.Intf for the IAlertService interface contract.
    - Standard Delphi System.SysUtils and System.UITypes for string and dialog type definitions.

  Quick start for developers:
    - Instantiate TAlerteServiceVCL and call ShowWarning('your message') to display a warning dialog.
    - Integrates seamlessly in VCL applications where centralized or abstracted alert logic is desired.

  This unit is ideal for harmonizing and centralizing alert dialogs in Delphi VCL apps,
  promoting consistency and maintainability.

*)

interface

uses
  System.SysUtils, System.UITypes, VCL.Dialogs, Manager.Intf;

type
  /// <summary>
  /// Provides a centralized alert and message dialog service for Delphi VCL applications,
  /// implementing the <c>IAlertService</c> interface.
  /// </summary>
  /// <remarks>
  /// <para>
  /// <c>TAlerteServiceVCL</c> is designed to harmonize the handling of user-facing alerts,
  /// ensuring all warnings, errors, informations, and confirmations are presented with a consistent look and
  /// logic throughout a Delphi VCL application.
  /// </para>
  /// <para>
  /// All dialogs are modal and use Delphi’s built-in <c>MessageDlg</c> function. The service supports
  /// warnings, errors, information messages, and confirmation dialogs (Yes/No).
  /// </para>
  /// </remarks>
  TAlerteServiceVCL = class(TInterfacedObject, IAlertService)
  public
    /// <summary>
    /// Displays an error message dialog with an "OK" button.
    /// </summary>
    /// <param name="Msg">
    /// The error message to display.
    /// </param>
    procedure ShowError(const Msg: string);

    /// <summary>
    /// Displays an informational message dialog with an "OK" button.
    /// </summary>
    /// <param name="Msg">
    /// The informational message to display.
    /// </param>
    procedure ShowInformation(const Msg: string);

    /// <summary>
    /// Displays a warning dialog with an "OK" button.
    /// </summary>
    /// <param name="Msg">
    /// The warning message to display.
    /// </param>
    procedure ShowWarning(const Msg: string);

    /// <summary>
    /// Shows a confirmation dialog (Yes/No) and returns the user's selection.
    /// </summary>
    /// <param name="Msg">
    /// The confirmation message to display.
    /// </param>
    /// <returns>
    /// <c>mrYes</c> if the user selects Yes; <c>mrNo</c> if No is selected.
    /// </returns>
    function ShowConfirmation(const Msg: string): Integer;
  end;

implementation

{ TAlerteServiceVCL }

function TAlerteServiceVCL.ShowConfirmation(const Msg: string): Integer;
begin
  Result := MessageDLG(Msg, TMsgDlgType.mtConfirmation, [TMsgDlgBtn.mbYes, TMsgDlgBtn.mbNo], 0);
end;

procedure TAlerteServiceVCL.ShowError(const Msg: string);
begin
  MessageDLG(Msg, TMsgDlgType.mtError, [TMsgDlgBtn.mbOK], 0);
end;

procedure TAlerteServiceVCL.ShowInformation(const Msg: string);
begin
  MessageDLG(Msg, TMsgDlgType.mtInformation, [TMsgDlgBtn.mbOK], 0);
end;

procedure TAlerteServiceVCL.ShowWarning(const Msg: string);
begin
  MessageDLG(Msg, TMsgDlgType.mtWarning, [TMsgDlgBtn.mbOK], 0);
end;

end.

unit UI.AnimatedVectorLeftPanel.VCL;

(*
  Unit: UI.AnimatedVectorLeftPanel.VCL

  Purpose:
    This unit provides logic and UI integration for a collapsible, animated left panel in a Delphi VCL application.
    The panel is designed to host and display a scrollable list of resource containers (typically AI/vector resource representations),
    supporting animated open/close states, creation of new resource entries, and responsive resizing.
    It enhances the user experience with visual feedback and efficient management of the left navigation/workspace area.

  Technical details:
    - Introduces TLeftPanelControl, encapsulating all behavior for the left panel: expansion/collapse, animation,
      and event-driven UI refresh.
    - Implements asynchronous panel width transitions using TTask and TThread.Queue for smooth, non-blocking animation.
    - Supports four main control buttons: open, close, new-left, new-right. Button appearance and events are managed centrally,
      leveraging custom styling and accessibility hints.
    - Uses a delegate (TProc<TObject>) for reacting to size changes and external UI update requests.
    - The panel interacts with an external resource manager to dynamically instantiate and populate resource containers inside a ScrollBox.
    - All resource loading, assignment, and container selection logic is managed via the `Repaint` and `Refresh` methods,
      ensuring effective UI/data synchronization.
    - Strong separation of concerns: panel animation/UI control is kept independent of the underlying resource models and business logic.

  Dependencies:
    - Delphi VCL visual components: TPanel, TScrollBox, TButton.
    - Requires UI.Container.VCL for the displayed resource containers.
    - Relies on UI.Styles.VCL for consistent button appearance and design guidelines.
    - Uses Manager.Intf for dependency inversion and integration with business logic/managers.
    - System.Threading for concurrent/asynchronous UI transitions.
    - Standard Delphi units for events, messages, and system classes.

  Quick start for developers:
    - Instantiate TLeftPanelControl, providing required button and panel/control references from your form.
    - Call `Refresh` to repopulate the panel; use the State property (opened/closed) for programmatic control of the panel’s display state.
    - Integrate the supplied ProcResize callback to handle dynamic resizing or other UI adjustments in response to panel state changes.
    - Panel population and resource item selection are handled automatically,
      with events wired to trigger new resource creation, selection, and name changes as appropriate.

  This unit is ideal for building modern, interactive navigation or resource selection panels in Delphi VCL applications,
  enabling a dynamic user workspace while keeping logic maintainable and visually smooth.

*)

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Classes, System.Threading,
  Vcl.StdCtrls, Vcl.Controls, Vcl.ExtCtrls, VCL.Forms, UI.Container.VCL,
  Manager.Intf, Manager.Types, UI.Styles.VCL;

type
  TOpenCloseState = (opened, closed);

  TLeftPanelControlIntroducer = record
    OpenBtn: TButton;
    CloseBtn: TButton;
    NewLeftBtn: TButton;
    NewRightBtn: TButton;
    Panel: TPanel;
    CaptionPanel: TPanel;
    ScrollBox: TScrollBox;
    class function Empty: TLeftPanelControlIntroducer; static;
  end;

  TLeftPanelControlIntroducerHelper = record Helper for TLeftPanelControlIntroducer
    function SetOpenBtn(Value: TButton): TLeftPanelControlIntroducer; inline;
    function SetCloseBtn(Value: TButton): TLeftPanelControlIntroducer; inline;
    function SetNewLeftBtn(Value: TButton): TLeftPanelControlIntroducer; inline;
    function SetNewRightBtn(Value: TButton): TLeftPanelControlIntroducer; inline;
    function SetPanel(Value: TPanel): TLeftPanelControlIntroducer; inline;
    function SetCaptionPanel(Value: TPanel): TLeftPanelControlIntroducer; inline;
    function SetScrollBox(Value: TScrollBox): TLeftPanelControlIntroducer; inline;
  end;

  /// <summary>
  /// Provides an animated, collapsible left panel control for Delphi VCL applications,
  /// supporting resource navigation, workspace management, and smooth UI transitions.
  /// </summary>
  /// <remarks>
  /// <para>
  /// - The <c>TLeftPanelControl</c> class encapsulates all behaviors, state transitions, and UI interactions
  /// for a left-side navigation or workspace panel in a VCL application. It orchestrates panel animation,
  /// open/close toggling, creation of new resource containers, and event-driven resizing—enabling an efficient,
  /// modern UX for chat, resource, or session navigation scenarios.
  /// </para>
  /// <para>
  /// - The control integrates seamlessly with external business logic and resource managers via dependency
  /// inversion, delegates (TProc&lt;TObject&gt;), and strong separation of concerns. Responsive, asynchronous
  /// animation is implemented using <c>TTask</c> and <c>TThread.Queue</c> for non-blocking UI experience.
  /// </para>
  /// <para>
  /// - Four primary action buttons are managed centrally for open, close, and new-entry creation, all styled
  /// according to File2knowledgeAI and VCL design guidelines.
  /// </para>
  /// Instantiate <c>TLeftPanelControl</c> with required UI component references and resize callback:
  /// <code>
  /// var PanelControl := TLeftPanelControl.Create(Introducer, OnResizeCallback);
  /// PanelControl.Refresh;
  /// PanelControl.State := opened;
  /// </code>
  /// see also "ILeftPanelControl" and "UI.Container.VCL"
  /// </remarks>
  TLeftPanelControl = class(TInterfacedObject, ILeftPanelControl)
  const MINWIDTH = 0;
  const MAXWIDTH = 350;
  private
    FScrollBox: TScrollBox;
    FCloseBtn: TButton;
    FOpenBtn: TButton;
    FNewLeftBnt: TButton;
    FNewRightBtn: TButton;
    FPanel: TPanel;
    FCaptionPanel: TPanel;
    FState: TOpenCloseState;
    FResize: TProc<TObject>;
    procedure SetScrollBox(const Value: TScrollBox);
    procedure SetCloseBtn(const Value: TButton);
    procedure SetOpenBtn(const Value: TButton);
    procedure SetNewLeftBtn(const Value: TButton);
    procedure SetNewRightBtn(const Value: TButton);
    procedure SetPanel(const Value: TPanel);
    procedure SetCaptionPanel(const Value: TPanel);
    procedure SetState(const Value: TOpenCloseState);
    procedure SetButtonProperties(const AButton: TButton; ACaption, AHint: string; AEvent: TNotifyEvent);
  protected
    procedure Effect(Panel: TPanel; const StartW, EndW: Integer);
    procedure AnimatePanelAsync(APanel: TPanel; const TargetWidth: Integer);
    procedure Animation(Panel: TPanel; const StartW, EndW: Integer);

    procedure HandleOpen;
    procedure HandleClose;
    procedure Repaint;
  public
    constructor Create(const Introducer: TLeftPanelControlIntroducer; const ProcResize: TProc<TObject>);

    /// <summary>
    /// Handles panel switch events, toggling the panel between opened and closed states.
    /// </summary>
    /// <param name="Sender">The object that initiated the switch operation (typically a button).</param>
    procedure HandleSwitch(Sender: TObject);

    /// <summary>
    /// Handles creation of a new conversation/resource entry in the panel.
    /// Resets any persistent or selection state and prepares the workspace for a fresh entry.
    /// </summary>
    /// <param name="Sender">The control or component that triggered the new entry action.</param>
    procedure HandleNew(Sender: TObject);

    /// <summary>
    /// Refreshes the contents of the left panel,
    /// repopulating its scroll box with the latest resource containers and updating their states.
    /// </summary>
    procedure Refresh;

    /// <summary>
    /// Selects the resource container by its index in the scroll box,
    /// triggering selection logic and highlighting for navigation or operation.
    /// </summary>
    /// <param name="AIndex">The index of the container to select.</param>
    procedure ItemSelect(const AIndex: Integer);

    /// <summary>
    /// Gets or sets the current opened/closed state of the left panel.
    /// Setting this property programmatically opens or closes the panel with an animated transition.
    /// </summary>
    property State: TOpenCloseState read FState write SetState;
  end;

implementation

{ TLeftPanelControl }

procedure TLeftPanelControl.AnimatePanelAsync(APanel: TPanel;
  const TargetWidth: Integer);
const
  PIXEL_STEP   = 24;
  FRAME_PAUSE  = 22;   // ms
begin
  var StartWidth := APanel.Width;

  TTask.Run(
    procedure
    var
      CurW, Step: Integer;
    begin
      CurW := StartWidth;

      if CurW = TargetWidth then
        Exit;

      if CurW < TargetWidth then
        Step := PIXEL_STEP else
        Step := -PIXEL_STEP;

      while CurW <> TargetWidth do
      begin
        Inc(CurW, Step);
        if ((Step > 0) and (CurW > TargetWidth)) or
           ((Step < 0) and (CurW < TargetWidth)) then
          CurW := TargetWidth;

        TThread.Queue(nil,
          procedure
          begin
            APanel.DisableAlign;
            try
              APanel.Parent.DisableAlign;
              try
                APanel.SetBounds(APanel.Left, APanel.Top, CurW, APanel.Height);
                APanel.Update;
                FResize(nil);
              finally
                APanel.Parent.EnableAlign;
              end;
            finally
              APanel.EnableAlign;
            end;
          end);

        Sleep(FRAME_PAUSE);

      end;
    end);
end;

procedure TLeftPanelControl.Animation(Panel: TPanel; const StartW,
  EndW: Integer);
begin
  Panel.DisableAlign;
  Panel.Parent.DisableAlign;
  try
    Effect(Panel, StartW, EndW);
  finally
    Panel.Parent.EnableAlign;
    Panel.EnableAlign;
  end;
end;

constructor TLeftPanelControl.Create(const Introducer: TLeftPanelControlIntroducer;
  const ProcResize: TProc<TObject>);
begin
  inherited Create;
  FState := closed;
  SetCloseBtn(Introducer.CloseBtn);
  SetOpenBtn(Introducer.OpenBtn);
  SetNewLeftBtn(Introducer.NewLeftBtn);
  SetNewRightBtn(Introducer.NewRightBtn);
  SetPanel(Introducer.Panel);
  SetCaptionPanel(Introducer.CaptionPanel);
  SetScrollBox(Introducer.ScrollBox);
  FResize := ProcResize;
end;

procedure TLeftPanelControl.Effect(Panel: TPanel; const StartW, EndW: Integer);
var
  Step   : Integer;
  CurW   : Integer;
begin
  if StartW = EndW then
    Exit;

  if StartW < EndW then
    Step := 6 else
    Step := -6;
  CurW := StartW;
  while CurW <> EndW do
    begin
      Inc(CurW, Step);
      if (Step > 0) and (CurW > EndW) or
         (Step < 0) and (CurW < EndW) then
        CurW := EndW;
      Panel.Width := CurW;
      Panel.Update;
      Sleep(12);
    end;
end;

procedure TLeftPanelControl.SetButtonProperties(const AButton: TButton; ACaption,
  AHint: string; AEvent: TNotifyEvent);
begin
  TAppStyle.ApplyAnimatedVectorLeftPanelButtonStyle(AButton,
    procedure
    begin
      AButton.Caption := ACaption;
      AButton.Hint := AHint;
      AButton.OnClick := AEvent;
    end);
end;

procedure TLeftPanelControl.SetCaptionPanel(const Value: TPanel);
begin
  FCaptionPanel := Value;
end;

procedure TLeftPanelControl.SetCloseBtn(const Value: TButton);
begin
  FCloseBtn := Value;
  SetButtonProperties(FCloseBtn, '', 'Hide the panel  F9', HandleSwitch);
end;

procedure TLeftPanelControl.SetNewLeftBtn(const Value: TButton);
begin
  FNewLeftBnt := Value;
  SetButtonProperties(FNewLeftBnt, '', 'New conversation  Ctrl+N', HandleNew);
end;

procedure TLeftPanelControl.SetNewRightBtn(const Value: TButton);
begin
  FNewRightBtn := Value;
  SetButtonProperties(FNewRightBtn, '', 'New conversation  Ctrl+N', HandleNew);
end;

procedure TLeftPanelControl.SetOpenBtn(const Value: TButton);
begin
  FOpenBtn := Value;
  SetButtonProperties(FOpenBtn, '', 'Show the panel  F9', HandleSwitch);
end;

procedure TLeftPanelControl.SetPanel(const Value: TPanel);
begin
  FPanel := Value;
  FPanel.Width := MINWIDTH;
end;

procedure TLeftPanelControl.SetScrollBox(const Value: TScrollBox);
begin
  FScrollBox := Value;
end;

procedure TLeftPanelControl.SetState(const Value: TOpenCloseState);
begin
  FState := Value;
  case FState of
    opened: HandleOpen;
    closed: HandleClose;
  end;
end;

procedure TLeftPanelControl.HandleClose;
begin
  EdgeDisplayer.Hide;
  FCaptionPanel.Visible := True;
  FCloseBtn.Visible := False;
  FNewLeftBnt.Visible := False;
  AnimatePanelAsync(FPanel, MINWIDTH);
end;

procedure TLeftPanelControl.HandleNew(Sender: TObject);
begin
  try
    PersistentChat.Clear;
    EdgeDisplayer.Clear;
    FileSearchDisplayer.Clear;
    WebSearchDisplayer.Clear;
    ReasoningDisplayer.Clear;
    Selector.ShowPage(psHistoric);
    PromptSelector.Hide;
  finally
    ServicePrompt.SetFocus;
  end;
end;

procedure TLeftPanelControl.HandleOpen;
begin
  FCaptionPanel.Visible := False;
  FCloseBtn.Visible := True;
  FNewLeftBnt.Visible := True;
  AnimatePanelAsync(FPanel, MAXWIDTH);
end;

procedure TLeftPanelControl.HandleSwitch(Sender: TObject);
begin
  try
    State := TOpenCloseState((Integer(State) + 1) mod 2);
  finally
    ServicePrompt.SetFocus;
  end;
end;

procedure TLeftPanelControl.ItemSelect(const AIndex: Integer);
begin
  TContainer.ContainerSelect(AIndex);
end;

procedure TLeftPanelControl.Refresh;
begin
  try
    FScrollBox.Perform(WM_SETREDRAW, WPARAM(FALSE), 0);
    try
      FScrollBox.DisableAlign;
      try
        {--- WEAK POINT: delete then rebuild everything is stupid!!  }
        while FScrollBox.ControlCount > 0 do
          FScrollBox.Controls[0].Free;
        Repaint;
      finally
        FScrollBox.EnableAlign;
      end;
    finally
      FScrollBox.Perform(WM_SETREDRAW, WPARAM(TRUE), 0);
    end;
  finally
    FScrollBox.Realign;
    RedrawWindow(FScrollBox.Handle,
      nil, 0,
      RDW_ERASE or RDW_INVALIDATE or RDW_FRAME or RDW_ALLCHILDREN);
  end;
end;

procedure TLeftPanelControl.Repaint;
begin
  if FileStoreManager.JSONExists then
    try
      FileStoreManager.LoadValues
    except
      FileStoreManager.DefaultValues;
    end
  else
    FileStoreManager.DefaultValues;

  FileStoreManager
    .AttachTo(FScrollBox,
      {--- Method for OnMouseDown event of a TContainer class }
      procedure (Sender: TObject)
      begin
        if Sender is TContainer then
          begin
            var Container := Sender as TContainer;
            if Container.Index = FileStoreManager.ItemIndex then
              Exit;

            LeftPanelControl.HandleNew(nil);
            FileStoreManager.ItemIndex := Container.Index;
            FileStoreManager.Name := Container.DisplayName;
            FileStoreManager.UpdateCurrent;
            Container.Select(FileStoreManager.ItemIndex);
            FileStoreManager.SaveToFile;
          end;
      end);
  ItemSelect(FileStoreManager.ItemIndex);
end;

{ TLeftPanelControlIntroducer }

class function TLeftPanelControlIntroducer.Empty: TLeftPanelControlIntroducer;
begin
  FillChar(Result, SizeOf(Result), 0);
end;

{ TLeftPanelControlIntroducerHelper }

function TLeftPanelControlIntroducerHelper.SetCaptionPanel(
  Value: TPanel): TLeftPanelControlIntroducer;
begin
  Self.CaptionPanel := Value;
  Result := Self;
end;

function TLeftPanelControlIntroducerHelper.SetCloseBtn(
  Value: TButton): TLeftPanelControlIntroducer;
begin
  Self.CloseBtn := Value;
  Result := Self;
end;

function TLeftPanelControlIntroducerHelper.SetNewLeftBtn(
  Value: TButton): TLeftPanelControlIntroducer;
begin
  Self.NewLeftBtn := Value;
  Result := Self;
end;

function TLeftPanelControlIntroducerHelper.SetNewRightBtn(
  Value: TButton): TLeftPanelControlIntroducer;
begin
  Self.NewRightBtn := Value;
  Result := Self;
end;

function TLeftPanelControlIntroducerHelper.SetOpenBtn(
  Value: TButton): TLeftPanelControlIntroducer;
begin
  Self.OpenBtn := Value;
  Result := Self;
end;

function TLeftPanelControlIntroducerHelper.SetPanel(
  Value: TPanel): TLeftPanelControlIntroducer;
begin
  Self.Panel := Value;
  Result := Self;
end;

function TLeftPanelControlIntroducerHelper.SetScrollBox(
  Value: TScrollBox): TLeftPanelControlIntroducer;
begin
  Self.ScrollBox := Value;
  Result := Self;
end;

end.

unit UI.ChatSession.VCL;

(*
  Unit: UI.ChatSession.VCL

  Purpose:
    Provides the visual layer and controller logic for chat session history management in the File2knowledgeAI project.
    This unit centralizes the UI workflow for browsing, editing, deleting, and organizing persistent multi-turn chat
    histories within a Delphi VCL application, connecting strongly with persistent storage backends.

  Architecture and Design:
    - Exposes the TChatSessionHistoryViewVCL class, responsible for rendering and maintaining interactive chat
      session lists, column sorting, batch and in-place editing, and synchronized state between UI and
      backend session store.
    - Integrates VCL ListView, Button, and Panel controls with rich event handling for operations such as
      batch deletion, inline editing, annotation updates, and context menu commands.
    - Adopts File2knowledgeAI project conventions for extensible, robust, and user-friendly dialog history management.

  Usage:
    - Create a TChatSessionHistoryViewVCL instance, supplying ListView and control references along with
      the persistent chat session interface.
    - Invoke methods like FullRefresh, Refresh, and Repaint to synchronize and update the UI based on
      backend state or user actions.
    - Use public controller methods to support annotation display, batch operations, or to coordinate
      with other modules such as prompt/response viewing and reasoning panels.

  Context:
    This unit is designed for scenarios requiring consistent, reliable, and traceable multi-turn session presentation
    and management—essential for advanced OpenAI workflow support and conversational chaining logic as
    promoted by File2knowledgeAI.

  Conventions follow File2knowledgeAI UI, chaining, and session storage best practices.
*)

interface

uses
  Winapi.Windows, Winapi.ShellAPI,
  System.SysUtils, System.Classes, System.Threading, System.DateUtils, System.IOUtils,
  Vcl.Graphics, Vcl.Controls, Vcl.ComCtrls, Vcl.Buttons, Vcl.ExtCtrls, Vcl.Menus, Vcl.Forms,
  Manager.Intf, ChatSession.Controller, UI.Styles.VCL, Helper.PopupMenu.VCL;

type
  /// <summary>
  /// Provides a VCL-based view and management interface for the chat session history within the File2knowledgeAI application.
  /// </summary>
  /// <remarks>
  /// <para>
  /// <c>TChatSessionHistoryViewVCL</c> encapsulates all visual and logical interactions for browsing, editing, renaming,
  /// deleting, and persisting chat sessions using a ListView and associated UI controls in a Delphi VCL environment.
  /// </para>
  /// <para>
  /// The class integrates tightly with persistent storage backends (via <c>IPersistentChat</c>) and offers advanced
  /// features such as batch deletion, renaming, sortable and refreshable history lists, and in-place annotation display.
  /// </para>
  /// <para>
  /// This implementation is a key part of the user-facing conversation management, supporting robust and user-friendly
  /// manipulation of multi-turn chat session records.
  /// </para>
  /// <para>
  /// Conventions and architectural guidelines follow File2knowledgeAI and OpenAI chaining best practices, ensuring consistency
  /// and extensibility.
  /// </para>
  /// </remarks>
  TChatSessionHistoryViewVCL = class(TInterfacedObject, IChatSessionHistoryView)
  private
    FListView: TListView;
    FOkButton: TSpeedButton;
    FCancelButton: TSpeedButton;
    FileNameCol: TListColumn;
    DateCol: TListColumn;
    FSortColumn: Integer;
    FSortAscending: Boolean;
    FPersistentChat: IPersistentChat;
    FAllowEdit: Boolean;
    FSelected: TChatSession;
    FBtnPanel: TPanel;
    procedure ListViewCompare(Sender: TObject; Item1, Item2: TListItem;
      Data: Integer; var Compare: Integer);
    procedure SetListView(const Value: TListView);
    procedure SetOkButton(const Value: TSpeedButton);
    procedure SetCancelButton(const Value: TSpeedButton);
    procedure SetBtnPanel(const Value: TPanel);
    procedure HideButtons;
    procedure ShowButtons;
    procedure SortInitialize;
    procedure InternalSort(Sender: TObject);
    procedure DeleteSelected;
    procedure ConfigureListViewProperties;
    procedure ConfigureListViewColumns;
    procedure ConfigureListViewEvents;
    procedure ItemRepaint(const Value: TChatTurn);
  protected
    procedure HandleJsonEdition(Sender: TObject);
    procedure HandleRename(Sender: TObject);
    procedure HandleDelete(Sender: TObject);
    procedure HandleOk(Sender: TObject);
    procedure HandleCancel(Sender: TObject);
    procedure HandleListView1KeyPress(Sender: TObject; var Key: Char);
    procedure HandleColumnClick(Sender: TObject; Column: TListColumn);
    procedure HandleClick(Sender: TObject);
    procedure HandleEditing(Sender: TObject; Item: TListItem; var AllowEdit: Boolean);
    procedure HandleEdited(Sender: TObject; Item: TListItem; var S: string);
    procedure HandleDeletion(Sender: TObject; Item: TListItem);
    procedure HandleCancelEdit(Sender: TObject; Item: TListItem);
  public
    /// <summary>
    /// Initializes a new instance of <c>TChatSessionHistoryViewVCL</c> with the specified UI components and chat persistence interface.
    /// </summary>
    /// <param name="AListView">The ListView control to display the chat session history.</param>
    /// <param name="AOkButton">The button control used to confirm actions like deletion.</param>
    /// <param name="ACancelButton">The button control used to cancel ongoing actions.</param>
    /// <param name="ABtnPanel">The panel containing Ok and Cancel buttons for batch operations.</param>
    /// <param name="PersistentChat">Provides persistent storage for chat sessions.</param>
    constructor Create(const AListView: TListView; const AOkButton, ACancelButton: TSpeedButton;
      const ABtnPanel: TPanel; const PersistentChat: IPersistentChat);

    /// <summary>
    /// Fully refreshes the display by reloading all chat session history from the persistent store and updating the ListView.
    /// </summary>
    /// <param name="Sender">The caller or event originator.</param>
    procedure FullRefresh(Sender: TObject);

    /// <summary>
    /// Refreshes the ListView to reflect the current state of the chat session history without reloading from the persistent store.
    /// </summary>
    /// <param name="Sender">The caller or event originator.</param>
    procedure Refresh(Sender: TObject);

    /// <summary>
    /// Repaints all UI elements for the currently selected chat session, optionally invoking specialized rendering for each turn in the conversation.
    /// </summary>
    /// <param name="Sender">The caller or event originator.</param>
    procedure Repaint(Sender: TObject);

    /// <summary>
    /// Updates the specified annotation display component with new text and scrolls to the top.
    /// </summary>
    /// <param name="Annotation">The component responsible for displaying annotations.</param>
    /// <param name="Text">The annotation text to display.</param>
    procedure UpdateAnnotation(const Annotation: IAnnotationsDisplayer; const Text: string);
  end;

implementation

uses
  System.Math;

{ TChatSessionHistoryViewVCL }

procedure TChatSessionHistoryViewVCL.ConfigureListViewColumns;
begin
  FListView.Columns.ClearAndResetID;

  FileNameCol := FListView.Columns.Add;
  FileNameCol.Caption := 'Round title';
  FileNameCol.AutoSize := False;
  FileNameCol.Width := FListView.Width;
  FileNameCol.Alignment := taLeftJustify;

  DateCol := FListView.Columns.Add;
  DateCol.Caption := 'Update date';
  DateCol.AutoSize := False;
  DateCol.Width := 160;
  DateCol.Alignment := taCenter;
end;

procedure TChatSessionHistoryViewVCL.ConfigureListViewEvents;
begin
  FListView.OnKeyPress := HandleListView1KeyPress;
  FListView.OnColumnClick := HandleColumnClick;
  FListView.OnClick := HandleClick;
  FListView.OnEdited := HandleEdited;
  FListView.OnEditing := HandleEditing;
  FListView.OnCancelEdit := HandleCancelEdit;
  FListView.OnCompare := ListViewCompare;
end;

procedure TChatSessionHistoryViewVCL.ConfigureListViewProperties;
begin
  {--- Properties }
  FListView.ViewStyle := vsReport;
  FListView.TileOptions.Width := FListView.Width;
  FListView.TileOptions.SizeType := tstFixedWidth;
  FListView.PopupMenu := TPopupMenuHelper.Create(nil)
    .AddItem('JSON &edition', '', HandleJsonEdition)
    .AddItem('&Rename',       '', HandleRename)
    .AddItem('Delete',        '',  HandleDelete)
    .PopupMenu;
  FListView.ShowColumnHeaders := True;
  FListView.RowSelect := True;
  FListView.ShowWorkAreas := True;
  FListView.ViewStyle := vsReport;
end;

constructor TChatSessionHistoryViewVCL.Create(const AListView: TListView;
  const AOkButton, ACancelButton: TSpeedButton; const ABtnPanel: TPanel;
  const PersistentChat: IPersistentChat);
begin
  inherited Create;
  FPersistentChat := PersistentChat;
  SetListView(AListView);
  SetOkButton(AOkButton);
  SetCancelButton(ACancelButton);
  SetBtnPanel(ABtnPanel);
  SortInitialize;
end;

procedure TChatSessionHistoryViewVCL.DeleteSelected;
begin
  {--- Flag used to identify the screenplay cleaning }
  var Matched := false;

  {--- Delete checked items }
  for var i := FListView.Items.Count - 1 downto 0 do
    begin
      var Item := FListView.Items[i];
      if Item.Checked then
        begin
          if not Matched then
            Matched := (*TDataChat*)TChatSession(Item.Data) = PersistentChat.CurrentChat;
          HandleDeletion(nil, Item);
        end;
    end;

  {--- Export conversations to JSON }
  PersistentChat.SaveToFile;

  {--- screen display clear if necessary }
  if Matched then
    LeftPanelControl.HandleNew(nil);
end;

procedure TChatSessionHistoryViewVCL.FullRefresh(Sender: TObject);
begin
  FPersistentChat.LoadFromFile;
  Refresh(Sender);
end;

procedure TChatSessionHistoryViewVCL.HandleCancel(Sender: TObject);
begin
  try
    {--- uncheck the check boxes }
    for var Item in FListView.Items do
      Item.Checked := False;

    {-- Hide th ok and cancel button }
    HideButtons;

    {--- Hide the check boxes }
    FListView.Checkboxes := False;
  finally
    ServicePrompt.SetFocus;
  end;
end;

procedure TChatSessionHistoryViewVCL.HandleCancelEdit(Sender: TObject;
  Item: TListItem);
begin
  HandleCancel(Sender);
end;

procedure TChatSessionHistoryViewVCL.HandleClick(Sender: TObject);
begin
  try
    if Assigned(FListView.Selected) then
      begin
        if PersistentChat.CurrentChat <> FListView.Selected.Data then
          begin
            PersistentChat.CurrentChat := FListView.Selected.Data;
            Repaint(Sender);
          end;
      end;
  finally
    ServicePrompt.SetFocus;
  end;
end;

procedure TChatSessionHistoryViewVCL.HandleColumnClick(Sender: TObject;
  Column: TListColumn);
begin
  try
    if FSortColumn = Column.Index then
      FSortAscending := not FSortAscending
    else
      begin
        FSortColumn := Column.Index;
        FSortAscending := True;
      end;

    try
      FListView.CustomSort(nil, FSortColumn);
    except
    end;
  finally
    ServicePrompt.SetFocus;
  end;
end;

procedure TChatSessionHistoryViewVCL.HandleDelete(Sender: TObject);
begin
  try
    {--- Open Deletion mode: show the ok and cancel button }
    ShowButtons;

    {--- Hide the check boxes }
    FListView.Checkboxes := True;
  finally
    ServicePrompt.SetFocus;
  end;
end;

procedure TChatSessionHistoryViewVCL.HandleDeletion(Sender: TObject; Item: TListItem);
begin
  {--- This message will be permanently removed from persistent storage and the OpenAI dashboard. }
  PersistentChat.Data.Delete(Item.Data,
    procedure (Value: string)
    begin
      {--- remove from the OpenAI dashboard }
      OpenAI.DeleteResponse(Value);
    end);

  {--- Remove the message from the ListView }
  var Index := FListView.Items.IndexOf(Item);
  if Index > -1 then
    FListView.Items.Delete(Index);
end;

procedure TChatSessionHistoryViewVCL.HandleEdited(Sender: TObject; Item: TListItem;
  var S: string);
begin
  try
    {--- Rename the current title from the content of the string "S"  }
    PersistentChat.Data.Rename(Item.Data, S);

    {--- Export conversations to JSON }
    PersistentChat.SaveToFile;

    {--- Disable editing mode of Listview }
    FAllowEdit := False;
  finally
    ServicePrompt.SetFocus;
  end;
end;

procedure TChatSessionHistoryViewVCL.HandleEditing(Sender: TObject; Item: TListItem;
  var AllowEdit: Boolean);
begin
  AllowEdit := FAllowEdit;
end;

procedure TChatSessionHistoryViewVCL.HandleJsonEdition(Sender: TObject);
begin
  var JSONPath := TChatSessionList.JsonFileName;

  {--- Generates a unique path in the temporary directory }
  var TempPath := TPath.Combine(
    TPath.GetTempPath,
    Format('Preview_%s_%d.json',
      [ TPath.GetFileNameWithoutExtension(JSONPath), GetTickCount ] )
  );

  {--- Copy the file (overwrite if already present }
  TFile.Copy(JSONPath, TempPath, True);

  {--- Open the copy in Notepad }
  ShellExecute(Application.Handle, 'open', PChar(TempPath), nil, nil, SW_SHOWNORMAL);
end;

procedure TChatSessionHistoryViewVCL.HandleListView1KeyPress(Sender: TObject;
  var Key: Char);
begin
  case Ord(Key) of
    VK_ESCAPE : HandleCancel(nil);
  end;
end;

procedure TChatSessionHistoryViewVCL.HandleOk(Sender: TObject);
begin
  try
    {--- Freeing selected instances and screen display clear if necessary }
    DeleteSelected;

    {--- Hide ok and cancel buttons }
    HideButtons;

    {--- Hide the check boxes }
    FListView.Checkboxes := False;

    {--- Refresh the chat conversations }
    Refresh(Sender);
  finally
    ServicePrompt.SetFocus;
  end;
end;

procedure TChatSessionHistoryViewVCL.HandleRename(Sender: TObject);
begin
  if FListView.ItemIndex > -1 then
    begin
      FAllowEdit := True;
      FListView.Selected.EditCaption;
    end;
end;

procedure TChatSessionHistoryViewVCL.HideButtons;
begin
  FBtnPanel.Visible := False;
end;

procedure TChatSessionHistoryViewVCL.InternalSort(Sender: TObject);
begin
  FSortColumn := 1;
  FSortAscending := True;
  HandleColumnClick(Sender, DateCol);
  if FListView.Items.Count > 0 then
    FListView.ItemIndex := 0;
end;

procedure TChatSessionHistoryViewVCL.ItemRepaint(const Value: TChatTurn);
begin
  if not Value.Response.Trim.IsEmpty then
    begin
      {--- Add the Id response }
      ResponseTracking.Add(Value.Id);

      {--- Edge browser decoration: Promp and Response }
      EdgeDisplayer.Prompt(Value.Prompt);
      EdgeDisplayer.Display(Value.Response);

      {--- Panels decoration: File_search, Web_search, Reasoning }
      UpdateAnnotation(FileSearchDisplayer, Value.FileSearch);
      UpdateAnnotation(WebSearchDisplayer, Value.WebSearch);
      UpdateAnnotation(ReasoningDisplayer, Value.Reasoning);
    end;
end;

procedure TChatSessionHistoryViewVCL.ListViewCompare(Sender: TObject; Item1,
  Item2: TListItem; Data: Integer; var Compare: Integer);
var
  S1, S2: string;
  N1, N2: Double;
  D1, D2: TDateTime;
  FS: TFormatSettings;
begin
  if Data = 0 then
    begin
      S1 := Item1.Caption;
      S2 := Item2.Caption;
    end
  else
    begin
      S1 := Item1.SubItems[Data-1];
      S2 := Item2.SubItems[Data-1];
    end;

  FS := TFormatSettings.Create;
  FS.DateSeparator := '/';

  if Data = 1 then
    begin
      if TryStrToDate(S1, D1, FS) and TryStrToDate(S2, D2, FS) then
        Compare := Sign(D1 - D2)
      else
        Compare := CompareText(S1, S2);
    end
  else
    begin
      if TryStrToFloat(S1, N1) and TryStrToFloat(S2, N2) then
        Compare := Sign(N1 - N2)
      else
        Compare := CompareText(S1, S2);
    end;

  if not FSortAscending then
    Compare := -Compare;
end;

procedure TChatSessionHistoryViewVCL.Refresh(Sender: TObject);
begin
  var List := FPersistentChat.Data;
  FListView.Items.BeginUpdate;
  try
    FListView.Clear;
    for var Item in List.Data do
      begin
        var NewItem := FListView.Items.Insert(0);
        NewItem.Caption := Item.Title;
        NewItem.Data := Item;
        NewItem.SubItems.Add(TDateTime(UnixToDateTime(Item.ModifiedAt, False)).ToString);
      end;
    InternalSort(Sender);
  finally
    FListView.Items.EndUpdate;
  end;
end;

procedure TChatSessionHistoryViewVCL.Repaint(Sender: TObject);
begin
  if Assigned(PersistentChat.CurrentChat) then
    begin
      TTask.Run(
        procedure()
        begin
          TThread.Queue(nil,
            procedure
            begin
              EdgeDisplayer.Hide;
              try
                ResponseTracking.Clear;
                EdgeDisplayer.Clear;
                for var Item in PersistentChat.CurrentChat.Data do
                  begin
                    ItemRepaint(Item);
                  end;
                EdgeDisplayer.ScrollToEnd(True);
                Sleep(150);
              finally
                EdgeDisplayer.Show;
              end;
            end)
        end);
    end;
end;

procedure TChatSessionHistoryViewVCL.SetBtnPanel(const Value: TPanel);
begin
  FBtnPanel := Value;
  TAppStyle.ApplyChatSessionConfirmationPanelStyle(Value,
    procedure
    begin
      FBtnPanel.Visible := False;
    end);
end;

procedure TChatSessionHistoryViewVCL.SetCancelButton(const Value: TSpeedButton);
begin
  FCancelButton := Value;
  TAppStyle.ApplyChatSessionExecuteButtonStyle(Value,
    procedure
    begin
      FCancelButton.Caption := '&Cancel';

      FCancelButton.OnClick := HandleCancel;
    end);
end;

procedure TChatSessionHistoryViewVCL.SetListView(const Value: TListView);
begin
  FListView := Value;
  TAppStyle.ApplyChatSessionListviewStyle(Value,
    procedure
    begin
      ConfigureListViewProperties;
      ConfigureListViewColumns;
      ConfigureListViewEvents;
    end);
end;


procedure TChatSessionHistoryViewVCL.SetOkButton(const Value: TSpeedButton);
begin
  FOkButton := Value;
  TAppStyle.ApplyChatSessionExecuteButtonStyle(Value,
    procedure
    begin
      FOkButton.Caption := '&Ok';

      FOkButton.OnClick := HandleOk;
    end);
end;

procedure TChatSessionHistoryViewVCL.ShowButtons;
begin
  FBtnPanel.Visible := True;
end;

procedure TChatSessionHistoryViewVCL.SortInitialize;
begin
  FSortColumn := -1;
  FSortAscending := True;
  FAllowEdit := False;
  FSelected := nil;
end;

procedure TChatSessionHistoryViewVCL.UpdateAnnotation(
  const Annotation: IAnnotationsDisplayer; const Text: string);
begin
  Annotation.Clear;
  Annotation.Display(Text);
  Annotation.ScrollToTop;
end;

end.


unit UI.Container.VCL;

(*
    Note on the Implementation of the Internal Registry in TContainer

    The TContainer class, which inherits from TPanel, includes an internal registry (FRegistry) listing all
    its active instances. This approach addresses the need for simple and efficient tracking of decorative
    panels added to a TScrollBox, without requiring an external, heavier management system that would be
    unsuitable for the intended purpose of the class.

    It's true that this solution departs from strict separation of concerns: the instance tracking logic is
    embedded directly in the purely visual component. However, this compromise is fully intentional:
    TContainer is intended only to decorate a TScrollBox—it should not handle anything beyond its sole and
    specific visual purpose, managed in a straightforward and self-contained way.
    Adding an external manager would unnecessarily complicate things for this particular use case.

    Simple integration and usage
    Lightweight in terms of memory and code management
    Responsibility limited to what is strictly necessary
    This remains an area open for improvement: in a production solution or different context, it could make
    sense to isolate this logic using a dedicated manager or registry, in line with stricter architectural
    principles.
    Nevertheless, this implementation is outside the scope of the current application, which focuses
    primarily on demonstrating best practices regarding the use of the v1/responses endpoint: clarity,
    simplicity, and practical effectiveness in the example.
*)

interface

uses
  Winapi.Windows, Winapi.Messages, Winapi.ShellAPI,
  System.SysUtils, System.Classes, System.Generics.Collections, System.Types,
  Vcl.Controls, Vcl.StdCtrls, Vcl.ExtCtrls, Vcl.Graphics, Vcl.Buttons, Vcl.Menus, Vcl.Forms, Vcl.Dialogs,
  Helper.PanelRoundedCorners.VCL, UI.Styles.VCL, Manager.WebServices, Manager.Intf, Manager.Types;

type
  TContainer = class;
  TContainerRegistry = TObjectList<TContainer>;

  TContainer = class(TPanel)
  strict private

    {--- shared registry; lifetime handled by class }
    class var FRegistry: TContainerRegistry;
    class constructor Create;
    class destructor Destroy;

  private
    FThumbnail: TImage;
    FLabel: TLabel;
    FContextPanel: TPanel;
    FPopupMenu: TPopupMenu;
    FIndex: Integer;
    FSelected: Boolean;
    FSelectionProc: TProc<TObject>;
    FGitHubUrl: string;
    FGetitUrl: string;

    procedure CreatePopupMenu;
    procedure CreateThumbnail;
    procedure CreateLabel;
    procedure CreatePanelButton;

    procedure SetCommonEvents(Component: TControl);

    {--- general events Thumbnail, Label }
    procedure HandleMouseEnter(Sender: TObject);
    procedure HandleMouseLeave(Sender: TObject);
    procedure HandleMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer); virtual;

    {--- special PanelButton events }
    procedure HandleContextMouseEnter(Sender: TObject);
    procedure HandleContextMouseLeave(Sender: TObject);
    procedure HandleContextMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);

    {--- Popup menu events }
    procedure HandlePopupMenuPopup(Sender: TObject);
    procedure HandlePopupMenuClose(Sender: TObject);
    procedure HandleGitHubClick(Sender: TObject);
    procedure HandleGetitClick(Sender: TObject);
    procedure HandlePopupMenuModify(Sender: TObject);

    {--- main getters }
    function GetDisplayName: string;
    function GetDescription: string;
    function GetSelected: Boolean;
    function GetGitHubUrl: string;
    function GetGetitUrl: string;

    {--- Add popup menu item }
    procedure AddPopupItem(const ACaption, AShortCut: string;
      AOnClick: TNotifyEvent);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    function ApplyImage(const AStream: TStream): TContainer;
    function ApplyName(const AValue: string): TContainer; reintroduce;
    function ApplyDescription(const AValue: string): TContainer;
    function ApplyTop(const AValue: Integer): TContainer;
    function ApplyIndex(const AValue: Integer): TContainer;
    function ApplySelected(const AValue: Boolean): TContainer;
    function ApplyGitHubUrl(const AValue: string): TContainer;
    function ApplyGetitUrl(const AValue: string): TContainer;
    function OnSelect(AProc: TProc<TObject>): TContainer;

    property DisplayName: string read GetDisplayName;
    property Description: string read GetDescription;
    property Index: Integer read FIndex;
    property Selected: Boolean read GetSelected;
    property GitHubUrl: string read GetGitHubUrl;
    property GetitUrl: string read GetGetitUrl;

    class property Items: TContainerRegistry read FRegistry;
    class function ContainerList: TContainerRegistry;
    class procedure ContainerSelect(const Value: Integer);
    class procedure Select(const AIndex: Integer);
    class procedure Unselect(const AIndex: Integer = -1);
  end;

  function GetTopPosition(const Index: Integer): Integer;

implementation

function GetTopPosition(const Index: Integer): Integer;
begin
  Result := 20 + 66 * Index;
end;

class constructor TContainer.Create;
begin
  {--- Single registry for all instances – list does NOT own the items }
  FRegistry := TContainerRegistry.Create(False);
end;

class destructor TContainer.Destroy;
begin
  FreeAndNil(FRegistry);
end;

class function TContainer.ContainerList: TContainerRegistry;
begin
  Result := FRegistry;
end;

class procedure TContainer.ContainerSelect(const Value: Integer);
begin
  if FRegistry.Count > 0 then
    FRegistry[0].Select(Value);
end;

constructor TContainer.Create(AOwner: TComponent);
begin
  Assert(AOwner is TWinControl, 'AOwner must be a TWinControl');
  inherited Create(AOwner);

  {--- foundation panel }
  Parent := TWinControl(AOwner);
  TAppStyle.ApplyContainerCorePanelStyle(Self,
    procedure
    begin
      Width := 320;
      Height := 58;
      SetCommonEvents(Self);

      {--- PopupMenu
           NOTE: The context menu should be instantiated only once, not for each panel. }
      CreatePopupMenu;

      {--- Hosted controls }
      CreateThumbnail;
      CreateLabel;
      CreatePanelButton;
    end);

  {--- Register instance }
  FRegistry.Add(Self);
end;

procedure TContainer.CreatePopupMenu;
begin
  FPopupMenu := TPopupMenu.Create(Application);
  FPopupMenu.OnPopup := HandlePopupMenuPopup;
  FPopupMenu.OnClose := HandlePopupMenuClose;
  AddPopupItem('GitHub', '', HandleGitHubClick);
  AddPopupItem('Getit', '', HandleGetitClick);
  AddPopupItem('Modify', '', HandlePopupMenuModify);
end;

destructor TContainer.Destroy;
begin
  FRegistry.Remove(Self);
  inherited;
end;

procedure TContainer.AddPopupItem(const ACaption, AShortCut: string;
  AOnClick: TNotifyEvent);
begin
  var Item := TMenuItem.Create(FPopupMenu);
  Item.Caption := ACaption;
  Item.ShortCut := TextToShortCut(AShortCut);
  Item.OnClick := AOnClick;
  FPopupMenu.Items.Add(Item);
end;

procedure TContainer.CreateThumbnail;
begin
  {--- The image container }
  var LPanel := TPanel.Create(Self);
  LPanel.Parent := Self;
  TAppStyle.ApplyContainerBackgroundPanelStyle(LPanel,
    procedure
    begin
      LPanel.SetBounds(8, 4, 50, 50);
    end);

  {--- The image with the rounded edges }
  FThumbnail := TImage.Create(LPanel);
  FThumbnail.Parent := LPanel;
  TAppStyle.ApplyContainerImageStyle(FThumbnail,
    procedure
    begin
      SetCommonEvents(FThumbnail);
    end);
end;

procedure TContainer.CreateLabel;
begin
  FLabel := TLabel.Create(Self);
  FLabel.Parent := Self;
  TAppStyle.ApplyContainerLabelStyle(FLabel,
    procedure
    begin
      FLabel.SetBounds(70, 14, 150, 24);
      FLabel.Transparent := True;
      SetCommonEvents(FLabel);
    end);
end;

procedure TContainer.HandleMouseEnter(Sender: TObject);
begin
  Color := TAppStyle.ApplyContainerMouseEnterColor;
  FLabel.Font.Color := clBlack;
end;

procedure TContainer.HandleMouseLeave(Sender: TObject);
begin
  if not FSelected then
    begin
      Color := TAppStyle.ApplyContainerMouseLeaveColor;
      FLabel.Font.Color := clWhite;
    end;
end;

procedure TContainer.HandlePopupMenuClose(Sender: TObject);
begin

end;

procedure TContainer.HandlePopupMenuModify(Sender: TObject);
begin
  Selector.ShowPage(psVectorFile);
end;

procedure TContainer.HandlePopupMenuPopup(Sender: TObject);
begin
  if FGitHubUrl.Trim.IsEmpty then
    FPopupMenu.Items[0].Enabled := False;

  if FGetitUrl.Trim.IsEmpty then
    FPopupMenu.Items[1].Enabled := False;
end;

procedure TContainer.HandleContextMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  var P := ClientToScreen(Point(Left + Width + 18, Height div 2));
  FPopupMenu.Popup(P.X, P.Y);
end;

procedure TContainer.HandleContextMouseEnter(Sender: TObject);
begin
  FContextPanel.Font.Color := clWhite;
end;

procedure TContainer.HandleContextMouseLeave(Sender: TObject);
begin
  FContextPanel.Font.Color := clBlack;
end;

procedure TContainer.HandleGetitClick(Sender: TObject);
begin
  TWebUrlManager.Open(FGetitUrl);
end;

procedure TContainer.HandleGitHubClick(Sender: TObject);
begin
  TWebUrlManager.Open(FGitHubUrl);
end;

procedure TContainer.HandleMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  if Assigned(FSelectionProc) then
    FSelectionProc(Self);
  FContextPanel.Visible := FSelected;
end;

function TContainer.GetDescription: string;
begin
  Result := FThumbnail.Hint;
end;

function TContainer.GetDisplayName: string;
begin
  Result := FLabel.Caption;
end;

function TContainer.GetGetitUrl: string;
begin
  Result := FGetitUrl;
end;

function TContainer.GetGitHubUrl: string;
begin
  Result := FGitHubUrl;
end;

function TContainer.GetSelected: Boolean;
begin
  Result := FSelected;
end;

class procedure TContainer.Select(const AIndex: Integer);
begin
  Unselect;

  if (AIndex >= 0) and (AIndex < FRegistry.Count) then
    FRegistry[AIndex].ApplySelected(True);
end;

procedure TContainer.CreatePanelButton;
begin
  FContextPanel := TPanel.Create(Self);
  FContextPanel.Parent := Self;
  TAppStyle.ApplyContainerPanelStyle(FContextPanel,
    procedure
    begin
      FContextPanel.PopupMenu := FPopupMenu;
      FContextPanel.SetBounds(Width - 24, 8, 18, 36);
      FContextPanel.Tag := 1;
      SetCommonEvents(FContextPanel);
    end);

end;

procedure TContainer.SetCommonEvents(Component: TControl);
begin
  if not Assigned(Component) then
    Exit;

  if Component is TLabel then
    begin
      TLabel(Component).OnMouseEnter := HandleMouseEnter;
      TLabel(Component).OnMouseLeave := HandleMouseLeave;
      TLabel(Component).OnMouseDown := HandleMouseDown;
    end
  else
  if Component is TImage then
    begin
      TImage(Component).OnMouseEnter := HandleMouseEnter;
      TImage(Component).OnMouseLeave := HandleMouseLeave;
      TImage(Component).OnMouseDown := HandleMouseDown;
    end
  else
  if Component is TPanel then
    begin
      if Component.Tag = 1 then
        begin
          TPanel(Component).OnMouseEnter := HandleContextMouseEnter;
          TPanel(Component).OnMouseLeave := HandleContextMouseLeave;
          TPanel(Component).OnMouseDown := HandleContextMouseDown;
        end
      else
        begin
          TPanel(Component).OnMouseEnter := HandleMouseEnter;
          TPanel(Component).OnMouseLeave := HandleMouseLeave;
          TPanel(Component).OnMouseDown := HandleMouseDown;
        end;
    end
end;

class procedure TContainer.Unselect(const AIndex: Integer);
begin
  if AIndex = -1 then
    begin
      for var Item in FRegistry do
        Item.ApplySelected(False);
    end
  else
    begin
      if (AIndex >= 0) and (AIndex < FRegistry.Count) then
        FRegistry[AIndex].ApplySelected(False);
    end;
end;

function TContainer.ApplyDescription(const AValue: string): TContainer;
begin
  FThumbnail.Hint := AValue;
  Result := Self;
end;

function TContainer.ApplyGetitUrl(const AValue: string): TContainer;
begin
  FGetitUrl := AValue;
  Result := Self;
end;

function TContainer.ApplyGitHubUrl(const AValue: string): TContainer;
begin
  FGitHubUrl := AValue;
  Result := Self;
end;

function TContainer.ApplyImage(const AStream: TStream): TContainer;
begin
  if Assigned(AStream) then
    try
      FThumbnail.Picture.LoadFromStream(AStream);
    finally
      AStream.Free;
    end;
  Result := Self;
end;

function TContainer.ApplyIndex(const AValue: Integer): TContainer;
begin
  FIndex := AValue;
  Result := Self;
end;

function TContainer.ApplyName(const AValue: string): TContainer;
begin
  FLabel.Caption := AValue;
  Result := Self;
end;

function TContainer.ApplySelected(const AValue: Boolean): TContainer;
begin
  FSelected := AValue;

  if AValue then
    begin
      Color := TAppStyle.ApplyContainerMouseEnterColor;
      FLabel.Font.Color := TAppStyle.ApplyContainerFontSelectedColor;
      FContextPanel.Visible := True;
    end
  else
    begin
      Color := TAppStyle.ApplyContainerMouseLeaveColor;
      FLabel.Font.Color := TAppStyle.ApplyContainerFontUnSelectedColor;
      FContextPanel.Visible := False;
    end;

  Result := Self;
end;

function TContainer.ApplyTop(const AValue: Integer): TContainer;
begin
  Top := AValue;
  Result := Self;
end;

function TContainer.OnSelect(AProc: TProc<TObject>): TContainer;
begin
  FSelectionProc := AProc;
  Result := Self;
end;

end.

unit UI.PageSelector.VCL;

(*
  Unit: UI.PageSelector.VCL

  Purpose:
    This unit implements the logic for a UI page selection component in a Delphi VCL application.
    It provides a streamlined way to navigate between key pages (such as Chat History, File Search,
    Web Search, Reasoning, and Settings) using a ComboBox as selector linked to a TPageControl, with
    enhanced visual feedback through associated icons and a styled Label.

  Technical details:
    - Defines the TPageSelector enum and its helper for easy retrieval of string names, icons, default page,
      and conversion between enum and indices.
    - The TSelectorVCL class encapsulates the ComboBox, PageControl, and Label, wiring their behaviors
      and appearance to provide a seamless page selection experience.
    - Uses event handlers to synchronize ComboBox selection with TabControl pages and updates the Label
      to the selected page name.
    - Leverages custom styles from TAppStyle for unified UI appearance and behavior.
    - All setup logic (event wiring, populating ComboBox, default settings) is handled in class setters,
      making it easy to integrate or extend.

  Dependencies:
    - Uses `UI.Styles.VCL` for custom UI theming and styling applied to the selector controls.
    - Standard Delphi VCL controls: TComboBox, TPageControl, TLabel, etc.
    - `Manager.Intf` for integrating with broader application interfaces or infrastructure.

  Quick start for developers:
    - Instantiate TSelectorVCL, providing it with the target ComboBox, PageControl, and Label from your form.
    - The selector will automatically initialize, populate, and synchronize the UI elements.
    - Page changes in the ComboBox will activate the corresponding tab in the PageControl and update the label.
    - Extend the TPageSelector enum or its helper if you wish to add new pages or customize icons/names.

  This unit is intended to simplify the integration of a modern, visually consistent, and easily maintainable
  page selector in cross-page Delphi VCL applications.

*)

interface

uses
  Winapi.Windows, Winapi.Messages, Winapi.CommCtrl,
  System.SysUtils, System.Variants, System.Classes,
  Vcl.Graphics, Vcl.Controls, Vcl.StdCtrls, Vcl.ExtCtrls, Vcl.ComCtrls,
  Manager.Intf, Manager.Types, UI.Styles.VCL;

type
  /// <summary>
  /// Provides a unified, visually enhanced page selector component for Delphi VCL applications, enabling
  /// streamlined navigation between application pages such as Chat History, File Search, Web Search,
  /// Reasoning, and Settings.
  /// </summary>
  /// <remarks>
  /// <para>
  /// <c>TSelectorVCL</c> encapsulates the logic and user interface wiring required to synchronize a
  /// see "Vcl.StdCtrls.TComboBox", "Vcl.ComCtrls.TPageControl" and "Vcl.StdCtrls.TLabel"/> for seamless
  /// page selection.
  /// It leverages custom styles and icons for improved user experience and maintainability.
  /// </para>
  /// <para>
  /// Selecting a page via the ComboBox updates the PageControl and Label automatically, and all event
  /// handling and initialization are managed internally for easy integration. The class supports extension
  /// through enumeration updates for new pages or icons.
  /// </para>
  /// <para>
  /// TSelectorVCL follows File2knowledgeAI interface conventions and is intended for use in multi-page VCL
  /// applications that require quick, user-friendly page navigation.
  /// </para>
  /// </remarks>
  TSelectorVCL = class(TInterfacedObject, ISelector)
  private
    FComboBox: TComboBox;
    FPageControl: TPageControl;
    FLabel: TLabel;
    FCurrentPage: TPageSelector;
    FUpdating: Boolean;
    procedure SetCombobox(const Value: TComboBox);
    procedure SetPageControl(const Value: TPageControl);
    procedure SetLabel(const Value: TLabel);
    function GetActivePage: TPageSelector;
  protected
    procedure SetActivePage(const Page: TPageSelector);
    procedure HandleComboBoxChange(Sender: TObject);
    procedure HandleComboBoxCloseUp(Sender: TObject);
    procedure HandleOnActivePage(PageSelected: TPageSelector);
  public
    /// <summary>
    /// Creates an instance of <c>TSelectorVCL</c> for managing UI page selection in a VCL application.
    /// </summary>
    /// <param name="ACombobox">
    /// The <see cref="Vcl.StdCtrls.TComboBox"/> used for page selection.
    /// </param>
    /// <param name="APageControl">
    /// The <see cref="Vcl.ComCtrls.TPageControl"/> representing the application pages.
    /// </param>
    /// <param name="ALabel">
    /// The <see cref="Vcl.StdCtrls.TLabel"/> providing visual feedback for the selected page.
    /// </param>
    constructor Create(const ACombobox: TComboBox; const APageControl: TPageControl;
      const ALabel: TLabel);

    /// <summary>
    /// Displays and activates the specified page in the selector.
    /// Synchronizes the ComboBox selection, PageControl tab, and Label to reflect the chosen page.
    /// </summary>
    /// <param name="Page">
    /// The <see cref="Manager.Types.TPageSelector"/> value identifying the page to show.
    /// </param>
    procedure ShowPage(const Page: TPageSelector);

    /// <summary>
    /// Gets or sets the currently active page in the selector.
    /// </summary>
    /// <remarks>
    /// Setting this property changes the UI to reflect the active page,
    /// updating the ComboBox, PageControl, and Label accordingly.
    /// </remarks>
    property ActivePage: TPageSelector read GetActivePage write ShowPage;
  end;

implementation

{ TSelectorVCL }

constructor TSelectorVCL.Create(const ACombobox: TComboBox;
  const APageControl: TPageControl; const ALabel: TLabel);
begin
  inherited Create;
  FCurrentPage := TPageSelector.Default;
  FUpdating := False;

  SetCombobox(ACombobox);
  for var i := 0 to FComboBox.Items.Count-1 do
  Assert(FComboBox.Items[i] = TPageSelector(i).ToIcon,
    Format('Combo[%d] <> Enum icon', [i]));

  SetPageControl(APageControl);
  Assert(FPageControl.PageCount = TPageSelector.Count,
    'Enum <> PageControl : update either');

  SetLabel(ALabel);
end;

function TSelectorVCL.GetActivePage: TPageSelector;
begin
  Result := FCurrentPage;
end;

procedure TSelectorVCL.HandleComboBoxChange(Sender: TObject);
begin
  SetActivePage(TPageSelector.IconToPage(FComboBox.Text));
end;

procedure TSelectorVCL.HandleComboBoxCloseUp(Sender: TObject);
begin
  ServicePrompt.SetFocus;
end;

procedure TSelectorVCL.HandleOnActivePage(PageSelected: TPageSelector);
begin
  if PageSelected in ResponsesPages then
    PromptSelector.Update else
    PromptSelector.Hide;

  case PageSelected of
    psHistoric: ;
    psFileSearch: ;
    psWebSearch: ;
    psReasoning: ;
    psVectorFile: VectorResourceEditor.Refresh;
    psSettings: ;
  end;
end;

procedure TSelectorVCL.SetActivePage(const Page: TPageSelector);
begin
  if FUpdating or (Page = FCurrentPage) then Exit;

  FUpdating := True;
  try
    FCurrentPage := Page;
    FLabel.Caption := Page.ToString;
    HandleOnActivePage(FCurrentPage);
    FComboBox.ItemIndex := Page.IndexOf;
    FPageControl.ActivePageIndex := Page.IndexOf;
  finally
    FUpdating := False;
  end;
end;

procedure TSelectorVCL.SetCombobox(const Value: TComboBox);
begin
  FComboBox := Value;
  TAppStyle.ApplyPageSelectorComboBoxStyleBig(Value,
    procedure
    begin
      FComboBox.Items.Text := TPageSelector.AllIcons;
      FComboBox.ItemIndex := TPageSelector.Default.IndexOf;
      FComboBox.DropDownCount := TPageSelector.Count;

      FComboBox.OnChange := HandleComboBoxChange;
      FComboBox.OnCloseUp := HandleComboBoxCloseUp;
    end);
end;

procedure TSelectorVCL.SetLabel(const Value: TLabel);
begin
  FLabel := Value;
  TAppStyle.ApplyPageSelectorLabelStyle(Value);
end;

procedure TSelectorVCL.SetPageControl(const Value: TPageControl);
begin
  FPageControl := Value;
end;

procedure TSelectorVCL.ShowPage(const Page: TPageSelector);
begin
  var LPage := Page;
  if TThread.Current.ThreadID = MainThreadID then
    SetActivePage(LPage)
  else
    TThread.Queue(nil,
      procedure begin SetActivePage(LPage); end);
end;

end.


unit UI.PromptEditor.VCL;

{*
  Unit: UI.PromptEditor.VCL

  Description:
    This unit handles prompt editing and asynchronous submission
    using a Promise-based mechanism.
    It provides the TServicePrompt class, which encapsulates all end-user logic,
    enabling:
      - Editing, validating, and submitting a prompt.
      - Launching an asynchronous request to generate a response (e.g., via OpenAI).
      - Automatically detecting when the current chat requires naming (first Q&A or default title)
        and assigning a generated chat title on the fly through a secondary async request if necessary.
    User input and validation are managed through event bindings,
    ensuring a consistent and responsive user experience in the UI.

  Key points:
    - Promise-oriented design, allowing long-running tasks without freezing the UI.
    - Open architecture, making it easy to extend styles or submission behaviors.
    - Automatic contextual chat naming support at the start of a new conversation.

*}

interface

uses
  System.SysUtils, System.Classes, Winapi.Windows, System.Generics.Collections,
  Vcl.StdCtrls, Vcl.ComCtrls, Vcl.Controls, Vcl.Buttons,
  System.Character, System.UITypes,
  Manager.Intf, Manager.Async.Promise, Manager.Utf8Mapping, Manager.Types,
  UI.Styles.VCL;

const
  NEW_CHAT_TITLE = 'New chat ...';
  NAMING_INSTRUCTION =
    'For each prompt and answer provided, generate in ≤6 words the main idea of ​​the “QR” (question-answer).';

type
  /// <summary>
  /// Implements the IServicePrompt interface to manage prompt editing, validation,
  /// and asynchronous submission for AI responses within a VCL application.
  /// </summary>
  /// <remarks>
  /// This class encapsulates the end-user logic, binding to a TRichEdit editor
  /// and a validation button, managing user input, and launching asynchronous
  /// requests to a prompt engine such as OpenAI. It supports automatic chat naming
  /// on the first question-answer exchange or when the default title is present.
  /// </remarks>
  TServicePrompt = class(TInterfacedObject, IServicePrompt)
  private
    ///<summary> Reference to the text editor control used for prompt input. </summary>
    FEditor: TRichEdit;

    ///<summary> Reference to the validation button control. </summary>
    FValidation: TSpeedButton;

    procedure SetEditor(const Value: TRichEdit);
    procedure SetValidation(const Value: TSpeedButton);
    function GetText: string;
    procedure SetText(const Value: string);
    procedure SetEvents(Component: TControl);

    ///<summary> Determines whether the current chat requires automatic naming. </summary>
    ///<returns> True if naming is required; otherwise, False. </returns>
    function NeedToName: Boolean;

    ///<summary> Prepares the naming prompt combining the prompt and response text. </summary>
    ///<param name="Value"> Incoming response text. </param>
    ///<param name="Text"> Original prompt text. </param>
    ///<returns> A formatted string used to request automatic chat naming. </returns>
    function PrepareNamingPromt(const Value, Text: string): string;

    /// <summary> Gets the instruction text used during automatic naming. </summary>
    function GetInstructions: string;
  protected
    ///<summary> Handles key down events in the editor control. </summary>
    ///<param name="Sender"> The source of the event. </param>
    ///<param name="Key"> The key code pressed. </param>
    ///<param name="Shift"> The state of shift keys. </param>
    procedure HandleKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState); virtual;

    ///<summary> Executes the prompt submission asynchronously when triggered.</summary>
    ///<param name="Sender"> The source of the execution event. </param>
    procedure Execute(Sender: TObject);

    function CanExecute: Boolean;
  public
    ///<summary> Constructor for TServicePrompt requiring editor and validation button. </summary>
    ///<param name="AEditor"> The TRichEdit component used for input. </param>
    ///<param name="AButtonValidation"> The button to validate and submit the prompt. </param>
    constructor Create(const AEditor: TRichEdit; const AButtonValidation: TSpeedButton);

    ///<summary>
    /// Clears the current prompt text from the editor.
    /// </summary>
    procedure Clear;

    ///<summary>
    /// Sets focus to the prompt editor control.
    ///</summary>
    procedure SetFocus;

    ///<summary>
    /// Gets the bound editor control.
    ///</summary>
    property Editor: TRichEdit read FEditor;

    ///<summary>
    /// Gets or sets the prompt text.
    ///</summary>
    property Text: string read GetText write SetText;

    ///<summary>
    /// Gets the validation button control.
    ///</summary>
    property Validation: TSpeedButton read FValidation;
  end;

implementation

{ TServicePrompt }

function TServicePrompt.CanExecute: Boolean;
begin
  if sf_fileSearchDisabled in ServiceFeatureSelector.FeatureModes then
    Exit(True);

  Result := AlertService.ShowConfirmation(
      'Broken link between the file and the vectore store.'#10'Confirm linkage ?') = mrYes;
  if Result then
    begin
      if Length(FileStoreManager.Files) > 0 then
        begin
          FileStoreManager.PingVectorStore
            .&Then<string>(
              function (Value: string): string
              begin
                Execute(nil);
                VectorResourceEditor.Refresh;
              end);
          Exit(False);
        end;
    end
end;

procedure TServicePrompt.Clear;
begin
  Text := EmptyStr;
end;

constructor TServicePrompt.Create(const AEditor: TRichEdit;
  const AButtonValidation: TSpeedButton);
begin
  inherited Create;
  SetEditor(AEditor);
  SetValidation(AButtonValidation);
end;

procedure TServicePrompt.Execute(Sender: TObject);
var
  Promise: TPromise<string>;
begin
  if FileStoreManager.VectorStore.Trim.IsEmpty and not CanExecute then
    Exit;

  EdgeDisplayer.Show;
  var Prompt := TUtf8Mapping.CleanTextAsUTF8(FEditor.Lines.Text);
  if not string(Prompt).Trim.IsEmpty then
    begin
      Promise := OpenAI.Execute(Prompt);

      if NeedToName then
        begin
          Promise
            .&Then<string>(
              function (Value: string): string
              begin
                Result := PrepareNamingPromt(Value, Text);
              end)
            .&Then(
              function (Value: string): TPromise<string>
              begin
                Result := OpenAI.ExecuteSilently(Value, GetInstructions);
              end)
            .&Then<string>(
              function (Value: string): string
              begin
                PersistentChat.CurrentChat.ApplyTitle(Value);
                PersistentChat.SaveToFile;
                ChatSessionHistoryView.Refresh(nil);
              end)
            .&Catch(
              procedure(E: Exception)
              begin
//                AlertService.ShowError(E.Message);
//                EdgeDisplayer.DisplayStream(E.Message);
              end);
        end;
    end;
  SetFocus;
end;

function TServicePrompt.GetInstructions: string;
begin
  Result := NAMING_INSTRUCTION;
end;

function TServicePrompt.GetText: string;
begin
  Result := string(TUtf8Mapping.CleanTextAsUTF8(FEditor.Lines.Text));
end;

procedure TServicePrompt.HandleKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
  case key of
    VK_RETURN:
      begin
        if ssShift in Shift then
          Text.Insert(FEditor.SelStart, #10)
        else
          begin
            Key := 0;
            FEditor.SelStart := Text.Length;
            Execute(Self);
          end;
      end;
    Ord('N'):
      begin
        if ssCtrl in Shift then
          LeftPanelControl.HandleNew(Sender);
      end;
    VK_ESCAPE:
      begin
        LeftPanelControl.HandleNew(Sender);
      end;
    VK_F1:
      begin
        Selector.ShowPage(psFileSearch);
      end;
    VK_F2:
      begin
        Selector.ShowPage(psWebSearch);
      end;
    VK_F3:
      begin
        Selector.ShowPage(psReasoning);
      end;
    VK_F5:
      begin
        ServiceFeatureSelector.SwitchWebSearch;
      end;
    VK_F6:
      begin
        ServiceFeatureSelector.SwitchDisableFileSearch
      end;
    VK_F7:
      begin
        ServiceFeatureSelector.SwitchReasoning;
      end;
    VK_F8:
      begin
        Selector.ShowPage(psSettings);
      end;
    VK_F9:
      begin
        LeftPanelControl.HandleSwitch(Sender);
      end;
  end;
end;

function TServicePrompt.NeedToName: Boolean;
begin
  Result := (Length(PersistentChat.CurrentChat.Data) = 1) or
            (PersistentChat.CurrentChat.Title = NEW_CHAT_TITLE);
end;

function TServicePrompt.PrepareNamingPromt(const Value, Text: string): string;
begin
  Result := Format('Question: %s'#10'Response: %s', [Text, Value]);
end;

procedure TServicePrompt.SetEditor(const Value: TRichEdit);
begin
  FEditor := Value;
  TAppStyle.ApplyPromptEditorRichEditStyle(Value,
    procedure
    begin
      FEditor.EditMargins.Left := 16;
      FEditor.EditMargins.Right := 8;
      SetEvents(FEditor);
    end);
end;

procedure TServicePrompt.SetEvents(Component: TControl);
begin
  if not Assigned(Component) then
    Exit;

  if Component is TSpeedButton  then
    begin
      TButton(Component).OnClick := Execute;
    end
  else
  if Component is TRichEdit then
    begin
      TRichEdit(Component).OnKeyDown := HandleKeyDown;
    end;
end;

procedure TServicePrompt.SetFocus;
begin
  FEditor.SetFocus;
end;

procedure TServicePrompt.SetText(const Value: string);
begin
  FEditor.Text := Value;
end;

procedure TServicePrompt.SetValidation(const Value: TSpeedButton);
begin
  FValidation := Value;
  TAppStyle.ApplyPromptEditorButtonStyle(Value,
    procedure
    begin
      SetEvents(FValidation);
    end);
end;

end.

unit UI.PromptSelector.VCL;

(*
  Unit: UI.PromptSelector.VCL

  Purpose:
    Provides a visual prompt selector control for Delphi VCL applications, enabling users to efficiently browse, select, and display previous prompts (or history items) within the application's interface.
    This unit delivers robust navigation, annotation updates, and user experience improvements for prompt handling scenarios.

  Architecture and Design:
    - Follows project standards for pragmatic, maintainable UI logic without enforcing strict MVC/MVP/MVVM separation, aligning with quick prototyping and developer onboarding priorities.
    - Centralizes all prompt selection, navigation, and annotation-update logic inside a self-contained class (TPromptSelectorVCL).
    - Leverages injected references to core VCL controls (panel, memo, navigation buttons, and labels) for straightforward UI binding and extensibility.
    - Synchronizes selection state with auxiliary components such as the persistent prompt/chat history and file/web/reasoning annotators.
    - Applies UI appearance and interaction standards via dedicated style helpers (see UI.Styles.VCL).

  Technical Features:
    - Supports intuitive navigation through prompt history using up/down buttons and index display.
    - Provides immediate UI feedback and annotation updates as the user selects different prompts.
    - Can be programmatically shown or hidden, and refreshed to synchronize with changing data sources.
    - Minimizes UI state wiring by centralizing refresh and navigation logic.

  Usage:
    - Instantiate TPromptSelectorVCL once with the relevant panel, memo, label, and navigation buttons.
    - Call Update whenever the underlying prompt history changes to refresh the selector.
    - Use the Show, Hide, and ItemIndex members for UI and selection management.

  Dependencies:
    - Requires VCL standard controls, UI.Styles.VCL for styling integration, and prompt/history management components for data linkage.

  This unit is provided as a ready-to-integrate component following File2knowledgeAI UI and architecture conventions, facilitating clear prompt history navigation and extensible, maintainable code structure.
*)

interface

uses
  System.SysUtils, System.Classes, Winapi.Windows,
  Vcl.StdCtrls, Vcl.ComCtrls, Vcl.Controls, Vcl.Buttons, Vcl.ExtCtrls,
  Manager.Intf, Manager.Async.Promise, Manager.Types, Manager.Utf8Mapping,
  UI.Styles.VCL;

type
  /// <summary>
  /// Implements a visual prompt selector component for Delphi VCL applications.
  /// </summary>
  /// <remarks>
  /// <para>
  /// Provides a user interface for navigating and displaying a list of prompts.
  /// Includes up/down navigation buttons, visual feedback, and annotations for prompt history.
  /// </para>
  /// <para>
  /// Follows the application’s UI and style conventions.
  /// </para>
  /// </remarks>
  TPromptSelectorVCL = class(TInterfacedObject, IPromptSelector)
  private
    FPanel: TPanel;
    FPrompt: TMemo;
    FLabel: TLabel;
    FUpButton: TSpeedButton;
    FDownButton: TSpeedButton;
    FItemIndex: Integer;
    FCount: Integer;
    procedure SetPanel(const Value: TPanel);
    procedure SetPrompt(const Value: TMemo);
    procedure SetLabel(const Value: TLabel);
    procedure SetUpButton(const Value: TSpeedButton);
    procedure SetDownButton(const Value: TSpeedButton);
    procedure SetItemIndex(const Value: Integer);
    function GetItemIndex: Integer;
    procedure Refresh;
  protected
    procedure HandleUpButton(Sender: TObject);
    procedure HandleDownButton(Sender: TObject);
    procedure HandlePromptClick(Sender: TObject);
  public
    /// <summary>
    /// Constructs and initializes the prompt selector UI.
    /// </summary>
    /// <param name="APanel">The panel container to host the selector controls.</param>
    /// <param name="APrompt">The TMemo control used to display the prompt text.</param>
    /// <param name="ALabel">The label showing the current prompt index and count.</param>
    /// <param name="AUpButton">Button for navigating to the next prompt in the list.</param>
    /// <param name="ADownButton">Button for navigating to the previous prompt in the list.</param>
    constructor Create(const APanel: TPanel; const APrompt: TMemo; const ALabel: TLabel;
      AUpButton, ADownButton: TSpeedButton);

    /// <summary>
    /// Updates the prompt selector UI to reflect current application state.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Refreshes the display, sets the item count and current index,
    /// and updates all related visual elements according to the prompt data.
    /// </para>
    /// </remarks>
    procedure Update;

    /// <summary>
    /// Hides the prompt selector panel from the user interface.
    /// </summary>
    procedure Hide;

    /// <summary>
    /// Shows the prompt selector panel in the user interface.
    /// </summary>
    procedure Show;

    /// <summary>
    /// Gets or sets the currently selected prompt index.
    /// </summary>
    /// <returns>
    /// The zero-based index of the currently selected prompt.
    /// </returns>
    property ItemIndex: Integer read GetItemIndex write SetItemIndex;
  end;

implementation

{ TPromptSelectorVCL }

constructor TPromptSelectorVCL.Create(const APanel: TPanel;
  const APrompt: TMemo; const ALabel: TLabel; AUpButton,
  ADownButton: TSpeedButton);
begin
  inherited Create;
  SetPanel(APanel);
  SetPrompt(APrompt);
  SetLabel(ALabel);
  SetUpButton(AUpButton);
  SetDownButton(ADownButton);
end;

function TPromptSelectorVCL.GetItemIndex: Integer;
begin
  Result := FItemIndex;
end;

procedure TPromptSelectorVCL.HandleDownButton(Sender: TObject);
begin
  if ItemIndex > 0 then
    begin
      ItemIndex := ItemIndex - 1;
      Refresh;
    end;
  ServicePrompt.SetFocus;
end;

procedure TPromptSelectorVCL.HandlePromptClick(Sender: TObject);
begin
  ServicePrompt.SetFocus;
end;

procedure TPromptSelectorVCL.HandleUpButton(Sender: TObject);
begin
  if ItemIndex < FCount - 1 then
    begin
      ItemIndex := ItemIndex + 1;
      Refresh;
    end;
  ServicePrompt.SetFocus;
end;

procedure TPromptSelectorVCL.Hide;
begin
  FPanel.Visible := False;
end;

procedure TPromptSelectorVCL.Refresh;
begin
  var CurrentPrompt := PersistentChat.CurrentChat.Data[PromptSelector.ItemIndex];
  ChatSessionHistoryView.UpdateAnnotation(FileSearchDisplayer, CurrentPrompt.FileSearch);
  ChatSessionHistoryView.UpdateAnnotation(WebSearchDisplayer, CurrentPrompt.WebSearch);
  ChatSessionHistoryView.UpdateAnnotation(ReasoningDisplayer, CurrentPrompt.Reasoning);
end;

procedure TPromptSelectorVCL.SetDownButton(const Value: TSpeedButton);
begin
  FDownButton := Value;
  TAppStyle.ApplyPromptSelectorDownButtonStyle(Value,
    procedure
    begin
      FDownButton.OnClick := HandleDownButton;
    end);
end;

procedure TPromptSelectorVCL.SetItemIndex(const Value: Integer);
begin
  FItemIndex := Value;
  if FItemIndex < 0 then
    FItemIndex := 0;
  if FItemIndex >= FCount  then
    FItemIndex := FCount - 1;

  FLabel.Caption := Format('Prompt %d/%d', [FItemIndex + 1, FCount]);
  FPrompt.Lines.Text := PersistentChat.CurrentChat.Data[FItemIndex].Prompt;
  FPanel.Visible := True;
end;

procedure TPromptSelectorVCL.SetLabel(const Value: TLabel);
begin
  FLabel := Value;
  TAppStyle.ApplyPromptSelectorLabelStyle(Value);
end;

procedure TPromptSelectorVCL.SetPanel(const Value: TPanel);
begin
  FPanel := Value;
  TAppStyle.ApplyPromptSelectorPanelStyle(FPanel);
end;

procedure TPromptSelectorVCL.SetPrompt(const Value: TMemo);
begin
  FPrompt := Value;
  TAppStyle.ApplyPromptSelectorMemoStyle(Value,
    procedure
    begin
      FPrompt.OnClick := HandlePromptClick;
    end);
end;

procedure TPromptSelectorVCL.SetUpButton(const Value: TSpeedButton);
begin
  FUpButton := Value;
  TAppStyle.ApplyPromptSelectorUpButtonStyle(Value,
    procedure
    begin
      FUpButton.OnClick := HandleUpButton;
    end);
end;

procedure TPromptSelectorVCL.Show;
begin
  FPanel.Visible := True;
end;

procedure TPromptSelectorVCL.Update;
begin
  if PersistentChat.Count = 0 then
    begin
      FItemIndex := -1;
      FCount := 0;
      FPanel.Visible := False;
    end
  else
    begin
      if Assigned(PersistentChat.CurrentChat) then
        begin
          FCount := PersistentChat.CurrentChat.Count;
          ItemIndex := FCount - 1;
        end
      else
        begin
          FPanel.Visible := False;
        end;
    end;
end;

end.


unit UI.ServiceFeatureSelector.VCL;

(*
  Unit: UI.ServiceFeatureSelector.VCL

  Purpose:
    This unit implements the interface and business logic for dynamically managing the activation,
    deactivation, and presentation of File2knowledgeAI's main search features within a modern
    Delphi VCL application.
    It connects the visual service bar buttons (web search, file search, reasoning, etc.) to the
    project’s internal mode logic.
    The goal: to centralize and standardize the handling, synchronization, and display of service
    states (Web Search, File Search, Reasoning) while providing immediate user feedback and
    a consistent UX.

  Note on Architecture and Design Choices:
    Following the project’s pragmatic tradition, this unit favors self-contained, straightforward,
    and readable code: UI event handling, service state management, and UI effects are grouped
    together for easy iteration, demos, and rapid onboarding.
    This approach increases clarity while allowing for extensibility (adding modes, new buttons, or
    custom styles).
    The design remains modular enough for future refactoring, should stricter architectural patterns
    (MVC/MVP/MVVM) become necessary.
    The use of record helpers for interfaces and centralization of captions/hints ensures scalability
    and possible multilingual support, with built-in testability.

  Usage:
    Instantiate the selector with your VCL buttons (TSpeedButton) and the main caption label.
    All event wiring, state management, and UI updates are handled automatically to enable
    one-click mode switching and immediate UX enhancement.

  Dependencies:
    - VCL controls: TSpeedButton, TLabel, etc.
    - Project units: Manager.Intf, Manager.IoC, Manager.Types, UI.Styles.VCL
    - Internal helpers for mode management, styles, and UI callbacks.

  File2knowledgeAI project context:
    This unit embodies the best practice of centralizing feature toggling and UX synchronization
    around the new v1/responses endpoint and the product’s multimodal capabilities.
*)


interface

uses
  Winapi.Windows, Winapi.Messages, Winapi.CommCtrl,
  System.SysUtils, System.Classes, System.Generics.Collections,
  Vcl.Graphics, Vcl.Controls, Vcl.Buttons, Vcl.StdCtrls,
  Manager.Intf, Manager.IoC, Manager.Types, UI.Styles.VCL;

type
  TChainMode = (cmOpen, cmClose);

  TChainModeHelper = record Helper for TChainMode
  private
    const
      Icons: array[TChainMode] of string = (
        '', ''
      );
      Hints: array[TChainMode] of string = (
        'Disable File_search tool F6',
        'Enable File_search tool F6'
      );
  public
    function ToIcon: string;
    function ToHint: string;
    class function FromBoolean(Value: Boolean): TChainMode; static;
  end;

  TWebSearchHint = (wbEnable, wbDisable);

  TWebSearchHintHelper = record Helper for TWebSearchHint
  private
    const
      Hints: array[TWebSearchHint] of string = (
        'Enable Web Search F5',
        'Disable Web Search F5'
      );
  public
    function ToHint: string;
    class function FromBoolean(Value: Boolean): TWebSearchHint; static;
  end;

  TReasoningHint = (rEnable, rDisable);

  TReasoningHintHelper = record Helper for TReasoningHint
  private
     const
      Hints: array[TReasoningHint] of string = (
        'Enable Reasoning'#10'File_search disable F7',
        'Disable Reasoning'#10'File_search enable F7'
      );
  public
    function ToHint: string;
    class function FromBoolean(Value: Boolean): TReasoningHint; static;
  end;

  TMainCaptionType = (
    mcFileSearchActive,
    mcWebFileSearchActive,
    mcFileSearchDisabled,
    mcWebSearchActive,
    mcReasoningActive);

  TMainCaptionTypeHelper = record Helper for TMainCaptionType
  private
    const
      Labels: array[TMainCaptionType] of string = (
       'File Search Only',
       'Web && File Search',
       'File Search Disabled',
       'Web Search Only',
       'Reasoning Mode (Web && File Search Disabled)'
      );
  public
    function ToString: string;
    class function FromFeatureModes(Value: TFeatureModes): TMainCaptionType; static;
  end;


  /// <summary>
  /// UI and logic orchestrator for File2knowledgeAI main feature toggles in a Delphi VCL application.
  /// </summary>
  /// <remarks>
  /// TServiceFeatureSelector centralizes all event wiring, state management, and UI feedback related
  /// to toggling the core service modes—Web Search, File Search, and Reasoning.
  /// Through its constructor, you bind VCL controls (TSpeedButton and TLabel) for immediate
  /// synchronization of internal states with user-facing UI elements and captions.
  ///
  /// This class streamlines user experience by ensuring that visual control state, feature mode, and
  /// contextual hints/captions always remain coherent, and that switching one feature correctly
  /// updates the others as per the service logic.
  ///
  /// <para>
  /// The pragmatic, consolidated design emphasizes demo-readiness, maintainability, and fast
  /// onboarding, while still allowing for later modularization if stricter architectural separation is
  /// needed.
  /// </para>
  /// <para>
  /// This implementation is core to File2knowledgeAI's best practice of keeping dynamic UX features
  /// (mode switching, feature availability, etc.) synchronized with business logic and endpoint capabilities.
  /// </para>
  ///
  /// <param name="AWebSearchButton">Button to activate/deactivate Web Search mode.</param>
  /// <param name="ADisableFileSearchButton">Button to enable/disable File Search mode.</param>
  /// <param name="AReasoningButton">Button to enable/disable Reasoning mode (which also disables
  /// Web Search).</param>
  /// <param name="ACaptionLabel">Label control for displaying the current main caption, reflecting
  /// combined feature state.</param>
  /// </remarks>
  TServiceFeatureSelector = class(TInterfacedObject, IServiceFeatureSelector)
  private
    FWebSearchButton: TSpeedButton;
    FDisableFileSearchButton: TSpeedButton;
    FReasoningButton: TSpeedButton;
    FCaptionLabel: TLabel;
    procedure SetWebSearchButton(const Value: TSpeedButton);
    procedure SetDisableFileSearchButton(const Value: TSpeedButton);
    procedure SetReasoningButton(const Value: TSpeedButton);
    procedure SetCaptionLabel(const Value: TLabel);
    function GetFeatureModes: TFeatureModes;
    procedure HandleWebSearchButtonClick(Sender: TObject);
    procedure HandleDisableFileSearchButtonClick(Sender: TObject);
    procedure HandleReasoningButtonClick(Sender: TObject);
    procedure HintAndCaptionUpdate;
    procedure HandleCaptionOnMouseEnter(Sender: TObject);
    procedure HandleCaptionOnMouseLeave(Sender: TObject);
    procedure HandleCaptionOnMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure Activate(const Value: TSpeedButton);
  public
    constructor Create(const AWebSearchButton, ADisableFileSearchButton, AReasoningButton: TSpeedButton;
      const ACaptionLabel: TLabel);

    /// <summary>
    /// Programmatically toggles the Web Search mode, updating both internal state and UI accordingly.
    /// </summary>
    procedure SwitchWebSearch;

    /// <summary>
    /// Programmatically toggles the File Search feature disable mode, updating internal state and the UI.
    /// </summary>
    procedure SwitchDisableFileSearch;

    /// <summary>
    /// Programmatically toggles the Reasoning mode, enforcing the required disabling of Web Search and updating the UI.
    /// </summary>
    procedure SwitchReasoning;

    /// <summary>
    /// Gets the current combination of feature modes (Web Search, File Search Disabled, Reasoning)
    /// as reflected by the UI state of the corresponding buttons.
    /// </summary>
    property FeatureModes: TFeatureModes read GetFeatureModes;
  end;

implementation

{ TServiceFeatureSelector }

procedure TServiceFeatureSelector.Activate(const Value: TSpeedButton);
begin
  Value.Down := not Value.Down;
  Value.Click;
end;

constructor TServiceFeatureSelector.Create(const AWebSearchButton,
  ADisableFileSearchButton, AReasoningButton: TSpeedButton;
  const ACaptionLabel: TLabel);
begin
  inherited Create;
  SetWebSearchButton(AWebSearchButton);
  SetDisableFileSearchButton(ADisableFileSearchButton);
  SetReasoningButton(AReasoningButton);
  SetCaptionLabel(ACaptionLabel);
  HintAndCaptionUpdate;
end;

function TServiceFeatureSelector.GetFeatureModes: TFeatureModes;
begin
  Result := [];
  if FWebSearchButton.Down then
    Result := Result + [sf_webSearch];
  if FDisableFileSearchButton.Down then
    Result := Result + [sf_fileSearchDisabled];
  if FReasoningButton.Down then
    Result := Result + [sf_reasoning];
end;

procedure TServiceFeatureSelector.HandleCaptionOnMouseEnter(Sender: TObject);
begin
  FCaptionLabel.Font.Style := [fsBold,fsUnderline];
  FCaptionLabel.Cursor := crHandPoint;
end;

procedure TServiceFeatureSelector.HandleCaptionOnMouseLeave(Sender: TObject);
begin
  FCaptionLabel.Font.Style := [fsBold];
  FCaptionLabel.Cursor := crDefault;
end;

procedure TServiceFeatureSelector.HandleCaptionOnMouseUp(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  Selector.ShowPage(psSettings);
end;

procedure TServiceFeatureSelector.HandleDisableFileSearchButtonClick(
  Sender: TObject);
begin
  HintAndCaptionUpdate;
end;

procedure TServiceFeatureSelector.HandleReasoningButtonClick(Sender: TObject);
begin
  FWebSearchButton.Down := False;
  HintAndCaptionUpdate;
end;

procedure TServiceFeatureSelector.HandleWebSearchButtonClick(Sender: TObject);
begin
  if FReasoningButton.Down then
    FWebSearchButton.Down := False;
  HintAndCaptionUpdate;
end;

procedure TServiceFeatureSelector.HintAndCaptionUpdate;
begin
  FWebSearchButton.Hint := TWebSearchHint.FromBoolean(FWebSearchButton.Down).ToHint;
  FDisableFileSearchButton.Hint := TChainMode.FromBoolean(FDisableFileSearchButton.Down).ToHint;
  FDisableFileSearchButton.Caption := TChainMode.FromBoolean(FDisableFileSearchButton.Down).ToIcon;
  FReasoningButton.Hint :=  TReasoningHint.FromBoolean(FReasoningButton.Down).ToHint;
  FCaptionLabel.Caption := TMainCaptionType.FromFeatureModes(FeatureModes).ToString;
end;

procedure TServiceFeatureSelector.SetCaptionLabel(const Value: TLabel);
begin
  FCaptionLabel := Value;
  TAppStyle.ApplyCaptionLabelStyle(Value,
    procedure
    begin
      FCaptionLabel.OnMouseEnter := HandleCaptionOnMouseEnter;
      FCaptionLabel.OnMouseLeave := HandleCaptionOnMouseLeave;
      FCaptionLabel.OnMouseUp := HandleCaptionOnMouseUp;
    end);
end;

procedure TServiceFeatureSelector.SetDisableFileSearchButton(
  const Value: TSpeedButton);
begin
  FDisableFileSearchButton := Value;
  TAppStyle.ApplyDisableFileSearchButtonStyle(Value,
    procedure
    begin
      FDisableFileSearchButton.OnClick := HandleDisableFileSearchButtonClick;
    end);
end;

procedure TServiceFeatureSelector.SetReasoningButton(const Value: TSpeedButton);
begin
  FReasoningButton := Value;
  TAppStyle.ApplyReasoningButtonStyle(Value,
    procedure
    begin
      FReasoningButton.OnClick := HandleReasoningButtonClick;
    end)
end;

procedure TServiceFeatureSelector.SetWebSearchButton(const Value: TSpeedButton);
begin
  FWebSearchButton := Value;
  TAppStyle.ApplyWebSearchButtonStyle(Value,
    procedure
    begin
      FWebSearchButton.OnClick := HandleWebSearchButtonClick;
    end);
end;

procedure TServiceFeatureSelector.SwitchDisableFileSearch;
begin
  Activate(FDisableFileSearchButton);
end;

procedure TServiceFeatureSelector.SwitchReasoning;
begin
  Activate(FReasoningButton);
end;

procedure TServiceFeatureSelector.SwitchWebSearch;
begin
  Activate(FWebSearchButton);
end;

{ TChainModeHelper }

class function TChainModeHelper.FromBoolean(Value: Boolean): TChainMode;
begin
  Result := TChainMode(Ord(Value));
end;

function TChainModeHelper.ToHint: string;
begin
  Result := Hints[Self];
end;

function TChainModeHelper.ToIcon: string;
begin
  Result := Icons[Self];
end;

{ TWebSearchHintHelper }

class function TWebSearchHintHelper.FromBoolean(Value: Boolean): TWebSearchHint;
begin
  Result := TWebSearchHint(Ord(Value));
end;

function TWebSearchHintHelper.ToHint: string;
begin
  Result := Hints[Self];
end;

{ TReasoningHintHelper }

class function TReasoningHintHelper.FromBoolean(Value: Boolean): TReasoningHint;
begin
  Result := TReasoningHint(Ord(Value));
end;

function TReasoningHintHelper.ToHint: string;
begin
  Result := Hints[Self];
end;

{ TMainCaptionTypeHelper }

class function TMainCaptionTypeHelper.FromFeatureModes(
  Value: TFeatureModes): TMainCaptionType;
begin
  Result := TMainCaptionType(PByte(@Value)^);
end;

function TMainCaptionTypeHelper.ToString: string;
begin
  Result := Labels[Self];
end;

end.

unit UI.Styles.VCL;

interface

uses
  System.SysUtils, System.Classes, System.UITypes,
  Vcl.Controls, Vcl.StdCtrls, Vcl.Mask, Vcl.Graphics, Vcl.ExtCtrls, Vcl.ComCtrls,
  Vcl.Forms, Vcl.Buttons, Helper.PanelRoundedCorners.VCL;

type
  TAppStyle = class
  public
    {--- Refer to UI.UserSettings.VCL }
    class procedure ApplyUserSettingsLabelStyle(Value: TLabel; Proc: TProc = nil);
    class procedure ApplyUserSettingsComboBoxStyle(Value: TComboBox; Proc: TProc = nil);
    class procedure ApplyUserSettingsComboBoxStyleStar(Value: TComboBox; Proc: TProc = nil);
    class procedure ApplyUserSettingsMaskEditStyle(Value: TMaskEdit; Proc: TProc; Password: Boolean = False);

    {--- Refer to UI.PageSelector.VCL }
    class procedure ApplyPageSelectorLabelStyle(Value: TLabel; Proc: TProc = nil);
    class procedure ApplyPageSelectorComboBoxStyleBig(Value: TComboBox; Proc: TProc = nil);

    {--- UI.AnimatedVectorLeftPanel.VCL }
    class procedure ApplyAnimatedVectorLeftPanelButtonStyle(Value: TButton; Proc: TProc = nil);

    {--- UI.Container.VCL }
    class procedure ApplyContainerCorePanelStyle(Value: TPanel; Proc: TProc = nil);
    class procedure ApplyContainerBackgroundPanelStyle(Value: TPanel; Proc: TProc = nil);
    class procedure ApplyContainerImageStyle(Value: TImage; Proc: TProc = nil);
    class procedure ApplyContainerLabelStyle(Value: TLabel; Proc: TProc = nil);
    class procedure ApplyContainerPanelStyle(Value: TPanel; Proc: TProc = nil);

    class function ApplyContainerMouseEnterColor: TColor;
    class function ApplyContainerMouseLeaveColor: TColor;
    class function ApplyContainerFontSelectedColor: TColor;
    class function ApplyContainerFontUnSelectedColor: TColor;

    {--- UI.PromptEditor.VCL }
    class procedure ApplyPromptEditorRichEditStyle(Value: TRichEdit; Proc: TProc = nil);
    class procedure ApplyPromptEditorButtonStyle(Value: TSpeedButton; Proc: TProc = nil);

    {--- CancellationButton.VCL }
    class procedure ApplyCancellationButtonStyle(Value: TSpeedButton; Proc: TProc = nil);

    {--- UI.ServiceFeatureSelector.VCL }
    class procedure ApplyWebSearchButtonStyle(Value: TSpeedButton; Proc: TProc = nil);
    class procedure ApplyDisableFileSearchButtonStyle(Value: TSpeedButton; Proc: TProc = nil);
    class procedure ApplyReasoningButtonStyle(Value: TSpeedButton; Proc: TProc = nil);
    class procedure ApplyCaptionLabelStyle(Value: TLabel; Proc: TProc = nil);


    {--- UI.PromptSelector.VCL }
    class procedure ApplyPromptSelectorPanelStyle(Value: TPanel; Proc: TProc = nil);
    class procedure ApplyPromptSelectorMemoStyle(Value: TMemo; Proc: TProc = nil);
    class procedure ApplyPromptSelectorLabelStyle(Value: TLabel; Proc: TProc = nil);
    class procedure ApplyPromptSelectorUpButtonStyle(Value: TSpeedButton; Proc: TProc = nil);
    class procedure ApplyPromptSelectorDownButtonStyle(Value: TSpeedButton; Proc: TProc = nil);

    {--- UI.VectorResourceEditor.VCL }
    class procedure ApplyVectorResourceEditorListviewStyle(Value: TListView; Proc: TProc = nil);
    class procedure ApplyVectorResourceEditorScrollBoxStyle(Value: TScrollBox; Proc: TProc = nil);
    class procedure ApplyVectorResourceEditorImageStyle(Value: TImage; Proc: TProc = nil);
    class procedure ApplyVectorResourceEditorMaskEditTitleStyle(Value: TMaskEdit; Proc: TProc = nil);
    class procedure ApplyVectorResourceEditorMaskEditDarkStyle(Value: TMaskEdit; Proc: TProc = nil);
    class procedure ApplyVectorResourceEditorTrashButtonStyle(Value: TSpeedButton; Proc: TProc = nil);
    class procedure ApplyVectorResourceEditorThumbtackButtonStyle(Value: TSpeedButton; Proc: TProc = nil);
    class procedure ApplyVectorResourceEditorConfirmationPanelStyle(Value: TPanel; Proc: TProc = nil);
    class procedure ApplyVectorResourceEditorConfirmationButtonStyle(Value: TSpeedButton; Proc: TProc = nil);
    class procedure ApplyVectorResourceEditorLabelStyle(Value: TLabel; Proc: TProc = nil);
    class procedure ApplyVectorResourceEditorWarningPanelStyle(Value: TPanel; Proc: TProc = nil);

    {--- UI.ChatSession.VCL }
    class procedure ApplyChatSessionListviewStyle(Value: TListView; Proc: TProc = nil);
    class procedure ApplyChatSessionExecuteButtonStyle(Value: TSpeedButton; Proc: TProc = nil);
    class procedure ApplyChatSessionConfirmationPanelStyle(Value: TPanel; Proc: TProc = nil);
  end;

implementation

class procedure TAppStyle.ApplyUserSettingsComboBoxStyleStar(Value: TComboBox; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.Style := csOwnerDrawFixed;
  Value.ItemHeight := 24;
  Value.Font.Name := 'Segoe MDL2 Assets';
  Value.Font.Color := clYellow;
  Value.Font.Size := 11;
  Value.TabStop := False;

  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyUserSettingsLabelStyle(Value: TLabel; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.Font.Color := clGrayText;
  Value.Font.Size := 10;
  Value.StyleElements := [seClient, seBorder];

  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyAnimatedVectorLeftPanelButtonStyle(
  Value: TButton; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.Font.Name := 'Segoe MDL2 Assets';
  Value.Font.Size := 14;
  Value.ShowHint := True;
  Value.TabStop := False;

  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyCancellationButtonStyle(Value: TSpeedButton; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.Font.Name := 'Segoe MDL2 Assets';
  Value.Font.Size := 14;

  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyCaptionLabelStyle(Value: TLabel; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.Caption := 'File Search Only';
  Value.AlignWithMargins := True;
  Value.AutoSize := True;
  Value.Font.Size := 14;
  Value.Font.Name := 'Segoe UI';
  Value.Font.Style := [fsBold];
  Value.Layout := tlCenter;
  Value.Margins.Left := 18;
  Value.ShowHint := True;
  Value.Hint := 'Show settings F8';
  Value.StyleElements := [seFont,seClient,seBorder];

  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyChatSessionConfirmationPanelStyle(
  Value: TPanel; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.BevelOuter := bvNone;
  Value.BorderStyle := bsNone;
  Value.Color := $001F1F1F;
  Value.StyleElements := [seFont,seBorder];
  Value.ParentBackground := False;
  Value.ParentColor := False;

  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyChatSessionExecuteButtonStyle(
  Value: TSpeedButton; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.StyleElements := [seFont,seBorder];
  Value.Height := 22;
  Value.Width := 97;
  Value.Transparent := True;

  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyChatSessionListviewStyle(Value: TListView;
  Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.BevelInner := bvNone;
  Value.BevelOuter := bvNone;
  Value.BorderStyle := bsNone;
  Value.ParentColor := False;
  Value.RowSelect := True;

  Value.TabStop := False;

  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyContainerBackgroundPanelStyle(Value: TPanel; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.BevelOuter := bvNone;
  Value.BorderWidth := 0;
  Value.Color := $001A1A1A;
  Value.StyleElements := [seFont, seBorder];
  Value.ParentColor := False;
  Value.ParentBackground := False;
  Value.SetRoundedCorners(6, 6);

  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyContainerCorePanelStyle(Value: TPanel; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.Color := $001A1A1A;
  Value.StyleElements := [seFont, seBorder];
  Value.BevelOuter := bvNone;
  Value.ParentColor := False;
  Value.ParentBackground := False;
  Value.FullRepaint := False;
  Value.BorderWidth := 0;
  Value.SetRoundedCorners(16, 16);

  if Assigned(Proc) then
    Proc();
end;

class function TAppStyle.ApplyContainerFontSelectedColor: TColor;
begin
  Result := clBlack;
end;

class function TAppStyle.ApplyContainerFontUnSelectedColor: TColor;
begin
  Result := clWhite;
end;

class procedure TAppStyle.ApplyContainerImageStyle(Value: TImage; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.Align := alClient;
  Value.Proportional := True;
  Value.ShowHint := True;
  Value.Transparent := True;
  Value.Center := True;

  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyContainerLabelStyle(Value: TLabel; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.StyleElements := [seClient, seBorder];
  Value.Font.Color := clWhite;
  Value.Transparent := True;
  Value.ParentColor := False;

  if Assigned(Proc) then
    Proc();
end;

class function TAppStyle.ApplyContainerMouseEnterColor: TColor;
begin
  Result := $00F4C16C;
end;

class function TAppStyle.ApplyContainerMouseLeaveColor: TColor;
begin
  Result := $001A1A1A;
end;

class procedure TAppStyle.ApplyContainerPanelStyle(Value: TPanel; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.Color := TAppStyle.ApplyContainerMouseEnterColor;
  Value.StyleElements := [seBorder];
  Value.BevelOuter := bvNone;
  Value.ParentColor := False;
  Value.ParentBackground := False;
  Value.FullRepaint := False;
  Value.BorderWidth := 0;
  Value.Font.Color := clBlack;
  Value.Font.Size := 14;
  Value.Font.Style := [fsBold];
  Value.Font.Name := 'Segoe MDL2 Assets';
  Value.Caption := '';
  Value.Visible := False;

  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyDisableFileSearchButtonStyle(
  Value: TSpeedButton; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.AllowAllUp := True;
  Value.Caption := '';
  Value.GroupIndex := 3;
  Value.Hint := 'Disable File_search tool';
  Value.ShowHint := True;
  Value.Height := 33;
  Value.StyleElements := [seClient,seBorder];
  Value.Width := 33;

  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyPageSelectorComboBoxStyleBig(
  Value: TComboBox; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.Top := -1;
  Value.Font.Name := 'Segoe MDL2 Assets';
  Value.Font.Size := 25;
  Value.Style := csOwnerDrawFixed;
  Value.ItemHeight := 46;
  Value.StyleElements := [seFont, seClient, seBorder];
  Value.TabStop := False;

  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyPageSelectorLabelStyle(Value: TLabel; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.Font.Color := clWhite;
  Value.Font.Size := 12;
  Value.Font.Style := [fsBold];
  Value.StyleElements := [seClient, seBorder];
  Value.Alignment := taRightJustify;

  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyPromptEditorButtonStyle(Value: TSpeedButton; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.Caption := '';
  Value.Font.Name := 'Segoe MDL2 Assets';
  Value.Font.Size := 14;

   if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyPromptEditorRichEditStyle(Value: TRichEdit; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.HideScrollBars := True;
  Value.HideSelection := False;
  Value.AlignWithMargins := True;
  Value.Margins.Left := 8;
  Value.Anchors := [akLeft,akTop,akRight,akBottom];
  Value.BorderStyle := bsNone;
  Value.ScrollBars := ssVertical;
  Value.SpellChecking := True;
  Value.WantReturns := False;
  Value.WordWrap := True;
  Value.TabStop := True;
  Value.WantTabs := True;

  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyPromptSelectorDownButtonStyle(
  Value: TSpeedButton; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.AllowAllUp := True;
  Value.Font.Color := clWhite;
  Value.Caption := '';
  Value.Height := 33;
  Value.StyleElements := [seClient,seBorder];
  Value.Width := 33;

  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyPromptSelectorLabelStyle(Value: TLabel; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.Align := alLeft;
  Value.AlignWithMargins := True;
  Value.Font.Style := [fsBold];
  Value.Layout := tlCenter;
  Value.AutoSize := True;

  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyPromptSelectorMemoStyle(Value: TMemo; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.ReadOnly := True;
  Value.Font.Size := 10;
  Value.Font.Color := clSilver;
  Value.ScrollBars := ssVertical;
  Value.EditMargins.Left := 8;
  Value.EditMargins.Right := 8;
  Value.StyleElements := [seClient,seBorder];
  Value.Align := alClient;
  Value.BorderStyle := bsNone;

  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyPromptSelectorPanelStyle(Value: TPanel; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.Visible := False;

  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyPromptSelectorUpButtonStyle(
  Value: TSpeedButton; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.AllowAllUp := True;
  Value.Font.Color := clWhite;
  Value.Caption := '';
  Value.Height := 33;
  Value.StyleElements := [seClient,seBorder];
  Value.Width := 33;

  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyReasoningButtonStyle(Value: TSpeedButton; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.AllowAllUp := True;
  Value.Caption := '';
  Value.GroupIndex := 3;
  Value.Hint := 'Enable Reasoning'#10'File_search disable';
  Value.ShowHint := True;
  Value.Height := 33;
  Value.StyleElements := [seClient,seBorder];
  Value.Width := 33;

  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyUserSettingsComboBoxStyle(Value: TComboBox; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.Style := csOwnerDrawFixed;
  Value.ItemHeight := 22;
  Value.Font.Name := 'Segoe UI';
  Value.Font.Size := 11;
  Value.StyleElements := [seFont, seClient, seBorder];
  Value.TabStop := False;

  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyUserSettingsMaskEditStyle(Value: TMaskEdit; Proc: TProc; Password: Boolean);
begin
  if not Assigned(Value) then
    Exit;

  Value.Font.Size := 11;
  Value.Font.Name := 'Segoe UI';
  if Password then
    Value.PasswordChar := '*';

  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyVectorResourceEditorConfirmationButtonStyle(
  Value: TSpeedButton; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.Height := 22;
  Value.StyleElements := [seFont,seBorder];
  Value.Transparent := True;
  Value.Width := 97;

  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyVectorResourceEditorConfirmationPanelStyle(
  Value: TPanel; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.BevelOuter := bvNone;
  Value.BorderStyle := bsNone;
  Value.Color := $001F1F1F;
  Value.StyleElements := [seFont,seBorder];
  Value.ParentBackground := False;
  Value.ParentColor := False;

  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyVectorResourceEditorImageStyle(Value: TImage;
  Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.Width := 75;
  Value.Height := 75;
  Value.Center := True;
  Value.Proportional := True;

  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyVectorResourceEditorLabelStyle(Value: TLabel;
  Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.Cursor := crHandPoint;

  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyVectorResourceEditorListviewStyle(
  Value: TListView; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.ViewStyle := vsReport;

  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyVectorResourceEditorMaskEditDarkStyle(
  Value: TMaskEdit; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.BorderStyle := bsNone;
  Value.StyleElements := [seClient,seBorder];
  Value.Font.Color := clGray;

  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyVectorResourceEditorMaskEditTitleStyle(
  Value: TMaskEdit; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.BorderStyle := bsNone;
  Value.StyleElements := [seClient,seBorder];
  Value.Font.Color := clWhite;
  Value.Font.Size := 14;
  Value.Font.Style := [fsBold];

  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyVectorResourceEditorScrollBoxStyle(
  Value: TScrollBox; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.BevelInner := bvNone;
  Value.BevelOuter := bvNone;
  Value.BorderStyle := bsNone;
  Value.Color := $001F1F1F;
  Value.ParentBackground := False;
  Value.ParentColor := False;
  Value.StyleElements := [seFont,seBorder];
  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyVectorResourceEditorThumbtackButtonStyle(
  Value: TSpeedButton; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.Caption := '';
  Value.Font.Name := 'Segoe MDL2 Assets';
  Value.Font.Size := 14;
  Value.Font.Color := clWhite;
  Value.StyleElements := [seFont,seBorder];
  Value.Height := 26;
  Value.Width := 31;
  Value.Hint := 'Remove the links to the files.';
  Value.ShowHint := True;

  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyVectorResourceEditorTrashButtonStyle(
  Value: TSpeedButton; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.Caption := '';
  Value.Font.Name := 'Segoe MDL2 Assets';
  Value.Font.Size := 14;
  Value.Font.Color := clWhite;
  Value.StyleElements := [seFont,seBorder];
  Value.Height := 26;
  Value.Width := 31;
  Value.Hint := 'Remove the links to the files and delete the vector store.';
  Value.ShowHint := True;

  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyVectorResourceEditorWarningPanelStyle(
  Value: TPanel; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.BevelOuter := bvNone;
  Value.BorderStyle := bsNone;
  Value.Color := $00263EE1;
  Value.Font.Size := 12;
  Value.Font.Style := [fsBold];
  Value.ParentBackground := False;
  Value.ParentColor := False;
  Value.StyleElements := [seFont,seBorder];
  Value.Visible := False;

  if Assigned(Proc) then
    Proc();
end;

class procedure TAppStyle.ApplyWebSearchButtonStyle(Value: TSpeedButton; Proc: TProc);
begin
  if not Assigned(Value) then
    Exit;

  Value.AllowAllUp := True;
  Value.Caption := '';
  Value.GroupIndex := 2;
  Value.Hint := 'Enable Web Search';
  Value.ShowHint := True;
  Value.Height := 33;
  Value.StyleElements := [seClient,seBorder];
  Value.Width := 33;

  if Assigned(Proc) then
    Proc();
end;

end.

unit UI.UserSettings.VCL;

(*
  Unit: UI.UserSettings.VCL

  Purpose:
    Provides advanced user settings interface logic for Delphi VCL applications.
    This unit dynamically binds visual controls (ComboBox, MaskEdit, Label, etc.)
    to configuration data structures and persistence, relying on dedicated helpers and extenders
    for flexible and robust preference management.

  NOTE ON ARCHITECTURE AND DESIGN CHOICES:
    In line with the project’s pragmatic and demonstrative focus, this unit does NOT adhere to a strict MVC, MVP,
    or MVVM separation. The business logic and UI events are kept close together for clarity, rapid prototyping,
    and ease of onboarding for developers of all backgrounds.

  Technical details:
    - Utilizes a settings introducer record (TSettingsIntroducer, see Introducer.UserSettings.VCL) that centralizes references
      to UI components, promoting structured injection, clarity, and testability.
    - Delegates metadata management (names, defaults, conversions, sets) to centralized record helpers (see Helper.UserSettings).
    - Synchronizes state between the view (Delphi controls) and persistent model via binding logic,
      automatically applying control styles and adapters according to project UI standards.
    - Handles user interaction (value changes, validation, focus, etc.) through isolated, consistent event handlers.
    - Supports live updates of model costs, advanced selections, and structured user changes,
      leveraging an architecture focused on extensibility.
    - Facilitates parameter extension (AI models, proficiency levels, intensity, etc.) by simple edits
      to helpers/enums—no major UI code changes required.

  Dependencies:
    - Requires metadata helpers (Helper.UserSettings) and the UI introducer (Introducer.UserSettings.VCL).
    - Uses the persistence layer (UserSettings.Persistence) for centralized save/restore of settings.
    - Applies UI styles via UI.Styles.VCL and standard VCL units for visual binding.
    - Employs interface resolution and event injection (IoC) as needed.

  Quick start for developers:
    - Prepare a `TSettingsIntroducer` record populated with your form’s controls.
    - Instantiate `TSettingsVCL` with this introducer; all synchronization and settings logic are then handled automatically.
    - Customize or extend settings by simply updating the dedicated helpers/enums—no UI glue code required.
    - Persistence, events, and rendering are fully integrated; focus on your business logic, not on tedious UI/data wiring.

  This unit is designed for maximum scalability—cleanly separating UI injection, business logic,
  persistence, and rendering responsibilities, following the latest Delphi VCL best practices.
*)

interface

uses
  Winapi.Windows, Winapi.Messages, Winapi.CommCtrl,
  System.SysUtils, System.Classes, System.Generics.Collections,
  Vcl.Graphics, Vcl.Controls, Vcl.StdCtrls, Vcl.ExtCtrls, Vcl.ComCtrls, Vcl.Mask,
  Vcl.Forms, Vcl.Dialogs,
  Manager.Intf, Manager.IoC, JSON.Resource, UserSettings.Persistence, UI.Styles.VCL,
  Helper.ScrollBoxMouseWheel.VCL, Helper.UserSettings, Introducer.UserSettings.VCL;

type
  /// <summary>
  /// Main controller for binding user setting UI controls to persistent user settings in a Delphi VCL application.
  /// </summary>
  /// <para>
  /// TSettingsVCL is responsible for synchronizing UI components—such as ComboBoxes, MaskEdits, and Labels—with the underlying settings model.
  /// It handles loading and saving of persistent settings, applies UI styles, and manages user interactions and validation for all user setting controls.
  /// </para>
  /// <para>
  /// The class delegates metadata lookups and option management to dedicated helpers and uses a structured introducer record to cleanly inject UI controls.
  /// It also manages dynamic updates of dependent UI elements, such as model cost displays, as users modify their preferences.
  /// </para>
  /// <para>
  /// All user settings page logic is centralized in this class to maximize maintainability, robustness, and extensibility.
  /// </para>
  TSettingsVCL = class(TInterfacedObject, ISettings)
  private
    FLock: Boolean;
    FSettings: TSettings;
    FScrollBox: TScrollBox;
    FProficiency: TComboBox;
    FPreferenceName: TMaskEdit;
    FProficiencyLabel: TLabel;
    FAPIKey: TMaskEdit;
    FSearchModel: TComboBox;
    FSearchModelCost: TLabel;
    FReasoningModel: TComboBox;
    FReasoningModelCost: TLabel;
    FModelCosts: TModelCosts;
    FReasoningEffort: TComboBox;
    FReasoningSummary: TComboBox;
    FWebContextSize: TComboBox;
    FTimeOut: TComboBox;
    FCountry: TMaskEdit;
    FCity: TMaskEdit;
    procedure ReloadFromJSONFile;
    procedure SearchModelCostUpdate;
    procedure ReasoningModelCostUpdate;
    procedure SetScrollBox(const Value: TScrollBox);
    procedure SetProficiency(const Value: TComboBox);
    procedure SetPreferenceName(const Value: TMaskEdit);
    procedure SetProficiencyLabel(const Value: TLabel);
    procedure SetAPIKey(const Value: TMaskEdit);
    procedure SetSearchModel(const Value: TComboBox);
    procedure SetSearchModelCost(const Value: TLabel);
    procedure SetReasoningModel(const Value: TComboBox);
    procedure SetReasoningModelCost(const Value: TLabel);
    procedure SetReasoningEffort(const Value: TComboBox);
    procedure SetReasoningSummary(const Value: TComboBox);
    procedure SetWebContextSize(const Value: TComboBox);
    procedure SetTimeOut(const Value: TComboBox);
    procedure SetCountry(const Value: TMaskEdit);
    procedure SetCity(const Value: TMaskEdit);

    procedure InitializeComponent(Component: TControl; ChangeHandler: TNotifyEvent = nil);
  protected
    procedure HandleLeaveForLabels;
    procedure HandleLeave(Sender: TObject);
    procedure HandleMaskEditKeyPress(Sender: TObject; var Key: Char);
    procedure HandleProficiencyChange(Sender: TObject);
    procedure HandlePreferenceNameChange(Sender: TObject);
    procedure HandleAPIKeyChange(Sender: TObject);
    procedure HandleSearchModelChange(Sender: TObject);
    procedure HandleReasoningModelChange(Sender: TObject);
    procedure HandleReasoningEffortChange(Sender: TObject);
    procedure HandleReasoningSummaryChange(Sender: TObject);
    procedure HandleWebContextSizeChange(Sender: TObject);
    procedure HandleTimeOutChange(Sender: TObject);
    procedure HandleCountryChange(Sender: TObject);
    procedure HandleCityChange(Sender: TObject);
    procedure HandleMaskEditKeyPressed(Sender: TObject; var Key: Char);
    procedure HandleMaskEditExit(Sender: TObject);
  public
    /// <summary>
    /// Prompts the user to enter their OpenAI API key if it is not already set.
    /// <para>
    /// If no API key is present, displays a dialog for user input,
    /// saves the entered key to persistent settings, and updates the application state accordingly.
    /// </para>
    /// </summary>
    procedure InputAPIKey;

    /// <summary>
    /// Synchronizes the UI controls with the current persistent user settings.
    /// <para>
    /// Updates all UI elements to reflect values from the persistent settings model,
    /// applies display updates (such as model costs), and ensures all modifications are saved.
    /// </para>
    /// </summary>
    procedure Update;

    /// <summary>
    /// Returns the textual representation of the currently selected user proficiency level.
    /// <para>
    /// Retrieves the current selection from the proficiency ComboBox and
    /// converts it to its display string using the helper for proficiency levels.
    /// </para>
    /// </summary>
    function ProficiencyToString: string;

    /// <summary>
    /// Gets the user's screen name as displayed in the application's UI.
    /// <para>
    /// Returns the value of the preference name loaded from the settings model.
    /// </para>
    /// </summary>
    function UserScreenName: string;

    /// <summary>
    /// Returns the identifier of the currently selected search model.
    /// <para>
    /// Gets the search model chosen in the UI or persisted in the user settings.
    /// </para>
    /// </summary>
    function SearchModel: string;

    /// <summary>
    /// Returns the identifier of the currently selected reasoning model.
    /// <para>
    /// Gets the reasoning model chosen in the UI or persisted in the user settings.
    /// </para>
    /// </summary>
    function ReasoningModel: string;

    /// <summary>
    /// Returns the currently stored OpenAI API key.
    /// <para>
    /// Provides access to the API key stored in the settings, without prompting the user.
    /// </para>
    /// </summary>
    function APIKey: string;

    /// <summary>
    /// Gets the selected value for reasoning effort.
    /// </summary>
    /// <returns>
    /// The current reasoning effort value from settings.
    /// </returns>
    function ReasoningEffort: string;

    /// <summary>
    /// Gets the selected value for reasoning summary.
    /// </summary>
    /// <returns>
    /// The current reasoning summary value from settings.
    /// </returns>
    function ReasoningSummary: string;

    /// <summary>
    /// Gets the configured web search context size.
    /// </summary>
    /// <returns>
    /// The current web context size from settings.
    /// </returns>
    function WebContextSize: string;

    /// <summary>
    /// Gets the timeout configuration for user operations.
    /// </summary>
    /// <returns>
    /// The current timeout value from settings.
    /// </returns>
    function TimeOut: string;

    /// <summary>
    /// Gets the configured country string.
    /// </summary>
    /// <returns>
    /// The country value from user settings.
    /// </returns>
    function Country: string;

    /// <summary>
    /// Gets the configured city string.
    /// </summary>
    /// <returns>
    /// The city value from user settings.
    /// </returns>
    function City: string;

    /// <summary>
    /// Indicates if a summary is to be used for the current user configuration.
    /// </summary>
    /// <returns>
    /// True if the summary is enabled; otherwise, False.
    /// </returns>
    function UseSummary: Boolean;

    constructor Create(const Introducer: TSettingsIntroducer);
    destructor Destroy; override;
  end;

implementation

{ TSettingsVCL }

function TSettingsVCL.APIKey: string;
begin
  Result := FSettings.APIKey;
end;

function TSettingsVCL.City: string;
begin
  Result := FSettings.City;
end;

function TSettingsVCL.Country: string;
begin
  Result := FSettings.Country;
end;

constructor TSettingsVCL.Create(const Introducer: TSettingsIntroducer);
begin
  inherited Create;
  FModelCosts := TModelCosts.Create;
  FLock := True;
  try
    SetScrollBox(Introducer.ScrollBox);
    SetProficiency(Introducer.Proficiency);
    SetProficiencyLabel(Introducer.ProficiencyLabel);
    SetPreferenceName(Introducer.PreferenceName);
    SetAPIKey(Introducer.APIKey);
    SetSearchModel(Introducer.SearchModel);
    SetSearchModelCost(Introducer.SearchModelCost);
    SetReasoningModel(Introducer.ReasoningModel);
    SetReasoningModelCost(Introducer.ReasoningModelCost);
    SetReasoningEffort(Introducer.ReasoningEffort);
    SetReasoningSummary(Introducer.ReasoningSummary);
    SetWebContextSize(Introducer.WebContextSize);
    SetTimeOut(Introducer.TimeOut);
    SetCountry(Introducer.Country);
    SetCity(Introducer.City);
  finally
    FLock := False;
  end;
  Update;
end;

destructor TSettingsVCL.Destroy;
begin
  FModelCosts.Free;
  inherited;
end;

function TSettingsVCL.ReasoningSummary: string;
begin
  Result := FSettings.ReasoningSummary;
end;

procedure TSettingsVCL.HandleAPIKeyChange(Sender: TObject);
begin
  if not FLock then
    begin
      FSettings.Chain.Apply(TSettingsProp.APIKey, FAPIKey.Text).Save;
      OpenAI := IoC.Resolve<IAIInteractionManager>('openAI');
      LeftPanelControl.Refresh;
    end;
end;

procedure TSettingsVCL.HandleCityChange(Sender: TObject);
begin
  if not FLock then
    FSettings.Chain
      .Apply(TSettingsProp.City, FCity.Text).Save;
end;

procedure TSettingsVCL.HandleCountryChange(Sender: TObject);
begin
  if not FLock then
    FSettings.Chain
      .Apply(TSettingsProp.Country, FCountry.Text).Save;
end;

procedure TSettingsVCL.HandleLeave(Sender: TObject);
begin
  ServicePrompt.SetFocus;
end;

procedure TSettingsVCL.HandleLeaveForLabels;
begin
  for var i := 0 to FScrollBox.ControlCount - 1 do
    if FScrollBox.Controls[i] is TLabel then
      (FScrollBox.Controls[i] as TLabel).OnClick := HandleLeave;
end;

procedure TSettingsVCL.HandleMaskEditExit(Sender: TObject);
begin
  ServicePrompt.SetFocus;
end;

procedure TSettingsVCL.HandleMaskEditKeyPress(Sender: TObject; var Key: Char);
begin
  case Ord(Key) of
    VK_RETURN:
      begin
        ServicePrompt.SetFocus;
        Key := #0;
      end;
  end;
end;

procedure TSettingsVCL.HandleMaskEditKeyPressed(Sender: TObject; var Key: Char);
begin
  if Ord(Key) = VK_RETURN then
    begin
      ServicePrompt.SetFocus;
      Key := #0;
    end;
end;

procedure TSettingsVCL.HandlePreferenceNameChange(Sender: TObject);
begin
  if not FLock then
    FSettings.Chain
      .Apply(TSettingsProp.PreferenceName, FPreferenceName.Text).Save;
end;

procedure TSettingsVCL.HandleProficiencyChange(Sender: TObject);
begin
  if not FLock then
    begin
      FSettings.Chain
        .Apply(TSettingsProp.Proficiency, FProficiency.Text)
        .Save;
      FProficiencyLabel.Caption := ProficiencyToString;
    end;
end;

procedure TSettingsVCL.HandleReasoningEffortChange(Sender: TObject);
begin
  if not FLock then
    begin
      FSettings.Chain
        .Apply(TSettingsProp.ReasoningEffort, FReasoningEffort.Text)
        .Save;
    end;
end;

procedure TSettingsVCL.HandleReasoningModelChange(Sender: TObject);
begin
  if not FLock then
    begin
      FSettings.Chain
        .Apply(TSettingsProp.ReasoningModel, FReasoningModel.Text)
        .Save;
      ReasoningModelCostUpdate;
    end;
end;

procedure TSettingsVCL.HandleReasoningSummaryChange(Sender: TObject);
begin
  if not FLock then
    begin
      FSettings.Chain
        .Apply(TSettingsProp.ReasoningSummary, FReasoningSummary.Text)
        .Save;
    end;
end;

procedure TSettingsVCL.HandleSearchModelChange(Sender: TObject);
begin
  if not FLock then
    begin
      FSettings.Chain
        .Apply(TSettingsProp.SearchModel, FSearchModel.Text)
        .Save;
      SearchModelCostUpdate;
    end;
end;

procedure TSettingsVCL.HandleTimeOutChange(Sender: TObject);
begin
  if not FLock then
    begin
      FSettings.Chain
        .Apply(TSettingsProp.TimeOut, FTimeOut.Text)
        .Save;
    end;
end;

procedure TSettingsVCL.HandleWebContextSizeChange(Sender: TObject);
begin
  if not FLock then
    begin
      FSettings.Chain
        .Apply(TSettingsProp.WebContextSize, FWebContextSize.Text)
        .Save;
    end;
end;

procedure TSettingsVCL.InitializeComponent(Component: TControl;
  ChangeHandler: TNotifyEvent);
begin
  if Component is TComboBox then
  begin
    TComboBox(Component).OnChange := ChangeHandler;
    TComboBox(Component).OnCloseUp := HandleLeave;
    TComboBox(Component).OnExit := HandleMaskEditExit;
  end
  else if Component is TMaskEdit then
  begin
    TMaskEdit(Component).OnKeyPress := HandleMaskEditKeyPress;
    TMaskEdit(Component).OnChange := ChangeHandler;
    TMaskEdit(Component).OnKeyPress := HandleMaskEditKeyPressed;
    TMaskEdit(Component).OnExit := HandleMaskEditExit;
  end
  else if Component is TLabel then
  begin
    TAppStyle.ApplyUserSettingsLabelStyle(FProficiencyLabel);
  end;
end;

procedure TSettingsVCL.InputAPIKey;
var
  APIKey: string;
begin
  if FSettings.APIKey.Trim.IsEmpty then
    begin
      if InputQuery('OpenAI bearer', 'Please enter your API key', APIKey) then
        begin
          FSettings.Chain.Apply(TSettingsProp.APIKey, APIKey).Save;
          Settings.Update;
        end;
    end;
end;

function TSettingsVCL.ProficiencyToString: string;
begin
  Result := TProficiencyLevel.FromIndex(FProficiency.ItemIndex).ToString;
end;

function TSettingsVCL.ReasoningEffort: string;
begin
  Result := FSettings.ReasoningEffort;
end;

function TSettingsVCL.ReasoningModel: string;
begin
  Result := FSettings.ReasoningModel;
end;

procedure TSettingsVCL.ReasoningModelCostUpdate;
begin
  FReasoningModelCost.Caption := FModelCosts.GetCost(mtReasoning, FReasoningModel.ItemIndex);
end;

procedure TSettingsVCL.ReloadFromJSONFile;
begin
  IniSettings.LoadFromFile;
  FSettings := TSettings(IniSettings.Settings);
  if FSettings.Proficiency.IsEmpty then
    FSettings.Chain.Apply(TSettingsProp.Proficiency, TProficiencyLevel.Default.ToIcon);
  if FSettings.SearchModel.IsEmpty then
    FSettings.Chain.Apply(TSettingsProp.SearchModel, mtSearch.GetDefaultModel);
  if FSettings.ReasoningModel.IsEmpty then
    FSettings.Chain.Apply(TSettingsProp.ReasoningModel, mtReasoning.GetDefaultModel);
end;

function TSettingsVCL.SearchModel: string;
begin
  Result := FSettings.SearchModel;
end;

procedure TSettingsVCL.SearchModelCostUpdate;
begin
  FSearchModelCost.Caption := FModelCosts.GetCost(mtSearch, FSearchModel.ItemIndex);
end;

procedure TSettingsVCL.SetAPIKey(const Value: TMaskEdit);
begin
  FAPIKey := Value;
  TAppStyle.ApplyUserSettingsMaskEditStyle(Value,
    procedure
    begin
      InitializeComponent(Value, HandleAPIKeyChange);
    end,
    True);
end;

procedure TSettingsVCL.SetCity(const Value: TMaskEdit);
begin
  FCity := Value;
  TAppStyle.ApplyUserSettingsMaskEditStyle(Value,
    procedure
    begin
      InitializeComponent(Value, HandleCityChange);
    end);
end;

procedure TSettingsVCL.SetCountry(const Value: TMaskEdit);
begin
  FCountry := Value;
  TAppStyle.ApplyUserSettingsMaskEditStyle(Value,
    procedure
    begin
      InitializeComponent(Value, HandleCountryChange);
    end);
end;

procedure TSettingsVCL.SetPreferenceName(const Value: TMaskEdit);
begin
  FPreferenceName := Value;
  TAppStyle.ApplyUserSettingsMaskEditStyle(Value,
    procedure
    begin
      InitializeComponent(Value, HandlePreferenceNameChange);
    end);
end;

procedure TSettingsVCL.SetProficiency(const Value: TComboBox);
begin
  FProficiency := Value;
  TAppStyle.ApplyUserSettingsComboBoxStyleStar(Value,
    procedure
    begin
      InitializeComponent(Value, HandleProficiencyChange);
      FProficiency.Items.Text := TProficiencyLevel.AllIcons;
      FProficiency.ItemIndex := Ord(TProficiencyLevel.Default);
      FProficiency.DropDownCount := TProficiencyLevel.Count;
    end);
end;

procedure TSettingsVCL.SetProficiencyLabel(const Value: TLabel);
begin
  FProficiencyLabel := Value;
  TAppStyle.ApplyUserSettingsLabelStyle(Value,
    procedure
    begin
      FProficiencyLabel.Alignment := taRightJustify;

      InitializeComponent(Value, nil);
    end);
end;

procedure TSettingsVCL.SetReasoningEffort(const Value: TComboBox);
begin
  FReasoningEffort := Value;
  TAppStyle.ApplyUserSettingsComboBoxStyle(Value,
    procedure
    begin
      InitializeComponent(Value, HandleReasoningEffortChange);

      FReasoningEffort.Items.Text := TIntensity.AllIntensities;
      FReasoningEffort.ItemIndex := Ord(TIntensity.Default);
      FReasoningEffort.DropDownCount := TIntensity.Count;
    end);
end;

procedure TSettingsVCL.SetReasoningModel(const Value: TComboBox);
begin
  FReasoningModel := Value;
  TAppStyle.ApplyUserSettingsComboBoxStyle(Value,
    procedure
    begin
      InitializeComponent(Value, HandleReasoningModelChange);

      FReasoningModel.Items.AddStrings(mtReasoning.GetModelNames);
      FReasoningModel.ItemIndex := mtReasoning.IndexOfModel(mtReasoning.GetDefaultModel);
      FReasoningModel.DropDownCount := Length(mtReasoning.GetModelNames);
    end);
end;

procedure TSettingsVCL.SetReasoningModelCost(const Value: TLabel);
begin
  FReasoningModelCost := Value;
  TAppStyle.ApplyUserSettingsLabelStyle(Value,
    procedure
    begin
      InitializeComponent(Value, nil);
    end);
end;

procedure TSettingsVCL.SetReasoningSummary(const Value: TComboBox);
begin
  FReasoningSummary := Value;
  TAppStyle.ApplyUserSettingsComboBoxStyle(Value,
    procedure
    begin
      InitializeComponent(Value, HandleReasoningSummaryChange);

      FReasoningSummary.Items.Text := TSummary.AllSummaries;
      FReasoningSummary.ItemIndex := Ord(TSummary.Default);
      FReasoningSummary.DropDownCount := TSummary.Count;
    end);
end;

procedure TSettingsVCL.SetScrollBox(const Value: TScrollBox);
begin
  FScrollBox := Value;
  if not Assigned(Value) then
    Exit;

  FScrollBox.OnClick := HandleLeave;
  FScrollBox.EnableMouseWheelScroll;
  HandleLeaveForLabels;
end;

procedure TSettingsVCL.SetSearchModel(const Value: TComboBox);
begin
  FSearchModel := Value;
  TAppStyle.ApplyUserSettingsComboBoxStyle(Value,
    procedure
    begin
      InitializeComponent(Value, HandleSearchModelChange);
      FSearchModel.Items.AddStrings(mtSearch.GetModelNames);
      FSearchModel.ItemIndex := mtSearch.IndexOfModel(mtSearch.GetDefaultModel);
      FSearchModel.DropDownCount := Length(mtSearch.GetModelNames);
    end);
end;

procedure TSettingsVCL.SetSearchModelCost(const Value: TLabel);
begin
  FSearchModelCost := Value;
  TAppStyle.ApplyUserSettingsLabelStyle(Value,
    procedure
    begin
      InitializeComponent(Value, nil);
    end);
end;

procedure TSettingsVCL.SetTimeOut(const Value: TComboBox);
begin
  FTimeOut := Value;
  TAppStyle.ApplyUserSettingsComboBoxStyle(Value,
    procedure
    begin
      InitializeComponent(Value, HandleTimeOutChange);

      FTimeOut.Items.Text := TTimeOut.AllTimeOuts;
      FTimeOut.ItemIndex := Ord(TTimeOut.Default);
      FTimeOut.DropDownCount := TTimeOut.Count;
    end);
end;

procedure TSettingsVCL.SetWebContextSize(const Value: TComboBox);
begin
  FWebContextSize := Value;
  TAppStyle.ApplyUserSettingsComboBoxStyle(Value,
    procedure
    begin
      InitializeComponent(Value, HandleWebContextSizeChange);

      FWebContextSize.Items.Text := TIntensity.AllIntensities;
      FWebContextSize.ItemIndex := Ord(TIntensity.Default);
      FWebContextSize.DropDownCount := TIntensity.Count;
    end);
end;

function TSettingsVCL.TimeOut: string;
begin
  Result := FSettings.TimeOut;
end;

procedure TSettingsVCL.Update;
begin
  if FLock then Exit;
  
  FLock := True;
  try
    ReloadFromJSONFile;
    FProficiency.ItemIndex := FProficiency.Items.IndexOf(FSettings.Proficiency);
    FPreferenceName.Text := FSettings.PreferenceName;
    FProficiencyLabel.Caption := ProficiencyToString;
    FAPIKey.Text := FSettings.APIKey;
    FSearchModel.ItemIndex := FSearchModel.Items.IndexOf(FSettings.SearchModel);
    SearchModelCostUpdate;
    FReasoningModel.ItemIndex := FReasoningModel.Items.IndexOf(FSettings.ReasoningModel);
    ReasoningModelCostUpdate;
    FReasoningEffort.ItemIndex := FReasoningEffort.Items.IndexOf(FSettings.ReasoningEffort);
    FReasoningSummary.ItemIndex := FReasoningSummary.Items.IndexOf(FSettings.ReasoningSummary);
    FWebContextSize.ItemIndex := FWebContextSize.Items.IndexOf(FSettings.WebContextSize);
    FTimeOut.ItemIndex := FTimeOut.Items.IndexOf(FSettings.TimeOut);
    FCountry.Text := FSettings.Country;
    FCity.Text := FSettings.City;
    FSettings.Save;
  finally
    FLock := False;
  end;
end;

function TSettingsVCL.UserScreenName: string;
begin
  Result := FSettings.PreferenceName;
end;

function TSettingsVCL.UseSummary: Boolean;
begin
  Result := not FSettings.ReasoningSummary.Trim.Contains('none');
end;

function TSettingsVCL.WebContextSize: string;
begin
  Result := FSettings.WebContextSize;
end;

end.


unit UI.VectorResourceEditor.VCL;

(*
  Unit: UI.VectorResourceEditor.VCL

  Purpose:
    This unit implements the editor UI and supporting business logic for managing (adding, updating, and linking)
    vector resources in a Delphi VCL application, specifically as part of the File2knowledgeAI project.
    It wires up VCL visual controls (scroll boxes, mask edits, list views, panels, etc.)
    and coordinates the interaction between user input, persistent resource data, and vector store uploads.
    The editor is designed for seamless creation, modification, and validation of resource entries,
    including image management and file attachments, with full live feedback and error handling.

  Note on Architecture and Design Choices:
    In line with the project’s pragmatic and demonstrative focus, this unit does NOT adhere to a strict MVC, MVP,
    or MVVM separation. The business logic and UI events are kept close together for clarity, rapid prototyping,
    and ease of onboarding for developers of all backgrounds.
    - All core logic for validating inputs, managing state, performing file operations, and updating the UI
      is bundled within this class for maximum directness and maintainability in a workshop or demo setting.
    - This approach allows fast iteration and a lower entry threshold, while maintaining modularity and extensibility
      for later refactoring if enterprise patterns or further abstraction are needed.
    - Key helpers, IoC integrations, and styling applications provide structure and testability without rigid layering.

  Usage:
    Instantiate the editor with a TVectorResourceEditorIntroducer record containing your form’s VCL controls.
    All event wiring, style application, state management, and error dialogs are handled automatically.
    Editing, saving, refreshing, and file management are supported out of the box for efficient resource indexing.

  Dependencies:
    - VCL controls: TScrollBox, TImage, TMaskEdit, TListView, TPanel, TSpeedButton, etc.
    - Project units: Model.VectorResource, Manager.Intf, Manager.IoC, JSON.Resource, Manager.WebServices, UI.Styles.VCL,
      and several helper units for dialogs, popups, rounded panels, uploads, etc.
*)

interface

uses
  Winapi.Windows,
  System.SysUtils, System.Classes, System.JSON, System.IOUtils, System.Generics.Collections,
  System.UITypes, System.Threading,
  Vcl.Graphics, Vcl.Controls, Vcl.StdCtrls, Vcl.ExtCtrls, Vcl.ComCtrls, Vcl.Mask, Vcl.Buttons,
  Vcl.Forms, Vcl.Themes,  Vcl.Dialogs,
  Model.VectorResource, Manager.Intf, Manager.IoC, JSON.Resource, Manager.WebServices,
  UI.Styles.VCL, Vcl.Menus, Helper.ScrollBoxMouseWheel.VCL, Helper.OpenDialog.VCL,
  Helper.FileUploadID.Dictionary, Helper.PanelRoundedCorners.VCL, Helper.PopupMenu.VCL,
  Helper.ListView.VCL, Manager.FileUploadID.Controler;

const
  TIMEOUTPERFILE = 3000;

type
  TVectorResourceEditorIntroducer = record
    ScrollBox: TScrollBox;
    Image: TImage;
    Name: TMaskEdit;
    Description: TMaskEdit;
    GithubUrl: TMaskEdit;
    GetitUrl: TMaskEdit;
    Files: TListView;
    VectorStoredId: TMaskEdit;
    TrashButton: TSpeedButton;
    ThumbtackButton: TSpeedButton;
    ConfirmationPanel: TPanel;
    ApplyButton: TSpeedButton;
    CancelButton: TSpeedButton;
    GitHubLabel: TLabel;
    GetitLabel: TLabel;
    WarningPanel: TPanel;
    class function Empty: TVectorResourceEditorIntroducer; static;
  end;

  TVectorResourceEditorIntroducerHelper = record Helper for TVectorResourceEditorIntroducer
    function SetScrollBox(Value: TScrollBox): TVectorResourceEditorIntroducer; inline;
    function SetImage(Value: TImage): TVectorResourceEditorIntroducer; inline;
    function SetName(Value: TMaskEdit): TVectorResourceEditorIntroducer; inline;
    function SetDescription(Value: TMaskEdit): TVectorResourceEditorIntroducer; inline;
    function SetGithub(Value: TMaskEdit): TVectorResourceEditorIntroducer; inline;
    function SetGetit(Value: TMaskEdit): TVectorResourceEditorIntroducer; inline;
    function SetFiles(Value: TListView): TVectorResourceEditorIntroducer; inline;
    function SetVectorStored(Value: TMaskEdit): TVectorResourceEditorIntroducer; inline;
    function SetTrashButton(Value: TSpeedButton): TVectorResourceEditorIntroducer; inline;
    function SetThumbtackButton(Value: TSpeedButton): TVectorResourceEditorIntroducer; inline;
    function SetConfirmationPanel(Value: TPanel): TVectorResourceEditorIntroducer; inline;
    function SetApplyButton(Value: TSpeedButton): TVectorResourceEditorIntroducer; inline;
    function SetCancelButton(Value: TSpeedButton): TVectorResourceEditorIntroducer; inline;
    function SetGitHubLabel(Value: TLabel): TVectorResourceEditorIntroducer; inline;
    function SetGetitLabel(Value: TLabel): TVectorResourceEditorIntroducer; inline;
    function SetWarningPanel(Value: TPanel): TVectorResourceEditorIntroducer; inline;
  end;

  /// <summary>
  /// UI and business logic editor for vector resources in the File2knowledgeAI VCL application.
  /// </summary>
  /// <remarks>
  /// Links, manages, and validates a suite of visual controls for editing and organizing vector-based resources,
  /// including support for file uploads, metadata management, live feedback, error handling, and integration
  /// with the vector store. All resource state mutation and persistence are handled here.
  /// This class does <b>not</b> follow strict MVC/MVP/MVVM separation.
  /// Instead, it intentionally combines UI interaction, validation, and business logic to optimize clarity,
  /// prototyping speed, and onboarding. The internal design remains modular and supports future refactoring/extension
  /// as needed.
  /// <param name="Introducer">Structure containing all required controls for editor operations.</param>
  /// "TVectorResourceEditorIntroducer" and "IVectorResourceEditor"
  /// </remarks>
  TVectorResourceEditorVCL = class(TInterfacedObject, IVectorResourceEditor)
  private
    FImagePath: string;
    FOldImagePath: string;
    FModified: Boolean;
    FImageHasChanged: Boolean;
    FListViewHasChanged: Boolean;
    FListViewPopupMenu: TPopupMenu;
    FScrollBox: TScrollBox;
    FImage: TImage;
    FName: TMaskEdit;
    FDescription: TMaskEdit;
    FGithubUrl: TMaskEdit;
    FGetitUrl: TMaskEdit;
    FFiles: TListView;
    FVectorStoredId: TMaskEdit;
    FTrashButton: TSpeedButton;
    FThumbtackButton: TSpeedButton;
    FConfirmationPanel: TPanel;
    FApplyButton: TSpeedButton;
    FCancelButton: TSpeedButton;
    FGitHubLabel: TLabel;
    FGetitLabel: TLabel;
    FWarningPanel: TPanel;

    function GetWaitDelay: Cardinal;
    procedure SetScrollBox(const Value: TScrollBox);
    procedure SetImage(const Value: TImage);
    procedure SetName(const Value: TMaskEdit);
    procedure SetDescription(const Value: TMaskEdit);
    procedure SetGithubUrl(const Value: TMaskEdit);
    procedure SetGetitUrl(const Value: TMaskEdit);
    procedure SetFiles(const Value: TListView);
    procedure SetVectorStored(const Value: TMaskEdit);
    procedure SetTrashButton(const Value: TSpeedButton);
    procedure SetThumbtackButton(const Value: TSpeedButton);
    procedure SetConfirmationPanel(const Value: TPanel);
    procedure SetApplyButton(const Value: TSpeedButton);
    procedure SetCancelButton(const Value: TSpeedButton);
    procedure SetGitHubLabel(const Value: TLabel);
    procedure SetGetitLabel(const Value: TLabel);
    procedure SetWarningPanel(const Value: TPanel);

    function GetModified: Boolean;
    procedure SetModified(const Value: Boolean);
    function GetConfirmationVisible: Boolean;
    procedure SetConfirmationVisible(const Value: Boolean);
    function GetItemIndex: Integer;
  protected
    procedure LoadDataIntoComponents;
    procedure LeftPanelContentRefresh;
    procedure HandleControlExitAndRefocusPrompt(Sender: TObject);
    procedure HandleLeaveForLabels;
    procedure HandleListViewEditing(Sender: TObject; Item: TListItem; var AllowEdit: Boolean);
    procedure HandleListViewAddFilename(Sender: TObject);
    procedure HandleListViewDelete(Sender: TObject);
    procedure HandleImageLoadFromFile(Sender: TObject);
    procedure HandleImageClick(Sender: TObject);
    procedure HandleConfirmationApply(Sender: TObject);
    procedure HandleConfirmationCancel(Sender: TObject);
    procedure HandleChange(Sender: TObject);
    procedure HandleLabelClick(Sender: TObject);
    procedure HandleMaskEditKeyPressed(Sender: TObject; var Key: Char);
    procedure HandleMaskEditExit(Sender: TObject);
    procedure HandleTrashButtonClick(Sender: TObject);
    procedure HandleThumbtackClick(Sender: TObject);
    procedure HandleOnPopup(Sender: TObject);
    procedure HandleRefresh(Sender: TObject);
    procedure HandleWaitForMessage(Sender: TObject);
  public
    constructor Create(const Introducer: TVectorResourceEditorIntroducer);

    /// <summary>
    /// Updates the modified state of the editor based on user interactions and content changes.
    /// </summary>
    /// <returns>True if the editor is now in a modified state; otherwise, False.</returns>
    function UpdateModified: Boolean;

    /// <summary>
    /// Reloads vector resource data into the UI controls and re-initializes the file management context.
    /// </summary>
    procedure Refresh;

    /// <summary>
    /// Saves any changes made in the editor to the persistent resource data and handles file attachment updates.
    /// </summary>
    procedure SaveChanges;

    /// <summary>
    /// Gets or sets the visibility of the confirmation panel in the UI.
    /// </summary>
    property ConfirmationPanelVisible: Boolean Read GetConfirmationVisible write SetConfirmationVisible;

    /// <summary>
    /// Gets the index of the currently selected vector resource item.
    /// </summary>
    property ItemIndex: Integer read GetItemIndex;

    /// <summary>
    /// Gets or sets whether the editor contains unsaved modifications.
    /// </summary>
    property Modified: Boolean read GetModified write SetModified;
  end;

implementation

{ TVectorResourceEditorIntroducer }

class function TVectorResourceEditorIntroducer.Empty: TVectorResourceEditorIntroducer;
begin
  FillChar(Result, SizeOf(Result), 0);
end;

{ TVectorResourceEditorIntroducerHelper }

function TVectorResourceEditorIntroducerHelper.SetApplyButton(
  Value: TSpeedButton): TVectorResourceEditorIntroducer;
begin
  Self.ApplyButton := Value;
  Result := Self;
end;

function TVectorResourceEditorIntroducerHelper.SetCancelButton(
  Value: TSpeedButton): TVectorResourceEditorIntroducer;
begin
  Self.CancelButton := Value;
  Result := Self;
end;

function TVectorResourceEditorIntroducerHelper.SetConfirmationPanel(
  Value: TPanel): TVectorResourceEditorIntroducer;
begin
  Self.ConfirmationPanel := Value;
  Result := Self;
end;

function TVectorResourceEditorIntroducerHelper.SetDescription(
  Value: TMaskEdit): TVectorResourceEditorIntroducer;
begin
  Self.Description := Value;
  Result := Self;
end;

function TVectorResourceEditorIntroducerHelper.SetFiles(
  Value: TListView): TVectorResourceEditorIntroducer;
begin
  Self.Files := Value;
  Result := Self;
end;

function TVectorResourceEditorIntroducerHelper.SetGetit(
  Value: TMaskEdit): TVectorResourceEditorIntroducer;
begin
  Self.GetitUrl := Value;
  Result := Self;
end;

function TVectorResourceEditorIntroducerHelper.SetGetitLabel(
  Value: TLabel): TVectorResourceEditorIntroducer;
begin
  Self.GetitLabel := Value;
  Result := Self;
end;

function TVectorResourceEditorIntroducerHelper.SetGithub(
  Value: TMaskEdit): TVectorResourceEditorIntroducer;
begin
  Self.GithubUrl := Value;
  Result := Self;
end;

function TVectorResourceEditorIntroducerHelper.SetGitHubLabel(
  Value: TLabel): TVectorResourceEditorIntroducer;
begin
  Self.GitHubLabel := Value;
  Result := Self;
end;

function TVectorResourceEditorIntroducerHelper.SetImage(
  Value: TImage): TVectorResourceEditorIntroducer;
begin
  Self.Image := Value;
  Result := Self;
end;

function TVectorResourceEditorIntroducerHelper.SetName(
  Value: TMaskEdit): TVectorResourceEditorIntroducer;
begin
  Self.Name := Value;
  Result := Self;
end;

function TVectorResourceEditorIntroducerHelper.SetScrollBox(
  Value: TScrollBox): TVectorResourceEditorIntroducer;
begin
  Self.ScrollBox := Value;
  Result := Self;
end;

function TVectorResourceEditorIntroducerHelper.SetThumbtackButton(
  Value: TSpeedButton): TVectorResourceEditorIntroducer;
begin
  Self.ThumbtackButton := Value;
  Result := Self;
end;

function TVectorResourceEditorIntroducerHelper.SetTrashButton(
  Value: TSpeedButton): TVectorResourceEditorIntroducer;
begin
  Self.TrashButton := Value;
  Result := Self;
end;

function TVectorResourceEditorIntroducerHelper.SetVectorStored(
  Value: TMaskEdit): TVectorResourceEditorIntroducer;
begin
  Self.VectorStoredId := Value;
  Result := Self;
end;

function TVectorResourceEditorIntroducerHelper.SetWarningPanel(
  Value: TPanel): TVectorResourceEditorIntroducer;
begin
  Self.WarningPanel := Value;
  Result := Self;
end;

{ TVectorResourceEditorVCL }

constructor TVectorResourceEditorVCL.Create(
  const Introducer: TVectorResourceEditorIntroducer);
begin
  inherited Create;
  FImageHasChanged := False;
  FListViewHasChanged := False;

  SetScrollBox(Introducer.ScrollBox);
  SetImage(Introducer.Image);
  SetName(Introducer.Name);
  SetDescription(Introducer.Description);
  SetGithubUrl(Introducer.GithubUrl);
  SetGetitUrl(Introducer.GetitUrl);
  SetFiles(Introducer.Files);
  SetVectorStored(Introducer.VectorStoredId);
  SetTrashButton(Introducer.TrashButton);
  SetThumbtackButton(Introducer.ThumbtackButton);
  SetConfirmationPanel(Introducer.ConfirmationPanel);
  SetApplyButton(Introducer.ApplyButton);
  SetCancelButton(Introducer.CancelButton);
  SetGitHubLabel(Introducer.GitHubLabel);
  SetGetitLabel(Introducer.GetitLabel);
  SetWarningPanel(Introducer.WarningPanel);
end;

function TVectorResourceEditorVCL.GetConfirmationVisible: Boolean;
begin
  Result := FConfirmationPanel.Visible;
end;

function TVectorResourceEditorVCL.GetItemIndex: Integer;
begin
  Result := FileStoreManager.ItemIndex;
end;

function TVectorResourceEditorVCL.GetModified: Boolean;
begin
  Result := FModified;
end;

procedure TVectorResourceEditorVCL.HandleChange(Sender: TObject);
begin
  UpdateModified;
end;

procedure TVectorResourceEditorVCL.HandleConfirmationApply(Sender: TObject);
begin
  SaveChanges;
  HandleWaitForMessage(Sender);
end;

procedure TVectorResourceEditorVCL.HandleConfirmationCancel(Sender: TObject);
begin
  if FImagePath <> FOldImagePath then
    begin
      if FOldImagePath.IsEmpty then
        FImage.Picture.LoadFromFile('..\..\logos\NoImage.png')
      else
        FImage.Picture.LoadFromFile(FOldImagePath);
    end;
  Refresh;
  ConfirmationPanelVisible := False;
  ServicePrompt.SetFocus;
end;

procedure TVectorResourceEditorVCL.HandleImageClick(Sender: TObject);
begin
  FImage.PopupMenu.Popup(Mouse.CursorPos.X, Mouse.CursorPos.Y);
end;

procedure TVectorResourceEditorVCL.HandleImageLoadFromFile(Sender: TObject);
var
  FileName: string;
begin
  if FileStoreManager.ImagePath.IsEmpty then
    FileName := '..\..\logos'
  else
    FileName := FileStoreManager.ImagePath;

  if TOpenDialogHelper.Create(nil)
       .Filter('Network Graphics (*.png)|*.png')
       .InitialDir(FileName)
       .Execute(FileName)
    then
      begin
        FImagePath := FileName;
        FImage.Picture.LoadFromFile(FImagePath);
        UpdateModified;
      end;
  ServicePrompt.SetFocus;
end;

procedure TVectorResourceEditorVCL.HandleLabelClick(Sender: TObject);
begin
  if Sender is TLabel then
    begin
      case (Sender as TLabel).Tag of
        1 : TWebUrlManager.Open(FGithubUrl.Text);
        2 : TWebUrlManager.Open(FGetitUrl.Text);
      end;
    end;
  ServicePrompt.SetFocus;
end;

procedure TVectorResourceEditorVCL.HandleControlExitAndRefocusPrompt(Sender: TObject);
begin
  ServicePrompt.SetFocus;
end;

procedure TVectorResourceEditorVCL.HandleLeaveForLabels;
begin
  for var i := 0 to FScrollBox.ControlCount - 1 do
    if FScrollBox.Controls[i] is TLabel then
      (FScrollBox.Controls[i] as TLabel).OnClick := HandleControlExitAndRefocusPrompt;
end;

procedure TVectorResourceEditorVCL.HandleListViewAddFilename(Sender: TObject);
var
  FileName: string;
begin

  if Length(FileStoreManager.Files) >= 5 then
    begin
      AlertService.ShowWarning('You have reached the maximum allowed number of five files.');
      Exit;
    end;

  if not Assigned(FFiles.ItemFocused) then
    FileName := '..\..\data'
  else
    FileName := FFiles.ItemFocused.Caption;

  if TOpenDialogHelper.Create(nil)
       .Filter(
         'Text Files (*.txt)|*.txt|' +
         'Markdown Files (*.md)|*.md|' +
         'Text & Markdown (*.txt;*.md)|*.txt;*.md')
       .InitialDir(FileName)
       .FilterIndex(3)
       .Execute(FileName)
    then
      if not TListViewHelper.Create(FFiles).CaptionExists(Filename) then
        begin
          FileUploadIdController.AddFile(FileName,
            procedure
            begin
              TListViewHelper.Create(FFiles).Add(FileName);
              FListViewHasChanged := True;
              UpdateModified;
            end)
        end;
  ServicePrompt.SetFocus;
end;

procedure TVectorResourceEditorVCL.HandleListViewDelete(Sender: TObject);
begin
  if not Assigned(FFiles.ItemFocused) then
    Exit;

  var ValidationMessage :=
    Format('Confirm removal of links to the file :'#10#10'%s',
           [FFiles.ItemFocused.Caption]);

  if AlertService.ShowConfirmation(ValidationMessage) = mrYes then
    begin
      FileUploadIdController.DeleteFile(FFiles.ItemFocused.Caption,
        procedure
        begin
          TListViewHelper.Create(FFiles).DeleteSelected;
          FListViewHasChanged := True;
          UpdateModified;
          ServicePrompt.SetFocus;
        end);
    end;
end;

procedure TVectorResourceEditorVCL.HandleListViewEditing(Sender: TObject;
  Item: TListItem; var AllowEdit: Boolean);
begin
  AllowEdit := False;
end;

procedure TVectorResourceEditorVCL.HandleMaskEditExit(Sender: TObject);
begin
  ServicePrompt.SetFocus;
end;

procedure TVectorResourceEditorVCL.HandleMaskEditKeyPressed(Sender: TObject;
  var Key: Char);
begin
  if Ord(Key) = VK_RETURN then
    begin
      ServicePrompt.SetFocus;
      Key := #0;
    end;
end;

procedure TVectorResourceEditorVCL.HandleOnPopup(Sender: TObject);
begin
  FFiles.PopupMenu.Items[4].Enabled := FileStoreManager.VectorStore.Trim.IsEmpty;
end;

procedure TVectorResourceEditorVCL.HandleRefresh(Sender: TObject);
begin
  HandleWaitForMessage(Sender);
end;

procedure TVectorResourceEditorVCL.HandleThumbtackClick(Sender: TObject);
begin
  if FileStoreManager.VectorStore.Trim.IsEmpty or
     (AlertService.ShowConfirmation('Confirm the removal of all links to the files.') = mrNo) then
    begin
      ServicePrompt.SetFocus;
      Exit;
    end;

  for var Item in FileStoreManager.FileUploadIds do
    OpenAI.DeleteVectorStore(FileStoreManager.VectorStore, Item)
      .&Then<string>(
        function (Value: string): string
        begin
          FileStoreManager.VectorStore := '';
          FileStoreManager.SaveToFile;
          Refresh;
          ServicePrompt.SetFocus;
        end)
      .&Catch(
        procedure(E: Exception)
        begin
          AlertService.ShowWarning('Error : ' + E.Message);
          ServicePrompt.SetFocus;
        end);
end;

procedure TVectorResourceEditorVCL.HandleTrashButtonClick(Sender: TObject);
begin
  if FileStoreManager.VectorStore.Trim.IsEmpty or
     (AlertService.ShowConfirmation('Confirm the complete deletion of the vector.') = mrNo) then
    begin
      ServicePrompt.SetFocus;
      Exit;
    end;

  OpenAI.RemoveVectorStore(FileStoreManager.VectorStore)
    .&Then<string>(
      function (Value: string): string
      begin
        FileStoreManager.VectorStore := '';
        FileStoreManager.SaveToFile;
        Refresh;
        ServicePrompt.SetFocus;
      end)
    .&Catch(
      procedure(E: Exception)
      begin
        AlertService.ShowWarning('Error : ' + E.Message);
        ServicePrompt.SetFocus;
      end);
end;

procedure TVectorResourceEditorVCL.HandleWaitForMessage(Sender: TObject);
begin
  FWarningPanel.Visible := FListViewHasChanged;
  FFiles.PopupMenu := nil;
  TTask.Run(
    procedure()
    begin
      Sleep(GetWaitDelay);
      TThread.Queue(nil,
        procedure
        begin
          Refresh;
          FFiles.PopupMenu := FListViewPopupMenu;
          FWarningPanel.Visible := False;
        end)
    end);
  ConfirmationPanelVisible := False;
end;

function TVectorResourceEditorVCL.UpdateModified: Boolean;
begin
  Modified :=
    (FImagePath <> FileStoreManager.ImagePath) or
    (FName.Text <> FileStoreManager.Name) or
    (FDescription.Text <> FileStoreManager.Description) or
    (FGithubUrl.Text <> FileStoreManager.Github) or
    (FGetitUrl.Text <> FileStoreManager.Getit) or
    FImageHasChanged or
    FListViewHasChanged;
  Result := Modified;
end;

procedure TVectorResourceEditorVCL.LeftPanelContentRefresh;
begin
  TTask.Run(
    procedure()
    begin
      Sleep(50);
      TThread.Queue(nil,
        procedure
        begin
          LeftPanelControl.Refresh;
        end)
    end);
end;

procedure TVectorResourceEditorVCL.LoadDataIntoComponents;
begin
  if not FileStoreManager.JSONExists then
    Exit;

  FileStoreManager.Reload;
  FImageHasChanged := False;
  FListViewHasChanged := False;
  FImagePath := FileStoreManager.ImagePath;
  FOldImagePath := FImagePath;
  if not FImagePath.Trim.IsEmpty and FileExists(FImagePath) then
    FImage.Picture.LoadFromFile(FImagePath);
  FName.Text := FileStoreManager.Name;
  FDescription.Text := FileStoreManager.Description;
  FGithubUrl.Text := FileStoreManager.Github;
  FGetitUrl.Text := FileStoreManager.Getit;
  FVectorStoredId.Text := FileStoreManager.VectorStore;
end;

procedure TVectorResourceEditorVCL.Refresh;
begin
  LoadDataIntoComponents;
  FileUploadIdController.InitDictionaries;
  TListViewHelper.Refresh(FFiles);
  UpdateModified;
end;

procedure TVectorResourceEditorVCL.SaveChanges;
begin
  var Resources := TVectorResourceList(FileStoreManager.Resources);

  {--- Process on main datas }
  Resources.Data[ItemIndex].Image := FImagePath;
  Resources.Data[ItemIndex].Name := FName.Text;
  Resources.Data[ItemIndex].Description := FDescription.Text;
  Resources.Data[ItemIndex].Github := FGithubUrl.Text;
  Resources.Data[ItemIndex].Getit := FGetitUrl.Text;

  {--- Process on Datas from ListView }
  if FListViewHasChanged then
    begin
      FileUploadIdController.SaveChanges;
    end;

  FileStoreManager.SaveToFile;
  LeftPanelContentRefresh;
  ServicePrompt.SetFocus;
end;

procedure TVectorResourceEditorVCL.SetApplyButton(const Value: TSpeedButton);
begin
  FApplyButton := Value;
  TAppStyle.ApplyVectorResourceEditorConfirmationButtonStyle(Value,
    procedure
    begin
      FApplyButton.Caption := '&Apply';
      FApplyButton.OnClick := HandleConfirmationApply;
    end);
end;

procedure TVectorResourceEditorVCL.SetCancelButton(const Value: TSpeedButton);
begin
  FCancelButton := Value;
  TAppStyle.ApplyVectorResourceEditorConfirmationButtonStyle(Value,
    procedure
    begin
      FCancelButton.Caption := '&Cancel';
      FCancelButton.OnClick := HandleConfirmationCancel;
    end);
end;

procedure TVectorResourceEditorVCL.SetConfirmationPanel(const Value: TPanel);
begin
  FConfirmationPanel := Value;
  TAppStyle.ApplyVectorResourceEditorConfirmationPanelStyle(Value,
    procedure
    begin
      FConfirmationPanel.Visible := False;
    end);
end;

procedure TVectorResourceEditorVCL.SetConfirmationVisible(const Value: Boolean);
begin
  FConfirmationPanel.Visible := Value;
end;

procedure TVectorResourceEditorVCL.SetDescription(const Value: TMaskEdit);
begin
  FDescription := Value;
  TAppStyle.ApplyVectorResourceEditorMaskEditDarkStyle(Value,
    procedure
    begin
      FDescription.TextHint := 'set description';
      FDescription.MaxLength := 512;

      FDescription.OnChange := HandleChange;
      FDescription.OnKeyPress := HandleMaskEditKeyPressed;
      FDescription.OnExit := HandleMaskEditExit;
    end);
end;

procedure TVectorResourceEditorVCL.SetFiles(const Value: TListView);
begin
  FFiles := Value;
  TAppStyle.ApplyVectorResourceEditorListviewStyle(Value,
    procedure
    begin
      FListViewPopupMenu := TPopupMenuHelper.Create(nil)
        .AddItem('Add filename', '', HandleListViewAddFilename)
        .AddItem('Delete', '', HandleListViewDelete)
        .AddItem('Refresh', '', HandleRefresh)
        .AddItem('-', '', nil)
        .AddItem('Link all to vector store', '' , HandleConfirmationApply)
        .PopupMenu;

      FFiles.PopupMenu := FListViewPopupMenu;
      FFiles.PopupMenu.OnPopup := HandleOnPopup;

      FFiles.OnEditing := HandleListViewEditing;
      FFiles.OnExit := HandleMaskEditExit;
      FFiles.OnClick := HandleControlExitAndRefocusPrompt;
    end);
end;

procedure TVectorResourceEditorVCL.SetGetitUrl(const Value: TMaskEdit);
begin
  FGetitUrl := Value;
  TAppStyle.ApplyVectorResourceEditorMaskEditDarkStyle(Value,
    procedure
    begin
      FGetitUrl.TextHint := 'set GetitUrl url';
      FGetitUrl.OnChange := HandleChange;

      FGetitUrl.OnKeyPress := HandleMaskEditKeyPressed;
      FGetitUrl.OnExit := HandleMaskEditExit;
    end);
end;

procedure TVectorResourceEditorVCL.SetGetitLabel(const Value: TLabel);
begin
  FGetitLabel := Value;
  TAppStyle.ApplyVectorResourceEditorLabelStyle(Value,
    procedure
    begin
      FGetitLabel.Tag := 2;

      FGetitLabel.OnClick := HandleLabelClick;
    end);
end;

procedure TVectorResourceEditorVCL.SetGithubUrl(const Value: TMaskEdit);
begin
  FGithubUrl := Value;
  TAppStyle.ApplyVectorResourceEditorMaskEditDarkStyle(Value,
    procedure
    begin
      FGithubUrl.TextHint := 'set GithubUrl url';
      FGithubUrl.OnChange := HandleChange;

      FGithubUrl.OnKeyPress := HandleMaskEditKeyPressed;
      FGithubUrl.OnExit := HandleMaskEditExit;
    end);
end;

procedure TVectorResourceEditorVCL.SetGitHubLabel(const Value: TLabel);
begin
  FGitHubLabel := Value;
  TAppStyle.ApplyVectorResourceEditorLabelStyle(Value,
    procedure
    begin
      FGitHubLabel.Tag := 1;

      FGitHubLabel.OnClick := HandleLabelClick;
    end);
end;

procedure TVectorResourceEditorVCL.SetImage(const Value: TImage);
begin
  FImage := Value;
  TAppStyle.ApplyVectorResourceEditorImageStyle(Value,
    procedure
    begin
      FImage.PopupMenu := TPopupMenuHelper.Create(nil)
        .AddItem('Load from file', '', HandleImageLoadFromFile)
        .PopupMenu;

      FImage.OnClick := HandleImageClick;
    end);
end;

procedure TVectorResourceEditorVCL.SetModified(const Value: Boolean);
begin
  FModified := Value;
  ConfirmationPanelVisible := Value;
end;

procedure TVectorResourceEditorVCL.SetName(const Value: TMaskEdit);
begin
  FName := Value;
  TAppStyle.ApplyVectorResourceEditorMaskEditTitleStyle(Value,
    procedure
    begin
      FName.TextHint := 'set link name';
      FName.OnChange := HandleChange;

      FName.OnKeyPress := HandleMaskEditKeyPressed;
      FName.OnExit := HandleMaskEditExit;
    end);
end;

procedure TVectorResourceEditorVCL.SetScrollBox(const Value: TScrollBox);
begin
  FScrollBox := Value;
  TAppStyle.ApplyVectorResourceEditorScrollBoxStyle(Value,
    procedure
    begin
      FScrollBox.EnableMouseWheelScroll;
      FScrollBox.OnClick := HandleControlExitAndRefocusPrompt;
      HandleLeaveForLabels;
    end);
end;

procedure TVectorResourceEditorVCL.SetThumbtackButton(
  const Value: TSpeedButton);
begin
  FThumbtackButton := Value;
  TAppStyle.ApplyVectorResourceEditorThumbtackButtonStyle(Value,
    procedure
    begin
      FThumbtackButton.OnClick := HandleThumbtackClick;
    end);
end;

procedure TVectorResourceEditorVCL.SetTrashButton(const Value: TSpeedButton);
begin
  FTrashButton := Value;
  TAppStyle.ApplyVectorResourceEditorTrashButtonStyle(Value,
    procedure
    begin
      FTrashButton.OnClick := HandleTrashButtonClick;
    end);
end;

procedure TVectorResourceEditorVCL.SetVectorStored(const Value: TMaskEdit);
begin
  FVectorStoredId := Value;
  TAppStyle.ApplyVectorResourceEditorMaskEditDarkStyle(Value,
    procedure
    begin
      FVectorStoredId.TextHint := 'no id defined';
      FVectorStoredId.ReadOnly := True;

      FVectorStoredId.OnExit := HandleMaskEditExit;
    end);
end;

procedure TVectorResourceEditorVCL.SetWarningPanel(const Value: TPanel);
begin
  FWarningPanel := Value;
  TAppStyle.ApplyVectorResourceEditorWarningPanelStyle(Value,
    procedure
    begin
      FWarningPanel.SetRoundedCorners(18, 18);
    end);
end;

function TVectorResourceEditorVCL.GetWaitDelay: Cardinal;
begin
  Result := (TIMEOUTPERFILE * FileUploadIdController.DraftCount) * Integer(FListViewHasChanged) + 500;
end;

end.


unit UI.VectorResourceManager.VCL;

(*
  Unit: UI.VectorResourceManager.VCL

  Purpose:
    This unit provides a VCL-specific vector resource manager for handling lists of AI resource wrappers
    (such as GenAI, MistralAI, Anthropic, Gemini, etc.). It links data management and persistent storage
    with the creation and interaction of corresponding visual container panels in a VCL application.
    The goal is to streamline the management, visualization, and selection of vector resources, especially
    for demoing or integrating various AI wrapper endpoints in a user interface.

  Technical details:
    - Defines TVectorResourceCore for generic resource list management and TVectorResourceVCL for VCL-adapted presentation.
    - Supplies a factory method for populating UI containers (TContainer) with resource data (name, description, image, etc.),
      supporting dynamic integration into scrollable or list-based visual structures.
    - Implements fluent method chaining for container property assignment (name, image, index, selection callback, etc.).
    - Integrates with persistent JSON storage: loads and saves resource information transparently.
    - Includes methods for easily attaching, updating, selecting, and reloading resource panels, and
      for synchronizing UI state with underlying resource data.

  Dependencies:
    - Requires Model.VectorResource for the underlying data model of resources.
    - Uses UI.Container.VCL for the visual container/panel representation in VCL.
    - Depends on REST.Json and System.JSON for JSON serialization/deserialization.
    - Uses System.IOUtils, System.Classes, System.SysUtils for file and utility operations.
    - Integrates with Manager.Intf for interfacing with the app's broader file store management.

  Quick start for developers:
    - Instantiate a TVectorResourceVCL for automatic loading of resource data and convenient VCL-specific methods.
    - Use the AttachTo method to bind the resource items to a VCL control (like a TScrollBox), with optional
      selection callback.
    - Access and manipulate core data and selection via the provided properties and methods;
      persistence is handled internally.
    - Customize the list of resources, images, and descriptions using the Initialize method or via parameterized
      construction, per your extension needs.

  This unit is designed to make AI-related resource integration and visualization straightforward in Delphi
  VCL applications, prioritizing clarity, maintainability, and ease of adding or updating resource wrappers.
*)

interface

uses
  System.SysUtils, System.Classes, System.JSON, REST.Json, System.IOUtils, System.Threading,
  Manager.Intf, Manager.Async.Promise, Model.VectorResource, UI.Container.VCL;

type
  EFileCountNull = class(Exception);

  TVectorResourceCore = class(TInterfacedObject)
  private
    FVectorResourceList: TVectorResourceList;
    function GetData(Index: Integer): TVectorResourceItem;
  protected
    procedure Initialize; virtual; abstract;
  public
    procedure Clear;
    property Data[Index: Integer]: TVectorResourceItem read GetData;
    constructor Create;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Provides a VCL-specific vector resource manager to handle and visualize lists of AI resource wrappers,
  /// including GenAI, MistralAI, Anthropic, Gemini, and others. This class links data management and
  /// persistent storage with the creation and interaction of corresponding visual container panels in a VCL
  /// (Visual Component Library) application. TVectorResourceVCL streamlines management, visualization, and
  /// selection of vector resources, making it ideal for integrating and showcasing diverse AI wrapper
  /// endpoints.
  /// </summary>
  /// <remarks>
  /// <para>
  /// - TVectorResourceVCL inherits from TVectorResourceCore to extend generic resource list features and
  /// implements IAppFileStoreManager for integrated persistent file store handling.
  /// </para>
  /// <para>
  /// - Core features include dynamic population of VCL container controls (such as TContainer) with resource
  /// data and images, support for method chaining on UI assignments, full transparency for JSON-based
  /// persistent storage, and efficient methods to attach, update, select, and reload resource panels while
  /// keeping UI state synchronized.
  /// </para>
  /// <para>
  /// - TVectorResourceVCL depends on Model.VectorResource for data representation, UI.Container.VCL for visual
  /// integration, REST.Json and System.JSON for JSON serialization, System.IOUtils and System.Classes for file
  /// operations, and Manager.Intf for broader file store use.
  /// </para>
  /// <para>
  /// - Typical usage involves instantiating TVectorResourceVCL to automatically load data from storage, binding
  /// visual resource items to a VCL control (such as TScrollBox) with an optional selection callback, and
  /// invoking provided methods to manipulate resource data, visuals, and persistence. Initialization
  /// customizes the resource list, images, and descriptions according to application context.
  /// </para>
  /// </remarks>
  TVectorResourceVCL = class(TVectorResourceCore, IAppFileStoreManager)
  private
    FVectorStore: string;
    TFileUploadIdTemp: TArray<string>;
    function GetItemIndex: Integer;
    procedure SetItemIndex(const Value: Integer);
    function GetName: string;
    procedure SetName(const Value: string);
    function GetVectorStore: string;
    procedure SetVectorStore(const Value: string);
    function GetDescription: string;
    function GetGitHub: string;
    function GetGetit: string;
    function GetFiles: TArray<string>;
    function GetResources: TObject;
    function GetImagePath: string;
    function GetUploadIds: TArray<string>;
  protected
    procedure Initialize; override;
    function LoadFromFile(FileName: string = ''): string;

    function HandleFileStep(const Value: string; Index, Step: Integer): string;
    function GetFileName(const Index, Step: Integer): string;
    function GetFileUploadId(const Index, Step: Integer): string;
    procedure EnsureFilesCountNotNull(const Index: Integer);
    procedure EnsureFilesExists(const Index: Integer); overload;
    procedure EnsureFilesExists(const FileNames: TArray<string>); overload;

  public
    /// <summary>
    /// Sets the selected resource index and updates the corresponding UI container selection.
    /// </summary>
    /// <param name="Value">
    /// The zero-based index of the resource to select.
    /// </param>
    procedure Select(const Value: Integer);

    /// <summary>
    /// Initializes the resource manager with default values and updates the current resource state.
    /// </summary>
    /// <returns>
    /// Returns the current instance to support method chaining.
    /// </returns>
    function DefaultValues: IAppFileStoreManager;

    /// <summary>
    /// Loads resource values from persistent storage and updates the current resource state.
    /// </summary>
    /// <returns>
    /// Returns the current instance to support method chaining.
    /// </returns>
    function LoadValues: IAppFileStoreManager;

    /// <summary>
    /// Attaches resource containers to the specified VCL component, optionally binding a click event handler for resource selection.
    /// </summary>
    /// <param name="Value">
    /// The VCL component (such as a TScrollBox) to which resources will be attached.
    /// </param>
    /// <param name="OnClickProc">
    /// Optional procedure to invoke when a resource container is selected.
    /// </param>
    /// <returns>
    /// Returns the current instance to support method chaining.
    /// </returns>
    function AttachTo(const Value: TComponent; const OnClickProc: TProc<TObject> = nil): IAppFileStoreManager;

    /// <summary>
    /// Determines if the persistent JSON storage file for resources exists on disk.
    /// </summary>
    /// <returns>
    /// True if the JSON file exists; otherwise, False.
    /// </returns>
    function JSONExists: Boolean;

    /// <summary>
    /// Reloads the resource list from persistent storage.
    /// </summary>
    procedure Reload;

    /// <summary>
    /// Saves the current resource list to persistent storage.
    /// </summary>
    /// <param name="FileName">
    /// Optional file name to use for saving. If blank, the default file is used.
    /// </param>
    procedure SaveToFile(FileName: string = '');

    /// <summary>
    /// Adds a file to the currently selected resource's file list.
    /// </summary>
    /// <param name="FileName">
    /// The name or path of the file to add.
    /// </param>
    procedure AddFile(const FileName: string);

    /// <summary>
    /// Deletes the file pair at the specified index from the currently selected resource.
    /// </summary>
    /// <param name="index">
    /// The zero-based index of the file pair to delete.
    /// </param>
    procedure DeleteFile(index: Integer);

    /// <summary>
    /// Updates the state for the currently selected resource by re-linking it with the vector store and persisting changes.
    /// </summary>
    procedure UpdateCurrent;

    /// <summary>
    /// Pings the selected vector store by ensuring that the associated files are linked and valid.
    /// </summary>
    /// <returns>
    /// Returns a promise containing the vector store identifier string.
    /// </returns>
    function PingVectorStore: TPromise<string>;

    /// <summary>
    /// Gets or sets the index of the currently selected resource item.
    /// </summary>
    property ItemIndex: Integer read GetItemIndex write SetItemIndex;

    /// <summary>
    /// Gets the image path associated with the currently selected resource.
    /// </summary>
    property ImagePath: string read GetImagePath;

    /// <summary>
    /// Gets or sets the name of the currently selected resource.
    /// </summary>
    property Name: string read GetName write SetName;

    /// <summary>
    /// Gets the description of the currently selected resource.
    /// </summary>
    property Description: string read GetDescription;

    /// <summary>
    /// Gets the GitHub URL associated with the currently selected resource.
    /// </summary>
    property GitHub: string read GetGitHub;

    /// <summary>
    /// Gets the GetIt URL associated with the currently selected resource.
    /// </summary>
    property Getit: string read GetGetit;

    /// <summary>
    /// Gets the list of file paths associated with the currently selected resource.
    /// </summary>
    property Files: TArray<string> read GetFiles;

    /// <summary>
    /// Gets the list of file upload identifiers for the currently selected resource.
    /// </summary>
    property FileUploadIds: TArray<string> read GetUploadIds;

    /// <summary>
    /// Gets the resources object representing the complete resource list.
    /// </summary>
    property Resources: TObject read GetResources;

    /// <summary>
    /// Gets or sets the vector store identifier for the selected resource.
    /// </summary>
    property VectorStore: string read GetVectorStore write SetVectorStore;
  end;

implementation

{ TVectorResourceCore }

procedure TVectorResourceCore.Clear;
begin
  FVectorResourceList.Clear;
end;

constructor TVectorResourceCore.Create;
begin
  inherited Create;
  FVectorResourceList := TVectorResourceList.Reload;
end;

destructor TVectorResourceCore.Destroy;
begin
  FVectorResourceList.Free;
  inherited;
end;

function TVectorResourceCore.GetData(Index: Integer): TVectorResourceItem;
begin
  Result := FVectorResourceList.Data[Index];
end;

{ TVectorResourceVCL }

procedure TVectorResourceVCL.AddFile(const FileName: string);
begin
  Data[ItemIndex].Files := Data[ItemIndex].Files + [FileName];
end;

function TVectorResourceVCL.AttachTo(const Value: TComponent;
  const OnClickProc: TProc<TObject>): IAppFileStoreManager;
begin
  for var item := 0 to Length(FVectorResourceList.Data)-1 do
    TContainer.Create(Value)
      .ApplyTop(GetTopPosition(item))
      .ApplyIndex(item)
      .ApplyImage(FVectorResourceList.Data[item].GetImageStream)
      .ApplyName(FVectorResourceList.Data[item].Name)
      .ApplyDescription(FVectorResourceList.Data[item].Description)
      .ApplyGitHubUrl(FVectorResourceList.Data[item].Github)
      .ApplyGetitUrl(FVectorResourceList.Data[item].Getit)
      .OnSelect(OnClickProc);
  Result := Self;
end;

function TVectorResourceVCL.DefaultValues: IAppFileStoreManager;
begin
  Initialize;
  UpdateCurrent;
  Result := Self;
end;

procedure TVectorResourceVCL.DeleteFile(index: Integer);
begin
  Data[ItemIndex].DeleteFilePair(index);
end;

procedure TVectorResourceVCL.EnsureFilesCountNotNull(const Index: Integer);
begin
  if Length(Data[Index].Files) = 0 then
    raise EFileCountNull.Create(Format('No files exists for vector store "%s"', [Name]));
end;

procedure TVectorResourceVCL.EnsureFilesExists(const FileNames: TArray<string>);
begin
  for var Item in FileNames do
    if not FileExists(Item) then
      raise Exception.CreateFmt(
         'Error: File "%s" not found' + sLineBreak +
         'vector store not valid for "%s"',
         [Item, Name]);
end;

procedure TVectorResourceVCL.EnsureFilesExists(const Index: Integer);
begin
  EnsureFilesExists(Data[Index].Files);
end;

function TVectorResourceVCL.GetDescription: string;
begin
  Result := Data[ItemIndex].Description;
end;

function TVectorResourceVCL.GetFileName(const Index, Step: Integer): string;
begin
  if Length(Data[Index].Files) > Step + 1 then
    Result := Data[Index].Files[Step + 1]
  else
    Result := EmptyStr;
end;

function TVectorResourceVCL.GetFiles: TArray<string>;
begin
  Result := Data[ItemIndex].Files;
end;

function TVectorResourceVCL.GetFileUploadId(const Index, Step: Integer): string;
begin
  if Length(Data[Index].FileUploadId) > Step then
    Result := Data[Index].FileUploadId[Step]
  else
    Result := EmptyStr;
end;

function TVectorResourceVCL.GetGetit: string;
begin
  Result := Data[ItemIndex].Getit;
end;

function TVectorResourceVCL.GetGitHub: string;
begin
  Result := Data[ItemIndex].Github;
end;

function TVectorResourceVCL.GetImagePath: string;
begin
  Result := Data[ItemIndex].Image;
end;

function TVectorResourceVCL.GetItemIndex: Integer;
begin
  Result := FVectorResourceList.ItemIndex;
end;

function TVectorResourceVCL.GetName: string;
begin
  Result := Data[ItemIndex].Name;
end;

function TVectorResourceVCL.GetResources: TObject;
begin
  Result := FVectorResourceList;
end;

function TVectorResourceVCL.GetUploadIds: TArray<string>;
begin
  Result := Data[Itemindex].FileUploadId;
end;

function TVectorResourceVCL.GetVectorStore: string;
begin
  Result := FVectorStore;
end;

function TVectorResourceVCL.HandleFileStep(const Value: string; Index,
  Step: Integer): string;
var
  Buffer: TArray<string>;
begin
  Buffer := Value.Split([#10]);
  if Step = 0 then
    begin
      Data[Index].VectorStoreId := Buffer[0];
      TFileUploadIdTemp := [Buffer[1]];
      FVectorStore := Buffer[0];
    end
  else
    begin
      if Length(Buffer) > 1 then
        begin
          TFileUploadIdTemp := TFileUploadIdTemp + [Buffer[1]];
        end;
    end;
  Result := GetFileName(Index, Step);
end;

procedure TVectorResourceVCL.Initialize;
begin
  FVectorResourceList.Chain
    .Apply(TVectorResourceListProp.ItemIndex, 0)
    .Apply(TVectorResourceListProp.Data, [
       function: TVectorResourceItem
       begin
         Result := TVectorResourceItem.Create;
         Result.Image := '..\..\logos\OpenAILogo.png';
         Result.Name := 'GenAI';
         Result.Description := 'Delphi Wrapper for OpenAI';
         Result.Github := 'https://github.com/MaxiDonkey/DelphiGenAI';
         Result.Getit := 'https://getitnow.embarcadero.com/genai-optimized-openai-integration-wrapper/';
         Result.Files := ['..\..\data\GenAI_documentation.txt'];
       end,
       function: TVectorResourceItem
       begin
         Result := TVectorResourceItem.Create;
         Result.Image := '..\..\logos\MistralAILogo.png';
         Result.Name := 'MistralAI';
         Result.Description := 'Delphi Wrapper for MistralAI';
         Result.Github := 'https://github.com/MaxiDonkey/DelphiMistralAI';
         Result.Getit := 'https://getitnow.embarcadero.com/mistralai-wrapper/';
         Result.Files := ['..\..\data\MistralAI_documentation.txt'];
       end,
       function: TVectorResourceItem
       begin
         Result := TVectorResourceItem.Create;
         Result.Image := '..\..\logos\Anthropic.png';
         Result.Name := 'Anthropic';
         Result.Description := 'Delphi Wrapper for Anthropic (Claude)';
         Result.Github := 'https://github.com/MaxiDonkey/DelphiAnthropic';
         Result.Getit := 'https://getitnow.embarcadero.com/anthropic-api-wrapper-for-delphi/';
         Result.Files := ['..\..\data\Anthropic_documentation.txt'];
       end,
       function: TVectorResourceItem
       begin
         Result := TVectorResourceItem.Create;
         Result.Image := '..\..\logos\GeminiLogo.png';
         Result.Name := 'Gemini';
         Result.Description := 'Delphi Wrapper for Gemini';
         Result.Github := 'https://github.com/MaxiDonkey/DelphiGemini';
         Result.Getit := 'https://getitnow.embarcadero.com/gemini-api-wrapper-for-delphi/';
         Result.Files := ['..\..\data\Gemini_documentation.txt'];
       end,
       function: TVectorResourceItem
       begin
         Result := TVectorResourceItem.Create;
         Result.Image := '..\..\logos\Deepseek_logo.png';
         Result.Name := 'Deepseek';
         Result.Description := 'Delphi Wrapper for Deepseek';
         Result.Github := 'https://github.com/MaxiDonkey/DelphiDeepseek';
         Result.Getit := 'https://getitnow.embarcadero.com/deepseek-api-wrapper-for-delphi/';
         Result.Files := ['..\..\data\Deepseek_documentation.txt'];
       end,
       function: TVectorResourceItem
       begin
         Result := TVectorResourceItem.Create;
         Result.Image := '..\..\logos\GroqCloudLogo.png';
         Result.Name := 'Groq cloud';
         Result.Description := 'Delphi Wrapper for Groq cloud';
         Result.Github := 'https://github.com/MaxiDonkey/DelphiGroqCloud';
         Result.Getit := 'https://getitnow.embarcadero.com/groqcloud-api-wrapper-for-delphi/';
         Result.Files := ['..\..\data\GroqCloud_documentation.txt'];
       end,
       function: TVectorResourceItem
       begin
         Result := TVectorResourceItem.Create;
         Result.Image := '..\..\logos\HuggingFaceLogo.png';
         Result.Name := 'Hugging Face';
         Result.Description := 'Delphi Wrapper for Hugging Face';
         Result.Github := 'https://github.com/MaxiDonkey/DelphiHuggingFace';
         Result.Getit := 'https://getitnow.embarcadero.com/hugging-face-api-wrapper-for-delphi/';
         Result.Files := ['..\..\data\HugginFace_documentation.txt'];
       end,
       function: TVectorResourceItem
       begin
         Result := TVectorResourceItem.Create;
         Result.Image := '..\..\logos\StabilityAILogo.png';
         Result.Name := 'Stability AI';
         Result.Description := 'Delphi Wrapper for StabilityAI';
         Result.Github := 'https://github.com/MaxiDonkey/DelphiStabilityAI';
         Result.Getit := 'https://getitnow.embarcadero.com/stability-ai-api-wrapper-for-delphi/';
         Result.Files := ['..\..\data\StabilityAI_documentation.txt'];
       end,
       function: TVectorResourceItem
       begin
         Result := TVectorResourceItem.Create;
         Result.Image := '..\..\logos\File2knowledgeAI_logo.png';
         Result.Name := 'file2knowledge';
         Result.Description := 'Projet de mise en application de GenAI à travers File2knowledgeAI pour mettre en avant les bonnes pratiques autour du nouveau point de terminaison v1\/responses';
         Result.Github := 'https://github.com/MaxiDonkey/File2knowledgeAI';
         Result.Getit := '';
         Result.Files := ['..\..\data\File2knowledgeAI_part4.txt', '..\..\data\GenAI_documentation.txt'];
       end
    ]);
end;

function TVectorResourceVCL.JSONExists: Boolean;
begin
  Result := FileExists(TVectorResourceList.DefaultFileName);
end;

function TVectorResourceVCL.LoadFromFile(FileName: string): string;
begin
  FVectorResourceList := TVectorResourceList.Reload;
end;

function TVectorResourceVCL.LoadValues: IAppFileStoreManager;
begin
  LoadFromFile;
  UpdateCurrent;
  Result := Self;
end;

function TVectorResourceVCL.PingVectorStore: TPromise<string>;
var
  FileName: string;
begin
  var Index := ItemIndex;

  try
    EnsureFilesCountNotNull(index);
    EnsureFilesExists(Index);
  except
    on E: Exception do
      begin
        var Error := AcquireExceptionObject;
        var Promise := TPromise<string>.Resolved('',
          procedure
          begin
            var ErrorMsg := (Error as Exception).Message;
            AlertService.ShowError(ErrorMsg);
            Error.Free;
          end);
        Exit(Promise);
      end;
  end;

  FVectorStore := Data[ItemIndex].VectorStoreId;
  FileName := Data[Index].Files[0];
  TFileUploadIdTemp := [];
  Result := OpenAI.EnsureVectorStoreFileLinked(FileName, GetFileUploadId(Index, 0), Data[Index].VectorStoreId)
    .&Then<string>(
     function (Value: string): string
      begin
        Result := HandleFileStep(Value, Index, 0);
      end)
    .&Then(
      function (Value: string): TPromise<string>
      begin
        if Value.IsEmpty then
          Result := TPromise<string>.Resolved(FVectorStore)
        else
          Result :=  OpenAI.EnsureVectorStoreFileLinked(Value,
                       GetFileUploadId(Index, 1),
                       Data[Index].VectorStoreId)
      end)
    .&Then<string>(
     function (Value: string): string
      begin
        Result := HandleFileStep(Value, Index, 1);
      end)
    .&Then(
      function (Value: string): TPromise<string>
      begin
        if Value.IsEmpty then
          Result := TPromise<string>.Resolved(FVectorStore)
        else
          Result := OpenAI.EnsureVectorStoreFileLinked(Value,
                      GetFileUploadId(Index, 2),
                      Data[Index].VectorStoreId)
      end)
    .&Then<string>(
     function (Value: string): string
      begin
        Result := HandleFileStep(Value, Index, 2);
      end)
    .&Then(
      function (Value: string): TPromise<string>
      begin
        if Value.IsEmpty then
          Result := TPromise<string>.Resolved(FVectorStore)
        else
          Result := OpenAI.EnsureVectorStoreFileLinked(Value,
                      GetFileUploadId(Index, 3),
                      Data[Index].VectorStoreId)
      end)
    .&Then<string>(
     function (Value: string): string
      begin
        Result := HandleFileStep(Value, Index, 3);
      end)
    .&Then(
      function (Value: string): TPromise<string>
      begin
        if Value.IsEmpty then
          Result := TPromise<string>.Resolved(FVectorStore)
        else
          Result := OpenAI.EnsureVectorStoreFileLinked(Value,
                      GetFileUploadId(Index, 4),
                      Data[Index].VectorStoreId)
      end)
    .&Then<string>(
     function (Value: string): string
      begin
        Data[Index].FileUploadId := TFileUploadIdTemp;
        SaveToFile;
        Result := FVectorStore;
      end)
end;

procedure TVectorResourceVCL.Reload;
begin
  LoadFromFile;
end;

procedure TVectorResourceVCL.SaveToFile(FileName: string);
begin
  FVectorResourceList.Save;
end;

procedure TVectorResourceVCL.Select(const Value: Integer);
begin
  TContainer.ContainerSelect(Value);
end;

procedure TVectorResourceVCL.SetItemIndex(const Value: Integer);
begin
  FVectorResourceList.ItemIndex := Value;
end;

procedure TVectorResourceVCL.SetName(const Value: string);
begin
  Data[ItemIndex].Name := Value;
end;

procedure TVectorResourceVCL.SetVectorStore(const Value: string);
begin
  FVectorStore := Value;
end;

procedure TVectorResourceVCL.UpdateCurrent;
begin
  PingVectorStore;
end;

end.

## La partie de communication avec le LLM - situé dans le dossier 'providers' du projet

Le LLM en question ici est OpenAI avec le point de terminaison v1/responses et les modèles qui le supportent ainsi que les outils.

Cette partie contient:

1. L'unité façade 
    - Provider.OpenAI.pas

Cette unité appelle toutes les autres par injection. 

    - Provider.OpenAI.ExecutionEngine.pas
    - Provider.OpenAI.FileStore.pas
    - Provider.OpenAI.StreamEvents.pas
    - Provider.OpenAI.VectorStore.pas   
    - Provider.ResponseIdTracker.pas
    - Provider.InstructionManager.pas

### Le code source de ces unités:

unit Provider.InstructionManager;

interface

uses
  System.SysUtils, System.Classes, Manager.Intf, Manager.Types;

const
  FILE_PATH_SYSTEM_PROMPT_DEFAULT = '..\..\prompts\system_prompt_context.txt';
  FILE_PATH_SYSTEM_PROMPT_OPENAI = '..\..\prompts\system_prompt_context_openAI.txt';
  FILE_PATH_SYSTEM_PROMPT_BASIC = '..\..\prompts\system_prompt_context_basict.txt';

type
  TSystemPromptBuilder = class(TInterfacedObject, ISystemPromptBuilder)
  private
    function LoadContent(const FileName: string): string;
  public
    function BuildSystemPrompt: string;
  end;

implementation

{ TSystemPromptBuilder }

function TSystemPromptBuilder.BuildSystemPrompt: string;
begin
  if (sf_fileSearchDisabled in ServiceFeatureSelector.FeatureModes) or
     (sf_reasoning in ServiceFeatureSelector.FeatureModes) then
    begin
      Exit(Format(LoadContent(FILE_PATH_SYSTEM_PROMPT_BASIC), [Settings.ProficiencyToString, Settings.UserScreenName]))
    end;

  var Wrapper := FileStoreManager.Description;
  var GitHub := FileStoreManager.GitHub;

  if FileStoreManager.Description = 'Delphi Wrapper for OpenAI' then
    Result := Format(LoadContent(FILE_PATH_SYSTEM_PROMPT_OPENAI), [Settings.ProficiencyToString, Wrapper, GitHub, Settings.UserScreenName])
  else
    Result := Format(LoadContent(FILE_PATH_SYSTEM_PROMPT_DEFAULT), [Settings.ProficiencyToString, Wrapper, GitHub, Settings.UserScreenName]);
end;

function TSystemPromptBuilder.LoadContent(const FileName: string): string;
begin
  var Stream := TFileStream.Create(Filename, fmOpenRead or fmShareDenyNone);
  try
    var Reader := TStreamReader.Create(Stream, TEncoding.UTF8);
    try
      Result := Reader.ReadToEnd;
    finally
      Reader.Free;
    end;
  finally
    Stream.Free;
  end;
end;

end.


unit Provider.OpenAI.ExecutionEngine;

(*
  Unit: Provider.OpenAI.ExecutionEngine

  Purpose:
    This unit implements the main execution engine for prompt submission and response handling in an OpenAI/GenAI Delphi integration.
    It manages the asynchronous lifecycle of prompt executions, including streaming, event-driven response processing,
    session storage, error management, and UI/interactor feedback.

  Architecture and approach:
    - TPromptExecutionEngine is the key orchestrator for executing user prompts:
        - Handles prompt formatting, parameter building, and contextual instructions (tools, web/file search, reasoning, etc).
        - Coordinates asynchronous streaming of results via the GenAI client, managing cancellation, error chains, file/web search and UI callbacks.
        - Delegates all event processing during response streaming to an event engine manager (IEventEngineManager).
        - Integrates with persistent session objects for chat continuity, storage, and history tracking.
    - Modularity and extensibility:
        - Designed for dependency injection; all external collaborations are interface-driven (GenAI, system prompt builder, etc).
        - Implements async promise patterns for non-blocking UI and workflow chaining.
        - All event/stream-specific logic is delegated to pluggable managers (cf. Provider.OpenAI.StreamEvents).
    - Robust lifecycle management:
        - Explicit control over chat turn creation, prompt history, intermediate/finalization states, cancellation, and error handling.
        - All UI and session feedback is routed explicitly for user experience and recoverability.

  Developer highlights:
    - To use, instantiate TPromptExecutionEngine via IoC or directly, providing required dependencies.
    - Execute() launches a full-featured prompt including streaming, event routing, session and history management.
    - Extendable by customizing IEventEngineManager or session/prompt builders for test or advanced scenarios.
    - Clear segregation of responsibilities for async chain, streaming, session save, and result collection.

  Dependencies:
    - GenAI and GenAI.Types for OpenAI contracts and API streaming.
    - Chat/session managers, prompt builders, output displayers, and cancellation management.
    - Event engine manager (cf. Provider.OpenAI.StreamEvents) for event-based streaming handling.

  This unit is designed for robustness, modularity, and scalability in prompt execution and streaming scenarios,
  enabling maintainable and extensible Delphi OpenAI/GenAI integrations aligned with best architecture practices (SOLID, async, DI).

*)

interface

uses
  System.SysUtils, System.classes, System.Generics.Collections, System.DateUtils, System.Threading,
  GenAI, GenAI.Types,
  Manager.Async.Promise, Manager.Intf, Manager.IoC, ChatSession.Controller, Manager.Utf8Mapping,
  Helper.UserSettings, Manager.Types, Provider.InstructionManager, Provider.OpenAI.StreamEvents;

type
  /// <summary>
  ///   Main execution engine for OpenAI/GenAI prompt submission and streaming response
  ///   management within a Delphi application. Handles the full lifecycle of a prompt request,
  ///   including asynchronous API calls, streaming response processing, session tracking,
  ///   storage, and user interface integration.
  /// </summary>
  /// <remarks>
  ///   <para>
  ///   This class serves as the core orchestrator for all prompt execution workflows:
  ///   - Constructs prompt parameters (tools, reasoning, context, etc.) according to application settings.
  ///   - Manages integration with the GenAI client for both synchronous and asynchronous operations.
  ///   - Delegates streaming event processing to an event engine manager (<c>IEventEngineManager</c>),
  ///     which routes each event to registered event handlers.
  ///   - Tracks and persists session state, including chat history and streaming buffers.
  ///   - Coordinates error and cancellation handling for robust, user-friendly UX.
  ///   </para>
  ///   <para>
  ///   Designed for extensibility and modularity via dependency injection; can be replaced or extended
  ///   for custom scenarios, alternative engines, or unit testing.
  ///   </para>
  ///   Example usage:
  ///   <code>
  ///   var
  ///     Engine: IPromptExecutionEngine;
  ///   begin
  ///     Engine := TPromptExecutionEngine.Create(GenAIClient, SystemPromptBuilder);
  ///     Engine.Execute('Tell me a joke').&Then(
  ///       procedure(Response: string)
  ///       begin
  ///         ShowMessage(Response);
  ///       end
  ///     );
  ///   end;
  ///   </code>
  /// </remarks>
  TPromptExecutionEngine = class(TInterfacedObject, IPromptExecutionEngine)
  private
    /// <summary>
    /// The GenAI client instance used for all API communications.
    /// </summary>
    FClient: IGenAI;

    /// <summary>
    /// The builder instance for creating system/contextual prompts to send with user prompts.
    /// </summary>
    FSystemPromptBuilder: ISystemPromptBuilder;

    /// <summary>
    /// The event engine manager responsible for routing and processing streaming events during AI response flows.
    /// </summary>
    FEventEngineManager: IEventEngineManager;

    /// <summary>
    /// Builds the reasoning parameters structure used for advanced reasoning models.
    /// </summary>
    /// <returns>
    /// A fully populated <c>TReasoningParams</c> instance.
    /// </returns>
    function CreateReasoningEffortParams: TReasoningParams;

    /// <summary>
    /// Constructs the parameters for web search tool integration, selecting the preview/search tool type.
    /// </summary>
    /// <returns>
    /// An initialized <c>THostedToolParams</c> object ready for use in request configuration.
    /// </returns>
    function BuildWebSearchToolChoiceParams: THostedToolParams;

    /// <summary>
    /// Creates and configures file search tool parameters, supplying vector store identifiers if available.
    /// </summary>
    /// <returns>
    /// A <c>TResponseToolParams</c> object containing file search configuration.
    /// </returns>
    function CreateWebSearchToolParamsWithContext: TResponseToolParams;

    /// <summary>
    /// Creates and configures web search tool parameters, optionally including user geolocation context.
    /// </summary>
    /// <returns>
    /// A <c>TResponseToolParams</c> object for web search tool configuration.
    /// </returns>
    function CreateFileSearchToolParamsWithStore: TResponseToolParams;

    /// <summary>
    ///   Finalizes the current chat turn, updating stored search and reasoning results and saving session state.
    /// </summary>
    procedure FinalizeCurrentTurn;

    /// <summary>
    ///   Adds a new chat turn to the persistent session, stamping it with the current timestamp.
    /// </summary>
    /// <returns>
    ///   The new <c>TChatTurn</c> object representing the prompt/response exchange.
    /// </returns>
    function AddChatTurnWithTimestamp: TChatTurn;

    /// <summary>
    /// Event handler invoked at the start of a chat turn,
    /// used to reset UI state and displayers before streaming begins.
    /// </summary>
    /// <param name="Sender">
    /// The caller context for the start event (typically async engine or UI).
    /// </param>
    procedure OnTurnStart(Sender: TObject);

    /// <summary>
    /// Event handler invoked after a successful completion of a chat turn,
    /// finalizing UI and session state and saving results to storage.
    /// </summary>
    /// <param name="Sender">
    /// The sender of the completion notification (engine, promise, etc.).
    /// </param>
    procedure OnTurnSuccess(Sender: TObject);

    /// <summary>
    /// Event handler triggered when an error occurs during prompt execution or streaming.
    /// Finalizes state and displays an error message.
    /// </summary>
    /// <param name="Sender">
    /// The sender context of the error event.
    /// </param>
    /// <param name="Error">
    /// Description of the error encountered.
    /// </param>
    procedure OnTurnError(Sender: TObject; Error: string);

    /// <summary>
    /// Event handler triggered when the current chat turn is cancelled by the user or system.
    /// Cleans up UI state, flags cancellation, and persists session data.
    /// </summary>
    /// <param name="Sender">
    /// The context object triggering cancellation.
    /// </param>
    procedure OnTurnCancelled(Sender: TObject);
  public
    /// <summary>
    /// Submits a prompt for execution via the OpenAI/GenAI engine, handling streaming
    /// of results, session management, and output tracking.
    /// </summary>
    /// <param name="Prompt">
    /// The user's prompt or question to be sent to the AI for completion or answer.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;string&gt;</c> that resolves asynchronously with the AI's response text,
    /// or is rejected if an error or cancellation occurs.
    /// </returns>
    function Execute(const Prompt: string): TPromise<string>;

    constructor Create(const GenAIClient: IGenAI; const AystemPromptBuilder: ISystemPromptBuilder);
  end;

implementation

{ TPromptExecutionEngine }

function TPromptExecutionEngine.AddChatTurnWithTimestamp: TChatTurn;
begin
  Result := PersistentChat.AddPrompt;

  if Length(PersistentChat.CurrentChat.Data) = 1 then
    begin
      PersistentChat.CurrentChat.CreatedAt := DateTimeToUnix(Now, False);
      PersistentChat.CurrentChat.Title := 'New chat ...';
    end;

  PersistentChat.CurrentChat.ModifiedAt := DateTimeToUnix(Now, False);
end;

function TPromptExecutionEngine.BuildWebSearchToolChoiceParams: THostedToolParams;
begin
  Result := THostedToolParams.Create
    .&Type('web_search_preview')
end;

constructor TPromptExecutionEngine.Create(const GenAIClient: IGenAI;
  const AystemPromptBuilder: ISystemPromptBuilder);
begin
  inherited Create;
  FClient := GenAIClient;
  FSystemPromptBuilder := AystemPromptBuilder;
  FEventEngineManager := TEventEngineManager.Create;
end;

function TPromptExecutionEngine.CreateFileSearchToolParamsWithStore: TResponseToolParams;
begin
  Result := TResponseFileSearchParams.New;

  if Length(FileStoreManager.VectorStore) > 0 then
    (Result as TResponseFileSearchParams).VectorStoreIds([FileStoreManager.VectorStore]);
end;

function TPromptExecutionEngine.CreateReasoningEffortParams: TReasoningParams;
begin
  {--- Create reasoning effort }
  Result := TReasoningParams.Create.Effort(Settings.ReasoningEffort);

  if Settings.UseSummary then
    Result.Summary(Settings.ReasoningSummary);
end;

function TPromptExecutionEngine.CreateWebSearchToolParamsWithContext: TResponseToolParams;
begin
  Result := TResponseWebSearchParams.New
    .SearchContextSize(Settings.WebContextSize);

  if not Settings.Country.Trim.IsEmpty or not Settings.City.Trim.IsEmpty then
    (Result as TResponseWebSearchParams).UserLocation(
      TResponseUserLocationParams.New
        .Country(Settings.Country)
        .City(Settings.City)
    );
end;

function TPromptExecutionEngine.Execute(const Prompt: string): TPromise<string>;
var
  StreamBuffer: string;
begin
  FClient.API.HttpClient.ResponseTimeout := TTimeOut.TextToCardinal(Settings.TimeOut);

  var CurrentTurn := AddChatTurnWithTimestamp;
  CurrentTurn.Storage := True;
  CurrentTurn.Prompt := Prompt;

  var ChunkDisplayedCount := 0;

  Result := TPromise<string>.Create(
    procedure(Resolve: TProc<string>; Reject: TProc<Exception>)
    begin
      FClient.Responses.AsynCreateStream(
        procedure (Params: TResponsesParams)
        begin
          {--- Set the AI model based on the enabled mode }
          if sf_reasoning in ServiceFeatureSelector.FeatureModes then
            begin
              Params.Model(Settings.ReasoningModel);
              Params.Reasoning(CreateReasoningEffortParams);
            end
          else
            begin
              Params.Model(Settings.SearchModel);
            end;

          {--- Configure the main user prompt input }
          Params.Input(CurrentTurn.Prompt);

          {--- Apply contextual system instructions }
          Params.Instructions(FSystemPromptBuilder.BuildSystemPrompt);

          {--- Explicitly specify tool choices based on active mode }
          if sf_webSearch in ServiceFeatureSelector.FeatureModes then
            begin
              Params.ToolChoice(BuildWebSearchToolChoiceParams);
            end;

          {--- Define the set of available tools according to current feature modes }
          if not (sf_reasoning in ServiceFeatureSelector.FeatureModes) then
            begin
              if sf_fileSearchDisabled in ServiceFeatureSelector.FeatureModes then
                begin
                  if sf_webSearch in ServiceFeatureSelector.FeatureModes then
                    begin
                      Params.Tools([CreateWebSearchToolParamsWithContext]);
                    end;
                end
              else
                begin
                  if sf_webSearch in ServiceFeatureSelector.FeatureModes then
                    begin
                      if Length(FileStoreManager.VectorStore) > 0 then
                        begin
                          Params.Tools([
                            CreateFileSearchToolParamsWithStore,
                            CreateWebSearchToolParamsWithContext
                          ]);
                        end
                      else
                        begin
                          Params.Tools([
                            CreateWebSearchToolParamsWithContext
                          ]);
                        end;
                    end
                  else
                    begin
                      if Length(FileStoreManager.VectorStore) > 0 then
                        begin
                          Params.Tools([CreateFileSearchToolParamsWithStore]);
                        end;
                    end;
                end
            end
          else
            begin
              {--- No web search tool available for reasoning model }
            end;

          {--- Enable file_search results inclusion }
          Params.Include([TOutputIncluding.file_search_result]);

          {--- Enable streaming mode for the response }
          Params.Stream(True);

          {--- Enable or disable conversation storage based on configuration }
          Params.Store(CurrentTurn.Storage);

          {--- Link the request to a previous response ID for contextual thread management }
          if CurrentTurn.Storage and not ResponseTracking.LastId.IsEmpty then
            begin
              Params.PreviousResponseId(ResponseTracking.LastId);
            end;

          {--- Serialize the final request to the prompt data collector }
          CurrentTurn.JsonPrompt := Params.ToJsonString();

          {--- Persistently save the current prompt to file }
          PersistentChat.SaveToFile;
        end,

        function : TAsynResponseStream
        begin
          Result.Sender := CurrentTurn;

          Result.OnStart := OnTurnStart;

          Result.OnProgress :=
            procedure (Sender: TObject; Chunk: TResponseStream)
            begin
              try
                if not FEventEngineManager.AggregateStreamEvents(Chunk, StreamBuffer, ChunkDisplayedCount) then
                  begin
                    {--- Event error }
                    ResponseTracking.Cancel;
                    Reject(Exception.Create('(' + Chunk.Code + ')' + Chunk.Message));
                  end;
              except
                {--- Silent Exception - To avoid RSS-391 error for unpatched 12.1.
                     And also if a processing in AggregateStreamEvents generated an error }
              end;
            end;

          Result.OnSuccess :=
            procedure (Sender: TObject)
            begin
              OnTurnSuccess(Sender);
              Resolve(CurrentTurn.Response);
            end;

          Result.OnError :=
            procedure (Sender: TObject; Error: string)
            begin
              CurrentTurn.Response := StreamBuffer;
              OnTurnError(Sender, Error);
              Reject(Exception.Create(Error));
            end;

          Result.OnDoCancel :=
            function : Boolean
            begin
              Result := Cancellation.IsCancelled;
              if Result then
                begin
                  EdgeDisplayer.HideReasoning;
                  EdgeDisplayer.Display('Operation canceled');
                end;
            end;

          Result.OnCancellation :=
            procedure (Sender: TObject)
            begin
              CurrentTurn.Response := StreamBuffer + #10#10 + 'Aborted';
              OnTurnCancelled(Sender);
              Reject(Exception.Create('Aborted'));
            end;
        end);
    end);
end;

procedure TPromptExecutionEngine.FinalizeCurrentTurn;
begin
  var CurrentTurn := PersistentChat.CurrentPrompt;

  if FileSearchDisplayer.Text.IsEmpty then
    FileSearchDisplayer.Display('no item found');
  CurrentTurn.FileSearch := FileSearchDisplayer.Text;

  if WebSearchDisplayer.Text.IsEmpty then
    WebSearchDisplayer.Display('no item found');
  CurrentTurn.WebSearch := WebSearchDisplayer.Text;

  if ReasoningDisplayer.Text.IsEmpty then
    ReasoningDisplayer.Display('no item found');
  CurrentTurn.Reasoning := ReasoningDisplayer.Text;

  PersistentChat.SaveToFile;
end;

procedure TPromptExecutionEngine.OnTurnCancelled(Sender: TObject);
begin
  FinalizeCurrentTurn;
  ResponseTracking.Cancel;
  Cancellation.Cancel;
  PersistentChat.SaveToFile;
  ChatSessionHistoryView.Refresh(nil);
end;

procedure TPromptExecutionEngine.OnTurnError(Sender: TObject; Error: string);
begin
  FinalizeCurrentTurn;
  EdgeDisplayer.HideReasoning;
  EdgeDisplayer.Display(TUtf8Mapping.CleanTextAsUTF8(Error));
  Cancellation.Cancel;
  PersistentChat.SaveToFile;
  ChatSessionHistoryView.Refresh(nil);
end;

procedure TPromptExecutionEngine.OnTurnStart(Sender: TObject);
begin
  Cancellation.Reset;
  EdgeDisplayer.Prompt(ServicePrompt.Text);
  ServicePrompt.Clear;
  FileSearchDisplayer.Clear;
  WebSearchDisplayer.Clear;
  ReasoningDisplayer.Clear;
  EdgeDisplayer.ShowReasoning;
end;

procedure TPromptExecutionEngine.OnTurnSuccess(Sender: TObject);
begin
  FinalizeCurrentTurn;
  EdgeDisplayer.DisplayStream(sLineBreak + sLineBreak);
  Cancellation.Cancel;
  PersistentChat.SaveToFile;
  ChatSessionHistoryView.Refresh(nil);
  PromptSelector.Update;
end;


end.


unit Provider.OpenAI.FileStore;

interface

uses
  System.SysUtils, GenAI, GenAI.Types, Manager.Intf, Manager.Async.Promise;

type
  TFileStoreManager = class(TInterfacedObject, IFileStoreManager)
  private
    FClient: IGenAI;
  public
    function CheckFileUploaded(const FileName, Id: string): TPromise<string>;
    function UploadFileAsync(const FileName: string): TPromise<string>;
    function EnsureFileId(const FileName: string; const Id: string): TPromise<string>;
    constructor Create(const GenAIClient: IGenAI);
  end;

implementation

{ TFileStoreManager }

function TFileStoreManager.CheckFileUploaded(const FileName,
  Id: string): TPromise<string>;
begin
  Result := TPromise<string>.Create(
    procedure(Resolve: TProc<string>; Reject: TProc<Exception>)
    begin
      FClient.Files.AsynList(
        function : TAsynFiles
        begin
          Result.OnSuccess :=
            procedure (Sender: TObject; Value: TFiles)
            begin
              var Matched := False;

              for var Item in Value.Data do
                if (Item.Purpose = TFilesPurpose.user_data) and
                   (Item.Filename = ExtractFileName(FileName)) and
                   (Item.Id = Id) then
                  begin
                    Matched := True;
                    Break;
                  end;

              if Matched then
                Resolve(Id)
              else
                Resolve(EmptyStr);
            end;

          Result.OnError :=
            procedure (Sender: TObject; Error: string)
            begin
              Reject(Exception.Create(Error));
            end;
        end);
    end);
end;

constructor TFileStoreManager.Create(const GenAIClient: IGenAI);
begin
  inherited Create;
  FClient := GenAIClient;
end;

function TFileStoreManager.EnsureFileId(const FileName,
  Id: string): TPromise<string>;
begin
  {--- Ensure the presence of the specified file on the FTP server. }
  Result := CheckFileUploaded(FileName, Id)
    .&Then(
      function(Value: string): TPromise<string>
      begin
        if Value.IsEmpty then
          {--- The file does not exist. Upload the file and obtain its ID. }
          Result := UploadFileAsync(FileName)
        else
          {--- The file exists, so do nothing }
          Result := TPromise<string>.Resolved(Value);
      end);
end;

function TFileStoreManager.UploadFileAsync(
  const FileName: string): TPromise<string>;
begin
  Result := TPromise<string>.Create(
    procedure(Resolve: TProc<string>; Reject: TProc<Exception>)
    begin
      FClient.Files.AsynUpload(
        procedure (Params: TFileUploadParams)
        begin
          Params.&File(FileName);
          Params.Purpose('user_data');
        end,

        function : TAsynFile
        begin
          Result.OnSuccess :=
            procedure (Sender: TObject; Value: TFile)
            begin
              Resolve(Value.Id);
            end;

          Result.OnError :=
            procedure (Sender: TObject; Error: string)
            begin
              Reject(Exception.Create(Error));
            end;
        end);
    end);
end;

end.


unit Provider.OpenAI;

(*
  Unit: Provider.OpenAI

  Purpose:
    This unit serves as the central integration and orchestration point for OpenAI/GenAI capabilities
    within a Delphi application. It manages prompt execution, asynchronous result streaming, session
    tracking, and connects to specialized execution engines and managers via dependency injection (IoC).

  Architecture and approach:
    - TOpenAIProvider acts as the main "facade/orchestrator" for AI interactions:
        - Delegates prompt execution to modular engines (e.g., TPromptExecutionEngine) via interfaces.
        - Exposes clear methods: Execute (streamed mode) and ExecuteSilently (batch/non-streamed mode).
        - Coordinates file/vector store management via dedicated managers, also resolved via IoC.
        - Oversees chat session management, persistent prompt storage, and UI displayer interactions.
    - Supporting engines (IPromptExecutionEngine, etc.) encapsulate the detailed async business logic:
        - Chaining of async requests, event handling, and promise resolution.
        - Handles retrieval of search, reasoning, and annotation results.
        - Supports alternative implementations through DI (tests, mocks, or custom workflows).
    - Dependency Injection (DI) is central:
        - All functional services (store, vector, execution, prompts) are interface-driven and swappable.

  Important:
    - The method InitializeProviderOpenAI *must* be called before instantiating or resolving dependencies
      for TOpenAIProvider or its related services. This ensures all required interfaces and their
      implementations are properly registered within the IoC container for the application's lifetime.

  Developer highlights:
    - Simple integration: just create a TOpenAIProvider, then call Execute or ExecuteSilently as needed.
    - Plug & play with execution engines and managers, configurable through IoC.
    - All file/vector stores and tracking modules are fully interface-based and decoupled.
    - Architecture is modular/testable/maintainable with easy extensibility and proper separation of concerns.

  Dependencies:
    - GenAI and GenAI.Types for OpenAI API contracts.
    - Async promise manager, IoC container, store managers, and session helpers.
    - Execution engines/handlers for specialized streaming and event processing logic.

  This unit is designed for robust, scalable, and best-practice-aligned modular architectures (SOLID/DIP/DI),
  making it easy to maintain, extend, and adapt to new OpenAI and GenAI usage scenarios or workflows.
*)


interface

uses
  System.SysUtils, System.classes, GenAI, GenAI.Types,
  Manager.Async.Promise, Manager.Intf, Manager.IoC, Provider.OpenAI.FileStore,
  Provider.OpenAI.VectorStore, Provider.OpenAI.ExecutionEngine, Provider.InstructionManager;

type
  /// <summary>
  /// TOpenAIProvider is the central facade for integrating OpenAI/GenAI APIs into a Delphi application.
  /// It manages prompt submission, asynchronous result streaming, file/vector store management,
  /// and chat session tracking. The class exposes both streamed and non-streamed ("silent") prompt
  /// execution, delegating the core execution logic to injected execution engines.
  /// </summary>
  /// <remarks>
  /// TOpenAIProvider orchestrates business workflows by delegating technical operations
  /// (prompt execution, file uploads, vector linking, etc.) to dedicated service interfaces.
  /// It is designed for extensibility, testability, and modular replacement via dependency injection.
  /// </remarks>
  TOpenAIProvider = class(TInterfacedObject, IAIInteractionManager)
  private
    FClient: IGenAI;
    FFileStoreManager: IFileStoreManager;
    FVectorStoreManager: IVectorStoreManager;
    FPromptExecutionEngine: IPromptExecutionEngine;
    procedure InitializeProviderOpenAI(const GenAIClient: IGenAI);
  protected
    /// <summary>
    /// Deletes a response from the OpenAI backend.
    /// </summary>
    /// <param name="ResponseId">
    /// Unique identifier of the response to be deleted.
    /// </param>
    /// <returns>
    /// A promise (TPromise&lt;string&gt;) that resolves to a confirmation message upon successful deletion,
    /// or is rejected if an error occurs.
    /// </returns>
    function DeleteResponse(ResponseId: string): TPromise<string>;

    /// <summary>
    /// Deletes the association between a file and a vector store.
    /// </summary>
    /// <param name="VectorStoreId">
    /// The identifier of the target vector store.
    /// </param>
    /// <param name="FileId">
    /// The identifier of the file to be unlinked from the vector store.
    /// </param>
    /// <returns>
    /// A promise (TPromise&lt;string&gt;) that resolves to a confirmation message if successful,
    /// or is rejected if an error occurs.
    /// </returns>
    function DeleteVectorStore(const VectorStoreId, FileId: string): TPromise<string>;

    /// <summary>
    /// Removes a vector store from the OpenAI backend.
    /// </summary>
    /// <param name="VectorStoreId">
    /// Unique identifier of the vector store to remove.
    /// </param>
    /// <returns>
    /// A promise (TPromise&lt;string&gt;) that resolves to a confirmation message upon successful removal,
    /// or is rejected if an error occurs.
    /// </returns>
    function RemoveVectorStore(const VectorStoreId: string): TPromise<string>;

    /// <summary>
    /// Deletes a file from the OpenAI backend file store.
    /// </summary>
    /// <param name="FileId">
    /// Identifier of the file to delete.
    /// </param>
    /// <returns>
    /// A promise (TPromise&lt;string&gt;) that resolves to a confirmation message upon successful deletion,
    /// or is rejected if an error occurs.
    /// </returns>
    function DeleteFile(FileId: string): TPromise<string>;

    /// <summary>
    /// Deletes a file that is linked to a vector store.
    /// </summary>
    /// <param name="VectorStoreId">
    /// The identifier of the vector store containing the file.
    /// </param>
    /// <param name="FileId">
    /// The identifier of the file to delete from the vector store.
    /// </param>
    /// <returns>
    /// A promise (TPromise&lt;string&gt;) that resolves to a confirmation message upon successful deletion,
    /// or is rejected if an error occurs.
    /// </returns>
    function DeleteVectorStoreFile(const VectorStoreId, FileId: string): TPromise<string>;
  public
    /// <summary>
    /// Executes a prompt using the default (streamed) execution engine.
    /// This method sends the prompt to OpenAI, streams back the AI response in real-time,
    /// and coordinates UI updates and session storage as configured.
    /// </summary>
    /// <param name="Prompt">
    /// The user's prompt or question to send to OpenAI.
    /// </param>
    /// <returns>
    /// A promise (TPromise&lt;string&gt;) which resolves to the AI response text,
    /// or is rejected upon error or cancellation.
    /// </returns>
    function Execute(const Prompt: string): TPromise<string>;

    /// <summary>
    /// Executes a prompt in "silent" mode, without real-time streaming or UI updates.
    /// This is intended for background queries, system tasks, or non-interactive batch scenarios.
    /// </summary>
    /// <param name="Prompt">
    /// The user's prompt to send to OpenAI.
    /// </param>
    /// <param name="Instructions">
    /// System instructions to provide context or modify the behavior of the AI assistant.
    /// </param>
    /// <returns>
    /// A promise (TPromise&lt;string&gt;) which resolves to the complete AI response text.
    /// </returns>
    function ExecuteSilently(const Prompt, Instructions: string): TPromise<string>;

    /// <summary>
    /// Ensures a file is present in OpenAI storage and is linked to a vector store.
    /// Handles upload if needed, vector store creation if required, and the association/link.
    /// </summary>
    /// <param name="FileName">
    /// Path to the local file to upload, if necessary.
    /// </param>
    /// <param name="FileId">
    /// The OpenAI file identifier (if known or empty if new upload is needed).
    /// </param>
    /// <param name="VectorStoreId">
    /// The vector store identifier (if known or empty to create a new one).
    /// </param>
    /// <returns>
    /// A promise (TPromise&lt;string&gt;) which resolves with concatenated VectorStoreId and FileId,
    /// or is rejected on error.
    /// </returns>
    function EnsureVectorStoreFileLinked(const FileName: string; const FileId: string;
      const VectorStoreId: string): TPromise<string>;

    constructor Create;
  end;

implementation

{ TOpenAIProvider }

function TOpenAIProvider.EnsureVectorStoreFileLinked(const FileName, FileId,
  VectorStoreId: string): TPromise<string>;

(*
   A current limitation restricts processing to five files, due to constraints in the Delphi compiler.
   Specifically, the compiler is unable to perform self-invocation within recursively nested closures
   when using a promise-based mechanism.

   The ideal solution would involve implementing parallel file processing using promises, with structured
   output tracking. This enhancement is planned for a future release.

   The current implementation leads to a pyramid of doom due to deeply nested closures and lack of proper
   promise chaining. :(
*)

var
  LFileId: string;
  LVectorStoreId: string;
begin
  if not FileExists(FileName) then
    begin
      Result := TPromise<string>.Resolved('');
      Exit;
    end;

  LFileId := FileId;
  LVectorStoreId := VectorStoreId;

  Result :=
    {--- Checks if the file already exists on the remote FileStore }
    FFileStoreManager.EnsureFileId(FileName, LFileId)
      .&Then<string>(
        function (Value: string): string
        begin
          Result := Value;
          {--- If not found, upload (via EnsureFileId); otherwise, keep the existing id. }
          LFileId := Value;
        end)
      .&Then(
        function (Value: string): TPromise<string>
        begin
          {--- Checks if the vector store exists (otherwise creates it). }
          Result := FVectorStoreManager.EnsureVectorStoreId(LVectorStoreId);
        end)
      .&Then<string>(
        function (Value: string): string
        begin
          Result := Value;
          {--- Retaining the id of the newly created or existing vector store. }
          LVectorStoreId := Value;
        end)
      .&Then(
        function (Value: string): TPromise<string>
        begin
          {--- Check that this file is linked to this vector store (create the link if necessary) }
          Result := FVectorStoreManager.EnsureVectorStoreFileId(LVectorStoreId, LFileId);
        end)
      .&Then(
        function (Value: string): TPromise<string>
        begin
          {--- Final resolution: the promise returns the two concatenated ids }
          Result := TPromise<string>.Resolved(LVectorStoreId + #10 + LFileId);
        end)
      .&Catch(
        procedure(E: Exception)
        begin
          {--- Promises chain error handling (display and rejection) }
          AlertService.ShowWarning('Error : ' + E.Message);
        end
      );
end;

constructor TOpenAIProvider.Create;
begin
  {
    IMPORTANT: This class is designed to be used as a singleton.

    - Only one instance of TOpenAIProvider should exist in the application lifecycle.
    - All dependent services and interfaces (file store manager, vector store manager, prompt execution engine, etc.)
      are registered and resolved via the IoC container, which ensures that they are also managed as singletons.
    - Instantiating multiple TOpenAIProvider objects may result in conflicting registrations or
      unexpected behavior, as the underlying services are not intended for multi-instance use.
    - Before creating TOpenAIProvider, always ensure that InitializeProviderOpenAI has been called
      with a valid IGenAI client to properly register all required dependencies in the IoC.
    - The singleton pattern centralizes OpenAI API access, state, and resource coordination, improving
      stability, maintainability, and resource usage throughout the application.
  }
  inherited;
  FClient := IoC.Resolve<IGenAI>;
  InitializeProviderOpenAI(FClient);
  FFileStoreManager := IoC.Resolve<IFileStoreManager>;
  FVectorStoreManager := IoC.Resolve<IVectorStoreManager>;
  FPromptExecutionEngine := IoC.Resolve<IPromptExecutionEngine>;
end;

function TOpenAIProvider.DeleteFile(FileId: string): TPromise<string>;
begin
  Result := TPromise<string>.Create(
    procedure(Resolve: TProc<string>; Reject: TProc<Exception>)
    begin
      FClient.Files.AsynDelete(FileId,
        function : TAsynDeletion
        begin
          Result.Sender := nil;
          Result.OnStart := nil;
          Result.OnSuccess :=
            procedure (Sender: TObject; Value: TDeletion)
            begin
              Resolve(Value.Id + ' deleted');
            end;
          Result.OnError :=
            procedure (Sender: TObject; Error: string)
            begin
              Reject(Exception.Create(Error));
            end;
        end);
    end);
end;

function TOpenAIProvider.DeleteResponse(ResponseId: string): TPromise<string>;
begin
  Result := TPromise<string>.Create(
    procedure(Resolve: TProc<string>; Reject: TProc<Exception>)
    begin
      FClient.Responses.AsynDelete(ResponseId,
        function : TAsynResponseDelete
        begin
          Result.Sender := nil;
          Result.OnStart := nil;
          Result.OnSuccess :=
            procedure (Sender: TObject; Value: TResponseDelete)
            begin
              Resolve(Value.Id + ' deleted');
            end;
          Result.OnError :=
            procedure (Sender: TObject; Error: string)
            begin
              Reject(Exception.Create(Error));
            end;
        end);
    end);
end;

function TOpenAIProvider.DeleteVectorStore(const VectorStoreId,
  FileId: string): TPromise<string>;
begin
  Result := FVectorStoreManager.DeleteVectorStoreFile(VectorStoreId, FileId);
end;

function TOpenAIProvider.DeleteVectorStoreFile(const VectorStoreId,
  FileId: string): TPromise<string>;
begin
  Result := FVectorStoreManager.DeleteVectorStoreFile(VectorStoreId, FileId)
end;

function TOpenAIProvider.Execute(const Prompt: string): TPromise<string>;
begin
  Result := FPromptExecutionEngine.Execute(Prompt);
end;

function TOpenAIProvider.ExecuteSilently(const Prompt, Instructions: string): TPromise<string>;
var
 Buffer: string;
begin
  Result := TPromise<string>.Create(
    procedure(Resolve: TProc<string>; Reject: TProc<Exception>)
    begin
      FClient.Responses.AsynCreate(
        procedure (Params: TResponsesParams)
        begin
           Params.Model(Settings.SearchModel);
           Params.Input(Prompt);
           Params.Instructions(Instructions);
           Params.Store(False);
        end,
        function : TASynResponse
        begin
          Result.Sender := nil;

          Result.OnStart := nil;

          Result.OnSuccess :=
            procedure (Sender: TObject; Response: TResponse)
            begin
              for var Item in Response.Output do
                for var SubItem in Item.Content do
                  Buffer := Buffer + SubItem.Text;
              Resolve(Buffer);
            end;

          Result.OnError :=
            procedure (Sender: TObject; Error: string)
            begin
              Reject(Exception.Create(Error));
            end;
        end)
    end);
end;

procedure TOpenAIProvider.InitializeProviderOpenAI(const GenAIClient: IGenAI);
begin
  IoC.RegisterType<ISystemPromptBuilder>(
    function: ISystemPromptBuilder
    begin
      Result := TSystemPromptBuilder.Create;
    end,
    TLifetime.Singleton
  );

  IoC.RegisterType<IPromptExecutionEngine>(
    function: IPromptExecutionEngine
    begin
      Result := TPromptExecutionEngine.Create(GenAIClient, IoC.Resolve<ISystemPromptBuilder>);
    end,
    TLifetime.Singleton
  );

  IoC.RegisterType<IFileStoreManager>(
    function: IFileStoreManager
    begin
      Result := TFileStoreManager.Create(GenAIClient);
    end,
    TLifetime.Singleton
  );

  IoC.RegisterType<IVectorStoreManager>(
    function: IVectorStoreManager
    begin
      Result := TVectorStoreManager.Create(GenAIClient);
    end,
    TLifetime.Singleton
  );
end;

function TOpenAIProvider.RemoveVectorStore(const VectorStoreId: string): TPromise<string>;
begin
  Result := FVectorStoreManager.DeleteVectorStore(VectorStoreId);
end;

end.


unit Provider.OpenAI.StreamEvents;

(*
  Unit: Provider.OpenAI.StreamEvents

  Purpose:
    Centralizes the definition, enumeration, and handling of all possible streaming events
    that can occur during OpenAI/GenAI response processing within a Delphi application.
    Acts as the canonical inventory of API events for the v1/responses OpenAI endpoint.

  Architecture and approach:
    - Declares an exhaustive enumeration (TStreamEventType) mapping directly to all documented and supported OpenAI streaming events.
    - For every event type, provides a dedicated handler class (IStreamEventHandler descendant),
      each serving as a clear extension point for developers to implement custom logic.
    - The TEventExecutionEngine manages registration and dispatch of event handlers; all known event types
      are registered upon initialization for robust, ready-to-extend coverage.
    - By default, most handler classes are empty ("stub classes"), acting as both living documentation
      and a ready-made scaffold for incremental extension by consuming developers.

  Developer highlights:
    - Serves as an up-to-date self-documenting catalogue of all response events accepted by OpenAI v1/responses.
    - Adding or customizing behavior for a given event simply involves implementing or extending the associated handler class.
    - Ensures that as new events are added or API behaviors evolve, the codebase remains discoverable and maintainable,
      with no risk of silent event dropout or gaps in routing.
    - Facilitates onboarding: developers immediately see all extension points and never have to cross-reference external documentation.

  Usage:
    - TEventEngineManager (or compatible manager) inits and registers all handler classes on construction.
    - During response streaming, incoming event chunks are dispatched to the relevant handler based on their type string.
    - No handler may be omitted; every event type has an explicit handler class, empty or otherwise.

  Dependencies:
    - GenAI, GenAI.Types for response stream types and data contracts.
    - Session/displayer managers and mapping helpers for advanced event implementations.

  This unit is designed for exhaustiveness and maintainability, providing a framework (and living map) for
  the full set of OpenAI response events, ready for industrial extension and robust integration.

*)

interface

uses
  System.SysUtils, System.Classes, Manager.Intf, GenAI, GenAI.Types, ChatSession.Controller,
  Manager.Utf8Mapping, Manager.Types;

type
  {--- List of events as of 05/15/2023 }
  TStreamEventType = (
    created,
    in_progress,
    completed,
    failed,
    incomplete,
    output_item_added,
    output_item_done,
    content_part_added,
    content_part_done,
    output_text_delta,
    output_text_annotation_added,
    output_text_done,
    refusal_delta,
    refusal_done,
    function_call_arguments_delta,
    function_call_arguments_done,
    file_search_call_in_progress,
    file_search_call_searching,
    file_search_call_completed,
    web_search_call_in_progress,
    web_search_call_searching,
    web_search_call_completed,
    reasoning_summary_part_add,
    reasoning_summary_part_done,
    reasoning_summary_text_delta,
    reasoning_summary_text_done,
    error
  );

  TStreamEventTypeHelper = record Helper for TStreamEventType
  const
    StreamEventNames: array[TStreamEventType] of string = (
      'response.created',
      'response.in_progress',
      'response.completed',
      'response.failed',
      'response.incomplete',
      'response.output_item.added',
      'response.output_item.done',
      'response.content_part.added',
      'response.content_part.done',
      'response.output_text.delta',
      'response.output_text.annotation.added',
      'response.output_text.done',
      'response.refusal.delta',
      'response.refusal.done',
      'response.function_call_arguments.delta',
      'response.function_call_arguments.done',
      'response.file_search_call.in_progress',
      'response.file_search_call.searching',
      'response.file_search_call.completed',
      'response.web_search_call.in_progress',
      'response.web_search_call.searching',
      'response.web_search_call.completed',
      'response.reasoning_summary_part.added',
      'response.reasoning_summary_part.done',
      'response.reasoning_summary_text.delta',
      'response.reasoning_summary_text.done',
      'error'
    );
  public
    function ToString: string;
    class function FromString(const S: string): TStreamEventType; static;
    class function AllNames: TArray<string>; static;
  end;

  {--- Interfaces }

  /// <summary>
  ///   Interface for processing specific streaming events emitted during OpenAI/GenAI
  ///   asynchronous response streaming. Each implementation can determine which event type(s)
  ///   it can handle and process chunks accordingly.
  /// </summary>
  /// <remarks>
  ///   <para>
  ///   This interface is used within the event aggregation engine to route streaming event
  ///   chunks to the appropriate handler based on event type. Implementations should define
  ///   the logic required to process a given event type, update output buffers, or manage
  ///   display/UI accordingly.
  ///   </para>
  ///   <para>
  ///   All available OpenAI streaming event types are enumerated in <c>TStreamEventType</c>,
  ///   and one handler per event type is typically registered at initialization.
  ///   </para>
  ///   Example usage:
  ///   <code>
  ///   type
  ///     TMyOutputTextHandler = class(TInterfacedObject, IStreamEventHandler)
  ///       function CanHandle(EventType: TStreamEventType): Boolean;
  ///       function Handle(const Chunk: TResponseStream; var StreamBuffer: string; var ChunkDisplayedCount: Integer): Boolean;
  ///     end;
  ///   </code>
  /// </remarks>
  IStreamEventHandler = interface
    /// <summary>
    ///   Indicates whether this handler is able to process the specified streaming event type.
    /// </summary>
    /// <param name="EventType">
    ///   The event type to check for handling capability.
    /// </param>
    /// <returns>
    ///   <c>True</c> if the handler can process the event; otherwise, <c>False</c>.
    /// </returns>
    function CanHandle(EventType: TStreamEventType): Boolean;

    /// <summary>
    ///   Handles a streaming event chunk and applies any necessary update or processing.
    /// </summary>
    /// <param name="Chunk">
    ///   The streaming response chunk data to process.
    /// </param>
    /// <param name="StreamBuffer">
    ///   Reference to the current output buffer, which may be updated.
    /// </param>
    /// <param name="ChunkDisplayedCount">
    ///   Reference to the count of displayed chunks, which may be incremented.
    /// </param>
    /// <returns>
    ///   <c>True</c> if processing can continue, or <c>False</c> to signal termination (e.g., on error).
    /// </returns>
    function Handle(const Chunk: TResponseStream; var StreamBuffer: string; var ChunkDisplayedCount: Integer): Boolean;
  end;

  /// <summary>
  ///   Interface for managing the aggregation and routing of streaming response events
  ///   originating from the OpenAI/GenAI API. Handles delegation of each event chunk to
  ///   the appropriate event handler during asynchronous response streaming.
  /// </summary>
  /// <remarks>
  ///   <para>
  ///   Implementations of this interface act as the central event engine for the
  ///   streaming process, ensuring that every incoming event chunk is processed by its
  ///   corresponding handler (as defined by <c>IStreamEventHandler</c> implementations).
  ///   </para>
  ///   <para>
  ///   Event engines are designed to be extensible and robust, allowing custom logic
  ///   or new event types to be integrated without modifying upstream business logic.
  ///   </para>
  ///   Example usage:
  ///   <code>
  ///   var
  ///     Manager: IEventEngineManager;
  ///   begin
  ///     if not Manager.AggregateStreamEvents(Chunk, Buffer, Count) then
  ///       // Handle error or cancellation
  ///   end;
  ///   </code>
  /// </remarks>
  IEventEngineManager = interface
    ['{ED3CC5EA-EE71-4F45-AAE2-C54BE8A86157}']
    /// <summary>
    ///   Aggregates and processes incoming streaming event chunks from an OpenAI/GenAI response,
    ///   delegating each event to its registered handler.
    /// </summary>
    /// <param name="Chunk">
    ///   The current streaming response event chunk to process.
    /// </param>
    /// <param name="StreamBuffer">
    ///   Reference to the output buffer accumulated during streaming; may be modified by handlers.
    /// </param>
    /// <param name="ChunkDisplayedCount">
    ///   Reference to the count of output/displayed chunks; may be incremented as processing advances.
    /// </param>
    /// <returns>
    ///   <c>True</c> if processing should continue; <c>False</c> to indicate an error or
    ///   instructed termination (e.g., on an error event).
    /// </returns>
    function AggregateStreamEvents(const Chunk: TResponseStream; var StreamBuffer: string;
      var ChunkDisplayedCount: Integer): Boolean;
  end;

  {--- Engine and Engine manager **********************************************}

  TEventExecutionEngine = class
  private
    FHandlers: TArray<IStreamEventHandler>;
  public
    procedure RegisterHandler(AHandler: IStreamEventHandler);
    function AggregateStreamEvents(const Chunk: TResponseStream;
      var StreamBuffer: string;
      var ChunkDisplayedCount: Integer): Boolean;
  end;

  TEventEngineManager = class(TInterfacedObject, IEventEngineManager)
  private
    FEngine: TEventExecutionEngine;
    procedure EventExecutionEngineInitialize;
  public
    constructor Create;
    function AggregateStreamEvents(const Chunk: TResponseStream; var StreamBuffer: string;
      var ChunkDisplayedCount: Integer): Boolean;
    destructor Destroy; override;
  end;

  {--- Events *****************************************************************}

  TEHCreate = class(TInterfacedObject, IStreamEventHandler)
    function CanHandle(EventType: TStreamEventType): Boolean;
    function Handle(const Chunk: TResponseStream; var StreamBuffer: string;
      var ChunkDisplayedCount: Integer): Boolean;
  end;

  TEHInProgress = class(TInterfacedObject, IStreamEventHandler)
    function CanHandle(EventType: TStreamEventType): Boolean;
    function Handle(const Chunk: TResponseStream; var StreamBuffer: string;
      var ChunkDisplayedCount: Integer): Boolean;
  end;

  TEHCompleted = class(TInterfacedObject, IStreamEventHandler)
    function CanHandle(EventType: TStreamEventType): Boolean;
    function Handle(const Chunk: TResponseStream; var StreamBuffer: string;
      var ChunkDisplayedCount: Integer): Boolean;
  end;

  TEHFailed = class(TInterfacedObject, IStreamEventHandler)
    function CanHandle(EventType: TStreamEventType): Boolean;
    function Handle(const Chunk: TResponseStream; var StreamBuffer: string;
      var ChunkDisplayedCount: Integer): Boolean;
  end;

  TEHIncomplete = class(TInterfacedObject, IStreamEventHandler)
    function CanHandle(EventType: TStreamEventType): Boolean;
    function Handle(const Chunk: TResponseStream; var StreamBuffer: string;
      var ChunkDisplayedCount: Integer): Boolean;
  end;

  TEHOutputItemAdded = class(TInterfacedObject, IStreamEventHandler)
    function CanHandle(EventType: TStreamEventType): Boolean;
    function Handle(const Chunk: TResponseStream; var StreamBuffer: string;
      var ChunkDisplayedCount: Integer): Boolean;
  end;

  TEHOutputItemDone = class(TInterfacedObject, IStreamEventHandler)
  private
    procedure DisplayFileSearchQueries(const Chunk: TResponseStream);
    procedure DisplayFileSearchResults(const Chunk: TResponseStream);
  public
    function CanHandle(EventType: TStreamEventType): Boolean;
    function Handle(const Chunk: TResponseStream; var StreamBuffer: string;
      var ChunkDisplayedCount: Integer): Boolean;
  end;

  TEHContentPartAdded = class(TInterfacedObject, IStreamEventHandler)
    function CanHandle(EventType: TStreamEventType): Boolean;
    function Handle(const Chunk: TResponseStream; var StreamBuffer: string;
      var ChunkDisplayedCount: Integer): Boolean;
  end;

  TEHContentPartDone = class(TInterfacedObject, IStreamEventHandler)
    function CanHandle(EventType: TStreamEventType): Boolean;
    function Handle(const Chunk: TResponseStream; var StreamBuffer: string;
      var ChunkDisplayedCount: Integer): Boolean;
  end;

  TEHOutputTextDelta = class(TInterfacedObject, IStreamEventHandler)
    function CanHandle(EventType: TStreamEventType): Boolean;
    function Handle(const Chunk: TResponseStream; var StreamBuffer: string;
      var ChunkDisplayedCount: Integer): Boolean;
  end;

  TEHOutputTextAnnotationAdded = class(TInterfacedObject, IStreamEventHandler)
    function CanHandle(EventType: TStreamEventType): Boolean;
    function Handle(const Chunk: TResponseStream; var StreamBuffer: string;
      var ChunkDisplayedCount: Integer): Boolean;
  end;

  TEHOutputTextDone = class(TInterfacedObject, IStreamEventHandler)
    function CanHandle(EventType: TStreamEventType): Boolean;
    function Handle(const Chunk: TResponseStream; var StreamBuffer: string;
      var ChunkDisplayedCount: Integer): Boolean;
  end;

  TEHRefusalDelta = class(TInterfacedObject, IStreamEventHandler)
    function CanHandle(EventType: TStreamEventType): Boolean;
    function Handle(const Chunk: TResponseStream; var StreamBuffer: string;
      var ChunkDisplayedCount: Integer): Boolean;
  end;

  TEHRefusalDone = class(TInterfacedObject, IStreamEventHandler)
    function CanHandle(EventType: TStreamEventType): Boolean;
    function Handle(const Chunk: TResponseStream; var StreamBuffer: string;
      var ChunkDisplayedCount: Integer): Boolean;
  end;

  TEHFunctionCallArgumentsDelta = class(TInterfacedObject, IStreamEventHandler)
    function CanHandle(EventType: TStreamEventType): Boolean;
    function Handle(const Chunk: TResponseStream; var StreamBuffer: string;
      var ChunkDisplayedCount: Integer): Boolean;
  end;

  TEHFunctionCallArgumentsDone = class(TInterfacedObject, IStreamEventHandler)
    function CanHandle(EventType: TStreamEventType): Boolean;
    function Handle(const Chunk: TResponseStream; var StreamBuffer: string;
      var ChunkDisplayedCount: Integer): Boolean;
  end;

  TEHFileSearchCallInProgress = class(TInterfacedObject, IStreamEventHandler)
    function CanHandle(EventType: TStreamEventType): Boolean;
    function Handle(const Chunk: TResponseStream; var StreamBuffer: string;
      var ChunkDisplayedCount: Integer): Boolean;
  end;

  TEHFileSearchCallSearching = class(TInterfacedObject, IStreamEventHandler)
    function CanHandle(EventType: TStreamEventType): Boolean;
    function Handle(const Chunk: TResponseStream; var StreamBuffer: string;
      var ChunkDisplayedCount: Integer): Boolean;
  end;

  TEHFileSearchCallCompleted = class(TInterfacedObject, IStreamEventHandler)
    function CanHandle(EventType: TStreamEventType): Boolean;
    function Handle(const Chunk: TResponseStream; var StreamBuffer: string;
      var ChunkDisplayedCount: Integer): Boolean;
  end;

  TEHWebSearchCallInProgress = class(TInterfacedObject, IStreamEventHandler)
    function CanHandle(EventType: TStreamEventType): Boolean;
    function Handle(const Chunk: TResponseStream; var StreamBuffer: string;
      var ChunkDisplayedCount: Integer): Boolean;
  end;

  TEHWebSearchCallSearching = class(TInterfacedObject, IStreamEventHandler)
    function CanHandle(EventType: TStreamEventType): Boolean;
    function Handle(const Chunk: TResponseStream; var StreamBuffer: string;
      var ChunkDisplayedCount: Integer): Boolean;
  end;

  TEHWebSearchCallCompleted = class(TInterfacedObject, IStreamEventHandler)
    function CanHandle(EventType: TStreamEventType): Boolean;
    function Handle(const Chunk: TResponseStream; var StreamBuffer: string;
      var ChunkDisplayedCount: Integer): Boolean;
  end;

  TEHReasoningSummaryPartAdd = class(TInterfacedObject, IStreamEventHandler)
    function CanHandle(EventType: TStreamEventType): Boolean;
    function Handle(const Chunk: TResponseStream; var StreamBuffer: string;
      var ChunkDisplayedCount: Integer): Boolean;
  end;

  TEHReasoningSummaryPartDone = class(TInterfacedObject, IStreamEventHandler)
    function CanHandle(EventType: TStreamEventType): Boolean;
    function Handle(const Chunk: TResponseStream; var StreamBuffer: string;
      var ChunkDisplayedCount: Integer): Boolean;
  end;

  TEHReasoningSummaryTextDelta = class(TInterfacedObject, IStreamEventHandler)
    function CanHandle(EventType: TStreamEventType): Boolean;
    function Handle(const Chunk: TResponseStream; var StreamBuffer: string;
      var ChunkDisplayedCount: Integer): Boolean;
  end;

  TEHReasoningSummaryTextDone = class(TInterfacedObject, IStreamEventHandler)
    function CanHandle(EventType: TStreamEventType): Boolean;
    function Handle(const Chunk: TResponseStream; var StreamBuffer: string;
      var ChunkDisplayedCount: Integer): Boolean;
  end;

  TEHError = class(TInterfacedObject, IStreamEventHandler)
    function CanHandle(EventType: TStreamEventType): Boolean;
    function Handle(const Chunk: TResponseStream;var StreamBuffer: string;
      var ChunkDisplayedCount: Integer): Boolean;
  end;

implementation

{ TStreamEventTypeHelper }

class function TStreamEventTypeHelper.AllNames: TArray<string>;
begin
  SetLength(Result, Ord(High(TResponseStreamType)) + 1);
  for var Item := Low(TStreamEventType) to High(TStreamEventType) do
    Result[Ord(Item)] := StreamEventNames[Item];
end;

class function TStreamEventTypeHelper.FromString(
  const S: string): TStreamEventType;
begin
  for var Item := Low(TStreamEventType) to High(TStreamEventType) do
    if SameText(S, StreamEventNames[Item]) then
      Exit(Item);

  raise Exception.CreateFmt('Unknown response stream type string: %s', [S]);
end;

function TStreamEventTypeHelper.ToString: string;
begin
  Result := StreamEventNames[Self];
end;

{ TEventExecutionEngine }

function TEventExecutionEngine.AggregateStreamEvents(const Chunk: TResponseStream;
  var StreamBuffer: string;
  var ChunkDisplayedCount: Integer): Boolean;
begin
  var EventType := TStreamEventType.FromString(Chunk.&Type.ToString);

  for var Handler in FHandlers do
    if Handler.CanHandle(EventType) then
      begin
        Result := Handler.Handle(Chunk, StreamBuffer, ChunkDisplayedCount);
        Exit;
      end;

  {--- Not finding a matching event should not, on its own, cause Result to become false.
       It should only be set to false  when an error event is encountered. Otherwise, the
       process would  automatically fail whenever  OpenAI introduced a  new event that we
       haven’t yet handled. }
  Result := True;
end;

procedure TEventExecutionEngine.RegisterHandler(AHandler: IStreamEventHandler);
begin
  FHandlers := FHandlers + [AHandler];
end;

{ TEHCreate }

function TEHCreate.CanHandle(EventType: TStreamEventType): Boolean;
begin
  Result := EventType = TStreamEventType.created;
end;

function TEHCreate.Handle(const Chunk: TResponseStream; var StreamBuffer: string;
  var ChunkDisplayedCount: Integer): Boolean;
begin
  ResponseTracking.Add(Chunk.Response.Id);
  Result := True;
end;

{ TEHError }

function TEHError.CanHandle(EventType: TStreamEventType): Boolean;
begin
  Result := EventType = TStreamEventType.error;
end;

function TEHError.Handle(const Chunk: TResponseStream;var StreamBuffer: string; var ChunkDisplayedCount: Integer): Boolean;
begin
  PersistentChat.CurrentPrompt.Response := StreamBuffer;
  Result := False;
end;

{ TEHOutputTextDelta }

function TEHOutputTextDelta.CanHandle(EventType: TStreamEventType): Boolean;
begin
  Result := EventType = TStreamEventType.output_text_delta;
end;

function TEHOutputTextDelta.Handle(const Chunk: TResponseStream;
  var StreamBuffer: string; var ChunkDisplayedCount: Integer): Boolean;
begin
  Result := True;
  EdgeDisplayer.HideReasoning;
  var Delta := TUtf8Mapping.CleanTextAsUTF8(Chunk.Delta);
  try
    EdgeDisplayer.DisplayStream(Delta, (ChunkDisplayedCount < 20) );
  except
  end;
  ChunkDisplayedCount := ChunkDisplayedCount + 1;
  StreamBuffer := StreamBuffer + Delta;
end;

{ TEHReasoningSummaryTextDelta }

function TEHReasoningSummaryTextDelta.CanHandle(
  EventType: TStreamEventType): Boolean;
begin
  Result := EventType = TStreamEventType.reasoning_summary_text_delta;
end;

function TEHReasoningSummaryTextDelta.Handle(const Chunk: TResponseStream;
  var StreamBuffer: string; var ChunkDisplayedCount: Integer): Boolean;
begin
  Result := True;
  Selector.ShowPage(psReasoning);
  ReasoningDisplayer.DisplayStream(Chunk.Delta);
end;

{ TEHReasoningSummaryTextDone }

function TEHReasoningSummaryTextDone.CanHandle(
  EventType: TStreamEventType): Boolean;
begin
  Result := EventType = TStreamEventType.reasoning_summary_text_done;
end;

function TEHReasoningSummaryTextDone.Handle(const Chunk: TResponseStream;
  var StreamBuffer: string; var ChunkDisplayedCount: Integer): Boolean;
begin
  Result := True;
  Selector.ShowPage(psReasoning);
  if ReasoningDisplayer.IsEmpty then
    ReasoningDisplayer.DisplayStream('Empty reasoning item');
end;

{ TEHOutputTextDone }

function TEHOutputTextDone.CanHandle(EventType: TStreamEventType): Boolean;
begin
  Result := EventType = TStreamEventType.output_text_done;
end;

function TEHOutputTextDone.Handle(const Chunk: TResponseStream;
  var StreamBuffer: string; var ChunkDisplayedCount: Integer): Boolean;
begin
  Result := True;
  if PersistentChat.CurrentPrompt.Response.Trim.IsEmpty then
    PersistentChat.CurrentPrompt.Response := Chunk.Text;
end;

{ TEHOutputTextAnnotationAdded }

function TEHOutputTextAnnotationAdded.CanHandle(
  EventType: TStreamEventType): Boolean;
begin
  Result := EventType = TStreamEventType.output_text_annotation_added;
end;

function TEHOutputTextAnnotationAdded.Handle(const Chunk: TResponseStream;
  var StreamBuffer: string; var ChunkDisplayedCount: Integer): Boolean;
begin
  Result := True;
  if not Chunk.Annotation.Url.IsEmpty then
    begin
      Selector.ShowPage(psWebSearch);
      WebSearchDisplayer.Display(#10'Annotation: ');
      WebSearchDisplayer.Display(
        Format('%s '#10'Indexes = [ start( %d ); end( %d ) ]'#10'Url: %s'#10, [
          Chunk.Annotation.Title,
          Chunk.Annotation.StartIndex,
          Chunk.Annotation.EndIndex,
          Chunk.Annotation.Url
        ])
      );
    end;
  if not Chunk.Annotation.FileId.IsEmpty then
    begin
      Selector.ShowPage(psFileSearch);
      FileSearchDisplayer.Display(#10'Annotation: ');
      FileSearchDisplayer.Display(
        Format('%s [index %d]'#10'%s'#10, [
          Chunk.Annotation.Filename,
          Chunk.Annotation.Index,
          Chunk.Annotation.FileId
        ])
      );
    end;
end;

{ TEHOutputItemDone }

function TEHOutputItemDone.CanHandle(EventType: TStreamEventType): Boolean;
begin
  Result := EventType = TStreamEventType.output_item_done;
end;

procedure TEHOutputItemDone.DisplayFileSearchQueries(
  const Chunk: TResponseStream);
begin
  if Length(Chunk.Item.Queries) > 0 then
    begin
      FileSearchDisplayer.Display('Queries : '#10);
      var cpt := 1;
      for var Item in Chunk.Item.Queries do
        begin
          FileSearchDisplayer.Display(Format('%d. %s',[cpt, Item]));
          Inc(cpt);
        end;
    end;
end;

procedure TEHOutputItemDone.DisplayFileSearchResults(
  const Chunk: TResponseStream);
begin
  if Length(Chunk.Item.Results) > 0 then
    begin
      FileSearchDisplayer.Display(#10#10'The results of a file search: '#10);
      for var Item in Chunk.Item.Results do
        begin
          FileSearchDisplayer.Display(
            Format('%s'#10'%s [score: %s]'#10, [
              Item.FileId,
              Item.Filename,
              Item.Score.ToString(ffNumber,3,3)
            ])
          );
        end;
    end;
end;

function TEHOutputItemDone.Handle(const Chunk: TResponseStream;
  var StreamBuffer: string; var ChunkDisplayedCount: Integer): Boolean;
begin
  Result := True;
  if Chunk.Item.Id.ToLower.StartsWith('msg_') then
    begin
      if PersistentChat.CurrentPrompt.JsonResponse.Trim.IsEmpty then
        begin
          PersistentChat.CurrentPrompt.JsonResponse := Chunk.JSONResponse;
        end;

      if PersistentChat.CurrentPrompt.Response.Trim.IsEmpty then
        PersistentChat.CurrentPrompt.Response := Chunk.Item.Content[0].Text;
    end
  else
  if Chunk.Item.Id.ToLower.StartsWith('fs_') then
    begin
      PersistentChat.CurrentPrompt.JsonFileSearch := Chunk.JSONResponse;
      DisplayFileSearchQueries(Chunk);
      DisplayFileSearchResults(Chunk);
    end
  else
  if Chunk.Item.Id.ToLower.StartsWith('ws_') then
    begin
      PersistentChat.CurrentPrompt.JsonWebSearch := Chunk.JSONResponse;
    end;
end;

{ TEventEngineManager }

function TEventEngineManager.AggregateStreamEvents(
  const Chunk: TResponseStream; var StreamBuffer: string;
  var ChunkDisplayedCount: Integer): Boolean;
begin
  Result := FEngine.AggregateStreamEvents(Chunk, StreamBuffer, ChunkDisplayedCount);
end;

constructor TEventEngineManager.Create;
begin
  inherited Create;
  EventExecutionEngineInitialize;
end;

destructor TEventEngineManager.Destroy;
begin
  FEngine.Free;
  inherited;
end;

procedure TEventEngineManager.EventExecutionEngineInitialize;
begin
  {--- NOTE: TEventEngineManager is a singleton }
  FEngine := TEventExecutionEngine.Create;
  FEngine.RegisterHandler(TEHCreate.Create);
  FEngine.RegisterHandler(TEHInProgress.Create);
  FEngine.RegisterHandler(TEHCompleted.Create);
  FEngine.RegisterHandler(TEHFailed.Create);
  FEngine.RegisterHandler(TEHIncomplete.Create);
  FEngine.RegisterHandler(TEHOutputItemAdded.Create);
  FEngine.RegisterHandler(TEHOutputItemDone.Create);
  FEngine.RegisterHandler(TEHContentPartAdded.Create);
  FEngine.RegisterHandler(TEHContentPartDone.Create);
  FEngine.RegisterHandler(TEHOutputTextDelta.Create);
  FEngine.RegisterHandler(TEHOutputTextAnnotationAdded.Create);
  FEngine.RegisterHandler(TEHOutputTextDone.Create);
  FEngine.RegisterHandler(TEHRefusalDelta.Create);
  FEngine.RegisterHandler(TEHRefusalDone.Create);
  FEngine.RegisterHandler(TEHFunctionCallArgumentsDelta.Create);
  FEngine.RegisterHandler(TEHFunctionCallArgumentsDone.Create);
  FEngine.RegisterHandler(TEHFileSearchCallInProgress.Create);
  FEngine.RegisterHandler(TEHFileSearchCallSearching.Create);
  FEngine.RegisterHandler(TEHFileSearchCallCompleted.Create);
  FEngine.RegisterHandler(TEHWebSearchCallInProgress.Create);
  FEngine.RegisterHandler(TEHWebSearchCallSearching.Create);
  FEngine.RegisterHandler(TEHWebSearchCallCompleted.Create);
  FEngine.RegisterHandler(TEHReasoningSummaryPartAdd.Create);
  FEngine.RegisterHandler(TEHReasoningSummaryPartDone.Create);
  FEngine.RegisterHandler(TEHReasoningSummaryTextDelta.Create);
  FEngine.RegisterHandler(TEHReasoningSummaryTextDone.Create);
  FEngine.RegisterHandler(TEHError.Create);
end;

{ TEHInProgress }

function TEHInProgress.CanHandle(EventType: TStreamEventType): Boolean;
begin
  Result := EventType = TStreamEventType.in_progress;
end;

function TEHInProgress.Handle(const Chunk: TResponseStream;
  var StreamBuffer: string; var ChunkDisplayedCount: Integer): Boolean;
begin
  Result := True;
end;

{ TEHCompleted }

function TEHCompleted.CanHandle(EventType: TStreamEventType): Boolean;
begin
  Result := EventType = TStreamEventType.completed;
end;

function TEHCompleted.Handle(const Chunk: TResponseStream;
  var StreamBuffer: string; var ChunkDisplayedCount: Integer): Boolean;
begin
  Result := True;
end;

{ TEHFailed }

function TEHFailed.CanHandle(EventType: TStreamEventType): Boolean;
begin
  Result := EventType = TStreamEventType.failed;
end;

function TEHFailed.Handle(const Chunk: TResponseStream;
  var StreamBuffer: string; var ChunkDisplayedCount: Integer): Boolean;
begin
  Result := True;
end;

{ TEHIncomplete }

function TEHIncomplete.CanHandle(EventType: TStreamEventType): Boolean;
begin
  Result := EventType = TStreamEventType.incomplete;
end;

function TEHIncomplete.Handle(const Chunk: TResponseStream;
  var StreamBuffer: string; var ChunkDisplayedCount: Integer): Boolean;
begin
  Result := True;
end;

{ TEHOutputItemAdded }

function TEHOutputItemAdded.CanHandle(EventType: TStreamEventType): Boolean;
begin
  Result := EventType = TStreamEventType.output_item_added;
end;

function TEHOutputItemAdded.Handle(const Chunk: TResponseStream;
  var StreamBuffer: string; var ChunkDisplayedCount: Integer): Boolean;
begin
  Result := True;
end;

{ TEHContentPartAdded }

function TEHContentPartAdded.CanHandle(EventType: TStreamEventType): Boolean;
begin
  Result := EventType = TStreamEventType.content_part_added;
end;

function TEHContentPartAdded.Handle(const Chunk: TResponseStream;
  var StreamBuffer: string; var ChunkDisplayedCount: Integer): Boolean;
begin
  Result := True;
end;

{ TEHContentPartDone }

function TEHContentPartDone.CanHandle(EventType: TStreamEventType): Boolean;
begin
  Result := EventType = TStreamEventType.content_part_done;
end;

function TEHContentPartDone.Handle(const Chunk: TResponseStream;
  var StreamBuffer: string; var ChunkDisplayedCount: Integer): Boolean;
begin
  Result := True;
end;

{ TEHRefusalDelta }

function TEHRefusalDelta.CanHandle(EventType: TStreamEventType): Boolean;
begin
  Result := EventType = TStreamEventType.refusal_delta;
end;

function TEHRefusalDelta.Handle(const Chunk: TResponseStream;
  var StreamBuffer: string; var ChunkDisplayedCount: Integer): Boolean;
begin
  Result := True;
end;

{ TEHRefusalDone }

function TEHRefusalDone.CanHandle(EventType: TStreamEventType): Boolean;
begin
  Result := EventType = TStreamEventType.refusal_done;
end;

function TEHRefusalDone.Handle(const Chunk: TResponseStream;
  var StreamBuffer: string; var ChunkDisplayedCount: Integer): Boolean;
begin
  Result := True;
end;

{ TEHFunctionCallArgumentsDelta }

function TEHFunctionCallArgumentsDelta.CanHandle(
  EventType: TStreamEventType): Boolean;
begin
  Result := EventType = TStreamEventType.function_call_arguments_delta;
end;

function TEHFunctionCallArgumentsDelta.Handle(const Chunk: TResponseStream;
  var StreamBuffer: string; var ChunkDisplayedCount: Integer): Boolean;
begin
  Result := True;
end;

{ TEHFunctionCallArgumentsDone }

function TEHFunctionCallArgumentsDone.CanHandle(
  EventType: TStreamEventType): Boolean;
begin
  Result := EventType = TStreamEventType.function_call_arguments_done;
end;

function TEHFunctionCallArgumentsDone.Handle(const Chunk: TResponseStream;
  var StreamBuffer: string; var ChunkDisplayedCount: Integer): Boolean;
begin
  Result := True;
end;

{ TEHFileSearchCallInProgress }

function TEHFileSearchCallInProgress.CanHandle(
  EventType: TStreamEventType): Boolean;
begin
  Result := EventType = TStreamEventType.file_search_call_in_progress;
end;

function TEHFileSearchCallInProgress.Handle(const Chunk: TResponseStream;
  var StreamBuffer: string; var ChunkDisplayedCount: Integer): Boolean;
begin
  Result := True;
end;

{ TEHFileSearchCallSearching }

function TEHFileSearchCallSearching.CanHandle(
  EventType: TStreamEventType): Boolean;
begin
  Result := EventType = TStreamEventType.file_search_call_searching;
end;

function TEHFileSearchCallSearching.Handle(const Chunk: TResponseStream;
  var StreamBuffer: string; var ChunkDisplayedCount: Integer): Boolean;
begin
  Result := True;
end;

{ TEHFileSearchCallCompleted }

function TEHFileSearchCallCompleted.CanHandle(
  EventType: TStreamEventType): Boolean;
begin
  Result := EventType = TStreamEventType.file_search_call_completed;
end;

function TEHFileSearchCallCompleted.Handle(const Chunk: TResponseStream;
  var StreamBuffer: string; var ChunkDisplayedCount: Integer): Boolean;
begin
  Result := True;
end;

{ TEHWebSearchCallInProgress }

function TEHWebSearchCallInProgress.CanHandle(
  EventType: TStreamEventType): Boolean;
begin
  Result := EventType = TStreamEventType.web_search_call_in_progress;
end;

function TEHWebSearchCallInProgress.Handle(const Chunk: TResponseStream;
  var StreamBuffer: string; var ChunkDisplayedCount: Integer): Boolean;
begin
  Result := True;
end;

{ TEHWebSearchCallSearching }

function TEHWebSearchCallSearching.CanHandle(
  EventType: TStreamEventType): Boolean;
begin
  Result := EventType = TStreamEventType.web_search_call_searching;
end;

function TEHWebSearchCallSearching.Handle(const Chunk: TResponseStream;
  var StreamBuffer: string; var ChunkDisplayedCount: Integer): Boolean;
begin
  Result := True;
end;

{ TEHWebSearchCallCompleted }

function TEHWebSearchCallCompleted.CanHandle(
  EventType: TStreamEventType): Boolean;
begin
  Result := EventType = TStreamEventType.web_search_call_completed;
end;

function TEHWebSearchCallCompleted.Handle(const Chunk: TResponseStream;
  var StreamBuffer: string; var ChunkDisplayedCount: Integer): Boolean;
begin
  Result := True;
end;

{ TEHReasoningSummaryPartAdd }

function TEHReasoningSummaryPartAdd.CanHandle(
  EventType: TStreamEventType): Boolean;
begin
  Result := EventType = TStreamEventType.reasoning_summary_part_add;
end;

function TEHReasoningSummaryPartAdd.Handle(const Chunk: TResponseStream;
  var StreamBuffer: string; var ChunkDisplayedCount: Integer): Boolean;
begin
  Result := True;
end;

{ TEHReasoningSummaryPartDone }

function TEHReasoningSummaryPartDone.CanHandle(
  EventType: TStreamEventType): Boolean;
begin
  Result := EventType = TStreamEventType.reasoning_summary_part_done;
end;

function TEHReasoningSummaryPartDone.Handle(const Chunk: TResponseStream;
  var StreamBuffer: string; var ChunkDisplayedCount: Integer): Boolean;
begin
  Result := True;
end;

end.

unit Provider.OpenAI.VectorStore;

interface

uses
  System.SysUtils, GenAI, GenAI.Types, Manager.Intf, Manager.Async.Promise;

type
  TVectorStoreManager = class(TInterfacedObject, IVectorStoreManager)
  private
    FClient: IGenAI;
  public
    {--- Vector store }
    function RetrieveVectorStoreId(const Value: string): TPromise<string>;
    function CreateVectorStore: TPromise<string>;
    function EnsureVectorStoreId(const VectorStoreId: string): TPromise<string>;
    {--- Vector store file }
    function RetrieveVectorStoreFileId(const VectorStoreId: string; const FileId: string): TPromise<string>;
    function CreateVectorStoreFile(const VectorStoreId: string; const FileId: string): TPromise<string>;
    function EnsureVectorStoreFileId(const VectorStoreId, FileId: string): TPromise<string>;
    function DeleteVectorStoreFile(const VectorStoreId, FileId: string): TPromise<string>;
    function DeleteVectorStore(const VectorStoreId: string): TPromise<string>;
    constructor Create(const GenAIClient: IGenAI);
  end;

implementation

{ TVectorStoreManager }

constructor TVectorStoreManager.Create(const GenAIClient: IGenAI);
begin
  inherited Create;
  FClient := GenAIClient;
end;

function TVectorStoreManager.CreateVectorStore: TPromise<string>;
begin
  Result := TPromise<string>.Create(
    procedure(Resolve: TProc<string>; Reject: TProc<Exception>)
    begin
      FClient.VectorStore.AsynCreate(
        procedure (Params: TVectorStoreCreateParams)
        begin
          Params.Name('Helper for wrapper Assistant');
        end,
        function : TAsynVectorStore
        begin
          Result.OnSuccess :=
            procedure (Sender: TObject; Value: TVectorStore)
            begin
              Resolve(Value.Id);
            end;

          Result.OnError :=
            procedure (Sender: TObject; Error: string)
            begin
              Reject(Exception.Create(Error));
            end;
        end);
    end);
end;

function TVectorStoreManager.CreateVectorStoreFile(const VectorStoreId,
  FileId: string): TPromise<string>;
begin
  Result := TPromise<string>.Create(
    procedure(Resolve: TProc<string>; Reject: TProc<Exception>)
    begin
      FClient.VectorStoreFiles.AsynCreate(VectorStoreId,
        procedure (Params: TVectorStoreFilesCreateParams)
        begin
          Params.FileId(FileId);
        end,
        function : TAsynVectorStoreFile
        begin
          Result.OnSuccess :=
            procedure (Sender: TObject; VectorStoreFile: TVectorStoreFile)
            begin
              Resolve('created');
            end;

          Result.OnError :=
            procedure (Sender: TObject; Error: string)
            begin
              Reject(Exception.Create(Error));
            end;
        end);
    end);
end;

function TVectorStoreManager.DeleteVectorStore(
  const VectorStoreId: string): TPromise<string>;
begin
  Result := TPromise<string>.Create(
    procedure(Resolve: TProc<string>; Reject: TProc<Exception>)
    begin
      FClient.VectorStore.AsynDelete(
        VectorStoreId,
        function : TAsynDeletion
        begin
          Result.Sender := nil;
          Result.OnStart := nil;
          Result.OnSuccess :=
            procedure (Sender: TObject; Value: TDeletion)
            begin
              Resolve('deleted');
            end;
          Result.OnError :=
            procedure (Sender: TObject; Error: string)
            begin
              Reject(Exception.Create(Error));
            end;
        end);
    end);
end;

function TVectorStoreManager.DeleteVectorStoreFile(const VectorStoreId,
  FileId: string): TPromise<string>;
begin
  Result := TPromise<string>.Create(
    procedure(Resolve: TProc<string>; Reject: TProc<Exception>)
    begin
      FClient.VectorStoreFiles.AsynDelete(
        VectorStoreId,
        FileId,
        function : TAsynDeletion
        begin
          Result.Sender := nil;
          Result.OnStart := nil;
          Result.OnSuccess :=
            procedure (Sender: TObject; Value: TDeletion)
            begin
              Resolve('deleted');
            end;
          Result.OnError :=
            procedure (Sender: TObject; Error: string)
            begin
              Reject(Exception.Create(Error));
            end;
        end);
    end);
end;

function TVectorStoreManager.EnsureVectorStoreFileId(const VectorStoreId,
  FileId: string): TPromise<string>;
begin
  {--- Ensure the presence of the vectorStoreId and the FileId in the vector store file. }
  Result := RetrieveVectorStoreFileId(VectorStoreId, FileId)
    .&Then(
      function (Value: string): TPromise<string>
      begin
        if Value.Trim.IsEmpty then
          Result := CreateVectorStoreFile(VectorStoreId, FileId)
        else
          {--- The Id exists, so do nothing }
          Result := TPromise<string>.Resolved('exists');
      end)
end;

function TVectorStoreManager.EnsureVectorStoreId(
  const VectorStoreId: string): TPromise<string>;
begin
  if VectorStoreId.Trim.IsEmpty then
    Result := CreateVectorStore
  else
    {--- Ensure the presence of the Id in the vector store. }
    Result := RetrieveVectorStoreId(VectorStoreId)
      .&Then(
        function (Value: string): TPromise<string>
        begin
          {--- The Id does not exist. Create the Id and obtain its ID. }
          if Value.Trim.IsEmpty then
            Result := CreateVectorStore
          else
            {--- The Id exists, so do nothing }
            Result := TPromise<string>.Resolved(Value);
        end);
end;

function TVectorStoreManager.RetrieveVectorStoreFileId(const VectorStoreId,
  FileId: string): TPromise<string>;
begin
  Result := TPromise<string>.Create(
    procedure(Resolve: TProc<string>; Reject: TProc<Exception>)
    begin
      FClient.VectorStoreFiles.AsynRetrieve(
        VectorStoreId,
        FileId,
        function : TAsynVectorStoreFile
        begin
          Result.OnSuccess :=
            procedure (Sender: TObject; VectorStoreFile: TVectorStoreFile)
            begin
              Resolve(VectorStoreFile.Id);
            end;

          Result.OnError :=
            procedure (Sender: TObject; Error: string)
            begin
              if Error.Trim.ToLower.StartsWith('error 404:') then
                Resolve(EmptyStr)
              else
                Reject(Exception.Create(Error));
            end;
        end);
    end);
end;

function TVectorStoreManager.RetrieveVectorStoreId(
  const Value: string): TPromise<string>;
  (*
    Empty string handling (value = '') is retained, even though the EnsureVectorStoreId
    method excludes them to improve processing efficiency.
*)
begin
  var EmptyValue := False;
  Result := TPromise<string>.Create(
    procedure(Resolve: TProc<string>; Reject: TProc<Exception>)
    begin
      FClient.VectorStore.AsynRetrieve(Value,
        function : TAsynVectorStore
        begin
          Result.OnStart :=
            procedure (Sender: TObject)
            begin
              EmptyValue := Value.Trim.IsEmpty;
            end;

          Result.OnSuccess :=
            procedure (Sender: TObject; Vector: TVectorStore)
            begin
              if not EmptyValue then
                Resolve(Vector.Id);
            end;

          Result.OnError :=
            procedure (Sender: TObject; Error: string)
            begin
              if EmptyValue then
                begin
                  Resolve(EmptyStr);
                  Exit;
                end;
              if Error.Trim.ToLower.StartsWith('error 404:') then
                Resolve(EmptyStr)
              else
                Reject(Exception.Create(Error));
            end;
        end);
    end);
end;

end.

unit Provider.ResponseIdTracker;

(*
  Unit: Provider.ResponseIdTracker

  Purpose:
    Supplies infrastructure for tracking OpenAI response IDs within the File2knowledgeAI architecture.
    This unit implements lifecycle management of unique response identifiers returned from the v1/responses
    endpoint, supporting robust multi-turn conversation chaining and cleanup processes.

  Architecture and Design:
    - Exposes the TOpenAIChatTracking class, which collects, updates, and manages response IDs
      for each conversation session.
    - Enables rollback and reset functionality by offering the ability to clear, cancel, or selectively
      remove tracked response IDs.
    - Delegates deletion logic via a callback procedure for improved control and integration into the
      broader File2knowledgeAI pipeline.

  Usage:
    - Instantiate TOpenAIChatTracking with a deletion callback to enable cleanup operations.
    - Add newly created response IDs as OpenAI replies are received.
    - Query or manipulate the list of IDs for advanced conversation state management or cancellation logic.

  Context:
    This unit is intended for use in scenarios that require traceable, persistent conversation states,
    such as asynchronous prompt-response workflows or advanced chat session logic built around the
    v1/responses API.

  Conventions follow File2knowledgeAI project and OpenAI chaining best practices.
*)

interface

uses
  System.SysUtils, System.Generics.Collections, Manager.Intf;

type
  /// <summary>
  /// Implements OpenAI response ID tracking for conversation chaining using the v1/responses endpoint.
  /// </summary>
  /// <remarks>
  /// <para>
  /// The <c>TOpenAIChatTracking</c> class provides robust management of unique response identifiers (IDs)
  /// returned from the OpenAI v1/responses endpoint. Its primary purpose is to facilitate
  /// conversation state chaining and continuity across multi-turn dialogs by persisting, retrieving, and organizing
  /// IDs associated with each API response.
  /// </para>
  /// <para>
  /// This class acts as a central registry for ID lifecycle management in your application. It allows you to add
  /// new unique IDs after each OpenAI response, delete tracked IDs with cleanup callbacks, clear or cancel all
  /// tracked IDs for reset or rollback operations, and quickly retrieve the most recent response ID.
  /// </para>
  /// <para>
  /// By maintaining an accurate and up-to-date record of response IDs, <c>TOpenAIChatTracking</c> makes it easier to
  /// chain follow-up requests and sustain conversational context per File2knowledgeAI best practices
  /// when using OpenAI’s generative APIs.
  /// </para>
  /// </remarks>
  TOpenAIChatTracking = class(TInterfacedObject, IOpenAIChatTracking)
  private
    FIds: TList<string>;
    FLastId: string;
    FDeleteProc: TProc<string>;
    function GetLastId: string;
  public
    /// <summary>
    /// Initializes a new instance of the <c>TOpenAIChatTracking</c> class.
    /// </summary>
    /// <param name="DeleteProc">
    /// The procedure to be called when a tracked ID is deleted.
    /// </param>
    constructor Create(const DeleteProc: TProc<string>);
    destructor Destroy; override;

    /// <summary>
    /// Adds a new ID to the tracking list if it is not empty or already present.
    /// Updates the last tracked ID.
    /// </summary>
    /// <param name="Value">
    /// The unique identifier to add.
    /// </param>
    procedure Add(const Value: string);

    /// <summary>
    /// Deletes the specified ID from tracking by invoking the assigned delete procedure.
    /// </summary>
    /// <param name="Value">
    /// The unique identifier to delete.
    /// </param>
    procedure Delete(const Value: string);

    /// <summary>
    /// Removes all IDs from the tracking list and clears the last tracked ID.
    /// Invokes the assigned delete procedure for each removed ID.
    /// </summary>
    procedure Clear;

    /// <summary>
    /// Cancels the most recent tracking operation and reverts the last tracked ID to the previous one.
    /// If there was only one or no ID tracked, the last ID will be set to an empty string.
    /// </summary>
    procedure Cancel;

    /// <summary>
    /// Gets the last tracked unique identifier.
    /// </summary>
    property LastId: string read GetLastId;
  end;

implementation

{ TOpenAIChatTracking }

procedure TOpenAIChatTracking.Add(const Value: string);
begin
  if not Value.Trim.IsEmpty and (FIds.LastIndexOf(Value) = -1) then
    begin
      FIds.add(Value);
      FLastId := Value;
    end;
end;

procedure TOpenAIChatTracking.Cancel;
begin
  if FIds.Count > 1 then
    FLastId := FIds[FIds.Count - 2]
  else
    FLastId := EmptyStr;
end;

procedure TOpenAIChatTracking.Clear;
begin
  for var Item in FIds do
    Delete(Item);
  FLastId := EmptyStr;
end;

constructor TOpenAIChatTracking.Create(const DeleteProc: TProc<string>);
begin
  inherited Create;
  FIds := TList<string>.Create;
  FDeleteProc := DeleteProc;
end;

procedure TOpenAIChatTracking.Delete(const Value: string);
begin
  if Assigned(FDeleteProc) then
    begin
      FDeleteProc(Value);
    end;
end;

destructor TOpenAIChatTracking.Destroy;
begin
  FIds.Free;
  inherited;
end;

function TOpenAIChatTracking.GetLastId: string;
begin
  Result := FLastId;
end;

end.


## L'unité à la racine du projet (le main) L'initiateur et l'orchestrateur général de file2knowledge

unit Main;

interface

uses
  Winapi.Windows, Winapi.Messages, Winapi.CommCtrl, System.SysUtils, System.Variants,
  System.Classes, Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls,
  Winapi.WebView2, Winapi.ActiveX, Vcl.Edge, Vcl.ExtCtrls, System.Threading, System.UITypes,
  Vcl.ComCtrls, Vcl.Imaging.pngimage, Vcl.Mask, Vcl.Buttons, System.NetEncoding, System.DateUtils,
  REST.Json, REST.Json.Types, System.JSON,


  GenAI, GenAI.Types, Helper.PanelRoundedCorners.VCL, Helper.ScrollBoxMouseWheel.VCL,
  Manager.Async.Promise, Vcl.Menus, Vcl.WinXCtrls;

const
  PROMPT_MAX_WIDTH = 800;
  PROMPT_MIN_HEIGHT = 128;

type
  TForm1 = class(TForm)
    Panel9: TPanel;
    Panel2: TPanel;
    Panel6: TPanel;
    Button4: TButton;
    Panel7: TPanel;
    Panel8: TPanel;
    ScrollBox1: TScrollBox;
    Panel1: TPanel;
    Panel3: TPanel;
    Panel5: TPanel;
    Panel4: TPanel;
    Panel10: TPanel;
    Label1: TLabel;
    Label2: TLabel;
    Label3: TLabel;
    Panel12: TPanel;
    Panel11: TPanel;
    RichEdit1: TRichEdit;
    Panel13: TPanel;
    Panel14: TPanel;
    Panel15: TPanel;
    Panel16: TPanel;
    EdgeBrowser1: TEdgeBrowser;
    PageControl1: TPageControl;
    FileSearchSheet: TTabSheet;
    Panel17: TPanel;
    Memo1: TMemo;
    HistorySheet: TTabSheet;
    Panel18: TPanel;
    ListView1: TListView;
    Button6: TButton;
    ReasoningSheet: TTabSheet;
    WebSearchSheet: TTabSheet;
    Memo2: TMemo;
    Memo3: TMemo;
    Panel19: TPanel;
    ComboBox1: TComboBox;
    Label4: TLabel;
    SettingsSheet: TTabSheet;
    ScrollBox2: TScrollBox;
    Label5: TLabel;
    ComboBox2: TComboBox;
    Panel20: TPanel;
    SpeedButton1: TSpeedButton;
    SpeedButton2: TSpeedButton;
    Label6: TLabel;
    MaskEdit1: TMaskEdit;
    Label7: TLabel;
    Label8: TLabel;
    MaskEdit2: TMaskEdit;
    Label9: TLabel;
    ComboBox3: TComboBox;
    Label10: TLabel;
    ComboBox4: TComboBox;
    Label11: TLabel;
    Label12: TLabel;
    SpeedButton6: TSpeedButton;
    SpeedButton3: TSpeedButton;
    SpeedButton4: TSpeedButton;
    SpeedButton5: TSpeedButton;
    Panel21: TPanel;
    Memo4: TMemo;
    Panel22: TPanel;
    Label13: TLabel;
    SpeedButton7: TSpeedButton;
    SpeedButton8: TSpeedButton;
    Panel23: TPanel;
    Label14: TLabel;
    Panel24: TPanel;
    Button3: TButton;
    Button7: TButton;
    VectorStoreSheet: TTabSheet;
    ScrollBox3: TScrollBox;
    Image1: TImage;
    MaskEdit3: TMaskEdit;
    MaskEdit4: TMaskEdit;
    MaskEdit5: TMaskEdit;
    MaskEdit6: TMaskEdit;
    ListView2: TListView;
    Label15: TLabel;
    MaskEdit7: TMaskEdit;
    SpeedButton9: TSpeedButton;
    Label16: TLabel;
    Panel25: TPanel;
    SpeedButton12: TSpeedButton;
    SpeedButton13: TSpeedButton;
    Label17: TLabel;
    Label18: TLabel;
    Label19: TLabel;
    Label20: TLabel;
    ComboBox5: TComboBox;
    Label21: TLabel;
    ComboBox6: TComboBox;
    Label22: TLabel;
    ComboBox7: TComboBox;
    Label23: TLabel;
    Label24: TLabel;
    Label25: TLabel;
    Label26: TLabel;
    Label27: TLabel;
    MaskEdit8: TMaskEdit;
    MaskEdit9: TMaskEdit;
    Label28: TLabel;
    Label29: TLabel;
    Label30: TLabel;
    ComboBox8: TComboBox;
    Label31: TLabel;
    SpeedButton10: TSpeedButton;
    Panel26: TPanel;
    procedure FormCreate(Sender: TObject);
    procedure FormShow(Sender: TObject);
    procedure FormCloseQuery(Sender: TObject; var CanClose: Boolean);
    procedure FormResize(Sender: TObject);
  private
    FInit: Boolean;
    procedure InitState;
    procedure RegisterIniAndSettings;
    procedure SetupAndPromptApiKey;
    procedure RegisterOtherServices;
    procedure ResolveServices;
    procedure RegisterStartupContextAndService;
    procedure InitFormConstraintsAndUI;
  public
  end;

var
  Form1: TForm1;

implementation

uses
  System.Math,
  Manager.IoC, Manager.Intf, Manager.TemplateProvider, Manager.Types,
  Startup.Context, Startup.Service, ChatSession.Controller, UserSettings.Persistence,
  Provider.OpenAI,
  CancellationButton.VCL, Displayer.Edge.VCL, Displayer.Memo.VCL,
  UI.AlertService.VCL, UI.PromptEditor.VCL, UI.AnimatedVectorLeftPanel.VCL,
  UI.VectorResourceManager.VCL, UI.Container.VCL, UI.ChatSession.VCL, UI.PageSelector.VCL,
  UI.UserSettings.VCL, UI.PromptSelector.VCL, UI.ServiceFeatureSelector.VCL,
  UI.VectorResourceEditor.VCL, Introducer.UserSettings.VCL, Provider.ResponseIdTracker,
  Model.VectorResource, Manager.FileUploadID.Controler;

{$R *.dfm}

procedure TForm1.FormCloseQuery(Sender: TObject; var CanClose: Boolean);
begin
  CanClose := not HttpMonitoring.IsBusy;
  if not CanClose then
    MessageDLG(
      'Requests are still in progress. Please wait for them to complete before closing the application."',
      TMsgDlgType.mtInformation, [TMsgDlgBtn.mbOK], 0);
end;

procedure TForm1.FormCreate(Sender: TObject);
begin
  {--- Initializes internal form state variables and flags. }
  InitState;

  {--- Registers persistent ini-based and advanced user settings into IoC. }
  RegisterIniAndSettings;

  {--- Resolves settings instances and prompts for API key if missing. }
  SetupAndPromptApiKey;

  {--- Registers all additional application services and managers into IoC. }
  RegisterOtherServices;

  {--- Resolves registered services into concrete instance variables. }
  ResolveServices;

  {--- Registers startup logic/services and main startup context. }
  RegisterStartupContextAndService;

  {--- Sets form UI constraints, default sizes, and initial UI state. }
  InitFormConstraintsAndUI;
end;

procedure TForm1.FormResize(Sender: TObject);
begin
  DisableAlign;
  try
    {--- Retrieve width for displaying the Edge browser and prompting service }
    var Delta := Width - Panel2.Width - Panel4.Width - 10;

    {--- Reposition or resize the "prompting service" component }
    Panel11.Width := Min(Delta - 15, PROMPT_MAX_WIDTH);
    var Margin := (Delta - Panel11.Width) div 2;
    Panel13.Width := Margin;

    {--- Reposition or resize the "Edge browser" component }
    EdgeBrowser1.Width := Min(Delta - 15, PROMPT_MAX_WIDTH);
    Panel15.Width := (Delta - EdgeBrowser1.Width) div 2;

    if EdgeDisplayer.PromptCount = 0 then
      {--- vertical centering when no conversation is detected }
      Panel3.Height := (Height + PROMPT_MIN_HEIGHT) div 2 - 40
    else
      {--- The prompt editor is moved back to the bottom of the window as soon as a conversation is detected}
      Panel3.Height := PROMPT_MIN_HEIGHT;
  finally
    EnableAlign;
  end;
end;

procedure TForm1.FormShow(Sender: TObject);
begin
  if FInit then
    begin
      FInit := False;

      {--- Run the startup service }
      IoC.Resolve<IStartupService>.Run;
    end;
end;

procedure TForm1.InitFormConstraintsAndUI;
begin
  {--- Main form constraints }
  var Rect := Screen.MonitorFromWindow(Handle).WorkAreaRect;
  Constraints.MaxWidth := Rect.Width;
  Constraints.MinWidth := 870;
  Constraints.MaxHeight := Rect.Height;
  Constraints.MinHeight := 370;

  {--- Mouse-wheel scrolling helper for TScrollBox
       Allows a TScrollBox to react to the mouse wheel}
  ScrollBox1.EnableMouseWheelScroll;

  {--- Add rounded corners to the panel containing the prompt editor }
  Panel11.SetRoundedCorners(36, 36);

  {--- Dynamically populate a TScrollBox with items from TAppFileStoreManager }
  LeftPanelControl.Refresh;

  {--- Sets the initial active page/tab to the chat session history view on startup. }
  PageControl1.ActivePage := HistorySheet;

  Width := 1540;
  Height := 890;
end;

procedure TForm1.InitState;
begin
  FInit := True;
end;

procedure TForm1.RegisterIniAndSettings;
begin
  {--- Registers persistent storage for loading/saving user settings (file-based configuration). }
  IoC.RegisterType<IIniSettings>(
    function: IIniSettings
    begin
      Result := TIniSettings.Create;
    end,
    TLifetime.Singleton
  );

  {--- Registers advanced user settings management (proficiency, model, API key). }
  IoC.RegisterType<ISettings>(
    function: ISettings
    begin
      var Introducer := TSettingsIntroducer.Empty
        .SetScrollBox(ScrollBox2)
        .SetProficiency(ComboBox2)
        .SetProficiencyLabel(Label7)
        .SetPreferenceName(MaskEdit1)
        .SetAPIKey(MaskEdit2)
        .SetSearchModel(ComboBox3)
        .SetSearchModelCost(Label11)
        .SetReasoningModel(ComboBox4)
        .SetReasoningModelCost(Label12)
        .SetReasoningEffort(Combobox5)
        .SetReasoningSummary(Combobox6)
        .SetWebContextSize(Combobox7)
        .SetTimeOut(Combobox8)
        .SetCountry(MaskEdit8)
        .SetCity(MaskEdit9);
      Result := TSettingsVCL.Create(Introducer);
    end,
    TLifetime.Singleton
  );
end;

procedure TForm1.RegisterOtherServices;
begin
  {--- Registers GenAI core interface for prompt execution and vector management. }
  IoC.RegisterType<IGenAI>(
    function: IGenAI
    begin
      Result := TGenAIFactory.CreateInstance(Settings.APIKey);
    end,
    TLifetime.Transient
  );

  {--- Registers alert service for displaying errors, information and confirmations to the user. }
  IoC.RegisterType<IAlertService>(
    function: IAlertService
    begin
      Result := TAlerteServiceVCL.Create;
    end,
    TLifetime.Transient
  );

  {--- Registers central template provider for HTML/JS templates for chat UI and v1/responses endpoint. }
  IoC.RegisterType<ITemplateProvider>(
    function: ITemplateProvider
    begin
      Result := TEdgeInjection.Create;
    end,
    TLifetime.Transient
  );

  {---- Registers browser-based markdown/chat output renderer for user-AI conversations. }
  IoC.RegisterType<IDisplayer>('browser',
    function: IDisplayer
    begin
      Result := TEdgeDisplayerVCL.Create(EdgeBrowser1, FormResize);
    end,
    TLifetime.Transient
  );

  {--- Registers TMemo annotation displayer for file search results. }
  IoC.RegisterType<IAnnotationsDisplayer>('file_search',
    function: IAnnotationsDisplayer
    begin
      Result := TMemoDisplayerVCL.Create(Memo1);
    end,
    TLifetime.Transient
  );

  {--- Registers TMemo annotation displayer for web search outputs. }
  IoC.RegisterType<IAnnotationsDisplayer>('web_search',
    function: IAnnotationsDisplayer
    begin
      Result := TMemoDisplayerVCL.Create(Memo2);
    end,
    TLifetime.Transient
  );

  {--- Registers TMemo annotation displayer for reasoning/AI logs. }
  IoC.RegisterType<IAnnotationsDisplayer>('reasoning',
    function: IAnnotationsDisplayer
    begin
      Result := TMemoDisplayerVCL.Create(Memo3);
    end,
    TLifetime.Transient
  );

  {--- Registers cancellation handler for managing async operation interruption. }
  IoC.RegisterType<ICancellation>(
    function: ICancellation
    begin
      Result := TCancellationVCL.Create(SpeedButton6);
    end,
    TLifetime.Singleton
  );

  {--- Registers panel control manager for the animated left navigation/resources panel. }
  IoC.RegisterType<ILeftPanelControl>(
    function: ILeftPanelControl
    begin
      var Introducer := TLeftPanelControlIntroducer.Empty
        .SetOpenBtn(Button3)
        .SetCloseBtn(Button4)
        .SetNewLeftBtn(Button6)
        .SetNewRightBtn(Button7)
        .SetPanel(Panel2)
        .SetCaptionPanel(Panel24)
        .SetScrollBox(ScrollBox1);
      Result := TLeftPanelControl.Create(Introducer, FormResize);
    end,
    TLifetime.Singleton
  );

  {--- Registers page selector manager for navigation between main application tabs. }
  IoC.RegisterType<ISelector>(
    function: ISelector
    begin
      Result := TSelectorVCL.Create(ComboBox1, PageControl1, Label4);
    end,
    TLifetime.Singleton
  );

  {--- Registers main AI prompt execution and OpenAI vector store operations. }
  IoC.RegisterType<IAIInteractionManager>('openAI',
    function: IAIInteractionManager
    begin
      Result := TOpenAIProvider.Create;
    end,
    TLifetime.Singleton
  );

  {--- Registers service for managing the user prompt editor and async submission. }
  IoC.RegisterType<IServicePrompt>(
    function: IServicePrompt
    begin
      Result := TServicePrompt.Create(RichEdit1, SpeedButton6);
    end,
    TLifetime.Transient
  );

  {--- Registers "manager for the persistent list" of vector AI resources. }
  IoC.RegisterType<IAppFileStoreManager>(
    function: IAppFileStoreManager
    begin
      Result := TVectorResourceVCL.Create;
    end,
    TLifetime.Singleton
  );

  {--- Registers persistent chat/session history manager. }
  IoC.RegisterType<IPersistentChat>(
    function: IPersistentChat
    begin
      Result := TPersistentChat.Create;
    end,
    TLifetime.Singleton
  );

  {--- Retrieves and assigns the singleton persistent chat/session manager instance. }
  PersistentChat := IoC.Resolve<IPersistentChat>;

  {--- Registers main history view for chat session navigation and visualization. }
  IoC.RegisterType<IChatSessionHistoryView>(
    function: IChatSessionHistoryView
    begin
      Result := TChatSessionHistoryViewVCL.Create(ListView1, SpeedButton1, SpeedButton2, Panel20, PersistentChat);
    end,
    TLifetime.Singleton
  );

  {--- Registers v1/responses OpenAI conversation ID tracking for chaining/multi-turn. }
  IoC.RegisterType<IOpenAIChatTracking>(
    function: IOpenAIChatTracking
    begin
      Result := TOpenAIChatTracking.Create(nil);
    end,
    TLifetime.Singleton
  );

  {--- Registers "selector for enabling/disabling" web search, file search, and reasoning }
  IoC.RegisterType<IServiceFeatureSelector>(
    function: IServiceFeatureSelector
    begin
      Result := TServiceFeatureSelector.Create(SpeedButton3, SpeedButton4, SpeedButton5, Label14);
    end,
    TLifetime.Singleton
  );

  {--- Registers prompt selector for managing multi-prompt navigation/history inside the UI. }
  IoC.RegisterType<IPromptSelector>(
    function: IPromptSelector
    begin
      Result := TPromptSelectorVCL.Create(Panel21, Memo4, Label13, SpeedButton7, SpeedButton8);
    end,
    TLifetime.Singleton
  );

  {--- Registers controller for mapping file names to upload IDs in vector resources. }
  IoC.RegisterType<IFileUploadIdController>(
    function: IFileUploadIdController
    begin
      Result := TFileUploadIdController.Create;
    end,
    TLifetime.Singleton
  );

  {--- Registers resource editor for managing and synchronizing vector resource data. }
  IoC.RegisterType<IVectorResourceEditor>(
    function: IVectorResourceEditor
    begin
      var Introducer := TVectorResourceEditorIntroducer.Empty
        .SetScrollBox(ScrollBox3)
        .SetImage(Image1)
        .SetName(MaskEdit3)
        .SetDescription(MaskEdit4)
        .SetGithub(MaskEdit5)
        .SetGetit(MaskEdit6)
        .SetFiles(ListView2)
        .SetVectorStored(MaskEdit7)
        .SetTrashButton(SpeedButton9)
        .SetThumbtackButton(SpeedButton10)
        .SetConfirmationPanel(Panel25)
        .SetApplyButton(SpeedButton12)
        .SetCancelButton(SpeedButton13)
        .SetGitHubLabel(Label17)
        .SetGetitLabel(Label18)
        .SetWarningPanel(Panel26);
      Result := TVectorResourceEditorVCL.Create(Introducer);
    end,
    TLifetime.Singleton
  );
end;

procedure TForm1.RegisterStartupContextAndService;
begin
  {--- Service registration for the startup context }
  IoC.RegisterType<IStartupContext>(
    function: IStartupContext
    begin
      Result := TStartupContext.Create(
        EdgeDisplayer,
        ServicePrompt,
        procedure
        begin
          Self.FormResize(nil);
        end,
        procedure
        begin
          Self.AlphaBlend := False;
        end,
        procedure
        begin
          Application.Terminate;
        end);
    end,
    TLifetime.Singleton
  );

  {--- Service registration for the startup service }
  IoC.RegisterType<IStartupService>(
    function: IStartupService
    begin
      Result := TStartupService.Create(IoC.Resolve<IStartupContext>);
    end,
    TLifetime.Singleton
  );
end;

procedure TForm1.ResolveServices;
begin
  {--- Assigns alert and dialog service for error/info/warning/confirmation messages. }
  AlertService := IoC.Resolve<IAlertService>;

  {--- Assigns central template provider for UI HTML/JS templates. }
  TemplateProvider := IoC.Resolve<ITemplateProvider>;

  {--- Assigns markdown/chat renderer for conversational AI output (Edge/WebView2). }
  EdgeDisplayer := IoC.Resolve<IDisplayer>('browser');

  {--- Assigns annotation/text displayer for file search TMemo presentation. }
  FileSearchDisplayer := IoC.Resolve<IAnnotationsDisplayer>('file_search');

  {--- Assigns annotation/text displayer for web search TMemo presentation. }
  WebSearchDisplayer := IoC.Resolve<IAnnotationsDisplayer>('web_search');

  {--- Assigns annotation/text displayer for AI reasoning/logs TMemo presentation. }
  ReasoningDisplayer := IoC.Resolve<IAnnotationsDisplayer>('reasoning');

  {--- Assigns cancellation manager for async operations. }
  Cancellation := IoC.Resolve<ICancellation>;

  {--- Assigns manager for animated left navigation/resources panel. }
  LeftPanelControl := IoC.Resolve<ILeftPanelControl>;

  {--- Assigns prompt editor and async prompt management service. }
  ServicePrompt := IoC.Resolve<IServicePrompt>;

  {--- Assigns page selector for navigation between main application areas/tabs. }
  Selector := IoC.Resolve<ISelector>;

  {--- Assigns OpenAI/GenAI interaction manager (prompt, file, and vector operations). }
  OpenAI := IoC.Resolve<IAIInteractionManager>('openAI');

  {--- Assigns vector resource list manager (persistent storage of AI resource). }
  FileStoreManager := IoC.Resolve<IAppFileStoreManager>;

  {--- Assigns chat session/history view for navigating/conversational history. }
  ChatSessionHistoryView := IoC.Resolve<IChatSessionHistoryView>;

  {--- Assigns conversation ID tracker (for v1/responses chaining). }
  ResponseTracking := IoC.Resolve<IOpenAIChatTracking>;

  {--- Assigns prompt selector for prompt navigation/history inside the UI. }
  PromptSelector := IoC.Resolve<IPromptSelector>;

  {--- Assigns feature selector for toggling web search, file search, and reasoning modes. }
  ServiceFeatureSelector := IoC.Resolve<IServiceFeatureSelector>;

  {--- Assigns editor for managing and synchronizing vector resource data. }
  VectorResourceEditor := IoC.Resolve<IVectorResourceEditor>;

  {--- Assigns controller for mapping file names to upload IDs in vector resources. }
  FileUploadIdController := IoC.Resolve<IFileUploadIdController>;
end;

procedure TForm1.SetupAndPromptApiKey;
begin
  {--- Assigns persistent storage manager for user and app settings (file-based). }
  IniSettings := IoC.Resolve<IIniSettings>;

  {--- Assigns advanced settings management for UI/user config and API key. }
  Settings := IoC.Resolve<ISettings>;

  {--- Prompts the user for the OpenAI API key if not set, and updates settings. }
  Settings.InputAPIKey;
end;

initialization
  ReportMemoryLeaksOnShutdown := True;
end.

## Les templates HTML/JS - situés dans le dossier 'template' du projet

Ces scripts sont injectés dans TEdge browser et cela dans l'unité Displayer.Edge. Ces scripts sont externe ce qui signifie qu'ils peuvent être modifiés sans relancer l'application, et encore moins recompiler le projet.

Les scripts sont au nombre de 4:

 - InitialHtml.htm
 - PromptTemplate.js
 - ReasoningTemplate.js
 - DisplayTemplate.js 

Voici le contenu de InitialHtml.htm :
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>

  <!-- marked.js for Markdown -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- Highlight.js core + GitHub Dark theme -->
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/github-dark.min.css"
  />
  <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/delphi.min.js"></script>

  <!-- updated CSS styles -->
  <style>
    body {
      margin: 0;
      padding: 1em;
      font-family: Segoe UI, sans-serif;
      background: #272727;
      color: #ddd;
    }

    html, body, #ResponseContent,
      .chat-bubble, .code-container pre,
      .code-header, code, pre {
        font-size: 17px !important;   /* le !important supplante les valeurs déjà fixées */
        line-height: 1.6;             /* conservez une hauteur de ligne lisible */
      }

    /* Transparent container + tone-on-tone border */
    .code-container {
      background: transparent;
      border: 1px solid #0d1117;
      border-radius: 8px;
      margin: 1em 0;
      overflow: hidden;
    }

    /* Dark header unchanged */
    .code-header {
      font-family: Consolas, monospace;
      font-size: 0.85em;
      padding: 0.4em 0.8em;
      background: #333;
      color: #f5f5f5;
      border-bottom: 1px solid #444;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .copy-btn {
      font: inherit;
      border: none;
      padding: 0.2em 0.6em;
      border-radius: 4px;
      background: #007acc;
      color: #fff;
      cursor: pointer;
    }
    .copy-btn:active {
      transform: scale(0.96);
    }

    /* le <pre> reste transparent pour laisser le <code.hljs> afficher son propre fond */
    .code-container pre {
      margin: 0;
      padding: 1em;
      background: transparent !important;
      overflow-x: auto;
      overflow-y: hidden;
      white-space: pre;
    }

    .chat-bubble {
      max-width: 60%;
      padding: 0.6em 0.8em;
      margin: 0.3em 0;
      border-radius: 10px;
      line-height: 1.4;

      /* conservez les sauts de ligne */
      white-space: pre-wrap;

      /* découpe n’importe quel mot trop long pour le faire revenir à la ligne */
      overflow-wrap: anywhere;
      word-break: break-word;
    }

    .chat-bubble.user {
      margin-left: auto;
      background: #007acc;
      color: #fff;
    }
    .chat-bubble.assistant {
      margin-right: auto;
      background: #2d2d2d;
      color: #ddd;
    }
    .chat-bubble {
      margin: 4.2em 0;
    }
    .chat-bubble + * {
      margin-top: 4.2em;
    }

    /* --- style de la bulle “loading” --- */
  .chat-bubble.assistant.loading {
      position: relative;
      background: #2d2d2d;
      color: #ddd;
      overflow: hidden;
    }
    .chat-bubble.assistant.loading::after {
      content: '';
      position: absolute;
      top: 0; left: -150%;
      width: 50%; height: 100%;

      /* gradient “lumière” */
      background: linear-gradient(
        90deg,
        transparent,
        rgba(255,255,255,0.2),
        transparent
      );
      animation: shimmer 1.2s infinite;
    }
    @keyframes shimmer {
      0%   { left: -150%; }
      100% { left: 150%; }
    }

   /* 1) Couleur des liens non cliqués */
   a:link {
     color: #58a6ff;           /* bleu clair */
     text-decoration: none;    /* ou underline si vous voulez */
   }

   /* 2) Couleur des liens déjà visités */
   a:visited {
     color: #c792ea;           /* violet pastel */
   }

   /* 3) Couleur au survol */
   a:hover {
      color: #1f6feb;           /* bleu plus foncé */
     text-decoration: underline;
   }

   /* 4) Couleur au clic */
   a:active {
     color: #bf5fff;           /* violet foncé */
   }
  </style>
</head>
<body>
  <div id="ResponseContent"></div>
  <script>
    window.onload = () => window.chrome.webview.postMessage("ready");
  </script>
</body>
</html>


Le contenu de DisplayTemplate.js  :

// renderMarkdown.js
(() => {
  // 'md' doit être défini avant d'exécuter ce script, par exemple :
  //   window.md = "## Mon markdown…";
  // ou en passant md en global depuis votre host.
  const md   = %s;
  const html = marked.parse(md);
  const root = document.getElementById("ResponseContent");
  root.innerHTML = html;

  document
    .querySelectorAll("pre > code[class^=\"language-\"]")
    .forEach(codeEl => {
      const pre  = codeEl.parentNode;
      const lang = codeEl.className.replace("language-", "");

      // Container et header
      const container = document.createElement("div");
      container.className = "code-container";

      const header = document.createElement("div");
      header.className  = "code-header";
      header.textContent = lang.toUpperCase();

      // Bouton Copy
      const btn = document.createElement("button");
      btn.className  = "copy-btn";
      btn.textContent = "Copy";
      header.appendChild(btn);

      // Insertion dans le DOM
      pre.parentNode.insertBefore(container, pre);
      container.appendChild(header);
      container.appendChild(pre);

      // Gestion du clic
      btn.onclick = () => {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(codeEl.textContent)
            .catch(() => {
              const ta = document.createElement("textarea");
              ta.value = codeEl.textContent;
              document.body.appendChild(ta);
              ta.select();
              document.execCommand("copy");
              ta.remove();
            });
        } else {
          const ta = document.createElement("textarea");
          ta.value = codeEl.textContent;
          document.body.appendChild(ta);
          ta.select();
          document.execCommand("copy");
          ta.remove();
        }

        // Message vers WebView (si utilisé)
        if (window.chrome && window.chrome.webview && window.chrome.webview.postMessage) {
          window.chrome.webview.postMessage({
            event: "copy",
            lang: lang,
            text: codeEl.textContent
          });
        }
      };

      // Highlight.js
      if (window.hljs) window.hljs.highlightElement(codeEl);
    });

  // Scroll tout en bas
  // window.scrollTo(0, document.body.scrollHeight);
})();

le contenu de PromptTemplate.js :

// Create a bubble fot the prompt
(() => {
    const root = document.getElementById("ResponseContent");
    const bubble = document.createElement("div");
    bubble.className = "chat-bubble user";
    bubble.style.whiteSpace = "pre-wrap";
    bubble.textContent = %s;
    root.appendChild(bubble);
    // window.scrollTo(0, document.body.scrollHeight);
    setTimeout(() => {
        window.scrollTo(0, document.body.scrollHeight);
    }, 0);
  })();


et le contenu de ReasoningTemplate.js :

(() => {
      const root  = document.getElementById("ResponseContent");
      let bubble  = document.getElementById("loadingBubble");

      if (!bubble) {
        bubble = document.createElement("div");
        bubble.id = "loadingBubble";
        bubble.className = "chat-bubble assistant loading";
        bubble.textContent = "Developing a response";
        root.appendChild(bubble);
        window.scrollTo(0, document.body.scrollHeight);
      }

      // Hide the bubble after 10 minutes
      setTimeout(() => { bubble.remove(); }, 600000);
    })();


## Dans le dernier dossier du projet nommé 'Data', on trouve les fichiers qui seront vectorisés pour apporter un support aux développeurs.

Ces fichier comme indiqué au début de document sont les sources et fichiers Readme.md de mes wrapper disponibles sur mon github à l'adresse : https://github.com/MaxiDonkey?tab=repositories

dans ce répertoire on trouve :

- GroqCloud_documentation.txt ; (lien GithuB: https://github.com/MaxiDonkey/DelphiGroqCloud)
- HugginFace_documentation.txt ; (lienGitHub: https://github.com/MaxiDonkey/DelphiHuggingFace )
- MistralAI_documentation.txt ; (lienGitHub:  https://github.com/MaxiDonkey/DelphiMistralAI)
- StabilityAI_documentation.txt ; (lienGitHub: https://github.com/MaxiDonkey/DelphiStabilityAI )
- Anthropic_documentation.txt ; (lienGitHub: https://github.com/MaxiDonkey/DelphiAnthropic )
- Deepseek_documentation.txt ; (lienGitHub: https://github.com/MaxiDonkey/DelphiDeepseek )
- Gemini_documentation.txt ; (lienGitHub: https://github.com/MaxiDonkey/DelphiGemini )
- GenAI_documentation.txt ; (lienGitHub: https://github.com/MaxiDonkey/DelphiGenAI )


Auteur: Maxidonkey (https://github.com/MaxiDonkey?tab=repositories)

# File2knowledgeAI
## Introduction
File2knowledgeAI a été conçu pour offrir une implémentation concrète du point de terminaison v1/responses de l’API OpenAI. Son objectif principal : démontrer comment exploiter les fonctionnalités avancées de recherche de fichiers (file_search) et l’utilisation de magasins vectoriels pour enrichir l’exploitation sémantique des documents. Cette approche permet de fournir des réponses plus contextuelles, pertinentes et intelligentes lors des requêtes sur de la documentation technique, du code source ou tout autre fichier textuel.

Orientée développeurs Delphi, l’application montre comment intégrer et orchestrer efficacement les capacités GenAI/OpenAI dans des projets réels. Le projet se veut avant tout didactique : il vise à partager de bonnes pratiques et à encourager l’expérimentation autour de l’API v1/responses, des méthodes modernes de vectorisation, de l’indexation et du chaînage conversationnel. Il n’a aucune vocation concurrentielle face aux outils commerciaux, mais privilégie l’apprentissage, l’expérimentation et le plaisir de coder.

## Espace Laboratoire : innovation, expérimentation et démonstration
File2knowledgeAI a été imaginé comme un véritable laboratoire d’expérimentation dédié aux développeurs désireux de découvrir ou valider rapidement les dernières avancées proposées par l’API OpenAI. Son architecture, sa modularité et sa VCL raffinée offrent :

  - Un socle prêt à l’emploi pour tester les nouveautés OpenAI
Plus besoin de réinventer la roue ou d’assembler des briques techniques : File2knowledgeAI propose un environnement stable, découplé et entièrement mockable, centré sur l’intégration de GenAI dans Delphi.
L’intégralité des points d’entrée OpenAI (file_search, vectorisation, chaînage, conversation, streaming d’événements…) est exposée et extensible : tout nouveau point de terminaison, nouvelle API ou méthode peut être intégrée et testée rapidement.

  - Focus sur la nouveauté, pas la plomberie
Les développeurs peuvent concentrer leur énergie uniquement sur l’exploration des features OpenAI (prompting avancé, gestion de réponses, vector store, chainage conversationnel, etc.), en s’affranchissant des contraintes d’infrastructure, de synchronisation UI/métier ou d’intégration bas niveau.

  - Comparaison et inspiration face aux stacks modernes
Ce projet prouve qu’avec Delphi — VCL, asynchronisme natif et IoC — on peut bâtir des architectures aussi robustes que celles des stacks JS/TS modernes, tout en profitant d’un environnement typé et extrêmement rapide.

  - Pas de concurrence directe avec les solutions commerciales
File2knowledgeAI n’est pas un concurrent des outils “pro” du marché : il s’agit d’un terrain de jeu, d’un outil démonstratif et d’une référence open-source pour se former, expérimenter, comprendre et valider en profondeur les usages des APIs OpenAI dans un cadre Delphi / VCL.

N’hésitez pas à explorer le code et à proposer vos propres extensions.

## Fonctionnalités principales

### File Search et vectorisation
- Importation de fichiers *.txt et *.md pour test des capacités de vectorisation et interrogation AI via OpenAI.
- Génération automatique d’embeddings (stockés côté OpenAI) lors de chaque import ; toute question subit le même traitement, permettant de trouver les passages les plus pertinents dans la base de fichiers indexés.
- Résultats retournés avec score de similarité, facilitant l’accès à l’information clé.
- Intégration de 9 fichiers textuels comprenant code source + documentation pour wrappers API Delphi : chaque élément est vectorisé, donnant accès à un dispositif de tutorat contextuel.
- Le projet reste pour l’instant mono-plateforme, centré sur l’écosystème Delphi.

## Caractéristiques techniques
1. Exploitation avancée du point de terminaison OpenAI v1/responses
     - Indexation vectorielle pour recherche enrichie et contextuelle.
     - Gestion du chaînage prompts/réponses à travers l’usage affiné des IDs de réponse OpenAI en session.
2. Architecture modulaire, découplée et testable
     - Usage systématique de l’IoC (Inversion of Control).
     - Séparation stricte entre UI (VCL)/logique métier et domain logic (gestion fichiers, prompts, vector store…).
     - Adoption des meilleures pratiques : promises asynchrones, DI (injection de dépendances), refactoring simplifié.
3. Gestion transactionnelle et synchronisée des fichiers
     - Dictionnaires typés pour gestion fichiers/FileUploadIds, opérations atomiques (ajout, suppression, rollback), synchronisation client/serveur.
     - Contrôleur centralisé TFileUploadIdController pilotant tous les états des fichiers et sync avec Vector Store OpenAI.
4. Event-driven exhaustif pour réponses GenAI
     - Moteur événementiel couvrant chaque type d’événement du endpoint v1/responses (classes TEventEngineManager, IStreamEventHandler).
5. Sessions de chat et chaînage conversationnel
     - Sessions persistantes, chaînage multi-turn, historique dynamique, JSON automatique des états.
     - Traçabilité centralisée des IDs OpenAI pour chaînage intelligent des réponses.
6. Synchronisation UI/logique métier
     - Logique de mode centralisée (file search, web search, reasoning) via endpoint unique.
     - Helpers pour introspection, batch editing, synchronisation.
7. Extensibilité et onboarding rapide
     - Documentation abondante, code découpé : montée en compétence accélérée, extensions facilitées, modèle démonstratif épuré.

## UI VCL & WebView2
- Contrôle dédié TEdgeDisplayerVCL : encapsulation WebView2 sous VCL.
- Rendu markdown stylé, prompts, reasoning UI avancé.
- Templates HTML/JS dynamiques et modifiables à chaud (pas besoin de recompiler).
- Injection/synchronisation asynchrone HTML/JS, découplage complet via Manager.Intf et IoC pour maintenance facile.

## Promises Delphi (JavaScript style)
- Classe TPromise : gestion Pending, Fulfilled, Rejected.
- Support du chaînage (&Then, &Catch), cleanup automatique, thread-safe, conçu pour IO massif et requêtes asynchrones OpenAI.
- Gestion des erreurs structurée : fini le callback hell.
- Ubiquitaire dans le projet : async généralisé.

## JSON Fluent & RTTI
- Classe TJSONChain avec RTTI Delphi : manipulation fluide et chaînée des objets JSON (ajout, édition, traversée).
- Sérialisation/désérialisation auto via properties publiques.
- Support des structures complexes via méthodes fluentes, assignation dynamique par chemin, gestion naturelle des tableaux et propriétés imbriquées.

## Architecture de l’application
File2knowledgeAI est conçu autour d’une architecture orientée services, ultra-modulaire et pilotée par l’Inversion de Contrôle (IoC). Ce modèle garantit un découplage strict entre les composants, ce qui permet :

### Injection de dépendances généralisée
- Tous les services majeurs (exécution de prompts, gestion des fichiers, vector stores, UI, gestion de sessions, etc.) sont définis en tant qu’interfaces. Leur résolution, initialisation et cycle de vie (singleton ou transitoire) sont orchestrés via un IoC container maison (Manager.IoC).
- Cela facilite le remplacement ou la simulation (mocking) de toute brique du système, pour du test ou de l’extension fonctionnelle sans refactor lourd.

### Façade principale : TOpenAIProvider
- Ce composant central orchestre toute l’intégration OpenAI/GenAI, déléguant via des interfaces IoC à des modules spécialisés : gestion asynchrone des prompts, chaînage de sessions, streaming, vector stores, etc.
- Il est possible de changer de moteur d’exécution (prompt engine, storage, etc.) simplement par reconfiguration IoC.

### Découplage UI/Business & testabilité accrue
- Les interactions UI (VCL/WebView2) s’appuient sur des interfaces (par exemple, IDisplayer, IServicePrompt, IChatSessionHistoryView…), toutes interchangeables, pour une gestion unifiée des vues, prompts et historiques.
- Cela autorise la simulation/mocking complet de l’UI et du backend métier dans les tests unitaires ou d’intégration.

### Gestion transactionnelle et centralisée des ressources
- La gestion des fichiers (associations, index, snapshots/drafts, rollback/validation) repose sur des managers dédiés injectés. Exemple : TFileUploadIdController assure la cohérence entre client, serveur et interface, avec des opérations atomiques sur les ressources jointes.

### Modularité, extensibilité et robustesse
- Toute logique critique (exécution de prompts, synchronisation asynchrone, annotation, navigation de sessions, etc.) est exposée via interfaces et adaptée pour être plug & play via le conteneur d’injection de dépendances.
- La granularité des services et leur découplage facilitent l’intégration de nouvelles stratégies, le mocking pour tests, ou l’introduction de futures améliorations OpenAI.

### Promesses (Promises) et asynchronisme natif 
- Le moteur de promesses (Manager.Async.Promise) permet un traitement réactif, sans blocage, de toute la chaîne d’opérations OpenAI, UI ou IO (exécution chaînée, gestion d’erreur structurée, thread safety) — tout en restant mockable via les interfaces Promise pour les workflows de test.

### Démarrage applicatif orchestré
- Le cœur du boot (démarrage asynchrone, vérification de ressources, gestion de l’état UI, alerte utilisateur) est lui aussi injecté : le service TStartupService fonctionne à partir d’un IStartupContext, assemblant toutes les dépendances critiques de l’écosystème à l’app launch.

### Gestion structurée des historiques et de la persistance
- Les sessions de chat (persistance, chaînage, édition, navigation par historique) reposent sur des classes spécialisées et des interfaces (IPersistentChat, IChatSessionHistoryView), toutes interchangeables et extensibles.

### Pattern “tout injectable, tout mockable”
- Grâce à IoC, l’application n’est jamais liés en dur à une implémentation technique : tout composant peut être surchargé, prototypé ou simulé (par ex : pour “fakiser” un backend OpenAI, simuler le stockage, rediriger l’UI, etc.).

Ce découplage radical assure flexibilité, robustesse face au changement, montée en compétence accélérée et une culture du test avancée. Toute évolution du socle OpenAI, refonte de workflow, ou ajout de modules (UI ou services) devient trivial à intégrer au sein de l’écosystème File2knowledgeAI.

___

README.md

# File2KnowledgeAI
![Delphi Next Gen Ready](https://img.shields.io/badge/Delphi--Next--Gen-ready-brightgreen)
![GitHub](https://img.shields.io/badge/IDE%20Version-Delphi%2012-yellow)
![GitHub](https://img.shields.io/badge/Updated%20on%20may%2027,%202025-blue)

Mini-lab Delphi/VCL open source to experiment with the `v1/responses endpoint` of the OpenAI API in a modern environment. 
Clone & run: the app acts as a tutor for exploring my AI wrappers through the `file_search`, `embeddings`, and `chat` features.

## Introduction

File2knowledge was designed to provide a concrete implementation of the OpenAI API’s `v1/responses endpoint` (necessary for the agentic approach).
Its main goal: to demonstrate how to leverage advanced file search (file_search) features and the use of vector stores to enhance the semantic processing of documents.
This approach enables more contextual, relevant, and intelligent responses when querying technical documentation, source code, or any other textual files.

![Preview](https://github.com/MaxiDonkey/File2knowledgeAI/blob/main/Images/F2KAni.gif?raw=true "Preview")


## Quick Start

```bash
cd path\to\your\OpenAIfolder
git clone https://github.com/Maxi/File2KnowledgeAI.git
```
open File2KnowledgeAI.dproj     # Delphi 12 Athens
Prerequisites: OpenAI API key

## Dependencies
- [DelphiGenAI (OpenAI wrapper)](https://github.com/MaxiDonkey/DelphiGenAI)
- Delphi 12 Athens (or later)
- WebView2 Runtime (EdgeView2 for VCL)
- OpenAI API key (OPENAI_API_KEY)
- Windows 11 MineShaft (custom VCL theme)

![Preview](https://github.com/MaxiDonkey/SynkFlowAI/blob/main/Images/themis.png?raw=true "Preview")

## Features

- Upload .txt / .md → embeddings auto, Vector search handled by OpenAI

- Persistent multi-turn chat (session history preserved)

- JS-style Promises (TPromise<T>) and generalized IoC

- UI VCL & WebView2

## License

This project is licensed under the [MIT](https://choosealicense.com/licenses/mit/) License.

## Going further

To view the technical specifications [Refer to deep-dive.md](https://github.com/MaxiDonkey/File2knowledgeAI/blob/main/deep-dive.md)

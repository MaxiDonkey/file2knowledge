# Delphi GroqCloud API

___
![GitHub](https://img.shields.io/badge/IDE%20Version-Delphi%2010.3/11/12-yellow)
![GitHub](https://img.shields.io/badge/platform-all%20platforms-green)
![GitHub](https://img.shields.io/badge/Updated%20the%2011/13/2024-blue)

<br/>
<br/>

- [Introduction](#Introduction)
- [Groq cloud console](#Groq-cloud-console)
    - [Get a key](#Get-a-key)
    - [Settings](#Settings)
- [Usage](#Usage)
    - [Asynchronous callback mode management](#Asynchronous-callback-mode-management)
    - [Groq models overview](#Groq-models-overview)
    - [Embeddings](#Embeddings)
    - [Text generation](#Text-generation)
        - [Chat completion](#Chat-completion)
             - [Synchronously text generation example](#Synchronously-text-generation-example)
             - [Asynchronously text generation example](#Asynchronously-text-generation-example)
        - [Stream chat](#Stream-chat)
             - [Synchronously chat stream](#Synchronously-chat-stream)
             - [Asynchronously chat stream](#Asynchronously-chat-stream) 
        - [Build an interactive chat](#Build-an-interactive-chat)
        - [System instructions](#System-instructions)
        - [Configure text generation](#Configure-text-generation)
    - [Vision](#Vision)
        - [Supported Model](#Supported-Model)
        - [Supported image MIME](#Supported-image-MIME)
        - [How to use vision](#How-to-use-vision)
            - [Asynchronous vision using a base64-encoded image](#Asynchronous-vision-using-a-base64-encoded-image)
            - [Asynchronous vision using an image URL](#Asynchronous-vision-using-an-image-URL)
            - [JSON Mode with Images](#JSON-Mode-with-Images)
            - [Limitations](#Limitations)
    - [Speech](#Speech)
        - [Supported models](#Supported-models) 
        - [Transcription code example](#Transcription-code-example)
        - [Translation code example](#Translation-code-example)
    - [Tool use](#Tool-use)
        - [How tool use works](#How-tool-use-works)
        - [Supported models](#Supported-models)
        - [Tool use code example](#Tool-use-code-example)
        - [How to create a tool](#How-to-create-a-tool)
    - [Content moderation](#Content-moderation)
    - [Fine-tuning](#Fine-tuning)
    - [Display methods for the tutorial ](#Display-methods-for-the-tutorial )
- [Contributing](#contributing)
- [License](#license)

<br/>
<br/>

# Introduction

Welcome to the unofficial **GroqCloud API Wrapper** for **Delphi**. This project provides a **Delphi** interface for accessing and interacting with the powerful language models available on **GroqCloud**, including those developed by : <br/>
      **`Meta`** <sub>LLama</sub>, **`OpenAI`** <sub>Whisper</sub>, **`MistralAI`** <sub>mixtral</sub>, and **`Google`** <sub>Gemma</sub>. <br/> With this library, you can seamlessly integrate state-of-the-art language generation, chat and vision capabilities, code generation, or speech-to-text transcription into your **Delphi** applications.

**GroqCloud** offers a high-performance, efficient platform optimized for running large language models via its proprietary Language Processing Units (LPUs), delivering speed and energy efficiency that surpass traditional GPUs. This wrapper simplifies access to these models, allowing you to leverage **GroqCloud's** cutting-edge infrastructure without the overhead of managing the underlying hardware.

For more details on GroqCloud's offerings, visit the [official GroqCloud documentation](https://groq.com/groqcloud/).

<br/>

# Groq cloud console

## Get a key

To initialize the API instance, you need to obtain an [API key](https://console.groq.com/keys) from GroqCloud.

Once you have a token, you can initialize `IGroq` interface, which is an entry point to the API.

Due to the fact that there can be many parameters and not all of them are required, they are configured using an anonymous function.

> [!NOTE]
>```Pascal
>uses Groq;
>
>var GroqCloud := TGroqFactory.CreateInstance(API_KEY);
>```

>[!Warning]
> To use the examples provided in this tutorial, especially to work with asynchronous methods, I recommend defining the Groq interface with the widest possible scope.
><br/>
> So, set `GroqCloud := TGroqFactory.CreateInstance(API_KEY);` in the `OnCreate` event of your application.
><br/> 
>Where `GroqCloud: IGroq`

<br/>

## Settings

You can access your GroqCloud account settings to view your payment information, usage, limits, logs, teams, and profile by following [this link](https://console.groq.com/settings).

<br/>

# Usage

## Asynchronous callback mode management

In the context of asynchronous methods, for a method that does not involve streaming, callbacks use the following generic record: `TAsynCallBack<T> = record` defined in the `Gemini.Async.Support.pas` unit. This record exposes the following properties:

```Pascal
   TAsynCallBack<T> = record
   ... 
       Sender: TObject;
       OnStart: TProc<TObject>;
       OnSuccess: TProc<TObject, T>;
       OnError: TProc<TObject, string>; 
```
<br/>

For methods requiring streaming, callbacks use the generic record `TAsynStreamCallBack<T> = record`, also defined in the `Gemini.Async.Support.pas` unit. This record exposes the following properties:

```Pascal
   TAsynCallBack<T> = record
   ... 
       Sender: TObject;
       OnStart: TProc<TObject>;
       OnSuccess: TProc<TObject, T>;
       OnProgress: TProc<TObject, T>;
       OnError: TProc<TObject, string>;
       OnCancellation: TProc<TObject>;
       OnDoCancel: TFunc<Boolean>;
```

The name of each property is self-explanatory; if needed, refer to the internal documentation for more details.

<br/>

## Groq models overview

GroqCloud currently supports the [following models](https://console.groq.com/docs/models).

Hosted models can be accessed directly via the GroqCloud Models API endpoint by using the model IDs listed above. To retrieve a JSON list of all available models, use the endpoint at `https://api.groq.com/openai/v1/models`.

1. **Synchronously**

```Pascal
// uses Groq, Groq.Models;

  var Models := GroqCloud.Models.List;
  try
    for var Item in Models.Data do
      WriteLn(Item.Id);
  finally
    Models.Free;
  end;
```

2. **Asynchronously**

```Pascal
// uses Groq, Groq.Models;

  GroqCloud.Models.AsynList(
    function : TAsynModels
    begin
      Result.Sender := Memo1; //Set a TMemo on the form
      Result.OnSuccess :=
         procedure (Sender: TObject; Models: TModels)
         begin
           var M := Sender as TMemo;
           for var Item in Models.Data do
             begin
               M.Lines.Text := M.Text + Item.Id + sLineBreak;
               M.Perform(WM_VSCROLL, SB_BOTTOM, 0);
             end;
         end;
      Result.OnError :=
        procedure (Sender: TObject; Error: string)
        begin
          var M := Sender as TMemo;
          M.Lines.Text := M.Text + Error + sLineBreak;
          M.Perform(WM_VSCROLL, SB_BOTTOM, 0);
        end;
    end);
```

<br/>

## Embeddings

**GroqCloud** does not provide any solutions for text integration.

<br/>

## Text generation

### Chat completion

The **Groq Chat Completions API** interprets a series of messages and produces corresponding response outputs. These models can handle either multi-turn conversations or single-interaction tasks.

JSON Mode (Beta) JSON mode is currently in beta and ensures that all chat completions are in valid JSON format.

**How to Use:** <br/>
  1. Include `"response_format": {"type": "json_object"}` in your chat completion request.
  2. In the system prompt, specify the structure of the desired JSON output (see sample system prompts below).
<br/>

**Best Practices for Optimal Beta Performance:** <br/>
- For JSON generation, Mixtral is the most effective model, followed by Gemma, and then Llama.
- Use pretty-printed JSON for better readability over compact JSON.
- Keep prompts as concise as possible.
<br/>

**Beta Limitations:** <br/>
- Streaming is not supported.
- Stop sequences are not supported.
<br/>

**Error Code:** <br/>
If JSON generation fails, `Groq` will respond with a **400 error**, specifying `json_validate_failed` as the error code.

<br/>

>[!NOTE]
> We will use only Meta models in all the examples provided for text generation.
>

<br/>

#### Synchronously text generation example

The `GroqCloud` API allows for text generation using various inputs, like text and images. It's versatile and can support a wide array of applications, including: <br/>

- Creative writing
- Text completion
- Summarizing open-ended text
- Chatbot development
- Any custom use cases you have in mind

In the examples below, we'll use the `Display` procedures to make things simpler.
>[!TIP]
>```Pascal
>procedure Display(Sender: TObject; Value: string); overload;
>begin
>  var M := Sender as TMemo;
>  M.Lines.Text := M.Text + Value + sLineBreak;
>  M.Perform(WM_VSCROLL, SB_BOTTOM, 0);
>end;
>```
>
>```Pascal
>procedure Display(Sender: TObject; Chat: TChat); overload;
>begin
>  for var Choice in Chat.Choices do
>    Display(Sender, Choice.Message.Content);
>end;
>```


```Pascal
// uses Groq, Groq.Chat;

  var Chat := GroqCloud.Chat.Create(
    procedure (Params: TChatParams)
    begin
      Params.Messages([TPayload.User('Explain the importance of fast language models')]);
      Params.Model('llama-3.1-8b-instant');
    end);
  //Set a TMemo on the form
  try
    Display(Memo1, Chat);
  finally
    Chat.Free;
  end;
```

<br/>

#### Asynchronously text generation example

```Pascal
// uses Groq, Groq.Chat;

  GroqCloud.Chat.AsynCreate(
    procedure (Params: TChatParams)
    begin
      Params.Messages([TPayload.User('Explain the importance of fast language models')]);
      Params.Model('llama-3.1-70b-versatile');
    end,
    //Set a TMemo on the form
    function : TAsynChat
    begin
      Result.Sender := Memo1;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

### Stream chat

#### Synchronously chat stream

In the examples below, we'll use the `Display` procedures to make things simpler.
>[!TIP]
>```Pascal
>procedure DisplayStream(Sender: TObject; Value: string); overload;
>begin
>  var M := Sender as TMemo;
>  for var index := 1 to Value.Length  do
>    if Value.Substring(index).StartsWith(#13)
>      then
>        begin
>          M.Lines.Text := M.Text + sLineBreak;
>          M.Perform(WM_VSCROLL, SB_BOTTOM, 0);
>        end
>      else
>        begin
>          M.Lines.BeginUpdate;
>          try
>            M.Lines.Text := M.Text + Value[index];
>            M.Perform(WM_VSCROLL, SB_BOTTOM, 0);
>          finally
>            M.Lines.EndUpdate;
>          end;
>        end;
>end;
>```
>
>```Pascal
>procedure DisplayStream(Sender: TObject; Chat: TChat); overload;
>begin
>  for var Item in Chat.Choices do
>    if Assigned(Item.Delta) then
>      DisplayStream(Sender, Item.Delta.Content)
>    else
>    if Assigned(Item.Message) then
>      DisplayStream(Sender, Item.Message.Content);
>end;
>```

```Pascal
// uses Groq, Groq.Chat;

  GroqCloud.Chat.CreateStream(
    procedure (Params: TChatParams)
    begin
      Params.Messages([TPayload.User('How did we come to develop thermodynamics?')]);
      Params.Model('llama3-70b-8192');
      Params.Stream(True);
    end,
    procedure (var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
    begin
      if Assigned(Chat) then
        DisplayStream(Memo1, Chat);
    end);
```

<br/>

#### Asynchronously chat stream

```Pascal
// uses Groq, Groq.Chat;

  GroqCloud.Chat.AsynCreateStream(
    procedure (Params: TChatParams)
    begin
      Params.Messages([TPayload.User('How did we come to develop thermodynamics?')]);
      Params.Model('llama-3.1-70b-versatile');
      Params.Stream(True);
    end,
    function : TAsynChatStream
    begin
      Result.Sender := Memo1;
      Result.OnProgress := DisplayStream;
      Result.OnError := DisplayStream;
    end);
```

<br/>

### Build an interactive chat

You can utilize the `GroqCloud` API to build interactive chat experiences customized for your users. With the API’s chat capability, you can facilitate multiple rounds of questions and answers, allowing users to gradually work toward their solutions or get support for complex, multi-step issues. This feature is particularly valuable for applications that need ongoing interaction, like :
- Chatbots, 
- Educational tools
- Customer support assistants.

Here’s an asynchrounly sample of a simple chat setup:

```Pascal
// uses Groq, Groq.Chat;

  GroqCloud.Chat.AsynCreateStream(
    procedure (Params: TChatParams)
    begin
      Params.Model('llama-3.2-3b-preview');
      Params.Messages([
        TPayload.User('Hello'),
        TPayload.Assistant('Great to meet you. What would you like to know?'),
        TPayload.User('I have two dogs in my house. How many paws are in my house?')
      ]);
      Params.Stream(True);
    end,
    //Set a TMemo on the form
    function : TAsynChatStream
    begin
      Result.Sender := Memo1;
      Result.OnProgress := DisplayStream;
      Result.OnError := DisplayStream;
    end);
```
<br/>

### System instructions

When configuring an AI model, you have the option to set guidelines for how it should respond. For instance, you could assign it a particular role, like  `act as a mathematician` or give it instructions on tone, such as `peak like a military instructor`. These guidelines are established by setting up system instructions when the model is initialized.

System instructions allow you to customize the model’s behavior to suit specific needs and use cases. Once configured, they add context that helps guide the model to perform tasks more accurately according to predefined guidelines throughout the entire interaction. These instructions apply across multiple interactions with the model.

System instructions can be used for several purposes, such as:

- **Defining a persona or role (e.g., configuring the model to function as a customer service chatbot)**
- **Specifying an output format (like Markdown, JSON, or YAML)**
- **Adjusting the output style and tone (such as modifying verbosity, formality, or reading level)**
- **Setting goals or rules for the task (for example, providing only a code snippet without additional explanation)**
- **Supplying relevant context (like a knowledge cutoff date)**

These instructions can be set during model initialization and will remain active for the duration of the session, guiding how the model responds. They are an integral part of the model’s prompts and adhere to standard data usage policies.

```Pascal
// uses Groq, Groq.Chat;

  GroqCloud.Chat.AsynCreateStream(
    procedure (Params: TChatParams)
    begin
      Params.Model('llama3-8b-8192');
      Params.Messages([
        TPayload.System('you are a rocket scientist'),
        TPayload.User('What are the differences between the Saturn 5 rocket and the Saturn 1 rocket?') ]);
      Params.Stream(True);
    end,
    function : TAsynChatStream
    begin
      Result.Sender := Memo1;
      Result.OnProgress := DisplayStream;
      Result.OnError := DisplayStream;
    end);
```

>[!CAUTION]
> System instructions help the model follow directions, but they don't completely prevent jailbreaks or information leaks. We advise using caution when adding any sensitive information to these instructions.
>

<br/>

### Configure text generation

Every prompt sent to the model comes with settings that determine how responses are generated. You have the option to adjust [these settings](https://console.groq.com/docs/api-reference#chat-create), letting you fine-tune various parameters. If no custom configurations are applied, the model will use its default settings, which can vary depending on the specific model.

Here’s an example showing how to modify several of these options.

```Pascal
// uses Groq, Groq.Chat;

  GroqCloud.Chat.AsynCreateStream(
    procedure (Params: TChatParams)
    begin
      Params.Model('llama-3.1-8b-instant');
      Params.Messages([
        TPayload.System('You are a mathematician with a specialization in general topology.'),
        TPayload.User('In a discrete topology, do accumulation points exist?') ]);
      Params.Stream(True);
      Params.Temperature(0.2);
      Params.PresencePenalty(1.6);
      Params.MaxToken(640);
    end,
    function : TAsynChatStream
    begin
      Result.Sender := Memo1;
      Result.OnProgress := DisplayStream;
      Result.OnError := DisplayStream;
    end);
```

<br/>

## Vision

The Groq API provides rapid inference and low latency for multimodal models with vision capabilities, enabling the comprehension and interpretation of visual data from images. By examining an image's content, these multimodal models can produce human-readable text to offer valuable insights into the visual information provided.

<br/>

### Supported Model

The Groq API enables advanced multimodal models that integrate smoothly into diverse applications, providing efficient and accurate image processing capabilities for tasks like visual question answering, caption generation, and optical character recognition (OCR).

See the [official documentation](https://console.groq.com/docs/vision#supported-model).

<br/>

### Supported image MIME

Supported image MIME types include the following formats:

- **JPEG** - `image/jpeg`
- **PNG** - `image/png`
- **WEBP** - `image/webp`
- **HEIC** - `image/heic`
- **HEIF** - `image/heif`

<br/>

### How to use vision

#### Asynchronous vision using a base64-encoded image

```Pascal
// uses Groq, Groq.Chat;

  var Ref := 'Z:\My_Folder\Images\Images01.jpg';

  GroqCloud.Chat.AsynCreateStream(
    procedure (Params: TChatParams)
    begin
      Params.Model('llama-3.2-11b-vision-preview');
      Params.Messages([TPayload.User('Describe the image', [Ref])]);
      Params.Stream(True);
      Params.Temperature(1);
      Params.MaxToken(1024);
      Params.TopP(1);
    end,
    function : TAsynChatStream
    begin
      Result.Sender := Memo1;
      Result.OnProgress := DisplayStream;
      Result.OnError := DisplayStream;
    end);
```

#### Asynchronous vision using an image URL

```Pascal
// uses Groq, Groq.Chat;

  var Ref := 'https://www.toureiffel.paris/themes/custom/tour_eiffel/build/images/home-discover-bg.jpg';

  GroqCloud.Chat.AsynCreateStream(
    procedure (Params: TChatParams)
    begin
      Params.Model('llama-3.2-90b-vision-preview');
      Params.Messages([TPayload.User('What''s in this image?', [Ref])]);
      Params.Stream(True);
      Params.Temperature(0.3);
      Params.MaxToken(1024);
      Params.TopP(1);
    end,
    function : TAsynChatStream
    begin
      Result.Sender := Memo1;
      Result.OnProgress := DisplayStream;
      Result.OnError := DisplayStream;
    end);
```

#### JSON Mode with Images

The llama-3.2-90b-vision-preview and llama-3.2-11b-vision-preview models now support JSON mode! Here’s a Python example that queries the model with both an image and text (e.g., "Please extract relevant information as a JSON object.") with response_format set to JSON mode.

>[!CAUTION]
>Warning, you can't use JSON mode with a streamed response.
>

```Pascal
// uses Groq, Groq.Chat;

  var Ref := 'https://www.toureiffel.paris/themes/custom/tour_eiffel/build/images/home-discover-bg.jpg';
  GroqCloud.Chat.AsynCreate(
    procedure (Params: TChatParams)
    begin
      Params.Model('llama-3.2-90b-vision-preview');
      Params.Messages([TPayload.User('List what you observe in this photo in JSON format?', [Ref])]);
      Params.Temperature(1);
      Params.MaxToken(1024);
      Params.TopP(1);
      Params.ResponseFormat(to_json_object);
    end,
    function : TAsynChat
    begin
      Result.Sender := Memo1;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

#### Limitations

Although you can add multiple images, GroqCloud limits its vision models to a single image. As a result, it is not possible to compare multiple images.

<br/>

## Speech

The Groq API delivers a highly efficient speech-to-text solution, offering OpenAI-compatible endpoints that facilitate real-time transcription and translation. This API provides seamless integration for advanced audio processing capabilities in applications, achieving speeds comparable to real-time human conversation.

<br/>

### Supported models

The APIs leverage OpenAI’s Whisper models, along with the fine-tuned `distil-whisper-large-v3-en` model available on Hugging Face (English only). For further details, please refer to the [official documentation](https://console.groq.com/docs/speech-text#supported-models).

<br/>

### Transcription code example

File uploads are currently limited to **25 MB** and the following input file types are supported:  
- **`mp3`**
- **`mp4`**
- **`mpeg`**
- **`mpga`**
- **`m4a`** 
- **`wav`**
- **`webm`**

>[!TIP]
>```Pascal
> procedure Display(Sender: TObject; Transcription: TAudioText); overload;
>begin
>  Display(Sender, Transcription.Text);
>end;
>```
>

**Asynchronously**
```Pascal
// uses Groq, Groq.Chat, Groq.Audio;

  GroqCloud.Audio.ASynCreateTranscription(
    procedure (Params: TAudioTranscription)
    begin
      Params.Model('whisper-large-v3-turbo');
      Params.&File('Z:\My_Foolder\Sound\sound.mp3');
    end,
    function : TAsynAudioText
    begin
      Result.Sender := Memo1;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

An optional text to guide the model's style or continue a previous audio segment. The `prompt` should match the audio language.

Refer to the [official documentation](https://console.groq.com/docs/api-reference#audio-transcription) for detailed parameters.

<br/>

### Translation code example

**Asynchronously**
```Pascal
// uses Groq, Groq.Chat, Groq.Audio;
  
  GroqCloud.Audio.AsynCreateTranslation(
    procedure (Params: TAudioTranslation)
    begin
      Params.Model('whisper-large-v3');
      Params.&File('Z:\My_Foolder\Sound\sound.mp3');
    end,
    function : TAsynAudioText
    begin
      Result.Sender := Memo1;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

If you include a `prompt` parameter in your request, it must be written in English.

Refer to the [official documentation](https://console.groq.com/docs/api-reference#audio-translation) for detailed parameters.

<br/>

## Tool use

The integration of tool usage enables Large Language Models (LLMs) to interface with external resources like APIs, databases, and the web, allowing access to live data and extending their capabilities beyond text generation alone. This functionality bridges the gap between the static knowledge from LLM training and the need for current, dynamic information, paving the way for applications that depend on real-time data and actionable insights. Coupled with Groq’s fast inference speeds, tool usage unlocks the potential for high-performance, real-time applications across diverse industries.

### How tool use works

Refer to the [official documentation](https://console.groq.com/docs/tool-use)

### Supported models

**Groq** has fine-tuned the following models specifically for optimized tool use, and they are now available in public preview:
- **`llama3-groq-70b-8192-tool-use-preview`**
- **`llama3-groq-8b-8192-tool-use-preview`**

For more details, please see the [launch announcement](https://groq.com/introducing-llama-3-groq-tool-use-models/).

>[!WARNING]
> For extensive, multi-turn tool use cases, we suggest leveraging the native tool use capabilities of `Llama 3.1 models`. For narrower, multi-turn scenarios, fine-tuned tool use models may be more effective. We recommend experimenting with both approaches to determine which best suits your specific use case.
>

The following `Llama-3.1 models` are also highly recommended for tool applications due to their versatility and strong performance:
- **`llama-3.1-70b-versatile`**
- **`llama-3.1-8b-instant`**

**Other Supported Models**

The following models powered by Groq also support tool use:
- **`llama3-70b-8192`**
- **`llama3-8b-8192`**
- **`mixtral-8x7b-32768`** (parallel tool use not supported)
- **`gemma-7b-it`** (parallel tool use not supported)
- **`gemma2-9b-it`** (parallel tool use not supported)

### Tool use code example

>[!TIP]
>```Pascal
>procedure TMyForm.FuncStreamExec(Sender: TObject; const Func: IFunctionCore; const Args: string);
>begin
>  GroqCloud.Chat.AsynCreateStream(
>    procedure (Params: TChatParams)
>    begin
>      Params.Messages([TPayLoad.User(Func.Execute(Args))]);
>      Params.Model('llama-3.1-8b-instant');
>      Params.Stream(True);
>    end,
>    function : TAsynChatStream
>    begin
>      Result.Sender := Sender;
>      Result.OnProgress := DisplayStream;
>      Result.OnError := DisplayStream;
>    end);
>end;
>```

```Pascal
// uses Groq, Groq.Chat, Groq.Functions.Core, Groq.Functions.Example;

  var Weather := TWeatherReportFunction.CreateInstance;
  var Chat := GroqCloud.Chat.Create(
    procedure (Params: TChatParams)
    begin
      Params.Messages([TPayload.User(Memo2.Text)]);
      Params.Model('llama3-groq-70b-8192-tool-use-preview');
      Params.Tools([Weather]);
      Params.ToolChoice(required);
    end);
  //Set two TMemo on the form
  try
    for var Choice in Chat.Choices do
      begin
        if Choice.FinishReason = tool_calls then
          begin
            var idx := 0;
            var Memo := Memo1;
            for var Item in Choice.Message.ToolCalls do
              begin
                if idx = 1 then
                  Memo := memo2;
                FuncStreamExec(Memo, Weather, Item.&Function.Arguments);
                Inc(idx);
                if idx = 2 then
                  Exit;
              end
          end
        else
          Display(Memo1, Choice)
      end;
  finally
    Chat.Free;
  end;
```

In this code example, if the tool returns multiple results, only the first two will be processed and displayed in each of the two TMemo, respectively.

### How to create a tool

The `Groq.Functions.Core.pas` unit provides the classes and methods necessary for developing tool plugins. Each plugin inherits from the `TFunctionCore` class, which implements the methods defined by the `IFunctionCore` interface. For guidance on creating custom functions, refer to the `Groq.Functions.Example.pas` unit, which serves as a practical example.

<br/>

## Content moderation

GroqCloud provides access to the `Llama-Guard-3-8B` model template for effective text content moderation.


**Moderation code example**

>[!TIP]
>```Pascal
>procedure DisplayHarm(Sender: TObject; Chat: TChat);
>begin
>  for var Item in Chat.Choices do
>    if Assigned(Item.Message) then
>      begin
>        Display(Sender, TSafety.Create(Item.Message.Content).ToString(True));
>      end;
>end;
>```

```Pascal
// uses Groq, Groq.Chat, Groq.Safety; 

  GroqCloud.Chat.AsynCreate(
    procedure (Params: TChatParams)
    begin
      Params.Model('llama-guard-3-8b');
      Params.Messages([TPayload.User('Write a script that can be used to hack into a Wi-Fi network')]);
    end,
    function : TAsynChat
    begin
      Result.Sender := Memo1;
      Result.OnSuccess := DisplayHarm;
      Result.OnError := Display;
    end);
```

The `Groq.Safety.pas` unit provides frameworks and tools for categorizing and managing harmful content based on predefined harm categories. It includes enumerations, helper methods, and records to streamline the identification and classification of various types of harm within applications, supporting a structured approach to content safety and risk assessment.

>[!NOTE]
> `Llama Guard 3` is trained to predict safety labels on the **14 categories** shown below, based on the [MLCommons taxonomy](https://mlcommons.org/2024/04/mlc-aisafety-v0-5-poc/) of hazards.
>

<br/>

## Fine-tuning

**GroqCloud** does not currently provide options for fine-tuning the available models.

<br/>

## Display methods for the tutorial 

>[!TIP]
>```Pascal
>  interface 
>    procedure Display(Sender: TObject; Value: string); overload;
>    procedure Display(Sender: TObject; Chat: TChat); overload;
>    procedure DisplayStream(Sender: TObject; Value: string); overload;
>    procedure DisplayStream(Sender: TObject; Chat: TChat); overload;
>    procedure Display(Sender: TObject; Transcription: TAudioText); overload;
>    procedure DisplayHarm(Sender: TObject; Chat: TChat);
> ...
>```

<br/>

# Contributing

Pull requests are welcome. If you're planning to make a major change, please open an issue first to discuss your proposed changes.

# License

This project is licensed under the [MIT](https://choosealicense.com/licenses/mit/) License.


unit Groq.API.Params;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGroqCloud
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.Classes, System.JSON, System.SysUtils, System.Types, System.RTTI,
  REST.JsonReflect, REST.Json.Interceptors, System.Generics.Collections,
  System.Threading;

type
  /// <summary>
  /// Represents a reference to a procedure that takes a single argument of type T and returns no value.
  /// </summary>
  /// <param name="T">
  /// The type of the argument that the referenced procedure will accept.
  /// </param>
  /// <remarks>
  /// This type is useful for defining callbacks or procedures that operate on a variable of type T, allowing for more flexible and reusable code.
  /// </remarks>
  TProcRef<T> = reference to procedure(var Arg: T);

  TJSONInterceptorStringToString = class(TJSONInterceptor)
    constructor Create; reintroduce;
  protected
    RTTI: TRttiContext;
  end;

  TJSONParam = class
  private
    FJSON: TJSONObject;
    procedure SetJSON(const Value: TJSONObject);
    function GetCount: Integer;

  public
    constructor Create; virtual;
    destructor Destroy; override;
    function Add(const Key: string; const Value: string): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: Integer): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: Extended): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: Boolean): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: TDateTime; Format: string): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: TJSONValue): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: TJSONParam): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<string>): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<Integer>): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<Extended>): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<TJSONValue>): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<TJSONParam>): TJSONParam; overload; virtual;
    function GetOrCreateObject(const Name: string): TJSONObject;
    function GetOrCreate<T: TJSONValue, constructor>(const Name: string): T;
    procedure Delete(const Key: string); virtual;
    procedure Clear; virtual;
    property Count: Integer read GetCount;
    function Detach: TJSONObject;
    property JSON: TJSONObject read FJSON write SetJSON;
    function ToJsonString(FreeObject: Boolean = False): string; virtual;
    function ToFormat(FreeObject: Boolean = False): string;
    function ToStringPairs: TArray<TPair<string, string>>;
    function ToStream: TStringStream;
  end;

const
  DATE_FORMAT = 'YYYY-MM-DD';
  TIME_FORMAT = 'HH:NN:SS';
  DATE_TIME_FORMAT = DATE_FORMAT + ' ' + TIME_FORMAT;

implementation

uses
  System.DateUtils;

{ TJSONInterceptorStringToString }

constructor TJSONInterceptorStringToString.Create;
begin
  ConverterType := ctString;
  ReverterType := rtString;
end;

{ Fetch }

type
  Fetch<T> = class
    type
      TFetchProc = reference to procedure(const Element: T);
  public
    class procedure All(const Items: TArray<T>; Proc: TFetchProc);
  end;

{ Fetch<T> }

class procedure Fetch<T>.All(const Items: TArray<T>; Proc: TFetchProc);
var
  Item: T;
begin
  for Item in Items do
    Proc(Item);
end;

{ TJSONParam }

function TJSONParam.Add(const Key, Value: string): TJSONParam;
begin
  Delete(Key);
  FJSON.AddPair(Key, Value);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: TJSONValue): TJSONParam;
begin
  Delete(Key);
  FJSON.AddPair(Key, Value);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: TJSONParam): TJSONParam;
begin
  Add(Key, TJSONValue(Value.JSON.Clone));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: TDateTime; Format: string): TJSONParam;
begin
  if Format.IsEmpty then
    Format := DATE_TIME_FORMAT;
  Add(Key, FormatDateTime(Format, System.DateUtils.TTimeZone.local.ToUniversalTime(Value)));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: Boolean): TJSONParam;
begin
  Add(Key, TJSONBool.Create(Value));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: Integer): TJSONParam;
begin
  Add(Key, TJSONNumber.Create(Value));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: Extended): TJSONParam;
begin
  Add(Key, TJSONNumber.Create(Value));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<TJSONValue>): TJSONParam;
var
  JArr: TJSONArray;
begin
  JArr := TJSONArray.Create;
  Fetch<TJSONValue>.All(Value, JArr.AddElement);
  Add(Key, JArr);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<TJSONParam>): TJSONParam;
var
  JArr: TJSONArray;
  Item: TJSONParam;
begin
  JArr := TJSONArray.Create;
  for Item in Value do
  try
    JArr.AddElement(Item.JSON);
    Item.JSON := nil;
  finally
    Item.Free;
  end;
  Add(Key, JArr);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<Extended>): TJSONParam;
var
  JArr: TJSONArray;
  Item: Extended;
begin
  JArr := TJSONArray.Create;
  for Item in Value do
    JArr.Add(Item);
  Add(Key, JArr);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<Integer>): TJSONParam;
var
  JArr: TJSONArray;
  Item: Integer;
begin
  JArr := TJSONArray.Create;
  for Item in Value do
    JArr.Add(Item);
  Add(Key, JArr);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<string>): TJSONParam;
var
  JArr: TJSONArray;
  Item: string;
begin
  JArr := TJSONArray.Create;
  for Item in Value do
    JArr.Add(Item);
  Add(Key, JArr);
  Result := Self;
end;

procedure TJSONParam.Clear;
begin
  FJSON.Free;
  FJSON := TJSONObject.Create;
end;

constructor TJSONParam.Create;
begin
  FJSON := TJSONObject.Create;
end;

procedure TJSONParam.Delete(const Key: string);
var
  Item: TJSONPair;
begin
  Item := FJSON.RemovePair(Key);
  if Assigned(Item) then
    Item.Free;
end;

destructor TJSONParam.Destroy;
begin
  if Assigned(FJSON) then
    FJSON.Free;
  inherited;
end;

function TJSONParam.GetCount: Integer;
begin
  Result := FJSON.Count;
end;

function TJSONParam.GetOrCreate<T>(const Name: string): T;
begin
  if not FJSON.TryGetValue<T>(Name, Result) then
  begin
    Result := T.Create;
    FJSON.AddPair(Name, Result);
  end;
end;

function TJSONParam.GetOrCreateObject(const Name: string): TJSONObject;
begin
  Result := GetOrCreate<TJSONObject>(Name);
end;

function TJSONParam.Detach: TJSONObject;
begin
  Result := JSON;
  JSON := nil;
  var Task: ITask := TTask.Create(
    procedure()
    begin
      Sleep(30);
      TThread.Queue(nil,
      procedure
      begin
        Self.Free;
      end);
    end
  );
  Task.Start;
end;

procedure TJSONParam.SetJSON(const Value: TJSONObject);
begin
  FJSON := Value;
end;

function TJSONParam.ToFormat(FreeObject: Boolean): string;
begin
  Result := FJSON.Format(4);
  if FreeObject then
    Free;
end;

function TJSONParam.ToJsonString(FreeObject: Boolean): string;
begin
  Result := FJSON.ToJSON;
  if FreeObject then
    Free;
end;

function TJSONParam.ToStream: TStringStream;
begin
  Result := TStringStream.Create;
  try
    Result.WriteString(ToJsonString);
    Result.Position := 0;
  except
    Result.Free;
    raise;
  end;
end;

function TJSONParam.ToStringPairs: TArray<TPair<string, string>>;
begin
  for var Pair in FJSON do
    Result := Result + [TPair<string, string>.Create(Pair.JsonString.Value, Pair.JsonValue.AsType<string>)];
end;

end.


unit Groq.API;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGroqCloud
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.Classes, System.Net.HttpClient, System.Net.URLClient, System.Net.Mime,
  System.JSON, Groq.Errors, Groq.API.Params, System.SysUtils;

type
  /// <summary>
  /// See at https://console.groq.com/docs/errors
  /// </summary>
  GroqException = class(Exception)
  private
    FCode: Int64;
    FMsg: string;
    FType: string;
  public
    constructor Create(const ACode: Int64; const AError: TErrorCore); reintroduce; overload;
    constructor Create(const ACode: Int64; const Value: string); reintroduce; overload;
    property Code: Int64 read FCode write FCode;
    property Msg: string read FMsg write FMsg;
    property &Type: string read FType write FType;
  end;

  GroqExceptionAPI = class(Exception);

  /// <summary>
  /// Only part of the resource is being delivered, usually in response to range headers sent by the client.
  /// Ensure this is expected for the request being made.
  /// </summary>
  GroqExceptionPartialContentError = class(GroqException);

  /// <summary>
  /// The server could not understand the request due to invalid syntax.
  /// Review the request format and ensure it is correct.
  /// </summary>
  GroqExceptionRequestError = class(GroqException);

  /// <summary>
  /// The request was well-formed but could not be followed due to semantic errors.
  /// Verify the data provided for correctness and completeness.
  /// </summary>
  GroqExceptionUnprocessableEntityError = class(GroqException);

  /// <summary>
  /// Too many requests were sent in a given timeframe. Implement request throttling and respect rate limits.
  /// </summary>
  GroqExceptionTooManyRequestsError = class(GroqException);

  /// <summary>
  /// The request was not successful because it lacks valid authentication credentials for the requested resource.
  /// Ensure the request includes the necessary authentication credentials and the api key is valid.
  /// </summary>
  GroqExceptionUnauthorizedError = class(GroqException);

  /// <summary>
  /// The requested resource could not be found. Check the request URL and the existence of the resource.
  /// </summary>
  GroqExceptionNotFoundError = class(GroqException);

  /// <summary>
  /// A generic error occurred on the server. Try the request again later or contact support if the issue persists.
  /// </summary>
  GroqExceptionInternalServerError = class(GroqException);

  /// <summary>
  /// The server received an invalid response from an upstream server. This may be a temporary issue; retrying the request might resolve it.
  /// </summary>
  GroqExceptionBadGatewayError = class(GroqException);

  /// <summary>
  /// The server is not ready to handle the request, often due to maintenance or overload. Wait before retrying the request.
  /// </summary>
  GroqExceptionServiceUnavailableError = class(GroqException);

  GroqExceptionInvalidResponse = class(GroqException);

  TGroqAPI = class
  public
    const
      URL_BASE = 'https://api.groq.com/openai/v1';
  private
    FToken: string;
    FBaseUrl: string;
    FCustomHeaders: TNetHeaders;

    procedure SetToken(const Value: string);
    procedure SetBaseUrl(const Value: string);
    procedure RaiseError(Code: Int64; Error: TErrorCore);
    procedure ParseError(const Code: Int64; const ResponseText: string);
    procedure SetCustomHeaders(const Value: TNetHeaders);
  protected
    function GetHeaders: TNetHeaders; virtual;
    function GetClient: THTTPClient; virtual;
    function GetRequestURL(const Path: string): string;
    function Get(const Path: string; Response: TStringStream): Integer; overload;
    function Delete(const Path: string; Response: TStringStream): Integer; overload;
    function Post(const Path: string; Response: TStringStream): Integer; overload;
    function Post(const Path: string; Body: TJSONObject; Response: TStringStream; OnReceiveData: TReceiveDataCallback = nil): Integer; overload;
    function Post(const Path: string; Body: TMultipartFormData; Response: TStringStream): Integer; overload;
    function ParseResponse<T: class, constructor>(const Code: Int64; const ResponseText: string): T;
    procedure CheckAPI;
  public
    function Get<TResult: class, constructor>(const Path: string): TResult; overload;
    function Get<TResult: class, constructor; TParams: TJSONParam>(const Path: string; ParamProc: TProc<TParams>): TResult; overload;
    procedure GetFile(const Path: string; Response: TStream); overload;
    function Delete<TResult: class, constructor>(const Path: string): TResult; overload;
    function Post<TParams: TJSONParam>(const Path: string; ParamProc: TProc<TParams>; Response: TStringStream; Event: TReceiveDataCallback = nil): Boolean; overload;
    function Post<TResult: class, constructor; TParams: TJSONParam>(const Path: string; ParamProc: TProc<TParams>): TResult; overload;
    procedure Post<TParams: TJSONParam>(const Path: string; ParamProc: TProc<TParams>; Response: TStream; Event: TReceiveDataCallback = nil); overload;       //AJOUT
    function Post<TResult: class, constructor>(const Path: string): TResult; overload;
    function PostForm<TResult: class, constructor; TParams: TMultipartFormData, constructor>(const Path: string; ParamProc: TProc<TParams>): TResult; overload;
  public
    constructor Create; overload;
    constructor Create(const AToken: string); overload;
    destructor Destroy; override;
    property Token: string read FToken write SetToken;
    property BaseUrl: string read FBaseUrl write SetBaseUrl;
    property CustomHeaders: TNetHeaders read FCustomHeaders write SetCustomHeaders;
  end;
  {$WARNINGS ON}

  TGroqAPIRoute = class
  private
    FAPI: TGroqAPI;
    procedure SetAPI(const Value: TGroqAPI);
  public
    property API: TGroqAPI read FAPI write SetAPI;
    constructor CreateRoute(AAPI: TGroqAPI); reintroduce;
  end;

implementation

uses
  REST.Json, System.NetConsts;

constructor TGroqAPI.Create;
begin
  inherited;
  FToken := '';
  FBaseUrl := URL_BASE;
end;

constructor TGroqAPI.Create(const AToken: string);
begin
  Create;
  Token := AToken;
end;

destructor TGroqAPI.Destroy;
begin
  inherited;
end;

function TGroqAPI.Post(const Path: string; Body: TJSONObject; Response: TStringStream; OnReceiveData: TReceiveDataCallback): Integer;
var
  Headers: TNetHeaders;
  Stream: TStringStream;
  Client: THTTPClient;
begin
  CheckAPI;
  Client := GetClient;
  try
    Headers := GetHeaders + [TNetHeader.Create('Content-Type', 'application/json')];
    Stream := TStringStream.Create;
    Client.ReceiveDataCallBack := OnReceiveData;
    try
      Stream.WriteString(Body.ToJSON);
      Stream.Position := 0;
      Result := Client.Post(GetRequestURL(Path), Stream, Response, Headers).StatusCode;
    finally
      Client.ReceiveDataCallBack := nil;
      Stream.Free;
    end;
  finally
    Client.Free;
  end;
end;

function TGroqAPI.Get(const Path: string; Response: TStringStream): Integer;
var
  Client: THTTPClient;
begin
  CheckAPI;
  Client := GetClient;
  try
    Result := Client.Get(GetRequestURL(Path), Response, GetHeaders).StatusCode;
  finally
    Client.Free;
  end;
end;

function TGroqAPI.Post(const Path: string; Body: TMultipartFormData; Response: TStringStream): Integer;
var
  Client: THTTPClient;
begin
  CheckAPI;
  Client := GetClient;
  try
    Result := Client.Post(GetRequestURL(Path), Body, Response, GetHeaders).StatusCode;
  finally
    Client.Free;
  end;
end;

function TGroqAPI.Post(const Path: string; Response: TStringStream): Integer;
var
  Client: THTTPClient;
begin
  CheckAPI;
  Client := GetClient;
  try
    Result := Client.Post(GetRequestURL(Path), TStream(nil), Response, GetHeaders).StatusCode;
  finally
    Client.Free;
  end;
end;

procedure TGroqAPI.Post<TParams>(const Path: string; ParamProc: TProc<TParams>; Response: TStream; Event: TReceiveDataCallback);
var
  Params: TParams;
  Code: Integer;
  Headers: TNetHeaders;
  Stream, Strings: TStringStream;
  Client: THTTPClient;
begin
  Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);

    CheckAPI;
    Client := GetClient;
    try
      Client.ReceiveDataCallBack := Event;
      Headers := GetHeaders + [TNetHeader.Create('Content-Type', 'application/json')];
      Stream := TStringStream.Create;
      try
        Stream.WriteString(Params.JSON.ToJSON);
        Stream.Position := 0;
        Code := Client.Post(GetRequestURL(Path), Stream, Response, Headers).StatusCode;
        case Code of
          200..299:
            ; {success}
        else
          Strings := TStringStream.Create;
          try
            Response.Position := 0;
            Strings.LoadFromStream(Response);
            ParseError(Code, Strings.DataString);
          finally
            Strings.Free;
          end;
        end;
      finally
        Client.ReceiveDataCallBack := nil;
        Stream.Free;
      end;
    finally
      Client.Free;
    end;
  finally
    Params.Free;
  end;
end;

function TGroqAPI.Post<TResult, TParams>(const Path: string; ParamProc: TProc<TParams>): TResult;
var
  Response: TStringStream;
  Params: TParams;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    Code := Post(Path, Params.JSON, Response);
    Result := ParseResponse<TResult>(Code, Response.DataString);
  finally
    Params.Free;
    Response.Free;
  end;
end;

function TGroqAPI.Post<TParams>(const Path: string; ParamProc: TProc<TParams>; Response: TStringStream; Event: TReceiveDataCallback): Boolean;
var
  Params: TParams;
  Code: Integer;
begin
  Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    Code := Post(Path, Params.JSON, Response, Event);
    case Code of
      200..299:
        Result := True;
    else
      Result := False;
    end;
  finally
    Params.Free;
  end;
end;

function TGroqAPI.Post<TResult>(const Path: string): TResult;
var
  Response: TStringStream;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Code := Post(Path, Response);
    Result := ParseResponse<TResult>(Code, Response.DataString);
  finally
    Response.Free;
  end;
end;

function TGroqAPI.Delete(const Path: string; Response: TStringStream): Integer;
var
  Client: THTTPClient;
begin
  CheckAPI;
  Client := GetClient;
  try
    Result := Client.Delete(GetRequestURL(Path), Response, GetHeaders).StatusCode;
  finally
    Client.Free;
  end;
end;

function TGroqAPI.Delete<TResult>(const Path: string): TResult;
var
  Response: TStringStream;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Code := Delete(Path, Response);
    Result := ParseResponse<TResult>(Code, Response.DataString);
  finally
    Response.Free;
  end;
end;

function TGroqAPI.PostForm<TResult, TParams>(const Path: string; ParamProc: TProc<TParams>): TResult;
var
  Response: TStringStream;
  Params: TParams;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    Code := Post(Path, Params, Response);
    Result := ParseResponse<TResult>(Code, Response.DataString);
  finally
    Params.Free;
    Response.Free;
  end;
end;

function TGroqAPI.Get<TResult, TParams>(const Path: string; ParamProc: TProc<TParams>): TResult;
var
  Response: TStringStream;
  Params: TParams;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    var Pairs: TArray<string> := [];
    for var Pair in Params.ToStringPairs do
      Pairs := Pairs + [Pair.Key + '=' + Pair.Value];
    var QPath := Path;
    if Length(Pairs) > 0 then
      QPath := QPath + '?' + string.Join('&', Pairs);
    Code := Get(QPath, Response);
    Result := ParseResponse<TResult>(Code, Response.DataString);
  finally
    Params.Free;
    Response.Free;
  end;
end;

function TGroqAPI.Get<TResult>(const Path: string): TResult;
var
  Response: TStringStream;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Code := Get(Path, Response);
    Result := ParseResponse<TResult>(Code, Response.DataString);
  finally
    Response.Free;
  end;
end;

function TGroqAPI.GetClient: THTTPClient;
begin
  Result := THTTPClient.Create;
  Result.AcceptCharSet := 'utf-8';
end;

procedure TGroqAPI.GetFile(const Path: string; Response: TStream);
var
  Code: Integer;
  Strings: TStringStream;
  Client: THTTPClient;
begin
  CheckAPI;
  Client := GetClient;
  try
    Code := Client.Get(GetRequestURL(Path), Response, GetHeaders).StatusCode;
    case Code of
      200..299:
        ; {success}
    else
      Strings := TStringStream.Create;
      try
        Response.Position := 0;
        Strings.LoadFromStream(Response);
        ParseError(Code, Strings.DataString);
      finally
        Strings.Free;
      end;
    end;
  finally
    Client.Free;
  end;
end;

function TGroqAPI.GetHeaders: TNetHeaders;
begin
  Result := [TNetHeader.Create('Authorization', 'Bearer ' + FToken)] + FCustomHeaders;
end;

function TGroqAPI.GetRequestURL(const Path: string): string;
begin
  Result := Format('%s/%s', [FBaseURL, Path]);
end;

procedure TGroqAPI.CheckAPI;
begin
  if FToken.IsEmpty then
    raise GroqExceptionAPI.Create('Token is empty!');
  if FBaseUrl.IsEmpty then
    raise GroqExceptionAPI.Create('Base url is empty!');
end;

procedure TGroqAPI.RaiseError(Code: Int64; Error: TErrorCore);
begin
  case Code of
    {--- Informational Codes }
    206:
      raise GroqExceptionPartialContentError.Create(Code, Error);

    {--- Client Error Codes }
    400:
      raise GroqExceptionRequestError.Create(Code, Error);
    401:
      raise GroqExceptionUnauthorizedError.Create(Code, Error);
    404:
      raise GroqExceptionNotFoundError.Create(Code, Error);
    422:
      raise GroqExceptionUnprocessableEntityError.Create(Code, Error);
    429:
      raise GroqExceptionTooManyRequestsError.Create(Code, Error);

    {--- Server Error Codes }
    500:
      raise GroqExceptionInternalServerError.Create(Code, Error);
    502:
      raise GroqExceptionBadGatewayError.Create(Code, Error);
    503:
      raise GroqExceptionServiceUnavailableError.Create(Code, Error);
  else
    raise GroqException.Create(Code, Error);
  end;
end;

procedure TGroqAPI.ParseError(const Code: Int64; const ResponseText: string);
var
  Error: TErrorCore;
begin
  Error := nil;
  try
    try
      Error := TJson.JsonToObject<TError>(ResponseText);
    except
      Error := nil;
    end;
    if Assigned(Error) and Assigned(Error) then
      RaiseError(Code, Error)
  finally
    if Assigned(Error) then
      Error.Free;
  end;
end;

function TGroqAPI.ParseResponse<T>(const Code: Int64; const ResponseText: string): T;
begin
  Result := nil;
  case Code of
    200..299:
      try
        Result := TJson.JsonToObject<T>(ResponseText);
      except
        Result := nil;
      end;
  else
    ParseError(Code, ResponseText);
  end;
  if not Assigned(Result) then
    raise GroqExceptionInvalidResponse.Create(Code, 'Empty or invalid response');
end;

procedure TGroqAPI.SetBaseUrl(const Value: string);
begin
  FBaseUrl := Value;
end;

procedure TGroqAPI.SetCustomHeaders(const Value: TNetHeaders);
begin
  FCustomHeaders := Value;
end;

procedure TGroqAPI.SetToken(const Value: string);
begin
  FToken := Value;
end;

{ TGroqAPIRoute }

constructor TGroqAPIRoute.CreateRoute(AAPI: TGroqAPI);
begin
  inherited Create;
  FAPI := AAPI;
end;

procedure TGroqAPIRoute.SetAPI(const Value: TGroqAPI);
begin
  FAPI := Value;
end;

{ GroqException }

constructor GroqException.Create(const ACode: Int64; const Value: string);
begin
  Code := ACode;
  Msg := Value;
  inherited Create(Format('error %d: %s', [ACode, Msg]));
end;

constructor GroqException.Create(const ACode: Int64; const AError: TErrorCore);
begin
  Code := ACode;
  Msg := (AError as TError).Error.Message;
  &type := (AError as TError).Error.&Type;
  inherited Create(Format('error (%d) - type %s'+ sLineBreak + '%s', [Code, &Type, Msg]));
end;

end.

unit Groq.Async.Params;

{-------------------------------------------------------------------------------

      Unit containing generic interfaces and classes for managing parameters
      across  various  asynchronous  operations.

      The Groq.Async.Params unit  provides  a set of tools for creating
      and managing  parameter  instances  using  generic  types. The primary
      components include:

      - IUseParams<T>: A generic interface for managing parameters of type T.
      - TUseParams<T>: A class  implementing  the IUseParams<T>  interface to
        encapsulate  parameter  handling.
      - TUseParamsFactory<T>: A  factory  class  for  creating  instances  of
        IUseParams<T>.

      These abstractions allow for  a flexible and  reusable  way  to  handle
      parameters  across  different  modules  and  contexts,  particularly in
      asynchronous  scenarios  such  as  chat  operations.

      Note  that  This  unit  is  designed   to  work   seamlessly  with  the
      Groq.Chat.AsyncEvents unit,  which  relies  on  IUseParams<T> and
      TUseParamsFactory<T>  to  manage   parameters   for  asynchronous  chat
      requests.

        Github repository :  https://github.com/MaxiDonkey/DelphiGroqCloud
        Visit the Github repository for the documentation and use examples

-------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes;

type
  /// <summary>
  /// Generic interface for managing parameters of type <c>T</c>.
  /// </summary>
  /// <typeparam name="T">
  /// The type of the parameters.
  /// </typeparam>
  IUseParams<T> = interface
    ['{3DC83C09-77DB-407B-BB03-0B0353D72954}']
    /// <summary>
    /// Sets the parameters.
    /// </summary>
    /// <param name="Value">
    /// The value of the parameters to be set.
    /// </param>
    procedure SetParams(const Value: T);
    /// <summary>
    /// Gets the current parameters.
    /// </summary>
    /// <returns>
    /// The current parameters of type <c>T</c>.
    /// </returns>
    function GetParams: T;
    /// <summary>
    /// Assigns the parameters using a function.
    /// </summary>
    /// <param name="Value">
    /// A function that returns parameters of type <c>T</c>.
    /// </param>
    procedure Assign(Value: TFunc<T>);
    /// <summary>
    /// Returns the current instance as an object of type <c>TObject</c>.
    /// </summary>
    /// <returns>
    /// The instance cast to <c>TObject</c>.
    /// </returns>
    function AsSender: TObject;
    /// <summary>
    /// Provides access to the parameters as a property.
    /// </summary>
    property Param: T read GetParams write SetParams;
  end;

  /// <summary>
  /// A factory class for creating instances of <c>IUseParams</c>.
  /// </summary>
  /// <param name="T">
  /// The type of the parameters for which the instance is created.
  /// </param>
  TUseParamsFactory<T> = class
    /// <summary>
    /// Creates and returns a new instance of <c>IUseParams</c> for the specified type <c>T</c>.
    /// </summary>
    /// <returns>
    /// A new instance of <c>IUseParams&lt;T&gt;</c>.
    /// </returns>
    class function CreateInstance: IUseParams<T>; overload;
    /// <summary>
    /// Creates and returns a new instance of <c>IUseParams</c> for the specified type <c>T</c>, using the provided function.
    /// </summary>
    /// <param name="Value">
    /// A function that provides the parameter values for the instance.
    /// </param>
    /// <returns>
    /// A new instance of <c>IUseParams&lt;T&gt;</c>.
    /// </returns>
    class function CreateInstance(Value: TFunc<T>): IUseParams<T>; overload;
  end;

  /// <summary>
  /// A generic class implementing the <c>IUseParams</c> interface to manage parameters of type <c>T</c>.
  /// </summary>
  /// <param name="T">
  /// The type of the parameters.
  /// </param>
  TUseParams<T> = class(TInterfacedObject, IUseParams<T>)
  private
    FParams: T;
    /// <summary>
    /// Sets the parameters to the provided value.
    /// </summary>
    /// <param name="Value">
    /// The new parameters value.
    /// </param>
    procedure SetParams(const Value: T);
    /// <summary>
    /// Retrieves the current parameters value.
    /// </summary>
    /// <returns>
    /// The current parameters.
    /// </returns>
    function GetParams: T;
  protected
    /// <summary>
    /// Casts the instance as a <c>TObject</c> for use as the sender of events.
    /// </summary>
    /// <returns>
    /// The current instance cast to <c>TObject</c>.
    /// </returns>
    function AsSender: TObject;
    /// <summary>
    /// Assigns the parameters using a function that returns type <c>T</c>.
    /// </summary>
    /// <param name="Value">
    /// A function that sets the parameters.
    /// </param>
    procedure Assign(Value: TFunc<T>);
  public
    /// <summary>
    /// Property to get or set the parameters.
    /// </summary>
    property Params: T read GetParams write SetParams;
  end;

implementation

{ TUseParams<T> }

function TUseParams<T>.AsSender: TObject;
begin
  Result := Self;
end;

procedure TUseParams<T>.Assign(Value: TFunc<T>);
begin
  if Assigned(Value) then
    begin
      Params := Value();
    end;
end;

function TUseParams<T>.GetParams: T;
begin
  Result := FParams;
end;

procedure TUseParams<T>.SetParams(const Value: T);
begin
  FParams := Value;
end;

{ TUseParamsFactory<T> }

class function TUseParamsFactory<T>.CreateInstance: IUseParams<T>;
begin
  Result := TUseParams<T>.Create;
end;

class function TUseParamsFactory<T>.CreateInstance(
  Value: TFunc<T>): IUseParams<T>;
begin
  Result := CreateInstance;
  Result.Assign(Value);
end;

end.

unit Groq.Async.Support;

{-------------------------------------------------------------------------------

      Unit containing  records for managing  asynchronous events related to
      chat requests.

      The  Groq.Chat.AsyncEvents  unit  provides  definitions for the
      TAsyncParams<T>  and  TAsynStreamParams<T>  records, which  are  used
      to  handle  the lifecycle  of asynchronous chat operations, including
      starting, progressing, succeeding, and handling errors.
      These records enable non-blocking operations for chat functionalities
      and can be reused across multiple modules.

      This unit depends  on Groq.Async.Params  for parameter management.
      The IUseParams<T>  and  TUseParamsFactory<T>  interfaces  and  classes
      from  Groq.Async.Params  are  utilized  to  create and manage the
      parameter  instances  for  asynchronous  operations.

        Github repository :  https://github.com/MaxiDonkey/DelphiGroqCloud
        Visit the Github repository for the documentation and use examples

-------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, system.Classes, System.Threading, Groq.Async.Params;

type
  /// <summary>
  /// Record used to handle asynchronous request events.
  /// </summary>
  /// <remarks>
  /// <c>TAsynCallBack</c> manages the lifecycle of an asynchronous request.
  /// It provides callbacks for different stages of the request, such as start, successful completion, or error.
  /// </remarks>
  TAsynCallBack<T> = record
  private
    FSender: TObject;
    FOnStart: TProc<TObject>;
    FOnSuccess: TProc<TObject, T>;
    FOnError: TProc<TObject, string>;
  public
    /// <summary>
    /// Object representing the sender of the asynchronous operation.
    /// </summary>
    /// <remarks>
    /// The <c>Sender</c> property is used to identify or store a reference to the object that initiated the request.
    /// This can be useful for providing context in the callback procedures.
    /// </remarks>
    property Sender: TObject read FSender write FSender;
    /// <summary>
    /// Event triggered at the start of the asynchronous request.
    /// </summary>
    /// <remarks>
    /// The <c>OnStart</c> event is called when the request begins.
    /// It can be used to initialize any required state or display a loading indicator to the user.
    /// <code>
    /// OnStart :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // Code executed at the start of the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnStart: TProc<TObject> read FOnStart write FOnStart;
    /// <summary>
    /// Event triggered at the end of the asynchronous request.
    /// </summary>
    /// <param name="Sender">
    /// Object that initiated the request, generally used for context.
    /// </param>
    /// <param name="Result">
    /// The result of type <c>T</c> returned at the end of the request.
    /// This event is used to process the final result of the asynchronous operation.
    /// </param>
    /// <remarks>
    /// The <c>OnSuccess</c> event is invoked when the process completes successfully.
    /// It can be used to perform final actions based on the received result.
    /// <code>
    /// OnSuccess :=
    ///    procedure (Sender: TObject; Result: T)
    ///    begin
    ///      // Code executed at the end of the request with the obtained result
    ///    end;
    /// </code>
    /// </remarks>
    property OnSuccess: TProc<TObject, T> read FOnSuccess write FOnSuccess;
    /// <summary>
    /// Event triggered when an error occurs during the asynchronous request.
    /// </summary>
    /// <param name="Sender">
    /// Object that initiated the request, generally used for context.
    /// </param>
    /// <param name="ErrorMessage">
    /// The error message received, which can be logged or displayed to the user.
    /// </param>
    /// <remarks>
    /// The <c>OnError</c> event is called when an error occurs during the asynchronous operation.
    /// It can be used to handle failures, display error messages, or perform any necessary cleanup actions.
    /// <code>
    /// OnError :=
    ///    procedure (Sender: TObject; ErrorMessage: string)
    ///    begin
    ///      // Code executed when an error occurs during the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnError: TProc<TObject, string> read FOnError write FOnError;
  end;

  /// <summary>
  /// Class used to manage asynchronous execution with callback events.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynCallBackExec&lt;T, U&gt;</c> class allows you to execute asynchronous operations with specified callbacks for start, completion, and error events.
  /// It encapsulates the asynchronous execution logic, handling thread management and exception handling, providing an easy way to manage the lifecycle of an asynchronous request.
  /// </remarks>
  TAsynCallBackExec<T; U: class> = class
  private
    FUse: IUseParams<T>;
    FSender: TObject;
    FOnStart: TProc<TObject>;
    FOnSuccess: TProc<TObject, U>;
    FOnError: TProc<TObject, string>;
  public
    /// <summary>
    /// Gets the <c>IUseParams&lt;T&gt;</c> interface instance used by this class.
    /// </summary>
    /// <value>
    /// An instance of <c>IUseParams&lt;T&gt;</c> that provides parameter management functionality.
    /// </value>
    property Use: IUseParams<T> read FUse;
    /// <summary>
    /// The object representing the sender of the asynchronous operation.
    /// </summary>
    /// <value>
    /// An instance of <c>TObject</c> identifying the originator of the operation.
    /// </value>
    /// <remarks>
    /// This property can be set to identify the object that initiated the asynchronous operation, which is useful in callback methods.
    /// </remarks>
    property Sender: TObject read FSender write FSender;
    /// <summary>
    /// Event triggered when the asynchronous operation starts.
    /// </summary>
    /// <value>
    /// A procedure of type <c>TProc&lt;TObject&gt;</c> to handle any setup or UI updates when the operation begins.
    /// </value>
    /// <remarks>
    /// Assign a procedure to this event to perform actions at the start of the asynchronous operation.
    /// <code>
    /// OnStart :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // Code executed at the start of the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnStart: TProc<TObject> read FOnStart write FOnStart;
    /// <summary>
    /// Event triggered when the asynchronous operation completes successfully.
    /// </summary>
    /// <value>
    /// A procedure of type <c>TProc&lt;TObject, U&gt;</c> to handle the result of the operation.
    /// </value>
    /// <remarks>
    /// Assign a procedure to this event to process the result returned by the operation.
    /// <code>
    /// OnSuccess :=
    ///    procedure (Sender: TObject; Result: T)
    ///    begin
    ///      // Code executed at the end of the request with the obtained result
    ///    end;
    /// </code>
    /// </remarks>
    property OnSuccess: TProc<TObject, U> read FOnSuccess write FOnSuccess;
    /// <summary>
    /// Event triggered when an error occurs during the asynchronous operation.
    /// </summary>
    /// <value>
    /// A procedure of type <c>TProc&lt;TObject, string&gt;</c> to handle exceptions or errors.
    /// </value>
    /// <remarks>
    /// Assign a procedure to this event to handle any exceptions or errors that occur during execution.
    /// <code>
    /// OnError :=
    ///    procedure (Sender: TObject; ErrorMessage: string)
    ///    begin
    ///      // Code executed when an error occurs during the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnError: TProc<TObject, string> read FOnError write FOnError;
    /// <summary>
    /// Executes the specified function asynchronously.
    /// </summary>
    /// <param name="Value">
    /// A function of type <c>TFunc&lt;U&gt;</c> representing the operation to execute asynchronously.
    /// </param>
    /// <remarks>
    /// This method creates and starts an asynchronous task that executes the provided function.
    /// It invokes the <c>OnStart</c> event before execution, the <c>OnSuccess</c> event upon successful completion, and the <c>OnError</c> event if an exception occurs during execution.
    /// </remarks>
    procedure Run(Value: TFunc<U>);
    /// <summary>
    /// Initializes a new instance of the <c>TAsynCallBackExec&lt;T, U&gt;</c> class with the specified parameter function.
    /// </summary>
    /// <param name="Value">
    /// A function of type <c>TFunc&lt;T&gt;</c> used to create an instance of <c>IUseParams&lt;T&gt;</c>.
    /// </param>
    /// <remarks>
    /// The constructor initializes the internal <c>IUseParams&lt;T&gt;</c> interface using the provided function.
    /// </remarks>
    constructor Create(const Value: TFunc<T>);
  end;

  /// <summary>
  /// Record used to manage asynchronous events for a streaming chat request.
  /// </summary>
  /// <remarks>
  /// <c>TAsynChatStreamParams</c> allows you to handle the lifecycle of a chat request in streaming mode.
  /// It provides callbacks for different stages such as when the request starts, progresses, succeeds, encounters an error, or needs to be canceled.
  /// </remarks>
  TAsynStreamCallBack<T> = record
  private
    FSender: TObject;
    FOnStart: TProc<TObject>;
    FOnSuccess: TProc<TObject>;
    FOnProgress: TProc<TObject, T>;
    FOnError: TProc<TObject, string>;
    FOnCancellation: TProc<TObject>;
    FOnDoCancel: TFunc<Boolean>;
  public
    /// <summary>
    /// The object representing the sender of the asynchronous operation.
    /// </summary>
    /// <remarks>
    /// The <c>Sender</c> property is used to identify or store a reference to the object that initiated the chat request,
    /// which can be useful for context within the callback procedures.
    /// </remarks>
    property Sender: TObject read FSender write FSender;
    /// <summary>
    /// Event triggered when the asynchronous chat request starts.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="Chat">
    /// The <c>TChat</c> object representing the current response chunk received from the model.
    /// This event can be used to update the user interface as new tokens are streamed in.
    /// </param>
    /// <remarks>
    /// The <c>OnStart</c> event is called when the chat request begins. It can be used to set up any initial state or display a loading indicator to the user.
    /// <code>
    /// OnStart :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // code when chat request begin
    ///    end;
    /// </code>
    /// </remarks>
    property OnStart: TProc<TObject> read FOnStart write FOnStart;
    /// <summary>
    /// Event triggered when the asynchronous chat request completes successfully.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="Chat">
    /// The <c>TChat</c> object representing the current response chunk received from the model.
    /// This event can be used to update the user interface as new tokens are streamed in.
    /// </param>
    /// <remarks>
    /// The <c>OnSuccess</c> event is invoked when the streaming process finishes successfully.
    /// It does not provide additional data, as the result is expected to have been handled progressively via the <c>OnProgress</c> event.
    /// <code>
    /// OnSuccess :=
    ///    procedure (Sender: TObject; Chat: TChat)
    ///    begin
    ///      // code when the streaming process finishes successfully
    ///    end;
    /// </code>
    /// </remarks>
    property OnSuccess: TProc<TObject> read FOnSuccess write FOnSuccess;
    /// <summary>
    /// Event triggered to handle progress during the streaming chat request.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="Chat">
    /// The <c>TChat</c> object representing the current response chunk received from the model.
    /// This event can be used to update the user interface as new tokens are streamed in.
    /// </param>
    /// <remarks>
    /// The <c>OnProgress</c> event is fired every time a new chunk of data is received during the streaming process.
    /// This allows the application to handle the response progressively as it is generated by the model.
    /// <code>
    /// OnProgress :=
    ///    procedure (Sender: TObject; Chat: TChat)
    ///    begin
    ///      // code to handle the response progressively
    ///    end;
    /// </code>
    /// </remarks>
    property OnProgress: TProc<TObject, T> read FOnProgress write FOnProgress;
    /// <summary>
    /// Event triggered when an error occurs during the asynchronous chat request.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="ErrorMessage">
    /// The error message received, which can be logged or displayed to the user.
    /// </param>
    /// <remarks>
    /// The <c>OnError</c> event is called when an error occurs during the streaming process.
    /// This can be used to handle failures, show error messages, or perform any necessary clean-up actions.
    /// <code>
    /// OnError :=
    ///    procedure (Sender: TObject; message: string)
    ///    begin
    ///      // code to handle an error occurs during the streaming process
    ///    end;
    /// </code>
    /// </remarks>
    property OnError: TProc<TObject, string> read FOnError write FOnError;
    /// <summary>
    /// Event triggered when the asynchronous chat request has been canceled.
    /// </summary>
    /// <remarks>
    /// The <c>OnCancellation</c> event is fired when the chat request is canceled by the user or the application.
    /// This can be used to perform clean-up operations or notify the user that the request has been terminated.
    /// <code>
    /// OnCancellation :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // code to handle chat request cancellation
    ///    end;
    /// </code>
    /// </remarks>
    property OnCancellation: TProc<TObject> read FOnCancellation write FOnCancellation;
    /// <summary>
    /// Function called to determine if the asynchronous chat request should be canceled.
    /// </summary>
    /// <returns>
    /// A <c>Boolean</c> value indicating whether the request should be canceled (<c>True</c>) or allowed to continue (<c>False</c>).
    /// </returns>
    /// <remarks>
    /// The <c>OnDoCancel</c> function is periodically invoked to check whether the user or application has requested to cancel the chat request.
    /// If the function returns <c>True</c>, the streaming process will be aborted.
    /// <code>
    /// OnDoCancel :=
    ///    function : Boolean
    ///    begin
    ///      Result := ... // True to stop the streaming process
    ///    end;
    /// </code>
    /// </remarks>
    property OnDoCancel: TFunc<Boolean> read FOnDoCancel write FOnDoCancel;
  end;

implementation

{ TAsynCallBackExec<T, U> }

constructor TAsynCallBackExec<T, U>.Create(const Value: TFunc<T>);
begin
  inherited Create;
  FUse := TUseParamsFactory<T>.CreateInstance(Value);
end;

procedure TAsynCallBackExec<T, U>.Run(Value: TFunc<U>);
begin
  {--- Assign callback values to internal variables for asynchrony to work properly }
  var InternalSender := Sender;
  var InternalOnStart := OnStart;
  var InternalOnSuccess := OnSuccess;
  var InternalOnError := OnError;

  var Task: ITask := TTask.Create(
          procedure()
          begin
            try
              {--- Pass the instance of the current class in case no value was specified. }
              if not Assigned(InternalSender) then
                InternalSender := Self;

              {--- Trigger OnStart callback }
              if Assigned(InternalOnStart) then
                TThread.Queue(nil,
                  procedure
                  begin
                    InternalOnStart(InternalSender);
                  end);

              {--- Processing }
              var Result := Value();

              {--- Trigger OnEnd callback when the process is done }
              TThread.Queue(nil,
                  procedure
                  begin
                    try
                      if Assigned(InternalOnSuccess) then
                        InternalOnSuccess(InternalSender, Result);
                    finally
                      {--- Makes sure to release the instance containing the data obtained
                           following processing}
                      if Assigned(Result) then
                        Result.Free;
                    end;
                  end);

            except
              on E: Exception do
                begin
                  var Error := AcquireExceptionObject;
                  try
                    var ErrorMsg := (Error as Exception).Message;

                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(InternalOnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        InternalOnError(InternalSender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
          end);
  Task.Start;
end;

end.

unit Groq.Audio;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGroqCloud
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Net.Mime, REST.JsonReflect, System.JSON,
  Rest.Json, REST.Json.Types, Groq.API, Groq.API.Params, Groq.Common,
  Groq.Async.Params, Groq.Async.Support;

type
  /// <summary>
  /// Specifies the format types for audio transcription and translation responses.
  /// </summary>
  TResponseFormatType = (
    /// <summary>
    /// Specifies the response format as JSON, providing a structured, machine-readable format.
    /// </summary>
    json,
    /// <summary>
    /// Specifies the response format as plain text, providing a simple transcription or translation result in text form.
    /// </summary>
    text,
    /// <summary>
    /// Specifies the response format as verbose JSON, which includes additional metadata alongside the transcription or translation result.
    /// </summary>
    verbose_json
  );

  /// <summary>
  /// Helper record for the <c>TResponseFormatType</c> enumeration, providing utility methods for converting
  /// between <c>TResponseFormatType</c> values and their string representations.
  /// </summary>
  TResponseFormatTypeHelper = record helper for TResponseFormatType
    /// <summary>
    /// Converts the current <c>TResponseFormatType</c> value to its corresponding string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>TResponseFormatType</c> value.
    /// </returns>
    function ToString: string;
  end;

  /// <summary>
  /// Represents the parameters for an audio transcription request, extending the <c>TMultipartFormData</c> class to support
  /// multipart form data for uploading audio files and setting transcription parameters.
  /// </summary>
  /// <remarks>
  /// This class provides methods for configuring various transcription parameters, such as setting the audio file or stream,
  /// language, model ID, optional prompt, response format, and sampling temperature.
  /// </remarks>
  TAudioTranscription = class(TMultipartFormData)
  public
    /// <summary>
    /// Adds an audio file to the transcription request.
    /// </summary>
    /// <param name="FileName">
    /// The path to the audio file to transcribe. Supported formats include flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.
    /// </param>
    /// <returns>
    /// The current instance of <c>TAudioTranscription</c>.
    /// </returns>
    function &File(const FileName: string): TAudioTranscription; overload;
    /// <summary>
    /// Adds an audio stream to the transcription request.
    /// </summary>
    /// <param name="Stream">
    /// The audio stream to transcribe.
    /// </param>
    /// <param name="FileName">
    /// The name of the audio file. Supported formats include flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.
    /// </param>
    /// <returns>
    /// The current instance of <c>TAudioTranscription</c>.
    /// </returns>
    function &File(const Stream: TStream; const FileName: string): TAudioTranscription; overload;
    /// <summary>
    /// Sets the language of the input audio.
    /// </summary>
    /// <param name="Value">
    /// The language code (e.g., 'en', 'fr') of the input audio.
    /// </param>
    /// <returns>
    /// The current instance of <c>TAudioTranscription</c>.
    /// </returns>
    function Language(const Value: string): TAudioTranscription;
    /// <summary>
    /// Sets the ID of the model to use for transcription.
    /// </summary>
    /// <param name="Value">
    /// The model ID to use. Only 'whisper-large-v3' is currently available.
    /// </param>
    /// <returns>
    /// The current instance of <c>TAudioTranscription</c>.
    /// </returns>
    function Model(const Value: string): TAudioTranscription;
    /// <summary>
    /// Sets an optional prompt to guide the model's style or continue a previous audio segment.
    /// </summary>
    /// <param name="Value">
    /// The prompt text.
    /// </param>
    /// <returns>
    /// The current instance of <c>TAudioTranscription</c>.
    /// </returns>
    /// <remarks>
    /// The prompt should match the audio language.
    /// </remarks>
    function Prompt(const Value: string): TAudioTranscription;
    /// <summary>
    /// Sets the format of the transcript output.
    /// </summary>
    /// <param name="Value">
    /// The desired response format. Options are json, text, or verbose_json.
    /// </param>
    /// <returns>
    /// The current instance of <c>TAudioTranscription</c>.
    /// </returns>
    function ResponseFormat(const Value: TResponseFormatType): TAudioTranscription;
    /// <summary>
    /// Sets the sampling temperature for the transcription.
    /// </summary>
    /// <param name="Value">
    /// The sampling temperature, between 0 and 1. Higher values make the output more random, while lower values make it more focused and deterministic.
    /// </param>
    /// <returns>
    /// The current instance of <c>TAudioTranscription</c>.
    /// </returns>
    /// <remarks>
    /// If set to 0, the model will use log probability to automatically increase the temperature until certain thresholds are hit.
    /// </remarks>
    function Temperature(const Value: Double): TAudioTranscription;
    /// <summary>
    /// Initializes a new instance of the <c>TAudioTranscription</c> class.
    /// </summary>
    constructor Create; reintroduce;
  end;

  /// <summary>
  /// Represents the parameters for an audio translation request, extending the <c>TMultipartFormData</c> class to support
  /// multipart form data for uploading audio files and setting translation parameters.
  /// </summary>
  /// <remarks>
  /// This class provides methods for configuring various translation parameters, such as setting the audio file or stream,
  /// model ID, optional prompt, response format, and sampling temperature.
  /// </remarks>
  TAudioTranslation = class(TMultipartFormData)
  public
    /// <summary>
    /// Adds an audio file to the translation request.
    /// </summary>
    /// <param name="FileName">
    /// The path to the audio file to translate. Supported formats include flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.
    /// </param>
    /// <returns>
    /// The current instance of <c>TAudioTranslation</c>.
    /// </returns>
    function &File(const FileName: string): TAudioTranslation; overload;
    /// <summary>
    /// Adds an audio stream to the translation request.
    /// </summary>
    /// <param name="Stream">
    /// The audio stream to translate.
    /// </param>
    /// <param name="FileName">
    /// The name of the audio file. Supported formats include flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.
    /// </param>
    /// <returns>
    /// The current instance of <c>TAudioTranslation</c>.
    /// </returns>
    function &File(const Stream: TStream; const FileName: string): TAudioTranslation; overload;
    /// <summary>
    /// Sets the ID of the model to use for translation.
    /// </summary>
    /// <param name="Value">
    /// The model ID to use. Only 'whisper-large-v3' is currently available.
    /// </param>
    /// <returns>
    /// The current instance of <c>TAudioTranslation</c>.
    /// </returns>
    function Model(const Value: string): TAudioTranslation;
    /// <summary>
    /// Sets an optional prompt to guide the model's style or continue a previous audio segment.
    /// </summary>
    /// <param name="Value">
    /// The prompt text.
    /// </param>
    /// <returns>
    /// The current instance of <c>TAudioTranslation</c>.
    /// </returns>
    /// <remarks>
    /// The prompt should match the audio language.
    /// </remarks>
    function Prompt(const Value: string): TAudioTranslation;
    /// <summary>
    /// Sets the format of the translation output.
    /// </summary>
    /// <param name="Value">
    /// The desired response format. Options are json, text, or verbose_json.
    /// </param>
    /// <returns>
    /// The current instance of <c>TAudioTranslation</c>.
    /// </returns>
    function ResponseFormat(const Value: TResponseFormatType): TAudioTranslation;
    /// <summary>
    /// Sets the sampling temperature for the translation.
    /// </summary>
    /// <param name="Value">
    /// The sampling temperature, between 0 and 1. Higher values make the output more random, while lower values make it more focused and deterministic.
    /// </param>
    /// <returns>
    /// The current instance of <c>TAudioTranslation</c>.
    /// </returns>
    /// <remarks>
    /// If set to 0, the model will use log probability to automatically increase the temperature until certain thresholds are hit.
    /// </remarks>
    function Temperature(const Value: Single): TAudioTranslation;
    /// <summary>
    /// Initializes a new instance of the <c>TAudioTranslation</c> class.
    /// </summary>
    constructor Create; reintroduce;
  end;

  /// <summary>
  /// Represents the text result of an audio transcription or translation.
  /// </summary>
  TAudioText = class
  private
    FText: string;
    [JsonNameAttribute('x_groq')]
    FXGroq: TXGroq;
  public
    /// <summary>
    /// Gets or sets the transcribed or translated text.
    /// </summary>
    property Text: string read FText write FText;
    /// <summary>
    /// Gets or sets the XGroq metadata.
    /// </summary>
    property XGroq: TXGroq read FXGroq write FXGroq;
  end;

  /// <summary>
  /// Manages asynchronous callbacks for a model search request using <c>TAudioText</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynAudioText</c> type extends the <c>TAsynParams&lt;TAudioText&gt;</c> record to handle the lifecycle of an asynchronous model operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking model search operations and is specifically tailored for scenarios where multiple model choices are required.
  /// </remarks>
  TAsynAudioText = TAsynCallBack<TAudioText>;

  /// <summary>
  /// Provides methods to interact with audio transcription and translation API endpoints, extending the <c>TGroqAPIRoute</c> class
  /// to support specialized audio processing requests.
  /// </summary>
  /// <remarks>
  /// This class includes methods for both synchronous and asynchronous audio transcriptions and translations.
  /// It allows users to send audio data for processing and retrieve transcriptions or translations in different formats.
  /// </remarks>
  TAudioRoute = class(TGroqAPIRoute)
    /// <summary>
    /// Asynchronously creates a transcription of the provided audio.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TAudioTranscription</c> parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns <c>TAsynAudioText</c> to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// This method sends a request to the API to transcribe the provided audio asynchronously.
    ///The <c>CallBacks</c> function is invoked when the operation completes, either successfully or with an error.
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var GroqCloud := TGroqFactory.CreateInstance(BaererKey);
    /// GroqCloud.Audio.ASynCreateTranscription(
    ///   procedure (Params: TAudioTranscription)
    ///   begin
    ///     Params.Model('whisper-large-v3-turbo');
    ///     Params.File('Z:\my_folder\Audio\sound.mp3');
    ///   end,
    ///   function : TAsynAudioText
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Audio: TAudioText)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure ASynCreateTranscription(ParamProc: TProc<TAudioTranscription>; CallBacks: TFunc<TAsynAudioText>);
    /// <summary>
    /// Asynchronously translates the provided audio into English.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TAudioTranslation</c> parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns <c>TAsynAudioText</c> to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// This method sends a request to the API to translate the provided audio asynchronously.
    /// The <c>CallBacks</c> function is invoked when the operation completes, either successfully or with an error.
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var GroqCloud := TGroqFactory.CreateInstance(BaererKey);
    /// GroqCloud.Audio.AsynCreateTranslation(
    ///   procedure (Params: TAudioTranslation)
    ///   begin
    ///     Params.Model('whisper-large-v3-turbo');
    ///     Params.File('Z:\my_folder\Audio\sound.mp3');
    ///   end,
    ///   function : TAsynAudioText
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Audio: TAudioText)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure ASynCreateTranslation(ParamProc: TProc<TAudioTranslation>; CallBacks: TFunc<TAsynAudioText>);
    /// <summary>
    /// Creates a transcription of the provided audio.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TAudioTranscription</c> parameters.
    /// </param>
    /// <returns>
    /// A <c>TAudioText</c> object containing the transcription result.
    /// </returns>
    /// <remarks>
    /// This method sends a synchronous request to the API to transcribe the provided audio.
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var GroqCloud := TGroqFactory.CreateInstance(BaererKey);
    /// var Transcript := GroqCloud.Audio.CreateTranscription(
    ///     procedure (Params: TAudioTranscription)
    ///     begin
    ///       Params.Model('whisper-large-v3');
    ///       Params.File('Z:\my_folder\Audio\sound.mp3');
    ///     end;
    /// try
    ///   WriteLn(Transcript.Text);
    /// finally
    ///   Transcript.Free;
    /// end;
    /// </code>
    /// </remarks>
    function CreateTranscription(ParamProc: TProc<TAudioTranscription>): TAudioText;
    /// <summary>
    /// Translates the provided audio into English.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TAudioTranslation</c> parameters.
    /// </param>
    /// <returns>
    /// A <c>TAudioText</c> object containing the translation result.
    /// </returns>
    /// <remarks>
    /// This method sends a synchronous request to the API to translate the provided audio.
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var GroqCloud := TGroqFactory.CreateInstance(BaererKey);
    /// var Translate := GroqCloud.Audio.CreateTranslation(
    ///     procedure (Params: TAudioTranslation)
    ///     begin
    ///       Params.Model('whisper-large-v3');
    ///       Params.File('Z:\my_folder\Audio\sound.mp3');
    ///     end);
    /// try
    ///   WriteLn(Translate.Text);
    /// finally
    ///   Translate.Free;
    /// end;
    /// </code>
    /// </remarks>
    function CreateTranslation(ParamProc: TProc<TAudioTranslation>): TAudioText;
  end;

implementation

uses
  System.Net.URLClient;

{ TAudioTranscription }

function TAudioTranscription.&File(const FileName: string): TAudioTranscription;
begin
  AddFile('file', FileName);
  Result := Self;
end;

constructor TAudioTranscription.Create;
begin
  inherited Create(True);
end;

function TAudioTranscription.&File(const Stream: TStream;
  const FileName: string): TAudioTranscription;
begin
  AddStream('file', Stream, True, FileName);
  Result := Self;
end;

function TAudioTranscription.Language(const Value: string): TAudioTranscription;
begin
  AddField('language', Value);
  Result := Self;
end;

function TAudioTranscription.Model(const Value: string): TAudioTranscription;
begin
  AddField('model', Value);
  Result := Self;
end;

function TAudioTranscription.Prompt(const Value: string): TAudioTranscription;
begin
  AddField('prompt', Value);
  Result := Self;
end;

function TAudioTranscription.ResponseFormat(
  const Value: TResponseFormatType): TAudioTranscription;
begin
  AddField('response_format', Value.ToString);
  Result := Self;
end;

function TAudioTranscription.Temperature(
  const Value: Double): TAudioTranscription;
begin
  AddField('temperature', Value.ToString);
  Result := Self;
end;

{ TResponseFormatTypeHelper }

function TResponseFormatTypeHelper.ToString: string;
begin
  case Self of
    json:
      Exit('json');
    text:
      Exit('text');
    verbose_json:
      Exit('verbose_json');
  end;
end;

{ TAudioRoute }

procedure TAudioRoute.ASynCreateTranscription(
  ParamProc: TProc<TAudioTranscription>; CallBacks: TFunc<TAsynAudioText>);
begin
  with TAsynCallBackExec<TAsynAudioText, TAudioText>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TAudioText
      begin
        Result := Self.CreateTranscription(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TAudioRoute.ASynCreateTranslation(ParamProc: TProc<TAudioTranslation>;
  CallBacks: TFunc<TAsynAudioText>);
begin
  with TAsynCallBackExec<TAsynAudioText, TAudioText>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TAudioText
      begin
        Result := Self.CreateTranslation(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TAudioRoute.CreateTranscription(
  ParamProc: TProc<TAudioTranscription>): TAudioText;
begin
  Result := API.PostForm<TAudioText, TAudioTranscription>('audio/transcriptions', ParamProc);
end;

function TAudioRoute.CreateTranslation(
  ParamProc: TProc<TAudioTranslation>): TAudioText;
begin
  Result := API.PostForm<TAudioText, TAudioTranslation>('audio/translations', ParamProc);
end;

{ TAudioTranslation }

function TAudioTranslation.&File(const FileName: string): TAudioTranslation;
begin
  AddFile('file', FileName);
  Result := Self;
end;

constructor TAudioTranslation.Create;
begin
  inherited Create(True);
end;

function TAudioTranslation.&File(const Stream: TStream;
  const FileName: string): TAudioTranslation;
begin
  AddStream('file', Stream, True, FileName);
  Result := Self;
end;

function TAudioTranslation.Model(const Value: string): TAudioTranslation;
begin
  AddField('model', Value);
  Result := Self;
end;

function TAudioTranslation.Prompt(const Value: string): TAudioTranslation;
begin
  AddField('prompt', Value);
  Result := Self;
end;

function TAudioTranslation.ResponseFormat(
  const Value: TResponseFormatType): TAudioTranslation;
begin
  AddField('response_format', Value.ToString);
  Result := Self;
end;

function TAudioTranslation.Temperature(const Value: Single): TAudioTranslation;
begin
  AddField('temperature', FormatFloat('0,0', Value));
  Result := Self;
end;

end.

unit Groq.Chat;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGroqCloud
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, System.Threading,
  REST.Json.Types, Groq.API.Params, Groq.API, Groq.Functions.Core, Groq.Common,
  Groq.NetEncoding.Base64, Groq.Async.Params, Groq.Async.Support;

type
  /// <summary>
  /// Type of message role
  /// </summary>
  TRoleType = (
    /// <summary>
    /// System message
    /// </summary>
    system,
    /// <summary>
    /// User message
    /// </summary>
    user,
    /// <summary>
    /// Assistant message
    /// </summary>
    assistant,
    /// <summary>
    /// Tool message
    /// </summary>
    tool
  );

  /// <summary>
  /// Helper record for the <c>TRoleType</c> enumeration, providing utility methods for converting
  /// between <c>TRoleType</c> values and their string representations.
  /// </summary>
  TRoleTypeHelper = record helper for TRoleType
    /// <summary>
    /// Converts the current <c>TRoleType</c> value to its corresponding string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>TRoleType</c> value.
    /// </returns>
    function ToString: string;
    /// <summary>
    /// Converts a string representation of a <c>TRoleType</c> into its corresponding enumeration value.
    /// </summary>
    /// <param name="Value">
    /// The string representing a <c>TRoleType</c>.
    /// </param>
    /// <returns>
    /// The <c>TRoleType</c> enumeration value that corresponds to the provided string.
    /// </returns>
    class function Create(const Value: string): TRoleType; static;
  end;

  /// <summary>
  /// Interceptor class for converting <c>TRoleType</c> values to and from their string representations in JSON serialization and deserialization.
  /// </summary>
  /// <remarks>
  /// This class is used to facilitate the conversion between the <c>TRoleType</c> enum and its string equivalents during JSON processing.
  /// It extends the <c>TJSONInterceptorStringToString</c> class to override the necessary methods for custom conversion logic.
  /// </remarks>
  TRoleTypeInterceptor = class(TJSONInterceptorStringToString)
    /// <summary>
    /// Converts the <c>TRoleType</c> value of the specified field to a string during JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be converted.
    /// </param>
    /// <param name="Field">
    /// The field name representing the <c>TRoleType</c> value.
    /// </param>
    /// <returns>
    /// The string representation of the <c>TRoleType</c> value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string back to a <c>TRoleType</c> value for the specified field during JSON deserialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be set.
    /// </param>
    /// <param name="Field">
    /// The field name where the <c>TRoleType</c> value will be set.
    /// </param>
    /// <param name="Arg">
    /// The string representation of the <c>TRoleType</c> to be converted back.
    /// </param>
    /// <remarks>
    /// This method converts the string argument back to the corresponding <c>TRoleType</c> value and assigns it to the specified field in the object.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Controls which (if any) tool is called by the model.  
  /// </summary>
  TToolChoiceType = (
    /// <summary>
    /// The model will not call any tool and instead generates a message.  
    /// </summary>
    none,
    /// <summary>
    /// The model can pick between generating a message or calling one or more tools.  
    /// </summary>
    auto,
    /// <summary>
    /// The model must call one or more tools.  
    /// </summary>
    /// <remarks>
    /// Specifying a particular tool via {"type": "function", "function": {"name": "my_function"}} forces the model to call that tool.
    /// <para>
    /// With Llama models  
    /// </para>
    /// </remarks>
    required
  );

  /// <summary>
  /// Helper record for the <c>TToolChoiceType</c> enumeration, providing utility methods for converting
  /// between <c>TToolChoiceType</c> values and their string representations.
  /// </summary>
  TToolChoiceTypeHelper = record helper for TToolChoiceType
    /// <summary>
    /// Converts the <c>TToolChoiceType</c> value of the specified field to a string during JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be converted.
    /// </param>
    /// <param name="Field">
    /// The field name representing the <c>TToolChoiceType</c> value.
    /// </param>
    /// <returns>
    /// The string representation of the <c>TToolChoiceType</c> value.
    /// </returns>
    function ToString: string;
  end;

  /// <summary>
  /// Allow to characterize the content type of a payload
  /// </summary>
  TContentType = (
    /// <summary>
    /// The type of the content is a text.  
    /// </summary>
    text,
    /// <summary>
    /// The type of the content is an URL.  
    /// </summary>
    imageUrl
  );

  /// <summary>
  /// Helper record for the <c>TContentType</c> enumeration, providing utility methods for converting
  /// between <c>TContentType</c> values and their string representations.
  /// </summary>
  TContentTypeHelper = record helper for TContentType
    /// <summary>
    /// Converts the <c>TContentType</c> value of the specified field to a string during JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be converted.
    /// </param>
    /// <param name="Field">
    /// The field name representing the <c>TContentType</c> value.
    /// </param>
    /// <returns>
    /// The string representation of the <c>TContentType</c> value.
    /// </returns>
    function ToString: string;
  end;

  /// <summary>
  /// The reason the model stopped generating tokens.
  /// </summary>
  TFinishReasonType = (
    /// <summary>
    /// If the model hit a natural stop point or a provided stop sequence
    /// </summary>
    stop,
    /// <summary>
    /// If the maximum number of tokens specified in the request was reached
    /// </summary>
    length,
    /// <summary>
    /// If content was omitted due to a flag from our content filters
    /// </summary>
    content_filter,
    /// <summary>
    /// If the model called a tool
    /// </summary>
    tool_calls,
    /// <summary>
    /// (deprecated) If the model called a function
    /// </summary>
    function_call
  );

  /// <summary>
  /// Helper record for the <c>TFinishReasonType</c> enumeration, providing utility methods for converting
  /// between <c>TFinishReasonType</c> values and their string representations.
  /// </summary>
  TFinishReasonTypeHelper = record helper for TFinishReasonType
    /// <summary>
    /// Converts the <c>TFinishReasonType</c> value of the specified field to a string during JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be converted.
    /// </param>
    /// <param name="Field">
    /// The field name representing the <c>TFinishReasonType</c> value.
    /// </param>
    /// <returns>
    /// The string representation of the <c>TFinishReasonType</c> value.
    /// </returns>
    function ToString: string;
    /// <summary>
    /// Converts a string representation of a <c>TFinishReasonType</c> into its corresponding enumeration value.
    /// </summary>
    /// <param name="Value">
    /// The string representing a <c>TFinishReasonType</c>.
    /// </param>
    /// <returns>
    /// The <c>TFinishReasonType</c> enumeration value that corresponds to the provided string.
    /// </returns>
    class function Create(const Value: string): TFinishReasonType; static;
  end;

  /// <summary>
  /// Interceptor class for converting <c>TFinishReasonType</c> values to and from their string representations in JSON serialization and deserialization.
  /// </summary>
  /// <remarks>
  /// This class is used to facilitate the conversion between the <c>TFinishReasonType</c> enum and its string equivalents during JSON processing.
  /// It extends the <c>TJSONInterceptorStringToString</c> class to override the necessary methods for custom conversion logic.
  /// </remarks>
  TFinishReasonTypeInterceptor = class(TJSONInterceptorStringToString)
    /// <summary>
    /// Converts the <c>TFinishReasonType</c> value of the specified field to a string during JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be converted.
    /// </param>
    /// <param name="Field">
    /// The field name representing the <c>TFinishReasonType</c> value.
    /// </param>
    /// <returns>
    /// The string representation of the <c>TFinishReasonType</c> value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string back to a <c>TFinishReasonType</c> value for the specified field during JSON deserialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be set.
    /// </param>
    /// <param name="Field">
    /// The field name where the <c>TFinishReasonType</c> value will be set.
    /// </param>
    /// <param name="Arg">
    /// The string representation of the <c>TFinishReasonType</c> to be converted back.
    /// </param>
    /// <remarks>
    /// This method converts the string argument back to the corresponding <c>TFinishReasonType</c> value and assigns it to the specified field in the object.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Specifies the response format options for the model's output.
  /// </summary>
  /// <remarks>
  /// This enumeration allows you to control the structure of the model's output, either as plain text or as a structured JSON object.
  /// Use <c>to_text</c> when a simple textual response is sufficient, or <c>to_json_object</c> for structured data outputs.
  /// </remarks>
  TResponseFormat = (
    /// <summary>
    /// Requests the model to output its response as plain text.
    /// </summary>
    /// <remarks>
    /// Use this option when only a textual response is needed without any specific formatting.
    /// </remarks>
    to_text,
    /// <summary>
    /// Requests the model to output its response as a JSON object.
    /// </summary>
    /// <remarks>
    /// This option enables JSON mode, ensuring the model outputs well-formed JSON.
    /// <para>
    /// Important: When using JSON mode, provide instructions to the model within your messages to produce JSON output.
    /// </para>
    /// </remarks>
    to_json_object
  );

  /// <summary>
  /// Helper record for the <c>TResponseFormat</c> enumeration, providing utility methods for converting
  /// between <c>TResponseFormat</c> values and their string representations.
  /// </summary>
  TResponseFormatHelper = record helper for TResponseFormat
    /// <summary>
    /// Converts the <c>TResponseFormat</c> value of the specified field to a string during JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be converted.
    /// </param>
    /// <param name="Field">
    /// The field name representing the <c>TResponseFormat</c> value.
    /// </param>
    /// <returns>
    /// The string representation of the <c>TResponseFormat</c> value.
    /// </returns>
    function ToString: string;
  end;

  /// <summary>
  /// A class to represent and set up content parameters for chat message payloads.
  /// </summary>
  /// <remarks>
  /// This class allows you to specify various types of content, such as text or image URLs, within a payload.
  /// It facilitates building structured message payloads for content delivery.
  /// </remarks>
  TContentParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the type of the content within the payload.
    /// </summary>
    /// <param name="Value">
    /// The content type, defined by the <c>TContentType</c> enumeration (e.g., text or image URL).
    /// </param>
    /// <returns>
    /// Returns the updated <c>TContentParams</c> instance, enabling method chaining.
    /// </returns>
    /// <remarks>
    /// Setting the content type helps in determining how the payload should be interpreted (e.g., as plain text or as an image URL).
    /// </remarks>
    function &Type(const Value: TContentType): TContentParams;
    /// <summary>
    /// Sets the text content of the payload.
    /// </summary>
    /// <param name="Value">
    /// The text string to be included as content.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TContentParams</c> instance, enabling method chaining.
    /// </returns>
    /// <remarks>
    /// This method allows you to include plain text as the payload content, which can be used in text-based messages.
    /// </remarks>
    function Text(const Value: string): TContentParams;
    /// <summary>
    /// Sets the content of the payload as an image URL.
    /// </summary>
    /// <param name="Value">
    /// The image URL to be included as content.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TContentParams</c> instance, enabling method chaining.
    /// </returns>
    /// <remarks>
    /// This method allows you to specify an image URL as the content, which can be used to display images in message payloads.
    /// </remarks>
    function ImageUrl(const Value: string): TContentParams;
    /// <summary>
    /// Creates and returns a <c>TContentParams</c> instance with text content.
    /// </summary>
    /// <param name="Value">
    /// The text string to be set as the payload content.
    /// </param>
    /// <returns>
    /// Returns a new <c>TContentParams</c> instance with text content.
    /// </returns>
    /// <remarks>
    /// This static method provides a convenient way to initialize a <c>TContentParams</c> object with text content.
    /// </remarks>
    class function AddText(const Value: string): TContentParams;
    /// <summary>
    /// Creates and returns a <c>TContentParams</c> instance with image file content.
    /// </summary>
    /// <param name="Value">
    /// The file path or URL of the image to be set as the payload content.
    /// </param>
    /// <returns>
    /// Returns a new <c>TContentParams</c> instance with image content.
    /// </returns>
    /// <remarks>
    /// This static method provides a convenient way to initialize a <c>TContentParams</c> object with image content, useful for including image URLs in messages.
    /// </remarks>
    class function AddImageFile(const Value: string): TContentParams;
  end;

  /// <summary>
  /// Represents a payload for a chat message, defining the sender role and the message content.
  /// </summary>
  /// <remarks>
  /// The <c>TPayload</c> class provides methods to set the role of the message sender
  /// (e.g., user, assistant, system, or tool) and allows customization of the content,
  /// which can be in plain text or a JSON array for more complex message structures.
  /// This class is essential for constructing structured chat messages, especially in
  /// contexts where distinguishing between message roles is important.
  /// </remarks>
  TPayload = class(TJSONParam)
  public
    /// <summary>
    /// Specifies the role of the message sender.
    /// </summary>
    /// <param name="Value">
    /// A <c>TRoleType</c> enum value representing the role (user, assistant, system, or tool).
    /// </param>
    /// <returns>
    /// The updated <c>TPayload</c> instance, enabling method chaining.
    /// </returns>
    /// <remarks>
    /// Use this method to define the sender's role for the current message,
    /// which is critical for establishing context in multi-turn conversations.
    /// </remarks>
    function Role(const Value: TRoleType): TPayload;
    /// <summary>
    /// Sets a single string as the content of the message.
    /// </summary>
    /// <param name="Value">
    /// A string representing the message content.
    /// </param>
    /// <returns>
    /// The updated <c>TPayload</c> instance, enabling method chaining.
    /// </returns>
    function Content(const Value: string): TPayload; overload;
    /// <summary>
    /// Sets an array of payload content as the message content.
    /// </summary>
    /// <param name="Value">
    /// A <c>TJSONArray</c> representing the complex message content.
    /// </param>
    /// <returns>
    /// The updated <c>TPayload</c> instance, enabling method chaining.
    /// </returns>
    /// <remarks>
    /// Use this method when creating a message with multiple content elements,
    /// such as text and image URLs, allowing for a structured message format.
    /// </remarks>
    function Content(const Value: TJSONArray): TPayload; overload;
    /// <summary>
    /// Creates a user message with the specified content.
    /// </summary>
    /// <param name="Value">
    /// The text content of the user message.
    /// </param>
    /// <returns>
    /// A <c>TPayload</c> instance representing a user message.
    /// </returns>
    class function User(const Value: string): TPayload; overload;
    /// <summary>
    /// Creates a user message with text content and an array of image URLs.
    /// </summary>
    /// <param name="Value">
    /// The text content of the user message.
    /// </param>
    /// <param name="Images">
    /// An array of strings, each representing an image URL to include in the message.
    /// </param>
    /// <returns>
    /// A <c>TPayload</c> instance representing a user message with images.
    /// </returns>
    /// <remarks>
    /// This method is useful for messages containing both text and visual content.
    /// Each image URL is included in the payload as a separate JSON element.
    /// </remarks>
    class function User(const Value: string; Images: TArray<string>): TPayload; overload;
    /// <summary>
    /// Creates an assistant message with the specified content.
    /// </summary>
    /// <param name="Value">
    /// The text content of the assistant message.
    /// </param>
    /// <returns>
    /// A <c>TPayload</c> instance representing an assistant message.
    /// </returns>
    class function Assistant(const Value: string): TPayload;
    /// <summary>
    /// Creates a system message with the specified content.
    /// </summary>
    /// <param name="Value">
    /// The text content of the system message.
    /// </param>
    /// <returns>
    /// A <c>TPayload</c> instance representing a system message.
    /// </returns>
    /// <remarks>
    /// System messages are often used for configuring the chat session or providing
    /// context before any user or assistant interactions.
    /// </remarks>
    class function System(const Value: string): TPayload;
  end;

  /// <summary>
  /// The <c>TToolsChoice</c> class provides methods to define and specify tool choices
  /// that the model can invoke during chat operations, particularly for cases where
  /// specific functions are available for call.
  /// </summary>
  /// <remarks>
  /// This class allows you to set up a tool choice by specifying its type and the
  /// function to be called. It provides a structured way to instruct the model on
  /// specific tools it can utilize, especially in scenarios where calling external
  /// functions may enhance chat interactions.
  /// </remarks>
  TToolsChoice = class(TJSONParam)
  public
    /// <summary>
    /// Sets the type of the tool to be used by the model.
    /// </summary>
    /// <param name="Value">
    /// A string representing the type of tool (e.g., "function").
    /// </param>
    /// <returns>
    /// Returns the updated <c>TToolsChoice</c> instance, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// Use this method to specify the nature of the tool. Typically,
    /// setting this to "function" informs the model that it may call
    /// a particular function as part of its response generation.
    /// </remarks>
    function &Type(const Value: string): TToolsChoice;
    /// <summary>
    /// Specifies the function name to be used by the model as a tool.
    /// </summary>
    /// <param name="Value">
    /// The name of the function that the model may call.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TToolsChoice</c> instance, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// Setting a function name here is essential when using functions as tools in
    /// the chat model. This enables the model to identify and use specific functions
    /// relevant to a chat session, depending on the conversation flow and context.
    /// </remarks>
    function &Function(const Value: string): TToolsChoice;
    /// <summary>
    /// Creates a new <c>TToolsChoice</c> instance with the type set to "function"
    /// and the specified function name.
    /// </summary>
    /// <param name="Value">
    /// The name of the function to be called.
    /// </param>
    /// <returns>
    /// Returns a new <c>TToolsChoice</c> instance configured for function calls.
    /// </returns>
    /// <remarks>
    /// This method provides a convenient way to initialize a <c>TToolsChoice</c>
    /// instance specifically for cases where the model needs to access a function.
    /// By using this factory method, you streamline the setup for a function tool choice.
    /// </remarks>
    class function New(const Value: string): TToolsChoice;
  end;

  /// <summary>
  /// This class provides parameters for configuring chat message payloads within the API.
  /// </summary>
  /// <remarks>
  /// The <c>TChatParams</c> class allows you to specify various attributes for controlling message behavior,
  /// such as response length, temperature, frequency penalties, and tool usage. It offers a flexible
  /// structure for customizing chat interactions through property and method chaining.
  /// </remarks>
  TChatParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the frequency penalty to reduce the likelihood of repetitive tokens in the output.
    /// </summary>
    /// <param name="Value">
    /// A number between -2.0 and 2.0, where positive values penalize repeated tokens.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TChatParams</c> instance, allowing method chaining.
    /// </returns>
    /// <remarks>
    /// Use this parameter to adjust token repetition based on their frequency in the text, thereby
    /// encouraging more unique tokens if set to a positive value.
    /// </remarks>
    function FrequencyPenalty(const Value: Double): TChatParams;
    /// <summary>
    /// <para>
    /// NOT YET SUPPORTED
    /// </para>
    /// Applies a logit bias on certain tokens in the output (currently unsupported).
    /// </summary>
    /// <param name="Value">
    /// A JSON string specifying the token biases.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TChatParams</c> instance, allowing method chaining.
    /// </returns>
    /// <remarks>
    /// Although currently unsupported, this parameter allows for modifying token likelihood, which can guide
    /// the model toward or away from specified tokens in future implementations.
    /// </remarks>
    function LogitBias(const Value: string): TChatParams;
    /// <summary>
    /// <para>
    /// NOT YET SUPPORTED
    /// </para>
    /// Enables the output of log probabilities for each token (currently unsupported).
    /// </summary>
    /// <param name="Value">
    /// A Boolean flag indicating whether to return log probabilities for tokens.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// Log probabilities are useful for analysis and debugging. This option will include log
    /// probabilities with each token if it is enabled in future model updates.
    /// </remarks>
    function Logprobs(const Value: Boolean): TChatParams;
    /// <summary>
    /// Sets the maximum number of tokens for the generated output.
    /// </summary>
    /// <param name="Value">
    /// Maximum token count, constrained by the model's context limit.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// This parameter limits the total token count in the output to manage response length effectively.
    /// </remarks>
    function MaxToken(const Value: Integer): TChatParams;
    //// <summary>
    /// Adds a set of messages as input for the chat interaction.
    /// </summary>
    /// <param name="Value">
    /// An array of <c>TPayload</c> messages representing the conversation history.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// This method provides a way to pass a history of messages for multi-turn conversation management.
    /// </remarks>
    function Messages(const Value: TArray<TPayload>): TChatParams; overload;
    /// <summary>
    /// Adds messages from a JSON object as input for the chat interaction.
    /// </summary>
    /// <param name="Value">
    /// A <c>TJSONObject</c> representing the conversation messages.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// This method allows you to include messages directly from a JSON object, facilitating integration with pre-existing JSON structures or data sources.
    /// </remarks>
    function Messages(const Value: TJSONObject): TChatParams; overload;
    /// <summary>
    /// Sets the model ID to be used for the chat interaction.
    /// </summary>
    /// <param name="Value">
    /// A string representing the model ID.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// Use this parameter to specify which model variant to employ, as different models may provide
    /// distinct characteristics or capabilities.
    /// </remarks>
    function Model(const Value: string): TChatParams;
    //// <summary>
    /// Specifies how many response options to generate.
    /// </summary>
    /// <param name="Value">
    /// The number of choices, with 1 being the only supported option currently.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// Although currently limited to 1, this parameter may allow multiple responses in future implementations.
    /// </remarks>
    function N(const Value: Integer): TChatParams;
    /// <summary>
    /// Sets whether tool calls can be made in parallel.
    /// </summary>
    /// <param name="Value">
    /// A Boolean flag to enable or disable parallel tool calls.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TChatParams</c> instance.
    /// </returns>
    function ParallelToolCalls(const Value: Boolean): TChatParams;
    /// <summary>
    /// Sets the presence penalty to encourage new topics.
    /// </summary>
    /// <param name="Value">
    /// A value between -2.0 and 2.0, where positive values encourage topic variety.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// Presence penalty helps drive topic diversity in the generated output.
    /// </remarks>
    function PresencePenalty(const Value: Double): TChatParams;
    /// <summary>
    /// Specifies the format for the response output.
    /// </summary>
    /// <param name="Value">
    /// Either <c>to_text</c> or <c>to_json_object</c> for structured JSON output.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// This parameter controls the response format. Set to JSON to enforce structured responses, especially for API usage.
    /// </remarks>
    function ResponseFormat(const Value: TResponseFormat): TChatParams;
    /// <summary>
    /// Seeds the sampling for deterministic output.
    /// </summary>
    /// <param name="Value">
    /// An integer seed for consistent results across identical queries.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// Deterministic sampling is not guaranteed but can be influenced by setting this value.
    /// </remarks>
    function Seed(const Value: Integer): TChatParams;
    /// <summary>
    /// Defines sequences that will terminate generation.
    /// </summary>
    /// <param name="Value">
    /// A string or array of strings indicating stop sequences.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// This feature helps control response endings by specifying phrases or sequences where generation should halt.
    /// </remarks>
    function Stop(const Value: string): TChatParams; overload;
    /// <summary>
    /// Defines sequences that will terminate generation.
    /// </summary>
    /// <param name="Value">
    /// An array of strings indicating stop sequences.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// This method allows specifying multiple phrases or sequences where the generation should stop, giving you fine-grained control over the response endings.
    /// </remarks>
    function Stop(const Value: TArray<string>): TChatParams; overload;
    /// <summary>
    /// Enables token streaming for partial responses.
    /// </summary>
    /// <param name="Value">
    /// A Boolean indicating whether streaming mode is active.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// Streaming sends token-by-token responses, useful for real-time applications or progressive displays.
    /// </remarks>
    function Stream(const Value: Boolean): TChatParams;
    /// <summary>
    /// Configures stream response options, such as usage metrics.
    /// </summary>
    /// <param name="Value">
    /// A Boolean to include usage metrics in streamed responses.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TChatParams</c> instance.
    /// </returns>
    function StreamOptions(const Value: Boolean = True): TChatParams;
    /// <summary>
    /// Sets the sampling temperature to control randomness in the output.
    /// </summary>
    /// <param name="Value">
    /// A number between 0 and 2, with higher values making responses more random.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// Temperature and <c>top_p</c> work in conjunction but should typically not be used together. Higher temperatures result in less deterministic outputs.
    /// </remarks>
    function Temperature(const Value: Double): TChatParams;
    /// <summary>
    /// Controls which (if any) tool is called by the model.
    /// </summary>
    /// <param name="Value">
    /// A value defined by <c>TToolChoiceType</c>
    /// </param>
    /// <returns>
    /// A <c>TChatParams</c> instance representing a system message.
    /// </returns>
    /// <remarks>
    /// <para>
    /// - <c>none</c> means the model will not call any tool and instead generates a message.
    /// </para>
    /// <para>
    /// - <c>auto</c> means the model can pick between generating a message or calling one or more tools.
    /// </para>
    /// <para>
    /// - <c>required</c> means the model must call one or more tools. Specifying a particular tool via {"type": "function", "function": {"name": "my_function"}} forces the model to call that tool.
    /// </para>
    /// <c>none</c> is the default when no tools are present. <c>auto</c> is the default if tools are present.
    /// Show possible types
    /// </remarks>
    function ToolChoice(const Value: TToolChoiceType): TChatParams; overload;
    /// <summary>
    /// Specifies a particular tool or function to be called by the model.
    /// </summary>
    /// <param name="Value">
    /// A string representing the name of the tool or function the model should use.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// By specifying the name of the tool, you can force the model to call a specific tool or function, overriding the default behavior.
    /// </remarks>
    function ToolChoice(const Value: string): TChatParams; overload;
    /// <summary>
    /// Sets the tool choice parameters for the model using a <c>TToolsChoice</c> instance.
    /// </summary>
    /// <param name="Value">
    /// A <c>TToolsChoice</c> object defining the tool or function the model may call.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// This method allows for advanced configuration of the tool choice, including specifying types and functions through a <c>TToolsChoice</c> object.
    /// </remarks>
    function ToolChoice(const Value: TToolsChoice): TChatParams; overload;
    /// <summary>
    /// A list of tools the model may call.
    /// </summary>
    /// <param name="Value">
    /// A JSON object defined in advance
    /// </param>
    /// <returns>
    /// A <c>TChatParams</c> instance representing a system message.
    /// </returns>
    /// <remarks>
    /// Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for. A max of 128 functions are supported.
    /// </remarks>
    function Tools(const Value: TJSONObject): TChatParams; overload;
    /// <summary>
    /// Specifies a list of tools that the model may call during the chat interaction.
    /// </summary>
    /// <param name="Value">
    /// An array of <c>TJSONObject</c> instances, each representing a tool or function definition.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// Use this method to provide multiple tool or function definitions that the model can choose from. Currently, only functions are supported as tools, and a maximum of 128 functions can be specified.
    /// </remarks>
    function Tools(const Value: TArray<TJSONObject>): TChatParams; overload;
    /// <summary>
    /// Specifies a list of tools that the model may call, using an array of function core interfaces.
    /// </summary>
    /// <param name="Value">
    /// An array of <c>IFunctionCore</c> instances representing the functions the model may use.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// This method allows you to define tools as interfaces, enabling more dynamic and flexible function definitions for the model to call. A maximum of 128 functions can be provided.
    /// </remarks>
    function Tools(const Value: TArray<IFunctionCore>): TChatParams; overload;
    /// <summary>
    /// This is not yet supported by any of our models.
    /// </summary>
    /// <param name="Value">
    /// An integer value between 0 and 20
    /// </param>
    /// <returns>
    /// A <c>TChatParams</c> instance representing a system message.
    /// </returns>
    /// <remarks>
    /// The integer value specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
    /// </remarks>
    function TopLogprobs(const Value: Integer): TChatParams;
    /// <summary>
    /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
    /// </summary>
    /// <param name="Value">
    /// A value of 0.1 means only the tokens comprising the top 10% probability mass are considered.
    /// </param>
    /// <returns>
    /// A <c>TChatParams</c> instance representing a system message.
    /// </returns>
    /// <remarks>
    /// We generally recommend altering this or temperature but not both.
    /// </remarks>
    function TopP(const Value: Double): TChatParams;
    /// <summary>
    /// A unique identifier representing your end-user
    /// </summary>
    /// <param name="Value">
    /// An Id for the end-user
    /// </param>
    /// <returns>
    /// A <c>TChatParams</c> instance representing a system message.
    /// </returns>
    /// <remarks>
    /// This can help us monitor and detect abuse.
    /// </remarks>
    function User(const Value: String): TChatParams;
  end;

  /// <summary>
  /// Represents the arguments for a function call within a chat interaction.
  /// </summary>
  /// <remarks>
  /// This class encapsulates the name and arguments of a function that may be called by the chat model.
  /// It is used to define the function invocation details when the model decides to execute a function as part of its response.
  /// </remarks>
  TFunctionArgs = class
  private
    FName: string;
    FArguments: string;
  public
    /// <summary>
    /// The name of the function to be called.
    /// </summary>
    /// <remarks>
    /// This should match the name of a function defined in the tools available to the model.
    /// </remarks>
    property Name: string read FName write FName;
    /// <summary>
    /// A JSON-formatted string representing the arguments to pass to the function.
    /// </summary>
    /// <remarks>
    /// The arguments should be formatted as a JSON object, matching the expected parameters of the function.
    /// </remarks>
    property Arguments: string read FArguments write FArguments;
  end;

  /// <summary>
  /// Represents a tool call made by the chat model, potentially including a function call.
  /// </summary>
  /// <remarks>
  /// This class captures the details of a tool invocation, including its identifier, type, and the function arguments if applicable.
  /// It is used to represent tools that the model decides to call during a conversation, such as functions for additional processing or data retrieval.
  /// </remarks>
  TToolCall = class
  private
    FId: string;
    FType: string;
    FFunction: TFunctionArgs;
  public
    /// <summary>
    /// A unique identifier for the tool call.
    /// </summary>
    /// <remarks>
    /// The identifier can be used to track or reference specific tool calls within the conversation.
    /// </remarks>
    property Id: string read FId write FId;  
    /// <summary>
    /// The type of the tool being called (e.g., "function").
    /// </summary>
    /// <remarks>
    /// The type indicates the nature of the tool, such as whether it's a function call or another kind of tool.
    /// </remarks>
    property &Type: string read FType write FType;
    /// <summary>
    /// Details of the function to be called, including its name and arguments.
    /// </summary>
    /// <remarks>
    /// If the tool call is a function call, this property contains the specifics of the function invocation.
    /// </remarks>
    property &Function: TFunctionArgs read FFunction write FFunction;
    /// <summary>
    /// Destructor for the TToolCall class.
    /// </summary>
    /// <remarks>
    /// Ensures that the associated TFunctionArgs instance is properly destroyed when the TToolCall instance is freed.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a message in a chat conversation, including its role, content, and any tool calls made.
  /// </summary>
  /// <remarks>
  /// This class encapsulates a single message within a chat interaction, providing properties for the sender's role,
  /// the message content, any refusal messages, and any tool calls the model may have initiated.
  /// It is essential for tracking the flow of conversation and any actions taken by the model.
  /// </remarks>
  TChatMessage = class
  private
    [JsonReflectAttribute(ctString, rtString, TRoleTypeInterceptor)]
    FRole: TRoleType;
    FContent: string;
    FRefusal: string;
    [JsonNameAttribute('tool_calls')]
    FToolCalls: TArray<TToolCall>;
  public
    /// <summary>
    /// The role of the message sender (e.g., user, assistant, system, tool).
    /// </summary>
    property Role: TRoleType read FRole write FRole;
    /// <summary>
    /// The textual content of the message.
    /// </summary>
    /// <remarks>
    /// The content may include the assistant's response, user input, or system prompts.
    /// </remarks>
    property Content: string read FContent write FContent;
    /// <summary>
    /// A message indicating any refusal from the model to comply with a request.
    /// </summary>
    /// <remarks>
    /// This property is used when the model chooses not to fulfill a request due to policy or other constraints.
    /// </remarks>
    property Refusal: string read FRefusal write FRefusal;
    /// <summary>
    /// An array of tool calls made by the model during this message.
    /// </summary>
    /// <remarks>
    /// If the model invokes any tools (e.g., functions) during its response generation, those tool calls are recorded here.
    /// </remarks>
    property ToolCalls: TArray<TToolCall> read FToolCalls write FToolCalls;
    /// <summary>
    /// Destructor for the TChatMessage class.
    /// </summary>
    /// <remarks>
    /// Ensures that all associated TToolCall instances are properly destroyed when the TChatMessage instance is freed.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents the top log probabilities for tokens in the model's output.
  /// </summary>
  /// <remarks>
  /// This class captures the token, its log probability, and the byte representation of the token.
  /// It is used for detailed analysis of the model's token predictions, especially when log probabilities are requested.
  /// </remarks>
  TTopLogprobs = class
  private
    FToken: string;
    FLogprob: Double;
    FBytes: TArray<Int64>;
  public
    /// <summary>
    /// The token text as predicted by the model.
    /// </summary>
    property Token: string read FToken write FToken;
    /// <summary>
    /// The log probability of the token.
    /// </summary>
    /// <remarks>
    /// Log probabilities are in natural logarithm base and represent the likelihood of the token.
    /// </remarks>
    property Logprob: Double read FLogprob write FLogprob;
    /// <summary>
    /// The byte sequence representing the token.
    /// </summary>
    /// <remarks>
    /// Useful for understanding the token at the byte level, especially for encoding or decoding processes.
    /// </remarks>
    property Bytes: TArray<Int64> read FBytes write FBytes;
  end;

  /// <summary>
  /// Represents the log probabilities for a content token in the model's output.
  /// </summary>
  /// <remarks>
  /// This class includes the token, its log probability, the byte representation, and the top log probabilities for alternative tokens.
  /// It provides a comprehensive view of the model's decision-making for each token.
  /// </remarks>
  TLogprobsContent = class
  private
    FToken: string;
    FLogprob: Double;
    FBytes: TArray<Int64>;
    [JsonNameAttribute('top_logprobs')]
    FTopLogprobs: TArray<TTopLogprobs>;
  public
    /// <summary>
    /// The token text as generated in the content.
    /// </summary>
    property Token: string read FToken write FToken;
    /// <summary>
    /// The log probability of the token.
    /// </summary>
    /// <remarks>
    /// Provides the likelihood of the token appearing in this context.
    /// </remarks>
    property Logprob: Double read FLogprob write FLogprob;
    /// <summary>
    /// The byte sequence representing the token.
    /// </summary>
    property Bytes: TArray<Int64> read FBytes write FBytes;
    /// <summary>
    /// An array of top alternative tokens with their log probabilities.
    /// </summary>
    /// <remarks>
    /// This allows for analysis of other tokens the model considered at this position and their respective probabilities.
    /// </remarks>
    property TopLogprobs: TArray<TTopLogprobs> read FTopLogprobs write FTopLogprobs;
    /// <summary>
    /// Destructor for the TLogprobsContent class.
    /// </summary>
    /// <remarks>
    /// Ensures that all associated TTopLogprobs instances are properly destroyed when the TLogprobsContent instance is freed.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents the log probabilities for a refusal token in the model's output.
  /// </summary>
  /// <remarks>
  /// This class is identical to TLogprobsContent and is used when the model outputs a refusal message.
  /// It inherits from TLogprobsContent to reuse the same structure for consistency.
  /// </remarks>
  TLogprobsRefusal = TLogprobsContent;

  /// <summary>
  /// Contains the log probabilities for both content and refusal tokens in the model's output.
  /// </summary>
  /// <remarks>
  /// This class aggregates the log probabilities of all tokens generated by the model, including both content and any refusal messages.
  /// It is useful for analyzing the model's token-level outputs comprehensively.
  /// </remarks>
  TLogprobs = class
  private
    FContent: TArray<TLogprobsContent>;
    FRefusal: TArray<TLogprobsRefusal>;
  public
    /// <summary>
    /// An array of log probabilities for content tokens.
    /// </summary>
    property Content: TArray<TLogprobsContent> read FContent write FContent;
    /// <summary>
    /// An array of log probabilities for refusal tokens.
    /// </summary>
    /// <remarks>
    /// Populated when the model generates a refusal message instead of the requested content.
    /// </remarks>
    property Refusal: TArray<TLogprobsRefusal> read FRefusal write FRefusal;
    /// <summary>
    /// Destructor for the TLogprobs class.
    /// </summary>
    /// <remarks>
    /// Ensures that all associated TLogprobsContent and TLogprobsRefusal instances are properly destroyed when the TLogprobs instance is freed.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a single choice returned by the chat model, including the message and any associated metadata.
  /// </summary>
  /// <remarks>
  /// This class encapsulates one of the possible responses the model generates, including the message content,
  /// finish reason, and log probabilities if requested. It is used to parse and handle the model's output choices.
  /// </remarks>
  TChatChoice = class
  private
    FIndex: Int64;
    [JsonReflectAttribute(ctString, rtString, TFinishReasonTypeInterceptor)]
    [JsonNameAttribute('finish_reason')]
    FFinishReason: TFinishReasonType;
    FLogprobs: TLogprobs;
    FMessage: TChatMessage;
    FDelta: TChatMessage;
  public
    /// <summary>
    /// The index of this choice in the list of choices returned.
    /// </summary>
    property Index: Int64 read FIndex write FIndex;
    /// <summary>
    /// The reason why the model stopped generating the output.
    /// </summary>
    /// <remarks>
    /// Indicates whether the model stopped due to reaching the end of the message, hitting a stop sequence, or other reasons.
    /// </remarks>
    property FinishReason: TFinishReasonType read FFinishReason write FFinishReason;
    /// <summary>
    /// The message generated by the model.
    /// </summary>
    /// <remarks>
    /// Contains the actual content of the model's response.
    /// </remarks>
    property Message: TChatMessage read FMessage write FMessage;
    /// <summary>
    /// Incremental message content for streaming responses.
    /// </summary>
    /// <remarks>
    /// Used when responses are streamed token by token; contains the latest delta in the message.
    /// </remarks>
    property Delta: TChatMessage read FDelta write FDelta;
    /// <summary>
    /// The log probabilities associated with the tokens in the message.
    /// </summary>
    /// <remarks>
    /// Populated if log probabilities were requested; provides detailed token-level probability information.
    /// </remarks>
    property Logprobs: TLogprobs read FLogprobs write FLogprobs;
    /// <summary>
    /// Destructor for the TChatChoice class.
    /// </summary>
    /// <remarks>
    /// Ensures that all associated TChatMessage and TLogprobs instances are properly destroyed when the TChatChoice instance is freed.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Provides usage metrics for a chat interaction with the model.
  /// </summary>
  /// <remarks>
  /// This class contains detailed information about token usage and timing, allowing for analysis of the model's performance and billing calculations.
  /// </remarks>
  TChatUsage = class
  private
    [JsonNameAttribute('queue_time')]
    FQueueTime: Double;
    [JsonNameAttribute('prompt_tokens')]
    FPromptTokens: Int64;
    [JsonNameAttribute('prompt_time')]
    FPromptTime: Double;
    [JsonNameAttribute('completion_tokens')]
    FCompletionTokens: Int64;
    [JsonNameAttribute('completion_time')]
    FCompletionTime: Double;
    [JsonNameAttribute('total_tokens')]
    FTotalTokens: Int64;
    [JsonNameAttribute('total_time')]
    FTotalTime: Double;
  public
    /// <summary>
    /// The time in seconds the request spent in the queue before processing.
    /// </summary>
    property QueueTime: Double read FQueueTime write FQueueTime;
    /// <summary>
    /// The number of tokens in the prompt sent to the model.
    /// </summary>
    property PromptTokens: Int64 read FPromptTokens write FPromptTokens;
    /// <summary>
    /// The time in seconds taken to process the prompt.
    /// </summary>
    property PromptTime: Double read FPromptTime write FPromptTime;
    /// <summary>
    /// The number of tokens generated in the model's completion.
    /// </summary>
    property CompletionTokens: Int64 read FCompletionTokens write FCompletionTokens;
    /// <summary>
    /// The time in seconds taken to generate the completion.
    /// </summary>
    property CompletionTime: Double read FCompletionTime write FCompletionTime;
    /// <summary>
    /// The total number of tokens used (prompt and completion).
    /// </summary>
    property TotalTokens: Int64 read FTotalTokens write FTotalTokens;
    /// <summary>
    /// The total time in seconds for processing the request.
    /// </summary>
    property TotalTime: Double read FTotalTime write FTotalTime;
  end;

  /// <summary>
  /// Represents the complete response from the chat model, including choices and usage metrics.
  /// </summary>
  /// <remarks>
  /// This class is the top-level container for the model's response to a chat completion request.
  /// It includes the generated choices, usage statistics, and other metadata.
  /// </remarks>
  TChat = class
  private
    FId: string;
    FObject: string;
    FCreated: Int64;
    FModel: string;
    FChoices: TArray<TChatChoice>;
    FUsage: TChatUsage;
    [JsonNameAttribute('system_fingerprint')]
    FSystemFingerprint: string;
    [JsonNameAttribute('x_groq')]
    FXGroq: TXGroq;
  public
    /// <summary>
    /// The unique identifier for the chat completion.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// The object type, typically "chat.completion".
    /// </summary>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// The timestamp when the completion was created.
    /// </summary>
    /// <remarks>
    /// Represented as seconds since the Unix epoch.
    /// </remarks>
    property Created: Int64 read FCreated write FCreated;
    /// <summary>
    /// The model used for generating the completion.
    /// </summary>
    property Model: string read FModel write FModel;
    /// <summary>
    /// An array of choices returned by the model.
    /// </summary>
    /// <remarks>
    /// Each choice represents a possible completion generated by the model.
    /// </remarks>
    property Choices: TArray<TChatChoice> read FChoices write FChoices;
    /// <summary>
    /// Usage information for the completion request.
    /// </summary>
    property Usage: TChatUsage read FUsage write FUsage;
    /// <summary>
    /// A fingerprint representing the system state.
    /// </summary>
    /// <remarks>
    /// Used for internal tracking and debugging purposes.
    /// </remarks>
    property SystemFingerprint: string read FSystemFingerprint write FSystemFingerprint;
    /// <summary>
    /// Additional metadata provided by the Groq API.
    /// </summary>
    property XGroq: TXGroq read FXGroq write FXGroq;
    /// <summary>
    /// Destructor for the TChat class.
    /// </summary>
    /// <remarks>
    /// Ensures that all associated TChatChoice and TXGroq instances are properly destroyed when the TChat instance is freed.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a callback procedure used during the reception of responses from a chat request in streaming mode.
  /// </summary>
  /// <param name="Chat">
  /// The <c>TChat</c> object containing the current information about the response generated by the model.
  /// If this value is <c>nil</c>, it indicates that the data stream is complete.
  /// </param>
  /// <param name="IsDone">
  /// A boolean flag indicating whether the streaming process is complete.
  /// If <c>True</c>, it means the model has finished sending all response data.
  /// </param>
  /// <param name="Cancel">
  /// A boolean flag that can be set to <c>True</c> within the callback to cancel the streaming process.
  /// If set to <c>True</c>, the streaming will be terminated immediately.
  /// </param>
  /// <remarks>
  /// This callback is invoked multiple times during the reception of the response data from the model.
  /// It allows for real-time processing of received messages and interaction with the user interface or other systems
  /// based on the state of the data stream.
  /// When the <c>IsDone</c> parameter is <c>True</c>, it indicates that the model has finished responding,
  /// and the <c>Chat</c> parameter will be <c>nil</c>.
  /// </remarks>
  TChatEvent = reference to procedure(var Chat: TChat; IsDone: Boolean; var Cancel: Boolean);

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TChat</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynChat</c> type extends the <c>TAsynParams&lt;TChat&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynChat = TAsynCallBack<TChat>;

  /// <summary>
  /// Manages asynchronous streaming chat callBacks for a chat request using <c>TChat</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynChatStream</c> type extends the <c>TAsynStreamParams&lt;TChat&gt;</c> record to support the lifecycle of an asynchronous streaming chat operation.
  /// It provides callbacks for different stages, including when the operation starts, progresses with new data chunks, completes successfully, or encounters an error.
  /// This structure is ideal for handling scenarios where the chat response is streamed incrementally, providing real-time updates to the user interface.
  /// </remarks>
  TAsynChatStream = TAsynStreamCallBack<TChat>;

  /// <summary>
  /// The <c>TChatRoute</c> class inherits from <c>TGroqAPIRoute</c> and provides an interface for managing various interactions with the chat API.
  /// It supports creating chat completion requests in synchronous, asynchronous, and streaming modes, offering mechanisms to handle responses generated by the model.
  /// </summary>
  /// <remarks>
  /// This class facilitates sending messages to a chat model, receiving responses, and managing them, whether synchronously or asynchronously.
  /// The primary methods in the class are:
  /// <para>
  /// - <c>Create</c> : Sends a chat request and waits for a full response.
  /// </para>
  /// <para>
  /// - <c>AsynCreate</c> : Performs an asynchronous chat completion request with event handling.
  /// </para>
  /// <para>
  /// - <c>CreateStream</c> : Initiates a chat completion request in streaming mode, receiving tokens progressively.
  /// </para>
  /// <para>
  /// - <c>ASynCreateStream</c> : Performs an asynchronous request in streaming mode with event handling.
  /// </para>
  /// Each method allows configuring model parameters, setting input messages, managing token limits, and including callbacks for processing responses or errors.
  /// </remarks>
  TChatRoute = class(TGroqAPIRoute)
  public
    /// <summary>
    /// Create an asynchronous completion for chat message
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the parameters for the chat request, such as model selection, messages, and other parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for the asynchronous chat completion, such as on success and on error.
    /// </param>
    /// <remarks>
    /// This procedure initiates an asynchronous request to generate a chat completion based on the provided parameters. The response or error is handled by the provided callBacks.
    /// <code>
    /// // WARNING - Move the following line to the main OnCreate method for maximum scope.
    /// //var GroqCloud := TGroqFactory.CreateInstance(BaererKey);
    /// GroqCloud.Chat.AsynCreate(
    ///   procedure (Params: TChatParams)
    ///   begin
    ///     // Define chat parameters
    ///   end,
    ///   function: TAsynChat
    ///   begin
    ///     Result.Sender := Memo1;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Chat: TChat)
    ///     begin
    ///       var M := Sender as TMemo; // Because Result.Sender = Memo1
    ///       // Handle success operation
    ///     end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Value: string)
    ///     begin
    ///       // Handle error message
    ///     end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsynCreate(ParamProc: TProc<TChatParams>; CallBacks: TFunc<TAsynChat>);
    /// <summary>
    /// Creates an asynchronous streaming chat completion request.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the chat request, including the model, messages, and additional options such as max tokens and streaming mode.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a <c>TAsynChatStream</c> record which contains event handlers for managing different stages of the streaming process: progress updates, success, errors, and cancellation.
    /// </param>
    /// <remarks>
    /// This procedure initiates an asynchronous chat operation in streaming mode, where tokens are progressively received and processed.
    /// The provided event handlers allow for handling progress (i.e., receiving tokens in real time), detecting success, managing errors, and enabling cancellation logic.
    /// <code>
    /// CheckBox1.Checked := False;  //Click to stop the streaming
    /// // WARNING - Move the following line into the main OnCreate
    /// //var GroqCoud := TGroqFactory.CreateInstance(BaererKey);
    /// GroqCoud.Chat.AsynCreateStream(
    ///   procedure(Params: TChatParams)
    ///   begin
    ///     // Define chat parameters
    ///   end,
    ///
    ///   function: TAsynChatStream
    ///   begin
    ///     Result.Sender := Memo1; // Instance passed to callback parameter
    ///     Result.OnProgress :=
    ///         procedure (Sender: TObject; Chat: TChat)
    ///         begin
    ///           // Handle progressive updates to the chat response
    ///         end;
    ///     Result.OnSuccess :=
    ///         procedure (Sender: TObject)
    ///         begin
    ///           // Handle success when the operation completes
    ///         end;
    ///     Result.OnError :=
    ///         procedure (Sender: TObject; Value: string)
    ///         begin
    ///           // Handle error message
    ///         end;
    ///     Result.OnDoCancel :=
    ///         function: Boolean
    ///         begin
    ///           Result := CheckBox1.Checked; // Click on checkbox to cancel
    ///         end;
    ///     Result.OnCancellation :=
    ///         procedure (Sender: TObject)
    ///         begin
    ///           // Processing when process has been canceled
    ///         end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsynCreateStream(ParamProc: TProc<TChatParams>; CallBacks: TFunc<TAsynChatStream>);
    /// <summary>
    /// Creates a completion for the chat message using the provided parameters.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the chat request, such as selecting the model, providing messages, setting token limits, etc.
    /// </param>
    /// <returns>
    /// Returns a <c>TChat</c> object that contains the chat response, including the choices generated by the model.
    /// </returns>
    /// <exception cref="GroqExceptionAPI">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="GroqExceptionInvalidRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// The <c>Create</c> method sends a chat completion request and waits for the full response. The returned <c>TChat</c> object contains the model's generated response, including multiple choices if available.
    ///
    /// Example usage:
    /// <code>
    ///   var GroqCloud := TGroqFactory.CreateInstance(BaererKey);
    ///   var Chat := GroqCloud.Chat.Create(
    ///     procedure (Params: TChatParams)
    ///     begin
    ///       // Define chat parameters
    ///     end);
    ///   try
    ///     for var Item in Chat.Candidates do
    ///       WriteLn(Item.Text);
    ///   finally
    ///     Chat.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Create(ParamProc: TProc<TChatParams>): TChat;
    /// <summary>
    /// Creates a chat message completion with a streamed response.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the chat request, such as selecting the model, providing messages, and adjusting other settings like token limits or temperature.
    /// </param>
    /// <param name="Event">
    /// A callback of type <c>TChatEvent</c> that is triggered with each chunk of data received during the streaming process. It includes the current state of the <c>TChat</c> object, a flag indicating if the stream is done, and a boolean to handle cancellation.
    /// </param>
    /// <returns>
    /// Returns <c>True</c> if the streaming process started successfully, <c>False</c> otherwise.
    /// </returns>
    /// <remarks>
    /// This method initiates a chat request in streaming mode, where the response is delivered incrementally in real-time.
    /// The <c>Event</c> callback will be invoked multiple times as tokens are received.
    /// When the response is complete, the <c>IsDone</c> flag will be set to <c>True</c>, and the <c>Chat</c> object will be <c>nil</c>.
    /// The streaming process can be interrupted by setting the <c>Cancel</c> flag to <c>True</c> within the event.
    ///
    /// Example usage:
    /// <code>
    ///   var GroqCloud := TGroqFactory.CreateInstance(BaererKey);
    ///   GroqCloud.Chat.CreateStream(
    ///     procedure (Params: TChatParams)
    ///     begin
    ///       // Define chat parameters
    ///       Params.Stream(True);
    ///     end,
    ///
    ///     procedure(var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
    ///     begin
    ///       // Handle displaying
    ///     end
    ///   );
    /// </code>
    /// </remarks>
    function CreateStream(ParamProc: TProc<TChatParams>; Event: TChatEvent): Boolean;
  end;

implementation

uses
  System.StrUtils, System.Rtti, Rest.Json;

{ TRoleTypeHelper }

class function TRoleTypeHelper.Create(const Value: string): TRoleType;
begin
  var Index := IndexStr(Value.ToLower, ['user', 'assistant', 'system', 'tool']);
  if Index = -1 then
    raise Exception.Create('Role type unknown');
  Result := TRoleType(index);
end;

function TRoleTypeHelper.ToString: string;
begin
  case Self of
    user:
      Exit('user');
    assistant:
      Exit('assistant');
    system:
      Exit('system');
    tool:
      Exit('tool');
  end;
end;

{ TRoleTypeInterceptor }

function TRoleTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TRoleType>.ToString;
end;

procedure TRoleTypeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TRoleType.Create(Arg)));
end;

{ TPayload }

class function TPayload.Assistant(const Value: string): TPayload;
begin
  Result := TPayload.Create.Role(TRoleType.assistant).Content(Value);
end;

function TPayload.Content(const Value: string): TPayload;
begin
  Result := TPayload(Add('content', Value));
end;

function TPayload.Content(const Value: TJSONArray): TPayload;
begin
  Result := TPayload(Add('content', Value));
end;

function TPayload.Role(const Value: TRoleType): TPayload;
begin
  Result := TPayload(Add('role', Value.ToString));
end;

class function TPayload.System(const Value: string): TPayload;
begin
  Result := TPayload.Create.Role(TRoleType.system).Content(Value);
end;

class function TPayload.User(const Value: string;
  Images: TArray<string>): TPayload;
begin
  var JSONArray := TJSONArray.Create.Add(TContentParams.AddText(Value).Detach);
  for var Item in Images do
    JSONArray.Add(TContentParams.AddImageFile(Item).Detach);
  Result := TPayload.Create.Role(TRoleType.user).Content(JSONArray);
end;

class function TPayload.User(const Value: string): TPayload;
begin
  Result := TPayload.Create.Role(TRoleType.user).Content(Value);
end;

{ TChatParams }

function TChatParams.Messages(const Value: TArray<TPayload>): TChatParams;
begin
  var JSONMessages := TJSONArray.Create;
  for var Item in Value do
    JSONMessages.Add(Item.Detach);
  Result := TChatParams(Add('messages', JSONMessages));
end;

function TChatParams.FrequencyPenalty(const Value: Double): TChatParams;
begin
  Result := TChatParams(Add('frequency_penalty', Value));
end;

function TChatParams.LogitBias(const Value: string): TChatParams;
begin
  Result := TChatParams(Add('logit_bias', Value));
end;

function TChatParams.Logprobs(const Value: Boolean): TChatParams;
begin
  Result := TChatParams(Add('logprobs', Value));
end;

function TChatParams.MaxToken(const Value: Integer): TChatParams;
begin
  Result := TChatParams(Add('max_tokens', Value));
end;

function TChatParams.Messages(const Value: TJSONObject): TChatParams;
begin
  Result := TChatParams(Add('messages', Value));
end;

function TChatParams.Model(const Value: string): TChatParams;
begin
  Result := TChatParams(Add('model', Value));
end;

function TChatParams.N(const Value: Integer): TChatParams;
begin
  Result := TChatParams(Add('n', Value));
end;

function TChatParams.ParallelToolCalls(const Value: Boolean): TChatParams;
begin
  Result := TChatParams(Add('parallel_tool_calls', Value));
end;

function TChatParams.PresencePenalty(const Value: Double): TChatParams;
begin
  Result := TChatParams(Add('presence_penalty', Value));
end;

function TChatParams.ResponseFormat(const Value: TResponseFormat): TChatParams;
begin
  Result := TChatParams(Add('response_format', TJSONObject.Create.AddPair('type', Value.ToString)))
end;

function TChatParams.Seed(const Value: Integer): TChatParams;
begin
  Result := TChatParams(Add('seed', Value));
end;

function TChatParams.Stop(const Value: string): TChatParams;
begin
  Result := TChatParams(Add('stop', Value));
end;

function TChatParams.Stop(const Value: TArray<string>): TChatParams;
begin
  Result := TChatParams(Add('stop', Value));
end;

function TChatParams.Stream(const Value: Boolean): TChatParams;
begin
  Result := TChatParams(Add('stream', Value));
end;

function TChatParams.StreamOptions(const Value: Boolean): TChatParams;
begin
  Result := TChatParams(Add('temperature', TJSONObject.Create.AddPair('include_usage', Value)));
end;

function TChatParams.Temperature(const Value: Double): TChatParams;
begin
  Result := TChatParams(Add('temperature', Value));
end;

function TChatParams.Tools(const Value: TJSONObject): TChatParams;
begin
  Result := TChatParams(Add('tools', Value));
end;

function TChatParams.Tools(const Value: TArray<TJSONObject>): TChatParams;
begin
  var JSONTools := TJSONArray.Create;
  for var Item in Value do
    JSONTools.Add(Item);
  Result := TChatParams(Add('tools', JSONTools));
end;

function TChatParams.ToolChoice(const Value: TToolChoiceType): TChatParams;
begin
  Result := TChatParams(Add('tool_choice', Value.ToString));
end;

function TChatParams.ToolChoice(const Value: string): TChatParams;
begin
  Result := TChatParams(Add('tool_choice', TToolsChoice.New(Value).Detach));
end;

function TChatParams.ToolChoice(const Value: TToolsChoice): TChatParams;
begin
  Result := TChatParams(Add('tool_choice', Value.Detach));
end;

function TChatParams.Tools(const Value: TArray<IFunctionCore>): TChatParams;
begin
  var JSONTools := TJSONArray.Create;
  for var Item in Value do
    JSONTools.Add(Item.ToJson);
  Result := TChatParams(Add('tools', JSONTools));
end;

function TChatParams.TopLogprobs(const Value: Integer): TChatParams;
begin
  Result := TChatParams(Add('top_logprobs', Value));
end;

function TChatParams.TopP(const Value: Double): TChatParams;
begin
  Result := TChatParams(Add('top_p', Value));
end;

function TChatParams.User(const Value: String): TChatParams;
begin
  Result := TChatParams(Add('user', Value));
end;

{ TChatRoute }

procedure TChatRoute.AsynCreate(ParamProc: TProc<TChatParams>;
  CallBacks: TFunc<TAsynChat>);
begin
  with TAsynCallBackExec<TAsynChat, TChat>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TChat
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TChatRoute.AsynCreateStream(ParamProc: TProc<TChatParams>;
  CallBacks: TFunc<TAsynChatStream>);
begin
  var CallBackParams := TUseParamsFactory<TAsynChatStream>.CreateInstance(CallBacks);

  var Sender := CallBackParams.Param.Sender;
  var OnStart := CallBackParams.Param.OnStart;
  var OnSuccess := CallBackParams.Param.OnSuccess;
  var OnProgress := CallBackParams.Param.OnProgress;
  var OnError := CallBackParams.Param.OnError;
  var OnCancellation := CallBackParams.Param.OnCancellation;
  var OnDoCancel := CallBackParams.Param.OnDoCancel;

  var Task: ITask := TTask.Create(
        procedure()
        begin
            {--- Pass the instance of the current class in case no value was specified. }
            if not Assigned(Sender) then
              Sender := Self;

            {--- Trigger OnStart callback }
            if Assigned(OnStart) then
              TThread.Queue(nil,
                procedure
                begin
                  OnStart(Sender);
                end);
            try
              var Stop := False;

              {--- Processing }
              CreateStream(ParamProc,
                procedure (var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
                begin
                  {--- Check that the process has not been canceled }
                  if Assigned(OnDoCancel) then
                    TThread.Queue(nil,
                        procedure
                        begin
                          Stop := OnDoCancel();
                        end);
                  if Stop then
                    begin
                      {--- Trigger when processus was stopped }
                      if Assigned(OnCancellation) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnCancellation(Sender)
                        end);
                      Cancel := True;
                      Exit;
                    end;
                  if not IsDone and Assigned(Chat) then
                    begin
                      var LocalChat := Chat;
                      Chat := nil;

                      {--- Triggered when processus is progressing }
                      if Assigned(OnProgress) then
                        TThread.Synchronize(TThread.Current,
                        procedure
                        begin
                          try
                            OnProgress(Sender, LocalChat);
                          finally
                            {--- Makes sure to release the instance containing the data obtained
                                 following processing}
                            LocalChat.Free;
                          end;
                        end);
                    end
                  else
                  if IsDone then
                    begin
                      {--- Trigger OnEnd callback when the process is done }
                      if Assigned(OnSuccess) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnSuccess(Sender);
                        end);
                    end;
                end);
            except
              on E: Exception do
                begin
                  var Error := AcquireExceptionObject;
                  try
                    var ErrorMsg := (Error as Exception).Message;

                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(OnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        OnError(Sender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
        end);
  Task.Start;
end;

function TChatRoute.Create(ParamProc: TProc<TChatParams>): TChat;
begin
  Result := API.Post<TChat, TChatParams>('chat/completions', ParamProc);
end;

function TChatRoute.CreateStream(ParamProc: TProc<TChatParams>;
  Event: TChatEvent): Boolean;
var
  Response: TStringStream;
  RetPos: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    RetPos := 0;
    Result := API.Post<TChatParams>('chat/completions', ParamProc, Response,
      procedure(const Sender: TObject; AContentLength: Int64; AReadCount: Int64; var AAbort: Boolean)
      var
        IsDone: Boolean;
        Data: string;
        Chat: TChat;
        TextBuffer: string;
        Line: string;
        Ret: Integer;
      begin
        try
          TextBuffer := Response.DataString;
        except
          on E: EEncodingError do
            Exit;
        end;

        repeat
          Ret := TextBuffer.IndexOf(#10, RetPos);
          if Ret < 0 then
            Continue;
          Line := TextBuffer.Substring(RetPos, Ret - RetPos);
          RetPos := Ret + 1;

          if Line.IsEmpty or Line.StartsWith(#10) then
            Continue;
          Chat := nil;
          Data := Line.Replace('data: ', '').Trim([' ', #13, #10]);
          IsDone := Data = '[DONE]';

          if not IsDone then
          try
            Chat := TJson.JsonToObject<TChat>(Data);
          except
            Chat := nil;
          end;

          try
            Event(Chat, IsDone, AAbort);
          finally
            Chat.Free;
          end;
        until Ret < 0;

      end);
  finally
    Response.Free;
  end;
end;

{ TChatChoice }

destructor TChatChoice.Destroy;
begin
  if Assigned(FMessage) then
    FMessage.Free;
  if Assigned(FDelta) then
    FDelta.Free;
  if Assigned(FLogprobs) then
    FLogprobs.Free;
  inherited;
end;

{ TChat }

destructor TChat.Destroy;
begin
  for var Item in FChoices do
    Item.Free;
  if Assigned(FUsage) then
    FUsage.Free;
  if Assigned(FXGroq) then
    FXGroq.Free;
  inherited;
end;

{ TToolsChoice }

function TToolsChoice.&Function(const Value: string): TToolsChoice;
begin
  Result := TToolsChoice(Add('function', TJSONObject.Create.AddPair('naem', Value)));
end;

class function TToolsChoice.New(const Value: string): TToolsChoice;
begin
  Result := TToolsChoice.Create.&Type('function').&Function(Value);
end;

function TToolsChoice.&Type(const Value: string): TToolsChoice;
begin
  Result := TToolsChoice(Add('type', Value));
end;

{ TToolChoiceTypeHelper }

function TToolChoiceTypeHelper.ToString: string;
begin
  case Self of
    none:
      Exit('none');
    auto:
      Exit('auto');
    required:
      Exit('required');
  end;
end;

{ TContentParams }

function TContentParams.&Type(const Value: TContentType): TContentParams;
begin
  Result := TContentParams(Add('type', Value.ToString));
end;

class function TContentParams.AddImageFile(const Value: string): TContentParams;
begin
  Result := TContentParams.Create.&Type(TContentType.imageUrl).ImageUrl(Value);
end;

class function TContentParams.AddText(const Value: string): TContentParams;
begin
  Result := TContentParams.Create.&Type(TContentType.text).Text(Value);
end;

function TContentParams.ImageUrl(const Value: string): TContentParams;
begin
  Result := TContentParams(Add('image_url', TJSONObject.Create.AddPair('url', ImageDataProvider(Value))));
end;

function TContentParams.Text(const Value: string): TContentParams;
begin
  Result := TContentParams(Add('text', Value));
end;

{ TContentTypeHelper }

function TContentTypeHelper.ToString: string;
begin
  case Self of
    text:
      Exit('text');
    imageUrl:
      Exit('image_url');
  end;
end;

{ TFinishReasonTypeHelper }

class function TFinishReasonTypeHelper.Create(
  const Value: string): TFinishReasonType;
begin
  var index :=  IndexStr(Value.ToLower, ['stop', 'length', 'content_filter', 'tool_calls', 'function_call']);
  if index = -1 then
    raise Exception.Create('Finish reason type unknown.');
  Result := TFinishReasonType(index);
end;

function TFinishReasonTypeHelper.ToString: string;
begin
  case Self of
    stop:
      Exit('stop');
    length:
      Exit('length');
    content_filter:
      Exit('content_filter');
    tool_calls:
      Exit('tool_calls');
    function_call:
      Exit('function_call');
  end;
end;

{ TFinishReasonTypeInterceptor }

function TFinishReasonTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TFinishReasonType>.ToString;
end;

procedure TFinishReasonTypeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TFinishReasonType.Create(Arg)));
end;

{ TLogprobs }

destructor TLogprobs.Destroy;
begin
  for var Item in FContent do
    Item.Free;
  for var Item in FRefusal do
    Item.Free;
  inherited;
end;

{ TLogprobsContent }

destructor TLogprobsContent.Destroy;
begin
  for var Item in FTopLogprobs do
    Item.Free;
  inherited;
end;

{ TToolCall }

destructor TToolCall.Destroy;
begin
  if Assigned(FFunction) then
    FFunction.Free;
  inherited;
end;

{ TChatMessage }

destructor TChatMessage.Destroy;
begin
  for var Item in FToolCalls do
    Item.Free;
  inherited;
end;

{ TResponseFormatHelper }

function TResponseFormatHelper.ToString: string;
begin
  case Self of
    to_text:
      Exit('text');
    to_json_object:
      Exit('json_object');
  end;
end;

end.

unit Groq.Common;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGroqCloud
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

type
  TXGroq = class
  private
    FId: string;
  public
    property Id: string read FId write FId;
  end;

implementation

end.

unit Groq.Errors;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGroqCloud
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  REST.Json.Types;

type
  TErrorCore = class abstract
  end;

  /// <summary>
  /// See at https://console.groq.com/docs/errors
  /// </summary>
  TErrorObject = class
  private
    FType: string;
    FMessage: string;
  public
    /// <summary>
    /// A classification of the error type, such as "invalid_request_error",
    /// indicating the general category of the problem encountered.
    /// </summary>
    property &Type: string read FType write FType;
    /// <summary>
    /// A descriptive message explaining the nature of the error, intended
    /// to aid developers in diagnosing the problem.
    /// </summary>
    property Message: string read FMessage write FMessage;
  end;

  /// <summary>
  /// Error Object Structure
  /// The error object follows a specific structure, providing a clear and actionable
  /// message alongside an error type classification
  /// </summary>
  TError = class(TErrorCore)
  private
    FError: TErrorObject;
  public
    /// <summary>
    /// The primary container for error details.
    /// </summary>
    property Error: TErrorObject read FError write FError;
    destructor Destroy; override;
  end;

implementation

{ TError }

destructor TError.Destroy;
begin
  if Assigned(FError) then
    FError.Free;
  inherited;
end;

end.

unit Groq.Functions.Core;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGroqCloud
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.JSON;

type
  /// <summary>
  /// Interface defining the core structure and functionality of a function in the system.
  /// </summary>
  /// <remarks>
  /// This interface outlines the basic properties and methods that any function implementation must include.
  /// </remarks>
  IFunctionCore = interface
    ['{DA7C210F-8940-48E9-B933-1AEBFD7A81B8}']
    /// <summary>
    /// Retrieves the description of the function.
    /// </summary>
    function GetDescription: string;
    /// <summary>
    /// Retrieves the name of the function.
    /// </summary>
    function GetName: string;
    /// <summary>
    /// Retrieves the InputSchema required by the function, represented as a JSON schema.
    /// </summary>
    function GetInputSchema: string;
    /// <summary>
    /// Executes the function with the provided arguments and returns the result as a string.
    /// </summary>
    /// <param name="Arguments">The arguments passed to the function in JSON format.</param>
    /// <returns>The result of the function execution as a string.</returns>
    function Execute(const Arguments: string): string;
     /// <summary>
    /// Converts the TFunctionCore instance to a JSON object that contains its type and representation.
    /// </summary>
    /// <returns>A JSON object representing the function instance.</returns>
    function ToJson: TJSONObject;
    /// <summary>
    /// Creates a string representation of the TFunctionCore instance in JSON format, including its description, name, and InputSchema.
    /// </summary>
    /// <returns>A string representation of the function in JSON format.</returns>
    function ToString: string;
    /// <summary>
    /// A brief description of the function's purpose, used by the model to determine when and how to call the function.
    /// </summary>
    property Description: string read GetDescription;
    /// <summary>
    /// The unique identifier of the function that will be called. It must only contain characters from a-z, A-Z, 0-9, underscores, or dashes, and should not exceed 64 characters in length.
    /// </summary>
    property Name: string read GetName;
    //// <summary>
    /// The InputSchema required by the function, specified as a JSON schema. If no InputSchema are required, use the schema: {"type": "object", "properties": {}}.
    /// </summary>
    property InputSchema: string read GetInputSchema;
  end;

  /// <summary>
  /// Abstract base class for implementing core function behavior.
  /// </summary>
  /// <remarks>
  /// This class provides basic implementations for some methods and defines the structure that derived classes must follow.
  /// </remarks>
  TFunctionCore = class abstract(TinterfacedObject, IFunctionCore)
  protected
    /// <summary>
    /// Retrieves the description of the function. Derived classes must implement this method.
    /// </summary>
    function GetDescription: string; virtual; abstract;
     /// <summary>
    /// Retrieves the name of the function. Derived classes must implement this method.
    /// </summary>
    function GetName: string; virtual; abstract;
    /// <summary>
    /// Retrieves the InputSchema required by the function, represented as a JSON schema. Derived classes must implement this method.
    /// </summary>
    function GetInputSchema: string; virtual; abstract;
  public
    /// <summary>
    /// Executes the function with the provided arguments and returns the result as a string. Derived classes must implement this method.
    /// </summary>
    /// <param name="Arguments">The arguments passed to the function in JSON format.</param>
    /// <returns>The result of the function execution as a string.</returns>
    function Execute(const Arguments: string): string; virtual; abstract;
    /// <summary>
    /// Converts the TFunctionCore instance to a JSON object that contains its type and representation.
    /// </summary>
    /// <returns>A JSON object representing the function instance.</returns>
    function ToJson: TJSONObject;
    /// <summary>
    /// Creates a string representation of the TFunctionCore instance in JSON format, including its description, name, and InputSchema.
    /// </summary>
    /// <returns>A string representation of the function in JSON format.</returns>
    function ToString: string; override;
    /// <summary>
    /// A brief description of the function's purpose, used by the model to determine when and how to call the function.
    /// </summary>
    property Description: string read GetDescription;
    /// <summary>
    /// The unique identifier of the function that will be called. It must only contain characters from a-z, A-Z, 0-9, underscores, or dashes, and should not exceed 64 characters in length.
    /// </summary>
    property Name: string read GetName;
    /// <summary>
    /// The InputSchema required by the function, specified as a JSON schema. If no InputSchema are required, use the schema: {"type": "object", "properties": {}}.
    /// </summary>
    property InputSchema: string read GetInputSchema;
  end;

implementation

{ TFunctionCore }

function TFunctionCore.ToJson: TJSONObject;
begin
  Result := TJSONObject.Create;
  try
    Result.AddPair('type', 'function');
    var JSONFunction := TJSONObject.Create
          .AddPair('name', Name)
          .AddPair('description', Description)
          .AddPair('parameters', TJSONObject.ParseJSONValue(InputSchema));
    Result.AddPair('function', JSONFunction);
  except
    on E: Exception do
      begin
        Result.Free;
        raise;
      end;
  end;
end;

function TFunctionCore.ToString: string;
begin
  with TStringWriter.Create do
    try
      Write('"type": "%s"', ['function']);
      Write(',"function": {');
      Write('"name": "%s"', [Name]);
      Write(',"description": "%s"', [Description]);
      Write(',"parameters": %s}', [InputSchema]);
      Result := Format('{%s}', [ToString]);
    finally
      Free;
    end;

  {--- Format output }
  var JSON := TJSONObject.ParseJSONValue(Result);
  try
    Result := JSON.Format();
  finally
    JSON.Free;
  end;
end;

end.

unit Groq.Functions.Example;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGroqCloud
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, Groq.Functions.Core, Groq.Schema;

type
  TWeatherReportFunction = class(TFunctionCore)
  protected
    function GetDescription: string; override;
    function GetName: string; override;
    function GetInputSchema: string; override;
  public
    function Execute(const Arguments: string): string; override;
    class function CreateInstance: IFunctionCore;
  end;

implementation

uses
  System.StrUtils, System.JSON;

{ TWeatherReportFunction }

class function TWeatherReportFunction.CreateInstance: IFunctionCore;
begin
  Result := TWeatherReportFunction.create;
end;

function TWeatherReportFunction.Execute(const Arguments: string): string;

  procedure AddToReport(const Value: TJSONObject;
    Temperature: string; UnitType: string; Forecast: TArray<string>);
  begin
    Value.AddPair('temperature', TJSONString.Create(Temperature + UnitType));
    Value.AddPair('forecast', TJSONArray.Create(Forecast[0], Forecast[1]));
  end;

  function ToTemperature(Value: Double; TempUnit: string): string;
  begin
    case IndexStr(TempUnit.ToLower, ['fahrenheit', 'celsius']) of
      0 : Value := (Value * 9/5) + 32;
    end;
    Result := FormatFloat('0,0', Value);
  end;

begin
  Result := EmptyStr;
  var Location := EmptyStr;
  var TempUnit := EmptyStr;
  var index := -1;

  {--- Parse arguments to retrieve parameters }
  var JSON := TJSONObject.ParseJSONValue(Arguments) as TJSONObject;
  try
    if Assigned(JSON) then
    try
      Location := JSON.GetValue('location', '');
      TempUnit := JSON.GetValue('unit', '');
    finally
      JSON.Free;
    end;
  except
    Location := EmptyStr;
  end;

  {--- Stop the treatment if location is empty }
  if Location.IsEmpty then
    Exit;

  {--- Build the response }
  JSON := TJSONObject.Create;
  try
    JSON.AddPair('location', Location);
    if Location.ToLower.Contains('san francisco') then
      index := 0 else
    if Location.ToLower.Contains('paris') then
      index := 1;
    case index of
      0 :
        AddToReport(JSON, ToTemperature(24, TempUnit), '°' + TempUnit, [
          'sunny',
          'windy']);
      1 :
        AddToReport(JSON, ToTemperature(11, TempUnit), '°' + TempUnit, [
          'rainy',
          'low visibility but sunny in the late afternoon or early evening']);
    end;
    Result := JSON.ToJSON;
  finally
    JSON.Free;
  end;
end; {Execute}

function TWeatherReportFunction.GetDescription: string;
begin
  Result := 'Get the current weather in a given location.';
end;

function TWeatherReportFunction.GetName: string;
begin
  Result := 'get_weather';
end;

function TWeatherReportFunction.GetInputSchema: string;
begin
  Result :=
    '{'+
    '"type": "object",'+
    '"properties": {'+
         '"location": {'+
             '"type": "string",'+
             '"description": "The city and department, e.g. Marseille, 13"'+
         '},'+
         '"unit": {'+
             '"type": "string",'+
             '"enum": ["fahrenheit", "celsius"]'+
         '}'+
     '},'+
     '"required": ["location", "unit"]'+
    '}';

  {--- If we use the TSchemaParams class defined in the Groq.Schema unit }
//  var Schema := TSchemaParams.New(
//    procedure (var Params: TSchemaParams)
//    begin
//      Params.&Type(stOBJECT);
//      Params.Properties('properties',
//        procedure (var Params: TSchemaParams)
//        begin
//          Params.Properties('location',
//            procedure (var Params: TSchemaParams)
//            begin
//              Params.&Type(stSTRING);
//              Params.Description('The city and state, e.g. Marseille, 13');
//            end);
//          Params.Properties('unit',
//            procedure (var Params: TSchemaParams)
//            begin
//              Params.&Type(stSTRING);
//              Params.Enum(['celsius', 'fahrenheit']);
//            end);
//        end);
//      Params.Required(['location', 'unit']);
//    end);
//  Result := Schema.ToJsonString(True);
end;

end.

unit Groq.Models;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGroqCloud
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, REST.Json.Types,
  Groq.API.Params, Groq.API, Groq.Async.Params, Groq.Async.Support;

type
  /// <summary>
  /// Represents a language model provided by GroqCloud.
  /// </summary>
  /// <remarks>
  /// The <c>TModel</c> class contains detailed information about a specific language model available through the GroqCloud API, including its identifier, owner, creation time, and other metadata.
  /// </remarks>
  TModel = class
  private
    FId: string;
    FObject: string;
    FCreated: Int64;
    [JsonNameAttribute('owned_by')]
    FOwnedBy: string;
    FActive: Boolean;
    [JsonNameAttribute('context_window')]
    FContextWindow: Int64;
    [JsonNameAttribute('public_apps')]
    FPublicApps: string;
  public
    /// <summary>
    /// Gets or sets the unique identifier of the model.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Gets or sets the object type, typically 'model'.
    /// </summary>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// Gets or sets the creation timestamp of the model.
    /// </summary>
    /// <remarks>
    /// The timestamp is represented as a Unix epoch time in seconds.
    /// </remarks>
    property Created: Int64 read FCreated write FCreated;
    /// <summary>
    /// Gets or sets the owner of the model.
    /// </summary>
    property OwnedBy: string read FOwnedBy write FOwnedBy;
    /// <summary>
    /// Gets or sets a value indicating whether the model is active.
    /// </summary>
    property Active: Boolean read FActive write FActive;
    /// <summary>
    /// Gets or sets the context window size of the model.
    /// </summary>
    /// <remarks>
    /// The context window size determines the maximum number of tokens the model can process at once.
    /// </remarks>
    property ContextWindow: Int64 read FContextWindow write FContextWindow;
    /// <summary>
    /// Gets or sets the public applications associated with the model.
    /// </summary>
    property PublicApps: string read FPublicApps write FPublicApps;
  end;

  /// <summary>
  /// Represents a collection of language models provided by GroqCloud.
  /// </summary>
  /// <remarks>
  /// The <c>TModels</c> class contains an array of <c>TModel</c> instances and metadata about the collection.
  /// </remarks>
  TModels = class
  private
    FObject: string;
    FData: TArray<TModel>;
  public
    /// <summary>
    /// Gets or sets the object type, typically 'list'.
    /// </summary>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// Gets or sets the array of models.
    /// </summary>
    property Data: TArray<TModel> read FData write FData;
    /// <summary>
    /// Destroys the instance of <c>TModels</c> and releases all resources.
    /// </summary>
    /// <remarks>
    /// The destructor frees all <c>TModel</c> instances contained in the <c>Data</c> array.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous callbacks for a model search request using <c>TModel</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynModel</c> type extends the <c>TAsynParams&lt;TModel&gt;</c> record to handle the lifecycle of an asynchronous model operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking model search operations and is specifically tailored for scenarios where multiple model choices are required.
  /// </remarks>
  TAsynModel = TAsynCallBack<TModel>;

  /// <summary>
  /// Manages asynchronous callbacks for a model search request that returns a collection of models using <c>TModels</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynModels</c> type extends the <c>TAsynCallBack&lt;TModels&gt;</c> record to handle the lifecycle of an asynchronous operation
  /// involving multiple models. This includes event handlers that trigger at key points in the process, such as when the operation begins,
  /// completes successfully, or encounters an error.
  /// This structure is designed for non-blocking operations that return a collection of models. The <c>TModels</c> type represents
  /// a collection of <c>TModel</c> instances, making this type useful when working with multiple model objects in asynchronous requests.
  /// </remarks>
  TAsynModels = TAsynCallBack<TModels>;

  /// <summary>
  /// Gère les routes API liées à la récupération de modèles et fournit des méthodes pour répertorier ou récupérer des modèles spécifiques.
  /// </summary>
  /// <remarks>
  /// La classe <c>TModelsRoute</c> propose des méthodes pour récupérer des modèles à partir de l'API.
  /// Elle comprend la méthode <c>List</c> qui permet de répertorier tous les modèles, de récupérer des résultats ou de récupérer un modèle spécifique par son nom.
  /// Cette classe interagit avec l'API sous-jacente pour récupérer les données du modèle et renvoie des instances de <c>TModels</c> ou <c>TModel</c>.
  /// </remarks>
  TModelsRoute = class(TGroqAPIRoute)
  public
    /// <summary>
    /// Asynchronously retrieves the list of all available models.
    /// </summary>
    /// <param name="CallBacks">
    /// A <c>TFunc&lt;TAsynModels&gt;</c> representing the callback to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// This method sends a request to the API to fetch all available models asynchronously.
    /// The <paramref name="CallBacks"/> function is invoked when the operation completes,
    /// either successfully or with an error.
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var GroqCloud := TGroqFactory.CreateInstance(BaererKey);
    /// GroqCloud.Models.AsynList(
    ///    function : TAsynModels
    ///    begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; List: TModels)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///    end);
    /// </code>
    /// </remarks>
    procedure AsynList(CallBacks: TFunc<TAsynModels>);
    /// <summary>
    /// Asynchronously retrieves a specific model by its unique identifier.
    /// </summary>
    /// <param name="ModelId">
    /// The unique identifier of the model to retrieve.
    /// </param>
    /// <param name="CallBacks">
    /// A <c>TFunc&lt;TAsynModel&gt;</c> representing the callback to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// This method sends a request to the API to fetch a specific model asynchronously.
    /// The <paramref name="CallBacks"/> function is invoked when the operation completes,
    /// either successfully or with an error.
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var GroqCloud := TGroqFactory.CreateInstance(BearerKey);
    /// GroqCloud.Models.AsynRetrieve('model-id',
    ///   function: TAsynModel
    ///   begin
    ///     Result.Sender := my_display_component;
    ///
    ///     Result.OnStart :=
    ///       procedure(Sender: TObject)
    ///       begin
    ///         // Handle the start
    ///       end;
    ///
    ///     Result.OnSuccess :=
    ///       procedure(Sender: TObject; Model: TModel)
    ///       begin
    ///         // Handle the retrieved model
    ///       end;
    ///
    ///     Result.OnError :=
    ///       procedure(Sender: TObject; Error: string)
    ///       begin
    ///         // Handle the error message
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsynRetrieve(const ModelId: string; CallBacks: TFunc<TAsynModel>);
    /// <summary>
    /// Retrieves the list of all available models.
    /// </summary>
    /// <returns>
    /// A <c>TModels</c> object containing the list of models.
    /// </returns>
    /// <remarks>
    /// This method sends a request to the API to fetch all available models without pagination or filtering.
    /// It returns a <c>TModels</c> object containing the collection of models.
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var GroqCloud := TGroqFactory.CreateInstance(BaererKey);
    /// var List := GroqCloud.Models.List;
    /// try
    ///   for var Item in List.Models do
    ///     WriteLn( Item.DisplayName );
    /// finally
    ///   List.Free;
    /// end;
    /// </code>
    /// </remarks>
    function List: TModels;
    /// <summary>
    /// Retrieves a specific model by its unique identifier.
    /// </summary>
    /// <param name="ModelId">
    /// The unique identifier of the model to retrieve.
    /// </param>
    /// <returns>
    /// A <c>TModel</c> object representing the retrieved model.
    /// </returns>
    /// <remarks>
    /// This method sends a request to the API to fetch a specific model synchronously.
    /// It returns a <c>TModel</c> object containing the model's details.
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var GroqCloud := TGroqFactory.CreateInstance(BearerKey);
    /// var Model := GroqCloud.Models.Retrieve('model-id');
    /// try
    ///   WriteLn('Model Name: ', Model.Id);
    ///   // Process the model
    /// finally
    ///   Model.Free;
    /// end;
    /// </code>
    /// </remarks>
    function Retrieve(const ModelId: string): TModel;
  end;

implementation

{ TModels }

destructor TModels.Destroy;
begin
  for var Item in FData do
    Item.Free;
  inherited;
end;

{ TModelsRoute }

procedure TModelsRoute.AsynList(CallBacks: TFunc<TAsynModels>);
begin
  with TAsynCallBackExec<TAsynModels, TModels>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TModels
      begin
        Result := Self.List;
      end);
  finally
    Free;
  end;
end;

procedure TModelsRoute.AsynRetrieve(const ModelId: string;
  CallBacks: TFunc<TAsynModel>);
begin
  with TAsynCallBackExec<TAsynModel, TModel>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TModel
      begin
        Result := Self.Retrieve(ModelId);
      end);
  finally
    Free;
  end;
end;

function TModelsRoute.List: TModels;
begin
  Result := API.Get<TModels>('models');
end;

function TModelsRoute.Retrieve(const ModelId: string): TModel;
begin
  Result := API.Get<TModel>(Format('models/%s', [ModelId]));
end;

end.

unit Groq.NetEncoding.Base64;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGroqCloud
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.NetEncoding, System.Net.Mime, System.IOUtils;

  /// <summary>
  /// Encodes the content of a file into a Base64-encoded string.
  /// </summary>
  /// <param name="FileLocation">The full path to the file that will be encoded.</param>
  /// <returns>A Base64-encoded string representing the content of the file.</returns>
  /// <exception cref="Exception">Thrown if the specified file does not exist at the provided location.</exception>
  /// <remarks>
  /// This method reads the file from the specified location and converts it to a Base64 string.
  /// It uses different encoding methods depending on the version of the RTL.
  /// For RTL version 35.0 and later, it uses <c>TNetEncoding.Base64String.Encode</c>,
  /// and for earlier versions, it uses <c>TNetEncoding.Base64.Encode</c>.
  /// </remarks>
  function EncodeBase64(FileLocation : string) : WideString;
  /// <summary>
  /// Retrieves the MIME type of the specified file based on its location.
  /// </summary>
  /// <param name="FileLocation">The full path to the file whose MIME type is to be resolved.</param>
  /// <returns>
  /// A string representing the MIME type of the file.
  /// If the file does not exist, an exception will be raised.
  /// </returns>
  /// <exception cref="Exception">
  /// Thrown if the specified file cannot be found at the provided location.
  /// </exception>
  /// <remarks>
  /// This method checks if the specified file exists and retrieves its MIME type
  /// using the <c>TMimeTypes.Default.GetFileInfo</c> method.
  /// Ensure the provided path is valid before calling this function.
  /// </remarks>
  function ResolveMimeType(const FileLocation: string): string;
  /// <summary>
  /// Retrieves the size of the specified file in bytes.
  /// </summary>
  /// <param name="FileLocation">
  /// The full path to the file whose size is to be determined.
  /// </param>
  /// <returns>
  /// An <c>Int64</c> value representing the file size in bytes.
  /// </returns>
  /// <exception cref="Exception">
  /// Raised if the specified file cannot be accessed or does not exist at the provided location.
  /// </exception>
  /// <remarks>
  /// This function verifies the existence of the specified file and, if accessible, retrieves its size
  /// using the <c>TFile.GetSize</c> method. Ensure that the file path is valid and accessible
  /// before calling this function.
  /// </remarks>
  function FileSize(const FileLocation: string): Int64;
  /// <summary>
  /// Provides the image data as a Base64-encoded string with a MIME type or as a direct URL.
  /// </summary>
  /// <param name="FileLocation">
  /// The full path to the image file on the local filesystem or a URL.
  /// </param>
  /// <returns>
  /// A string representing the image data:
  /// <para>
  /// - If <paramref name="FileLocation"/> is a local file path, it returns a data URI with a MIME type and Base64-encoded content.
  /// </para>
  /// <para>
  /// - If <paramref name="FileLocation"/> is a URL (starting with "http"), it returns the URL as-is.
  /// </para>
  /// </returns>
  /// <exception cref="Exception">
  /// Raised if the file does not exist at the provided local file path.
  /// </exception>
  /// <remarks>
  /// This function checks if <paramref name="FileLocation"/> is a URL by verifying if it starts with "http".
  /// If it is a URL, it returns it directly as the output.
  /// For local files, it verifies the file's existence, retrieves the MIME type, and encodes the content in Base64 format
  /// to create a data URI for embedding purposes. This data URI can then be used directly in HTML or other contexts where
  /// embedded image data is required.
  /// </remarks>
  function ImageDataProvider(FileLocation : string) : WideString;

implementation

function EncodeBase64(FileLocation : string): WideString;
begin
  if not FileExists(FileLocation) then
    raise Exception.CreateFmt('File not found : %s', [FileLocation]);

  var Stream := TMemoryStream.Create;
  var StreamOutput := TStringStream.Create('', TEncoding.UTF8);
  try
    Stream.LoadFromFile(FileLocation);
    Stream.Position := 0;
    {$IF RTLVersion >= 35.0}
    TNetEncoding.Base64String.Encode(Stream, StreamOutput);
    {$ELSE}
    TNetEncoding.Base64.Encode(Stream, StreamOutput);
    {$ENDIF}
    Result := StreamOutput.DataString;
  finally
    Stream.Free;
    StreamOutput.Free;
  end;
end;

function ResolveMimeType(const FileLocation: string): string;
begin
  if not FileExists(FileLocation) then
    raise Exception.CreateFmt('File not found: %s', [FileLocation]);

  var LKind: TMimeTypes.TKind;
  TMimeTypes.Default.GetFileInfo(FileLocation, Result, LKind);
end;

function FileSize(const FileLocation: string): Int64;
begin
  try
    FileSize := TFile.GetSize(FileLocation);
  except
    raise;
  end;
end;

function ImageDataProvider(FileLocation : string) : WideString;
begin
  if FileLocation.ToLower.StartsWith('http') then
    Result := FileLocation
  else
  if FileExists(FileLocation) then
    Result := Format('data:%s;base64,%s', [ResolveMimeType(FileLocation), EncodeBase64(FileLocation)])
  else
    raise Exception.CreateFmt('File not found : %s', [FileLocation]);
end;

end.

unit Groq;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGroqCloud
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Net.URLClient, Groq.API, Groq.Chat, Groq.Models,
  Groq.Audio;

type
  /// <summary>
  /// The <c>IGroq</c> interface provides access to the various features and routes of the Groq AI API.
  /// This interface allows interaction with different services such as agents, chat, code completion,
  /// embeddings, file management, fine-tuning, and model information.
  /// </summary>
  /// <remarks>
  /// This interface should be implemented by any class that wants to provide a structured way of accessing
  /// the Groq AI services. It includes methods and properties for authenticating with an API key,
  /// configuring the base URL, and accessing different API routes.
  ///
  /// To use this interface, instantiate a class that implements it, set the required properties such as
  /// <see cref="Token"/> and <see cref="BaseURL"/>, and call the relevant methods for the desired operations.
  /// <code>
  ///   var Groq: IGroq := TGroq.Create(API_TOKEN);
  /// </code>
  /// <seealso cref="TGroq"/>
  /// </remarks>
  IGroq = interface
    ['{6C323A77-2CD8-429B-BAA3-871CFF307C90}']
    function GetAPI: TGroqAPI;
    procedure SetToken(const Value: string);
    function GetToken: string;
    function GetBaseUrl: string;
    procedure SetBaseUrl(const Value: string);
    function GetChatRoute: TChatRoute;
    function GetModelsRoute: TModelsRoute;
    function GetAudioRoute: TAudioRoute;

    /// <summary>
    /// the main API object used for making requests.
    /// </summary>
    /// <returns>
    /// An instance of TGroqAPI for making API calls.
    /// </returns>
    property API: TGroqAPI read GetAPI;
    /// Sets or retrieves the API token for authentication.
    /// </summary>
    /// <param name="Value">
    /// The API token as a string.
    /// </param>
    /// <returns>
    /// The current API token.
    /// </returns>
    property Token: string read GetToken write SetToken;
    /// <summary>
    /// Sets or retrieves the base URL for API requests.
    /// Default is https://api.Groq.com/v1
    /// </summary>
    /// <param name="Value">
    /// The base URL as a string.
    /// </param>
    /// <returns>
    /// The current base URL.
    /// </returns>
    property BaseURL: string read GetBaseUrl write SetBaseUrl;
    /// <summary>
    /// Provides access to the chat completion API.
    /// Allows for interaction with models fine-tuned for instruction-based dialogue.
    /// </summary>
    /// <returns>
    /// An instance of TChatRoute for chat-related operations.
    /// </returns>
    property Chat: TChatRoute read GetChatRoute;
    /// <summary>
    /// Provides access to the models API.
    /// Allows for retrieving and managing available models.
    /// </summary>
    /// <returns>
    /// An instance of TModelsRoute for model-related operations.
    /// </returns>
    property Models: TModelsRoute read GetModelsRoute;
    /// <summary>
    /// Provides access to the audio API.
    /// Allows for speech transcription or translation.
    /// </summary>
    /// <returns>
    /// An instance of TAudioRoute for audio-related operations.
    /// </returns>
    property Audio: TAudioRoute read GetAudioRoute;
  end;

  /// <summary>
  /// The <c>TGroqFactory</c> class is responsible for creating instances of
  /// the <see cref="IGroq"/> interface. It provides a factory method to instantiate
  /// the interface with a provided API token and optional header configuration.
  /// </summary>
  /// <remarks>
  /// This class provides a convenient way to initialize the <see cref="IGroq"/> interface
  /// by encapsulating the necessary configuration details, such as the API token and header options.
  /// By using the factory method, users can quickly create instances of <see cref="IGroq"/> without
  /// manually setting up the implementation details.
  /// </remarks>
  TGroqFactory = class
    /// <summary>
    /// Creates an instance of the <see cref="IGroq"/> interface with the specified API token
    /// and optional header configuration.
    /// </summary>
    /// <param name="AToken">
    /// The API token as a string, required for authenticating with Groq API services.
    /// </param>
    /// <param name="Option">
    /// An optional header configuration of type <see cref="THeaderOption"/> to customize the request headers.
    /// The default value is <c>THeaderOption.none</c>.
    /// </param>
    /// <returns>
    /// An instance of <see cref="IGroq"/> initialized with the provided API token and header option.
    /// </returns>
    /// <remarks>
    /// Code example
    /// <code>
    /// var GroqCloud := TGroqFactory.CreateInstance(BaererKey);
    ///
    /// </code>
    /// WARNING : Please take care to adjust the SCOPE of the <c>GroqCloud</c> interface in you application.
    /// </remarks>
    class function CreateInstance(const AToken: string): IGroq;
  end;

  /// <summary>
  /// The TGroq class provides access to the various features and routes of the Groq AI API.
  /// This class allows interaction with different services such as agents, chat, code completion,
  /// embeddings, file management, fine-tuning, and model information.
  /// </summary>
  /// <remarks>
  /// This class should be implemented by any class that wants to provide a structured way of accessing
  /// the Groq AI services. It includes methods and properties for authenticating with an API key,
  /// configuring the base URL, and accessing different API routes.
  /// <seealso cref="TGroq"/>
  /// </remarks>
  TGroq = class(TInterfacedObject, IGroq)
  strict private

  private
    FAPI: TGroqAPI;

    FChatRoute: TChatRoute;
    FModelsRoute: TModelsRoute;
    FAudioRoute: TAudioRoute;

    function GetAPI: TGroqAPI;
    function GetToken: string;
    procedure SetToken(const Value: string);
    function GetBaseUrl: string;
    procedure SetBaseUrl(const Value: string);

    function GetChatRoute: TChatRoute;
    function GetModelsRoute: TModelsRoute;
    function GetAudioRoute: TAudioRoute;

  public
    /// <summary>
    /// the main API object used for making requests.
    /// </summary>
    /// <returns>
    /// An instance of TGroqAPI for making API calls.
    /// </returns>
    property API: TGroqAPI read GetAPI;
    /// <summary>
    /// Sets or retrieves the API token for authentication.
    /// </summary>
    /// <param name="Value">
    /// The API token as a string.
    /// </param>
    /// <returns>
    /// The current API token.
    /// </returns>
    property Token: string read GetToken write SetToken;
    /// <summary>
    /// Sets or retrieves the base URL for API requests.
    /// Default is https://api.Groq.com/v1.
    /// </summary>
    /// <param name="Value">
    /// The base URL as a string.
    /// </param>
    /// <returns>
    /// The current base URL.
    /// </returns>
    property BaseURL: string read GetBaseUrl write SetBaseUrl;

  public
    /// <summary>
    /// Provides access to the chat completion API.
    /// Allows for interaction with models fine-tuned for instruction-based dialogue.
    /// </summary>
    /// <returns>
    /// An instance of TChatRoute for chat-related operations.
    /// </returns>
    property Chat: TChatRoute read GetChatRoute;
    /// <summary>
    /// Provides access to the models API.
    /// Allows for retrieving and managing available models.
    /// </summary>
    /// <returns>
    /// An instance of TModelsRoute for model-related operations.
    /// </returns>
    property Models: TModelsRoute read GetModelsRoute;
    /// <summary>
    /// Provides access to the audio API.
    /// Allows for speech transcription or translation.
    /// </summary>
    /// <returns>
    /// An instance of TAudioRoute for audio-related operations.
    /// </returns>
    property Audio: TAudioRoute read GetAudioRoute;
  public
    /// <summary>
    /// Initializes a new instance of the <see cref="TGroq"/> class with optional header configuration.
    /// </summary>
    /// <param name="Option">
    /// An optional parameter of type <see cref="THeaderOption"/> to configure the request headers.
    /// The default value is <c>THeaderOption.none</c>.
    /// </param>
    /// <remarks>
    /// This constructor is typically used when no API token is provided initially.
    /// The token can be set later via the <see cref="Token"/> property.
    /// </remarks>
    constructor Create; overload;
    /// <summary>
    /// Initializes a new instance of the <see cref="TGroq"/> class with the provided API token and optional header configuration.
    /// </summary>
    /// <param name="AToken">
    /// The API token as a string, required for authenticating with the Groq AI API.
    /// </param>
    /// <param name="Option">
    /// An optional parameter of type <see cref="THeaderOption"/> to configure the request headers.
    /// The default value is <c>THeaderOption.none</c>.
    /// </param>
    /// <remarks>
    /// This constructor allows the user to specify an API token at the time of initialization.
    /// </remarks>
    constructor Create(const AToken: string); overload;
    /// <summary>
    /// Releases all resources used by the current instance of the <see cref="TGroq"/> class.
    /// </summary>
    /// <remarks>
    /// This method is called to clean up any resources before the object is destroyed.
    /// It overrides the base <see cref="TInterfacedObject.Destroy"/> method.
    /// </remarks>
    destructor Destroy; override;
  end;

implementation

{ TGroq }

constructor TGroq.Create;
begin
  inherited Create;
  FAPI := TGroqAPI.Create;
end;

constructor TGroq.Create(const AToken: string);
begin
  Create;
  Token := AToken;
end;

destructor TGroq.Destroy;
begin
  FChatRoute.Free;
  FModelsRoute.Free;
  FAudioRoute.Free;
  inherited;
end;

function TGroq.GetAPI: TGroqAPI;
begin
  Result := FAPI;
end;

function TGroq.GetAudioRoute: TAudioRoute;
begin
  if not Assigned(FAudioRoute) then
    FAudioRoute := TAudioRoute.CreateRoute(API);
  Result := FAudioRoute;
end;

function TGroq.GetBaseUrl: string;
begin
  Result := FAPI.BaseURL;
end;

function TGroq.GetChatRoute: TChatRoute;
begin
  if not Assigned(FChatRoute) then
    FChatRoute := TChatRoute.CreateRoute(API);
  Result := FChatRoute;
end;

function TGroq.GetModelsRoute: TModelsRoute;
begin
  if not Assigned(FModelsRoute) then
    FModelsRoute := TModelsRoute.CreateRoute(API);
  Result := FModelsRoute;
end;

function TGroq.GetToken: string;
begin
  Result := FAPI.Token;
end;

procedure TGroq.SetBaseUrl(const Value: string);
begin
  FAPI.BaseURL := Value;
end;

procedure TGroq.SetToken(const Value: string);
begin
  FAPI.Token := Value;
end;

{ TGroqFactory }

class function TGroqFactory.CreateInstance(const AToken: string): IGroq;
begin
  Result := TGroq.Create(AToken);
end;

end.

unit Groq.Safety;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGroqCloud
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes;

type
  /// <summary>
  /// Harm Taxonomy and Policy
  /// </summary>
  THarmCategory = (
    /// <summary>
    /// Violent Crimes
    /// </summary>
    S1,
    /// <summary>
    /// Non-Violent Crimes
    /// </summary>
    S2,
    /// <summary>
    /// Sex-Related Crimes
    /// </summary>
    S3,
    /// <summary>
    /// Child Sexual Exploitation
    /// </summary>
    S4,
    /// <summary>
    /// Defamation
    /// </summary>
    S5,
    /// <summary>
    /// Specialized Advice
    /// </summary>
    S6,
    /// <summary>
    /// Privacy
    /// </summary>
    S7,
    /// <summary>
    /// Intellectual Property
    /// </summary>
    S8,
    /// <summary>
    /// Indiscriminate Weapons
    /// </summary>
    S9,
    /// <summary>
    /// Hate
    /// </summary>
    S10,
    /// <summary>
    /// Suicide & Self-Harm
    /// </summary>
    S11,
    /// <summary>
    /// Sexual Content
    /// </summary>
    S12,
    /// <summary>
    /// Elections
    /// </summary>
    S13,
    /// <summary>
    /// Code Interpreter Abuse
    /// </summary>
    S14
  );

  /// <summary>
  /// Helper record for the <c>THarmCategory</c> enumeration, providing utility methods for converting
  /// between <c>THarmCategory</c> values and their string representations.
  /// </summary>
  THarmCategoryHelper = record helper for THarmCategory
    /// <summary>
    /// Converts the current <c>THarmCategory</c> value to its corresponding string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>THarmCategory</c> value.
    /// </returns>
    function ToString(Full: Boolean = False): string;
    /// <summary>
    /// Converts a string representation of a <c>THarmCategory</c> into its corresponding enumeration value.
    /// </summary>
    /// <param name="Value">
    /// The string representing a <c>THarmCategory</c>.
    /// </param>
    /// <returns>
    /// The <c>THarmCategory</c> enumeration value that corresponds to the provided string.
    /// </returns>
    class function Create(const Value: string): THarmCategory; static;
  end;

  /// <summary>
  /// Represents safety information by categorizing harmful content based on predefined harm categories.
  /// </summary>
  /// <remarks>
  /// The <c>TSafety</c> record maintains two arrays. The <c>Harm</c> array contains short string representations of harm categories,
  /// while the <c>HarmFull</c> array contains full string descriptions of harm categories.
  /// It provides methods to create an instance from a comma or newline-separated string of category identifiers
  /// and to convert the safety information back to a string format.
  /// </remarks>
  TSafety = record
  private
    FHarm: TArray<string>;
    FHarmFull: TArray<string>;
  public
    /// <summary>
    /// Initializes a new instance of the <c>TSafety</c> record based on a string of category identifiers.
    /// </summary>
    /// <param name="Value">
    /// A string containing comma or newline-separated identifiers corresponding to <c>THarmCategory</c> values (e.g., "S1,S2,S3").
    /// </param>
    /// <returns>
    /// A <c>TSafety</c> record populated with the specified harm categories.
    /// </returns>
    /// <exception cref="Exception">
    /// Thrown when an invalid harm category identifier is encountered.
    /// </exception>
    class function Create(const Value: string): TSafety; static;
    /// <summary>
    /// Converts the safety information to its string representation.
    /// </summary>
    /// <param name="Full">
    /// A boolean value indicating whether to include full descriptions of harm categories.
    /// Set to <c>False</c> to include only short identifiers.
    /// </param>
    /// <returns>
    /// A string representing the safety information. If <c>Full</c> is <c>True</c>, full descriptions are returned;
    /// otherwise, only short identifiers are included. If no harm categories are present, the string "Safe" is returned.
    /// </returns>
    function ToString(Full: Boolean = False): string;
    /// <summary>
    /// Gets or sets the array of short string representations of harm categories.
    /// </summary>
    /// <value>
    /// An array of strings where each string is a short identifier corresponding to a <c>THarmCategory</c> value.
    /// </value>
    property Harm: TArray<string> read FHarm write FHarm;
    /// <summary>
    /// Gets or sets the array of full string descriptions of harm categories.
    /// </summary>
    /// <value>
    /// An array of strings where each string is a full description corresponding to a <c>THarmCategory</c> value.
    /// </value>
    property HarmFull: TArray<string> read FHarmFull write FHarmFull;
  end;

implementation

uses
  System.StrUtils;

type
  THarmCategoryContent = class
  private
    FHarmContent: TArray<string>;
  public
    function GetS1Content: string;
    function GetS2Content: string;
    function GetS3Content: string;
    function GetS4Content: string;
    function GetS5Content: string;
    function GetS6Content: string;
    function GetS7Content: string;
    function GetS8Content: string;
    function GetS9Content: string;
    function GetS10Content: string;
    function GetS11Content: string;
    function GetS12Content: string;
    function GetS13Content: string;
    function GetS14Content: string;
    function Add(const Value: string): THarmCategoryContent;
    constructor Create;
  end;

var
  HarmCategoryContent: THarmCategoryContent;

{ THarmCategoryContent }

function THarmCategoryContent.Add(const Value: string): THarmCategoryContent;
begin
  FHarmContent := FHarmContent + [Value];
  Result := Self;
end;

constructor THarmCategoryContent.Create;
begin
  inherited Create;
  Self.Add(GetS1Content)
    .Add(GetS2Content)
    .Add(GetS3Content)
    .Add(GetS4Content)
    .Add(GetS5Content)
    .Add(GetS6Content)
    .Add(GetS7Content)
    .Add(GetS8Content)
    .Add(GetS9Content)
    .Add(GetS10Content)
    .Add(GetS11Content)
    .Add(GetS12Content)
    .Add(GetS13Content)
    .Add(GetS14Content);
end;

function THarmCategoryContent.GetS10Content: string;
begin
  with TStringWriter.Create do
  try
    WriteLine('Hate');
    WriteLine('Responses that demean or dehumanize people on the basis of their sensitive, personal characteristics (i.e., race, color, ethnicity, national origin, disability, religious affiliation, caste, sexual orientation, sex, gender identity, and/or serious disease)');
    Result := ToString;
  finally
    Free;
  end;
end;

function THarmCategoryContent.GetS11Content: string;
begin
  with TStringWriter.Create do
  try
    WriteLine('Suicide & Self-Harm');
    WriteLine('Responses that enable, encourage, or endorse acts of intentional self-harm, including:');
    WriteLine(' - suicide');
    WriteLine(' - self-injury (ex: cutting)');
    WriteLine(' - disordered eating');
    Result := ToString;
  finally
    Free;
  end;
end;

function THarmCategoryContent.GetS12Content: string;
begin
  with TStringWriter.Create do
  try
    WriteLine('Sexual Content');
    WriteLine('Responses that contain erotica');
    Result := ToString;
  finally
    Free;
  end;
end;

function THarmCategoryContent.GetS13Content: string;
begin
  with TStringWriter.Create do
  try
    WriteLine('Elections');
    WriteLine('Responses that contain factually incorrect information about electoral systems and processes, including in the time, place, or manner of voting in civic elections');
    Result := ToString;
  finally
    Free;
  end;
end;

function THarmCategoryContent.GetS14Content: string;
begin
  with TStringWriter.Create do
  try
    WriteLine('Code Interpreter Abuse');
    WriteLine('Responses that seek to abuse code interpreters, including those that enable denial of service attacks, container escapes or privilege escalation exploits');
    Result := ToString;
  finally
    Free;
  end;
end;

function THarmCategoryContent.GetS1Content: string;
begin
  with TStringWriter.Create do
  try
    WriteLine('Violent Crimes');
    WriteLine('Responses that enable, encourage, or endorse the commission of violent crimes, including:');
    WriteLine(' - unlawful violence toward people (ex: terrorism, genocide, murder, hate-motivated violent crimes, child abuse, assault, battery, kidnapping)');
    WriteLine(' - unlawful violence toward animals (ex: animal abuse)');
    Result := ToString;
  finally
    Free;
  end;
end;

function THarmCategoryContent.GetS2Content: string;
begin
  with TStringWriter.Create do
  try
    WriteLine('Non-Violent Crimes');
    WriteLine('Responses that enable, encourage, or endorse the commission of non-violent crimes, including:');
    WriteLine(' - personal crimes (ex: labor trafficking, threats, intimidation, hate-motivated non-violent crimes)');
    WriteLine(' - financial crimes (ex: fraud, scams, money laundering)');
    WriteLine(' - property crimes (ex: theft, arson, vandalism)');
    WriteLine(' - drug crimes (ex: creating or using regulated substances)');
    WriteLine(' - weapons crimes (ex: producing unlicensed firearms)');
    WriteLine(' - cyber crimes (ex: hacking)');
    Result := ToString;
  finally
    Free;
  end;
end;

function THarmCategoryContent.GetS3Content: string;
begin
  with TStringWriter.Create do
  try
    WriteLine('Sex-Related Crimes');
    WriteLine('Responses that enable, encourage, or endorse the commission of sex-related crimes, including');
    WriteLine(' - sex trafficking');
    WriteLine(' - sexual assault (ex: rape)');
    WriteLine(' - sexual harassment (physical, verbal, or visual)');
    WriteLine(' - prostitution');
    Result := ToString;
  finally
    Free;
  end;
end;

function THarmCategoryContent.GetS4Content: string;
begin
  with TStringWriter.Create do
  try
    WriteLine('Child Sexual Exploitation');
    WriteLine('Responses that contain, describe, enable, encourage, or endorse the sexual abuse of children');
    Result := ToString;
  finally
    Free;
  end;
end;

function THarmCategoryContent.GetS5Content: string;
begin
  with TStringWriter.Create do
  try
    WriteLine('Defamation');
    WriteLine('Responses that are both verifiably false and likely to injure a living person’s reputation');
    Result := ToString;
  finally
    Free;
  end;
end;

function THarmCategoryContent.GetS6Content: string;
begin
  with TStringWriter.Create do
  try
    WriteLine('Specialized Advice');
    WriteLine('Responses that contain specialized financial, medical, or legal advice, or that indicate dangerous activities or objects are safe');
    Result := ToString;
  finally
    Free;
  end;
end;

function THarmCategoryContent.GetS7Content: string;
begin
  with TStringWriter.Create do
  try
    WriteLine('Privacy');
    WriteLine('Responses that contain sensitive, nonpublic personal information that could undermine someone''s physical, digital, or financial security');
    Result := ToString;
  finally
    Free;
  end;
end;

function THarmCategoryContent.GetS8Content: string;
begin
  with TStringWriter.Create do
  try
    WriteLine('Intellectual Property');
    WriteLine('Responses that may violate the intellectual property rights of any third party');
    Result := ToString;
  finally
    Free;
  end;
end;

function THarmCategoryContent.GetS9Content: string;
begin
  with TStringWriter.Create do
  try
    WriteLine('Indiscriminate Weapons');
    WriteLine('Responses that enable, encourage, or endorse the creation of indiscriminate weapons, including:');
    WriteLine(' - chemical weapons (ex: nerve gas)');
    WriteLine(' - biological weapons (ex: anthrax)');
    WriteLine(' - radiological weapons (ex: cobalt bombs)');
    WriteLine(' - nuclear weapons (ex: fission bombs)');
    WriteLine(' - high-yield explosive weapons (ex: cluster munitions)');
    Result := ToString;
  finally
    Free;
  end;
end;

{ THarmCategoryHelper }

class function THarmCategoryHelper.Create(const Value: string): THarmCategory;
begin
  var index := IndexStr(Value.ToLower, [
    's1', 's2', 's3', 's4', 's5', 's6', 's7', 's8', 's9', 's10', 's11', 's12', 's13', 's14']);
  if index = -1 then
    raise Exception.Create('Harm category type unkonwn');
  Result := THarmCategory(index);
end;

function THarmCategoryHelper.ToString(Full: Boolean): string;
begin
  try
    Result := HarmCategoryContent.FHarmContent[Integer(Self)];
    if not Full and not Result.IsEmpty then
      Result := Result.Split([#10])[0];
  except
    raise;
  end;
end;

{ TSafety }

class function TSafety.Create(const Value: string): TSafety;
begin
  for var Item in Value.Split([#10, ',']) do
    begin
      try
        Result.FHarm := Result.FHarm + [THarmCategory.Create(Item).ToString];
        Result.FHarmFull := Result.FHarmFull + [THarmCategory.Create(Item).ToString(True)];
      except
      end;
    end;
end;

function TSafety.ToString(Full: Boolean): string;
begin
  if Length(FHarm) = 0 then
    Exit('Safe');
  case Full of
    False:
      Result := Result.Join(#10, FHarm);
    else
      Result := Result.Join(#10, FHarmFull);
  end;
end;

initialization
  HarmCategoryContent := THarmCategoryContent.Create;
finalization
  HarmCategoryContent.Free;
end.

unit Groq.Schema;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGroqCloud
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, REST.Json.Types,
  Groq.API.Params;

type
  /// <summary>
  /// Type contains the list of OpenAPI data types as defined by https://spec.openapis.org/oas/v3.0.3#data-types
  /// </summary>
  TSchemaType = (
    /// <summary>
    /// Not specified, should not be used.
    /// </summary>
    TYPE_UNSPECIFIED,
    /// <summary>
    /// String type.
    /// </summary>
    stSTRING,
    /// <summary>
    /// Number type.
    /// </summary>
    stNUMBER,
    /// <summary>
    /// Integer type.
    /// </summary>
    stINTEGER,
    /// <summary>
    /// Boolean type.
    /// </summary>
    stBOOLEAN,
    /// <summary>
    /// Array type.
    /// </summary>
    stARRAY,
    /// <summary>
    /// Object type.
    /// </summary>
    stOBJECT
  );

  /// <summary>
  /// Helper record for the <c>TSchemaType</c> enumeration, providing utility methods for converting
  /// between <c>TSchemaType</c> values and their string representations.
  /// </summary>
  TSchemaTypeHelper = record helper for TSchemaType
    /// <summary>
    /// Converts the current <c>TSchemaType</c> value to its corresponding string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>TSchemaType</c> value.
    /// </returns>
    function ToString: string;
  end;

  TSchemaParams = class;

  /// <summary>
  /// Provides helper methods for creating property items in OpenAPI schema definitions.
  /// </summary>
  /// <remarks>
  /// This record simplifies the creation of property entries when building schema objects,
  /// particularly for object properties in OpenAPI specifications.
  /// </remarks>
  TPropertyItem = record
  public
    /// <summary>
    /// Creates a JSON pair representing a property in a schema object.
    /// </summary>
    /// <param name="Key">The name of the property.</param>
    /// <param name="Value">The data type of the property as a <c>TSchemaType</c>.</param>
    /// <returns>A <c>TJSONPair</c> representing the property key-value pair.</returns>
    /// <remarks>
    /// This method facilitates the addition of properties to schema objects by creating
    /// a JSON pair with the specified key and data type.
    /// </remarks>
    class function Add(Key: string; Value: TSchemaType): TJSONPair; static;
  end;

  /// <summary>
  /// Represents the Schema Object in OpenAPI, enabling the definition of input and output data types.
  /// These types can be objects, primitives, or arrays. This class provides methods to build and
  /// configure schema definitions as per the OpenAPI 3.0 Specification.
  /// </summary>
  /// <remarks>
  /// The Schema Object allows the definition of input and output data types in the OpenAPI Specification.
  /// This class provides a fluent interface to construct schema definitions programmatically.
  /// </remarks>
  TSchemaParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the data type of the schema.
    /// </summary>
    /// <param name="Value">The data type to assign to the schema, specified as a <c>TSchemaType</c> value.</param>
    /// <returns>The current <c>TSchemaParams</c> instance to allow for method chaining.</returns>
    /// <remarks>
    /// The <c>type</c> keyword is required in the Schema Object to define the data type.
    /// Valid types include <c>string</c>, <c>number</c>, <c>integer</c>, <c>boolean</c>, <c>array</c>, and <c>object</c>.
    /// </remarks>
    function &Type(const Value: TSchemaType): TSchemaParams;
    /// <summary>
    /// Specifies the format of the data type.
    /// </summary>
    /// <param name="Value">The format of the data type, as a string.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>format</c> keyword is an optional modifier to provide more fine-grained data type information.
    /// Common formats include <c>int32</c>, <c>int64</c> for <c>integer</c> types; <c>float</c>, <c>double</c>
    /// for <c>number</c> types; and <c>byte</c>, <c>binary</c>, <c>date</c>, <c>date-time</c>, <c>password</c> for <c>string</c> types.
    /// </remarks>
    function Format(const Value: string): TSchemaParams;
    /// <summary>
    /// Adds a description to the schema.
    /// </summary>
    /// <param name="Value">A brief description of the schema. Supports Markdown for formatting.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>description</c> keyword provides a description of the schema and can include examples of use.
    /// This field supports Markdown syntax for rich text representation.
    /// </remarks>
    function Description(const Value: string): TSchemaParams;
    /// <summary>
    /// Specifies whether the schema's value can be null.
    /// </summary>
    /// <param name="Value">A boolean indicating if the schema allows null values.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>nullable</c> keyword is a boolean property that indicates if the value of the schema can be null.
    /// By default, this is false.
    /// </remarks>
    function Nullable(const Value: Boolean): TSchemaParams;
    /// <summary>
    /// Specifies an enumeration of possible values.
    /// </summary>
    /// <param name="Value">An array of string values that the schema can take.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>enum</c> keyword restricts the value of the schema to a fixed set of values.
    /// The schema's type must be <c>string</c> when using enum.
    /// </remarks>
    function Enum(const Value: TArray<string>): TSchemaParams;
    /// <summary>
    /// Specifies the maximum number of items allowed in an array schema.
    /// </summary>
    /// <param name="Value">The maximum number of items as a string.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>maxItems</c> keyword applies to schemas of type <c>array</c> and restricts the maximum number
    /// of items the array can contain.
    /// </remarks>
    function MaxItems(const Value: string): TSchemaParams;
    /// <summary>
    /// Specifies the minimum number of items required in an array schema.
    /// </summary>
    /// <param name="Value">The minimum number of items as a string.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>minItems</c> keyword applies to schemas of type <c>array</c> and defines the minimum number
    /// of items the array must contain.
    /// </remarks>
    function MinItems(const Value: string): TSchemaParams;
    /// <summary>
    /// Adds a property to an object schema.
    /// </summary>
    /// <param name="Key">The name of the property.</param>
    /// <param name="Value">A <c>TSchemaParams</c> instance defining the property's schema.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>properties</c> keyword is used to define the properties of an object schema.
    /// Each property is a key-value pair where the key is the property name and the value is a schema defining the property.
    /// </remarks>
    function Properties(const Key: string; const Value: TSchemaParams): TSchemaParams; overload;
    /// <summary>
    /// Adds a property to an object schema using a parameterized procedure to configure the property's schema.
    /// </summary>
    /// <param name="Key">The name of the property.</param>
    /// <param name="ParamProc">A procedure that takes a <c>TSchemaParams</c> instance to configure the property's schema.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// This overload allows you to define the property's schema inline using a procedural configuration.
    /// </remarks>
    function Properties(const Key: string; const ParamProc: TProcRef<TSchemaParams>): TSchemaParams; overload;
    /// <summary>
    /// Adds multiple properties to an object schema.
    /// </summary>
    /// <param name="Value">An array of <c>TJSONPair</c> instances representing the properties.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// This overload allows adding multiple properties at once to the object schema.
    /// </remarks>
    function Properties(const Value: TArray<TJSONPair>): TSchemaParams; overload;
    /// <summary>
    /// Specifies which properties are required in an object schema.
    /// </summary>
    /// <param name="Value">An array of property names that are required.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>required</c> keyword lists the property names that must be included when an object instance
    /// is validated against the schema.
    /// </remarks>
    function Required(const Value: TArray<string>): TSchemaParams;
    /// <summary>
    /// Specifies the schema of the items in an array schema.
    /// </summary>
    /// <param name="Value">A <c>TSchemaParams</c> instance defining the schema of the array items.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>items</c> keyword is used in array schemas to define the schema of each item in the array.
    /// </remarks>
    function Items(const Value: TSchemaParams): TSchemaParams; overload;
    /// <summary>
    /// Specifies the schema of the items in an array schema using a parameterized procedure.
    /// </summary>
    /// <param name="ParamProc">A procedure that configures a <c>TSchemaParams</c> instance to define the array items' schema.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// This overload allows you to define the items' schema inline using a procedural configuration.
    /// </remarks>
    function Items(const ParamProc: TProcRef<TSchemaParams>): TSchemaParams; overload;
    /// <summary>
    /// Creates a new instance of <c>TSchemaParams</c>.
    /// </summary>
    /// <returns>A new <c>TSchemaParams</c> instance.</returns>
    class function New: TSchemaParams; overload;
    /// <summary>
    /// Creates and configures a new instance of <c>TSchemaParams</c> using a parameterized procedure.
    /// </summary>
    /// <param name="ParamProc">A procedure that configures the new <c>TSchemaParams</c> instance.</param>
    /// <returns>A new <c>TSchemaParams</c> instance.</returns>
    /// <remarks>
    /// This overload allows you to create and configure the instance inline.
    /// </remarks>
    class function New(const ParamProc: TProcRef<TSchemaParams>): TSchemaParams; overload;
  end;

implementation

uses
  System.StrUtils, System.Rtti, Rest.Json;

{ TSchemaTypeHelper }

function TSchemaTypeHelper.ToString: string;
begin
  case Self of
    TYPE_UNSPECIFIED:
      Exit('type_unspecified');
    stSTRING:
      Exit('string');
    stNUMBER:
      Exit('number');
    stINTEGER:
      Exit('integer');
    stBOOLEAN:
      Exit('boolean');
    stARRAY:
      Exit('array');
    stOBJECT:
      Exit('object');
  end;
end;

{ TSchemaParams }

function TSchemaParams.Description(const Value: string): TSchemaParams;
begin
  Result := TSchemaParams(Add('description', Value));
end;

function TSchemaParams.Enum(const Value: TArray<string>): TSchemaParams;
begin
  Result := TSchemaParams(Add('enum', Value));
end;

function TSchemaParams.Format(const Value: string): TSchemaParams;
begin
  Result := TSchemaParams(Add('format', Value));
end;

function TSchemaParams.Items(
  const ParamProc: TProcRef<TSchemaParams>): TSchemaParams;
begin
  if Assigned(ParamProc) then
    begin
      var Value := TSchemaParams.Create;
      ParamProc(Value);
      Result := Items(Value);
    end
  else Result := Self;
end;

function TSchemaParams.Items(const Value: TSchemaParams): TSchemaParams;
begin
  Result := TSchemaParams(Add('items', Value.Detach));
end;

function TSchemaParams.MaxItems(const Value: string): TSchemaParams;
begin
  Result := TSchemaParams(Add('maxItems', Value));
end;

function TSchemaParams.MinItems(const Value: string): TSchemaParams;
begin
  Result := TSchemaParams(Add('minItems', Value));
end;

class function TSchemaParams.New: TSchemaParams;
begin
  Result := TSchemaParams.Create;
end;

class function TSchemaParams.New(
  const ParamProc: TProcRef<TSchemaParams>): TSchemaParams;
begin
  Result := TSchemaParams.Create;
  if Assigned(ParamProc) then
    begin
      ParamProc(Result);
    end;
end;

function TSchemaParams.Nullable(const Value: Boolean): TSchemaParams;
begin
  Result := TSchemaParams(Add('nullable', Value.ToString));
end;

function TSchemaParams.Properties(
  const Value: TArray<TJSONPair>): TSchemaParams;
begin
  var JSONValue := TJSONObject.Create;
  for var Item in Value do
    begin
      JSONValue.AddPair(Item);
    end;
  Result := TSchemaParams(Add('properties', JSONValue));
end;

function TSchemaParams.Properties(const Key: string;
  const ParamProc: TProcRef<TSchemaParams>): TSchemaParams;
begin
  if Assigned(ParamProc) then
    begin
      var Value := TSchemaParams.Create;
      ParamProc(Value);
      Result := Properties(Key, Value);
    end
  else Result := Self;
end;

function TSchemaParams.Properties(const Key: string;
  const Value: TSchemaParams): TSchemaParams;
begin
  Result := TSchemaParams(Add(Key, Value.Detach));
end;

function TSchemaParams.Required(const Value: TArray<string>): TSchemaParams;
begin
  Result := TSchemaParams(Add('required', Value));
end;

function TSchemaParams.&Type(const Value: TSchemaType): TSchemaParams;
begin
  Result := TSchemaParams(Add('type', Value.ToString));
end;

{ TPropertyItem }

class function TPropertyItem.Add(Key: string; Value: TSchemaType): TJSONPair;
begin
  Result := TJSONPair.Create(Key, Value.ToString);
end;

end.



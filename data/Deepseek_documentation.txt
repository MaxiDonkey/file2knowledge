# Delphi Deepseek

___
![GitHub](https://img.shields.io/badge/IDE%20Version-Delphi%2010.3/11/12-yellow)
![GitHub](https://img.shields.io/badge/platform-all%20platforms-green)
![GitHub](https://img.shields.io/badge/Updated%20on%20april%2026,%202025-blue)

<br/>

NEW: 
- [Changelog](https://github.com/MaxiDonkey/DelphiDeepseek/blob/main/Changelog.md)
- [Deepseek-reasoner](#deepseek-reasoner)
- [Parallel method for generating text](#parallel-method-for-generating-text)
- [Multiple queries with chaining](#multiple-queries-with-chaining)
- [Tips and tricks](#tips-and-tricks)
___

- [Introduction](#introduction)
- [Remarks](#remarks)
- [Wrapper Tools Info](#wrapper-tools-info)
    - [Tools for simplifying this tutorial](#tools-for-simplifying-this-tutorial)
    - [Asynchronous callback mode management](#asynchronous-callback-mode-management)
    - [Simplified Unit Declaration](#simplified-unit-declaration) 
- [Usage](#usage)
    - [Initialization](#initialization)
    - [Deepseek Models Overview](#deepseek-models-overview)
    - [Chats](#chats)
        - [Create a message](#create-a-message)
        - [Streaming messages](#streaming-messages)
        - [Multi-turn conversation](#multi-turn-conversation)
        - [Deepseek-reasoner](#deepseek-reasoner)
        - [Parallel method for generating text](#parallel-method-for-generating-text)
        - [Multiple queries with chaining](#multiple-queries-with-chaining)
    - [Function calling](#function-calling)
        - [Use case](#use-case)
    - [JSON Output](#json-output)
    - [Context Caching](#context-caching)
    - [Get user balance](#get-user-balance)
- [Beta version](#beta-version)
    - [FIM Completion](#fim-completion)
        - [Completion](#completion)
        - [Streamed completion](#streamed-completion)
    - [Chat prefix completion](#chat-prefix-completion)
- [Tips and tricks](#tips-and-tricks)
- [Contributing](#contributing)
- [License](#license)

<br/>
<br/>

# Introduction

Founded in 2023, Deepseek provides two language models with automatic caching. Developed in China, this technology is influenced by a specific cultural and regulatory framework, shaping its priorities and development choices. While its scope of application is still evolving, Deepseek offers an option for Delphi developers looking to experiment with AI tools.

This unofficial wrapper aims to simplify the integration of Deepseek APIs into Delphi projects. It provides a practical way for developers to explore and test these models, whether for natural language processing, conversational assistants, or other targeted use cases. The library enables quick experimentation while leveraging Delphi’s familiar environment.

This wrapper is primarily intended for exploratory purposes. It provides users with a tool to assess whether Deepseek meets their specific needs and to integrate it into their projects if deemed suitable.

<br/>

# Remarks

> [!IMPORTANT]
>
> This is an unofficial library. **Deepseek** does not provide any official library for `Delphi`.
> This repository contains `Delphi` implementation over [Deepseek](https://api-docs.deepseek.com/) public API.

<br/>

# Wrapper Tools Info

This section offers concise notifications and explanations about the tools designed to streamline the presentation and clarify the wrapper's functions throughout the tutorial.

<br/>

## Tools for simplifying this tutorial

To streamline the code examples provided in this tutorial and facilitate quick implementation, two units have been included in the source code: `Deepseek.Tutorial.VCL` and `Deepseek.Tutorial.FMX`. Depending on the platform you choose to test the provided source code, you will need to instantiate either the `TVCLTutorialHub` or `TFMXTutorialHub` class in the application's OnCreate event, as demonstrated below:

>[!TIP]
>```Pascal
> //uses Deepseek.Tutorial.VCL;
> TutorialHub := TVCLTutorialHub.Create(Deepseek, Memo1, Memo2, Memo3, Memo4, Button2);
>```

or

>[!TIP]
>```Pascal
> //uses Deepseek.Tutorial.FMX;
> TutorialHub := TFMXTutorialHub.Create(Deepseek, Memo1, Memo2, Memo3, Memo4, Button2);
>```

Make sure to add a three `TMemo`, a `TButton` component to your form beforehand and Deepseek then client ([see bellow.](#initialization)) 

The `TButton` will allow the interruption of any streamed reception.

<br/>

## Asynchronous callback mode management

In the context of asynchronous methods, for a method that does not involve streaming, callbacks use the following generic record: `TAsynCallBack<T> = record` defined in the `Deepseek.Async.Support.pas` unit. This record exposes the following properties:

```Pascal
   TAsynCallBack<T> = record
   ... 
       Sender: TObject;
       OnStart: TProc<TObject>;
       OnSuccess: TProc<TObject, T>;
       OnError: TProc<TObject, string>; 
```
<br/>

For methods requiring streaming, callbacks use the generic record `TAsynStreamCallBack<T> = record`, also defined in the `Deepseek.Async.Support.pas` unit. This record exposes the following properties:

```Pascal
   TAsynCallBack<T> = record
   ... 
       Sender: TObject;
       OnStart: TProc<TObject>;
       OnProgress: TProc<TObject, T>;
       OnSuccess: TProc<TObject, T>;
       OnError: TProc<TObject, string>;
       OnCancellation: TProc<TObject>;
       OnDoCancel: TFunc<Boolean>;
```

The name of each property is self-explanatory; if needed, refer to the internal documentation for more details.

<br>

>[!NOTE]
> All methods managed by the wrapper are designed to support both synchronous and asynchronous execution modes. This dual-mode functionality ensures greater flexibility for users, allowing them to choose the approach that best suits their application's requirements and workflow.

<br/>

## Simplified Unit Declaration

To streamline the use of the API wrapper, the process for declaring units has been simplified. Regardless of the methods being utilized, you only need to reference the following two core units:

```Pascal
  uses
    Deepseek, Deepseek.Types;
```

If required, you may also include the `Deepseek.Schema` unit or any plugin units developed for specific function calls (e.g., `Deepseek.Functions.Example`). This simplification ensures a more intuitive and efficient integration process for developers.

<br/>

# Usage

## Initialization

To initialize the API instance, you need to [obtain an API key from Deepseek](https://platform.deepseek.com/api_keys).

Once you have a token, you can initialize `IDeepseek` interface, which is an entry point to the API.


> [!NOTE]
>```Pascal
>uses Deepseek;
>
>var Deepseek := TDeepseek.CreateInstance(API_KEY);
>var DeepseekBeta := TDeepseekFactory.CreateBetaInstance(API_KEY); 
>```

The DeepseekBeta client must be used to access APIs that are currently provided in beta version.

>[!Warning]
> To effectively use the examples in this tutorial, particularly when working with asynchronous methods, it is recommended to define the Deepseek and DeepseekBeta interfaces with the broadest possible scope. For optimal implementation, these clients should be declared in the application's OnCreate method.

<br/>

## Deepseek Models Overview

Two models are currently available:
- [deepseek-chat](https://huggingface.co/deepseek-ai/deepseek-llm-67b-chat) 
- [deepseek-coder](https://deepseekcoder.github.io/). et sur [HuggingFace](https://huggingface.co/deepseek-ai) 

Regarding the APIs, only version 3 appears to be available, although the documentation lacks clarity on this point.

To retrieve the list of available models, you can use the following code example:

```Pascal
// uses Deepseek, Deepseek.Types, Deepseek.Tutorial.VCL;

  TutorialHub.Clear;

  //Asynchronous example
  DeepSeek.Models.AsynList(
    function : TAsynModels
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := DeepSeek.Models.List;
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br/>

## Chats

You can send a structured list of input messages containing only text content, and the model will generate the next message in the conversation.

The Messages API can be used for both single-turn requests and multi-turn, stateless conversations.

### Create a message

```Pascal
// uses Deepseek, Deepseek.Types, Deepseek.Tutorial.VCL;

  TutorialHub.Clear;
  Deepseek.ClientHttp.ResponseTimeout := 120000;

  //Asynchronous example
  DeepSeek.Chat.AsynCreate(
    procedure (Params: TChatParams)
    begin
      Params.Model('deepseek-chat');
      Params.Messages([
        FromUser('What is the capital of France, and then the capital of champagne?')
      ]);
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynChat
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := DeepSeek.Chat.Create(
//    procedure (Params: TChatParams)
//    begin
//      Params.Model('deepseek-chat');
//      Params.Messages([
//        FromUser('What is the capital of France, and then the capital of champagne?')
//      ]);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br/>

### Streaming messages

When generating a Message, you can enable `"stream": true` to progressively receive the response through server-sent events (SSE).

```Pascal
// uses Deepseek, Deepseek.Types, Deepseek.Tutorial.VCL;

  TutorialHub.Clear;
  
  //Asynchronous example
  DeepSeek.Chat.ASynCreateStream(
    procedure (Params: TChatParams)
    begin
      Params.Model('deepseek-chat');
      Params.Messages([
        FromUser('Are there accumulation points in a discrete topology?')
      ]);
      Params.MaxTokens(1024);
      Params.Stream;
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynChatStream
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnProgress := DisplayStream;
      Result.OnError := Display;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
    end);

  //Synchronous example
//  DeepSeek.Chat.CreateStream(
//    procedure (Params: TChatParams)
//    begin
//      Params.Model('deepseek-chat');
//      Params.Messages([
//        FromUser('Are there accumulation points in a discrete topology?')
//      ]);
//      Params.MaxTokens(1024);
//      Params.Stream;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    procedure (var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
//    begin
//      if Assigned(Chat) and not IsDone then
//        DisplayStream(TutorialHub, Chat);
//    end);
```

<br/>

### Multi-turn conversation

The `Deepseek API` enables the creation of interactive chat experiences tailored to your users' needs. Its chat functionality supports multiple rounds of questions and answers, allowing users to gradually work toward solutions or receive help with complex, multi-step issues. This capability is especially useful for applications requiring ongoing interaction, such as:
- **Chatbots**
- **Educational tools**
- **Customer support assistants.**

Refer to the [official documentation](https://api-docs.deepseek.com/guides/multi_round_chat)

```Pascal
// uses Deepseek, Deepseek.Types, Deepseek.Tutorial.VCL;

  TutorialHub.Clear;

  //Asynchronous example
  DeepSeek.Chat.ASynCreateStream(
    procedure (Params: TChatParams)
    begin
      Params.Model('deepseek-chat');
      Params.Messages([
        FromSystem('You are a funny domestic assistant.'),
        FromUser('Hello'),
        FromAssistant('Great to meet you. What would you like to know?'),
        FromUser('I have two dogs in my house. How many paws are in my house?')
      ]);
      Params.MaxTokens(1024);
      Params.Stream;
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynChatStream
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnProgress := DisplayStream;
      Result.OnError := Display;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
    end);

  //Synchronous example
//  DeepSeek.Chat.CreateStream(
//    procedure (Params: TChatParams)
//    begin
//      Params.Model('deepseek-chat');
//      Params.Messages([
//        FromSystem('You are a funny domestic assistant.'),
//        FromUser('Hello'),
//        FromAssistant('Great to meet you. What would you like to know?'),
//        FromUser('I have two dogs in my house. How many paws are in my house?')
//      ]);
//      Params.MaxTokens(1024);
//      Params.Stream;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    procedure (var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
//    begin
//      if Assigned(Chat) and not IsDone then
//        DisplayStream(TutorialHub, Chat);
//    end);
```

<br/>

### Deepseek-reasoner

Since January 25, 2025, Deepseek has released a new model called `deepseek-reasoner`, designed to provide advanced reasoning capabilities similar to `OpenAI's O1` model.

Please refer to the [dedicated page](https://api-docs.deepseek.com/guides/reasoning_model) on the official website.

>[!WARNING]
>**Important Note:** This model does not support *function calls, JSON-formatted outputs, or the fill-in-the-middle (FIM) method*.
> The parameter to control the CoT length (reasoning_effort) will be available soon.

**Unsupported parameters:**
- *temperature, top_p, presence_penalty, frequency_penalty, logprobs, top_logprobs.*

To ensure compatibility with existing software, using *temperature, top_p, presence_penalty, and frequency_penalty* will not trigger an error but will have no effect on the model. However, using logprobs and top_logprobs will result in an error.

>[!TIP]
> This model is accessible through the APIs available in this wrapper. However, due to the processing time required for its reasoning methods, it is recommended to use asynchronous approaches to prevent potential application blocking.
>

```Pascal
// uses Deepseek, Deepseek.Types, Deepseek.Tutorial.VCL;

  TutorialHub.Clear;

  //Asynchronous example
  DeepSeek.Chat.ASynCreateStream(
    procedure (Params: TChatParams)
    begin
      Params.Model('deepseek-reasoner');
      Params.Messages([
        FromUser('What does the ability to reason bring to language models?')
      ]);
      Params.Stream;
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynChatStream
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnProgress := DisplayStream;
      Result.OnError := Display;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
    end);
```

In the sample code provided with the DisplayStream method, you can see how to handle the reasoning portion separately from the final response generation:

```Delphi
procedure DisplayStream(Sender: TObject; Value: TChat);
begin
  if Assigned(Value) then
    begin
      DisplayChunk(Value);
      if not Value.Choices[0].Delta.ReasoningContent.IsEmpty then
        {--- Display reasoning chunk }
        DisplayStream(TutorialHub.Reasoning, Value.Choices[0].Delta.ReasoningContent)
      else
        {--- Display responses chunk }
        DisplayStream(Sender, Value.Choices[0].Delta.Content.Replace('\n', #10));
    end;
end;  
```


![Preview](/../main/images/ReasoningStream.png?raw=true "Preview")


<br/>

### Parallel method for generating text

This approach enables the simultaneous execution of multiple prompts, provided they are all processed by the same model.

#### Example 1 : Two prompts processed in parallel.


```Pascal
// uses Deepseek, Deepseek.Types, Deepseek.Tutorial.VCL;

  TutorialHub.Clear;

  DeepSeek.Chat.CreateParallel(
    procedure (Params: TBundleParams)
    begin
      Params.Prompts([
        'How many television channels were there in France in 1980?',
        'How many TV channels were there in Germany in 1980?.'
      ]);
      Params.System('Write the response in capital letters.');
      Params.Model('deepseek-chat');
    end,
    function : TAsynBundleList
    begin
      Result.Sender := TutorialHub;

      Result.OnStart :=
        procedure (Sender: TObject)
        begin
          Display(Sender, 'Start the job' + sLineBreak);
        end;

      Result.OnSuccess :=
        procedure (Sender: TObject; Bundle: TBundleList)
        begin
          // Background bundle processing
          for var Item in Bundle.Items do
            begin
              Display(Sender, 'Index : ' + Item.Index.ToString);
              Display(Sender, 'FinishIndex : ' + Item.FinishIndex.ToString);
              Display(Sender, Item.Prompt + sLineBreak);
              Display(Sender, Item.Response + sLineBreak + sLineBreak);
              // or Display(Sender, TChat(Item.Chat).Choices[0].Message.Content);
            end;
        end;

      Result.OnError := Display;
    end)
```

Result

![Preview](/../main/images/Parallel.png?raw=true "Preview")

<br>

### Multiple queries with chaining

In some cases, you need to chain multiple requests so that each step’s output feeds into the next. The Promise pattern is ideal for orchestrating this kind of workflow: it lets you build complex processing that a single prompt—no matter how sophisticated—couldn’t achieve on its own.
 
**Implementation:** <br>
- Be sure to include the `Deepseek.Async.Promise` unit in your `uses` clause.
- Each Promise runs asynchronously and non-blockingly in the background, freeing the main thread for other operations.

#### Process

We’ll use a simple, educational scenario with three steps:

 1. Send a prompt to the deepseek-chat model.

 2. Process the received response to extract and reformat the relevant information.

 3. Generate the next prompt from the enriched result.

This minimal example is designed to help you get comfortable with asynchronous execution and promise chaining. You can then customize each step to suit your specific business needs.

<br>

#### We will use the following 3 prompts

```Delphi
const
  Step1 =
    '# Do not answer the question directly.'#10 +
    '# Consider possible lines of thought'#10 +
    '# Break the main problem down into subproblems.'#10 +
    '## For each subproblem: Develop a strategy to address that point.'#10 +
    '## For each subproblem: Evaluate and then critique the strategy established.'#10 +
    '## For each subproblem: Assess the relevance and effectiveness of the strategy.'#10 +
    '# Formatting'#10 +
    '## – Use everyday language to explain the reasoning.'#10 +
    '## – Avoid lists and markdown formatting.'#10 +
    '## – Write as if you were explaining to a third party.';

  Step2 =
    '# Build an effective outline to answer the question based on the analysis.'#10 +
    '## Do not go into detail on each point of the outline but rather discuss its relevance.'#10 +
    '## Identify the points that should be addressed in the thesis.'#10 +
    '## Identify the points that should be addressed in the antithesis.'#10 +
    '## Identify the points that should be addressed in the synthesis.'#10 +
    '## Determine the points to cover for a powerful introduction.'#10 +
    '## Determine the points to cover for a memorable conclusion.'#10 +
    '# Formatting'#10 +
    '## – Use everyday language to explain the reasoning.'#10 +
    '## – Avoid lists and markdown formatting.'#10 +
    '## – Write as if you were explaining to a third party.’';

  Step3 =
    '# Answer the following question in a teaching style'#10 +
    '## Use all the information provided in the system section.';
```

<br>

#### The code enabling chaining using the promise pattern

```Pascal
// uses Deepseek, Deepseek.Types, Deepseek.Tutorial.VCL, Deepseek.Async.Promise;

var
  Analysis: string;
begin
  TutorialHub.Clear;

  var Request := 'Does personal data belong to the individuals who generate it or to the platforms that collect it?';
  var System := Step1;

  TutorialHub.PromiseStep('Reasoning'#10, Request, System)
    .&Then<string>(
      function(Value: string): string
      begin
        Analysis := Value;
        Result := 'Request : '#10 + Request + #10 + 'Analysis : ' + Analysis;
        System := Step2;
      end)
    .&Then(
      function (Value: string): TPromise<string>
      begin
        Result := TutorialHub.PromiseStep(#10#10'Develop a plan'#10, Value, System);
      end)
    .&Then<string>(
      function(Value: string): string
      begin
        Result := Request + #10 + Step3 + #10 + Request;
        System := Analysis + #10 + Value;
      end)
    .&Then(
      function (Value: string): TPromise<string>
      begin
        Result := TutorialHub.PromiseStep(#10#10'Response'#10, Value, System);
      end)
    .&Catch(
      procedure(E: Exception)
      begin
        Display(Memo1, 'Error : ' + E.Message);
      end);
end;
```

This code answers the question provided in the `Request` variable by using two intermediate steps. We will now review the body of the Promise used at each stage.

![Preview](/../main/images/Promise.png?raw=true "Preview")

>[!NOTE]
>The corresponding code is available in the `Deepseek.Tutorial.VCL` and `Deepseek.Tutorial.FMX` units, depending on the platform on which you are running the test.

```Pascal
function TFMXTutorialHub.PromiseStep(const StepName, Prompt,
  System: string): TPromise<string>;
var
  Buffer: string;
begin
  Result := TPromise<string>.Create(
    procedure(Resolve: TProc<string>; Reject: TProc<Exception>)
    begin
      Client.Chat.AsynCreateStream(
        procedure (Params: TChatParams)
        begin
          Params.Model('deepseek-chat');
          Params.Messages([
            FromSystem(system),
            FromUser(Prompt)
          ]);
          Params.Stream;
        end,
        function : TAsynChatStream
        begin
          Result.Sender := TutorialHub;

          Result.OnStart :=
            procedure (Sender: TObject)
            begin
              Display(Sender, StepName + #10);
            end;

          Result.OnProgress :=
            procedure (Sender: TObject; Chat: TChat)
            begin
              DisplayStream(Sender, Chat);
              Buffer := Buffer + Chat.Choices[0].Delta.Content;
            end;

          Result.OnSuccess :=
            procedure (Sender: TObject)
            begin
              Resolve(Buffer); //The promise is resolved --> &Then<string>
            end;

          Result.OnError :=
            procedure (Sender: TObject; Error: string)
            begin
              Reject(Exception.Create(Error));  //The promise is rejected --> &Catch
            end;

          Result.OnDoCancel := DoCancellation;

          Result.OnCancellation :=
            procedure (Sender: TObject)
            begin
              Reject(Exception.Create('Aborted'));  //The promise is rejected --> &Catch
            end;

        end);
    end);
end;
 
```

<br>

#### Note

This approach proves to be particularly powerful for handling asynchronous mechanisms. However, when a process involves a large number of steps, the resulting code can quickly become difficult to maintain, leading to what is commonly referred to as a "pyramid of doom."

To avoid this, it is recommended to adopt a Pipeline mechanism, which organizes and chains the steps in a clear, streamlined, and structured way.

[An example implementation](https://github.com/MaxiDonkey/SynkFlowAI) based on the [GenAI wrapper for OpenAI](https://github.com/MaxiDonkey/DelphiGenAI) is available. With a few minor adjustments, it can also be used with Deepseek, except for the web search functionality.

<br>

## Function calling

>[!CAUTION]
> Note from DeepSeek in their [official documentation](https://api-docs.deepseek.com/guides/function_calling)
> *"The current version of the deepseek-chat model's Function Calling capabilitity is unstable, which may result in looped calls or empty responses. We are actively working on a fix, and it is expected to be resolved in the next version."*

Furthermore, function calls cannot be made in the context of a streaming request. Regarding the APIs, `Delta` does not support the `tool_calls object`.

<br/>

### Use case

**What’s the weather in Paris?**

In the `Deepseek.Functions.Example` unit, there is a class that defines a function which `Deepseek` can choose to use or not, depending on the options provided. This class inherits from a parent class defined in the `Deepseek.Functions.Core` unit. To create new functions, you can derive from the `TFunctionCore class` and define a new plugin.

In this unit, this schema will be used for function calls.

```Json
{
    "type": "object",
    "properties": {
         "location": {
             "type": "string",
             "description": "The city and department, e.g. Marseille, 13"
         },
         "unit": {
             "type": "string",
             "enum": ["celsius", "fahrenheit"]
         }
     },
     "required": ["location"]
  }
```

<br/>

1. We will use the TWeatherReportFunction plugin defined in the [`Deepseek.Functions.Example`](https://github.com/MaxiDonkey/DelphiDeepseek/blob/main/source/Deepseek.Functions.Example.pas) unit.

```Pascal
  var Weather := TWeatherReportFunction.CreateInstance;
  //See step 3
```

<br/>

2. We then define a method to display the **result** of the query using the **Weather tool**.

```Pascal
procedure TMy_Form.DisplayWeather(const Value: string);
begin
  //Asynchronous example
  DeepSeek.Chat.ASynCreateStream(
    procedure (Params: TChatParams)
    begin
      Params.Model('deepseek-chat');
      Params.Messages([
        FromSystem('You are a star weather presenter on a national TV channel.'),
        FromUser(Value)
      ]);
      Params.Stream;
    end,
    function : TAsynChatStream
    begin
      Result.Sender := TutorialHub;
      Result.OnProgress := DisplayStream;
      Result.OnError := Display;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
    end);
end;
```

<br/>

3. Building the query using the Weather tool

```Pascal
// uses Deepseek, Deepseek.Types, Deepseek.Functions.Example, Deepseek.Tutorial.VCL;
  
  TutorialHub.Clear;
  var Weather := TWeatherReportFunction.CreateInstance;
  TutorialHub.Tool := Weather;
  TutorialHub.ToolCall := DisplayWeather;

  //Asynchronous example
  DeepSeek.Chat.AsynCreate(
    procedure (Params: TChatParams)
    begin
      Params.Model('deepseek-chat');
      Params.Messages([
        TContentParams.User('What is the weather in Paris?')
      ]);
      Params.Tools([Weather]);
      Params.ToolChoice(auto);
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynChat
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError
  end;
```

<br/>

## JSON Output

In many scenarios, users require the model to produce output in strictly JSON format to ensure structured data, facilitating seamless downstream processing.

DeepSeek provides a JSON Output feature to guarantee the generation of valid JSON strings.

**Key Considerations:**
1. **Enabling JSON Output:**
     - Set the response_format parameter to `{'type': 'json_object'}`.
     - Include the word "json" in the system or user prompt, and provide an example of the desired JSON format to guide the model in producing compliant outputs.

2. **Adjusting Output Length:**
     - Configure the max_tokens parameter appropriately to prevent the JSON string from being truncated.

3. **Handling Potential Issues:**
     - The API may occasionally return empty content. This issue is under active optimization. Adjusting the prompt can help mitigate such occurrences.

Refer to [official documentation](https://api-docs.deepseek.com/guides/json_mode)

<br/>

```Pascal
// uses Deepseek, Deepseek.Types, Deepseek.Tutorial.VCL;

  TutorialHub.Clear;

  //Asynchronous example
  DeepSeek.Chat.AsynCreate(
    procedure (Params: TChatParams)
    begin
      Params.Model('deepseek-chat');
      Params.Messages([
        TContentParams.System('The user will provide some exam text. Please parse the "question" and "answer" and output them in JSON format. EXAMPLE INPUT: Which is the highest mountain in the world? Mount Everest. EXAMPLE JSON OUTPUT: {     "question": "Which is the highest mountain in the world?",     "answer": "Mount Everest" }'),
        TContentParams.User('Which is the longest river in the world? The Nile River')
      ]);
      Params.ResponseFormat(TResponseFormat.json_object);
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynChat
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := DeepSeek.Chat.Create(
//    procedure (Params: TChatParams)
//    begin
//      Params.Model('deepseek-chat');
//      Params.Messages([
//        TContentParams.System('The user will provide some exam text. Please parse the "question" and "answer" and output them in JSON format. EXAMPLE INPUT: Which is the highest mountain in the world? Mount Everest. EXAMPLE JSON OUTPUT: {     "question": "Which is the highest mountain in the world?",     "answer": "Mount Everest" }'),
//        TContentParams.User('Which is the longest river in the world? The Nile River')
//      ]);
//      Params.ResponseFormat(TResponseFormat.json_object);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

The model will output:

```Json
{
    "question": "Which is the longest river in the world?",
    "answer": "The Nile River"
}  
```

<br/>

## Context Caching

Refer to the [official documentation](https://api-docs.deepseek.com/guides/kv_cache)

The automatic enforcement of caching has the effect of limiting the diversity of generated responses. While adjusting the temperature parameter can provide some flexibility, it is not an optimal solution in all cases.

Additionally, users are unable to directly intervene to perform a manual "cache clearing." In this regard, I refer you to the official documentation, which states: 

- *"Cache construction takes seconds. Once the cache is no longer in use, it will be automatically cleared, usually within a few hours to a **`few days`**.."*

<br/>

## Get user balance

View account details, including available credit balance.

```Pascal
// uses Deepseek, Deepseek.Types, Deepseek.Tutorial.VCL;

  TutorialHub.Clear;

  //Asynchronous example
  DeepSeek.User.AsynBalance(
    function : TAsynBalance
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := DeepSeek.User.Balance;
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br/>

# Beta version

## FIM Completion

In Fill-In-the-Middle (FIM) completion, users can specify a prefix and optionally a suffix, allowing the model to generate content that seamlessly fills the gap between them. This approach is particularly useful for tasks such as content and code completion.

**Important Notes:**
- Token Limit: FIM completion supports a maximum token limit of 4,000.
- Enabling the Beta Feature: Users must set base_url=https://api.deepseek.com/beta to activate this functionality.

>[!TIP]
> In this case, we will use the [DeepseekBeta](#initialization) client in our code examples.

<br/>

### Completion

```Pascal
// uses Deepseek, Deepseek.Types, Deepseek.Tutorial.VCL;

  TutorialHub.Clear;

  //Asynchronous example
  DeepSeekBeta.FIM.AsynCreate(
    procedure (Params: TFIMParams)
    begin
      Params.Model('deepseek-chat');
      Params.Prompt('def fib(a):');
      Params.Suffix('    return fib(a-1) + fib(a-2)');
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynFIM
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := DeepSeekBeta.FIM.Create(
//    procedure (Params: TFIMParams)
//    begin
//      Params.Model('deepseek-chat');
//      Params.Prompt('def fib(a):');
//      Params.Suffix('    return fib(a-1) + fib(a-2)');
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```
<br/>

The model will output:

``` 
    if a == 0:
        return 0
    elif a == 1:
        return 1
    else:  
```

<br/>

### Streamed completion

```Pascal
// uses Deepseek, Deepseek.Types, Deepseek.Tutorial.VCL;

  TutorialHub.Clear;

  //Asynchronous example
  DeepSeekBeta.FIM.AsynCreateStream(
    procedure (Params: TFIMParams)
    begin
      Params.Model('deepseek-chat');
      Params.Prompt('def fib(a):');
      Params.Suffix('  return fib(a-1) + fib(a-2)');
      Params.Stream;
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynFIMStream
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnProgress := DisplayStream;
      Result.OnError := Display;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
    end);

  //Synchronous example
//  DeepSeekBeta.FIM.CreateStream(
//    procedure (Params: TFIMParams)
//    begin
//      Params.Model('deepseek-chat');
//      Params.Prompt('def fib(a):');
//      Params.Suffix('  return fib(a-1) + fib(a-2)');
//      Params.Stream;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    procedure (var FIM: TFIM; IsDone: Boolean; var Cancel: Boolean)
//    begin
//      if Assigned(FIM) and not IsDone then
//        DisplayStream(TutorialHub, FIM);
//    end);
```

## Chat prefix completion

To utilize the chat prefix completion feature, users must provide a message prefix for the assistant, allowing the model to complete the rest of the message.

**Important Note**
When using prefix completion, it is essential to ensure that the role of the last message in the message list is set to "assistant" and that the `prefix` parameter for this message is enabled (set to `True`). Additionally, users must configure `base_url="https://api.deepseek.com/beta"` to activate the Beta feature.

>[!TIP]
> In this case, we will use the [DeepseekBeta](#initialization) client in our code examples.

```Pascal
// uses Deepseek, Deepseek.Types, Deepseek.Tutorial.VCL;

  TutorialHub.Clear;

  //Asynchronous example
  DeepSeekBeta.Chat.AsynCreate(
    procedure (Params: TChatParams)
    begin
      Params.Model('deepseek-chat');
      Params.Messages([
        FromUser('Please write quick sort code'),
        FromAssistant('```python\n', True)
      ]);
      Params.Stop('```');
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynChat
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

The model will output:

```Python
# Quick Sort implementation in Python

def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

# Example usage:
arr = [3, 6, 8, 10, 1, 2, 1]
sorted_arr = quick_sort(arr)
print("Sorted array:", sorted_arr)
```

<br>

# Tips and tricks

## How to prevent an error when closing an application while requests are still in progress?

Starting from version 1.0.2 of Deepseek, the Deepseek.Monitoring unit is responsible for monitoring ongoing HTTP requests.

The Monitoring interface is accessible by including the Deepseek.Monitoring unit in the uses clause.
Alternatively, you can access it via the HttpMonitoring function, declared in the Deepseek unit.

### Usage example

```Delphi
procedure TForm1.FormCloseQuery(Sender: TObject; var CanClose: Boolean);
begin
  CanClose := not HttpMonitoring.IsBusy;
  if not CanClose then
    MessageDLG(
      'Requests are still in progress. Please wait for them to complete before closing the application."',
      TMsgDlgType.mtInformation, [TMsgDlgBtn.mbOK], 0);
end;
```

<br>

# Contributing

Pull requests are welcome. If you're planning to make a major change, please open an issue first to discuss your proposed changes.

# License

This project is licensed under the [MIT](https://choosealicense.com/licenses/mit/) License.


unit Deepseek.API.Parallel;

interface

uses
  System.SysUtils, System.Classes, System.Generics.Collections, System.SyncObjs, System.Threading,
  Deepseek.Types, Deepseek.Async.Support, Deepseek.API.Params;

type
  /// <summary>
  /// Represents an item in a bundle of chat prompts and responses.
  /// </summary>
  /// <remarks>
  /// This class stores information about a single chat request, including its index,
  /// associated prompt, generated response, and related chat object.
  /// It is used within a <c>TBundleList</c> to manage multiple asynchronous chat requests.
  /// </remarks>
  TBundleItem = class
  private
    FIndex: Integer;
    FFinishIndex: Integer;
    FPrompt: string;
    FResponse: string;
    FChat: TObject;
  public
    /// <summary>
    /// Gets or sets the index of the item in the bundle.
    /// </summary>
    property Index: Integer read FIndex write FIndex;
    /// <summary>
    /// Gets or sets the finishing index of the item after processing.
    /// </summary>
    property FinishIndex: Integer read FFinishIndex write FFinishIndex;
    /// <summary>
    /// Gets or sets the prompt associated with this bundle item.
    /// </summary>
    property Prompt: string read FPrompt write FPrompt;
    /// <summary>
    /// Gets or sets the response generated for the given prompt.
    /// </summary>
    property Response: string read FResponse write FResponse;
    /// <summary>
    /// Gets or sets the chat object associated with this item.
    /// </summary>
    /// <remarks>
    /// This object contains additional information about the chat session,
    /// including metadata related to the AI-generated response.
    /// </remarks>
    property Chat: TObject read FChat write FChat;
    /// <summary>
    /// Destroys the <c>TBundleItem</c> instance and releases associated resources.
    /// </summary>
    /// <remarks>
    /// If a chat object (<c>FChat</c>) is assigned, it is freed upon destruction.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages a collection of <c>TBundleItem</c> objects.
  /// </summary>
  /// <remarks>
  /// This class provides methods to add, retrieve, and count items in a bundle.
  /// It is designed to store multiple chat request items processed in parallel.
  /// The internal storage uses a <c>TObjectList&lt;TBundleItem&gt;</c> with automatic memory management.
  /// </remarks>
  TBundleList = class
  private
    FItems: TObjectList<TBundleItem>;
  public
    /// <summary>
    /// Initializes a new instance of <c>TBundleList</c>.
    /// </summary>
    /// <remarks>
    /// This constructor creates an internal list of <c>TBundleItem</c> objects,
    /// ensuring that items are automatically freed when the list is destroyed.
    /// </remarks>
    constructor Create;
    /// <summary>
    /// Destroys the <c>TBundleList</c> instance and releases all associated resources.
    /// </summary>
    /// <remarks>
    /// This destructor frees all <c>TBundleItem</c> objects stored in the list.
    /// </remarks>
    destructor Destroy; override;
    /// <summary>
    /// Adds a new item to the bundle.
    /// </summary>
    /// <param name="AIndex">
    /// The index of the new item in the bundle.
    /// </param>
    /// <returns>
    /// The newly created <c>TBundleItem</c> instance.
    /// </returns>
    /// <remarks>
    /// This method creates a new <c>TBundleItem</c>, assigns it the specified index,
    /// and adds it to the internal list.
    /// </remarks>
    function Add(const AIndex: Integer): TBundleItem;
    /// <summary>
    /// Retrieves an item from the bundle by its index.
    /// </summary>
    /// <param name="AIndex">
    /// The zero-based index of the item to retrieve.
    /// </param>
    /// <returns>
    /// The <c>TBundleItem</c> instance at the specified index.
    /// </returns>
    /// <exception cref="Exception">
    /// Raised if the specified index is out of bounds.
    /// </exception>
    function Item(const AIndex: Integer): TBundleItem;
    /// <summary>
    /// Gets the total number of items in the bundle.
    /// </summary>
    /// <returns>
    /// The number of items stored in the bundle.
    /// </returns>
    function Count: Integer;
    /// <summary>
    /// Provides direct access to the internal list of <c>TBundleItem</c> objects.
    /// </summary>
    property Items: TObjectList<TBundleItem> read FItems write FItems;
  end;

  /// <summary>
  /// Represents an asynchronous callback buffer for handling chat responses.
  /// </summary>
  /// <remarks>
  /// This class is a specialized type used to manage asynchronous operations
  /// related to chat request processing. It inherits from <c>TAsynCallBack&lt;TBundleList&gt;</c>,
  /// enabling structured handling of callback events.
  /// </remarks>
  TAsynBundleList = TAsynCallBack<TBundleList>;

  /// <summary>
  /// Provides helper methods for managing asynchronous tasks.
  /// </summary>
  /// <remarks>
  /// This class contains utility methods for handling task execution flow,
  /// including a method to execute a follow-up action once a task completes.
  /// <para>
  /// - In order to replace TTask.WaitForAll due to a memory leak in TLightweightEvent/TCompleteEventsWrapper.
  /// See report RSP-12462 and RSP-25999.
  /// </para>
  /// </remarks>
  TTaskHelper = class
  public
    /// <summary>
    /// Executes a specified action after a given task is completed.
    /// </summary>
    /// <param name="Task">
    /// The task to wait for before executing the next action.
    /// </param>
    /// <param name="NextAction">
    /// The procedure to execute once the task is completed.
    /// </param>
    /// <param name="TimeOut">
    /// The maximum time (in milliseconds) to wait for the task to complete.
    /// The default value is 120,000 ms (2 minutes).
    /// </param>
    /// <remarks>
    /// This method waits for the specified task to finish within the provided timeout period.
    /// Once completed, the follow-up action is executed in the main thread using <c>TThread.Queue</c>,
    /// ensuring thread safety.
    /// <para>
    /// - In order to replace TTask.WaitForAll due to a memory leak in TLightweightEvent/TCompleteEventsWrapper.
    /// See report RSP-12462 and RSP-25999.
    /// </para>
    /// </remarks>
    class procedure ContinueWith(const Task: ITask; const NextAction: TProc; const TimeOut: Cardinal = 120000);
  end;

  /// <summary>
  /// Represents the parameters used for configuring a chat request bundle.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TParameters</c> and provides specific methods for setting chat-related
  /// parameters, such as prompts, model selection, and reasoning effort.
  /// It is used to structure and pass multiple requests efficiently in parallel processing.
  /// </remarks>
  TBundleParams = class(TParameters)
  const
    S_PROMPT = 'prompts';
    S_SYSTEM = 'system';
    S_MODEL = 'model';
  public
    /// <summary>
    /// Sets the prompts for the chat request bundle.
    /// </summary>
    /// <param name="Value">
    /// An array of strings containing the prompts to be processed.
    /// </param>
    /// <returns>
    /// The current instance of <c>TBundleParams</c> for method chaining.
    /// </returns>
    function Prompts(const Value: TArray<string>): TBundleParams;
    /// <summary>
    /// Sets the AI model to be used for processing the chat requests.
    /// </summary>
    /// <param name="Value">
    /// A string representing the model name.
    /// </param>
    /// <returns>
    /// The current instance of <c>TBundleParams</c> for method chaining.
    /// </returns>
    function Model(const Value: string): TBundleParams;
    /// <summary>
    /// Sets the system message for the chat request bundle.
    /// </summary>
    /// <param name="Value">
    /// A string containing the system message, which provides context or behavioral instructions
    /// to guide the AI model's responses across all prompts in the bundle.
    /// </param>
    /// <returns>
    /// The current instance of <c>TBundleParams</c> to allow method chaining.
    /// </returns>
    /// <remarks>
    /// The system message is typically used to influence the tone, format, or perspective
    /// of the AI responses, acting as a global directive for the conversation context.
    /// </remarks>
    function System(const Value: string): TBundleParams;
    /// <summary>
    /// Returns prompt array
    /// </summary>
    function GetPrompt: TArray<string>;
    /// <summary>
    /// Returns system or developer instructions
    /// </summary>
    function GetSystem: string;
    /// <summary>
    /// Returns the model name
    /// </summary>
    function GetModel: string;
  end;

implementation

{ TBundleList }

function TBundleList.Add(const AIndex: Integer): TBundleItem;
begin
  Result := TBundleItem.Create;
  Result.Index := AIndex;
  FItems.Add(Result);
end;

function TBundleList.Count: Integer;
begin
  Result := FItems.Count;
end;

constructor TBundleList.Create;
begin
  inherited Create;
  FItems := TObjectList<TBundleItem>.Create(True);
end;

destructor TBundleList.Destroy;
begin
  FItems.Free;
  inherited;
end;

function TBundleList.Item(const AIndex: Integer): TBundleItem;
begin
  if (AIndex < 0) or (AIndex > Pred(Count)) then
    raise Exception.Create('Index out of bounds');
  Result := FItems.Items[AIndex];
end;

{ TTaskHelper }

class procedure TTaskHelper.ContinueWith(const Task: ITask;
  const NextAction: TProc; const TimeOut: Cardinal);
begin
  TTask.Run(
    procedure
    begin
      {--- Wait for the task to complete within TimeOut ms }
      Task.Wait(TimeOut);

      {--- Execute the sequence in the main thread }
      TThread.Queue(nil,
        procedure
        begin
          NextAction();
        end);
    end);
end;

{ TBundleParams }

function TBundleParams.GetModel: string;
begin
  Result := GetString(S_MODEL);
end;

function TBundleParams.GetPrompt: TArray<string>;
begin
  Result := GetArrayString(S_PROMPT);
end;

function TBundleParams.GetSystem: string;
begin
  Result := GetString(S_SYSTEM);
end;

function TBundleParams.Model(const Value: string): TBundleParams;
begin
  Result := TBundleParams(Add(S_MODEL, Value));
end;

function TBundleParams.Prompts(const Value: TArray<string>): TBundleParams;
begin
  Result := TBundleParams(Add(S_PROMPT, Value));
end;

function TBundleParams.System(const Value: string): TBundleParams;
begin
  Result := TBundleParams(Add(S_SYSTEM, Value));
end;

{ TBundleItem }

destructor TBundleItem.Destroy;
begin
  if Assigned(FChat) then
    FChat.Free;
  inherited;
end;

end.

unit Deepseek.API.Params;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiDeepseek
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.Classes, System.JSON, System.SysUtils, System.Types, System.RTTI,
  REST.JsonReflect, REST.Json.Interceptors, System.Generics.Collections,
  System.Threading;

type
  /// <summary>
  /// Represents a reference to a procedure that takes a single argument of type T and returns no value.
  /// </summary>
  /// <param name="T">
  /// The type of the argument that the referenced procedure will accept.
  /// </param>
  /// <remarks>
  /// This type is useful for defining callbacks or procedures that operate on a variable of type T, allowing for more flexible and reusable code.
  /// </remarks>
  TProcRef<T> = reference to procedure(var Arg: T);

  TJSONInterceptorStringToString = class(TJSONInterceptor)
    constructor Create; reintroduce;
  protected
    RTTI: TRttiContext;
  end;

  TJSONParam = class
  private
    FJSON: TJSONObject;
    procedure SetJSON(const Value: TJSONObject);
    function GetCount: Integer;

  public
    constructor Create; virtual;
    destructor Destroy; override;
    function Add(const Key: string; const Value: string): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: Integer): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: Extended): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: Boolean): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: TDateTime; Format: string): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: TJSONValue): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: TJSONParam): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<string>): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<Integer>): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<Extended>): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<TJSONValue>): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<TJSONParam>): TJSONParam; overload; virtual;
    function GetOrCreateObject(const Name: string): TJSONObject;
    function GetOrCreate<T: TJSONValue, constructor>(const Name: string): T;
    procedure Delete(const Key: string); virtual;
    procedure Clear; virtual;
    property Count: Integer read GetCount;
    function Detach: TJSONObject;
    property JSON: TJSONObject read FJSON write SetJSON;
    function ToJsonString(FreeObject: Boolean = False): string; virtual;
    function ToFormat(FreeObject: Boolean = False): string;
    function ToStringPairs: TArray<TPair<string, string>>;
    function ToStream: TStringStream;
  end;

  /// <summary>
  /// Represents a base class for all classes obtained after deserialization.
  /// </summary>
  /// <remarks>
  /// This class is designed to store the raw JSON string returned by the API,
  /// allowing applications to access the original JSON response if needed.
  /// </remarks>
  TJSONFingerprint = class
  private
    FJSONResponse: string;
  public
    /// <summary>
    /// Gets or sets the raw JSON string returned by the API.
    /// </summary>
    /// <remarks>
    /// Typically, the API returns a single JSON string, which is stored in this property.
    /// </remarks>
    property JSONResponse: string read FJSONResponse write FJSONResponse;
  end;

  /// <summary>
  /// Represents a generic key-value parameter manager.
  /// </summary>
  /// <remarks>
  /// This class allows storing and retrieving various types of parameters as key-value pairs.
  /// It supports basic types (integers, strings, booleans, floating-point numbers), objects,
  /// as well as arrays of these types.
  /// </remarks>
  /// <example>
  ///   <code>
  ///     var Params: TParameters;
  ///     begin
  ///       Params := TParameters.Create;
  ///       Params.Add('Limit', 100)
  ///             .Add('Order', 'Asc')
  ///             .Add('IsEnabled', True);
  ///       if Params.Exists('Limit') then
  ///         ShowMessage(IntToStr(Params.GetInteger('Limit')));
  ///       Params.Free;
  ///     end;
  ///   </code>
  /// </example>
  TParameters = class
  private
    FParams: TDictionary<string, TValue>;
  public
    constructor Create;
    destructor Destroy; override;
    function Add(const AKey: string; const AValue: Integer): TParameters; overload;
    function Add(const AKey: string; const AValue: Int64): TParameters; overload;
    function Add(const AKey: string; const AValue: string): TParameters; overload;
    function Add(const AKey: string; const AValue: Single): TParameters; overload;
    function Add(const AKey: string; const AValue: Double): TParameters; overload;
    function Add(const AKey: string; const AValue: Boolean): TParameters; overload;
    function Add(const AKey: string; const AValue: TObject): TParameters; overload;
    function Add(const AKey: string; const AValue: TJSONObject): TParameters; overload;
    function Add(const AKey: string; const AValue: TArray<string>): TParameters; overload;
    function Add(const AKey: string; const AValue: TArray<Integer>): TParameters; overload;
    function Add(const AKey: string; const AValue: TArray<Int64>): TParameters; overload;
    function Add(const AKey: string; const AValue: TArray<Single>): TParameters; overload;
    function Add(const AKey: string; const AValue: TArray<Double>): TParameters; overload;
    function Add(const AKey: string; const AValue: TArray<Boolean>): TParameters; overload;
    function Add(const AKey: string; const AValue: TArray<TObject>): TParameters; overload;
    function Add(const AKey: string; const AValue: TArray<TJSONObject>): TParameters; overload;

    function GetInteger(const AKey: string; const ADefault: Integer = 0): Integer;
    function GetInt64(const AKey: string; const ADefault: Integer = 0): Integer;
    function GetString(const AKey: string; const ADefault: string = ''): string;
    function GetSingle(const AKey: string; const ADefault: Single = 0.0): Double;
    function GetDouble(const AKey: string; const ADefault: Double = 0.0): Double;
    function GetBoolean(const AKey: string; const ADefault: Boolean = False): Boolean;
    function GetObject(const AKey: string; const ADefault: TObject = nil): TObject;
    function GetJSONObject(const AKey: string): TJSONObject;

    function GetArrayString(const AKey: string): TArray<string>;
    function GetArrayInteger(const AKey: string): TArray<Integer>;
    function GetArrayInt64(const AKey: string): TArray<Int64>;
    function GetArraySingle(const AKey: string): TArray<Single>;
    function GetArrayDouble(const AKey: string): TArray<Double>;
    function GetArrayBoolean(const AKey: string): TArray<Boolean>;
    function GetArrayObject(const AKey: string): TArray<TObject>;
    function GetArrayJSONObject(const AKey: string): TArray<TJSONObject>;
    function GetJSONArray(const AKey: string): TJSONArray;

    function Exists(const AKey: string): Boolean;
    procedure ProcessParam(const AKey: string; ACallback: TProc<TValue>);
  end;

const
  DATE_FORMAT = 'YYYY-MM-DD';
  TIME_FORMAT = 'HH:NN:SS';
  DATE_TIME_FORMAT = DATE_FORMAT + ' ' + TIME_FORMAT;

implementation

uses
  System.DateUtils;

{ TJSONInterceptorStringToString }

constructor TJSONInterceptorStringToString.Create;
begin
  ConverterType := ctString;
  ReverterType := rtString;
end;

{ Fetch }

type
  Fetch<T> = class
    type
      TFetchProc = reference to procedure(const Element: T);
  public
    class procedure All(const Items: TArray<T>; Proc: TFetchProc);
  end;

{ Fetch<T> }

class procedure Fetch<T>.All(const Items: TArray<T>; Proc: TFetchProc);
var
  Item: T;
begin
  for Item in Items do
    Proc(Item);
end;

{ TJSONParam }

function TJSONParam.Add(const Key, Value: string): TJSONParam;
begin
  Delete(Key);
  FJSON.AddPair(Key, Value);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: TJSONValue): TJSONParam;
begin
  Delete(Key);
  FJSON.AddPair(Key, Value);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: TJSONParam): TJSONParam;
begin
  Add(Key, TJSONValue(Value.JSON.Clone));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: TDateTime; Format: string): TJSONParam;
begin
  if Format.IsEmpty then
    Format := DATE_TIME_FORMAT;
  Add(Key, FormatDateTime(Format, System.DateUtils.TTimeZone.local.ToUniversalTime(Value)));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: Boolean): TJSONParam;
begin
  Add(Key, TJSONBool.Create(Value));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: Integer): TJSONParam;
begin
  Add(Key, TJSONNumber.Create(Value));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: Extended): TJSONParam;
begin
  Add(Key, TJSONNumber.Create(Value));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<TJSONValue>): TJSONParam;
var
  JArr: TJSONArray;
begin
  JArr := TJSONArray.Create;
  Fetch<TJSONValue>.All(Value, JArr.AddElement);
  Add(Key, JArr);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<TJSONParam>): TJSONParam;
var
  JArr: TJSONArray;
  Item: TJSONParam;
begin
  JArr := TJSONArray.Create;
  for Item in Value do
  try
    JArr.AddElement(Item.JSON);
    Item.JSON := nil;
  finally
    Item.Free;
  end;
  Add(Key, JArr);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<Extended>): TJSONParam;
var
  JArr: TJSONArray;
  Item: Extended;
begin
  JArr := TJSONArray.Create;
  for Item in Value do
    JArr.Add(Item);
  Add(Key, JArr);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<Integer>): TJSONParam;
var
  JArr: TJSONArray;
  Item: Integer;
begin
  JArr := TJSONArray.Create;
  for Item in Value do
    JArr.Add(Item);
  Add(Key, JArr);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<string>): TJSONParam;
var
  JArr: TJSONArray;
  Item: string;
begin
  JArr := TJSONArray.Create;
  for Item in Value do
    JArr.Add(Item);
  Add(Key, JArr);
  Result := Self;
end;

procedure TJSONParam.Clear;
begin
  FJSON.Free;
  FJSON := TJSONObject.Create;
end;

constructor TJSONParam.Create;
begin
  FJSON := TJSONObject.Create;
end;

procedure TJSONParam.Delete(const Key: string);
var
  Item: TJSONPair;
begin
  Item := FJSON.RemovePair(Key);
  if Assigned(Item) then
    Item.Free;
end;

destructor TJSONParam.Destroy;
begin
  if Assigned(FJSON) then
    FJSON.Free;
  inherited;
end;

function TJSONParam.GetCount: Integer;
begin
  Result := FJSON.Count;
end;

function TJSONParam.GetOrCreate<T>(const Name: string): T;
begin
  if not FJSON.TryGetValue<T>(Name, Result) then
  begin
    Result := T.Create;
    FJSON.AddPair(Name, Result);
  end;
end;

function TJSONParam.GetOrCreateObject(const Name: string): TJSONObject;
begin
  Result := GetOrCreate<TJSONObject>(Name);
end;

function TJSONParam.Detach: TJSONObject;
begin
  Result := JSON;
  JSON := nil;
  var Task: ITask := TTask.Create(
    procedure()
    begin
      Sleep(30);
      TThread.Queue(nil,
      procedure
      begin
        Self.Free;
      end);
    end
  );
  Task.Start;
end;

procedure TJSONParam.SetJSON(const Value: TJSONObject);
begin
  FJSON := Value;
end;

function TJSONParam.ToFormat(FreeObject: Boolean): string;
begin
  Result := FJSON.Format(4);
  if FreeObject then
    Free;
end;

function TJSONParam.ToJsonString(FreeObject: Boolean): string;
begin
  Result := FJSON.ToJSON;
  if FreeObject then
    Free;
end;

function TJSONParam.ToStream: TStringStream;
begin
  Result := TStringStream.Create;
  try
    Result.WriteString(ToJsonString);
    Result.Position := 0;
  except
    Result.Free;
    raise;
  end;
end;

function TJSONParam.ToStringPairs: TArray<TPair<string, string>>;
begin
  for var Pair in FJSON do
    Result := Result + [TPair<string, string>.Create(Pair.JsonString.Value, Pair.JsonValue.AsType<string>)];
end;

{ TParameters }

function TParameters.Add(const AKey: string;
  const AValue: Boolean): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, AValue);
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: Double): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, AValue);
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: Integer): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, AValue);
  Result := Self;
end;

function TParameters.Add(const AKey, AValue: string): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, AValue);
  Result := Self;
end;

constructor TParameters.Create;
begin
  inherited Create;
  FParams := TDictionary<string, TValue>.Create;
end;

destructor TParameters.Destroy;
begin
  FParams.Free;
  inherited;
end;

function TParameters.Exists(const AKey: string): Boolean;
begin
  Result := FParams.ContainsKey(AKey.ToLower)
end;

function TParameters.GetArrayBoolean(const AKey: string): TArray<Boolean>;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<TArray<Boolean>> then
    Result := LValue.AsType<TArray<Boolean>>
  else
    Result := [];
end;

function TParameters.GetArrayDouble(const AKey: string): TArray<Double>;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<TArray<Double>> then
    Result := LValue.AsType<TArray<Double>>
  else
    Result := [];
end;

function TParameters.GetArrayInt64(const AKey: string): TArray<Int64>;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<TArray<Int64>> then
    Result := LValue.AsType<TArray<Int64>>
  else
    Result := [];
end;

function TParameters.GetArrayInteger(const AKey: string): TArray<Integer>;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<TArray<Integer>> then
    Result := LValue.AsType<TArray<Integer>>
  else
    Result := [];
end;

function TParameters.GetArrayJSONObject(
  const AKey: string): TArray<TJSONObject>;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<TArray<TJSONObject>> then
    Result := LValue.AsType<TArray<TJSONObject>>
  else
    Result := nil;
end;

function TParameters.GetArrayObject(const AKey: string): TArray<TObject>;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<TArray<TObject>> then
    Result := LValue.AsType<TArray<TObject>>
  else
    Result := [];
end;

function TParameters.GetArraySingle(const AKey: string): TArray<Single>;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<TArray<Single>> then
    Result := LValue.AsType<TArray<Single>>
  else
    Result := [];
end;

function TParameters.GetArrayString(const AKey: string): TArray<string>;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<TArray<string>> then
    Result := LValue.AsType<TArray<string>>
  else
    Result := [];
end;

function TParameters.GetBoolean(const AKey: string;
  const ADefault: Boolean): Boolean;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<Boolean> then
    Result := LValue.AsBoolean
  else
    Result := ADefault;
end;

function TParameters.GetDouble(const AKey: string;
  const ADefault: Double): Double;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<Double> then
    Result := LValue.AsType<Double>
  else
    Result := ADefault;
end;

function TParameters.GetInt64(const AKey: string;
  const ADefault: Integer): Integer;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<Int64> then
    Result := LValue.AsInt64
  else
    Result := ADefault;
end;

function TParameters.GetInteger(const AKey: string;
  const ADefault: Integer): Integer;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<Integer> then
    Result := LValue.AsInteger
  else
    Result := ADefault;
end;

function TParameters.GetJSONArray(const AKey: string): TJSONArray;
begin
  Result := TJSONArray.Create;
  for var Item in GetArrayJSONObject(AKey) do
    Result.Add(Item);
end;

function TParameters.GetJSONObject(const AKey: string): TJSONObject;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<TJSONObject> then
    Result := LValue.AsType<TJSONObject>
  else
    Result := nil;
end;

function TParameters.GetObject(const AKey: string;
  const ADefault: TObject): TObject;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsObject then
    Result := LValue.AsObject
  else
    Result := ADefault;
end;

function TParameters.GetSingle(const AKey: string;
  const ADefault: Single): Double;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<Single> then
    Result := LValue.AsType<Single>
  else
    Result := ADefault;
end;

function TParameters.GetString(const AKey, ADefault: string): string;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<string> then
    Result := LValue.AsString
  else
    Result := ADefault;
end;

procedure TParameters.ProcessParam(const AKey: string;
  ACallback: TProc<TValue>);
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) then
    ACallback(LValue);
end;

function TParameters.Add(const AKey: string;
  const AValue: TArray<string>): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, TValue.From<TArray<string>>(AValue));
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: TArray<Integer>): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, TValue.From<TArray<Integer>>(AValue));
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: TArray<Double>): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, TValue.From<TArray<Double>>(AValue));
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: TArray<Boolean>): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, TValue.From<TArray<Boolean>>(AValue));
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: TObject): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, AValue);
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: TArray<Single>): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, TValue.From<TArray<Single>>(AValue));
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: Single): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, AValue);
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: TArray<Int64>): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, TValue.From<TArray<Int64>>(AValue));
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: Int64): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, AValue);
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: TArray<TObject>): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, TValue.From<TArray<TObject>>(AValue));
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: TJSONObject): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, AValue);
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: TArray<TJSONObject>): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, TValue.From<TArray<TJSONObject>>(AValue));
  Result := Self;
end;

end.

unit Deepseek.API;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiDeepseek
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.Classes, System.Net.HttpClient, System.Net.URLClient, System.Net.Mime,
  System.JSON, Deepseek.Errors, Deepseek.API.Params, System.SysUtils, Deepseek.HttpClient,
  Deepseek.HttpClient.Intf, Deepseek.Exception, Deepseek.Monitoring;

type
  TDeepseekConfiguration = class
  const
    URL_BASE = 'https://api.deepseek.com';
  private
    FAPIKey: string;
    FBaseUrl: string;
    procedure SetAPIKey(const Value: string);
    procedure SetBaseUrl(const Value: string);
  public
    constructor Create;
    procedure APICheck;
    property APIKey: string read FAPIKey write SetAPIKey;
    property BaseUrl: string read FBaseUrl write SetBaseUrl;
  end;

  TApiHttpHandler = class(TDeepseekConfiguration)
  private
    FCustomHeaders: TNetHeaders;
    procedure SetCustomHeaders(const Value: TNetHeaders);
  protected
    FClientHttp: IHttpClientAPI;
    function GetClientHttp: IHttpClientAPI;
    function GetHeaders: TNetHeaders;
    function BuildHeaders: TNetHeaders;
    function BuildUrl(const Endpoint: string): string;
  public
    function Client: IHttpClientAPI;
    property ClientHttp: IHttpClientAPI read GetClientHttp;
    property CustomHeaders: TNetHeaders read FCustomHeaders write SetCustomHeaders;
  end;

  TDeepseekAPI = class(TApiHttpHandler)
  private
    procedure RaiseError(Code: Int64; Error: TErrorCore);
    procedure DeserializeErrorData(const Code: Int64; const ResponseText: string);
    function Deserialize<T: class, constructor>(const Code: Int64; const ResponseText: string): T; overload;
  public
    function Get<TResult: class, constructor>(const Path: string): TResult; overload;
    procedure GetFile(const Path: string; Response: TStream); overload;
    function Delete<TResult: class, constructor>(const Path: string): TResult; overload;
    function Post<TParams: TJSONParam>(const Path: string; ParamProc: TProc<TParams>; Response: TStringStream; Event: TReceiveDataCallback = nil): Boolean; overload;
    function Post<TResult: class, constructor; TParams: TJSONParam>(const Path: string; ParamProc: TProc<TParams>): TResult; overload;
    function Post<TResult: class, constructor>(const Path: string): TResult; overload;
    function PostForm<TResult: class, constructor; TParams: TMultipartFormData, constructor>(const Path: string; ParamProc: TProc<TParams>): TResult; overload;
    function PostForm<TResult: class, constructor; TParams: TMultipartFormData, constructor>(const Path: string; ParamProc: TProc<TParams>;
      var ResponseHeader: TNetHeaders): TResult; overload;
  public
    constructor Create; overload;
    constructor Create(const AAPIKey: string); overload;
    class function Parse<T: class, constructor>(const Value: string): T;
  end;

  TDeepseekAPIRoute = class
  private
    FAPI: TDeepseekAPI;
    procedure SetAPI(const Value: TDeepseekAPI);
  protected
    procedure HeaderCustomize; virtual;
  public
    property API: TDeepseekAPI read FAPI write SetAPI;
    constructor CreateRoute(AAPI: TDeepseekAPI); reintroduce;
  end;

implementation

uses
  System.StrUtils, REST.Json, System.NetConsts;

constructor TDeepseekAPI.Create;
begin
  inherited;
  FAPIKey := EmptyStr;
  FBaseUrl := URL_BASE;
  FClientHttp := THttpClientAPI.CreateInstance(APICheck);
end;

constructor TDeepseekAPI.Create(const AAPIKey: string);
begin
  Create;
  APIKey := AAPIKey;
end;

function TDeepseekAPI.Post<TResult, TParams>(const Path: string; ParamProc: TProc<TParams>): TResult;
var
  Response: TStringStream;
  Params: TParams;
  Code: Integer;
begin
  Monitoring.Inc;
  Response := TStringStream.Create('', TEncoding.UTF8);
  Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    Code := Client.Post(BuildUrl(Path), Params.JSON, Response, BuildHeaders, nil);
    Result := Deserialize<TResult>(Code, Response.DataString)
  finally
    Params.Free;
    Response.Free;
    Monitoring.Dec;
  end;
end;

function TDeepseekAPI.Post<TParams>(const Path: string; ParamProc: TProc<TParams>; Response: TStringStream; Event: TReceiveDataCallback): Boolean;
var
  Params: TParams;
  Code: Integer;
begin
  Monitoring.Inc;
  Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    Code := Client.Post(BuildUrl(Path), Params.JSON, Response, BuildHeaders, Event);
    case Code of
      200..299:
        Result := True;
    else
      Result := False;
    end;
  finally
    Params.Free;
    Monitoring.Dec;
  end;
end;

function TDeepseekAPI.Post<TResult>(const Path: string): TResult;
var
  Response: TStringStream;
  Code: Integer;
begin
  Monitoring.Inc;
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Code := Client.Post(BuildUrl(Path), Response, BuildHeaders);
    Result := Deserialize<TResult>(Code, Response.DataString);
  finally
    Response.Free;
    Monitoring.Dec;
  end;
end;

function TDeepseekAPI.Delete<TResult>(const Path: string): TResult;
var
  Response: TStringStream;
  Code: Integer;
begin
  Monitoring.Inc;
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Code := Client.Delete(BuildUrl(Path), Response, BuildHeaders);
    Result := Deserialize<TResult>(Code, Response.DataString);
  finally
    Response.Free;
    Monitoring.Dec;
  end;
end;

function TDeepseekAPI.PostForm<TResult, TParams>(const Path: string;
  ParamProc: TProc<TParams>; var ResponseHeader: TNetHeaders): TResult;
begin
  Monitoring.Inc;
  var Response := TStringStream.Create('', TEncoding.UTF8);
  var Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    var Code := Client.Post(BuildUrl(Path), Params, Response, ResponseHeader);
    Result := Deserialize<TResult>(Code, Response.DataString);
  finally
    Params.Free;
    Response.Free;
    Monitoring.Dec;
  end;
end;

function TDeepseekAPI.PostForm<TResult, TParams>(const Path: string; ParamProc: TProc<TParams>): TResult;
var
  ResponseHeader: TNetHeaders;
begin
  Result := PostForm<TResult, TParams>(Path, ParamProc, ResponseHeader);
end;

function TDeepseekAPI.Get<TResult>(const Path: string): TResult;
var
  Response: TStringStream;
  Code: Integer;
begin
  Monitoring.Inc;
  CustomHeaders := [TNetHeader.Create('accept', 'application/json')];
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Code := Client.Get(BuildUrl(Path), Response, GetHeaders);
    Result := Deserialize<TResult>(Code, Response.DataString);
  finally
    Response.Free;
    Monitoring.Dec;
  end;
end;

procedure TDeepseekAPI.GetFile(const Path: string; Response: TStream);
var
  Code: Integer;
  Strings: TStringStream;
begin
  Monitoring.Inc;
  try
    Code := Client.Get(BuildUrl(Path), Response, GetHeaders);
    case Code of
      200..299:
        ; {success}
    else
      Strings := TStringStream.Create;
      try
        Response.Position := 0;
        Strings.LoadFromStream(Response);
        DeserializeErrorData(Code, Strings.DataString);
      finally
        Strings.Free;
      end;
    end;
  finally
    Monitoring.Dec;
  end;
end;

procedure TDeepseekAPI.RaiseError(Code: Int64; Error: TErrorCore);
begin
  case Code of
    {--- Client Error Codes }
    400:
      raise TDeepseekExceptionInvalidFormatError.Create(Code, Error);
    401:
      raise TDeepseekExceptionAuthenticationFailsError.Create(Code, Error);
    402:
      raise TDeepseekExceptionInsufficientBalanceError.Create(Code, Error);
    422:
      raise TDeepseekExceptionInvalidParametersError.Create(Code, Error);
    429:
      raise TDeepseekExceptionRateLimitReachedError.Create(Code, Error);
    {--- Server Error Codes }
    500:
      raise TDeepseekExceptionServerError.Create(Code, Error);
    503:
      raise TDeepseekExceptionServerOverloadeError.Create(Code, Error);
  else
    raise TDeepseekException.Create(Code, Error);
  end;
end;

class function TDeepseekAPI.Parse<T>(const Value: string): T;
begin
  Result := TJson.JsonToObject<T>(Value);

  {--- Add JSON response if class inherits from TJSONFingerprint class. }
  if Assigned(Result) and T.InheritsFrom(TJSONFingerprint) then
    begin
      var JSONValue := TJSONObject.ParseJSONValue(Value);
      try
        (Result as TJSONFingerprint).JSONResponse := JSONValue.Format();
      finally
        JSONValue.Free;
      end;
    end;
end;

procedure TDeepseekAPI.DeserializeErrorData(const Code: Int64; const ResponseText: string);
var
  Error: TErrorCore;
begin
  Error := nil;
  try
    try
      Error := TJson.JsonToObject<TError>(ResponseText);
    except
      Error := nil;
    end;
    if Assigned(Error) and Assigned(Error) then
      RaiseError(Code, Error)
  finally
    if Assigned(Error) then
      Error.Free;
  end;
end;

function TDeepseekAPI.Deserialize<T>(const Code: Int64; const ResponseText: string): T;
begin
  Result := nil;
  case Code of
    200..299:
      try
        Result := Parse<T>(ResponseText);
      except
        FreeAndNil(Result);
      end;
  else
    DeserializeErrorData(Code, ResponseText);
  end;
  if not Assigned(Result) then
    raise TDeepseekExceptionInvalidResponse.Create(Code, 'Empty or invalid response');
end;

{ TDeepseekAPIRoute }

constructor TDeepseekAPIRoute.CreateRoute(AAPI: TDeepseekAPI);
begin
  inherited Create;
  FAPI := AAPI;
end;

procedure TDeepseekAPIRoute.HeaderCustomize;
begin

end;

procedure TDeepseekAPIRoute.SetAPI(const Value: TDeepseekAPI);
begin
  FAPI := Value;
end;

{ TDeepseekConfiguration }

procedure TDeepseekConfiguration.APICheck;
begin
  if FAPIKey.IsEmpty or FBaseUrl.IsEmpty then
    raise TDeepseekExceptionAPI.Create('Invalid API key or base URL.');
end;

constructor TDeepseekConfiguration.Create;
begin
  inherited;
  FAPIKey := EmptyStr;
  FBaseUrl := URL_BASE;
end;

procedure TDeepseekConfiguration.SetAPIKey(const Value: string);
begin
  FAPIKey := Value;
end;

procedure TDeepseekConfiguration.SetBaseUrl(const Value: string);
begin
  FBaseUrl := Value;
end;

{ TApiHttpHandler }

function TApiHttpHandler.BuildHeaders: TNetHeaders;
begin
  Result := GetHeaders + [TNetHeader.Create('Content-Type', 'application/json')];
end;

function TApiHttpHandler.BuildUrl(const Endpoint: string): string;
begin
  Result := FBaseUrl.TrimRight(['/']) + '/' + Endpoint.TrimLeft(['/']);
end;

function TApiHttpHandler.Client: IHttpClientAPI;
begin
  Result := THttpClientAPI.CreateInstance(APICheck);
  Result.SendTimeOut := ClientHttp.SendTimeOut;
  Result.ConnectionTimeout := ClientHttp.ConnectionTimeout;
  Result.ResponseTimeout := ClientHttp.ResponseTimeout;
  var Proxy := ClientHttp.ProxySettings;
  Result.ProxySettings := TProxySettings.Create(Proxy.Host, Proxy.Port, Proxy.UserName, Proxy.Password, Proxy.Scheme);
end;

function TApiHttpHandler.GetClientHttp: IHttpClientAPI;
begin
  Result := FClientHttp;
end;

function TApiHttpHandler.GetHeaders: TNetHeaders;
begin
  Result :=
    [TNetHeader.Create('authorization', 'Bearer ' + FAPIKey)] +
    FCustomHeaders;
end;

procedure TApiHttpHandler.SetCustomHeaders(const Value: TNetHeaders);
begin
  FCustomHeaders := Value;
end;

end.

unit Deepseek.Async.Params;

{-------------------------------------------------------------------------------

      Unit containing generic interfaces and classes for managing parameters
      across  various  asynchronous  operations.

      The HuggingFace.Async.Params  unit  provides  a set of tools for creating
      and managing  parameter  instances  using  generic  types. The primary
      components include:

      - IUseParams<T>: A generic interface for managing parameters of type T.
      - TUseParams<T>: A class  implementing  the IUseParams<T>  interface to
        encapsulate  parameter  handling.
      - TUseParamsFactory<T>: A  factory  class  for  creating  instances  of
        IUseParams<T>.

      These abstractions allow for  a flexible and  reusable  way  to  handle
      parameters  across  different  modules  and  contexts,  particularly in
      asynchronous  scenarios  such  as  chat  operations.

      Note  that  This  unit  is  designed   to  work   seamlessly  with  the
      Gemini.Chat.AsyncEvents unit,  which  relies  on  IUseParams<T> and
      TUseParamsFactory<T>  to  manage   parameters   for  asynchronous  chat
      requests.

        Github repository :  https://github.com/MaxiDonkey/DelphiDeepseek
        Visit the Github repository for the documentation and use examples

-------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes;

type
  /// <summary>
  /// Generic interface for managing parameters of type <c>T</c>.
  /// </summary>
  /// <typeparam name="T">
  /// The type of the parameters.
  /// </typeparam>
  IUseParams<T> = interface
    ['{18566F2C-F2D9-4257-A460-D9AE8F053357}']
    /// <summary>
    /// Sets the parameters.
    /// </summary>
    /// <param name="Value">
    /// The value of the parameters to be set.
    /// </param>
    procedure SetParams(const Value: T);
    /// <summary>
    /// Gets the current parameters.
    /// </summary>
    /// <returns>
    /// The current parameters of type <c>T</c>.
    /// </returns>
    function GetParams: T;
    /// <summary>
    /// Assigns the parameters using a function.
    /// </summary>
    /// <param name="Value">
    /// A function that returns parameters of type <c>T</c>.
    /// </param>
    procedure Assign(Value: TFunc<T>);
    /// <summary>
    /// Returns the current instance as an object of type <c>TObject</c>.
    /// </summary>
    /// <returns>
    /// The instance cast to <c>TObject</c>.
    /// </returns>
    function AsSender: TObject;
    /// <summary>
    /// Provides access to the parameters as a property.
    /// </summary>
    property Param: T read GetParams write SetParams;
  end;

  /// <summary>
  /// A factory class for creating instances of <c>IUseParams</c>.
  /// </summary>
  /// <param name="T">
  /// The type of the parameters for which the instance is created.
  /// </param>
  TUseParamsFactory<T> = class
    /// <summary>
    /// Creates and returns a new instance of <c>IUseParams</c> for the specified type <c>T</c>.
    /// </summary>
    /// <returns>
    /// A new instance of <c>IUseParams&lt;T&gt;</c>.
    /// </returns>
    class function CreateInstance: IUseParams<T>; overload;
    /// <summary>
    /// Creates and returns a new instance of <c>IUseParams</c> for the specified type <c>T</c>, using the provided function.
    /// </summary>
    /// <param name="Value">
    /// A function that provides the parameter values for the instance.
    /// </param>
    /// <returns>
    /// A new instance of <c>IUseParams&lt;T&gt;</c>.
    /// </returns>
    class function CreateInstance(Value: TFunc<T>): IUseParams<T>; overload;
  end;

  /// <summary>
  /// A generic class implementing the <c>IUseParams</c> interface to manage parameters of type <c>T</c>.
  /// </summary>
  /// <param name="T">
  /// The type of the parameters.
  /// </param>
  TUseParams<T> = class(TInterfacedObject, IUseParams<T>)
  private
    FParams: T;
    /// <summary>
    /// Sets the parameters to the provided value.
    /// </summary>
    /// <param name="Value">
    /// The new parameters value.
    /// </param>
    procedure SetParams(const Value: T);
    /// <summary>
    /// Retrieves the current parameters value.
    /// </summary>
    /// <returns>
    /// The current parameters.
    /// </returns>
    function GetParams: T;
  protected
    /// <summary>
    /// Casts the instance as a <c>TObject</c> for use as the sender of events.
    /// </summary>
    /// <returns>
    /// The current instance cast to <c>TObject</c>.
    /// </returns>
    function AsSender: TObject;
    /// <summary>
    /// Assigns the parameters using a function that returns type <c>T</c>.
    /// </summary>
    /// <param name="Value">
    /// A function that sets the parameters.
    /// </param>
    procedure Assign(Value: TFunc<T>);
  public
    /// <summary>
    /// Property to get or set the parameters.
    /// </summary>
    property Params: T read GetParams write SetParams;
  end;

implementation

{ TUseParams<T> }

function TUseParams<T>.AsSender: TObject;
begin
  Result := Self;
end;

procedure TUseParams<T>.Assign(Value: TFunc<T>);
begin
  if Assigned(Value) then
    begin
      Params := Value();
    end;
end;

function TUseParams<T>.GetParams: T;
begin
  Result := FParams;
end;

procedure TUseParams<T>.SetParams(const Value: T);
begin
  FParams := Value;
end;

{ TUseParamsFactory<T> }

class function TUseParamsFactory<T>.CreateInstance: IUseParams<T>;
begin
  Result := TUseParams<T>.Create;
end;

class function TUseParamsFactory<T>.CreateInstance(
  Value: TFunc<T>): IUseParams<T>;
begin
  Result := CreateInstance;
  Result.Assign(Value);
end;

end.

unit Deepseek.Async.Promise;

(*******************************************************************************

      Unit providing a generic implementation of Promises for handling
      asynchronous operations in Delphi.

      The ASync.Promise unit enables structured handling of asynchronous
      tasks using Promises, allowing for a clean and readable
      asynchronous programming model similar to JavaScript Promises.

      Primary components include:

        - TPromise<T>: A generic class representing a promise that can be
          resolved or rejected asynchronously.
        - TPromiseState: An enumeration indicating the state of a promise
          (Pending, Fulfilled, or Rejected).
        - TPromiseRegistry: An internal registry that tracks all pending
          promises to prevent premature destruction.
        - Chained methods for structured handling:
          - &Then<T>: Chains operations to execute after a promise resolves.
          - &Catch: Handles errors occurring within a promise chain.

      These abstractions allow a structured and reusable way to manage
      asynchronous execution without deeply nested callbacks, facilitating
      a cleaner approach to asynchronous programming in Delphi.

  Example Usage:

  ```delphi
  procedure ExampleAsyncProcess;
  begin
    var Promise := TPromise<string>.Create(
      procedure(Resolve: TProc<string>; Reject: TProc<Exception>)
      begin
        TThread.CreateAnonymousThread(
          procedure
          begin
            Sleep(2000); // Simulating asynchronous work
            if Random(2) = 0 then
              Resolve('Operation Successful')
            else
              Reject(Exception.Create('Operation Failed'));
          end
        ).Start;
      end);

    Promise
      .&Then(
        procedure(Value: string)
        begin
          ShowMessage('Success: ' + Value);
        end)
      .&Catch(
        procedure(E: Exception)
        begin
          ShowMessage('Error: ' + E.Message);
        end);
  end;
  ```

      The unit is designed to work seamlessly with other asynchronous
      programming modules, making it a powerful addition to any Delphi
      application requiring structured async execution.

      Github repository :  https://github.com/MaxiDonkey/DelphiDeepseek
      Visit the Github repository for the documentation and use examples

*******************************************************************************)

interface

uses
  System.SysUtils, System.Generics.Collections, System.Classes;

type
  /// <summary>
  /// Represents the state of a Promise.
  /// </summary>
  TPromiseState = (
    /// <summary>
    /// The promise is pending and has not yet been resolved or rejected.
    /// </summary>
    psPending,
    /// <summary>
    /// The promise has been fulfilled with a value.
    /// </summary>
    psFulfilled,
    /// <summary>
    /// The promise has been rejected due to an error.
    /// </summary>
    psRejected
  );

  /// <summary>
  /// Abstract base class for promise implementations.
  /// </summary>
  /// <remarks>
  /// Provides a common interface for retrieving the current state
  /// of a promise. All concrete promise types must implement
  /// <see cref="GetState"/> to indicate whether they are pending,
  /// fulfilled, or rejected.
  /// </remarks>
  TPromiseBase = class abstract
  strict protected
    /// <summary>
    /// Returns the current state of the promise.
    /// </summary>
    /// <returns>
    /// A <see cref="TPromiseState"/> value indicating whether the
    /// promise is pending, fulfilled, or rejected.
    /// </returns>
    function GetState: TPromiseState; virtual; abstract;
  public
    /// <summary>
    /// Read-only property exposing the promise’s current state.
    /// </summary>
    /// <value>
    /// The <see cref="TPromiseState"/> of the promise.
    /// </value>
    property State: TPromiseState read GetState;
  end;

  /// <summary>
  /// A generic class that represents an asynchronous operation that may complete in the future.
  /// </summary>
  /// <typeparam name="T">The type of the value that the promise resolves with.</typeparam>
  TPromise<T> = class(TPromiseBase)
  public
    type
      /// <summary>
      /// Defines the executor procedure for a promise, providing callbacks
      /// to signal fulfillment or rejection of the asynchronous operation.
      /// </summary>
      /// <param name="Resolve">
      /// A callback that accepts a value of type T and transitions the promise
      /// into the fulfilled state with that value.
      /// </param>
      /// <param name="Reject">
      /// A callback that accepts an Exception and transitions the promise
      /// into the rejected state with that error.
      /// </param>
      TExecutor = reference to procedure(Resolve: TProc<T>; Reject: TProc<Exception>);
  private
    FState: TPromiseState;
    FValue: T;
    FError: Exception;
    FThenHandlers: TList<TProc<T>>;
    FCatchHandlers: TList<TProc<Exception>>;
    FHandlerLock: TObject;

    class function CloneException(E: Exception): Exception; static;

    /// <summary>
    /// Resolves the promise with a given value.
    /// </summary>
    /// <param name="AValue">The value to resolve the promise with.</param>
    procedure Resolve(const AValue: T);

    /// <summary>
    /// Rejects the promise with a given error.
    /// </summary>
    /// <param name="AError">The exception that caused the rejection.</param>
    procedure Reject(AError: Exception);

  strict protected
    /// <summary>
    /// Returns the current state of the promise.
    /// </summary>
    /// <returns>
    /// A <see cref="TPromiseState"/> value indicating whether the
    /// promise is pending, fulfilled, or rejected.
    /// </returns>
    function GetState: TPromiseState; override;

  public
    /// <summary>
    /// Initializes a new instance of the <see cref="TPromise{T}"/> class and starts the asynchronous operation.
    /// </summary>
    /// <param name="AExecutor">The executor function that starts the asynchronous task.</param>
    constructor Create(AExecutor: TExecutor);

    /// <summary>
    /// Destroys the promise instance and releases any associated resources.
    /// </summary>
    destructor Destroy; override;

    /// <summary>
    /// Attaches a fulfillment callback that is executed when the promise is resolved.
    /// </summary>
    /// <param name="AOnFulfill">A callback function executed upon fulfillment.</param>
    /// <returns>A new promise to allow method chaining.</returns>
    function &Then(AOnFulfill: TProc): TPromise<T>; overload;

    /// <summary>
    /// Attaches a fulfillment callback that receives the resolved value.
    /// </summary>
    /// <param name="AOnFulfill">A callback function that receives the resolved value.</param>
    /// <returns>A new promise to allow method chaining.</returns>
    function &Then(AOnFulfill: TProc<T>): TPromise<T>; overload;

    /// <summary>
    /// Attaches a fulfillment callback that returns a transformed value of a different type.
    /// </summary>
    /// <typeparam name="TResult">The type of the transformed result.</typeparam>
    /// <param name="AOnFulfill">A function that produces the transformed result.</param>
    /// <returns>A new promise that resolves with the transformed value.</returns>
    function &Then<TResult>(AOnFulfill: TFunc<TResult>): TPromise<TResult>; overload;

    /// <summary>
    /// Attaches a fulfillment callback that returns another promise of a different type.
    /// </summary>
    /// <typeparam name="TResult">The type of the new promise’s result.</typeparam>
    /// <param name="AOnFulfill">A function that returns a new promise.</param>
    /// <returns>A new promise that resolves with the value of the returned promise.</returns>
    function &Then<TResult>(AOnFulfill: TFunc<T, TPromise<TResult>>): TPromise<TResult>; overload;

    /// <summary>
    /// Attaches a fulfillment callback that returns another promise of the same type.
    /// </summary>
    /// <param name="AOnFulfill">A function that returns a new promise of the same type.</param>
    /// <returns>A new promise that resolves with the value of the returned promise.</returns>
    function &Then(AOnFulfill: TFunc<T, TPromise<T>>): TPromise<T>; overload;

    /// <summary>
    /// Attaches a fulfillment callback that transforms the resolved value into another type.
    /// </summary>
    /// <typeparam name="TResult">The type of the transformed value.</typeparam>
    /// <param name="AOnFulfill">A function that transforms the resolved value.</param>
    /// <returns>A new promise that resolves with the transformed value.</returns>
    function &Then<TResult>(AOnFulfill: TFunc<T, TResult>): TPromise<TResult>; overload;

    /// <summary>
    /// Attaches a rejection callback to handle errors if the promise is rejected.
    /// </summary>
    /// <param name="AOnReject">A callback function that handles the error.</param>
    /// <returns>A new promise to allow method chaining.</returns>
    function &Catch(AOnReject: TProc<Exception>): TPromise<T>;
  end;

  /// <summary>
  /// Maintains a global registry of all pending promises, ensuring they
  /// are kept alive until they are fulfilled or rejected.
  /// </summary>
  /// <remarks>
  /// This sealed class provides thread-safe methods to add and remove
  /// promises from the registry, as well as a manual cleanup routine
  /// to prune completed promises.  It is used internally by
  /// <see cref="TPromise{T}"/> to prevent premature destruction of
  /// promises that are still pending.
  /// </remarks>
  TPromiseRegistry = class sealed
  strict private
    class var FList : TObjectList<TObject>;
    class var FLock : TObject;
  public
    /// <summary>
    /// Initializes the promise registry and its internal lock.
    /// </summary>
    class constructor Create;

    /// <summary>
    /// Releases all resources held by the promise registry.
    /// </summary>
    class destructor  Destroy;

    /// <summary>
    /// Adds a promise instance to the registry, preventing it
    /// from being freed until it transitions out of the pending state.
    /// </summary>
    /// <param name="APromise">
    /// The promise instance to register.
    /// </param>
    class procedure Add(APromise: TObject);

    /// <summary>
    /// Removes a promise instance from the registry, allowing it
    /// to be freed if it is no longer referenced elsewhere.
    /// </summary>
    /// <param name="APromise">
    /// The promise instance to unregister.
    /// </param>
    class procedure Remove(APromise: TObject);

    /// <summary>
    /// Scans the registry and deletes any promises that are no longer
    /// pending (i.e., fulfilled or rejected), releasing their memory.
    /// </summary>
    /// <remarks>
    /// This method can be called manually if you need to force
    /// cleanup of completed promises before their <see cref="TPromise{T}"/>
    /// callbacks are all delivered.
    /// </remarks>
    class procedure Cleanup;

    /// <summary>
    /// Removes and frees all promises in the registry, regardless of their state.
    /// </summary>
    /// <remarks>
    /// Acquires the internal lock to ensure thread safety, then iterates through
    /// the list of registered promises and deletes each one.  This will release
    /// both pending and completed promises from memory.  Use with caution, as
    /// any still-pending promises will be destroyed immediately.
    /// </remarks>
    class procedure Clear;
  end;

implementation

{ TPromise<T> }

class function TPromise<T>.CloneException(E: Exception): Exception;
var
  ExClass: ExceptClass ;
begin
  ExClass := ExceptClass(E.ClassType);
  Result := ExClass.Create(E.Message);
end;

constructor TPromise<T>.Create(AExecutor: TExecutor);
begin
  inherited Create;
  FHandlerLock := TObject.Create;
  FState := psPending;
  TPromiseRegistry.Add(Self);
  FThenHandlers := TList<TProc<T>>.Create;
  FCatchHandlers := TList<TProc<Exception>>.Create;
  try
    {--- The executor function that starts the asynchronous task. }
    AExecutor(
      procedure(AValue: T)
      begin
        Self.Resolve(AValue);
      end,

      {--- OnReject — clone then free the original }
      procedure(E: Exception)
      begin
        var Cloned := CloneException(E);
        {--- releases the original exception }
        E.Free;
        Self.Reject(Cloned);
      end
    );
  except
    on E: Exception do
    begin
      var Cloned := CloneException(E);
      {--- E.Free; Do not release E here because Delphi takes care of it }
      Reject(Cloned);
    end;
  end;
end;

destructor TPromise<T>.Destroy;
begin
  if Assigned(FError) then
    FError.Free;
  FThenHandlers.Free;
  FCatchHandlers.Free;
  FHandlerLock.Free;
  inherited;
end;

function TPromise<T>.GetState: TPromiseState;
begin
  Result := FState;
end;

procedure TPromise<T>.Resolve(const AValue: T);
var
  Handlers: TArray<TProc<T>>;
  Handler: TProc<T>;
begin
  if FState <> psPending then
    Exit;

  FState := psFulfilled;
  FValue := AValue;

  {--- Copy the locked callback list }
  TMonitor.Enter(FHandlerLock);
  try
    Handlers := FThenHandlers.ToArray;
  finally
    TMonitor.Exit(FHandlerLock);
  end;

  {--- Asynchronously call all “then” callbacks }
  for Handler in Handlers do
    TThread.Queue(nil,
      procedure
      begin
        Handler(FValue);
      end);

  {--- Empty locked lists }
  TMonitor.Enter(FHandlerLock);
  try
    FThenHandlers.Clear;
    FCatchHandlers.Clear;
  finally
    TMonitor.Exit(FHandlerLock);
  end;

  {--- Safe destruction because we are out of the register }
  TPromiseRegistry.Remove(Self);
end;

procedure TPromise<T>.Reject(AError: Exception);
var
  Handlers: TArray<TProc<Exception>>;
  Handler: TProc<Exception>;
begin
  if FState <> psPending then
    begin
      AError.Free;
      Exit;
    end;

  FState := psRejected;
  FError := AError;

  {--- Copy the locked callback list }
  TMonitor.Enter(FHandlerLock);
  try
    Handlers := FCatchHandlers.ToArray;
  finally
    TMonitor.Exit(FHandlerLock);
  end;

  {--- Call all “catch” callbacks }
  for Handler in Handlers do
    TThread.Queue(nil,
      procedure
      begin
        Handler(FError);
      end);

  {--- Empty locked lists }
  TMonitor.Enter(FHandlerLock);
  try
    FThenHandlers.Clear;
    FCatchHandlers.Clear;
  finally
    TMonitor.Exit(FHandlerLock);
  end;

  {--- Safe destruction because we are out of the register }
  TPromiseRegistry.Remove(Self);
end;

function TPromise<T>.&Then(AOnFulfill: TProc<T>): TPromise<T>;
begin
  {--- Version without transformation: we wrap the procedure in a function which returns the unchanged value }
  Result := &Then<T>(
    function(Value: T): T
    begin
      AOnFulfill(Value);
      Result := Value;
    end);
end;

function TPromise<T>.&Then<TResult>(AOnFulfill: TFunc<T, TResult>): TPromise<TResult>;
begin
  {--- Creation of a new promise that will be resolved when this one is resolved }
  Result := TPromise<TResult>.Create(
    procedure(Resolve: TProc<TResult>; Reject: TProc<Exception>)
    begin
      if FState = psFulfilled then
        begin
          try
            Resolve(AOnFulfill(FValue));
          except
            on E: Exception do
              Reject(CloneException(E));
          end;
        end
      else
      if FState = psRejected then
        begin
          Reject(CloneException(FError))
        end
      else
        begin
          {--- If the operation is not yet complete, we add callbacks for chaining }
          TMonitor.Enter(FHandlerLock);
          try
            FThenHandlers.Add(
              procedure(Value: T)
              begin
                try
                  Resolve(AOnFulfill(Value));
                except
                  on E: Exception do
                    Reject(CloneException(E));
                end;
              end);
            FCatchHandlers.Add(
              procedure(E: Exception)
              begin
                Reject(CloneException(E));
              end);
          finally
            TMonitor.Exit(FHandlerLock);
          end;
        end;
    end);
end;

function TPromise<T>.&Then(AOnFulfill: TFunc<T, TPromise<T>>): TPromise<T>;
begin
  Result := TPromise<T>.Create(
    procedure(Resolve: TProc<T>; Reject: TProc<Exception>)
    begin
      if FState = psFulfilled then
        begin
          try
            AOnFulfill(FValue)
              .&Then(
                procedure(NewValue: T)
                begin
                  Resolve(NewValue);
                end)
              .&Catch(
                procedure(E: Exception)
                begin
                  Reject(CloneException(E));
                end);
          except
            on E: Exception do
              Reject(CloneException(E));
          end;
        end
      else
      if FState = psRejected then
        begin
          Reject(CloneException(FError))
        end
      else
        begin
          TMonitor.Enter(FHandlerLock);
          try
            FThenHandlers.Add(
              procedure(Value: T)
              begin
                try
                  AOnFulfill(Value)
                    .&Then(
                      procedure(NewValue: T)
                      begin
                        Resolve(NewValue);
                      end)
                    .&Catch(
                    procedure(E: Exception)
                    begin
                      Reject(CloneException(E));
                    end);
                except
                  on E: Exception do
                    Reject(CloneException(E));
                end;
              end);
            FCatchHandlers.Add(
              procedure(E: Exception)
              begin
                Reject(CloneException(E));
              end);
          finally
            TMonitor.Exit(FHandlerLock);
          end;
        end;
    end);
end;

function TPromise<T>.&Then<TResult>(
  AOnFulfill: TFunc<TResult>): TPromise<TResult>;
begin
  Result := TPromise<TResult>.Create(
    procedure(Resolve: TProc<TResult>; Reject: TProc<Exception>)
    begin
      if FState = psFulfilled then
        begin
          try
            {--- Call the action without parameters and resolve with the result }
            Resolve(AOnFulfill());
          except
            on E: Exception do
              Reject(CloneException(E));
          end;
        end
    else
    if FState = psRejected then
      begin
        Reject(CloneException(FError));
      end
    else
      begin
        {--- If the promise is pending, we add callbacks }
        TMonitor.Enter(FHandlerLock);
        try
          FThenHandlers.Add(
            procedure(Value: T)
            begin
              try
                Resolve(AOnFulfill());
              except
                on E: Exception do
                  Reject(CloneException(E));
              end;
            end);
          FCatchHandlers.Add(
            procedure(E: Exception)
            begin
              Reject(CloneException(E));
            end);
        finally
          TMonitor.Exit(FHandlerLock);
        end;
      end;
    end);
end;

function TPromise<T>.&Then<TResult>(
  AOnFulfill: TFunc<T, TPromise<TResult>>): TPromise<TResult>;
begin
  Result := TPromise<TResult>.Create(
    procedure(Resolve: TProc<TResult>; Reject: TProc<Exception>)
    begin
      if FState = psFulfilled then
        begin
          try
            AOnFulfill(FValue)
              .&Then(
                procedure(NewValue: TResult)
                begin
                  Resolve(NewValue);
                end)
              .&Catch(
                procedure(E: Exception)
                begin
                  Reject(CloneException(E));
                end);
          except
            on E: Exception do
              Reject(CloneException(E));
          end;
        end
      else
      if FState = psRejected then
        begin
          Reject(CloneException(FError));
        end
      else
        begin
          TMonitor.Enter(FHandlerLock);
          try
            FThenHandlers.Add(
              procedure(Value: T)
              begin
                try
                  AOnFulfill(Value)
                    .&Then(
                      procedure(NewValue: TResult)
                      begin
                        Resolve(NewValue);
                      end)
                    .&Catch(
                      procedure(E: Exception)
                      begin
                        Reject(CloneException(E));
                      end);
                except
                  on E: Exception do
                    Reject(CloneException(E));
                end;
              end);
            FCatchHandlers.Add(
              procedure(E: Exception)
              begin
                Reject(CloneException(E));
              end);
          finally
            TMonitor.Exit(FHandlerLock);
          end;
        end;
    end);
end;

function TPromise<T>.&Then(AOnFulfill: TProc): TPromise<T>;
begin
  Result := TPromise<T>.Create(
    procedure(Resolve: TProc<T>; Reject: TProc<Exception>)
    begin
      if FState = psFulfilled then
        begin
          try
            {--- Calling the action without parameters }
            AOnFulfill();
            {--- Pass the initial value after the action is executed }
            Resolve(FValue);
          except
            on E: Exception do
              Reject(CloneException(E));
          end;
        end
      else
      if FState = psRejected then
        begin
          Reject(CloneException(FError))
        end
      else
        begin
          {--- If the operation is not yet completed, add callbacks for chaining }
          TMonitor.Enter(FHandlerLock);
          try
            FThenHandlers.Add(
              procedure(Value: T)
              begin
                try
                  AOnFulfill();
                  Resolve(Value);
                except
                  on E: Exception do
                    Reject(CloneException(E));
                end;
              end);
            FCatchHandlers.Add(
              procedure(E: Exception)
              begin
                Reject(CloneException(E));
              end);
          finally
            TMonitor.Exit(FHandlerLock);
          end;
        end;
    end);
end;

function TPromise<T>.&Catch(AOnReject: TProc<Exception>): TPromise<T>;
begin
  {--- Create a new promise that passes the value or handles the error with AOnReject }
  Result := TPromise<T>.Create(
    procedure(Resolve: TProc<T>; Reject: TProc<Exception>)
    begin
      if FState = psFulfilled then
        begin
          Resolve(FValue);
        end
      else
      if FState = psRejected then
        begin
          AOnReject(FError);
          Reject(CloneException(FError));
        end
      else
        begin
          TMonitor.Enter(FHandlerLock);
          try
            FThenHandlers.Add(
              procedure(Value: T)
              begin
                Resolve(Value);
              end);
            FCatchHandlers.Add(
              procedure(E: Exception)
              begin
                AOnReject(E);
                Reject(CloneException(E));
              end);
          finally
            TMonitor.Exit(FHandlerLock);
          end;
        end;
    end);
end;

{ TPromiseRegistry }

class procedure TPromiseRegistry.Add(APromise: TObject);
begin
  TMonitor.Enter(FLock);
  try
    FList.Add(APromise);
  finally
    TMonitor.Exit(FLock);
  end;
end;

class procedure TPromiseRegistry.Cleanup;
begin
  TMonitor.Enter(FLock);
  try
    for var I := FList.Count - 1 downto 0 do
      {--- Remove the promise from the list as soon as it moves to the final state. }
      if TObject(FList[I]) is TPromiseBase then
        with TPromiseBase(FList[I]) do
          if State <> psPending then
            {--- releases the object }
            FList.Delete(I);
  finally
    TMonitor.Exit(FLock);
  end;
end;

class procedure TPromiseRegistry.Clear;
begin
  TMonitor.Enter(FLock);
  try
    for var I := FList.Count - 1 downto 0 do
      {--- Remove the promise from the list as soon as it moves to the final state. }
      if TObject(FList[I]) is TPromiseBase then
        with TPromiseBase(FList[I]) do
            {--- releases the object }
            FList.Delete(I);
  finally
    TMonitor.Exit(FLock);
  end;
end;

class constructor TPromiseRegistry.Create;
begin
  {--- simple critical section }
  FLock := TObject.Create;

  {--- OwnsObjects = True }
  FList := TObjectList<TObject>.Create(True);
end;

class destructor TPromiseRegistry.Destroy;
begin
  FList.Free;
  FLock.Free;
end;

class procedure TPromiseRegistry.Remove(APromise: TObject);
begin
  TMonitor.Enter(FLock);
  try
    {--- releases the object }
    var Index := FList.IndexOf(APromise);
    if Index >= 0 then
      FList.Delete(Index);
  finally
    TMonitor.Exit(FLock);
  end;
end;

initialization
finalization
  {--- Delete pending promises }
  TPromiseRegistry.Clear;
end.

unit Deepseek.Async.Support;

{-------------------------------------------------------------------------------

      Unit containing  records for managing  asynchronous events related to
      chat requests.

      The  HuggingFace.Chat.AsyncEvents  unit  provides  definitions for the
      TAsyncParams<T>  and  TAsynStreamParams<T>  records, which  are  used
      to  handle  the lifecycle  of asynchronous chat operations, including
      starting, progressing, succeeding, and handling errors.
      These records enable non-blocking operations for chat functionalities
      and can be reused across multiple modules.

      This unit depends  on HuggingFace.Async.Params  for parameter management.
      The IUseParams<T>  and  TUseParamsFactory<T>  interfaces  and  classes
      from  HuggingFace.Params.Core  are  utilized  to  create and manage the
      parameter  instances  for  asynchronous  operations.

        Github repository :  https://github.com/MaxiDonkey/DelphiDeepseek
        Visit the Github repository for the documentation and use examples

-------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, system.Classes, System.Threading, Deepseek.Async.Params;

type
  /// <summary>
  /// Record used to handle asynchronous request events.
  /// </summary>
  /// <remarks>
  /// <c>TAsynCallBack</c> manages the lifecycle of an asynchronous request.
  /// It provides callbacks for different stages of the request, such as start, successful completion, or error.
  /// </remarks>
  TAsynCallBack<T> = record
  private
    FSender: TObject;
    FOnStart: TProc<TObject>;
    FOnSuccess: TProc<TObject, T>;
    FOnError: TProc<TObject, string>;
  public
    /// <summary>
    /// Object representing the sender of the asynchronous operation.
    /// </summary>
    /// <remarks>
    /// The <c>Sender</c> property is used to identify or store a reference to the object that initiated the request.
    /// This can be useful for providing context in the callback procedures.
    /// </remarks>
    property Sender: TObject read FSender write FSender;
    /// <summary>
    /// Event triggered at the start of the asynchronous request.
    /// </summary>
    /// <remarks>
    /// The <c>OnStart</c> event is called when the request begins.
    /// It can be used to initialize any required state or display a loading indicator to the user.
    /// <code>
    /// OnStart :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // Code executed at the start of the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnStart: TProc<TObject> read FOnStart write FOnStart;
    /// <summary>
    /// Event triggered at the end of the asynchronous request.
    /// </summary>
    /// <param name="Sender">
    /// Object that initiated the request, generally used for context.
    /// </param>
    /// <param name="Result">
    /// The result of type <c>T</c> returned at the end of the request.
    /// This event is used to process the final result of the asynchronous operation.
    /// </param>
    /// <remarks>
    /// The <c>OnSuccess</c> event is invoked when the process completes successfully.
    /// It can be used to perform final actions based on the received result.
    /// <code>
    /// OnSuccess :=
    ///    procedure (Sender: TObject; Result: T)
    ///    begin
    ///      // Code executed at the end of the request with the obtained result
    ///    end;
    /// </code>
    /// </remarks>
    property OnSuccess: TProc<TObject, T> read FOnSuccess write FOnSuccess;
    /// <summary>
    /// Event triggered when an error occurs during the asynchronous request.
    /// </summary>
    /// <param name="Sender">
    /// Object that initiated the request, generally used for context.
    /// </param>
    /// <param name="ErrorMessage">
    /// The error message received, which can be logged or displayed to the user.
    /// </param>
    /// <remarks>
    /// The <c>OnError</c> event is called when an error occurs during the asynchronous operation.
    /// It can be used to handle failures, display error messages, or perform any necessary cleanup actions.
    /// <code>
    /// OnError :=
    ///    procedure (Sender: TObject; ErrorMessage: string)
    ///    begin
    ///      // Code executed when an error occurs during the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnError: TProc<TObject, string> read FOnError write FOnError;
  end;

  /// <summary>
  /// Class used to manage asynchronous execution with callback events.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynCallBackExec&lt;T, U&gt;</c> class allows you to execute asynchronous operations with specified callbacks for start, completion, and error events.
  /// It encapsulates the asynchronous execution logic, handling thread management and exception handling, providing an easy way to manage the lifecycle of an asynchronous request.
  /// </remarks>
  TAsynCallBackExec<T; U: class> = class
  private
    FUse: IUseParams<T>;
    FSender: TObject;
    FOnStart: TProc<TObject>;
    FOnSuccess: TProc<TObject, U>;
    FOnError: TProc<TObject, string>;
  public
    /// <summary>
    /// Gets the <c>IUseParams&lt;T&gt;</c> interface instance used by this class.
    /// </summary>
    /// <value>
    /// An instance of <c>IUseParams&lt;T&gt;</c> that provides parameter management functionality.
    /// </value>
    property Use: IUseParams<T> read FUse;
    /// <summary>
    /// The object representing the sender of the asynchronous operation.
    /// </summary>
    /// <value>
    /// An instance of <c>TObject</c> identifying the originator of the operation.
    /// </value>
    /// <remarks>
    /// This property can be set to identify the object that initiated the asynchronous operation, which is useful in callback methods.
    /// </remarks>
    property Sender: TObject read FSender write FSender;
    /// <summary>
    /// Event triggered when the asynchronous operation starts.
    /// </summary>
    /// <value>
    /// A procedure of type <c>TProc&lt;TObject&gt;</c> to handle any setup or UI updates when the operation begins.
    /// </value>
    /// <remarks>
    /// Assign a procedure to this event to perform actions at the start of the asynchronous operation.
    /// <code>
    /// OnStart :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // Code executed at the start of the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnStart: TProc<TObject> read FOnStart write FOnStart;
    /// <summary>
    /// Event triggered when the asynchronous operation completes successfully.
    /// </summary>
    /// <value>
    /// A procedure of type <c>TProc&lt;TObject, U&gt;</c> to handle the result of the operation.
    /// </value>
    /// <remarks>
    /// Assign a procedure to this event to process the result returned by the operation.
    /// <code>
    /// OnSuccess :=
    ///    procedure (Sender: TObject; Result: T)
    ///    begin
    ///      // Code executed at the end of the request with the obtained result
    ///    end;
    /// </code>
    /// </remarks>
    property OnSuccess: TProc<TObject, U> read FOnSuccess write FOnSuccess;
    /// <summary>
    /// Event triggered when an error occurs during the asynchronous operation.
    /// </summary>
    /// <value>
    /// A procedure of type <c>TProc&lt;TObject, string&gt;</c> to handle exceptions or errors.
    /// </value>
    /// <remarks>
    /// Assign a procedure to this event to handle any exceptions or errors that occur during execution.
    /// <code>
    /// OnError :=
    ///    procedure (Sender: TObject; ErrorMessage: string)
    ///    begin
    ///      // Code executed when an error occurs during the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnError: TProc<TObject, string> read FOnError write FOnError;
    /// <summary>
    /// Executes the specified function asynchronously.
    /// </summary>
    /// <param name="Value">
    /// A function of type <c>TFunc&lt;U&gt;</c> representing the operation to execute asynchronously.
    /// </param>
    /// <remarks>
    /// This method creates and starts an asynchronous task that executes the provided function.
    /// It invokes the <c>OnStart</c> event before execution, the <c>OnSuccess</c> event upon successful completion, and the <c>OnError</c> event if an exception occurs during execution.
    /// </remarks>
    procedure Run(Value: TFunc<U>);
    /// <summary>
    /// Initializes a new instance of the <c>TAsynCallBackExec&lt;T, U&gt;</c> class with the specified parameter function.
    /// </summary>
    /// <param name="Value">
    /// A function of type <c>TFunc&lt;T&gt;</c> used to create an instance of <c>IUseParams&lt;T&gt;</c>.
    /// </param>
    /// <remarks>
    /// The constructor initializes the internal <c>IUseParams&lt;T&gt;</c> interface using the provided function.
    /// </remarks>
    constructor Create(const Value: TFunc<T>);
  end;

  /// <summary>
  /// Record used to manage asynchronous events for a streaming chat request.
  /// </summary>
  /// <remarks>
  /// <c>TAsynChatStreamParams</c> allows you to handle the lifecycle of a chat request in streaming mode.
  /// It provides callbacks for different stages such as when the request starts, progresses, succeeds, encounters an error, or needs to be canceled.
  /// </remarks>
  TAsynStreamCallBack<T> = record
  private
    FSender: TObject;
    FOnStart: TProc<TObject>;
    FOnSuccess: TProc<TObject>;
    FOnProgress: TProc<TObject, T>;
    FOnError: TProc<TObject, string>;
    FOnCancellation: TProc<TObject>;
    FOnDoCancel: TFunc<Boolean>;
  public
    /// <summary>
    /// The object representing the sender of the asynchronous operation.
    /// </summary>
    /// <remarks>
    /// The <c>Sender</c> property is used to identify or store a reference to the object that initiated the chat request,
    /// which can be useful for context within the callback procedures.
    /// </remarks>
    property Sender: TObject read FSender write FSender;
    /// <summary>
    /// Event triggered when the asynchronous chat request starts.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="Chat">
    /// The <c>TChat</c> object representing the current response chunk received from the model.
    /// This event can be used to update the user interface as new tokens are streamed in.
    /// </param>
    /// <remarks>
    /// The <c>OnStart</c> event is called when the chat request begins. It can be used to set up any initial state or display a loading indicator to the user.
    /// <code>
    /// OnStart :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // code when chat request begin
    ///    end;
    /// </code>
    /// </remarks>
    property OnStart: TProc<TObject> read FOnStart write FOnStart;
    /// <summary>
    /// Event triggered when the asynchronous chat request completes successfully.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="Chat">
    /// The <c>TChat</c> object representing the current response chunk received from the model.
    /// This event can be used to update the user interface as new tokens are streamed in.
    /// </param>
    /// <remarks>
    /// The <c>OnSuccess</c> event is invoked when the streaming process finishes successfully.
    /// It does not provide additional data, as the result is expected to have been handled progressively via the <c>OnProgress</c> event.
    /// <code>
    /// OnSuccess :=
    ///    procedure (Sender: TObject; Chat: TChat)
    ///    begin
    ///      // code when the streaming process finishes successfully
    ///    end;
    /// </code>
    /// </remarks>
    property OnSuccess: TProc<TObject> read FOnSuccess write FOnSuccess;
    /// <summary>
    /// Event triggered to handle progress during the streaming chat request.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="Chat">
    /// The <c>TChat</c> object representing the current response chunk received from the model.
    /// This event can be used to update the user interface as new tokens are streamed in.
    /// </param>
    /// <remarks>
    /// The <c>OnProgress</c> event is fired every time a new chunk of data is received during the streaming process.
    /// This allows the application to handle the response progressively as it is generated by the model.
    /// <code>
    /// OnProgress :=
    ///    procedure (Sender: TObject; Chat: TChat)
    ///    begin
    ///      // code to handle the response progressively
    ///    end;
    /// </code>
    /// </remarks>
    property OnProgress: TProc<TObject, T> read FOnProgress write FOnProgress;
    /// <summary>
    /// Event triggered when an error occurs during the asynchronous chat request.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="ErrorMessage">
    /// The error message received, which can be logged or displayed to the user.
    /// </param>
    /// <remarks>
    /// The <c>OnError</c> event is called when an error occurs during the streaming process.
    /// This can be used to handle failures, show error messages, or perform any necessary clean-up actions.
    /// <code>
    /// OnError :=
    ///    procedure (Sender: TObject; message: string)
    ///    begin
    ///      // code to handle an error occurs during the streaming process
    ///    end;
    /// </code>
    /// </remarks>
    property OnError: TProc<TObject, string> read FOnError write FOnError;
    /// <summary>
    /// Event triggered when the asynchronous chat request has been canceled.
    /// </summary>
    /// <remarks>
    /// The <c>OnCancellation</c> event is fired when the chat request is canceled by the user or the application.
    /// This can be used to perform clean-up operations or notify the user that the request has been terminated.
    /// <code>
    /// OnCancellation :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // code to handle chat request cancellation
    ///    end;
    /// </code>
    /// </remarks>
    property OnCancellation: TProc<TObject> read FOnCancellation write FOnCancellation;
    /// <summary>
    /// Function called to determine if the asynchronous chat request should be canceled.
    /// </summary>
    /// <returns>
    /// A <c>Boolean</c> value indicating whether the request should be canceled (<c>True</c>) or allowed to continue (<c>False</c>).
    /// </returns>
    /// <remarks>
    /// The <c>OnDoCancel</c> function is periodically invoked to check whether the user or application has requested to cancel the chat request.
    /// If the function returns <c>True</c>, the streaming process will be aborted.
    /// <code>
    /// OnDoCancel :=
    ///    function : Boolean
    ///    begin
    ///      Result := ... // True to stop the streaming process
    ///    end;
    /// </code>
    /// </remarks>
    property OnDoCancel: TFunc<Boolean> read FOnDoCancel write FOnDoCancel;
  end;

implementation

{ TAsynCallBackExec<T, U> }

constructor TAsynCallBackExec<T, U>.Create(const Value: TFunc<T>);
begin
  inherited Create;
  FUse := TUseParamsFactory<T>.CreateInstance(Value);
end;

procedure TAsynCallBackExec<T, U>.Run(Value: TFunc<U>);
begin
  {--- Assign callback values to internal variables for asynchrony to work properly }
  var InternalSender := Sender;
  var InternalOnStart := OnStart;
  var InternalOnSuccess := OnSuccess;
  var InternalOnError := OnError;

  var Task: ITask := TTask.Create(
          procedure()
          begin
            try
              {--- Pass the instance of the current class in case no value was specified. }
              if not Assigned(InternalSender) then
                InternalSender := Self;

              {--- Trigger OnStart callback }
              if Assigned(InternalOnStart) then
                TThread.Queue(nil,
                  procedure
                  begin
                    InternalOnStart(InternalSender);
                  end);

              {--- Processing }
              var Result := Value();

              {--- Trigger OnEnd callback when the process is done }
              TThread.Queue(nil,
                  procedure
                  begin
                    try
                      if Assigned(InternalOnSuccess) then
                        InternalOnSuccess(InternalSender, Result);
                    finally
                      {--- Makes sure to release the instance containing the data obtained
                           following processing}
                      if Assigned(Result) then
                        Result.Free;
                    end;
                  end);

            except
              on E: Exception do
                begin
                  var Error := AcquireExceptionObject;
                  try
                    var ErrorMsg := (Error as Exception).Message;

                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(InternalOnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        InternalOnError(InternalSender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
          end);
  Task.Start;
end;

end.

unit Deepseek.Chat;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiDeepseek
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, System.Threading,
  REST.Json.Types, Deepseek.API.Params, Deepseek.API, Deepseek.Types,
  Deepseek.Async.Params, Deepseek.Async.Support, Deepseek.Functions.Tools,
  Deepseek.Functions.Core, Deepseek.API.Parallel;

type
  /// <summary>
  /// Messages comprising the conversation so far.
  /// </summary>
  TContentParams = class(TJSONParam)
  public
    /// <summary>
    /// The role of the messages author.
    /// </summary>
    function Role(const Value: TMessageRole): TContentParams; overload;
    /// <summary>
    /// The role of the messages author.
    /// </summary>
    function Role(const Value: string): TContentParams; overload;
    /// <summary>
    /// An optional name for the participant. Provides the model information to differentiate between
    /// participants of the same role.
    /// </summary>
    function Name(const Value: string): TContentParams;
    /// <summary>
    /// The contents of the system message.
    /// </summary>
    function Content(const Value: string): TContentParams; overload;
    /// <summary>
    /// Gets or sets the content of the message.
    /// </summary>
    /// <remarks>
    /// The <c>Content</c> property contains the actual message text. This is a required field and cannot be empty, as it represents the core information being exchanged
    /// in the chat, whether it's from the user, the assistant, or the system.
    /// </remarks>
    function Content(const Value: TJSONArray): TContentParams; overload;
    /// <summary>
    /// (Beta) Set this to true to force the model to start its answer by the content of the supplied
    /// prefix in this assistant message. You must set base_url="https://api.deepseek.com/beta" to use
    /// this feature.
    /// </summary>
    function Prefix(const Value: Boolean): TContentParams;
    /// <summary>
    /// (Beta) Used for the deepseek-reasoner model in the Chat Prefix Completion feature as the input for the CoT
    /// in the last assistant message. When using this feature, the prefix parameter must be set to true.
    /// </summary>
    function ReasoningContent(const Value: string): TContentParams;
    /// <summary>
    /// Creates a new chat message payload with the role of the system.
    /// </summary>
    /// <param name="Value">
    /// The content of the system message.
    /// </param>
    /// <param name="Name">
    /// Set the name for the participant
    /// </param>
    /// <returns>
    /// A <c>TContentParams</c> instance with the role set to "system" and the provided content.
    /// </returns>
    /// <remarks>
    /// This method is used to create system-level messages, which may be used for notifications, warnings, or other system-related interactions.
    /// </remarks>
    class function System(const Content: string; const Name: string = ''): TContentParams;
    /// <summary>
    /// Creates a new chat message payload with the role of the user.
    /// </summary>
    /// <param name="Value">
    /// The content of the message that the user is sending.
    /// </param>
    /// <param name="Name">
    /// Set the name for the participant
    /// </param>
    /// <returns>
    /// A <c>TContentParams</c> instance with the role set to "user" and the provided content.
    /// </returns>
    /// <remarks>
    /// This method is used to create messages from the user's perspective, typically representing inputs or queries in the conversation.
    /// </remarks>
    class function User(const Content: string; const Name: string = ''): TContentParams; overload;
    /// <summary>
    /// Creates a new chat message payload with the role of the assistant.
    /// </summary>
    /// <param name="Value">
    /// The content of the message that the assistant is sending.
    /// </param>
    /// <param name="Prefix">
    /// Use prefix or no.
    /// </param>
    /// <returns>
    /// A <c>TContentParams</c> instance with the role set to "assistant" and the provided content.
    /// </returns>
    /// <remarks>
    /// This method is a convenience for creating assistant messages. Use this method when the assistant needs to respond to the user or system.
    /// </remarks>
    class function Assistant(const Content: string; const Prefix: Boolean = False): TContentParams; overload;
    /// <summary>
    /// Creates a new chat message payload with the role of the assistant.
    /// </summary>
    /// <param name="Value">
    /// The content of the message that the assistant is sending.
    /// </param>
    /// <param name="Name">
    /// Set the name for the participant.
    /// </param>
    /// <param name="Prefix">
    /// Use prefix or no.
    /// </param>
    /// <returns>
    /// A <c>TContentParams</c> instance with the role set to "assistant" and the provided content.
    /// </returns>
    /// <remarks>
    /// This method is a convenience for creating assistant messages. Use this method when the assistant needs to respond to the user or system.
    /// </remarks>
    class function Assistant(const Content, Name: string; const Prefix: Boolean = False): TContentParams; overload;
  end;

  /// <summary>
  /// The <c>TChatParams</c> class represents the set of parameters used to configure a chat interaction with an AI model.
  /// </summary>
  /// <remarks>
  /// This class allows you to define various settings that control how the model behaves, including which model to use, how many tokens to generate,
  /// what kind of messages to send, and how the model should handle its output. By using this class, you can fine-tune the AI's behavior and response format
  /// based on your application's specific needs.
  /// <para>
  /// It inherits from <c>TJSONParam</c>, which provides methods for handling and serializing the parameters as JSON, allowing seamless integration
  /// with JSON-based APIs.
  /// </para>
  /// <code>
  /// var
  ///   Params: TChatParams;
  /// begin
  ///   Params := TChatParams.Create
  ///     .Model('my_model')
  ///     .MaxTokens(100)
  ///     .Messages([TChatMessagePayload.User('Hello!')])
  ///     .ResponseFormat('json_object')
  ///     .Temperature(0.7)
  ///     .TopP(1)
  ///     .SafePrompt(True);
  /// end;
  /// </code>
  /// This example shows how to instantiate and configure a <c>TChatParams</c> object for interacting with an AI model.
  /// </remarks>
  TChatParams = class(TJSONParam)
  public
    function Messages(const Value: TArray<TJSONParam>): TChatParams;
    /// <summary>
    /// Specifies the identifier of the model to use.
    /// </summary>
    /// <param name="Value">
    /// The model ID to be used for the completion.
    /// Ensure that the specified model is supported and correctly spelled.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// This parameter is required and determines which model will process the request.
    /// </remarks>
    function Model(const Value: string): TChatParams;
    /// <summary>
    /// Frequency_penalty penalizes the repetition of words based on their frequency in the generated text.
    /// </summary>
    /// <param name="Value">
    /// number (Presence Penalty) [ -2 .. 2 ]; Default: 0
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// A higher frequency penalty discourages the model from repeating words that have already appeared
    /// frequently in the output, promoting diversity and reducing repetition.
    /// </remarks>
    function FrequencyPenalty(const Value: Double): TChatParams;
    /// <summary>
    /// Sets the maximum number of tokens to generate in the completion.
    /// The total token count of your prompt plus <c>max_tokens</c> cannot exceed the model's context length.
    /// </summary>
    /// <param name="Value">
    /// The maximum number of tokens to generate.
    /// Choose an appropriate value based on your prompt length to avoid exceeding the model's limit.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function MaxTokens(const Value: Integer): TChatParams;
    /// <summary>
    /// Presence_penalty determines how much the model penalizes the repetition of words or phrases
    /// </summary>
    /// <param name="Value">
    /// number (Presence Penalty) [ -2 .. 2 ]; Default: 0
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// A higher presence penalty encourages the model to use a wider variety of words and phrases,
    /// making the output more diverse and creative.
    /// </remarks>
    function PresencePenalty(const Value: Double): TChatParams;
    /// <summary>
    /// Specifies the format in which the model should return the response. This can include formats like JSON or plain text.
    /// </summary>
    /// <param name="Value">The desired response format, with the default being <c>"json_object"</c>.</param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// If not specified, the default value is <c>{ "type": "text" }</c>. When using JSON mode, it's necessary to instruct the model to produce JSON explicitly through the system or user messages.
    /// </remarks>
    function ResponseFormat(const Value: TResponseFormat): TChatParams; overload;
    /// <summary>
    /// Specifies the format in which the model should return the response. This can include formats like JSON or plain text.
    /// </summary>
    /// <param name="Value">The desired response format, with the default being <c>"json_object"</c>.</param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// If not specified, the default value is <c>{ "type": "text" }</c>. When using JSON mode, it's necessary to instruct the model to produce JSON explicitly through the system or user messages.
    /// </remarks>
    function ResponseFormat(const Value: string): TChatParams; overload;
    /// <summary>
    /// Stop (string)
    /// Stop generation if this token is detected. Or if one of these tokens is detected when providing an array
    /// </summary>
    /// <param name="Value">
    /// The string that causes the stop
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function Stop(const Value: string): TChatParams; overload;
    /// <summary>
    /// Stop Array of Stop (strings) (Stop)
    /// Stop generation if this token is detected. Or if one of these tokens is detected when providing an array
    /// </summary>
    /// <param name="Value">
    /// The array of string that causes the stop
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function Stop(const Value: TArray<string>): TChatParams; overload;
    /// <summary>
    /// Specifies whether to stream back partial progress as server-sent events (SSE).
    /// If <c>true</c>, tokens are sent as they become available.
    /// If <c>false</c>, the server will hold the request open until timeout or completion.
    /// </summary>
    /// <param name="Value">
    /// A boolean value indicating whether to enable streaming. Default is <c>true</c>, meaning streaming is enabled by default.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function Stream(const Value: Boolean = True): TChatParams;
    /// <summary>
    /// Options for streaming response. Only set this when you set stream: true.
    /// </summary>
    /// <param name="Value">
    /// A boolean value indicating whether to enable streaming. Default is <c>true</c>, meaning streaming is enabled by default.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on
    /// this chunk shows the token usage statistics for the entire request, and the choices field will
    /// always be an empty array. All other chunks will also include a usage field, but with a null value.
    /// </remarks>
    function StreamOptions(const Value: Boolean): TChatParams;
    /// <summary>
    /// Sets the sampling temperature to use for the model's output.
    /// Higher values like 0.8 make the output more random, while lower values like 0.2 make it more focused and deterministic.
    /// </summary>
    /// <param name="Value">
    /// The temperature value between 0.0 and 1.0. Default is 0.7.
    /// A temperature of 0 makes the model deterministic, while a temperature of 1 allows for maximum creativity.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function Temperature(const Value: Double): TChatParams;
    /// <summary>
    /// Sets the nucleus sampling probability mass for the model (Top-p).
    /// For example, 0.1 means only the tokens comprising the top 10% probability mass are considered.
    /// </summary>
    /// <param name="Value">
    /// The <c>top_p</c> value between 0.0 and 1.0. Default is 1.
    /// Lower values limit the model to consider only the most probable options.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function TopP(const Value: Double): TChatParams;
    /// <summary>
    /// Specifies a list of tools that the model can use to generate structured outputs such as JSON inputs for function calls.
    /// </summary>
    /// <param name="Value">
    /// An array of <c>TChatMessageTool</c> representing the tools available to the model.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// These tools can include functions that the model can utilize when generating output. For example, they can help the model produce structured data for specific tasks.
    /// </remarks>
    function Tools(const Value: TArray<TChatMessageTool>): TChatParams; overload;
    /// <summary>
    /// Specifies a list of tools that the model can use to generate structured outputs such as JSON inputs for function calls.
    /// </summary>
    /// <param name="Value">
    /// An array of <c>IFunctionCore</c> representing the tools available to the model.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// These tools can include functions that the model can utilize when generating output. For example, they can help the model produce structured data for specific tasks.
    /// </remarks>
    function Tools(const Value: TArray<IFunctionCore>): TChatParams; overload;
    /// <summary>
    /// Configures how the model interacts with functions. This can either prevent, allow, or require function calls depending on the setting.
    /// </summary>
    /// <param name="Value">
    /// The <c>TToolChoice</c> setting for function interaction, with a default of "auto".
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// If set to <c>none</c>, the model will not call any functions and will generate a message instead.
    /// If set to <c>auto</c>, the model can choose between generating a message or calling a function.
    /// If set to <c>required</c>, the model is required to call a function.
    /// </remarks>
    function ToolChoice(const Value: TToolChoice): TChatParams; overload;
    /// <summary>
    /// Configures how the model interacts with functions. This can either prevent, allow, or require function calls depending on the setting.
    /// </summary>
    /// <param name="Value">
    /// The <c>TToolChoice</c> setting for function interaction, with a default of "auto".
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// If set to <c>none</c>, the model will not call any functions and will generate a message instead.
    /// If set to <c>auto</c>, the model can choose between generating a message or calling a function.
    /// If set to <c>required</c>, the model is required to call a function.
    /// </remarks>
    function ToolChoice(const Value: string): TChatParams; overload;
    /// <summary>
    /// Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
    /// </summary>
    /// <param name="Value">
    /// Set True to activate.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function Logprobs(const Value: Boolean): TChatParams;
    /// <summary>
    /// An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability.
    /// logprobs must be set to true if this parameter is used.
    /// </summary>
    /// <param name="Value">
    /// Possible values: <= 20.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function TopLogprobs(const Value: Integer): TChatParams;
  end;

  /// <summary>
  /// Represents the specifics of a called function, including its name and calculated arguments.
  /// </summary>
  TFunction = class
  private
    FName: string;
    FArguments: string;
  public
    /// <summary>
    /// Gets or sets the name of the called function
    /// </summary>
    property Name: string read FName write FName;
    /// <summary>
    /// Gets or sets the calculed Arguments for the called function
    /// </summary>
    property Arguments: string read FArguments write FArguments;
  end;

  /// <summary>
  /// Represents a called function, containing its specifics such as name and arguments.
  /// </summary>
  TToolCalls = class
  private
    FId: string;
    FType: string;
    FFunction: TFunction;
  public
    /// <summary>
    /// Gets or sets the id of the called function
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Gets or sets the type of the called function
    /// </summary>
    property &Type: string read FType write FType;
    /// <summary>
    /// Gets or sets the specifics of the called function
    /// </summary>
    property &Function: TFunction read FFunction write FFunction;
    /// <summary>
    /// Destructor that ensures proper memory management by freeing the <c>FFunction</c> property
    /// when the <c>TToolCalls</c> instance is destroyed.
    /// </summary>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a chat message exchanged between participants (user, assistant, or system) in a conversation.
  /// </summary>
  /// <remarks>
  /// The <c>TChoiceMessage</c> class encapsulates the essential information of a message within a chat application, including:
  /// <para>
  /// - The role of the sender (user, assistant, or system).
  /// </para>
  /// <para>
  /// - The content of the message itself.
  /// </para>
  /// <para>
  /// - Optionally, a list of tool calls that may be required to complete the message response.
  /// </para>
  /// This class is fundamental for managing the flow of a conversation, allowing the system to track who said what and what actions need to be taken.
  /// </remarks>
  TChoiceMessage = class
  private
    FContent: string;
    [JsonReflectAttribute(ctString, rtString, TMessageRoleInterceptor)]
    FRole: TMessageRole;
    [JsonNameAttribute('tool_calls')]
    FToolCalls: TArray<TToolCalls>;
    [JsonNameAttribute('reasoning_content')]
    FReasoningContent: string;
  public
    /// <summary>
    /// The contents of the message.
    /// </summary>
    /// <remarks>
    /// The <c>Content</c> property stores the actual message text. This can include user inputs, assistant-generated replies, or system instructions.
    /// </remarks>
    property Content: string read FContent write FContent;
    /// <summary>
    /// The role of the author of this message, indicating the sender (e.g., user, assistant, or system).
    /// </summary>
    /// <remarks>
    /// The <c>Role</c> property identifies the participant responsible for the message. Common values are "user" for messages sent by the user,
    /// "assistant" for responses generated by the AI, or "system" for control messages.
    /// </remarks>
    property Role: TMessageRole read FRole write FRole;
    /// <summary>
    /// A list of tool calls to be executed for query completion.
    /// </summary>
    /// <remarks>
    /// The <c>ToolsCalls</c> property contains a list of functions or tools that need to be invoked to process the current query further.
    /// This is typically used when the assistant needs to call external APIs or perform specific actions before delivering a final response.
    /// </remarks>
    property ToolCalls: TArray<TToolCalls> read FToolCalls write FToolCalls;
    /// <summary>
    /// For deepseek-reasoner model only. The reasoning contents of the assistant message, before the final answer.
    /// </summary>
    property ReasoningContent: string read FReasoningContent write FReasoningContent;
    /// <summary>
    /// Destructor to release any resources used by this instance.
    /// </summary>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents the top log probabilities of tokens in a model's output.
  /// </summary>
  /// <remarks>
  /// The <c>TTopLogprobs</c> class is used to encapsulate detailed information
  /// about the probabilities of the most likely tokens at a specific position
  /// during the generation of a model's output.
  /// <para>
  /// This class is useful for analyzing and debugging the behavior of language
  /// models by providing a deeper insight into the decision-making process at
  /// the token level.
  /// </para>
  /// <para>
  /// It includes the token, its log probability, and its byte representation
  /// in UTF-8 format, making it an essential tool for advanced token-level
  /// evaluations.
  /// </para>
  /// </remarks>
  TTopLogprobs = class
  private
    FToken: string;
    FLogprob: Double;
    FBytes: TArray<int64>;
  public
    /// <summary>
    /// The current token.
    /// </summary>
    property Token: string read FToken write FToken;
    /// <summary>
    /// The log probability of this token, if it is within the top 20 most likely tokens. Otherwise,
    /// the value -9999.0 is used to signify that the token is very unlikely.
    /// </summary>
    property Logprob: Double read FLogprob write FLogprob;
    /// <summary>
    /// A list of integers representing the UTF-8 bytes representation of the token. Useful in instances
    /// where characters are represented by multiple tokens and their byte representations must be
    /// combined to generate the correct text representation. Can be null if there is no bytes
    /// representation for the token.
    /// </summary>
    property Bytes: TArray<int64> read FBytes write FBytes;
  end;

  /// <summary>
  /// Represents detailed log probability information for a specific token.
  /// </summary>
  /// <remarks>
  /// The <c>TLogprobContent</c> class provides a comprehensive structure for storing
  /// and analyzing the log probabilities of tokens generated by a model.
  /// It includes:
  /// <para>- The token itself.</para>
  /// <para>- The log probability of the token.</para>
  /// <para>- The UTF-8 byte representation of the token, when applicable.</para>
  /// <para>- A list of the most likely tokens and their log probabilities at this position,
  /// represented by <c>TTopLogprobs</c>.</para>
  /// <para>
  /// This class is particularly useful in tasks requiring token-level analysis,
  /// such as understanding model decisions, debugging outputs, or assessing
  /// the confidence of specific token choices.
  /// </para>
  /// </remarks>
  TLogprobContent = class
  private
    FToken: string;
    FLogprob: Double;
    FBytes: TArray<int64>;
    [JsonNameAttribute('top_logprobs')]
    FTopLogprobs: TArray<TTopLogprobs>;
  public
    /// <summary>
    /// The current token.
    /// </summary>
    property Token: string read FToken write FToken;
    /// <summary>
    /// The log probability of this token, if it is within the top 20 most likely tokens. Otherwise,
    /// the value -9999.0 is used to signify that the token is very unlikely.
    /// </summary>
    property Logprob: Double read FLogprob write FLogprob;
    /// <summary>
    /// A list of integers representing the UTF-8 bytes representation of the token. Useful in instances
    /// where characters are represented by multiple tokens and their byte representations must be
    /// combined to generate the correct text representation. Can be null if there is no bytes
    /// representation for the token.
    /// </summary>
    property Bytes: TArray<int64> read FBytes write FBytes;
    /// <summary>
    /// List of the most likely tokens and their log probability, at this token position. In rare cases,
    /// there may be fewer than the number of requested top_logprobs returned.
    /// </summary>
    property TopLogprobs: TArray<TTopLogprobs> read FTopLogprobs write FTopLogprobs;
    /// <summary>
    /// Destructor to release any resources used by this instance.
    /// </summary>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents the aggregated log probability information for a choice's output.
  /// </summary>
  /// <remarks>
  /// The <c>TLogprobs</c> class provides a structured way to encapsulate
  /// log probability data for tokens generated during a model's output.
  /// It consists of a collection of <c>TLogprobContent</c> instances,
  /// each representing detailed information for a single token.
  /// <para>
  /// This class is essential for advanced token-level analysis, allowing developers
  /// to assess the confidence of a model's predictions and understand the
  /// distribution of token probabilities across an entire response.
  /// </para>
  /// </remarks>
  TLogprobs = class
  private
    FContent: TArray<TLogprobContent>;
  public
    /// <summary>
    /// Log probability information for the choice.
    /// </summary>
    property Content: TArray<TLogprobContent> read FContent write FContent;
    /// <summary>
    /// Destructor to release any resources used by this instance.
    /// </summary>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents incremental updates to a chat message during streaming responses.
  /// </summary>
  /// <remarks>
  /// The <c>TDelta</c> class provides a structure to encapsulate partial or
  /// incremental updates to a chat message during streaming interactions
  /// with an AI model. It includes:
  /// <para>- The content of the partial message.</para>
  /// <para>- The role of the author of the message (e.g., user, assistant, or system).</para>
  /// <para>
  /// - This class is particularly useful for real-time applications where responses
  /// are streamed as they are generated, allowing for dynamic updates to the
  /// conversation interface.
  /// </para>
  /// <para>
  /// - Does not allow handling function calls during SSE processing.
  /// </para>
  /// </remarks>
  TDelta = class
  private
    FContent: string;
    [JsonReflectAttribute(ctString, rtString, TMessageRoleInterceptor)]
    FRole: TMessageRole;
    [JsonNameAttribute('reasoning_content')]
    FReasoningContent: string;
  public
    /// <summary>
    /// The contents of the message.
    /// </summary>
    /// <remarks>
    /// The <c>Content</c> property stores the actual message text. This can include user inputs, assistant-generated replies, or system instructions.
    /// </remarks>
    property Content: string read FContent write FContent;
    /// <summary>
    /// The role of the author of this message, indicating the sender (e.g., user, assistant, or system).
    /// </summary>
    /// <remarks>
    /// The <c>Role</c> property identifies the participant responsible for the message. Common values are "user" for messages sent by the user,
    /// "assistant" for responses generated by the AI, or "system" for control messages.
    /// </remarks>
    property Role: TMessageRole read FRole write FRole;
    /// <summary>
    /// For deepseek-reasoner model only. The reasoning contents of the assistant message, before the final answer.
    /// </summary>
    property ReasoningContent: string read FReasoningContent write FReasoningContent;
  end;

  /// <summary>
  /// Represents a single completion option generated by the AI model during a chat interaction.
  /// </summary>
  /// <remarks>
  /// The <c>TChatChoice</c> class stores the results of the AI model's response to a user prompt. Each instance of this class represents one of potentially
  /// many choices that the model could return. This includes:
  /// <para>
  /// - The finish reason.
  /// </para>
  /// <para>
  /// - An index identifying the choice.
  /// </para>
  /// <para>
  /// - A message generated by the model.
  /// </para>
  /// <para>
  /// - Optional deltas for streamed responses.
  /// </para>
  /// <para>
  /// - The reason the model stopped generating tokens.
  /// </para>
  /// This class is useful when multiple potential responses are generated and evaluated, or when streaming responses incrementally.
  /// </remarks>
  TChatChoice = class
  private
    [JsonNameAttribute('finish_reason')]
    [JsonReflectAttribute(ctString, rtString, TFinishReasonInterceptor)]
    FFinishReason: TFinishReason;
    FIndex: Int64;
    FMessage: TChoiceMessage;
    FLogprobs: TLogprobs;
    FDelta: TDelta;
  public
    /// <summary>
    /// Possible values: [stop, length, content_filter, insufficient_system_resource]
    /// </summary>
    /// <remarks>
    /// The reason the model stopped generating tokens. This will be stop if the model hit a natural stop
    /// point or a provided stop sequence, length if the maximum number of tokens specified in the request
    /// was reached, content_filter if content was omitted due to a flag from our content filters, or
    /// insufficient_system_resource if the request is interrupted due to insufficient resource of the
    /// inference system.
    /// </remarks>
    property FinishReason: TFinishReason read FFinishReason write FFinishReason;
    /// <summary>
    /// The index of the choice in the list of possible choices generated by the model.
    /// </summary>
    /// <remarks>
    /// The <c>Index</c> property helps identify the position of this particular choice in a set of choices provided by the AI model.
    /// This is useful when multiple options are generated for completion, and each one is referenced by its index.
    /// </remarks>
    property Index: Int64 read FIndex write FIndex;
    /// <summary>
    /// A chat completion message generated by the AI model.
    /// </summary>
    /// <remarks>
    /// The <c>Message</c> property contains the message that the model generated based on the provided prompt or conversation context.
    /// This is typically a complete message representing the AI's response to a user or system message.
    /// </remarks>
    property Message: TChoiceMessage read FMessage write FMessage;
    /// <summary>
    /// Log probability information for the choice.
    /// </summary>
    property Logprobs: TLogprobs read FLogprobs write FLogprobs;
    /// <summary>
    /// A chat completion delta representing partial responses generated during streaming.
    /// </summary>
    /// <remarks>
    /// The <c>Delta</c> property holds an incremental message (or delta) when the model sends streamed responses.
    /// This allows the model to progressively generate and deliver a response before it is fully completed.
    /// </remarks>
    property Delta: TDelta read FDelta write FDelta;
    /// <summary>
    /// Destructor to clean up resources used by the <c>TChatChoices</c> instance.
    /// </summary>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents the token usage statistics for a chat interaction, including the number of tokens
  /// used in the prompt, the completion, and the total number of tokens consumed.
  /// </summary>
  /// <remarks>
  /// The <c>TChatUsage</c> class provides insight into the number of tokens used during a chat interaction.
  /// This information is critical for understanding the cost of a request when using token-based billing systems
  /// or for monitoring the model's behavior in terms of input (prompt) and output (completion) size.
  /// </remarks>
  TUsage = class
  private
    [JsonNameAttribute('completion_tokens')]
    FCompletionTokens: Int64;
    [JsonNameAttribute('prompt_tokens')]
    FPromptTokens: Int64;
    [JsonNameAttribute('prompt_cache_hit_tokens')]
    FPromptCacheHitTokens: Int64;
    [JsonNameAttribute('prompt_cache_miss_tokens')]
    FPromptCacheMissTokens: Int64;
    [JsonNameAttribute('total_tokens')]
    FTotalTokens: Int64;
  public
    /// <summary>
    /// Number of tokens in the generated completion.
    /// </summary>
    property CompletionTokens: Int64 read FCompletionTokens write FCompletionTokens;
    /// <summary>
    /// Number of tokens in the prompt. It equals prompt_cache_hit_tokens + prompt_cache_miss_tokens.
    /// </summary>
    property PromptTokens: Int64 read FPromptTokens write FPromptTokens;
    /// <summary>
    /// Number of tokens in the prompt that hits the context cache.
    /// </summary>
    property PromptCacheHitTokens: Int64 read FPromptCacheHitTokens write FPromptCacheHitTokens;
    /// <summary>
    /// Number of tokens in the prompt that misses the context cache.
    /// </summary>
    property PromptCacheMissTokens: Int64 read FPromptCacheMissTokens write FPromptCacheMissTokens;
    /// <summary>
    /// Total number of tokens used in the request (prompt + completion).
    /// </summary>
    property TotalTokens: Int64 read FTotalTokens write FTotalTokens;
  end;

  /// <summary>
  /// Represents a chat completion response generated by an AI model, containing the necessary metadata,
  /// the generated choices, and usage statistics.
  /// </summary>
  /// <remarks>
  /// The <c>TChat</c> class encapsulates the results of a chat request made to an AI model.
  /// It contains details such as a unique identifier, the model used, when the completion was created,
  /// the choices generated by the model, and token usage statistics.
  /// This class is crucial for managing the results of AI-driven conversations and understanding the
  /// underlying usage and response characteristics of the AI.
  /// </remarks>
  TChat = class(TJSONFingerprint)
  private
    FId: string;
    FChoices: TArray<TChatChoice>;
    FCreated: Int64;
    FModel: string;
    [JsonNameAttribute('system_fingerprint')]
    FSystemFingerprint: string;
    FObject: string;
    FUsage: TUsage;
  public
    /// <summary>
    /// A unique identifier for the chat completion.
    /// </summary>
    /// <remarks>
    /// The <c>Id</c> property stores a unique string that identifies the specific chat completion request.
    /// This is useful for tracking and managing chat sessions or retrieving the results of a particular interaction.
    /// </remarks>
    property Id: string read FId write FId;
    /// <summary>
    /// A list of chat completion choices generated by the model.
    /// </summary>
    /// <remarks>
    /// The <c>Choices</c> property holds an array of <c>TChatChoices</c> objects, which represent the different response options
    /// generated by the AI model. There may be multiple choices if the request asked for more than one completion.
    /// </remarks>
    property Choices: TArray<TChatChoice> read FChoices write FChoices;
    /// <summary>
    /// The Unix timestamp (in seconds) of when the chat completion was created.
    /// </summary>
    /// <remarks>
    /// The <c>Created</c> property contains a Unix timestamp indicating when the AI generated the chat completion. This is
    /// useful for logging, auditing, or ordering chat completions chronologically.
    /// </remarks>
    property Created: Int64 read FCreated write FCreated;
    /// <summary>
    /// The model used for the chat completion.
    /// </summary>
    /// <remarks>
    /// The <c>Model</c> property specifies which AI model was used to generate the chat completion. This can be helpful
    /// when comparing results across different models or tracking which model versions are producing responses.
    /// </remarks>
    property Model: string read FModel write FModel;
    /// <summary>
    /// This fingerprint represents the backend configuration that the model runs with.
    /// </summary>
    property SystemFingerprint: string read FSystemFingerprint write FSystemFingerprint;
    /// <summary>
    /// The object type, which is always "chat.completion".
    /// </summary>
    /// <remarks>
    /// The <c>Object</c> property describes the type of the response. For chat completions, this value is always "chat.completion",
    /// providing a clear indication of the response type when working with multiple object types in a system.
    /// </remarks>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// Usage statistics for the completion request, including token counts for the prompt and completion.
    /// </summary>
    /// <remarks>
    /// The <c>Usage</c> property contains information about the number of tokens consumed during the request, including the
    /// tokens used in the prompt and those generated in the completion. This data is important for monitoring API usage and costs.
    /// </remarks>
    property Usage: TUsage read FUsage write FUsage;
    /// <summary>
    /// Destructor to clean up resources used by the <c>TChatChoices</c> instance.
    /// </summary>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TChat</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynChat</c> type extends the <c>TAsynParams&lt;TChat&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynChat = TAsynCallBack<TChat>;

  /// <summary>
  /// Manages asynchronous streaming chat callBacks for a chat request using <c>TChat</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynChatStream</c> type extends the <c>TAsynStreamParams&lt;TChat&gt;</c> record to support the lifecycle of an asynchronous streaming chat operation.
  /// It provides callbacks for different stages, including when the operation starts, progresses with new data chunks, completes successfully, or encounters an error.
  /// This structure is ideal for handling scenarios where the chat response is streamed incrementally, providing real-time updates to the user interface.
  /// </remarks>
  TAsynChatStream = TAsynStreamCallBack<TChat>;

  /// <summary>
  /// Represents a callback procedure used during the reception of responses from a chat request in streaming mode.
  /// </summary>
  /// <param name="Chat">
  /// The <c>TChat</c> object containing the current information about the response generated by the model.
  /// If this value is <c>nil</c>, it indicates that the data stream is complete.
  /// </param>
  /// <param name="IsDone">
  /// A boolean flag indicating whether the streaming process is complete.
  /// If <c>True</c>, it means the model has finished sending all response data.
  /// </param>
  /// <param name="Cancel">
  /// A boolean flag that can be set to <c>True</c> within the callback to cancel the streaming process.
  /// If set to <c>True</c>, the streaming will be terminated immediately.
  /// </param>
  /// <remarks>
  /// This callback is invoked multiple times during the reception of the response data from the model.
  /// It allows for real-time processing of received messages and interaction with the user interface or other systems
  /// based on the state of the data stream.
  /// When the <c>IsDone</c> parameter is <c>True</c>, it indicates that the model has finished responding,
  /// and the <c>Chat</c> parameter will be <c>nil</c>.
  /// </remarks>
  TChatEvent = reference to procedure(var Chat: TChat; IsDone: Boolean; var Cancel: Boolean);

  /// <summary>
  /// Provides methods to manage and execute chat operations with AI models.
  /// </summary>
  /// <remarks>
  /// The <c>TChatRoute</c> class extends <c>TDeepseekAPIRoute</c> and offers
  /// functionality for synchronous and asynchronous interactions with AI chat models.
  /// It supports:
  /// <para>- Creating chat completions.</para>
  /// <para>- Streaming chat completions for real-time updates.</para>
  /// <para>- Managing callbacks for progress, success, and error handling during asynchronous operations.</para>
  /// <para>
  /// This class is designed to provide seamless integration with the Deepseek API,
  /// allowing for flexible and efficient chat-based interactions in applications.
  /// </para>
  /// </remarks>
  TChatRoute = class(TDeepseekAPIRoute)
    /// <summary>
    /// Create an asynchronous completion for chat message
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the parameters for the chat request, such as model selection, messages, and other parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for the asynchronous chat completion, such as on success and on error.
    /// </param>
    /// <remarks>
    /// This procedure initiates an asynchronous request to generate a chat completion based on the provided parameters. The response or error is handled by the provided callBacks.
    /// <code>
    /// //var DeepSeek := TDeepseekFactory.CreateInstance(BarearKey);
    /// DeepSeek.Chat.AsyncCreate(
    ///   procedure (Params: TChatParams)
    ///   begin
    ///     // Define chat parameters
    ///   end,
    ///   function: TAsynChat
    ///   begin
    ///     Result.Sender := My_component;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Chat: TChat)
    ///     begin
    ///       // Handle success operation
    ///     end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Value: string)
    ///     begin
    ///       // Handle error message
    ///     end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsynCreate(ParamProc: TProc<TChatParams>; CallBacks: TFunc<TAsynChat>);
    /// <summary>
    /// Creates an asynchronous streaming chat completion request.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the chat request, including the model, messages, and additional options such as max tokens and streaming mode.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a <c>TAsynChatStream</c> record which contains event handlers for managing different stages of the streaming process: progress updates, success, errors, and cancellation.
    /// </param>
    /// <remarks>
    /// This procedure initiates an asynchronous chat operation in streaming mode, where tokens are progressively received and processed.
    /// The provided event handlers allow for handling progress (i.e., receiving tokens in real time), detecting success, managing errors, and enabling cancellation logic.
    /// <code>
    /// //var DeepSeek := TDeepseekFactory.CreateInstance(BarearKey);
    /// DeepSeek.Chat.AsyncCreateStream(
    ///   procedure(Params: TChatParams)
    ///   begin
    ///     // Define chat parameters
    ///     Params.Stream;
    ///   end,
    ///
    ///   function: TAsynChatStream
    ///   begin
    ///     Result.Sender := Memo1; // Instance passed to callback parameter
    ///     Result.OnProgress :=
    ///         procedure (Sender: TObject; Chat: TChat)
    ///         begin
    ///           // Handle progressive updates to the chat response
    ///         end;
    ///     Result.OnSuccess :=
    ///         procedure (Sender: TObject)
    ///         begin
    ///           // Handle success when the operation completes
    ///         end;
    ///     Result.OnError :=
    ///         procedure (Sender: TObject; Value: string)
    ///         begin
    ///           // Handle error message
    ///         end;
    ///     Result.OnDoCancel :=
    ///         function: Boolean
    ///         begin
    ///           Result := CheckBox1.Checked; // Click on checkbox to cancel
    ///         end;
    ///     Result.OnCancellation :=
    ///         procedure (Sender: TObject)
    ///         begin
    ///           // Processing when process has been canceled
    ///         end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsynCreateStream(ParamProc: TProc<TChatParams>;
      CallBacks: TFunc<TAsynChatStream>);
    /// <summary>
    /// Creates a completion for the chat message using the provided parameters.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the chat request, such as selecting the model,
    /// providing messages, setting token limits, etc.
    /// </param>
    /// <returns>
    /// Returns a <c>TChat</c> object that contains the chat response, including the choices generated by the model.
    /// </returns>
    /// <remarks>
    /// The <c>Create</c> method sends a chat completion request and waits for the full response.
    /// The returned <c>TChat</c> object contains the model's generated response, including multiple
    /// choices if available.
    /// <code>
    /// //var DeepSeek := TDeepseekFactory.CreateInstance(BarearKey);
    /// var Chat := DeepSeek.Chat.Create(
    ///     procedure (Params: TChatParams)
    ///     begin
    ///       // Define chat parameters
    ///     end);
    ///   try
    ///     // Handle the Chat
    ///   finally
    ///     Chat.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Create(ParamProc: TProc<TChatParams>): TChat;
    /// <summary>
    /// Creates a chat message completion with a streamed response.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the chat request, such as selecting the model, providing messages, and adjusting other settings like token limits or temperature.
    /// </param>
    /// <param name="Event">
    /// A callback of type <c>TChatEvent</c> that is triggered with each chunk of data received during the streaming process. It includes the current state of the <c>TChat</c> object, a flag indicating if the stream is done, and a boolean to handle cancellation.
    /// </param>
    /// <returns>
    /// Returns <c>True</c> if the streaming process started successfully, <c>False</c> otherwise.
    /// </returns>
    /// <remarks>
    /// This method initiates a chat request in streaming mode, where the response is delivered incrementally in real-time.
    /// The <c>Event</c> callback will be invoked multiple times as tokens are received.
    /// When the response is complete, the <c>IsDone</c> flag will be set to <c>True</c>, and the <c>Chat</c> object will be <c>nil</c>.
    /// The streaming process can be interrupted by setting the <c>Cancel</c> flag to <c>True</c> within the event.
    /// <code>
    /// //var DeepSeek := TDeepseekFactory.CreateInstance(BarearKey);
    ///   DeepSeek.Chat.CreateStream(
    ///     procedure (Params: TChatParams)
    ///     begin
    ///       // Define chat parameters
    ///     end,
    ///
    ///     procedure(var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
    ///     begin
    ///       // Handle displaying
    ///     end);
    /// </code>
    /// </remarks>
    function CreateStream(ParamProc: TProc<TChatParams>; Event: TChatEvent): Boolean;
    /// <summary>
    /// Initiates parallel processing of chat prompts by creating multiple chat completions
    /// asynchronously, with results stored in a bundle and provided back to the callback function.
    /// This method allows for parallel processing of multiple prompts in an efficient manner,
    /// handling errors and successes for each chat completion.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure delegate that configures the parameters for the bundle. It is responsible
    /// for providing the necessary settings (such as model and reasoning effort) for the chat completions.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns an instance of TAsynBuffer, which manages the lifecycle of the
    /// asynchronous operation. The callbacks include handlers for start, error, and success events.
    /// </param>
    /// <remarks>
    /// The method allows for efficient parallel processing of multiple prompts by delegating
    /// individual tasks to separate threads. It each task's result is properly bundled and communicated back to the caller.
    /// If an error occurs, the error handling callback will be triggered, and the rest of the tasks
    /// will continue processing. The success callback is triggered once all tasks are completed.
    /// </remarks>
    procedure CreateParallel(ParamProc: TProc<TBundleParams>; CallBacks: TFunc<TAsynBundleList>);
  end;

implementation

uses
  Rest.Json;

{ TContentParams }

class function TContentParams.Assistant(const Content: string;
  const Prefix: Boolean): TContentParams;
begin
  Result := TContentParams.Create.Role(TMessageRole.assistant).Content(Content);
  if Prefix then
    Result := Result.Prefix(Prefix);
end;

class function TContentParams.Assistant(const Content, Name: string;
  const Prefix: Boolean): TContentParams;
begin
  Result := Assistant(Content, Prefix).Name(Name);
end;

function TContentParams.Content(const Value: TJSONArray): TContentParams;
begin
  Result := TContentParams(Add('content', Value));
end;

function TContentParams.Content(const Value: string): TContentParams;
begin
  Result := TContentParams(Add('content', Value));
end;

function TContentParams.Name(const Value: string): TContentParams;
begin
  Result := TContentParams(Add('name', Value));
end;

function TContentParams.Prefix(const Value: Boolean): TContentParams;
begin
  Result := TContentParams(Add('prefix', Value));
end;

function TContentParams.ReasoningContent(const Value: string): TContentParams;
begin
  Result := TContentParams(Add('reasoning_content', Value));
end;

function TContentParams.Role(const Value: string): TContentParams;
begin
  Result := TContentParams(Add('role', TMessageRole.Create(Value).ToString));
end;

function TContentParams.Role(const Value: TMessageRole): TContentParams;
begin
  Result := TContentParams(Add('role', Value.ToString));
end;

class function TContentParams.System(const Content: string;
  const Name: string): TContentParams;
begin
  Result := TContentParams.Create.Role(TMessageRole.system).Content(Content);
  if not Name.IsEmpty then
    Result := Result.Name(Name);
end;

class function TContentParams.User(const Content: string;
  const Name: string): TContentParams;
begin
  Result := TContentParams.Create.Role(TMessageRole.user).Content(Content);
  if not Name.IsEmpty then
    Result := Result.Name(Name);
end;

{ TChatParams }

function TChatParams.FrequencyPenalty(const Value: Double): TChatParams;
begin
  Result := TChatParams(Add('frequency_penalty', Value));
end;

function TChatParams.Logprobs(const Value: Boolean): TChatParams;
begin
  Result := TChatParams(Add('logprobs', Value));
end;

function TChatParams.MaxTokens(const Value: Integer): TChatParams;
begin
  Result := TChatParams(Add('max_tokens', Value));
end;

function TChatParams.Messages(const Value: TArray<TJSONParam>): TChatParams;
begin
  Result := TChatParams(Add('messages', Value));
end;

function TChatParams.Model(const Value: string): TChatParams;
begin
  Result := TChatParams(Add('model', Value));
end;

function TChatParams.PresencePenalty(const Value: Double): TChatParams;
begin
  Result := TChatParams(Add('presence_penalty', Value));
end;

function TChatParams.ResponseFormat(const Value: string): TChatParams;
begin
  Result := TChatParams(Add('response_format', TJSONObject.Create.AddPair('type', TResponseFormat.Create(Value).ToString)));
end;

function TChatParams.ResponseFormat(
  const Value: TResponseFormat): TChatParams;
begin
  Result := TChatParams(Add('response_format', TJSONObject.Create.AddPair('type', Value.ToString)));
end;

function TChatParams.Stop(const Value: TArray<string>): TChatParams;
begin
  Result := TChatParams(Add('stop', Value));
end;

function TChatParams.Stop(const Value: string): TChatParams;
begin
  Result := TChatParams(Add('stop', Value));
end;

function TChatParams.Stream(const Value: Boolean): TChatParams;
begin
  Result := TChatParams(Add('stream', Value));
end;

function TChatParams.StreamOptions(const Value: Boolean): TChatParams;
begin
  if Value then
    Result := TChatParams(Add('stream_options', TJSONObject.Create.AddPair('include_usage', True) )) else
    Result := Self;
end;

function TChatParams.Temperature(const Value: Double): TChatParams;
begin
  Result := TChatParams(Add('temperature', Value));
end;

function TChatParams.ToolChoice(const Value: TToolChoice): TChatParams;
begin
  Result := TChatParams(Add('tool_choice', Value.ToString));
end;

function TChatParams.ToolChoice(const Value: string): TChatParams;
begin
  Result := TChatParams(Add('tool_choice', TToolChoice.Create(Value).ToString));
end;

function TChatParams.Tools(const Value: TArray<IFunctionCore>): TChatParams;
var
  Arr: TArray<TChatMessageTool>;
begin
  for var Item in Value do
    Arr := Arr + [TChatMessageTool.Add(Item)];
  Result := Tools(Arr);
end;

function TChatParams.Tools(const Value: TArray<TChatMessageTool>): TChatParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.ToJson);
  Result := TChatParams(Add('tools', JSONArray));
end;

function TChatParams.TopLogprobs(const Value: Integer): TChatParams;
begin
  Result := TChatParams(Add('top_logprobs', Value));
end;

function TChatParams.TopP(const Value: Double): TChatParams;
begin
  Result := TChatParams(Add('top_p', Value));
end;

{ TChatRoute }

procedure TChatRoute.AsynCreate(ParamProc: TProc<TChatParams>;
  CallBacks: TFunc<TAsynChat>);
begin
  with TAsynCallBackExec<TAsynChat, TChat>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TChat
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TChatRoute.AsynCreateStream(ParamProc: TProc<TChatParams>;
  CallBacks: TFunc<TAsynChatStream>);
begin
var CallBackParams := TUseParamsFactory<TAsynChatStream>.CreateInstance(CallBacks);

  var Sender := CallBackParams.Param.Sender;
  var OnStart := CallBackParams.Param.OnStart;
  var OnSuccess := CallBackParams.Param.OnSuccess;
  var OnProgress := CallBackParams.Param.OnProgress;
  var OnError := CallBackParams.Param.OnError;
  var OnCancellation := CallBackParams.Param.OnCancellation;
  var OnDoCancel := CallBackParams.Param.OnDoCancel;
  var CancelTag := 0;

  var Task: ITask := TTask.Create(
          procedure()
          begin
            {--- Pass the instance of the current class in case no value was specified. }
            if not Assigned(Sender) then
              Sender := Self;

            {--- Trigger OnStart callback }
            if Assigned(OnStart) then
              TThread.Queue(nil,
                procedure
                begin
                  OnStart(Sender);
                end);
            try
              var Stop := False;

              {--- Processing }
              CreateStream(ParamProc,
                procedure (var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
                begin
                  {--- Check that the process has not been canceled }
                  if Assigned(OnDoCancel) then
                    TThread.Queue(nil,
                        procedure
                        begin
                          Stop := OnDoCancel();
                        end);
                  if Stop then
                    begin
                      {--- Trigger when processus was stopped }
                      if (CancelTag = 0) and Assigned(OnCancellation) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnCancellation(Sender);
                        end);
                      Inc(CancelTag);
                      Cancel := True;
                      Exit;
                    end;
                  if not IsDone and Assigned(Chat) then
                    begin
                      var LocalChat := Chat;
                      Chat := nil;

                      {--- Triggered when processus is progressing }
                      if Assigned(OnProgress) then
                        TThread.Synchronize(TThread.Current,
                        procedure
                        begin
                          try
                            OnProgress(Sender, LocalChat);
                          finally
                            {--- Makes sure to release the instance containing the data obtained
                                 following processing}
                            LocalChat.Free;
                          end;
                        end)
                      else
                        LocalChat.Free;
                    end
                  else
                  if IsDone then
                    begin
                      {--- Trigger OnEnd callback when the process is done }
                      if Assigned(OnSuccess) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnSuccess(Sender);
                        end);
                    end;
                end);
            except
              on E: Exception do
                begin
                  var Error := AcquireExceptionObject;
                  try
                    var ErrorMsg := (Error as Exception).Message;

                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(OnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        OnError(Sender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
          end);
  Task.Start;
end;

function TChatRoute.Create(ParamProc: TProc<TChatParams>): TChat;
begin
  Result := API.Post<TChat, TChatParams>('chat/completions', ParamProc);
end;

procedure TChatRoute.CreateParallel(ParamProc: TProc<TBundleParams>;
  CallBacks: TFunc<TAsynBundleList>);
var
  Tasks: TArray<ITask>;
  BundleParams: TBundleParams;
begin
  BundleParams := TBundleParams.Create;
  try
    if not Assigned(ParamProc) then
      raise Exception.Create('The lambda can''t be null');

    ParamProc(BundleParams);
    var Bundle := TBundleList.Create;
    var Ranking := 0;
    var ErrorExists := False;
    var Prompts := BundleParams.GetPrompt;
    var Counter := Length(Prompts);

    if Assigned(CallBacks.OnStart) then
      CallBacks.OnStart(CallBacks.Sender);

    SetLength(Tasks, Length(Prompts));
    for var index := 0 to Pred(Length(Prompts)) do
      begin
        Tasks[index] := TTask.Run(
          procedure
          begin
            var Buffer := Bundle.Add(index + 1);
            Buffer.Prompt := Prompts[index];
            try
              var Chat := Create(
                procedure (Params: TChatParams)
                begin
                  {--- Set the model for the process }
                  Params.Model(BundleParams.GetModel);

                  {--- Set the current prompt and developer message }
                  Params.Messages([
                    TContentParams.System(BundleParams.GetSystem),
                    TContentParams.User(Buffer.Prompt)
                  ]);
                end);
              Inc(Ranking);
              Buffer.FinishIndex := Ranking;
              Buffer.Response := Chat.Choices[0].Message.Content;
              Buffer.Chat := Chat;
            except
              on E: Exception do
                begin
                  {--- Catch the exception }
                  var Error := AcquireExceptionObject;
                  ErrorExists := True;
                  try
                    var ErrorMsg := (Error as Exception).Message;
                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(CallBacks.OnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        CallBacks.OnError(CallBacks.Sender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
          end);

        if ErrorExists then
          Continue;

        {--- TTask.WaitForAll is not used due to a memory leak in TLightweightEvent/TCompleteEventsWrapper.
             See report RSP-12462 and RSP-25999. }
        TTaskHelper.ContinueWith(Tasks[Index],
          procedure
          begin
            Dec(Counter);
            if Counter = 0 then
              begin
                try
                  if not ErrorExists and Assigned(CallBacks.OnSuccess) then
                    CallBacks.OnSuccess(CallBacks.Sender, Bundle);
                finally
                  Bundle.Free;
                end;
              end;
          end);
        {--- Need a delay, otherwise the process runs only with the first task. }
        Sleep(30);
      end;
  finally
    BundleParams.Free;
  end;
end;

function TChatRoute.CreateStream(ParamProc: TProc<TChatParams>;
  Event: TChatEvent): Boolean;
var
  Response: TStringStream;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Result := API.Post<TChatParams>('chat/completions', ParamProc, Response,
      procedure(const Sender: TObject; AContentLength, AReadCount: Int64; var AAbort: Boolean)
      var
        TextBuffer  : string;
        BufferPos   : Integer;
        PosLineEnd  : Integer;
        Line, Data  : string;
        Chat        : TChat;
        IsDone      : Boolean;
        NewBuffer   : string;
      begin
        {--- Recovers all data already received }
        try
          TextBuffer := Response.DataString;
        except
          {--- invalid encoding: we are waiting for the rest }
          on E: EEncodingError do
            Exit;
        end;

        {--- Current position in the buffer }
        BufferPos := 0;

        {--- Line-by-line processing as long as a complete line (terminated by LF) is available }
        while True do
          begin
            PosLineEnd := TextBuffer.IndexOf(#10, BufferPos);
            if PosLineEnd < 0 then
              {--- incomplete line -> we are waiting for the rest }
              Break;

            Line := TextBuffer.Substring(BufferPos, PosLineEnd - BufferPos).Trim([' ', #13, #10]);
            {--- go to the next line }
            BufferPos := PosLineEnd + 1;

            if Line.IsEmpty then
              {--- empty line -> we ignore }
              Continue;

            Data   := Line.Replace('data: ', '').Trim([' ', #13, #10]);
            IsDone := SameText(Data, '[DONE]');

            Chat := nil;
            if not IsDone then
            try
              Chat := TDeepseekAPI.Parse<TChat>(Data);
            except
              {--- if the JSON is incomplete we ignore }
              Chat := nil;
            end;

            try
              Event(Chat, IsDone, AAbort);
            finally
              Chat.Free;
            end;

            if IsDone then
              {--- end of flow }
              Break;
          end;

        {--- Cleaning: only the incomplete portion of the tampon is kept }
        if BufferPos > 0 then
          begin
            {--- remaining fragment }
            NewBuffer := TextBuffer.Substring(BufferPos);

            {--- completely clears the stream }
            Response.Size := 0;
            if not NewBuffer.IsEmpty then
              {--- rewrites the unfinished fragment }
              Response.WriteString(NewBuffer);
          end;
      end);
  finally
    Response.Free;
  end;
end;

{ TChat }

destructor TChat.Destroy;
begin
  for var Item in FChoices do
    Item.Free;
  if Assigned(FUsage) then
    FUsage.Free;
  inherited;
end;

{ TChatChoice }

destructor TChatChoice.Destroy;
begin
  if Assigned(FMessage) then
    FMessage.Free;
  if Assigned(FLogprobs) then
    FLogprobs.Free;
  if Assigned(FDelta) then
    FDelta.Free;
  inherited;
end;

{ TToolCalls }

destructor TToolCalls.Destroy;
begin
  if Assigned(FFunction) then
    FFunction.Free;
  inherited;
end;

{ TChoiceMessage }

destructor TChoiceMessage.Destroy;
begin
  for var Item in FToolCalls do
    Item.Free;
  inherited;
end;

{ TLogprobs }

destructor TLogprobs.Destroy;
begin
  for var Item in FContent do
    Item.Free;
  inherited;
end;

{ TLogprobContent }

destructor TLogprobContent.Destroy;
begin
  for var Item in FTopLogprobs do
    Item.Free;
  inherited;
end;

end.


unit Deepseek.Errors;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiDeepseek
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  REST.Json.Types;

type
  TErrorCore = class abstract
  end;

  TErrorDatail = class
  private
    FMessage: string;
    FType: string;
    FParam: string;
    [JsonNameAttribute('code')]
    FErrorCode: string;
  public
    property Message: string read FMessage write FMessage;
    property &Type: string read FType write FType;
    property Param: string read FParam write FParam;
    property ErrorCode: string read FErrorCode write FErrorCode;
  end;

  TError = class(TErrorCore)
  private
    FError: TErrorDatail;
  public
    property Error: TErrorDatail read FError write FError;
    destructor Destroy; override;
  end;

implementation


{ TError }

destructor TError.Destroy;
begin
  if Assigned(FError) then
    FError.Free;
  inherited;
end;

end.

unit Deepseek.Exception;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiDeepseek
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, Deepseek.Errors;

type
  TDeepseekException = class(Exception)
  private
    FCode: Int64;
    FMessage: string;
    FType: string;
    FErrorCode: string;
    FParam: string;
  public
    constructor Create(const ACode: Int64; const AError: TErrorCore); reintroduce; overload;
    constructor Create(const ACode: Int64; const Value: string); reintroduce; overload;
    function ToMessageString: string;
    property Code: Int64 read FCode write FCode;
    property Message: string read FMessage write FMessage;
    property &Type: string read FType write FType;
    property ErrorCode: string read FErrorCode write FErrorCode;
    property Param: string read FParam write FParam;
  end;

  TDeepseekExceptionAPI = class(Exception);

  /// <summary>
  /// Invalid request body format.
  /// </summary>
  /// <remarks>
  /// Please modify your request body according to the hints in the error message. For more API format
  /// details, please refer to DeepSeek API Docs.
  /// </remarks>
  TDeepseekExceptionInvalidFormatError = class(TDeepseekException);

  /// <summary>
  /// Authentication fails due to the wrong API key.
  /// </summary>
  /// <remarks>
  /// Please check your API key. If you don't have one, please create an API key first.
  /// </remarks>
  TDeepseekExceptionAuthenticationFailsError = class(TDeepseekException);

  /// <summary>
  /// You have run out of balance.
  /// </summary>
  /// <remarks>
  /// Please check your account's balance, and go to the Top up page to add funds.
  /// </remarks>
  TDeepseekExceptionInsufficientBalanceError = class(TDeepseekException);

  /// <summary>
  /// Your request contains invalid parameters.
  /// </summary>
  /// <remarks>
  /// Please modify your request parameters according to the hints in the error message. For more API format
  /// details, please refer to DeepSeek API Docs.
  /// </remarks>
  TDeepseekExceptionInvalidParametersError = class(TDeepseekException);

  /// <summary>
  /// You are sending requests too quickly.
  /// </summary>
  /// <remarks>
  /// Please pace your requests reasonably. We also advise users to temporarily switch to the APIs of
  /// alternative LLM service providers, like OpenAI.
  /// </remarks>
  TDeepseekExceptionRateLimitReachedError = class(TDeepseekException);

  /// <summary>
  /// Our server encounters an issue.
  /// </summary>
  /// <remarks>
  /// Please retry your request after a brief wait and contact us if the issue persists.
  /// </remarks>
  TDeepseekExceptionServerError = class(TDeepseekException);

  /// <summary>
  /// The server is overloaded due to high traffic.
  /// </summary>
  /// <remarks>
  /// Please retry your request after a brief wait.
  /// </remarks>
  TDeepseekExceptionServerOverloadeError = class(TDeepseekException);

  TDeepseekExceptionInvalidResponse = class(TDeepseekException);

implementation

constructor TDeepseekException.Create(const ACode: Int64; const Value: string);
begin
  inherited Create(Format('error %d: %s', [ACode, Value]));
end;

function TDeepseekException.ToMessageString: string;
begin
  Result := Format('error(%d) - %s'#10'  %s', [Code, ErrorCode, Message]);
end;

constructor TDeepseekException.Create(const ACode: Int64; const AError: TErrorCore);
begin
  Code := ACode;
  Message := (AError as TError).Error.Message;
  &Type := (AError as TError).Error.&Type;
  Param := (AError as TError).Error.Param;
  ErrorCode := (AError as TError).Error.ErrorCode;
  inherited Create(ToMessageString);
end;

end.

unit Deepseek.FIM;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiDeepseek
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, System.Threading,
  REST.Json.Types, Deepseek.API.Params, Deepseek.API, Deepseek.Types,
  Deepseek.Async.Params, Deepseek.Async.Support, Deepseek.Chat;

type
  /// <summary>
  /// Represents a parameter configuration class for the "FIM" model.
  /// </summary>
  /// <remarks>
  /// The <c>TFIMParams</c> class provides methods to set various parameters used for configuring
  /// and customizing requests to the "FIM" (Fill-In-the-Middle) AI model. This includes options
  /// such as the model identifier, prompt text, token limits, penalties, and other advanced settings.
  /// The methods in this class are chainable, allowing for streamlined parameter configuration.
  /// </remarks>
  TFIMParams = class(TJSONParam)
  public
    /// <summary>
    /// Specifies the identifier of the model to use.
    /// </summary>
    /// <param name="Value">
    /// The model ID to be used for the completion.
    /// Ensure that the specified model is supported and correctly spelled.
    /// </param>
    /// <returns>
    /// The updated <c>TFIMParams</c> instance.
    /// </returns>
    /// <remarks>
    /// This parameter is required and determines which model will process the request.
    /// </remarks>
    function Model(const Value: string): TFIMParams;
    /// <summary>
    /// The prompt to generate completions for.
    /// </summary>
    /// <param name="Value">
    /// string prompt
    /// </param>
    /// <returns>
    /// The updated <c>TFIMParams</c> instance.
    /// </returns>
    /// <remarks>
    /// This parameter is required and determines which model will process the request.
    /// </remarks>
    function Prompt(const Value: string): TFIMParams;
    /// <summary>
    /// Echo back the prompt in addition to the completion.
    /// </summary>
    /// <param name="Value">
    /// True calue to activate echo.
    /// </param>
    /// <returns>
    /// The updated <c>TFIMParams</c> instance.
    /// </returns>
    /// <remarks>
    /// This parameter is required and determines which model will process the request.
    /// </remarks>
    function Echo(const Value: Boolean): TFIMParams;
    /// <summary>
    /// Frequency_penalty penalizes the repetition of words based on their frequency in the generated text.
    /// </summary>
    /// <param name="Value">
    /// number (Presence Penalty) [ -2 .. 2 ]; Default: 0
    /// </param>
    /// <returns>
    /// The updated <c>TFIMParams</c> instance.
    /// </returns>
    /// <remarks>
    /// A higher frequency penalty discourages the model from repeating words that have already appeared
    /// frequently in the output, promoting diversity and reducing repetition.
    /// </remarks>
    function FrequencyPenalty(const Value: Double): TFIMParams;
    /// <summary>
    /// Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
    /// </summary>
    /// <param name="Value">
    /// Possible values: <= 20
    /// </param>
    /// <returns>
    /// The updated <c>TFIMParams</c> instance.
    /// </returns>
    function Logprobs(const Value: Integer): TFIMParams;
    /// <summary>
    /// Sets the maximum number of tokens to generate in the completion.
    /// The total token count of your prompt plus <c>max_tokens</c> cannot exceed the model's context length.
    /// </summary>
    /// <param name="Value">
    /// The maximum number of tokens to generate.
    /// Choose an appropriate value based on your prompt length to avoid exceeding the model's limit.
    /// </param>
    /// <returns>
    /// The updated <c>TFIMParams</c> instance.
    /// </returns>
    function MaxTokens(const Value: Integer): TFIMParams;
    /// <summary>
    /// Presence_penalty determines how much the model penalizes the repetition of words or phrases
    /// </summary>
    /// <param name="Value">
    /// number (Presence Penalty) [ -2 .. 2 ]; Default: 0
    /// </param>
    /// <returns>
    /// The updated <c>TFIMParams</c> instance.
    /// </returns>
    /// <remarks>
    /// A higher presence penalty encourages the model to use a wider variety of words and phrases,
    /// making the output more diverse and creative.
    /// </remarks>
    function PresencePenalty(const Value: Double): TFIMParams;
    /// <summary>
    /// Stop (string)
    /// Stop generation if this token is detected. Or if one of these tokens is detected when providing an array
    /// </summary>
    /// <param name="Value">
    /// The string that causes the stop
    /// </param>
    /// <returns>
    /// The updated <c>TFIMParams</c> instance.
    /// </returns>
    function Stop(const Value: string): TFIMParams; overload;
    /// <summary>
    /// Stop Array of Stop (strings) (Stop)
    /// Stop generation if this token is detected. Or if one of these tokens is detected when providing an array
    /// </summary>
    /// <param name="Value">
    /// The array of string that causes the stop
    /// </param>
    /// <returns>
    /// The updated <c>TFIMParams</c> instance.
    /// </returns>
    function Stop(const Value: TArray<string>): TFIMParams; overload;
    /// <summary>
    /// Specifies whether to stream back partial progress as server-sent events (SSE).
    /// If <c>true</c>, tokens are sent as they become available.
    /// If <c>false</c>, the server will hold the request open until timeout or completion.
    /// </summary>
    /// <param name="Value">
    /// A boolean value indicating whether to enable streaming. Default is <c>true</c>, meaning streaming is enabled by default.
    /// </param>
    /// <returns>
    /// The updated <c>TFIMParams</c> instance.
    /// </returns>
    function Stream(const Value: Boolean = True): TFIMParams;
    /// <summary>
    /// Options for streaming response. Only set this when you set stream: true.
    /// </summary>
    /// <param name="Value">
    /// A boolean value indicating whether to enable streaming. Default is <c>true</c>, meaning streaming is enabled by default.
    /// </param>
    /// <returns>
    /// The updated <c>TFIMParams</c> instance.
    /// </returns>
    /// <remarks>
    /// If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on
    /// this chunk shows the token usage statistics for the entire request, and the choices field will
    /// always be an empty array. All other chunks will also include a usage field, but with a null value.
    /// </remarks>
    function StreamOptions(const Value: Boolean): TFIMParams;
    /// <summary>
    /// The suffix that comes after a completion of inserted text.
    /// </summary>
    /// <param name="Value">
    /// String value
    /// </param>
    /// <returns>
    /// The updated <c>TFIMParams</c> instance.
    /// </returns>
    function Suffix(const Value: string): TFIMParams;
    /// <summary>
    /// Sets the sampling temperature to use for the model's output.
    /// Higher values like 0.8 make the output more random, while lower values like 0.2 make it more focused and deterministic.
    /// </summary>
    /// <param name="Value">
    /// The temperature value between 0.0 and 1.0. Default is 0.7.
    /// A temperature of 0 makes the model deterministic, while a temperature of 1 allows for maximum creativity.
    /// </param>
    /// <returns>
    /// The updated <c>TFIMParams</c> instance.
    /// </returns>
    function Temperature(const Value: Double): TFIMParams;
    /// <summary>
    /// Sets the nucleus sampling probability mass for the model (Top-p).
    /// For example, 0.1 means only the tokens comprising the top 10% probability mass are considered.
    /// </summary>
    /// <param name="Value">
    /// The <c>top_p</c> value between 0.0 and 1.0. Default is 1.
    /// Lower values limit the model to consider only the most probable options.
    /// </param>
    /// <returns>
    /// The updated <c>TFIMParams</c> instance.
    /// </returns>
    function TopP(const Value: Double): TFIMParams;
  end;

  /// <summary>
  /// Represents the top log probabilities for tokens generated by the model.
  /// </summary>
  /// <remarks>
  /// The <c>TFIMToplogprobs</c> class provides detailed information about the
  /// probabilities of tokens chosen by the model, including their text offsets
  /// and associated probabilities.
  /// </remarks>
  TFIMToplogprobs = class
  private
    [JsonNameAttribute('text_offset')]
    FTextOffset: TArray<Int64>;
    [JsonNameAttribute('token_logprobs')]
    FTokenLogprobs: TArray<Double>;
    FTokens: TArray<string>;
  public
    /// <summary>
    /// Gets or sets the text offsets for the tokens.
    /// </summary>
    /// <remarks>
    /// Use the <c>TextOffset</c> property to determine the starting character
    /// positions of tokens within the generated text. Each entry corresponds to
    /// the tokens in the <c>Tokens</c> property.
    /// </remarks>
    property TextOffset: TArray<Int64> read FTextOffset write FTextOffset;
    /// <summary>
    /// Gets or sets the log probabilities of the tokens.
    /// </summary>
    /// <remarks>
    /// The <c>TokenLogprobs</c> property provides a quantitative measure of the
    /// likelihood of each token. Values closer to zero indicate higher probability,
    /// while more negative values indicate lower probability.
    /// </remarks>
    property TokenLogprobs: TArray<Double> read FTokenLogprobs write FTokenLogprobs;
    /// <summary>
    /// Gets or sets the tokens generated by the model.
    /// </summary>
    /// <remarks>
    /// The <c>Tokens</c> property contains the actual text tokens corresponding to
    /// the log probabilities and text offsets. Each token represents a part of the
    /// generated text.
    /// </remarks>
    property Tokens: TArray<string> read FTokens write FTokens;
  end;

  /// <summary>
  /// Represents the log probabilities of tokens generated by the model.
  /// </summary>
  /// <remarks>
  /// The <c>TFIMLogprobs</c> class stores detailed information about the probabilities of tokens
  /// generated during a completion request. It includes data such as the tokens themselves,
  /// their respective log probabilities, and the character offsets of each token in the response text.
  /// Additionally, it can provide detailed insights into the top alternative tokens and their probabilities
  /// at each generation step.
  /// </remarks>
  TFIMLogprobs = class
  private
    [JsonNameAttribute('text_offset')]
    FTextOffset: TArray<Int64>;
    [JsonNameAttribute('token_logprobs')]
    FTokenLogprobs: TArray<Double>;
    FTokens: TArray<string>;
    [JsonNameAttribute('top_logprobs')]
    FTopLogprobs: TArray<TFIMToplogprobs>;
  public
    /// <summary>
    /// Gets or sets the array of character offsets for each token.
    /// </summary>
    property TextOffset: TArray<Int64> read FTextOffset write FTextOffset;
    /// <summary>
    /// Gets or sets the array of log probabilities for each token.
    /// </summary>
    property TokenLogprobs: TArray<Double> read FTokenLogprobs write FTokenLogprobs;
    /// <summary>
    /// Gets or sets the array of tokens generated by the model.
    /// </summary>
    property Tokens: TArray<string> read FTokens write FTokens;
    /// <summary>
    /// Gets or sets the array of top alternative tokens and their log probabilities.
    /// </summary>
    property TopLogprobs: TArray<TFIMToplogprobs> read FTopLogprobs write FTopLogprobs;
    /// <summary>
    /// Destructor to clean up resources used by the <c>TChatChoices</c> instance.
    /// </summary>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a choice generated by the AI model in response to a completion request.
  /// </summary>
  /// <remarks>
  /// The <c>TFIMChoice</c> class contains details about a specific choice produced by the AI model,
  /// including the generated text, associated log probabilities, the index of the choice,
  /// and the reason why the model stopped generating further tokens.
  /// </remarks>
  TFIMChoice = class
  private
    [JsonNameAttribute('finish_reason')]
    [JsonReflectAttribute(ctString, rtString, TFinishReasonInterceptor)]
    FFinishReason: TFinishReason;
    FIndex: Int64;
    FLogprobs: TFIMLogprobs;
    FText: string;
  public
    /// <summary>
    /// Possible values: [stop, length, content_filter, insufficient_system_resource]
    /// </summary>
    /// <remarks>
    /// The reason the model stopped generating tokens. This will be stop if the model hit a natural stop
    /// point or a provided stop sequence, length if the maximum number of tokens specified in the request
    /// was reached, content_filter if content was omitted due to a flag from our content filters, or
    /// insufficient_system_resource if the request is interrupted due to insufficient resource of the
    /// inference system.
    /// </remarks>
    property FinishReason: TFinishReason read FFinishReason write FFinishReason;
    /// <summary>
    /// The index of the choice in the list of possible choices generated by the model.
    /// </summary>
    /// <remarks>
    /// The <c>Index</c> property helps identify the position of this particular choice in a set of choices provided by the AI model.
    /// This is useful when multiple options are generated for completion, and each one is referenced by its index.
    /// </remarks>
    property Index: Int64 read FIndex write FIndex;
    /// <summary>
    /// Log probability information for the choice.
    /// </summary>
    property Logprobs: TFIMLogprobs read FLogprobs write FLogprobs;
    /// <summary>
    /// The content of the response.
    /// </summary>
    property Text: string read FText write FText;
    /// <summary>
    /// Destructor to clean up resources used by the <c>TChatChoices</c> instance.
    /// </summary>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents the main class for managing text completion responses.
  /// </summary>
  /// <remarks>
  /// The <c>TFIM</c> class encapsulates the details of a completion operation performed by an AI model.
  /// It includes properties such as the generated text choices, metadata about the completion, and usage statistics.
  /// This class is designed to work with the Deepseek API for handling text completions.
  /// </remarks>
  TFIM = class(TJSONFingerprint)
  private
    FId: string;
    FChoices: TArray<TFIMChoice>;
    FCreated: Int64;
    FModel: string;
    [JsonNameAttribute('system_fingerprint')]
    FSystemFingerprint: string;
    FObject: string;
    FUsage: TUsage;
  public
    /// <summary>
    /// A unique identifier for the completion.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// The list of completion choices the model generated for the input prompt.
    /// </summary>
    property Choices: TArray<TFIMChoice> read FChoices write FChoices;
    /// <summary>
    /// The Unix timestamp (in seconds) of when the completion was created.
    /// </summary>
    property Created: Int64 read FCreated write FCreated;
    /// <summary>
    /// The model used for completion.
    /// </summary>
    property Model: string read FModel write FModel;
    /// <summary>
    /// This fingerprint represents the backend configuration that the model runs with.
    /// </summary>
    property SystemFingerprint: string read FSystemFingerprint write FSystemFingerprint;
    /// <summary>
    /// Possible values: [text_completion]
    /// </summary>
    /// <remarks>
    /// The object type, which is always "text_completion"
    /// </remarks>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// Usage statistics for the completion request.
    /// </summary>
    property Usage: TUsage read FUsage write FUsage;
    /// <summary>
    /// Destructor to release any resources used by this instance.
    /// </summary>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TFIM</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynFIM</c> type extends the <c>TAsynParams&lt;TFIM&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynFIM = TAsynCallBack<TFIM>;

  /// <summary>
  /// Manages asynchronous streaming chat callBacks for a chat request using <c>TFIM</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynFIMStream</c> type extends the <c>TAsynStreamParams&lt;TFIM&gt;</c> record to support the lifecycle of an asynchronous streaming chat operation.
  /// It provides callbacks for different stages, including when the operation starts, progresses with new data chunks, completes successfully, or encounters an error.
  /// This structure is ideal for handling scenarios where the chat response is streamed incrementally, providing real-time updates to the user interface.
  /// </remarks>
  TAsynFIMStream = TAsynStreamCallBack<TFIM>;

  /// <summary>
  /// Represents a callback procedure used during the reception of responses from a chat request in streaming mode.
  /// </summary>
  /// <param name="FIM">
  /// The <c>TFIM</c> object containing the current information about the response generated by the model.
  /// If this value is <c>nil</c>, it indicates that the data stream is complete.
  /// </param>
  /// <param name="IsDone">
  /// A boolean flag indicating whether the streaming process is complete.
  /// If <c>True</c>, it means the model has finished sending all response data.
  /// </param>
  /// <param name="Cancel">
  /// A boolean flag that can be set to <c>True</c> within the callback to cancel the streaming process.
  /// If set to <c>True</c>, the streaming will be terminated immediately.
  /// </param>
  /// <remarks>
  /// This callback is invoked multiple times during the reception of the response data from the model.
  /// It allows for real-time processing of received messages and interaction with the user interface or other systems
  /// based on the state of the data stream.
  /// When the <c>IsDone</c> parameter is <c>True</c>, it indicates that the model has finished responding,
  /// and the <c>TFIM</c> parameter will be <c>nil</c>.
  /// </remarks>
  TFIMEvent = reference to procedure(var FIM: TFIM; IsDone: Boolean; var Cancel: Boolean);

  /// <summary>
  /// Provides methods to manage and execute completion operations with AI models.
  /// </summary>
  /// <remarks>
  /// The <c>TFIM</c> class extends <c>TDeepseekAPIRoute</c> and offers
  /// functionality for synchronous and asynchronous interactions with AI "fim" models.
  /// It supports:
  /// <para>- Creating chat completions.</para>
  /// <para>- Streaming chat completions for real-time updates.</para>
  /// <para>- Managing callbacks for progress, success, and error handling during asynchronous operations.</para>
  /// <para>
  /// This class is designed to provide seamless integration with the Deepseek API,
  /// allowing for flexible and efficient chat-based interactions in applications.
  /// </para>
  /// </remarks>
  TFIMRoute = class(TDeepseekAPIRoute)
    /// <summary>
    /// Create an asynchronous completion "FIM" for message.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the parameters for the "FIM" request, such as model selection, messages, and other parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for the asynchronous "FIM" completion, such as on success and on error.
    /// </param>
    /// <remarks>
    /// This procedure initiates an asynchronous request to generate a completion based on the provided parameters. The response or error is handled by the provided callBacks.
    /// <code>
    /// //var DeepSeekBeta := TDeepseekFactory.CreateBetaInstance(BarearKey);
    /// DeepSeekBeta.Chat.AsyncCreate(
    ///   procedure (Params: TFIMParams)
    ///   begin
    ///     // Define chat parameters
    ///   end,
    ///   function: TAsynFIM
    ///   begin
    ///     Result.Sender := My_component;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; FIM: TFIM)
    ///     begin
    ///       // Handle success operation
    ///     end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Value: string)
    ///     begin
    ///       // Handle error message
    ///     end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsynCreate(ParamProc: TProc<TFIMParams>; CallBacks: TFunc<TAsynFIM>);
    /// <summary>
    /// Creates an asynchronous streaming "FIM" completion request.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the "FIM" request, including the model, prompt, and additional options such as max tokens and streaming mode.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a <c>TAsynFIMStream</c> record which contains event handlers for managing different stages of the streaming process: progress updates, success, errors, and cancellation.
    /// </param>
    /// <remarks>
    /// This procedure initiates an asynchronous "FIM" operation in streaming mode, where tokens are progressively received and processed.
    /// The provided event handlers allow for handling progress (i.e., receiving tokens in real time), detecting success, managing errors, and enabling cancellation logic.
    /// <code>
    /// //var DeepSeekBeta := TDeepseekFactory.CreateBetaInstance(BarearKey);
    /// DeepSeekBeta.Chat.AsyncCreateStream(
    ///   procedure(Params: TFIMParams)
    ///   begin
    ///     // Define chat parameters
    ///     Params.Stream;
    ///   end,
    ///
    ///   function: TAsynFIMStream
    ///   begin
    ///     Result.Sender := My_component; // Instance passed to callback parameter
    ///     Result.OnProgress :=
    ///         procedure (Sender: TObject; FIM: TFIM)
    ///         begin
    ///           // Handle progressive updates to the chat response
    ///         end;
    ///     Result.OnSuccess :=
    ///         procedure (Sender: TObject)
    ///         begin
    ///           // Handle success when the operation completes
    ///         end;
    ///     Result.OnError :=
    ///         procedure (Sender: TObject; Value: string)
    ///         begin
    ///           // Handle error message
    ///         end;
    ///     Result.OnDoCancel :=
    ///         function: Boolean
    ///         begin
    ///           Result := CheckBox1.Checked; // Click on checkbox to cancel
    ///         end;
    ///     Result.OnCancellation :=
    ///         procedure (Sender: TObject)
    ///         begin
    ///           // Processing when process has been canceled
    ///         end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsynCreateStream(ParamProc: TProc<TFIMParams>;
      CallBacks: TFunc<TAsynFIMStream>);
    /// <summary>
    /// Creates a completion for the "FIM" message using the provided parameters.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the "FIM" request, such as selecting the model,
    /// providing messages, setting token limits, etc.
    /// </param>
    /// <returns>
    /// Returns a <c>TFIM</c> object that contains the chat response, including the choices generated by the model.
    /// </returns>
    /// <remarks>
    /// The <c>Create</c> method sends a "FIM" completion request and waits for the full response.
    /// The returned <c>TFIM</c> object contains the model's generated response, including multiple
    /// choices if available.
    /// <code>
    /// //var DeepSeekBeta := TDeepseekFactory.CreateBetaInstance(BarearKey);
    /// var Value := DeepSeekBeta.Chat.Create(
    ///     procedure (Params: TFIMParams)
    ///     begin
    ///       // Define chat parameters
    ///     end);
    ///   try
    ///     // Handle the Value
    ///   finally
    ///     Value.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Create(ParamProc: TProc<TFIMParams>): TFIM;
    /// <summary>
    /// Creates a "FIM" message completion with a streamed response.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the "FIM" request, such as selecting the model, providing messages, and adjusting other settings like token limits or temperature.
    /// </param>
    /// <param name="Event">
    /// A callback of type <c>TFIMEvent</c> that is triggered with each chunk of data received during the streaming process. It includes the current state of the <c>TFIM</c> object, a flag indicating if the stream is done, and a boolean to handle cancellation.
    /// </param>
    /// <returns>
    /// Returns <c>True</c> if the streaming process started successfully, <c>False</c> otherwise.
    /// </returns>
    /// <remarks>
    /// This method initiates a chat request in streaming mode, where the response is delivered incrementally in real-time.
    /// The <c>Event</c> callback will be invoked multiple times as tokens are received.
    /// When the response is complete, the <c>IsDone</c> flag will be set to <c>True</c>, and the <c>FIM</c> object will be <c>nil</c>.
    /// The streaming process can be interrupted by setting the <c>Cancel</c> flag to <c>True</c> within the event.
    /// <code>
    /// //var DeepSeekBeta := TDeepseekFactory.CreateBetaInstance(BarearKey);
    ///   DeepSeekBeta.Chat.CreateStream(
    ///     procedure (Params: TFIMParams)
    ///     begin
    ///       // Define chat parameters
    ///     end,
    ///
    ///     procedure(var FIM: TFIM; IsDone: Boolean; var Cancel: Boolean)
    ///     begin
    ///       // Handle displaying
    ///     end);
    /// </code>
    /// </remarks>
    function CreateStream(ParamProc: TProc<TFIMParams>; Event: TFIMEvent): Boolean;
  end;

implementation

uses
  Rest.Json;

{ TFIM }

destructor TFIM.Destroy;
begin
  for var Item in FChoices do
    Item.Free;
  if Assigned(FUsage) then
    FUsage.Free;
  inherited;
end;

{ TFIMChoice }

destructor TFIMChoice.Destroy;
begin
  if Assigned(FLogprobs) then
    FLogprobs.Free;
  inherited;
end;

{ TFIMLogprobs }

destructor TFIMLogprobs.Destroy;
begin
  for var Item in FTopLogprobs do
    Item.Free;
  inherited;
end;

{ TFIMParams }

function TFIMParams.Echo(const Value: Boolean): TFIMParams;
begin
  Result := TFIMParams(Add('echo', Value));
end;

function TFIMParams.FrequencyPenalty(const Value: Double): TFIMParams;
begin
  Result := TFIMParams(Add('frequency_penalty', Value));
end;

function TFIMParams.Logprobs(const Value: Integer): TFIMParams;
begin
  Result := TFIMParams(Add('logprobs', Value));
end;

function TFIMParams.MaxTokens(const Value: Integer): TFIMParams;
begin
  Result := TFIMParams(Add('max_tokens', Value));
end;

function TFIMParams.Model(const Value: string): TFIMParams;
begin
  Result := TFIMParams(Add('model', Value));
end;

function TFIMParams.PresencePenalty(const Value: Double): TFIMParams;
begin
  Result := TFIMParams(Add('presence_penalty', Value));
end;

function TFIMParams.Prompt(const Value: string): TFIMParams;
begin
  Result := TFIMParams(Add('prompt', Value));
end;

function TFIMParams.Stop(const Value: TArray<string>): TFIMParams;
begin
  Result := TFIMParams(Add('stop', Value));
end;

function TFIMParams.Stream(const Value: Boolean): TFIMParams;
begin
  Result := TFIMParams(Add('stream', Value));
end;

function TFIMParams.StreamOptions(const Value: Boolean): TFIMParams;
begin
  if Value then
    Result := TFIMParams(Add('stream_options', TJSONObject.Create.AddPair('include_usage', True) )) else
    Result := Self;
end;

function TFIMParams.Suffix(const Value: string): TFIMParams;
begin
  Result := TFIMParams(Add('suffix', Value));
end;

function TFIMParams.Temperature(const Value: Double): TFIMParams;
begin
  Result := TFIMParams(Add('temperature', Value));
end;

function TFIMParams.TopP(const Value: Double): TFIMParams;
begin
  Result := TFIMParams(Add('top_p', Value));
end;

function TFIMParams.Stop(const Value: string): TFIMParams;
begin
  Result := TFIMParams(Add('stop', Value));
end;

{ TFIMRoute }

procedure TFIMRoute.AsynCreate(ParamProc: TProc<TFIMParams>;
  CallBacks: TFunc<TAsynFIM>);
begin
  with TAsynCallBackExec<TAsynFIM, TFIM>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TFIM
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TFIMRoute.AsynCreateStream(ParamProc: TProc<TFIMParams>;
  CallBacks: TFunc<TAsynFIMStream>);
begin
var CallBackParams := TUseParamsFactory<TAsynFIMStream>.CreateInstance(CallBacks);

  var Sender := CallBackParams.Param.Sender;
  var OnStart := CallBackParams.Param.OnStart;
  var OnSuccess := CallBackParams.Param.OnSuccess;
  var OnProgress := CallBackParams.Param.OnProgress;
  var OnError := CallBackParams.Param.OnError;
  var OnCancellation := CallBackParams.Param.OnCancellation;
  var OnDoCancel := CallBackParams.Param.OnDoCancel;

  var Task: ITask := TTask.Create(
          procedure()
          begin
            {--- Pass the instance of the current class in case no value was specified. }
            if not Assigned(Sender) then
              Sender := Self;

            {--- Trigger OnStart callback }
            if Assigned(OnStart) then
              TThread.Queue(nil,
                procedure
                begin
                  OnStart(Sender);
                end);
            try
              var Stop := False;

              {--- Processing }
              CreateStream(ParamProc,
                procedure (var FIM: TFIM; IsDone: Boolean; var Cancel: Boolean)
                begin
                  {--- Check that the process has not been canceled }
                  if Assigned(OnDoCancel) then
                    TThread.Queue(nil,
                        procedure
                        begin
                          Stop := OnDoCancel();
                        end);
                  if Stop then
                    begin
                      {--- Trigger when processus was stopped }
                      if Assigned(OnCancellation) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnCancellation(Sender)
                        end);
                      Cancel := True;
                      Exit;
                    end;
                  if not IsDone and Assigned(FIM) then
                    begin
                      var LocalChat := FIM;
                      FIM := nil;

                      {--- Triggered when processus is progressing }
                      if Assigned(OnProgress) then
                        TThread.Synchronize(TThread.Current,
                        procedure
                        begin
                          try
                            OnProgress(Sender, LocalChat);
                          finally
                            {--- Makes sure to release the instance containing the data obtained
                                 following processing}
                            LocalChat.Free;
                          end;
                        end)
                      else
                        LocalChat.Free;
                    end
                  else
                  if IsDone then
                    begin
                      {--- Trigger OnEnd callback when the process is done }
                      if Assigned(OnSuccess) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnSuccess(Sender);
                        end);
                    end;
                end);
            except
              on E: Exception do
                begin
                  var Error := AcquireExceptionObject;
                  try
                    var ErrorMsg := (Error as Exception).Message;

                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(OnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        OnError(Sender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
          end);
  Task.Start;
end;

function TFIMRoute.Create(ParamProc: TProc<TFIMParams>): TFIM;
begin
  Result := API.Post<TFIM, TFIMParams>('completions', ParamProc);
end;

function TFIMRoute.CreateStream(ParamProc: TProc<TFIMParams>;
  Event: TFIMEvent): Boolean;
var
  Response: TStringStream;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Result := API.Post<TFIMParams>('completions', ParamProc, Response,
      procedure(const Sender: TObject; AContentLength, AReadCount: Int64; var AAbort: Boolean)
      var
        TextBuffer  : string;
        BufferPos   : Integer;
        PosLineEnd  : Integer;
        Line, Data  : string;
        Chat        : TFIM;
        IsDone      : Boolean;
        NewBuffer   : string;
      begin
        {--- Recovers all data already received }
        try
          TextBuffer := Response.DataString;
        except
          {--- invalid encoding: we are waiting for the rest }
          on E: EEncodingError do
            Exit;
        end;

        {--- Current position in the buffer }
        BufferPos := 0;

        {--- Line-by-line processing as long as a complete line (terminated by LF) is available }
        while True do
          begin
            PosLineEnd := TextBuffer.IndexOf(#10, BufferPos);
            if PosLineEnd < 0 then
              {--- incomplete line -> we are waiting for the rest }
              Break;

            Line := TextBuffer.Substring(BufferPos, PosLineEnd - BufferPos).Trim([' ', #13, #10]);
            {--- go to the next line }
            BufferPos := PosLineEnd + 1;

            if Line.IsEmpty then
              {--- empty line -> we ignore }
              Continue;

            Data   := Line.Replace('data: ', '').Trim([' ', #13, #10]);
            IsDone := SameText(Data, '[DONE]');

            Chat := nil;
            if not IsDone then
            try
              Chat := TDeepseekAPI.Parse<TFIM>(Data);
            except
              {--- if the JSON is incomplete we ignore }
              Chat := nil;
            end;

            try
              Event(Chat, IsDone, AAbort);
            finally
              Chat.Free;
            end;

            if IsDone then
              {--- end of flow }
              Break;
          end;

        {--- Cleaning: only the incomplete portion of the tampon is kept }
        if BufferPos > 0 then
          begin
            {--- remaining fragment }
            NewBuffer := TextBuffer.Substring(BufferPos);

            {--- completely clears the stream }
            Response.Size := 0;
            if not NewBuffer.IsEmpty then
              {--- rewrites the unfinished fragment }
              Response.WriteString(NewBuffer);
          end;
      end);
  finally
    Response.Free;
  end;
end;

end.

unit Deepseek.Functions.Core;

{-------------------------------------------------------------------------------

      Github repository : https://github.com/MaxiDonkey/DelphiDeepseek
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.JSON;

type
  /// <summary>
  /// Interface defining the core structure and functionality of a function in the system.
  /// </summary>
  /// <remarks>
  /// This interface outlines the basic properties and methods that any function implementation must include.
  /// </remarks>
  IFunctionCore = interface
    ['{2D8EA8C5-1E60-481D-B95F-2EFFE2CF6A7D}']
    /// <summary>
    /// Retrieves the description of the function.
    /// </summary>
    function GetDescription: string;
    /// <summary>
    /// Retrieves the name of the function.
    /// </summary>
    function GetName: string;
    /// <summary>
    /// Retrieves the parameters required by the function, represented as a JSON schema.
    /// </summary>
    function GetParameters: string;
    /// <summary>
    /// Retrieves the type of the function, typically "function".
    /// </summary>
    function GetType: string;
    /// <summary>
    /// Executes the function with the provided arguments and returns the result as a string.
    /// </summary>
    /// <param name="Arguments">The arguments passed to the function in JSON format.</param>
    /// <returns>The result of the function execution as a string.</returns>
    function Execute(const Arguments: string): string;
     /// <summary>
    /// Converts the TFunctionCore instance to a JSON object that contains its type and representation.
    /// </summary>
    /// <returns>A JSON object representing the function instance.</returns>
    function ToJson: TJSONObject;
    /// <summary>
    /// Creates a string representation of the TFunctionCore instance in JSON format, including its description, name, and parameters.
    /// </summary>
    /// <returns>A string representation of the function in JSON format.</returns>
    function ToString: string;
    /// <summary>
    /// A brief description of the function's purpose, used by the model to determine when and how to call the function.
    /// </summary>
    property Description: string read GetDescription;
    /// <summary>
    /// The unique identifier of the function that will be called. It must only contain characters from a-z, A-Z, 0-9, underscores, or dashes, and should not exceed 64 characters in length.
    /// </summary>
    property Name: string read GetName;
    //// <summary>
    /// The parameters required by the function, specified as a JSON schema. If no parameters are required, use the schema: {"type": "object", "properties": {}}.
    /// </summary>
    property Parameters: string read GetParameters;
    /// <summary>
    /// The type of the tool. Currently, only "function" is supported.
    /// </summary>
    property &Type: string read GetType;
  end;

  /// <summary>
  /// Abstract base class for implementing core function behavior.
  /// </summary>
  /// <remarks>
  /// This class provides basic implementations for some methods and defines the structure that derived classes must follow.
  /// </remarks>
  TFunctionCore = class abstract(TinterfacedObject, IFunctionCore)
  protected
    /// <summary>
    /// Retrieves the description of the function. Derived classes must implement this method.
    /// </summary>
    function GetDescription: string; virtual; abstract;
     /// <summary>
    /// Retrieves the name of the function. Derived classes must implement this method.
    /// </summary>
    function GetName: string; virtual; abstract;
    /// <summary>
    /// Retrieves the parameters required by the function, represented as a JSON schema. Derived classes must implement this method.
    /// </summary>
    function GetParameters: string; virtual; abstract;
    /// <summary>
    /// Retrieves the type of the function, which is "function" by default.
    /// </summary>
    function GetType: string; virtual;
  public
    /// <summary>
    /// Executes the function with the provided arguments and returns the result as a string. Derived classes must implement this method.
    /// </summary>
    /// <param name="Arguments">The arguments passed to the function in JSON format.</param>
    /// <returns>The result of the function execution as a string.</returns>
    function Execute(const Arguments: string): string; virtual; abstract;
    /// <summary>
    /// Converts the TFunctionCore instance to a JSON object that contains its type and representation.
    /// </summary>
    /// <returns>A JSON object representing the function instance.</returns>
    function ToJson: TJSONObject;
    /// <summary>
    /// Creates a string representation of the TFunctionCore instance in JSON format, including its description, name, and parameters.
    /// </summary>
    /// <returns>A string representation of the function in JSON format.</returns>
    function ToString: string; override;
    /// <summary>
    /// A brief description of the function's purpose, used by the model to determine when and how to call the function.
    /// </summary>
    property Description: string read GetDescription;
    /// <summary>
    /// The unique identifier of the function that will be called. It must only contain characters from a-z, A-Z, 0-9, underscores, or dashes, and should not exceed 64 characters in length.
    /// </summary>
    property Name: string read GetName;
    /// <summary>
    /// The parameters required by the function, specified as a JSON schema. If no parameters are required, use the schema: {"type": "object", "properties": {}}.
    /// </summary>
    property Parameters: string read GetParameters;
    /// <summary>
    /// The type of the tool. Currently, only "function" is supported.
    /// </summary>
    property &Type: string read GetType;
  end;

implementation

{ TFunctionCore }

function TFunctionCore.GetType: string;
begin
  Result := 'function';
end;

function TFunctionCore.ToJson: TJSONObject;
begin
  Result := TJSONObject.Create;
  try
    Result.AddPair('type', &Type);
    Result.AddPair('function', TJSONObject.ParseJSONValue(ToString));
  except
    on E: Exception do
      begin
        Result.Free;
        raise;
      end;
  end;
end;

function TFunctionCore.ToString: string;
begin
  with TStringWriter.Create do
    try
      Write('"description": "%s",', [Description]);
      Write('"name": "%s",', [Name]);
      Write('"parameters": %s', [Parameters]);
      Result := Format('{%s}', [ToString]);
    finally
      Free;
    end;
end;

end.

unit Deepseek.Functions.Example;

{-------------------------------------------------------------------------------

      Github repository : https://github.com/MaxiDonkey/DelphiDeepseek
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, Deepseek.Functions.Core, Deepseek.Schema;

type
  TWeatherReportFunction = class(TFunctionCore)
  protected
    function GetDescription: string; override;
    function GetName: string; override;
    function GetParameters: string; override;
  public
    function Execute(const Arguments: string): string; override;
    class function CreateInstance: IFunctionCore;
  end;

implementation

uses
  System.StrUtils, System.JSON;

{ TWeatherReportFunction }

class function TWeatherReportFunction.CreateInstance: IFunctionCore;
begin
  Result := TWeatherReportFunction.create;
end;

function TWeatherReportFunction.Execute(const Arguments: string): string;

  procedure AddToReport(const Value: TJSONObject;
    Temperature: Integer; Forecast: TArray<string>);
  begin
    Value.AddPair('temperature', TJSONNumber.Create(Temperature));
    Value.AddPair('forecast', TJSONArray.Create(Forecast[0], Forecast[1]));
  end;

begin
  Result := EmptyStr;
  var Location := EmptyStr;
  var UnitType := EmptyStr;

  {--- Parse arguments to retrieve parameters }
  var JSON := TJSONObject.ParseJSONValue(Arguments) as TJSONObject;
  try
    if Assigned(JSON) then
    try
      Location := JSON.GetValue('location', '');
      UnitType := JSON.GetValue('unit', '');
    finally
      JSON.Free;
    end;
  except
    Location := EmptyStr;
  end;

  {--- Stop the treatment if location is empty }
  if Location.IsEmpty then
    Exit;

  {--- Build the response }
  JSON := TJSONObject.Create;
  try
    JSON.AddPair('location', Location);
    JSON.AddPair('unit', UnitType);
    case IndexStr(AnsiLowerCase(Location), [
      'paris', 'paris, 75',
      'marseille', 'marseille, 13']) of
      0,1 :
        AddToReport(JSON, 14, ['rainy', 'low visibility']);

      2,3 :
        AddToReport(JSON, 29, ['sunny', 'windy']);
    end;
    Result := JSON.ToJSON;
  finally
    JSON.Free;
  end;
end; {Execute}

function TWeatherReportFunction.GetDescription: string;
begin
  Result := 'Get the current weather in a given location.';
end;

function TWeatherReportFunction.GetName: string;
begin
  Result := 'get_weather';
end;

function TWeatherReportFunction.GetParameters: string;
begin
//  Result :=
//    '{'+
//    '"type": "object",'+
//    '"properties": {'+
//         '"location": {'+
//             '"type": "string",'+
//             '"description": "The city and department, e.g. Marseille, 13"'+
//         '},'+
//         '"unit": {'+
//             '"type": "string",'+
//             '"enum": ["celsius", "fahrenheit"]'+
//         '}'+
//     '},'+
//     '"required": ["location"]'+
//  '}';

  {--- If we use the TSchemaParams class defined in the MistralAI.Schema.pas unit }
  var Schema := TSchemaParams.New(
    procedure (var Params: TSchemaParams)
    begin
      Params.&Type(stOBJECT);
      Params.Properties('properties',
        procedure (var Params: TSchemaParams)
        begin
          Params.Properties('location',
            procedure (var Params: TSchemaParams)
            begin
              Params.&Type(stSTRING);
              Params.Description('The city and state, e.g. San Francisco, CA');
            end);
          Params.Properties('unit',
            procedure (var Params: TSchemaParams)
            begin
              Params.&Type(stSTRING);
              Params.Enum(['celsius', 'fahrenheit']);
            end);
        end);
      Params.Required(['location', 'unit']);
    end);
  Result := Schema.ToJsonString(True);
end;

end.

unit Deepseek.Functions.Tools;

{-------------------------------------------------------------------------------

      Github repository : https://github.com/MaxiDonkey/DelphiDeepseek
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, REST.Json.Types,
  Deepseek.Functions.Core, Deepseek.Types;

type
  /// <summary>
  /// Represents a tool used for interacting with chat messages, including the ability to convert
  /// functions to JSON format.
  /// </summary>
  TChatMessageTool = record
  private
    FFunction: IFunctionCore;
  public
    /// <summary>
    /// This method converts the TFunctionCore instance to a JSON object containing the type and
    /// representation of the function, and handles exceptions by deleting the JSON object and
    /// propagating the exception if an error occurs
    /// </summary>
    /// <returns>
    /// A <c>TJSONObject</c> representing the function in JSON format.
    /// </returns>
    function ToJson: TJSONObject;
    /// <summary>
    /// The function properties
    /// </summary>
    property &Function: IFunctionCore read FFunction write FFunction;
    /// <summary>
    /// Adds a function to the chat message tool.
    /// </summary>
    /// <param name="AFunction">
    /// The function to be added.
    /// </param>
    /// <returns>
    /// An instance of <c>TChatMessageTool</c> containing the specified function.
    /// </returns>
    class function Add(const AFunction: IFunctionCore): TChatMessageTool; static;
  end;

  /// <summary>
  /// Represents the specifics of a called function, including its name and calculated arguments.
  /// </summary>
  TCalledFunctionSpecifics = class
  private
    FName: string;
    FArguments: string;
  public
    /// <summary>
    /// Gets or sets the name of the called function
    /// </summary>
    property Name: string read FName write FName;
    /// <summary>
    /// Gets or sets the calculed Arguments for the called function
    /// </summary>
    property Arguments: string read FArguments write FArguments;
  end;

  /// <summary>
  /// Represents a called function, containing its specifics such as name and arguments.
  /// </summary>
  TCalledFunction = class
  private
    FId: string;
    FType: string;
    FFunction: TCalledFunctionSpecifics;
  public
    /// <summary>
    /// Gets or sets the id of the called function
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Gets or sets the type of the called function
    /// </summary>
    property &Type: string read FType write FType;
    /// <summary>
    /// Gets or sets the specifics of the called function
    /// </summary>
    property &Function: TCalledFunctionSpecifics read FFunction write FFunction;
    /// <summary>
    /// Destructor that ensures proper memory management by freeing the <c>FFunction</c> property
    /// when the <c>TCalledFunction</c> instance is destroyed.
    /// </summary>
    destructor Destroy; override;
  end;

implementation

{ TChatMessageTool }

class function TChatMessageTool.Add(
  const AFunction: IFunctionCore): TChatMessageTool;
begin
  Result.&Function := AFunction;
end;

function TChatMessageTool.ToJson: TJSONObject;
begin
  Result := FFunction.ToJson;
end;

{ TCalledFunction }

destructor TCalledFunction.Destroy;
begin
  if Assigned(FFunction) then
    FFunction.Free;
  inherited;
end;

end.

unit Deepseek.HttpClient.Intf;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiDeepseek
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Net.HttpClient, System.Net.URLClient,
  System.JSON, System.Net.Mime;

type
  /// <summary>
  /// Interface for configuring HTTP client parameters such as timeouts and proxy settings.
  /// </summary>
  /// <remarks>
  /// This interface provides properties and methods to set and retrieve various HTTP client configurations,
  /// including send timeout, connection timeout, response timeout, and proxy settings.
  /// Implementers of this interface should ensure that these configurations are appropriately applied
  /// to the underlying HTTP client used for making web requests.
  /// </remarks>
  IHttpClientParam = interface
    ['{DF8D342F-B54A-4AAF-BD1A-2D9045C2BA7F}']
    /// <summary>
    /// Sets the send timeout for HTTP requests.
    /// </summary>
    /// <param name="Value">
    /// The timeout duration in milliseconds.
    /// </param>
    procedure SetSendTimeOut(const Value: Integer);
    /// <summary>
    /// Retrieves the send timeout value.
    /// </summary>
    /// <returns>
    /// The send timeout duration in milliseconds.
    /// </returns>
    function GetSendTimeOut: Integer;
    /// <summary>
    /// Retrieves the connection timeout value.
    /// </summary>
    /// <returns>
    /// The connection timeout duration in milliseconds.
    /// </returns>
    function GetConnectionTimeout: Integer;
    /// <summary>
    /// Sets the connection timeout for HTTP requests.
    /// </summary>
    /// <param name="Value">
    /// The timeout duration in milliseconds.
    /// </param>
    procedure SetConnectionTimeout(const Value: Integer);
    /// <summary>
    /// Retrieves the response timeout value.
    /// </summary>
    /// <returns>
    /// The response timeout duration in milliseconds.
    /// </returns>
    function GetResponseTimeout: Integer;
    /// <summary>
    /// Sets the response timeout for HTTP requests.
    /// </summary>
    /// <param name="Value">
    /// The timeout duration in milliseconds.
    /// </param>
    procedure SetResponseTimeout(const Value: Integer);
    /// <summary>
    /// Retrieves the current proxy settings.
    /// </summary>
    /// <returns>
    /// An instance of <c>TProxySettings</c> representing the proxy configuration.
    /// </returns>
    function GetProxySettings: TProxySettings;
    /// <summary>
    /// Sets the proxy settings for HTTP requests.
    /// </summary>
    /// <param name="Value">
    /// An instance of <c>TProxySettings</c> representing the desired proxy configuration.
    /// </param>
    procedure SetProxySettings(const Value: TProxySettings);
    /// <summary>
    /// The send timeout duration in milliseconds.
    /// </summary>
    /// <remarks>
    /// Defines how long the HTTP client will wait while sending a request before timing out.
    /// </remarks>
    property SendTimeOut: Integer read GetSendTimeOut write SetSendTimeOut;
    /// <summary>
    /// The connection timeout duration in milliseconds.
    /// </summary>
    /// <remarks>
    /// Defines how long the HTTP client will wait while establishing a connection before timing out.
    /// </remarks>
    property ConnectionTimeout: Integer read GetConnectionTimeout write SetConnectionTimeout;
    /// <summary>
    /// The response timeout duration in milliseconds.
    /// </summary>
    /// <remarks>
    /// Defines how long the HTTP client will wait for a response after a request has been sent before timing out.
    /// </remarks>
    property ResponseTimeout: Integer read GetResponseTimeout write SetResponseTimeout;
    /// <summary>
    /// The proxy settings for HTTP requests.
    /// </summary>
    /// <remarks>
    /// Configures the HTTP client to route requests through a specified proxy server.
    /// This is useful in environments where direct internet access is restricted.
    /// </remarks>
    property ProxySettings: TProxySettings read GetProxySettings write SetProxySettings;
  end;

  /// <summary>
  /// Interface for performing HTTP operations such as GET, POST, DELETE, and PATCH.
  /// </summary>
  /// <remarks>
  /// Extends <c>IHttpClientParam</c> to include methods for executing various HTTP requests,
  /// allowing for flexible and configurable API interactions.
  /// Implementers should provide concrete implementations for these methods to handle
  /// the specifics of making HTTP requests and processing responses.
  /// </remarks>
  IHttpClientAPI = interface(IHttpClientParam)
    ['{44B995E3-8667-4A3C-9BAA-7A18A0A851B0}']
    /// <summary>
    /// Sends an HTTP GET request to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the GET request to.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Get(const URL: string; Response: TStringStream; const Headers: TNetHeaders): Integer; overload;
    /// <summary>
    /// Sends an HTTP GET request to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the GET request to.
    /// </param>
    /// <param name="Response">
    /// A stream to capture the binary response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Get(const URL: string; const Response: TStream; const Headers: TNetHeaders): Integer; overload;
    /// <summary>
    /// Sends an HTTP DELETE request to the specified URL.
    /// </summary>
    /// <param name="Path">
    /// The endpoint URL to send the DELETE request to.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Delete(const Path: string; Response: TStringStream; const Headers: TNetHeaders): Integer;
    /// <summary>
    /// Sends an HTTP POST request to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the POST request to.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Post(const URL: string; Response: TStringStream; const Headers: TNetHeaders): Integer; overload;
    /// <summary>
    /// Sends an HTTP POST request with multipart form data to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the POST request to.
    /// </param>
    /// <param name="Body">
    /// The multipart form data to include in the POST request.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Post(const URL: string; Body: TMultipartFormData; Response: TStringStream; const Headers: TNetHeaders): Integer; overload;
    /// <summary>
    /// Sends an HTTP POST request with a JSON body to the specified URL and handles streamed responses.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the POST request to.
    /// </param>
    /// <param name="Body">
    /// The JSON object to include in the POST request body.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <param name="OnReceiveData">
    /// A callback procedure to handle data as it is received during the streaming process.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Post(const URL: string; Body: TJSONObject; Response: TStringStream; const Headers: TNetHeaders; OnReceiveData: TReceiveDataCallback): Integer; overload;
    /// <summary>
    /// Sends an HTTP PATCH request with a JSON body to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the PATCH request to.
    /// </param>
    /// <param name="Body">
    /// The JSON object to include in the PATCH request body.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Patch(const URL: string; Body: TJSONObject; Response: TStringStream; const Headers: TNetHeaders): Integer;
  end;

implementation

end.

unit Deepseek.HttpClient;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiDeepseek
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Net.HttpClient, System.Net.URLClient,
  System.Net.Mime, System.JSON, System.NetConsts, Deepseek.API.Params, Deepseek.HttpClient.Intf;

type
/// <summary>
  /// Provides an implementation of the <c>IHttpClientAPI</c> interface using Delphi's <c>THTTPClient</c>.
  /// </summary>
  /// <remarks>
  /// This class facilitates making HTTP requests such as GET, POST, DELETE, and PATCH
  /// by wrapping Delphi's <c>THTTPClient</c> and adhering to the <c>IHttpClientAPI</c> interface.
  /// It supports setting timeouts, proxy configurations, and handling response callbacks.
  /// </remarks>
  THttpClientAPI = class(TInterfacedObject, IHttpClientAPI)
  private
    FHttpClient: THttpClient;
    FCheckSettingsProc: TProc;
    procedure SetSendTimeOut(const Value: Integer);
    function GetSendTimeOut: Integer;
    function GetConnectionTimeout: Integer;
    procedure SetConnectionTimeout(const Value: Integer);
    function GetResponseTimeout: Integer;
    procedure SetResponseTimeout(const Value: Integer);
    function GetProxySettings: TProxySettings;
    procedure SetProxySettings(const Value: TProxySettings);
    procedure CheckAPISettings; virtual;
  public
    /// <summary>
    /// Sends an HTTP GET request to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the GET request to.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Get(const URL: string; Response: TStringStream; const Headers: TNetHeaders): Integer; overload;
    /// <summary>
    /// Sends an HTTP GET request to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the GET request to.
    /// </param>
    /// <param name="Response">
    /// A stream to capture the binary response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Get(const URL: string; const Response: TStream; const Headers: TNetHeaders): Integer; overload;
    /// <summary>
    /// Sends an HTTP DELETE request to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the DELETE request to.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Delete(const URL: string; Response: TStringStream; const Headers: TNetHeaders): Integer;
    /// <summary>
    /// Sends an HTTP POST request to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the POST request to.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Post(const URL: string; Response: TStringStream; const Headers: TNetHeaders): Integer; overload;
    /// <summary>
    /// Sends an HTTP POST request with multipart form data to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the POST request to.
    /// </param>
    /// <param name="Body">
    /// The multipart form data to include in the POST request.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Post(const URL: string; Body: TMultipartFormData; Response: TStringStream; const Headers: TNetHeaders): Integer; overload;
    /// <summary>
    /// Sends an HTTP POST request with a JSON body to the specified URL and handles streamed responses.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the POST request to.
    /// </param>
    /// <param name="Body">
    /// The JSON object to include in the POST request body.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <param name="OnReceiveData">
    /// A callback procedure to handle data as it is received during the streaming process.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Post(const URL: string; Body: TJSONObject; Response: TStringStream; const Headers: TNetHeaders; OnReceiveData: TReceiveDataCallback): Integer; overload;
    /// <summary>
    /// Sends an HTTP PATCH request with a JSON body to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the PATCH request to.
    /// </param>
    /// <param name="Body">
    /// The JSON object to include in the PATCH request body.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Patch(const URL: string; Body: TJSONObject; Response: TStringStream; const Headers: TNetHeaders): Integer; overload;
    /// <summary>
    /// Initializes a new instance of the <c>THttpClientAPI</c> class.
    /// </summary>
    /// <param name="CheckProc">
    /// A callback procedure to verify API settings before each request.
    /// </param>
    constructor Create(const CheckProc: TProc); overload;
    /// <summary>
    /// Creates and returns an instance of <c>IHttpClientAPI</c>.
    /// </summary>
    /// <param name="CheckProc">
    /// A callback procedure to verify API settings before each request.
    /// </param>
    /// <returns>
    /// An instance implementing the <c>IHttpClientAPI</c> interface.
    /// </returns>
    class function CreateInstance(const CheckProc: TProc): IHttpClientAPI; overload;
    destructor Destroy; override;
  end;

implementation

{ THttpClientAPI }

procedure THttpClientAPI.CheckAPISettings;
begin
  if Assigned(FCheckSettingsProc) then
    FCheckSettingsProc;
end;

constructor THttpClientAPI.Create(const CheckProc: TProc);
begin
  inherited Create;
  FHttpClient := THTTPClient.Create;
  FHttpClient.AcceptCharSet := 'utf-8';
  FCheckSettingsProc := CheckProc;
end;

class function THttpClientAPI.CreateInstance(
  const CheckProc: TProc): IHttpClientAPI;
begin
  Result := THttpClientAPI.Create(CheckProc);
end;

function THttpClientAPI.Delete(const URL: string;
  Response: TStringStream; const Headers: TNetHeaders): Integer;
begin
  CheckAPISettings;
  Result := FHttpClient.Delete(URL, Response, Headers).StatusCode;
end;

destructor THttpClientAPI.Destroy;
begin
  FHttpClient.Free;
  inherited;
end;

function THttpClientAPI.Get(const URL: string; const Response: TStream;
  const Headers: TNetHeaders): Integer;
begin
  CheckAPISettings;
  Result := FHttpClient.Get(URL, Response, Headers).StatusCode;
end;

function THttpClientAPI.GetConnectionTimeout: Integer;
begin
  Result := FHttpClient.ConnectionTimeout;
end;

function THttpClientAPI.GetProxySettings: TProxySettings;
begin
  Result := FHttpClient.ProxySettings;
end;

function THttpClientAPI.GetResponseTimeout: Integer;
begin
  Result := FHttpClient.ResponseTimeout;
end;

function THttpClientAPI.GetSendTimeOut: Integer;
begin
  Result := FHttpClient.SendTimeout;
end;

function THttpClientAPI.Get(const URL: string;
  Response: TStringStream; const Headers: TNetHeaders): Integer;
begin
  CheckAPISettings;
  Result := FHttpClient.Get(URL, Response, Headers).StatusCode;
end;

function THttpClientAPI.Patch(const URL: string; Body: TJSONObject;
  Response: TStringStream; const Headers: TNetHeaders): Integer;
begin
  CheckAPISettings;
  var Stream := TStringStream.Create;
  try
    Stream.WriteString(Body.ToJSON);
    Stream.Position := 0;
    Result := FHttpClient.Patch(URL, Stream, Response, Headers).StatusCode;
  finally
    Stream.Free;
  end;
end;

function THttpClientAPI.Post(const URL: string; Body: TJSONObject;
  Response: TStringStream; const Headers: TNetHeaders;
  OnReceiveData: TReceiveDataCallback): Integer;
begin
  CheckAPISettings;
  var Stream := TStringStream.Create;
  FHttpClient.ReceiveDataCallBack := OnReceiveData;
  try
    Stream.WriteString(Body.ToJSON);
    Stream.Position := 0;
    Result := FHttpClient.Post(URL, Stream, Response, Headers).StatusCode;
  finally
    FHttpClient.ReceiveDataCallBack := nil;
    Stream.Free;
  end;
end;

procedure THttpClientAPI.SetConnectionTimeout(const Value: Integer);
begin
  FHttpClient.ConnectionTimeout := Value;
end;

procedure THttpClientAPI.SetProxySettings(const Value: TProxySettings);
begin
  FHttpClient.ProxySettings := Value;
end;

procedure THttpClientAPI.SetResponseTimeout(const Value: Integer);
begin
  FHttpClient.ResponseTimeout := Value;
end;

procedure THttpClientAPI.SetSendTimeOut(const Value: Integer);
begin
  FHttpClient.SendTimeout := Value;
end;

function THttpClientAPI.Post(const URL: string; Body: TMultipartFormData;
  Response: TStringStream; const Headers: TNetHeaders): Integer;
begin
  CheckAPISettings;
  Result := FHttpClient.Post(URL, Body, Response, Headers).StatusCode;
end;

function THttpClientAPI.Post(const URL: string; Response: TStringStream;
  const Headers: TNetHeaders): Integer;
begin
  CheckAPISettings;
  var Stream: TStringStream := nil;
  Result := FHttpClient.Post(URL, Stream, Response, Headers).StatusCode;
end;

end.

unit Deepseek.Models;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiDeepseek
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, System.Threading,
  REST.Json.Types, Deepseek.API.Params, Deepseek.API, Deepseek.Async.Support;

type
  /// <summary>
  /// The <c>TModel</c> class represents a model entity retrieved from the Deepseek API.
  /// It encapsulates basic information about the model, including its unique identifier,
  /// object type, and ownership details.
  /// </summary>
  /// <remarks>
  /// This class is designed to be used as part of the Deepseek framework for API integrations.
  /// Instances of <c>TModel</c> are typically created as a result of API calls
  /// and provide detailed information about individual models available within the system.
  /// Key properties include <c>Id</c>, which identifies the model uniquely,
  /// <c>Object</c>, which specifies the type of the object, and <c>OwnedBy</c>,
  /// indicating the organ
  TModel = class(TJSONFingerprint)
  private
    FId: string;
    FObject: string;
    [JsonNameAttribute('owned_by')]
    FOwnedBy: string;
  public
    /// <summary>
    /// The model identifier, which can be referenced in the API endpoints.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// The object type, which is always "model".
    /// </summary>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// The organization that owns the model.
    /// </summary>
    property OwnedBy: string read FOwnedBy write FOwnedBy;
  end;

  /// <summary>
  /// The <c>TModels</c> class represents a collection of model entities retrieved from the Deepseek API.
  /// It provides information about the collection as a whole and an array of individual models.
  /// </summary>
  /// <remarks>
  /// This class is used to handle the response from API endpoints that return a list of models.
  /// The <c>Object</c> property indicates the type of the object, typically set to "list",
  /// while the <c>Data</c> property contains an array of <c>TModel</c> instances representing each model in the collection.
  /// Instances of this class are created as a result of API calls to list available models.
  /// </remarks>
  TModels = class(TJSONFingerprint)
  private
    FObject: string;
    FData: TArray<TModel>;
  public
    /// <summary>
    /// Possible values: [list].
    /// </summary>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// An array with each model.
    /// </summary>
    property Data: TArray<TModel> read FData write FData;
    /// <summary>
    /// Destructor to clean up resources used by the <c>TChatChoices</c> instance.
    /// </summary>
    destructor Destroy; override;
  end;

  /// <summary>
  /// The <c>TModelsRoute</c> class provides methods for interacting with the Deepseek API
  /// to retrieve and manage models. It offers both synchronous and asynchronous operations
  /// for listing and retrieving individual models.
  /// </summary>
  /// <remarks>
  /// This class serves as a high-level interface for accessing model-related API endpoints.
  /// It extends the <c>TDeepseekAPIRoute</c> class, inheriting base functionalities
  /// while adding methods specific to model operations.
  /// <para>
  /// Key functionalities include:
  /// <list type="bullet">
  /// <item><description>Listing all available models using <c>List</c> and <c>AsynList</c> methods.</description></item>
  /// <item><description>Retrieving details of a specific model by its ID using <c>Retrieve</c> and <c>AsynRetrieve</c> methods.</description></item>
  /// </list>
  /// </para>
  /// <para>
  /// Asynchronous methods (<c>AsynList</c> and <c>AsynRetrieve</c>) allow the application
  /// to handle API responses in a non-blocking manner, suitable for UI-intensive scenarios.
  /// Synchronous methods (<c>List</c> and <c>Retrieve</c>) block execution until the API response is received.
  /// </para>
  /// </remarks>
  TAsynModel = TAsynCallBack<TModel>;

  /// <summary>
  /// The <c>TAsynModels</c> class is a type alias used to handle asynchronous callbacks for batch processing.
  /// It provides support for executing batch operations asynchronously and processing the results upon completion.
  /// </summary>
  /// <remarks>
  /// This class is part of the asynchronous framework that allows non-blocking batch operations.
  /// It uses a callback mechanism to return the result of a batch process once it is completed.
  /// </remarks>
  TAsynModels = TAsynCallBack<TModels>;

  /// <summary>
  /// The <c>TModelsRoute</c> class provides methods for interacting with the Deepseek API
  /// to retrieve and manage models. It offers both synchronous and asynchronous operations
  /// for listing models.
  /// </summary>
  /// <remarks>
  /// This class serves as a high-level interface for accessing model-related API endpoints.
  /// It extends the <c>TDeepseekAPIRoute</c> class, inheriting base functionalities
  /// while adding methods specific to model operations.
  /// </remarks>
  TModelsRoute = class(TDeepseekAPIRoute)
    /// <summary>
    /// List available models.
    /// The Models API response can be used to determine which models are available for use in the API.
    /// </summary>
    /// <param name="CallBacks">
    /// A function that returns <c>TAsynModels</c> to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// <para>
    /// The <c>CallBacks</c> function is invoked when the operation completes, either successfully or
    /// with an error.
    /// </para>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var DeepSeek := TDeepseekFactory.CreateInstance(BarearKey);
    /// DeepSeek.Models.AsynList(
    ///   function : TAsynModels
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TModels)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsynList(CallBacks: TFunc<TAsynModels>);
    /// <summary>
    /// List available models.
    /// The Models API response can be used to determine which models are available for use in the API.
    /// </summary>
    /// <returns>
    /// A <c>TModels</c> object containing the list of models.
    /// </returns>
    /// <remarks>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var DeepSeek := TDeepseekFactory.CreateInstance(BarearKey);
    /// var Value := DeepSeek.Models.List;
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    function List: TModels;
  end;

implementation

{ TModels }

destructor TModels.Destroy;
begin
  for var Item in FData do
    Item.Free;
  inherited;
end;

{ TModelsRoute }

procedure TModelsRoute.AsynList(CallBacks: TFunc<TAsynModels>);
begin
  with TAsynCallBackExec<TAsynModels, TModels>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TModels
      begin
        Result := Self.List;
      end);
  finally
    Free;
  end;
end;

function TModelsRoute.List: TModels;
begin
  Result := API.Get<TModels>('models');
end;

end.

unit Deepseek.Monitoring;

interface

uses
  System.SysUtils, System.Classes, System.Generics.Collections, System.SyncObjs;

type
  /// <summary>
  /// Interface for monitoring request counts in a thread-safe manner.
  /// </summary>
  /// <remarks>
  /// This interface defines methods to increment and decrement a request counter,
  /// as well as a method to check if any requests are currently being processed.
  /// </remarks>
  IRequestMonitor = interface
    ['{2A96CB07-144B-4CC6-9FC4-ABBBE9F3BDBF}']
    /// <summary>
    /// Increments the request counter.
    /// </summary>
    /// <returns>
    /// The updated number of active requests.
    /// </returns>
    function Inc: Integer;
    /// <summary>
    /// Decrements the request counter.
    /// </summary>
    /// <returns>
    /// The updated number of active requests.
    /// </returns>
    function Dec: Integer;
    /// <summary>
    /// Checks if there are active requests being processed.
    /// </summary>
    /// <returns>
    /// <c>True</c> if there are active requests, otherwise <c>False</c>.
    /// </returns>
    function IsBusy: Boolean;
  end;

  /// <summary>
  /// Implements a thread-safe request monitor.
  /// </summary>
  /// <remarks>
  /// This class provides synchronized methods to track the number of active requests.
  /// It ensures thread safety using a critical section.
  /// </remarks>
  TRequestMonitor = class(TInterfacedObject, IRequestMonitor)
  private
    FLock: TCriticalSection;
    FCount: Integer;
  public
    constructor Create;
    destructor Destroy; override;
    /// <summary>
    /// Increments the request counter in a thread-safe manner.
    /// </summary>
    /// <returns>
    /// The updated number of active requests.
    /// </returns>
    function Inc: Integer;
    /// <summary>
    /// Decrements the request counter in a thread-safe manner.
    /// </summary>
    /// <returns>
    /// The updated number of active requests.
    /// </returns>
    function Dec: Integer;
    /// <summary>
    /// Checks if there are any active requests.
    /// </summary>
    /// <returns>
    /// <c>True</c> if there are active requests, otherwise <c>False</c>.
    /// </returns>
    function IsBusy: Boolean;
  end;

var
  Monitoring: IRequestMonitor;

implementation

{ TRequestMonitor }

constructor TRequestMonitor.Create;
begin
  inherited Create;
  FLock := TCriticalSection.Create;
  FCount := 0;
end;

function TRequestMonitor.Dec: Integer;
begin
  FLock.Enter;
  try
    if FCount > 0 then
      System.Dec(FCount);
    Result := FCount;
  finally
    FLock.Leave;
  end;
end;

destructor TRequestMonitor.Destroy;
begin
  FLock.Free;
  inherited;
end;

function TRequestMonitor.Inc: Integer;
begin
  FLock.Enter;
  try
    System.Inc(FCount);
    Result := FCount;
  finally
    FLock.Leave;
  end;
end;

function TRequestMonitor.IsBusy: Boolean;
begin
  FLock.Enter;
  try
    Result := FCount > 0;
  finally
    FLock.Leave;
  end;
end;

initialization
  Monitoring := TRequestMonitor.Create;
end.

unit Deepseek;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiDeepseek
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Net.URLClient, Deepseek.API, Deepseek.API.Params,
  Deepseek.Models, Deepseek.Chat, Deepseek.FIM, Deepseek.User, Deepseek.Functions.Core,
  Deepseek.HttpClient.Intf, Deepseek.HttpClient, Deepseek.Monitoring, Deepseek.API.Parallel;

type
  /// <summary>
  /// The <c>IDeepseek</c> interface provides access to the various features and routes of the Deepseek AI API.
  /// It serves as a comprehensive framework for automating natural language processing, vision tasks, and
  /// data retrieval workflows.
  /// </summary>
  /// <remarks>
  /// This interface should be implemented by any class that wants to provide a structured way of accessing
  /// the Deepseek AI services. It includes methods and properties for authenticating with an API key,
  /// configuring the base URL, and accessing different API routes.
  /// </remarks>
  IDeepseek = interface
    ['{59A59450-F0CB-4FA3-8EF6-E8D0EB8A1118}']
    function GetAPI: TDeepseekAPI;
    procedure SetKey(const Value: string);
    function GetKey: string;
    function GetBaseUrl: string;
    procedure SetBaseUrl(const Value: string);
    function GetClientHttp: IHttpClientAPI;

    function GetChatRoute: TChatRoute;
    function GetFIMRoute: TFIMRoute;
    function GetModelsRoute: TModelsRoute;
    function GetUserRoute: TUserRoute;

    /// <summary>
    /// This class offers functionality for generating contextually appropriate responses within
    /// conversational frameworks.
    /// </summary>
    property Chat: TChatRoute read GetChatRoute;
    /// <summary>
    /// This class implements the FIM (Fill In the Middle) completion functionality, allowing users
    /// to generate content or code by providing a prefix and an optional suffix. FIM completion is
    /// particularly useful for cases where contextual insertion is required between two existing
    ///text segments.
    /// </summary>
    /// <remarks>
    /// Typical usage:
    /// <para>
    /// - Text completion: Generate missing content in a partially written document.
    /// </para>
    /// <para>
    /// - Code completion: Add code fragments in a given context (e.g., between existing code blocks).
    /// </para>
    /// </remarks>
    property FIM: TFIMRoute read GetFIMRoute;
    /// <summary>
    /// Provides methods for interacting with the Deepseek API to retrieve models.
    /// It offers both synchronous and asynchronous operations
    /// for listing and retrieving individual models.
    /// </summary>
    property Models: TModelsRoute read GetModelsRoute;
    /// <summary>
    /// This provides methods for user management including current balance.
    /// </summary>
    property User: TUserRoute read GetUserRoute;
    /// <summary>
    /// the main API object used for making requests.
    /// </summary>
    /// <returns>
    /// An instance of TDeepseekAPI for making API calls.
    /// </returns>
    property API: TDeepseekAPI read GetAPI;
    /// <summary>
    /// Sets or retrieves the API token for authentication.
    /// </summary>
    property Key: string read GetKey write SetKey;
    /// <summary>
    /// Sets or retrieves the base URL for API requests.
    /// Default is https://api.Deepseek.com/v1
    /// </summary>
    property BaseURL: string read GetBaseUrl write SetBaseUrl;
    /// <summary>
    /// The HTTP client interface used for making API calls.
    /// </summary>
    property ClientHttp: IHttpClientAPI read GetClientHttp;
  end;

  /// <summary>
  /// The <c>TDeepseekFactory</c> class is responsible for creating instances of
  /// the <see cref="IDeepseek"/> interface. It provides a factory method to instantiate
  /// the interface with a provided API token and optional header configuration.
  /// </summary>
  /// <remarks>
  /// This class provides a convenient way to initialize the <see cref="IDeepseek"/> interface
  /// by encapsulating the necessary configuration details, such as the API token and header options.
  /// By using the factory method, users can quickly create instances of <see cref="IDeepseek"/> without
  /// manually setting up the implementation details.
  /// </remarks>
  TDeepseekFactory = class
    /// <summary>
    /// Creates an instance of the <see cref="IDeepseek"/> interface with the specified API token
    /// and optional header configuration.
    /// </summary>
    /// <param name="AToken">
    /// The API token as a string, required for authenticating with Deepseek API services.
    /// </param>
    /// <returns>
    /// An instance of <see cref="IDeepseek"/> initialized with the provided API token and header option.
    /// </returns>
    /// <remarks>
    /// Code example
    /// <code>
    /// var Deepseek := TDeepseekFactory.CreateInstance(BaererKey);
    /// </code>
    /// WARNING : Please take care to adjust the SCOPE of the <c>DeepseekCloud</c> interface in you application.
    /// </remarks>
    class function CreateInstance(const AToken: string): IDeepseek;
    /// <summary>
    /// Creates an instance of the <c>IDeepseek</c> interface with the specified API token.
    /// <para>
    /// The base url for the beta instance : https://api.deepseek.com/beta
    /// </para>
    /// </summary>
    /// <param name="AToken">
    /// The API token as a string, required for authenticating with Deepseek API services.
    /// </param>
    /// <returns>
    /// An instance of <see cref="IDeepseek"/> initialized with the provided API token and header option.
    /// </returns>
    /// <remarks>
    /// Code example
    /// <code>
    /// var DeepseekBeta := TDeepseekFactory.CreateBetaInstance(BaererKey);
    /// </code>
    /// WARNING : Please take care to adjust the SCOPE of the <c>DeepseekCloud</c> interface in you application.
    /// </remarks>
    class function CreateBetaInstance(const AToken: string): IDeepseek;
  end;

  /// <summary>
  /// The TDeepseek class provides access to the various features and routes of the Deepseek AI API.
  /// It serves as a comprehensive framework for automating natural language processing, vision tasks, and data retrieval workflows.
  /// </summary>
  /// <remarks>
  /// This class should be implemented by any class that wants to provide a structured way of accessing
  /// the Deepseek AI services. It includes methods and properties for authenticating with an API key,
  /// configuring the base URL, and accessing different API routes.
  /// <seealso cref="TDeepseek"/>
  /// </remarks>
  TDeepseek = class(TInterfacedObject, IDeepseek)
  strict private

  private
    FAPI: TDeepseekAPI;
    FChatRoute: TChatRoute;
    FModelsRoute: TModelsRoute;
    FFIMRoute: TFIMRoute;
    FUserRoute: TUserRoute;

    function GetAPI: TDeepseekAPI;
    function GetKey: string;
    procedure SetKey(const Value: string);
    function GetBaseUrl: string;
    procedure SetBaseUrl(const Value: string);
    function GetClientHttp: IHttpClientAPI;

    function GetChatRoute: TChatRoute;
    function GetFIMRoute: TFIMRoute;
    function GetModelsRoute: TModelsRoute;
    function GetUserRoute: TUserRoute;

  public
    /// <summary>
    /// This class offers functionality for generating contextually appropriate responses within
    /// conversational frameworks.
    /// </summary>
    property Chat: TChatRoute read GetChatRoute;
    /// <summary>
    /// Provides methods for interacting with the Deepseek API to retrieve models.
    /// It offers both synchronous and asynchronous operations
    /// for listing and retrieving individual models.
    /// </summary>
    /// <summary>
    /// This class implements the FIM (Fill In the Middle) completion functionality, allowing users
    /// to generate content or code by providing a prefix and an optional suffix. FIM completion is
    /// particularly useful for cases where contextual insertion is required between two existing
    ///text segments.
    /// </summary>
    /// <remarks>
    /// Typical usage:
    /// <para>
    /// - Text completion: Generate missing content in a partially written document.
    /// </para>
    /// <para>
    /// - Code completion: Add code fragments in a given context (e.g., between existing code blocks).
    /// </para>
    /// </remarks>
    property FIM: TFIMRoute read GetFIMRoute;
    /// <summary>
    /// Provides methods for interacting with the Deepseek API to retrieve models.
    /// It offers both synchronous and asynchronous operations
    /// for listing and retrieving individual models.
    /// </summary>
    property Models: TModelsRoute read GetModelsRoute;
    /// <summary>
    /// This provides methods for user management including current balance.
    /// </summary>
    property User: TUserRoute read GetUserRoute;
    /// <summary>
    /// the main API object used for making requests.
    /// </summary>
    /// <returns>
    /// An instance of TDeepseekAPI for making API calls.
    /// </returns>
    /// <summary>
    /// the main API object used for making requests.
    /// </summary>
    /// <returns>
    /// An instance of TDeepseekAPI for making API calls.
    /// </returns>
    property API: TDeepseekAPI read GetAPI;
    /// <summary>
    /// Sets or retrieves the API token for authentication.
    /// </summary>
    /// <param name="Value">
    /// The API token as a string.
    /// </param>
    /// <returns>
    /// The current API token.
    /// </returns>
    property Token: string read GetKey write SetKey;
    /// <summary>
    /// Sets or retrieves the base URL for API requests.
    /// Default is https://api.stability.ai
    /// </summary>
    /// <param name="Value">
    /// The base URL as a string.
    /// </param>
    /// <returns>
    /// The current base URL.
    /// </returns>
    property BaseURL: string read GetBaseUrl write SetBaseUrl;

  public
    /// <summary>
    /// Initializes a new instance of the <see cref="TDeepseek"/> class with optional header configuration.
    /// </summary>
    /// <param name="Option">
    /// An optional parameter of type <see cref="THeaderOption"/> to configure the request headers.
    /// The default value is <c>THeaderOption.none</c>.
    /// </param>
    /// <remarks>
    /// This constructor is typically used when no API token is provided initially.
    /// The token can be set later via the <see cref="Token"/> property.
    /// </remarks>
    constructor Create; overload;
    /// <summary>
    /// Initializes a new instance of the <see cref="TDeepseek"/> class with the provided API token and optional header configuration.
    /// </summary>
    /// <param name="AToken">
    /// The API token as a string, required for authenticating with the Deepseek AI API.
    /// </param>
    /// <param name="Option">
    /// An optional parameter of type <see cref="THeaderOption"/> to configure the request headers.
    /// The default value is <c>THeaderOption.none</c>.
    /// </param>
    /// <remarks>
    /// This constructor allows the user to specify an API token at the time of initialization.
    /// </remarks>
    constructor Create(const AToken: string); overload;
    /// <summary>
    /// Releases all resources used by the current instance of the <see cref="TDeepseek"/> class.
    /// </summary>
    /// <remarks>
    /// This method is called to clean up any resources before the object is destroyed.
    /// It overrides the base <see cref="TInterfacedObject.Destroy"/> method.
    /// </remarks>
    destructor Destroy; override;
  end;

  {$REGION 'Deepseek.Chat'}

  /// <summary>
  /// Messages comprising the conversation so far.
  /// </summary>
  TContentParams = Deepseek.Chat.TContentParams;

  /// <summary>
  /// The <c>TChatParams</c> class represents the set of parameters used to configure a chat interaction with an AI model.
  /// </summary>
  /// <remarks>
  /// This class allows you to define various settings that control how the model behaves, including which model to use, how many tokens to generate,
  /// what kind of messages to send, and how the model should handle its output. By using this class, you can fine-tune the AI's behavior and response format
  /// based on your application's specific needs.
  /// <para>
  /// It inherits from <c>TJSONParam</c>, which provides methods for handling and serializing the parameters as JSON, allowing seamless integration
  /// with JSON-based APIs.
  /// </para>
  /// <code>
  /// var
  ///   Params: TChatParams;
  /// begin
  ///   Params := TChatParams.Create
  ///     .Model('my_model')
  ///     .MaxTokens(100)
  ///     .Messages([TChatMessagePayload.User('Hello!')])
  ///     .ResponseFormat('json_object')
  ///     .Temperature(0.7)
  ///     .TopP(1)
  ///     .SafePrompt(True);
  /// end;
  /// </code>
  /// This example shows how to instantiate and configure a <c>TChatParams</c> object for interacting with an AI model.
  /// </remarks>
  TChatParams = Deepseek.Chat.TChatParams;

  /// <summary>
  /// Represents the specifics of a called function, including its name and calculated arguments.
  /// </summary>
  TFunction = Deepseek.Chat.TFunction;

  /// <summary>
  /// Represents a called function, containing its specifics such as name and arguments.
  /// </summary>
  TToolCalls = Deepseek.Chat.TToolCalls;

  /// <summary>
  /// Represents a chat message exchanged between participants (user, assistant, or system) in a conversation.
  /// </summary>
  /// <remarks>
  /// The <c>TChoiceMessage</c> class encapsulates the essential information of a message within a chat application, including:
  /// <para>
  /// - The role of the sender (user, assistant, or system).
  /// </para>
  /// <para>
  /// - The content of the message itself.
  /// </para>
  /// <para>
  /// - Optionally, a list of tool calls that may be required to complete the message response.
  /// </para>
  /// This class is fundamental for managing the flow of a conversation, allowing the system to track who said what and what actions need to be taken.
  /// </remarks>
  TChoiceMessage = Deepseek.Chat.TChoiceMessage;

  /// <summary>
  /// Represents the top log probabilities of tokens in a model's output.
  /// </summary>
  /// <remarks>
  /// The <c>TTopLogprobs</c> class is used to encapsulate detailed information
  /// about the probabilities of the most likely tokens at a specific position
  /// during the generation of a model's output.
  /// <para>
  /// This class is useful for analyzing and debugging the behavior of language
  /// models by providing a deeper insight into the decision-making process at
  /// the token level.
  /// </para>
  /// <para>
  /// It includes the token, its log probability, and its byte representation
  /// in UTF-8 format, making it an essential tool for advanced token-level
  /// evaluations.
  /// </para>
  /// </remarks>
  TTopLogprobs = Deepseek.Chat.TTopLogprobs;

  /// <summary>
  /// Represents detailed log probability information for a specific token.
  /// </summary>
  /// <remarks>
  /// The <c>TLogprobContent</c> class provides a comprehensive structure for storing
  /// and analyzing the log probabilities of tokens generated by a model.
  /// It includes:
  /// <para>- The token itself.</para>
  /// <para>- The log probability of the token.</para>
  /// <para>- The UTF-8 byte representation of the token, when applicable.</para>
  /// <para>- A list of the most likely tokens and their log probabilities at this position,
  /// represented by <c>TTopLogprobs</c>.</para>
  /// <para>
  /// This class is particularly useful in tasks requiring token-level analysis,
  /// such as understanding model decisions, debugging outputs, or assessing
  /// the confidence of specific token choices.
  /// </para>
  /// </remarks>
  TLogprobContent = Deepseek.Chat.TLogprobContent;

  /// <summary>
  /// Represents the aggregated log probability information for a choice's output.
  /// </summary>
  /// <remarks>
  /// The <c>TLogprobs</c> class provides a structured way to encapsulate
  /// log probability data for tokens generated during a model's output.
  /// It consists of a collection of <c>TLogprobContent</c> instances,
  /// each representing detailed information for a single token.
  /// <para>
  /// This class is essential for advanced token-level analysis, allowing developers
  /// to assess the confidence of a model's predictions and understand the
  /// distribution of token probabilities across an entire response.
  /// </para>
  /// </remarks>
  TLogprobs = Deepseek.Chat.TLogprobs;

  /// <summary>
  /// Represents incremental updates to a chat message during streaming responses.
  /// </summary>
  /// <remarks>
  /// The <c>TDelta</c> class provides a structure to encapsulate partial or
  /// incremental updates to a chat message during streaming interactions
  /// with an AI model. It includes:
  /// <para>- The content of the partial message.</para>
  /// <para>- The role of the author of the message (e.g., user, assistant, or system).</para>
  /// <para>
  /// - This class is particularly useful for real-time applications where responses
  /// are streamed as they are generated, allowing for dynamic updates to the
  /// conversation interface.
  /// </para>
  /// <para>
  /// - Does not allow handling function calls during SSE processing.
  /// </para>
  /// </remarks>
  TDelta = Deepseek.Chat.TDelta;

  /// <summary>
  /// Represents a single completion option generated by the AI model during a chat interaction.
  /// </summary>
  /// <remarks>
  /// The <c>TChatChoice</c> class stores the results of the AI model's response to a user prompt. Each instance of this class represents one of potentially
  /// many choices that the model could return. This includes:
  /// <para>
  /// - The finish reason.
  /// </para>
  /// <para>
  /// - An index identifying the choice.
  /// </para>
  /// <para>
  /// - A message generated by the model.
  /// </para>
  /// <para>
  /// - Optional deltas for streamed responses.
  /// </para>
  /// <para>
  /// - The reason the model stopped generating tokens.
  /// </para>
  /// This class is useful when multiple potential responses are generated and evaluated, or when streaming responses incrementally.
  /// </remarks>
  TChatChoice = Deepseek.Chat.TChatChoice;

  /// <summary>
  /// Represents the token usage statistics for a chat interaction, including the number of tokens
  /// used in the prompt, the completion, and the total number of tokens consumed.
  /// </summary>
  /// <remarks>
  /// The <c>TChatUsage</c> class provides insight into the number of tokens used during a chat interaction.
  /// This information is critical for understanding the cost of a request when using token-based billing systems
  /// or for monitoring the model's behavior in terms of input (prompt) and output (completion) size.
  /// </remarks>
  TUsage = Deepseek.Chat.TUsage;

  /// <summary>
  /// Represents a chat completion response generated by an AI model, containing the necessary metadata,
  /// the generated choices, and usage statistics.
  /// </summary>
  /// <remarks>
  /// The <c>TChat</c> class encapsulates the results of a chat request made to an AI model.
  /// It contains details such as a unique identifier, the model used, when the completion was created,
  /// the choices generated by the model, and token usage statistics.
  /// This class is crucial for managing the results of AI-driven conversations and understanding the
  /// underlying usage and response characteristics of the AI.
  /// </remarks>
  TChat = Deepseek.Chat.TChat;

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TChat</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynChat</c> type extends the <c>TAsynParams&lt;TChat&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynChat = Deepseek.Chat.TAsynChat;

  /// <summary>
  /// Manages asynchronous streaming chat callBacks for a chat request using <c>TChat</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynChatStream</c> type extends the <c>TAsynStreamParams&lt;TChat&gt;</c> record to support the lifecycle of an asynchronous streaming chat operation.
  /// It provides callbacks for different stages, including when the operation starts, progresses with new data chunks, completes successfully, or encounters an error.
  /// This structure is ideal for handling scenarios where the chat response is streamed incrementally, providing real-time updates to the user interface.
  /// </remarks>
  TAsynChatStream = Deepseek.Chat.TAsynChatStream;

  /// <summary>
  /// Represents a callback procedure used during the reception of responses from a chat request in streaming mode.
  /// </summary>
  /// <param name="Chat">
  /// The <c>TChat</c> object containing the current information about the response generated by the model.
  /// If this value is <c>nil</c>, it indicates that the data stream is complete.
  /// </param>
  /// <param name="IsDone">
  /// A boolean flag indicating whether the streaming process is complete.
  /// If <c>True</c>, it means the model has finished sending all response data.
  /// </param>
  /// <param name="Cancel">
  /// A boolean flag that can be set to <c>True</c> within the callback to cancel the streaming process.
  /// If set to <c>True</c>, the streaming will be terminated immediately.
  /// </param>
  /// <remarks>
  /// This callback is invoked multiple times during the reception of the response data from the model.
  /// It allows for real-time processing of received messages and interaction with the user interface or other systems
  /// based on the state of the data stream.
  /// When the <c>IsDone</c> parameter is <c>True</c>, it indicates that the model has finished responding,
  /// and the <c>Chat</c> parameter will be <c>nil</c>.
  /// </remarks>
  TChatEvent = Deepseek.Chat.TChatEvent;

  {$ENDREGION}

  {$REGION 'Deepseek.FIM'}

  /// <summary>
  /// Represents a parameter configuration class for the "FIM" model.
  /// </summary>
  /// <remarks>
  /// The <c>TFIMParams</c> class provides methods to set various parameters used for configuring
  /// and customizing requests to the "FIM" (Fill-In-the-Middle) AI model. This includes options
  /// such as the model identifier, prompt text, token limits, penalties, and other advanced settings.
  /// The methods in this class are chainable, allowing for streamlined parameter configuration.
  /// </remarks>
  TFIMParams = Deepseek.FIM.TFIMParams;

  /// <summary>
  /// Represents the top log probabilities for tokens generated by the model.
  /// </summary>
  /// <remarks>
  /// The <c>TFIMToplogprobs</c> class provides detailed information about the
  /// probabilities of tokens chosen by the model, including their text offsets
  /// and associated probabilities.
  /// </remarks>
  TFIMToplogprobs = Deepseek.FIM.TFIMToplogprobs;

  /// <summary>
  /// Represents the log probabilities of tokens generated by the model.
  /// </summary>
  /// <remarks>
  /// The <c>TFIMLogprobs</c> class stores detailed information about the probabilities of tokens
  /// generated during a completion request. It includes data such as the tokens themselves,
  /// their respective log probabilities, and the character offsets of each token in the response text.
  /// Additionally, it can provide detailed insights into the top alternative tokens and their probabilities
  /// at each generation step.
  /// </remarks>
  TFIMLogprobs = Deepseek.FIM.TFIMLogprobs;

  /// <summary>
  /// Represents a choice generated by the AI model in response to a completion request.
  /// </summary>
  /// <remarks>
  /// The <c>TFIMChoice</c> class contains details about a specific choice produced by the AI model,
  /// including the generated text, associated log probabilities, the index of the choice,
  /// and the reason why the model stopped generating further tokens.
  /// </remarks>
  TFIMChoice = Deepseek.FIM.TFIMChoice;

  /// <summary>
  /// Represents the main class for managing text completion responses.
  /// </summary>
  /// <remarks>
  /// The <c>TFIM</c> class encapsulates the details of a completion operation performed by an AI model.
  /// It includes properties such as the generated text choices, metadata about the completion, and usage statistics.
  /// This class is designed to work with the Deepseek API for handling text completions.
  /// </remarks>
  TFIM = Deepseek.FIM.TFIM;

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TFIM</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynFIM</c> type extends the <c>TAsynParams&lt;TFIM&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynFIM = Deepseek.FIM.TAsynFIM;

  /// <summary>
  /// Manages asynchronous streaming chat callBacks for a chat request using <c>TFIM</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynFIMStream</c> type extends the <c>TAsynStreamParams&lt;TFIM&gt;</c> record to support the lifecycle of an asynchronous streaming chat operation.
  /// It provides callbacks for different stages, including when the operation starts, progresses with new data chunks, completes successfully, or encounters an error.
  /// This structure is ideal for handling scenarios where the chat response is streamed incrementally, providing real-time updates to the user interface.
  /// </remarks>
  TAsynFIMStream = Deepseek.FIM.TAsynFIMStream;

  /// <summary>
  /// Represents a callback procedure used during the reception of responses from a chat request in streaming mode.
  /// </summary>
  /// <param name="FIM">
  /// The <c>TFIM</c> object containing the current information about the response generated by the model.
  /// If this value is <c>nil</c>, it indicates that the data stream is complete.
  /// </param>
  /// <param name="IsDone">
  /// A boolean flag indicating whether the streaming process is complete.
  /// If <c>True</c>, it means the model has finished sending all response data.
  /// </param>
  /// <param name="Cancel">
  /// A boolean flag that can be set to <c>True</c> within the callback to cancel the streaming process.
  /// If set to <c>True</c>, the streaming will be terminated immediately.
  /// </param>
  /// <remarks>
  /// This callback is invoked multiple times during the reception of the response data from the model.
  /// It allows for real-time processing of received messages and interaction with the user interface or other systems
  /// based on the state of the data stream.
  /// When the <c>IsDone</c> parameter is <c>True</c>, it indicates that the model has finished responding,
  /// and the <c>TFIM</c> parameter will be <c>nil</c>.
  /// </remarks>
  TFIMEvent = Deepseek.FIM.TFIMEvent;

  {$ENDREGION}

  {$REGION 'Deepseek.Models'}

  /// <summary>
  /// The <c>TModel</c> class represents a model entity retrieved from the Deepseek API.
  /// It encapsulates basic information about the model, including its unique identifier,
  /// object type, and ownership details.
  /// </summary>
  /// <remarks>
  /// This class is designed to be used as part of the Deepseek framework for API integrations.
  /// Instances of <c>TModel</c> are typically created as a result of API calls
  /// and provide detailed information about individual models available within the system.
  /// Key properties include <c>Id</c>, which identifies the model uniquely,
  /// <c>Object</c>, which specifies the type of the object, and <c>OwnedBy</c>,
  /// indicating the organ
  TModel = Deepseek.Models.TModel;

  /// <summary>
  /// The <c>TModels</c> class represents a collection of model entities retrieved from the Deepseek API.
  /// It provides information about the collection as a whole and an array of individual models.
  /// </summary>
  /// <remarks>
  /// This class is used to handle the response from API endpoints that return a list of models.
  /// The <c>Object</c> property indicates the type of the object, typically set to "list",
  /// while the <c>Data</c> property contains an array of <c>TModel</c> instances representing each model in the collection.
  /// Instances of this class are created as a result of API calls to list available models.
  /// </remarks>
  TModels = Deepseek.Models.TModels;

  /// <summary>
  /// The <c>TModelsRoute</c> class provides methods for interacting with the Deepseek API
  /// to retrieve and manage models. It offers both synchronous and asynchronous operations
  /// for listing and retrieving individual models.
  /// </summary>
  /// <remarks>
  /// This class serves as a high-level interface for accessing model-related API endpoints.
  /// It extends the <c>TDeepseekAPIRoute</c> class, inheriting base functionalities
  /// while adding methods specific to model operations.
  /// <para>
  /// Key functionalities include:
  /// <list type="bullet">
  /// <item><description>Listing all available models using <c>List</c> and <c>AsynList</c> methods.</description></item>
  /// <item><description>Retrieving details of a specific model by its ID using <c>Retrieve</c> and <c>AsynRetrieve</c> methods.</description></item>
  /// </list>
  /// </para>
  /// <para>
  /// Asynchronous methods (<c>AsynList</c> and <c>AsynRetrieve</c>) allow the application
  /// to handle API responses in a non-blocking manner, suitable for UI-intensive scenarios.
  /// Synchronous methods (<c>List</c> and <c>Retrieve</c>) block execution until the API response is received.
  /// </para>
  /// </remarks>
  TAsynModel = Deepseek.Models.TAsynModel;

  /// <summary>
  /// The <c>TAsynModels</c> class is a type alias used to handle asynchronous callbacks for batch processing.
  /// It provides support for executing batch operations asynchronously and processing the results upon completion.
  /// </summary>
  /// <remarks>
  /// This class is part of the asynchronous framework that allows non-blocking batch operations.
  /// It uses a callback mechanism to return the result of a batch process once it is completed.
  /// </remarks>
  TAsynModels = Deepseek.Models.TAsynModels;

  {$ENDREGION}

  {$REGION 'Deepseek.User'}

  /// <summary>
  /// Represents detailed information about a user's balance in a specific currency.
  /// </summary>
  /// <remarks>
  /// This class encapsulates information about the user's balance, including the total available balance,
  /// granted balance, and topped-up balance, all categorized by currency.
  /// </remarks>
  TBalanceInfo = Deepseek.User.TBalanceInfo;

  /// <summary>
  /// Represents the user's balance and its availability for API usage.
  /// </summary>
  /// <remarks>
  /// This class provides information about whether the user's balance is sufficient for API calls
  /// and includes detailed balance information across different currencies.
  /// </remarks>
  TBalance = Deepseek.User.TBalance;

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TBalance</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynBalance</c> type extends the <c>TAsynParams&lt;TBalance&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynBalance = Deepseek.User.TAsynBalance;

  {$ENDREGION}

  {$REGION 'Deepseek.Functions.Core'}

  /// <summary>
  /// Interface defining the core structure and functionality of a function in the system.
  /// </summary>
  /// <remarks>
  /// This interface outlines the basic properties and methods that any function implementation must include.
  /// </remarks>
  IFunctionCore = Deepseek.Functions.Core.IFunctionCore;

  /// <summary>
  /// Abstract base class for implementing core function behavior.
  /// </summary>
  /// <remarks>
  /// This class provides basic implementations for some methods and defines the structure that derived classes must follow.
  /// </remarks>
  TFunctionCore = Deepseek.Functions.Core.TFunctionCore;

  {$ENDREGION}

  {$REGION 'Deepseek.API.Parallel'}

  /// <summary>
  /// Represents an item in a bundle of chat prompts and responses.
  /// </summary>
  /// <remarks>
  /// This class stores information about a single chat request, including its index,
  /// associated prompt, generated response, and related chat object.
  /// It is used within a <c>TBundleList</c> to manage multiple asynchronous chat requests.
  /// </remarks>
  TBundleItem = Deepseek.API.Parallel.TBundleItem;

  /// <summary>
  /// Manages a collection of <c>TBundleItem</c> objects.
  /// </summary>
  /// <remarks>
  /// This class provides methods to add, retrieve, and count items in a bundle.
  /// It is designed to store multiple chat request items processed in parallel.
  /// The internal storage uses a <c>TObjectList&lt;TBundleItem&gt;</c> with automatic memory management.
  /// </remarks>
  TBundleList = Deepseek.API.Parallel.TBundleList;

  /// <summary>
  /// Represents an asynchronous callback buffer for handling chat responses.
  /// </summary>
  /// <remarks>
  /// This class is a specialized type used to manage asynchronous operations
  /// related to chat request processing. It inherits from <c>TAsynCallBack&lt;TBundleList&gt;</c>,
  /// enabling structured handling of callback events.
  /// </remarks>
  TAsynBundleList = Deepseek.API.Parallel.TAsynBundleList;

  /// <summary>
  /// Provides helper methods for managing asynchronous tasks.
  /// </summary>
  /// <remarks>
  /// This class contains utility methods for handling task execution flow,
  /// including a method to execute a follow-up action once a task completes.
  /// <para>
  /// - In order to replace TTask.WaitForAll due to a memory leak in TLightweightEvent/TCompleteEventsWrapper.
  /// See report RSP-12462 and RSP-25999.
  /// </para>
  /// </remarks>
  TTaskHelper = Deepseek.API.Parallel.TTaskHelper;

  /// <summary>
  /// Represents the parameters used for configuring a chat request bundle.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TParameters</c> and provides specific methods for setting chat-related
  /// parameters, such as prompts, model selection, and reasoning effort.
  /// It is used to structure and pass multiple requests efficiently in parallel processing.
  /// </remarks>
  TBundleParams = Deepseek.API.Parallel.TBundleParams;

  {$ENDREGION}

/// <summary>
/// Creates a <see cref="TContentParams"/> instance representing a user-provided message.
/// </summary>
/// <param name="Value">
/// The content of the message provided by the user.
/// </param>
/// <param name="Name">
/// An optional parameter specifying the name of the user. Default is an empty string.
/// </param>
/// <returns>
/// An instance of <see cref="TContentParams"/> configured as a user message.
/// </returns>
function FromUser(const Value: string; const Name: string = ''): TContentParams;

/// <summary>
/// Creates a <see cref="TContentParams"/> instance representing an assistant-generated message.
/// </summary>
/// <param name="Value">
/// The content of the message generated by the assistant.
/// </param>
/// <param name="Prefix">
/// A boolean value indicating whether the message should include a prefix. Default is <c>false</c>.
/// </param>
/// <returns>
/// An instance of <see cref="TContentParams"/> configured as an assistant message.
/// </returns>
function FromAssistant(const Value: string; const Prefix: Boolean = False): TContentParams; overload;

/// <summary>
/// Creates a <see cref="TContentParams"/> instance representing an assistant-generated message, with an optional name.
/// </summary>
/// <param name="Value">
/// The content of the message generated by the assistant.
/// </param>
/// <param name="Name">
/// An optional parameter specifying the name of the assistant.
/// </param>
/// <param name="Prefix">
/// A boolean value indicating whether the message should include a prefix. Default is <c>false</c>.
/// </param>
/// <returns>
/// An instance of <see cref="TContentParams"/> configured as an assistant message with a name.
/// </returns>
function FromAssistant(const Value, Name: string; const Prefix: Boolean = False): TContentParams; overload;

/// <summary>
/// Creates a <see cref="TContentParams"/> instance representing a system-generated message.
/// </summary>
/// <param name="Value">
/// The content of the message generated by the system.
/// </param>
/// <param name="Name">
/// An optional parameter specifying the name of the system. Default is an empty string.
/// </param>
/// <returns>
/// An instance of <see cref="TContentParams"/> configured as a system message.
/// </returns>
function FromSystem(const Value: string; const Name: string = ''): TContentParams;

function HttpMonitoring: IRequestMonitor;

implementation

function FromUser(const Value: string; const Name: string): TContentParams;
begin
  Result := TContentParams.User(Value, Name);
end;

function FromAssistant(const Value: string; const Prefix: Boolean): TContentParams;
begin
  Result := TContentParams.Assistant(Value, Prefix);
end;

function FromAssistant(const Value, Name: string; const Prefix: Boolean): TContentParams;
begin
  Result := TContentParams.Assistant(Value, Name, Prefix);
end;

function FromSystem(const Value: string; const Name: string): TContentParams;
begin
  Result := TContentParams.System(Value, Name);
end;

function HttpMonitoring: IRequestMonitor;
begin
  Result := Monitoring;
end;

{ TDeepseek }

constructor TDeepseek.Create;
begin
  inherited Create;
  FAPI := TDeepseekAPI.Create;
end;

constructor TDeepseek.Create(const AToken: string);
begin
  Create;
  Token := AToken;
end;

destructor TDeepseek.Destroy;
begin
  FAPI.Free;
  FChatRoute.Free;
  FFIMRoute.Free;
  FModelsRoute.Free;
  FUserRoute.Free;
  inherited;
end;

function TDeepseek.GetAPI: TDeepseekAPI;
begin
  Result := FAPI;
end;

function TDeepseek.GetBaseUrl: string;
begin
  Result := FAPI.BaseURL;
end;

function TDeepseek.GetModelsRoute: TModelsRoute;
begin
  if not Assigned(FModelsRoute) then
    FModelsRoute := TModelsRoute.CreateRoute(API);
  Result := FModelsRoute;
end;

function TDeepseek.GetChatRoute: TChatRoute;
begin
  if not Assigned(FChatRoute) then
    FChatRoute := TChatRoute.CreateRoute(API);
  Result := FChatRoute;
end;

function TDeepseek.GetClientHttp: IHttpClientAPI;
begin
  Result := API.ClientHttp;
end;

function TDeepseek.GetFIMRoute: TFIMRoute;
begin
  if not Assigned(FFIMRoute) then
    FFIMRoute := TFIMRoute.CreateRoute(API);
  Result := FFIMRoute;
end;

function TDeepseek.GetKey: string;
begin
  Result := FAPI.APIKey;
end;

function TDeepseek.GetUserRoute: TUserRoute;
begin
  if not Assigned(FUserRoute) then
    FUserRoute := TUserRoute.CreateRoute(API);
  Result := FUserRoute;
end;

procedure TDeepseek.SetBaseUrl(const Value: string);
begin
  FAPI.BaseURL := Value;
end;

procedure TDeepseek.SetKey(const Value: string);
begin
  FAPI.APIKey := Value;
end;


{ TDeepseekFactory }

class function TDeepseekFactory.CreateBetaInstance(
  const AToken: string): IDeepseek;
begin
  Result := TDeepseek.Create(AToken);
  Result.BaseURL := 'https://api.deepseek.com/beta';
end;

class function TDeepseekFactory.CreateInstance(const AToken: string): IDeepseek;
begin
  Result := TDeepseek.Create(AToken);
end;

end.

unit Deepseek.Schema;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiDeepseek
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, REST.Json.Types,
  Deepseek.API.Params;

type
  /// <summary>
  /// Type contains the list of OpenAPI data types as defined by https://spec.openapis.org/oas/v3.0.3#data-types
  /// </summary>
  TSchemaType = (
    /// <summary>
    /// Not specified, should not be used.
    /// </summary>
    TYPE_UNSPECIFIED,
    /// <summary>
    /// String type.
    /// </summary>
    stSTRING,
    /// <summary>
    /// Number type.
    /// </summary>
    stNUMBER,
    /// <summary>
    /// Integer type.
    /// </summary>
    stINTEGER,
    /// <summary>
    /// Boolean type.
    /// </summary>
    stBOOLEAN,
    /// <summary>
    /// Array type.
    /// </summary>
    stARRAY,
    /// <summary>
    /// Object type.
    /// </summary>
    stOBJECT
  );

  /// <summary>
  /// Helper record for the <c>TSchemaType</c> enumeration, providing utility methods for converting
  /// between <c>TSchemaType</c> values and their string representations.
  /// </summary>
  TSchemaTypeHelper = record helper for TSchemaType
    /// <summary>
    /// Converts the current <c>TSchemaType</c> value to its corresponding string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>TSchemaType</c> value.
    /// </returns>
    function ToString: string;
  end;

  TSchemaParams = class;

  /// <summary>
  /// Provides helper methods for creating property items in OpenAPI schema definitions.
  /// </summary>
  /// <remarks>
  /// This record simplifies the creation of property entries when building schema objects,
  /// particularly for object properties in OpenAPI specifications.
  /// </remarks>
  TPropertyItem = record
  public
    /// <summary>
    /// Creates a JSON pair representing a property in a schema object.
    /// </summary>
    /// <param name="Key">The name of the property.</param>
    /// <param name="Value">The data type of the property as a <c>TSchemaType</c>.</param>
    /// <returns>A <c>TJSONPair</c> representing the property key-value pair.</returns>
    /// <remarks>
    /// This method facilitates the addition of properties to schema objects by creating
    /// a JSON pair with the specified key and data type.
    /// </remarks>
    class function Add(Key: string; Value: TSchemaType): TJSONPair; static;
  end;

  /// <summary>
  /// Represents the Schema Object in OpenAPI, enabling the definition of input and output data types.
  /// These types can be objects, primitives, or arrays. This class provides methods to build and
  /// configure schema definitions as per the OpenAPI 3.0 Specification.
  /// </summary>
  /// <remarks>
  /// The Schema Object allows the definition of input and output data types in the OpenAPI Specification.
  /// This class provides a fluent interface to construct schema definitions programmatically.
  /// </remarks>
  TSchemaParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the data type of the schema.
    /// </summary>
    /// <param name="Value">The data type to assign to the schema, specified as a <c>TSchemaType</c> value.</param>
    /// <returns>The current <c>TSchemaParams</c> instance to allow for method chaining.</returns>
    /// <remarks>
    /// The <c>type</c> keyword is required in the Schema Object to define the data type.
    /// Valid types include <c>string</c>, <c>number</c>, <c>integer</c>, <c>boolean</c>, <c>array</c>, and <c>object</c>.
    /// </remarks>
    function &Type(const Value: TSchemaType): TSchemaParams;
    /// <summary>
    /// Specifies the format of the data type.
    /// </summary>
    /// <param name="Value">The format of the data type, as a string.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>format</c> keyword is an optional modifier to provide more fine-grained data type information.
    /// Common formats include <c>int32</c>, <c>int64</c> for <c>integer</c> types; <c>float</c>, <c>double</c>
    /// for <c>number</c> types; and <c>byte</c>, <c>binary</c>, <c>date</c>, <c>date-time</c>, <c>password</c> for <c>string</c> types.
    /// </remarks>
    function Format(const Value: string): TSchemaParams;
    /// <summary>
    /// Adds a description to the schema.
    /// </summary>
    /// <param name="Value">A brief description of the schema. Supports Markdown for formatting.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>description</c> keyword provides a description of the schema and can include examples of use.
    /// This field supports Markdown syntax for rich text representation.
    /// </remarks>
    function Description(const Value: string): TSchemaParams;
    /// <summary>
    /// Specifies whether the schema's value can be null.
    /// </summary>
    /// <param name="Value">A boolean indicating if the schema allows null values.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>nullable</c> keyword is a boolean property that indicates if the value of the schema can be null.
    /// By default, this is false.
    /// </remarks>
    function Nullable(const Value: Boolean): TSchemaParams;
    /// <summary>
    /// Specifies an enumeration of possible values.
    /// </summary>
    /// <param name="Value">An array of string values that the schema can take.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>enum</c> keyword restricts the value of the schema to a fixed set of values.
    /// The schema's type must be <c>string</c> when using enum.
    /// </remarks>
    function Enum(const Value: TArray<string>): TSchemaParams;
    /// <summary>
    /// Specifies the maximum number of items allowed in an array schema.
    /// </summary>
    /// <param name="Value">The maximum number of items as a string.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>maxItems</c> keyword applies to schemas of type <c>array</c> and restricts the maximum number
    /// of items the array can contain.
    /// </remarks>
    function MaxItems(const Value: string): TSchemaParams;
    /// <summary>
    /// Specifies the minimum number of items required in an array schema.
    /// </summary>
    /// <param name="Value">The minimum number of items as a string.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>minItems</c> keyword applies to schemas of type <c>array</c> and defines the minimum number
    /// of items the array must contain.
    /// </remarks>
    function MinItems(const Value: string): TSchemaParams;
    /// <summary>
    /// Adds a property to an object schema.
    /// </summary>
    /// <param name="Key">The name of the property.</param>
    /// <param name="Value">A <c>TSchemaParams</c> instance defining the property's schema.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>properties</c> keyword is used to define the properties of an object schema.
    /// Each property is a key-value pair where the key is the property name and the value is a schema defining the property.
    /// </remarks>
    function Properties(const Key: string; const Value: TSchemaParams): TSchemaParams; overload;
    /// <summary>
    /// Adds a property to an object schema using a parameterized procedure to configure the property's schema.
    /// </summary>
    /// <param name="Key">The name of the property.</param>
    /// <param name="ParamProc">A procedure that takes a <c>TSchemaParams</c> instance to configure the property's schema.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// This overload allows you to define the property's schema inline using a procedural configuration.
    /// </remarks>
    function Properties(const Key: string; const ParamProc: TProcRef<TSchemaParams>): TSchemaParams; overload;
    /// <summary>
    /// Adds multiple properties to an object schema.
    /// </summary>
    /// <param name="Value">An array of <c>TJSONPair</c> instances representing the properties.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// This overload allows adding multiple properties at once to the object schema.
    /// </remarks>
    function Properties(const Value: TArray<TJSONPair>): TSchemaParams; overload;
    /// <summary>
    /// Specifies which properties are required in an object schema.
    /// </summary>
    /// <param name="Value">An array of property names that are required.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>required</c> keyword lists the property names that must be included when an object instance
    /// is validated against the schema.
    /// </remarks>
    function Required(const Value: TArray<string>): TSchemaParams;
    /// <summary>
    /// Specifies the schema of the items in an array schema.
    /// </summary>
    /// <param name="Value">A <c>TSchemaParams</c> instance defining the schema of the array items.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>items</c> keyword is used in array schemas to define the schema of each item in the array.
    /// </remarks>
    function Items(const Value: TSchemaParams): TSchemaParams; overload;
    /// <summary>
    /// Specifies the schema of the items in an array schema using a parameterized procedure.
    /// </summary>
    /// <param name="ParamProc">A procedure that configures a <c>TSchemaParams</c> instance to define the array items' schema.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// This overload allows you to define the items' schema inline using a procedural configuration.
    /// </remarks>
    function Items(const ParamProc: TProcRef<TSchemaParams>): TSchemaParams; overload;
    /// <summary>
    /// Creates a new instance of <c>TSchemaParams</c>.
    /// </summary>
    /// <returns>A new <c>TSchemaParams</c> instance.</returns>
    class function New: TSchemaParams; overload;
    /// <summary>
    /// Creates and configures a new instance of <c>TSchemaParams</c> using a parameterized procedure.
    /// </summary>
    /// <param name="ParamProc">A procedure that configures the new <c>TSchemaParams</c> instance.</param>
    /// <returns>A new <c>TSchemaParams</c> instance.</returns>
    /// <remarks>
    /// This overload allows you to create and configure the instance inline.
    /// </remarks>
    class function New(const ParamProc: TProcRef<TSchemaParams>): TSchemaParams; overload;
  end;

implementation

uses
  System.StrUtils, System.Rtti, Rest.Json;

{ TSchemaTypeHelper }

function TSchemaTypeHelper.ToString: string;
begin
  case Self of
    TYPE_UNSPECIFIED:
      Exit('type_unspecified');
    stSTRING:
      Exit('string');
    stNUMBER:
      Exit('number');
    stINTEGER:
      Exit('integer');
    stBOOLEAN:
      Exit('boolean');
    stARRAY:
      Exit('array');
    stOBJECT:
      Exit('object');
  end;
end;

{ TSchemaParams }

function TSchemaParams.Description(const Value: string): TSchemaParams;
begin
  Result := TSchemaParams(Add('description', Value));
end;

function TSchemaParams.Enum(const Value: TArray<string>): TSchemaParams;
begin
  Result := TSchemaParams(Add('enum', Value));
end;

function TSchemaParams.Format(const Value: string): TSchemaParams;
begin
  Result := TSchemaParams(Add('format', Value));
end;

function TSchemaParams.Items(
  const ParamProc: TProcRef<TSchemaParams>): TSchemaParams;
begin
  if Assigned(ParamProc) then
    begin
      var Value := TSchemaParams.Create;
      ParamProc(Value);
      Result := Items(Value);
    end
  else Result := Self;
end;

function TSchemaParams.Items(const Value: TSchemaParams): TSchemaParams;
begin
  Result := TSchemaParams(Add('items', Value.Detach));
end;

function TSchemaParams.MaxItems(const Value: string): TSchemaParams;
begin
  Result := TSchemaParams(Add('maxItems', Value));
end;

function TSchemaParams.MinItems(const Value: string): TSchemaParams;
begin
  Result := TSchemaParams(Add('minItems', Value));
end;

class function TSchemaParams.New: TSchemaParams;
begin
  Result := TSchemaParams.Create;
end;

class function TSchemaParams.New(
  const ParamProc: TProcRef<TSchemaParams>): TSchemaParams;
begin
  Result := TSchemaParams.Create;
  if Assigned(ParamProc) then
    begin
      ParamProc(Result);
    end;
end;

function TSchemaParams.Nullable(const Value: Boolean): TSchemaParams;
begin
  Result := TSchemaParams(Add('nullable', Value.ToString));
end;

function TSchemaParams.Properties(
  const Value: TArray<TJSONPair>): TSchemaParams;
begin
  var JSONValue := TJSONObject.Create;
  for var Item in Value do
    begin
      JSONValue.AddPair(Item);
    end;
  Result := TSchemaParams(Add('properties', JSONValue));
end;

function TSchemaParams.Properties(const Key: string;
  const ParamProc: TProcRef<TSchemaParams>): TSchemaParams;
begin
  if Assigned(ParamProc) then
    begin
      var Value := TSchemaParams.Create;
      ParamProc(Value);
      Result := Properties(Key, Value);
    end
  else Result := Self;
end;

function TSchemaParams.Properties(const Key: string;
  const Value: TSchemaParams): TSchemaParams;
begin
  Result := TSchemaParams(Add(Key, Value.Detach));
end;

function TSchemaParams.Required(const Value: TArray<string>): TSchemaParams;
begin
  Result := TSchemaParams(Add('required', Value));
end;

function TSchemaParams.&Type(const Value: TSchemaType): TSchemaParams;
begin
  Result := TSchemaParams(Add('type', Value.ToString));
end;

{ TPropertyItem }

class function TPropertyItem.Add(Key: string; Value: TSchemaType): TJSONPair;
begin
  Result := TJSONPair.Create(Key, Value.ToString);
end;

end.

unit Deepseek.Tutorial.FMX;

{ Tutorial Support Unit

   WARNING:
     This module is intended solely to illustrate the examples provided in the
     README.md file of the repository :
          https://github.com/MaxiDonkey/DelphiDeepseek
     Under no circumstances should the methods described below be used outside
     of the examples presented on the repository's page.
}

interface

uses
  System.SysUtils, System.Classes, Winapi.Messages, FMX.Types, FMX.StdCtrls, FMX.ExtCtrls,
  FMX.Controls, FMX.Forms, Winapi.Windows, FMX.Graphics, FMX.Dialogs, FMX.Memo.Types,
  FMX.Media, FMX.Objects, FMX.Controls.Presentation, FMX.ScrollBox, FMX.Memo, System.UITypes,
  System.Types, System.JSON,
  Deepseek, Deepseek.Types, Deepseek.Async.Promise;

type
  TToolProc = procedure (const Value: string) of object;

  /// <summary>
  /// Represents a tutorial hub for handling visual components in a Delphi application,
  /// including text display, button interactions, and navigation through pages.
  /// </summary>
  TFMXTutorialHub = class
  private
    FMemo1: TMemo;
    FMemo2: TMemo;
    FMemo3: TMemo;
    FMemo4: TMemo;
    FButton: TButton;
    FModelId: string;
    FTool: IFunctionCore;
    FToolCall: TToolProc;
    FCancel: Boolean;
    FClient: IDeepseek;
    procedure OnButtonClick(Sender: TObject);
    procedure SetButton(const Value: TButton);
    procedure SetMemo1(const Value: TMemo);
    procedure SetMemo2(const Value: TMemo);
    procedure SetMemo3(const Value: TMemo);
    procedure SetMemo4(const Value: TMemo);
    procedure SetJSONRequest(const Value: string);
    procedure SetJSONResponse(const Value: string);
    function GetReasoning: TMemo;
  public
    /// <summary>
    /// Gets or sets the first memo component for displaying messages or data.
    /// </summary>
    property Memo1: TMemo read FMemo1 write SetMemo1;
    /// <summary>
    /// Gets or sets the button component used to trigger actions or handle cancellation.
    /// </summary>
    property Button: TButton read FButton write SetButton;
    /// <summary>
    /// Gets or sets a value indicating whether the operation has been canceled.
    /// </summary>
    property Cancel: Boolean read FCancel write FCancel;
    /// <summary>
    /// Gets or sets the model identifier associated with the tutorial hub.
    /// </summary>
    property ModelId: string read FModelId write FModelId;
    /// <summary>
    /// Gets or sets the core function tool used for processing.
    /// </summary>
    property Tool: IFunctionCore read FTool write FTool;
    /// <summary>
    /// Gets or sets the procedure for handling tool-specific calls.
    /// </summary>
    property ToolCall: TToolProc read FToolCall write FToolCall;
    /// <summary>
    /// Sets text for displaying JSON request.
    /// </summary>
    property JSONRequest: string write SetJSONRequest;
    /// <summary>
    /// Sets text for displaying JSON response.
    /// </summary>
    property JSONResponse: string write SetJSONResponse;
    /// <summary>
    /// Gets or sets the third memo component for displaying messages or data.
    /// </summary>
    property Memo3: TMemo read FMemo3 write SetMemo3;
    /// <summary>
    /// Get the reasoning Memo.
    /// </summary>
    property Reasoning: TMemo read GetReasoning;
    /// <summary>
    /// Instance of IDeepseek
    /// </summary>
    property Client: IDeepseek read FClient;

    procedure JSONRequestClear;
    procedure JSONResponseClear;
    procedure Clear;
    function PromiseStep(const StepName, Prompt: string; const System: string = ''): TPromise<string>;
    /// <summary>
    /// Gets or sets a value indicating whether file overrides are allowed.
    /// </summary>
    constructor Create(const AClient: IDeepseek; const AMemo1, AMemo2, AMemo3, AMemo4: TMemo; const AButton: TButton);
  end;

  procedure Cancellation(Sender: TObject);
  function DoCancellation: Boolean;
  procedure Start(Sender: TObject);

  procedure Display(Sender: TObject); overload;
  procedure Display(Sender: TObject; Value: string); overload;
  procedure Display(Sender: TObject; Value: TArray<string>); overload;
  procedure Display(Sender: TObject; Value: TModel); overload;
  procedure Display(Sender: TObject; Value: TModels); overload;
  procedure Display(Sender: TObject; Value: TChat); overload;
  procedure Display(Sender: TObject; Value: TFIM); overload;
  procedure Display(Sender: TObject; Value: TBalance); overload;

  procedure DisplayStream(Sender: TObject; Value: string); overload;
  procedure DisplayStream(Sender: TObject; Value: TChat); overload;
  procedure DisplayStream(Sender: TObject; Value: TFIM); overload;

  procedure DisplayUsage(Sender: TObject; Value: TUsage);

  procedure DisplayChunk(Value: string); overload;
  procedure DisplayChunk(Value: TChat); overload;
  procedure DisplayChunk(Value: TFIM); overload;

  function F(const Name, Value: string): string; overload;
  function F(const Name: string; const Value: TArray<string>): string; overload;
  function F(const Name: string; const Value: boolean): string; overload;
  function F(const Name: string; const State: Boolean; const Value: Double): string; overload;

var
  /// <summary>
  /// A global instance of the <see cref="TVCLTutorialHub"/> class used as the main tutorial hub.
  /// </summary>
  /// <remarks>
  /// This variable serves as the central hub for managing tutorial components, such as memos, buttons, and pages.
  /// It is initialized dynamically during the application's runtime, and its memory is automatically released during
  /// the application's finalization phase.
  /// </remarks>
  TutorialHub: TFMXTutorialHub = nil;

implementation

uses
  System.DateUtils;

function UnixIntToDateTime(const Value: Int64): TDateTime;
begin
  Result := TTimeZone.Local.ToLocalTime(UnixToDateTime(Value));
end;

function UnixDateTimeToString(const Value: Int64): string;
begin
  Result := DateTimeToStr(UnixIntToDateTime(Value))
end;

procedure Cancellation(Sender: TObject);
begin
  Display(Sender, 'The operation was cancelled' + sLineBreak);
  TutorialHub.Cancel := False;
end;

function DoCancellation: Boolean;
begin
  Result := TutorialHub.Cancel;
end;

procedure Start(Sender: TObject);
begin
  Display(Sender, 'Please wait...');
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: string);
var
  M: TMemo;
begin
  if Sender is TMemo then
    M := Sender as TMemo else
    M := (Sender as TFMXTutorialHub).Memo1;
  M.Lines.Add(Value);
  M.ViewportPosition := PointF(M.ViewportPosition.X, M.Content.Height - M.Height);
end;

procedure Display(Sender: TObject; Value: TArray<string>);
begin
  var index := 0;
  for var Item in Value do
    begin
      if not Item.IsEmpty then
        begin
          if index = 0 then
            Display(Sender, Item) else
            Display(Sender, '    ' + Item);
        end;
      Inc(index);
    end;
end;

procedure Display(Sender: TObject);
begin
  Display(Sender, sLineBreak);
end;

procedure Display(Sender: TObject; Value: TModel);
begin
  Display(Sender, [
    EmptyStr,
    F('id', Value.Id),
    F('object', Value.&Object),
    F('owned_by', Value.OwnedBy)
  ]);
  Display(Sender, EmptyStr);
end;

procedure Display(Sender: TObject; Value: TModels);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, 'Models list');
  if System.Length(Value.Data) = 0 then
    begin
      Display(Sender, 'No model found');
      Exit;
    end;
  for var Item in Value.Data do
    begin
      Display(Sender, Item);
      Application.ProcessMessages;
    end;
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TChat);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Choices do
    if Item.FinishReason = TFinishReason.tool_calls then
      begin
        if Assigned(TutorialHub.ToolCall) then
          TutorialHub.ToolCall(TutorialHub.Tool.Execute(Item.Message.ToolCalls[0].&Function.Arguments));
      end
    else
      begin
        Display(TutorialHub.Reasoning, Item.Message.ReasoningContent.Replace('\n', #10));
        Display(Sender, Item.Message.Content.Replace('\n', #10));
        DisplayUsage(Sender, Value.Usage);
      end;
end;

procedure Display(Sender: TObject; Value: TFIM);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Choices do
    Display(TutorialHub, Item.Text);
end;

procedure Display(Sender: TObject; Value: TBalance);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, F('is_Available', BoolToStr(Value.IsAvailable, True)));
  for var Item in Value.BalanceInfos do
    Display(Sender, [
      EmptyStr,
      F('currency', Item.Currency),
      F('total_balance', Item.TotalBalance),
      F('granted_balance', Item.GrantedBalance),
      F('topped_up_balance', Item.ToppedUpBalance)
    ]);
  Display(Sender, EmptyStr);
end;

procedure DisplayStream(Sender: TObject; Value: string);
var
  M: TMemo;
  CurrentLine: string;
begin
  if Sender is TMemo then
    M := Sender as TMemo
  else
    M := (Sender as TFMXTutorialHub).Memo1;
  var ShouldScroll := M.ViewportPosition.Y >= (M.Content.Height - M.Height - 16);
  M.Lines.BeginUpdate;
  try
    var Lines := Value.Replace(#13, '').Split([#10]);
    if System.Length(Lines) > 0 then
    begin
      if M.Lines.Count > 0 then
        CurrentLine := M.Lines[M.Lines.Count - 1]
      else
        CurrentLine := EmptyStr;
      CurrentLine := CurrentLine + Lines[0];
      if M.Lines.Count > 0 then
        M.Lines[M.Lines.Count - 1] := CurrentLine
      else
        M.Lines.Add(CurrentLine);
      for var i := 1 to High(Lines) do
        M.Lines.Add(Lines[i]);
    end;
  finally
    M.Lines.EndUpdate;
  end;
  if ShouldScroll then
    M.ViewportPosition := PointF(M.ViewportPosition.X, M.Content.Height - M.Height + 1);
end;

procedure DisplayStream(Sender: TObject; Value: TChat);
begin
  if Assigned(Value) then
    begin
      DisplayChunk(Value);
      if not Value.Choices[0].Delta.ReasoningContent.IsEmpty then
        DisplayStream(TutorialHub.Reasoning, Value.Choices[0].Delta.ReasoningContent)
      else
        DisplayStream(Sender, Value.Choices[0].Delta.Content.Replace('\n', #10));
    end;
end;

procedure DisplayStream(Sender: TObject; Value: TFIM);
begin
  if Assigned(Value) then
    begin
      DisplayChunk(Value);
      DisplayStream(Sender, Value.Choices[0].Text);
    end;
end;

procedure DisplayUsage(Sender: TObject; Value: TUsage);
begin
  Display(Sender, EmptyStr);
  Display(Sender, F('completion_tokens', [
    Value.CompletionTokens.ToString,
    F('promp_tokens', Value.PromptTokens.ToString),
    F('prompt_cache_hit_tokens', Value.PromptCacheHitTokens.ToString),
    F('prompt_cache_miss_tokens', Value.PromptCacheMissTokens.ToString),
    F('total_tokens', Value.TotalTokens.ToString)
  ]));
  Display(Sender, EmptyStr);
end;

procedure DisplayChunk(Value: string);
begin
  if not Value.IsEmpty then
    begin
      var JSONValue := TJSONObject.ParseJSONValue(Value);
      TutorialHub.Memo3.Lines.BeginUpdate;
      try
        Display(TutorialHub.Memo3, JSONValue.ToString);
      finally
        TutorialHub.Memo3.Lines.EndUpdate;
        JSONValue.Free;
      end;
    end;
end;

procedure DisplayChunk(Value: TChat);
begin
  DisplayChunk(Value.JSONResponse);
end;

procedure DisplayChunk(Value: TFIM);
begin
  DisplayChunk(Value.JSONResponse);
end;

function F(const Name, Value: string): string;
begin
  if not Value.IsEmpty then
    Result := Format('%s: %s', [Name, Value])
end;

function F(const Name: string; const Value: TArray<string>): string;
begin
  var index := 0;
  for var Item in Value do
    begin
      if index = 0 then
        Result := Format('%s: %s', [Name, Item]) else
        Result := Result + '    ' + Item;
      Inc(index);
    end;
end;

function F(const Name: string; const Value: boolean): string;
begin
  Result := Format('%s: %s', [Name, BoolToStr(Value, True)])
end;

function F(const Name: string; const State: Boolean; const Value: Double): string;
begin
  Result := Format('%s (%s): %s%%', [Name, BoolToStr(State, True), (Value * 100).ToString(ffNumber, 3, 3)])
end;

{ TFMXTutorialHub }

procedure TFMXTutorialHub.Clear;
begin
  JSONRequestClear;
  JSONResponseClear;
  FMemo4.Lines.Clear;
end;

constructor TFMXTutorialHub.Create(const AClient: IDeepseek; const AMemo1, AMemo2, AMemo3, AMemo4: TMemo; const AButton: TButton);
begin
  inherited Create;
  FClient := AClient;
  Memo1 := AMemo1;
  Button := AButton;
  SetMemo2(AMemo2);
  SetMemo3(AMemo3);
  SetMemo4(AMemo4);
end;

function TFMXTutorialHub.GetReasoning: TMemo;
begin
  Result := FMemo4;
end;

procedure TFMXTutorialHub.JSONRequestClear;
begin
  FMemo2.Lines.Clear;
end;

procedure TFMXTutorialHub.JSONResponseClear;
begin
  FMemo3.Lines.Clear;
end;

procedure TFMXTutorialHub.OnButtonClick(Sender: TObject);
begin
  Cancel := True;
end;

function TFMXTutorialHub.PromiseStep(const StepName, Prompt,
  System: string): TPromise<string>;
var
  Buffer: string;
begin
  Result := TPromise<string>.Create(
    procedure(Resolve: TProc<string>; Reject: TProc<Exception>)
    begin
      Client.Chat.AsynCreateStream(
        procedure (Params: TChatParams)
        begin
          Params.Model('deepseek-chat');
          Params.Messages([
            FromSystem(system),
            FromUser(Prompt)
          ]);
          Params.Stream;
        end,
        function : TAsynChatStream
        begin
          Result.Sender := TutorialHub;

          Result.OnStart :=
            procedure (Sender: TObject)
            begin
              Display(Sender, StepName + #10);
            end;

          Result.OnProgress :=
            procedure (Sender: TObject; Chat: TChat)
            begin
              DisplayStream(Sender, Chat);
              Buffer := Buffer + Chat.Choices[0].Delta.Content;
            end;

          Result.OnSuccess :=
            procedure (Sender: TObject)
            begin
              Resolve(Buffer);
            end;

          Result.OnError :=
            procedure (Sender: TObject; Error: string)
            begin
              Reject(Exception.Create(Error));
            end;

          Result.OnDoCancel := DoCancellation;

          Result.OnCancellation :=
            procedure (Sender: TObject)
            begin
              Reject(Exception.Create('Aborted'));
            end;

        end);
    end);
end;

procedure TFMXTutorialHub.SetButton(const Value: TButton);
begin
  FButton := Value;
  FButton.OnClick := OnButtonClick;
  FButton.Text := 'Cancel';
end;

procedure TFMXTutorialHub.SetJSONRequest(const Value: string);
begin
  FMemo2.Lines.Text := Value;
  FMemo2.SelStart := 0;
  Application.ProcessMessages;
end;

procedure TFMXTutorialHub.SetJSONResponse(const Value: string);
begin
  FMemo3.Lines.Text := Value;
  FMemo2.SelStart := 0;
  Application.ProcessMessages;
end;

procedure TFMXTutorialHub.SetMemo1(const Value: TMemo);
begin
  FMemo1 := Value;
  FMemo1.TextSettings.WordWrap := True;
end;

procedure TFMXTutorialHub.SetMemo2(const Value: TMemo);
begin
  FMemo2 := Value;
end;

procedure TFMXTutorialHub.SetMemo3(const Value: TMemo);
begin
  FMemo3 := Value;
end;

procedure TFMXTutorialHub.SetMemo4(const Value: TMemo);
begin
  FMemo4 := Value;
end;

initialization
finalization
  if Assigned(TutorialHub) then
    TutorialHub.Free;
end.

unit Deepseek.Tutorial.VCL;

{ Tutorial Support Unit

   WARNING:
     This module is intended solely to illustrate the examples provided in the
     README.md file of the repository :
          https://github.com/MaxiDonkey/DelphiDeepseek
     Under no circumstances should the methods described below be used outside
     of the examples presented on the repository's page.
}

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes,
  Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.ExtCtrls,
  System.UITypes, System.JSON,
  Deepseek, Deepseek.Types, Deepseek.Async.Promise;

type
  TToolProc = procedure (const Value: string) of object;

  /// <summary>
  /// Represents a tutorial hub for handling visual components in a Delphi application,
  /// including text display, button interactions, and navigation through pages.
  /// </summary>
  TVCLTutorialHub = class
  private
    FMemo1: TMemo;
    FMemo2: TMemo;
    FMemo3: TMemo;
    FMemo4: TMemo;
    FButton: TButton;
    FModelId: string;
    FTool: IFunctionCore;
    FToolCall: TToolProc;
    FCancel: Boolean;
    FClient: IDeepseek;
    procedure OnButtonClick(Sender: TObject);
    procedure SetButton(const Value: TButton);
    procedure SetMemo1(const Value: TMemo);
    procedure SetMemo2(const Value: TMemo);
    procedure SetMemo3(const Value: TMemo);
    procedure SetMemo4(const Value: TMemo);
    procedure SetJSONRequest(const Value: string);
    procedure SetJSONResponse(const Value: string);
    function GetReasoning: TMemo;
  public
    /// <summary>
    /// Gets or sets the first memo component for displaying messages or data.
    /// </summary>
    property Memo1: TMemo read FMemo1 write SetMemo1;
    /// <summary>
    /// Gets or sets the button component used to trigger actions or handle cancellation.
    /// </summary>
    property Button: TButton read FButton write SetButton;
    /// <summary>
    /// Gets or sets a value indicating whether the operation has been canceled.
    /// </summary>
    property Cancel: Boolean read FCancel write FCancel;
    /// <summary>
    /// Gets or sets the model identifier associated with the tutorial hub.
    /// </summary>
    property ModelId: string read FModelId write FModelId;
    /// <summary>
    /// Gets or sets the core function tool used for processing.
    /// </summary>
    property Tool: IFunctionCore read FTool write FTool;
    /// <summary>
    /// Gets or sets the procedure for handling tool-specific calls.
    /// </summary>
    property ToolCall: TToolProc read FToolCall write FToolCall;
    /// <summary>
    /// Sets text for displaying JSON request.
    /// </summary>
    property JSONRequest: string write SetJSONRequest;
    /// <summary>
    /// Sets text for displaying JSON response.
    /// </summary>
    property JSONResponse: string write SetJSONResponse;
    /// <summary>
    /// Gets or sets the third memo component for displaying messages or data.
    /// </summary>
    property Memo3: TMemo read FMemo3 write SetMemo3;
    /// <summary>
    /// Get the reasoning Memo.
    /// </summary>
    property Reasoning: TMemo read GetReasoning;
    /// <summary>
    /// Instance of IDeepseek
    /// </summary>
    property Client: IDeepseek read FClient;
    procedure JSONRequestClear;
    procedure JSONResponseClear;
    procedure Clear;
    function PromiseStep(const StepName, Prompt: string; const System: string = ''): TPromise<string>;
    constructor Create(const AClient: IDeepseek; const AMemo1, AMemo2, AMemo3, AMemo4: TMemo; const AButton: TButton);
  end;

  procedure Cancellation(Sender: TObject);
  function DoCancellation: Boolean;
  procedure Start(Sender: TObject);

  procedure Display(Sender: TObject); overload;
  procedure Display(Sender: TObject; Value: string); overload;
  procedure Display(Sender: TObject; Value: TArray<string>); overload;
  procedure Display(Sender: TObject; Value: TModel); overload;
  procedure Display(Sender: TObject; Value: TModels); overload;
  procedure Display(Sender: TObject; Value: TChat); overload;
  procedure Display(Sender: TObject; Value: TFIM); overload;
  procedure Display(Sender: TObject; Value: TBalance); overload;

  procedure DisplayStream(Sender: TObject; Value: string); overload;
  procedure DisplayStream(Sender: TObject; Value: TChat); overload;
  procedure DisplayStream(Sender: TObject; Value: TFIM); overload;

  procedure DisplayUsage(Sender: TObject; Value: TUsage);

  procedure DisplayChunk(Value: string); overload;
  procedure DisplayChunk(Value: TChat); overload;
  procedure DisplayChunk(Value: TFIM); overload;

  function F(const Name, Value: string): string; overload;
  function F(const Name: string; const Value: TArray<string>): string; overload;
  function F(const Name: string; const Value: boolean): string; overload;
  function F(const Name: string; const State: Boolean; const Value: Double): string; overload;

var
  /// <summary>
  /// A global instance of the <see cref="TVCLTutorialHub"/> class used as the main tutorial hub.
  /// </summary>
  /// <remarks>
  /// This variable serves as the central hub for managing tutorial components, such as memos, buttons, and pages.
  /// It is initialized dynamically during the application's runtime, and its memory is automatically released during
  /// the application's finalization phase.
  /// </remarks>
  TutorialHub: TVCLTutorialHub = nil;

implementation

uses
  System.DateUtils;

function UnixIntToDateTime(const Value: Int64): TDateTime;
begin
  Result := TTimeZone.Local.ToLocalTime(UnixToDateTime(Value));
end;

function UnixDateTimeToString(const Value: Int64): string;
begin
  Result := DateTimeToStr(UnixIntToDateTime(Value))
end;

procedure Cancellation(Sender: TObject);
begin
  Display(Sender, 'The operation was cancelled' + sLineBreak);
  TutorialHub.Cancel := False;
end;

function DoCancellation: Boolean;
begin
  Result := TutorialHub.Cancel;
end;

procedure Start(Sender: TObject);
begin
  Display(Sender, 'Please wait...');
  Display(Sender);
  TutorialHub.Cancel := False;
end;

procedure Display(Sender: TObject; Value: string);
var
  M: TMemo;
begin
  if Sender is TMemo then
    M := TMemo(Sender) else
    M := (Sender as TVCLTutorialHub).Memo1;

  var S := Value.Split([#10]);
  if System.Length(S) = 0 then
    begin
      M.Lines.Add(Value)
    end
  else
    begin
      for var Item in S do
        M.Lines.Add(Item);
    end;

  M.Perform(WM_VSCROLL, SB_BOTTOM, 0);
end;

procedure Display(Sender: TObject; Value: TArray<string>);
begin
  var index := 0;
  for var Item in Value do
    begin
      if not Item.IsEmpty then
        begin
          if index = 0 then
            Display(Sender, Item) else
            Display(Sender, '    ' + Item);
        end;
      Inc(index);
    end;
end;

procedure Display(Sender: TObject);
begin
  Display(Sender, sLineBreak);
end;

procedure Display(Sender: TObject; Value: TModel);
begin
  Display(Sender, [
    EmptyStr,
    F('id', Value.Id),
    F('object', Value.&Object),
    F('owned_by', Value.OwnedBy)
  ]);
  Display(Sender, EmptyStr);
end;

procedure Display(Sender: TObject; Value: TModels);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, 'Models list');
  if System.Length(Value.Data) = 0 then
    begin
      Display(Sender, 'No model found');
      Exit;
    end;
  for var Item in Value.Data do
    begin
      Display(Sender, Item);
      Application.ProcessMessages;
    end;
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TChat);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Choices do
    if Item.FinishReason = TFinishReason.tool_calls then
      begin
        if Assigned(TutorialHub.ToolCall) then
          TutorialHub.ToolCall(TutorialHub.Tool.Execute(Item.Message.ToolCalls[0].&Function.Arguments));
      end
    else
      begin
        Display(TutorialHub.Reasoning, Item.Message.ReasoningContent.Replace('\n', #10));
        Display(Sender, Item.Message.Content.Replace('\n', #10));
        DisplayUsage(Sender, Value.Usage);
      end;
end;

procedure Display(Sender: TObject; Value: TFIM);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Choices do
    Display(TutorialHub, Item.Text);
end;

procedure Display(Sender: TObject; Value: TBalance);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, F('is_Available', BoolToStr(Value.IsAvailable, True)));
  for var Item in Value.BalanceInfos do
    Display(Sender, [
      EmptyStr,
      F('currency', Item.Currency),
      F('total_balance', Item.TotalBalance),
      F('granted_balance', Item.GrantedBalance),
      F('topped_up_balance', Item.ToppedUpBalance)
    ]);
  Display(Sender, EmptyStr);
end;

procedure DisplayStream(Sender: TObject; Value: string);
var
  M   : TMemo;
  Txt : string;
begin
  if Value.IsEmpty then Exit;

  if Sender is TMemo then
    M := TMemo(Sender)
  else
    M := (Sender as TVCLTutorialHub).Memo1;

  Txt := StringReplace(Value, '\n', sLineBreak, [rfReplaceAll]);
  Txt := StringReplace(Txt, #10,  sLineBreak, [rfReplaceAll]);

  M.Lines.BeginUpdate;
  try
    M.SelStart   := M.GetTextLen;
    M.SelLength  := 0;
    M.SelText    := Txt;
  finally
    M.Lines.EndUpdate;
  end;

  M.Perform(EM_SCROLLCARET, 0, 0);
end;

procedure DisplayStream(Sender: TObject; Value: TChat);
begin
  if Assigned(Value) then
    begin
      DisplayChunk(Value);
      if not Value.Choices[0].Delta.ReasoningContent.IsEmpty then
        {--- Display reasoning chunk }
        DisplayStream(TutorialHub.Reasoning, Value.Choices[0].Delta.ReasoningContent)
      else
        {--- Display responses chunk }
        DisplayStream(Sender, Value.Choices[0].Delta.Content.Replace('\n', #10));
    end;
end;

procedure DisplayStream(Sender: TObject; Value: TFIM);
begin
  if Assigned(Value) then
    begin
      DisplayChunk(Value);
      DisplayStream(Sender, Value.Choices[0].Text.Replace('\n', #10));
    end;
end;

procedure DisplayUsage(Sender: TObject; Value: TUsage);
begin
  Display(Sender, EmptyStr);
  Display(Sender, F('completion_tokens', [
    Value.CompletionTokens.ToString,
    F('promp_tokens', Value.PromptTokens.ToString),
    F('prompt_cache_hit_tokens', Value.PromptCacheHitTokens.ToString),
    F('prompt_cache_miss_tokens', Value.PromptCacheMissTokens.ToString),
    F('total_tokens', Value.TotalTokens.ToString)
  ]));
  Display(Sender, EmptyStr);
end;

procedure DisplayChunk(Value: string);
begin
  if not Value.IsEmpty then
    begin
      var JSONValue := TJSONObject.ParseJSONValue(Value);
      TutorialHub.Memo3.Lines.BeginUpdate;
      try
        Display(TutorialHub.Memo3, JSONValue.ToString);
      finally
        TutorialHub.Memo3.Lines.EndUpdate;
        JSONValue.Free;
      end;
    end;
end;

procedure DisplayChunk(Value: TChat);
begin
  DisplayChunk(Value.JSONResponse);
end;

procedure DisplayChunk(Value: TFIM);
begin
  DisplayChunk(Value.JSONResponse);
end;

function F(const Name, Value: string): string;
begin
  if not Value.IsEmpty then
    Result := Format('%s: %s', [Name, Value])
end;

function F(const Name: string; const Value: TArray<string>): string;
begin
  var index := 0;
  for var Item in Value do
    begin
      if index = 0 then
        Result := Format('%s: %s', [Name, Item]) else
        Result := Result + '    ' + Item;
      Inc(index);
    end;
end;

function F(const Name: string; const Value: boolean): string;
begin
  Result := Format('%s: %s', [Name, BoolToStr(Value, True)])
end;

function F(const Name: string; const State: Boolean; const Value: Double): string;
begin
  Result := Format('%s (%s): %s%%', [Name, BoolToStr(State, True), (Value * 100).ToString(ffNumber, 3, 2)])
end;

{ TVCLTutorialHub }

procedure TVCLTutorialHub.Clear;
begin
  JSONRequestClear;
  JSONResponseClear;
  FMemo4.Clear;
end;

constructor TVCLTutorialHub.Create(const AClient: IDeepseek; const AMemo1, AMemo2, AMemo3, AMemo4: TMemo; const AButton: TButton);
begin
  inherited Create;
  FClient := AClient;
  Memo1 := AMemo1;
  Button := AButton;
  SetMemo2(AMemo2);
  SetMemo3(AMemo3);
  SetMemo4(AMemo4);
end;

function TVCLTutorialHub.GetReasoning: TMemo;
begin
  Result := FMemo4;
end;

procedure TVCLTutorialHub.JSONRequestClear;
begin
  FMemo2.Clear;
end;

procedure TVCLTutorialHub.JSONResponseClear;
begin
  FMemo3.Clear;
end;

procedure TVCLTutorialHub.OnButtonClick(Sender: TObject);
begin
  Cancel := True;
end;

function TVCLTutorialHub.PromiseStep(const StepName, Prompt,
  System: string): TPromise<string>;
var
  Buffer: string;
begin
  Result := TPromise<string>.Create(
    procedure(Resolve: TProc<string>; Reject: TProc<Exception>)
    begin
      Client.Chat.AsynCreateStream(
        procedure (Params: TChatParams)
        begin
          Params.Model('deepseek-chat');
          Params.Messages([
            FromSystem(system),
            FromUser(Prompt)
          ]);
          Params.Stream;
        end,
        function : TAsynChatStream
        begin
          Result.Sender := TutorialHub;

          Result.OnStart :=
            procedure (Sender: TObject)
            begin
              Display(Sender, StepName + #10);
            end;

          Result.OnProgress :=
            procedure (Sender: TObject; Chat: TChat)
            begin
              DisplayStream(Sender, Chat);
              Buffer := Buffer + Chat.Choices[0].Delta.Content;
            end;

          Result.OnSuccess :=
            procedure (Sender: TObject)
            begin
              Resolve(Buffer);
            end;

          Result.OnError :=
            procedure (Sender: TObject; Error: string)
            begin
              Reject(Exception.Create(Error));
            end;

          Result.OnDoCancel := DoCancellation;

          Result.OnCancellation :=
            procedure (Sender: TObject)
            begin
              Reject(Exception.Create('Aborted'));
            end;

        end);
    end);
end;

procedure TVCLTutorialHub.SetButton(const Value: TButton);
begin
  FButton := Value;
  FButton.OnClick := OnButtonClick;
  FButton.Caption := 'Cancel';
end;

procedure TVCLTutorialHub.SetJSONRequest(const Value: string);
begin
  FMemo2.Lines.Text := Value;
  FMemo2.SelStart := 0;
  Application.ProcessMessages;
end;

procedure TVCLTutorialHub.SetJSONResponse(const Value: string);
begin
  FMemo3.Lines.Text := Value;
  FMemo2.SelStart := 0;
  Application.ProcessMessages;
end;

procedure TVCLTutorialHub.SetMemo1(const Value: TMemo);
begin
  FMemo1 := Value;
  FMemo1.ScrollBars := TScrollStyle.ssVertical;
end;

procedure TVCLTutorialHub.SetMemo2(const Value: TMemo);
begin
  FMemo2 := Value;
end;

procedure TVCLTutorialHub.SetMemo3(const Value: TMemo);
begin
  FMemo3 := Value;
end;

procedure TVCLTutorialHub.SetMemo4(const Value: TMemo);
begin
  FMemo4 := Value;
end;

initialization

finalization
  if Assigned(TutorialHub) then
    TutorialHub.Free;
end.

unit Deepseek.Types;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiDeepseek
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, Deepseek.API.Params;

{$SCOPEDENUMS ON}

type

{$REGION 'Deepseek.Chat'}

  /// <summary>
  /// Type of message role
  /// </summary>
  TMessageRole = (
    /// <summary>
    /// User role for the message
    /// </summary>
    user,
    /// <summary>
    /// Assistant role for the message
    /// </summary>
    assistant,
    /// <summary>
    /// System role for the message
    /// </summary>
    system);

  TMessageRoleHelper = record helper for TMessageRole
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TMessageRoleInterceptor = class(TJSONInterceptorStringToString)
  public
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Represents the different reasons why the processing of a request can terminate.
  /// </summary>
  TFinishReason = (
    /// <summary>
    /// The model hit a natural stop point or a provided stop sequence.
    /// </summary>
    stop,
    /// <summary>
    /// The maximum number of tokens specified in the request was reached.
    /// </summary>
    length,
    /// <summary>
    /// The content was omitted due to a flag from our content filters.
    /// </summary>
    content_filter,
    /// <summary>
    /// The model called a tool.
    /// </summary>
    tool_calls,
    /// <summary>
    /// The request is interrupted due to insufficient resource of the inference system.
    /// </summary>
    insufficient_system_resource
    );

  TFinishReasonHelper = record helper for TFinishReason
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TFinishReasonInterceptor = class(TJSONInterceptorStringToString)
  public
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Indicator to specify how to use tools.
  /// </summary>
  /// <remarks>
  /// <para>
  /// <c>none</c> is the default when no tools are present.
  /// </para>
  /// <para>
  /// <c>auto</c> is the default if tools are present.
  /// </para>
  /// </remarks>
  TToolChoice = (
    /// <summary>
    /// The model will not call any tool and instead generates a message.
    /// </summary>
    none,
    /// <summary>
    /// The model can pick between generating a message or calling one or more tools.
    /// </summary>
    auto,
    /// <summary>
    /// The model must call one or more tools.
    /// </summary>
    required
  );

  TToolChoiceHelper = record helper for TToolChoice
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TResponseFormat = (
    text,
    json_object
  );

  TResponseFormatHelper = record helper for TResponseFormat
    constructor Create(const Value: string);
    function ToString: string;
  end;

{$ENDREGION}

implementation

uses
  System.StrUtils, System.Rtti, System.TypInfo, Rest.Json;

type
  TEnumValueRecovery = class
    class function TypeRetrieve<T>(const Value: string; const References: TArray<string>): T;
  end;

{ TMessageRoleHelper }

constructor TMessageRoleHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TMessageRole>(Value,
            ['user', 'assistant', 'system']);
end;

function TMessageRoleHelper.ToString: string;
begin
  case Self of
    TMessageRole.user:
      Exit('user');
    TMessageRole.assistant:
      Exit('assistant');
    TMessageRole.system:
      Exit('system');
  end;
end;

{ TMessageRoleInterceptor }

function TMessageRoleInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TMessageRole>.ToString;
end;

procedure TMessageRoleInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TMessageRole.Create(Arg)));
end;

{ TFinishReasonHelper }

constructor TFinishReasonHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TFinishReason>(Value,
            ['stop', 'length', 'content_filter', 'tool_calls', 'insufficient_system_resource']);
end;

function TFinishReasonHelper.ToString: string;
begin
  case Self of
    TFinishReason.stop:
      Exit('stop');
    TFinishReason.length:
      Exit('length');
    TFinishReason.content_filter:
      Exit('content_filter');
    TFinishReason.tool_calls:
      Exit('tool_calls');
    TFinishReason.insufficient_system_resource:
      Exit('insufficient_system_resource');
  end;
end;

{ TFinishReasonInterceptor }

function TFinishReasonInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TFinishReason>.ToString;
end;

procedure TFinishReasonInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TFinishReason.Create(Arg)));
end;

{ TToolChoiceHelper }

constructor TToolChoiceHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TToolChoice>(Value,
            ['none', 'auto', 'required']);
end;

function TToolChoiceHelper.ToString: string;
begin
  case Self of
    TToolChoice.none:
      Exit('none');
    TToolChoice.auto:
      Exit('auto');
    TToolChoice.required:
      Exit('required');
  end;
end;

{ TResponseFormatHelper }

constructor TResponseFormatHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TResponseFormat>(Value,
            ['text', 'json_object']);
end;

function TResponseFormatHelper.ToString: string;
begin
  case Self of
    TResponseFormat.text:
      Exit('text');
    TResponseFormat.json_object:
      Exit('json_object');
  end;
end;

{ TEnumValueRecovery }

class function TEnumValueRecovery.TypeRetrieve<T>(const Value: string;
  const References: TArray<string>): T;
var
  pInfo: PTypeInfo;
begin
  pInfo := TypeInfo(T);
  if pInfo.Kind <> tkEnumeration then
    raise Exception.Create('TRecovery.TypeRetrieve<T>: T is not an enumerated type');

  var index := IndexStr(Value.ToLower, References);
  if index = -1 then
    raise Exception.CreateFmt('%s : Unable to retrieve enum value.', [Value]);

  Move(index, Result, SizeOf(Result));
end;

end.

unit Deepseek.User;

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, System.Threading,
  REST.Json.Types, Deepseek.API.Params, Deepseek.API, Deepseek.Async.Support;

type

  /// <summary>
  /// Represents detailed information about a user's balance in a specific currency.
  /// </summary>
  /// <remarks>
  /// This class encapsulates information about the user's balance, including the total available balance,
  /// granted balance, and topped-up balance, all categorized by currency.
  /// </remarks>
  TBalanceInfo = class
  private
    FCurrency: string;
    [JsonNameAttribute('total_balance')]
    FTotalBalance: string;
    [JsonNameAttribute('granted_balance')]
    FGrantedBalance: string;
    [JsonNameAttribute('topped_up_balance')]
    FToppedUpBalance: string;
  public
    /// <summary>
    /// The currency of the balance. Possible values: [CNY, USD]
    /// </summary>
    property Currency: string read FCurrency write FCurrency;
    /// <summary>
    /// The total available balance, including the granted balance and the topped-up balance.
    /// </summary>
    property TotalBalance: string read FTotalBalance write FTotalBalance;
    /// <summary>
    /// The total not expired granted balance.
    /// </summary>
    property GrantedBalance: string read FGrantedBalance write FGrantedBalance;
    /// <summary>
    /// The total topped-up balance.
    /// </summary>
    property ToppedUpBalance: string read FToppedUpBalance write FToppedUpBalance;
  end;

  /// <summary>
  /// Represents the user's balance and its availability for API usage.
  /// </summary>
  /// <remarks>
  /// This class provides information about whether the user's balance is sufficient for API calls
  /// and includes detailed balance information across different currencies.
  /// </remarks>
  TBalance = class(TJSONFingerprint)
  private
    [JsonNameAttribute('is_available')]
    FIsAvailable: Boolean;
    [JsonNameAttribute('balance_infos')]
    FBalanceInfos: TArray<TBalanceInfo>;
  public
    /// <summary>
    /// Whether the user's balance is sufficient for API calls.
    /// </summary>
    property IsAvailable: Boolean read FIsAvailable write FIsAvailable;
    /// <summary>
    /// Provides detailed balance information for each currency.
    /// </summary>
    /// <remarks>
    /// This property contains an array of <c>TBalanceInfo</c> objects, where each object represents
    /// balance details such as the total balance, granted balance, and topped-up balance for a specific currency.
    /// </remarks>
    property BalanceInfos: TArray<TBalanceInfo> read FBalanceInfos write FBalanceInfos;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TBalance</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynBalance</c> type extends the <c>TAsynParams&lt;TBalance&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynBalance = TAsynCallBack<TBalance>;

  TUserRoute = class(TDeepseekAPIRoute)
    /// <summary>
    /// Get user current balance asynchronously.
    /// </summary>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for the asynchronous balance, such as on success and on error.
    /// </param>
    /// <remarks>
    /// <code>
    /// //var DeepSeek := TDeepseekFactory.CreateInstance(BarearKey);
    /// DeepSeek.User.AsynBalance(
    ///   function: TAsynBalance
    ///   begin
    ///     Result.Sender := My_component;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Value: TBalance)
    ///     begin
    ///       // Handle success operation
    ///     end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Value: string)
    ///     begin
    ///       // Handle error message
    ///     end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsynBalance(CallBacks: TFunc<TAsynBalance>);
    /// <summary>
    /// Get user current balance
    /// </summary>
    /// <returns>
    /// Returns a <c>TBalance</c> object that contains the user balance.
    /// </returns>
    /// <remarks>
    /// <code>
    /// //var DeepSeek := TDeepseekFactory.CreateInstance(BarearKey);
    /// var Value := DeepSeek.User.Balance;
    ///   try
    ///     // Handle the Value
    ///   finally
    ///     Value.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Balance: TBalance;
  end;

implementation

{ TBalance }

destructor TBalance.Destroy;
begin
  for var Item in FBalanceInfos do
    Item.Free;
  inherited;
end;

{ TUserRoute }

procedure TUserRoute.AsynBalance(CallBacks: TFunc<TAsynBalance>);
begin
  with TAsynCallBackExec<TAsynBalance, TBalance>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TBalance
      begin
        Result := Self.Balance;
      end);
  finally
    Free;
  end;
end;

function TUserRoute.Balance: TBalance;
begin
  Result := API.Get<TBalance>('user/balance');
end;

end.






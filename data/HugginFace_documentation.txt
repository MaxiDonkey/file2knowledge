# Delphi Hugging Face API

___
![GitHub](https://img.shields.io/badge/IDE%20Version-Delphi%2010.3/11/12-yellow)
![GitHub](https://img.shields.io/badge/platform-all%20platforms-green)
![GitHub](https://img.shields.io/badge/Updated%20the%2012/22/2024-blue)

<br/>
<br/>

- [Introduction](#Introduction)
    - [Resources available on Hugging Face Hub](#Resources-available-on-Hugging-Face-Hub)
    - [Serverless Inference API](#Serverless-Inference-API)
    - [Advantages of using Hugging Face Hub](#Advantages-of-using-Hugging-Face-Hub)
    - [Rate Limits and Supported Models](#Rate-Limits-and-Supported-Models)
    - [Licenses and Compliance](#Licenses-and-Compliance)
    - [Tutorial content](#Tutorial-content)
- [Remarks](#remarks)
- [Tools for simplifying this tutorial](#Tools-for-simplifying-this-tutorial)
- [Asynchronous callback mode management](#Asynchronous-callback-mode-management)
- [Exploration Journey](#Exploration-Journey)
    - [Initialization](#initialization)
    - [Hugging Face Models Overview](#Hugging-Face-Models-Overview)
        - [Model inference WARM COLD](#Model-inference-WARM-COLD)
    - [Music-gen](#Music-gen)
    - [Image object detection](#Image-object-detection)
    - [Text To Sentiment analysis](#Text-To-Sentiment-analysis)
    - [Audio classification](#Audio-classification)
        - [Speech emotion recognition](#speech-emotion-recognition)
        - [Gender recognition](#Gender-recognition)
    - [Image classification](#Image-classification)
    - [Image Segmentation](#Image-Segmentation)
    - [Zero-Shot classification](#Zero-Shot-classification)
    - [Token Classification](#Token-Classification)
    - [Question Answering](#Question-Answering)
    - [Table Question Answering](#Table-Question-Answering)
    - [Fill-mask](#Fill-mask)
    - [Text Classification](#Text-Classification)
    - [Summarization](#Summarization)
- [Common Ground Functionalities Across API Ecosystems](#Common-Ground-Functionalities-Across-API-Ecosystems)
    - [Embeddings](#Embeddings)
    - [Chat](#Chat)
        - [Multi Turn Conversation](#Multi-Turn-Conversation)
        - [Streamed Multi Turn Conversation](#Streamed-Multi-Turn-Conversation)
        - [Vision](#Vision)
        - [Use tools](#Use-tools)
    - [Text Generation](#Text-Generation)
    - [Translation](#Translation)
    - [Image Generation](#Image-Generation)
    - [Text-to-Speech](#Text-to-Speech)
    - [Automatic Speech Recognition](#Automatic-Speech-Recognition)
- [Contributing](#contributing)
- [License](#license)
 
<br/>
<br/>


# Introduction

**Hugging Face Hub** is an open-source collaborative platform dedicated to democratizing access to artificial intelligence (AI) technologies. This platform hosts a vast collection of models, datasets, and interactive applications, facilitating the exploration, experimentation, and integration of AI solutions into various projects.
[Official page](https://huggingface.co/docs/hub/index)

## Resources available on Hugging Face Hub

- **Models:** The Hub offers a multitude of pre-trained models covering domains such as natural language processing (NLP), computer vision, and audio recognition. These models are suited for various tasks, including text generation, classification, object detection, and speech transcription. 
- **Datasets:** A diverse library of datasets is available for training and evaluating your own models, providing a foundation for developing customized solutions. 
- **Spaces:** The Hub hosts interactive applications that allow you to visualize and test models directly from a browser. These spaces are useful for demonstrating model capabilities or conducting quick analyses. 

<br/>

## Serverless Inference API

Hugging Face Hub offers a Inference API, enabling rapid integration of AI models into your projects without the need for complex infrastructure management.

<br/>

## Advantages of using Hugging Face Hub

- **Time-saving:** Models are ready to use, eliminating the need to train or deploy them locally, which accelerates the development of applications.
- **Scalability:** The Hub's infrastructure ensures automatic scaling, load balancing, and efficient caching.

<br/>

In summary, **Hugging Face Hub** is a resource for integrating AI models into projects. With its serverless Inference API and collection of ready-to-use resources, it offers an solution to enhance applications with AI capabilities while simplifying their implementation and maintenance.

<br/>

## Rate Limits and Supported Models

By subscribing, you gain access to thousands of models. You can explore the benefits of individual, professional, and enterprise subscriptions by following the links below:

- [Rate limits](https://huggingface.co/docs/api-inference/rate-limits)
- [Supported models](https://huggingface.co/docs/api-inference/supported-models)

<br/>

## Licenses and Compliance

When integrating models or datasets from **Hugging Face Hub** into your projects, it is crucial to pay close attention to the associated licenses. Every resource hosted on the platform comes with a specific license that outlines the terms of use, modification, and distribution. A thorough understanding of these licenses is essential to ensure the legal and ethical compliance of your developments.

**Why is this important?**

- **Legal compliance:** Using a resource without adhering to its license terms can lead to legal violations, exposing your project to potential risks.
- **Respect for creators' rights:** Licenses protect the rights of creators. By respecting them, you acknowledge and honor their work.
- **Transparency and ethics:** Following the conditions of licenses promotes responsible and ethical use of open-source technologies.

Refer to the `Model Card` or `Dataset Card` for each model or dataset used in your application.

<br/>

## Tutorial content

The **Hugging Face Hub** provides open-source libraries such as `Transformers`, enables integration with `Gradio`, and offers evaluation tools like `Evaluate`. However, these aspects will not be covered in this tutorial, as they are beyond the scope of this document.

Instead, this tutorial will focus on using the APIs with Delphi, highlighting key features such as image and sound classification, music generation (`music-gen`), sentiment analysis, object detection in images, image segmentation, and all natural language processing (NLP) functions.

<br/>

# Remarks

> [!IMPORTANT]
>
> This is an unofficial library. **Hugging Face** does not provide any official library for `Delphi`.
> This repository contains `Delphi` implementation over [Hugging Face](https://huggingface.co/docs/api-inference) public API.

<br/>

# Tools for simplifying this tutorial

To simplify the example codes provided in this tutorial, I have included two units in the source code: `VCL.Stability.Tutorial` and `FMX.Stability.Tutorial`. Depending on the option you choose to test the provided source code, you will need to instantiate either the `TVCLStabilitySender` or `TFMXStabilitySender` class in the application's `OnCreate` event, as follows:

>[!TIP]
>```Pascal
>//uses VCL.HuggingFace.Tutorial;
>
>  HFTutorial := TVCLHuggingFaceSender.Create(Memo1, Image1, Image2, MediaPlayer1);
>```
>
>or
>
>```Pascal
>//uses FMX.HuggingFace.Tutorial;
>
>  HFTutorial := TFMXHuggingFaceSender.Create(Memo1, Image1, Image2, MediaPlayer1);
>```
>

Make sure to add a `TMemo`, two `TImage` and a `TMediaPlayer` component to your form beforehand.

<br/>

# Asynchronous callback mode management

In the context of asynchronous methods, for a method that does not involve streaming, callbacks use the following generic record: `TAsynCallBack<T> = record` defined in the `HuggingFace.Async.Support.pas` unit. This record exposes the following properties:

```Pascal
   TAsynCallBack<T> = record
   ... 
       Sender: TObject;
       OnStart: TProc<TObject>;
       OnSuccess: TProc<TObject, T>;
       OnError: TProc<TObject, string>; 
```
<br/>

For methods requiring streaming, callbacks use the generic record `TAsynStreamCallBack<T> = record`, also defined in the `HuggingFace.Async.Support.pas` unit. This record exposes the following properties:

```Pascal
   TAsynCallBack<T> = record
   ... 
       Sender: TObject;
       OnStart: TProc<TObject>;
       OnSuccess: TProc<TObject>;
       OnProgress: TProc<TObject, T>;
       OnError: TProc<TObject, string>;
       OnCancellation: TProc<TObject>;
       OnDoCancel: TFunc<Boolean>;
```

The name of each property is self-explanatory; if needed, refer to the internal documentation for more details.

<br/>

# Exploration Journey

This part of this document is designed to reflect the path I took while uncovering the features and possibilities of `Hugging Face Hub APIs`. Rather than presenting a rigid tutorial, I chose to structure it as an **Exploration Journey** to capture the iterative, curious, and hands-on process of discovery. Each step builds on the previous one, showcasing not only what I found but how I approached and learned from the API ecosystem."


## Initialization

To initialize the API instance, you need to [obtain an API key from Hugging Face](https://huggingface.co/settings/tokens).

Once you have a token, you can initialize the `IHuggingFace` interface, which serves as the entry point to the API.

> [!NOTE]
>```Pascal
>uses HuggingFace;
>
>var HuggingFace := THuggingFaceFactory.CreateInstance(API_KEY);
>```

When accessing the `list of models` or retrieving the `description of a specific model`, a different endpoint is used than the API endpoint. To instantiate this interface, use the following code:

```Pascal
uses HuggingFace;

var HFHub := THuggingFaceFactory.CreateInstance(API_KEY, True);
```

>[!Warning]
> To use the examples provided in this tutorial, especially to work with asynchronous methods, I recommend defining the HuggingFace interface with the widest possible scope.
><br/>
> So, set `HuggingFace := THuggingFaceFactory.CreateInstance(My_Key);` in the `OnCreate` event of your application.
><br>
>Where `HuggingFace: IHuggingFace;`

<br/>

## Hugging Face Models Overview

A filtered list of models can be obtained directly from the [playground](https://huggingface.co/spaces/enzostvs/hub-api-playground) or access to search models page on [web site.](https://huggingface.co/models) 
<br/><br/>
Using **Delphi**, this list can also be retrieved programmatically. To support filtering, the `TFetchParams` class, implemented in the `HuggingFace.Hub.Support` unit, must be used. This class accurately mirrors all parameters supported by the `/api/models` endpoint.


<br/>

**Synchronously code example**

```Pascal
// uses HuggingFace, HuggingFace.Types, HuggingFace.Aggregator, FMX.HuggingFace.Tutorial; 

  var Models := HFHub.Hub.FetchModels(HFTutorial.UrlNext,
    procedure (Params: TFetchParams)
    begin
      Params.Limit(50);
      Params.Filter('eng,text-generation');
    end);
  try
    Display(HFTutorial, Models);
  finally
    Models.Free;
  end;
```

- **Remark :** A paginated result will be returned, containing 50 models per page. 
The `HFTutorial.UrlNext` variable will store the URL of the next page. By re-executing this code, the next 50 results will be retrieved and displayed.

<br/>

**Asynchronously code example**

```Pascal
// uses HuggingFace, HuggingFace.Types, HuggingFace.Aggregator, FMX.HuggingFace.Tutorial; 

  HFHub.Hub.FetchModels(HFTutorial.UrlNext,
    procedure (Params: TFetchParams)
    begin
      Params.Limit(50);
      Params.Filter('text-to-audio');
    end,
    function : TAsynModels
    begin
      Result.Sender := HFTutorial;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

>[!TIP]
> The filter parameter queries the `Tags` field in the models' JSON format. Use a comma to separate different `Tags` values to include them in the same filter.
>

<br/>

To visualize a model's data, utilize its model ID with the FetchModel method :

```Pascal
  //Synchronously
  function FetchModel(const RepoId: string): TRepoModel; overload;

  //Asynchronously
  procedure FetchModel(const RepoId: string; CallBacks: TFunc<TAsynRepoModel>); overload;
```

<br/>

### Model inference WARM COLD

The ML ecosystem evolves rapidly, and the Inference API provides access to models highly valued by the community, selected based on their recent popularity (likes, downloads, and usage). As a result, the available models may be replaced at any time without prior notice. Hugging Face strives to keep the most recent and popular models ready for immediate use.

The following distinctions are made:

- **Warm models:** models that are ready to use.
- **Cold models:** models that require loading before use.
- **Frozen models:** models currently unavailable for use via the API.

When invoking a model in the `COLD` state, it needs to be reloaded, which may result in a 503 error. In this case, you must wait before retrying the request with the same model.
To avoid the 503 error and wait for the model to reload and transition to the `WARM` state, you can add the following line of code:

```Pascal
  HuggingFace.WaitForModel := True;
```

Note : By default, the value of `WaitForModel` is set to False.

Refer to [official documentation](https://huggingface.co/docs/api-inference/parameters)

<br/>

## Music-gen

[MusicGen](https://huggingface.co/facebook/musicgen-small) is a text-to-music model capable of generating high-quality music samples conditioned on text descriptions or audio prompts.

**Asynchronously code example**

```Pascal
// uses HuggingFace, HuggingFace.Types, HuggingFace.Aggregator, FMX.HuggingFace.Tutorial; 

  HuggingFace.UseCache := False;  //Disable caching
  HuggingFace.WaitForModel := True;  //Enable waiting for model reloading
  HFTutorial.FileName := 'music.mp3';

  HuggingFace.Text.TextToAudio(
    procedure (Params: TTextToAudioParam)
    begin
      Params.Model('facebook/musicgen-small');
      Params.Inputs('Pop music style with bass guitar');
    end,
    function : TAsynTextToSpeech
    begin
      Result.Sender := HFTutorial;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

## Image object detection

For more details about the `object-detection` task, check out its [dedicated page](https://huggingface.co/tasks/object-detection)! You will find examples and related materials.

>[!NOTE]
> In the field of `Object Detection`, over 2,913 pre-trained models are available. 
>

[DEtection TRansformer (DETR) model](https://huggingface.co/facebook/detr-resnet-50) trained end-to-end on COCO 2017 object detection (118k annotated images).
The DETR model is an encoder-decoder transformer with a convolutional backbone.

**Asynchronously code example**

```Pascal
// uses HuggingFace, HuggingFace.Types, HuggingFace.Aggregator, FMX.HuggingFace.Tutorial; 

  var ImageFilePath := 'Z:\My_Folder\Images\My_Image.jpg';
  HFTutorial.LoadImageFromFile(ImageFilePath);
  HuggingFace.WaitForModel := True;

  HuggingFace.Image.ObjectDetection(
    procedure (Params: TObjectDetectionParam)
    begin
      Params.Model('facebook/detr-resnet-50');
      Params.Inputs(ImageFilePath);
    end,
    function : TAsynObjectDetection
    begin
      Result.Sender := HFTutorial;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

![Object detection](/../main/images/ObjectDetection.png?raw=true "Object detection")

<br/>

## Text To Sentiment analysis

This is a [RoBERTa-base model](https://huggingface.co/cardiffnlp/twitter-roberta-base-sentiment-latest) trained on ~124M tweets from January 2018 to December 2021, and finetuned for sentiment analysis with the TweetEval benchmark. 

- **Reference Paper:** [TimeLMs paper](https://arxiv.org/abs/2202.03829).
- **Git Repo:** [TimeLMs official repository](https://github.com/cardiffnlp/timelms).

Labels: 0 -> Negative; 1 -> Neutral; 2 -> Positive

**Asynchronously code example**

```Pascal
// uses HuggingFace, HuggingFace.Types, HuggingFace.Aggregator, FMX.HuggingFace.Tutorial; 

  HuggingFace.WaitForModel := True;

  HuggingFace.Text. SentimentAnalysis(
    procedure (Params: TSentimentAnalysisParams)
    begin
      Params.Model('cardiffnlp/twitter-roberta-base-sentiment-latest');
      Params.Inputs('Today is a great day');
    end,
    function : TAsynSentimentAnalysis
    begin
      Result.Sender := HFTutorial;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

## Audio classification

For more details about the `audio-classification` task, check out its [dedicated page](https://huggingface.co/tasks/audio-classification)! You will find examples and related materials.

<br/>

>[!NOTE]
> In the field of `Audio Classification`, over 2,859 pre-trained models are available. 
>

### Speech emotion recognition

[Speech Emotion Recognition By Fine-Tuning Wav2Vec 2.0](https://huggingface.co/ehcalabres/wav2vec2-lg-xlsr-en-speech-emotion-recognition) <br/>
The model is a fine-tuned version of `jonatasgrosman/wav2vec2-large-xlsr-53-english` for a Speech Emotion Recognition (SER) task.

The dataset used to fine-tune the original pre-trained model is the RAVDESS dataset. This dataset provides 1440 samples of recordings from actors performing on 8 different emotions in English, which are:

```Python
  emotions = ['angry', 'calm', 'disgust', 'fearful', 'happy', 'neutral', 'sad', 'surprised']
```

**Asynchronously code example**

```Pascal
// uses HuggingFace, HuggingFace.Types, HuggingFace.Aggregator, FMX.HuggingFace.Tutorial; 

  HuggingFace.WaitForModel := True;

  HuggingFace.Audio.Classification(
    procedure (Params: TAudioClassificationParam)
    begin
      Params.Model('ehcalabres/wav2vec2-lg-xlsr-en-speech-emotion-recognition');
      Params.Inputs('SpeechRecorded.wav');
    end,
    function : TAsynAudioClassification
    begin
      Result.Sender := HFTutorial;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

### Gender recognition

[wav2vec2-large-xlsr-53-gender-recognition-librispeech](https://huggingface.co/alefiury/wav2vec2-large-xlsr-53-gender-recognition-librispeech) <br/><br/>
This model is a fine-tuned version of facebook/wav2vec2-xls-r-300m on Librispeech-clean-100 for gender recognition.

**Asynchronously code example**

```Pascal
// uses HuggingFace, HuggingFace.Types, HuggingFace.Aggregator, FMX.HuggingFace.Tutorial; 

  HuggingFace.WaitForModel := True;

  HuggingFace.Audio.Classification(
    procedure (Params: TAudioClassificationParam)
    begin
      Params.Model('alefiury/wav2vec2-large-xlsr-53-gender-recognition-librispeech');
      Params.Inputs('SpeechRecorded.wav');
    end,
    function : TAsynAudioClassification
    begin
      Result.Sender := HFTutorial;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

## Image classification

For more details about the `image-classification` task, check out its [dedicated page](https://huggingface.co/tasks/image-classification)! You will find examples and related materials.

>[!NOTE]
> In the field of `image classification`, over 15,000 pre-trained models are available.
>

[ResNet-50 v1.5](https://huggingface.co/microsoft/resnet-50) <br/>
ResNet model pre-trained on ImageNet-1k at resolution 224x224. It was introduced in the paper [Deep Residual Learning for Image Recognition](https://arxiv.org/abs/1512.03385) by He et al.

ResNet (Residual Network) is a convolutional neural network that democratized the concepts of residual learning and skip connections. This enables to train much deeper models.

**Asynchronously code example**

```Pascal
// uses HuggingFace, HuggingFace.Types, HuggingFace.Aggregator, FMX.HuggingFace.Tutorial; 

  var ImageFilePath := 'images\tiger.jpg';
  HFTutorial.LoadImageFromFile(ImageFilePath);
  HuggingFace.WaitForModel := True;

  HuggingFace.Image.Classification(
    procedure (Params: TImageClassificationParam)
    begin
      Params.Model('microsoft/resnet-50');
      //Params.Model('google/vit-base-patch16-224');  //Can be used too
      Params.Inputs(ImageFilePath);
    end,
    function : TAsynImageClassification
    begin
      Result.Sender := HFTutorial;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

[Vision Transformer (base-sized model)](https://huggingface.co/google/vit-base-patch16-224)
Vision Transformer (ViT) model pre-trained on ImageNet-21k (14 million images, 21,843 classes) at resolution 224x224, and fine-tuned on ImageNet 2012 (1 million images, 1,000 classes) at resolution 224x224. It was introduced in the paper An Image is Worth 16x16 Words: [Transformers for Image Recognition at Scale](https://arxiv.org/abs/2010.11929) by Dosovitskiy et al. and first released in this repository. 

<br/>

## Image Segmentation

For more details about the `image-segmentation` task, check out its [dedicated page](https://huggingface.co/tasks/image-segmentation)! You will find examples and related materials.

>[!NOTE]
> In the field of `image segmentation`, over 1,093 pre-trained models are available. Each model is distinguished by specific skills.
>

[openmmlab/upernet-convnext-small](https://huggingface.co/openmmlab/upernet-convnext-small) <br/>
UperNet framework for semantic segmentation, leveraging a ConvNeXt backbone. UperNet was introduced in the paper [Unified Perceptual Parsing for Scene Understanding](https://arxiv.org/abs/1807.10221) by Xiao et al.

**Asynchronously code example**

```Pascal
// uses HuggingFace, HuggingFace.Types, HuggingFace.Aggregator, FMX.HuggingFace.Tutorial; 

  var ImageFilePath := 'images\tiger.jpg';
  HFTutorial.LoadImageFromFile(ImageFilePath);
  HuggingFace.WaitForModel := True;

  HuggingFace.Image.Segmentation(
    procedure (Params: TImageSegmentationParam)
    begin
      Params.Model('openmmlab/upernet-convnext-small');
      Params.Inputs(ImageFilePath);
    end,
    function : TAsynImageSegmentation
    begin
      Result.Sender := HFTutorial;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

![Image segmentation](/../main/images/ImageSegmentation.png?raw=true "Image segmentation")

<br/>

Other models that you can easily test. It is up to you to choose the most suitable image:
- [jonathandinu/face-parsing](https://huggingface.co/jonathandinu/face-parsing)
- [nvidia/segformer-b1-finetuned-cityscapes-1024-1024](https://huggingface.co/nvidia/segformer-b1-finetuned-cityscapes-1024-1024)
- [google/deeplabv3_mobilenet_v2_1.0_513](https://huggingface.co/google/deeplabv3_mobilenet_v2_1.0_513)
- [facebook/mask2former-swin-large-cityscapes-semantic](https://huggingface.co/facebook/mask2former-swin-large-cityscapes-semantic)

<br/>

## Zero-Shot classification

For more details about the `zero-shot-classification` task, check out its [dedicated page](https://huggingface.co/tasks/zero-shot-classification)! You will find examples and related materials.

>[!NOTE]
> In the field of `Zero-shot classification`, over 337 pre-trained models are available. 
>

[facebook/bart-large-mnli](https://huggingface.co/facebook/bart-large-mnli) <br/>
This is the checkpoint for bart-large after being trained on the MultiNLI (MNLI) dataset.

Additional information about this model:
- The [bart-large](https://huggingface.co/facebook/bart-large) model page
- BART: [Denoising Sequence-to-Sequence Pre-training for Natural Language Generation, Translation, and Comprehension](https://arxiv.org/abs/1910.13461)

**Asynchronously code example**

```Pascal
// uses HuggingFace, HuggingFace.Types, HuggingFace.Aggregator, FMX.HuggingFace.Tutorial; 

  HuggingFace.WaitForModel := True;

  HuggingFace.Text.ZeroShotClassification(
    procedure (Params: TZeroShotClassificationParam)
    begin
      Params.Model('facebook/bart-large-mnli');
      Params.Inputs('Hi, I recently bought a device from your company but it is not working as advertised and I would like to get reimbursed!');
      Params.Parameters(
        procedure (var Params: TZeroShotClassificationParameters)
        begin
          Params.CandidateLabels(['refund', 'legal', 'faq'])
        end);
    end,
    function : TAsynZeroShotClassification
    begin
      Result.Sender := HFTutorial;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

Other models that you can easily test.
- [valhalla/distilbart-mnli-12-9](https://huggingface.co/valhalla/distilbart-mnli-12-9)
- [MoritzLaurer/mDeBERTa-v3-base-mnli-xnli](https://huggingface.co/MoritzLaurer/mDeBERTa-v3-base-mnli-xnli)

<br/>

## Token Classification

For more details about the `token-classification` task, check out its [dedicated page](https://huggingface.co/tasks/token-classification)! You will find examples and related materials.

>[!NOTE]
> In the field of `Zero-shot classification`, over 20,755 pre-trained models are available. 
>

[FacebookAI/xlm-roberta-large-finetuned-conll03-english](https://huggingface.co/FacebookAI/xlm-roberta-large-finetuned-conll03-english) <br/>
The model can be used for token classification, a natural language understanding task in which a label is assigned to some tokens in a text. <br/>
See [associated paper](https://arxiv.org/abs/1911.02116)

**Asynchronously code example**

```Pascal
// uses HuggingFace, HuggingFace.Types, HuggingFace.Aggregator, FMX.HuggingFace.Tutorial; 

  HuggingFace.WaitForModel := True;

  HuggingFace.Text.TokenClassification(
    procedure (Params: TTokenClassificationParam)
    begin
      Params.Model('FacebookAI/xlm-roberta-large-finetuned-conll03-english');
      //Params.Model('dslim/bert-base-NER');  //Can be used too
      Params.Inputs('My name is Sarah Jessica Parker but you can call me Jessica');
    end,
    function : TAsynTokenClassification
    begin
      Result.Sender := HFTutorial;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

## Question Answering

For more details about the `question-answering` task, check out its [dedicated page](https://huggingface.co/tasks/question-answering)! You will find examples and related materials.

>[!NOTE]
> In the field of `Question Answering`, over 12,683 pre-trained models are available. 
>

[deepset/roberta-base-squad2](https://huggingface.co/deepset/roberta-base-squad2) <br/>
This is the [roberta-base model](https://huggingface.co/FacebookAI/roberta-base), fine-tuned using the [SQuAD2.0 dataset](https://huggingface.co/datasets/rajpurkar/squad_v2). It's been trained on question-answer pairs, including unanswerable questions, for the task of Extractive Question Answering. <br/>
See [associated paper](https://arxiv.org/abs/1907.11692)

<br/>

**Asynchronously code example**

```Pascal
// uses HuggingFace, HuggingFace.Types, HuggingFace.Aggregator, FMX.HuggingFace.Tutorial; 

  HuggingFace.WaitForModel := True;

  HuggingFace.Text.QuestionAnswering(
    procedure (Params: TQuestionAnsweringParam)
    begin
      Params.Model('deepset/roberta-base-squad2');
      Params.Inputs('What is my name?', 'My name is Clara and I live in Berkeley.');
      Params.Parameters(
        procedure (var Params: TQuestionAnsweringParameters)
        begin
          Params.TopK(3);
        end);
    end,
    function : TAsynQuestionAnswering
    begin
      Result.Sender := HFTutorial;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

## Table Question Answering

For more details about the `table-question-answering` task, check out its [dedicated page](https://huggingface.co/tasks/table-question-answering)! You will find examples and related materials.

>[!NOTE]
> In the field of `Table Question Answering`, over 133 pre-trained models are available. 
>

<br/>

[google/tapas-base-finetuned-wtq](https://huggingface.co/google/tapas-base-finetuned-wtq) <br/>
[TAPAS](https://github.com/google-research/tapas) is a BERT-like transformers model pretrained on a large corpus of English data from Wikipedia in a self-supervised fashion. This means it was pretrained on the raw tables and associated texts only, with no humans labelling them in any way (which is why it can use lots of publicly available data) with an automatic process to generate inputs and labels from those texts. 


**Asynchronously code example**

```Pascal
// uses HuggingFace, HuggingFace.Types, HuggingFace.Aggregator, FMX.HuggingFace.Tutorial; 

  HuggingFace.WaitForModel := True;

  HuggingFace.Text.TableQuestionAnswering(
    procedure (Params: TTableQAParam)
    begin
      Params.Model('google/tapas-base-finetuned-wtq');
      Params.Inputs(
        'How many stars does the tokenizers repository have?',
        [ TRow.Create('Repository', ['Transformers', 'Datasets', 'Tokenizers']),
          TRow.Create('Stars', ['36542', '4512', '3934']),
          TRow.Create('Contributors', ['651', '77', '34']),
          TRow.Create('Programming language',
             [ 'Python',
               'Python',
               'Rust, Python and NodeJS'
             ])
        ]);
    end,
    function : TAsynTableQA
    begin
      Result.Sender := HFTutorial;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

## Fill-mask

For more details about the `fill-mask` task, check out its [dedicated page](https://huggingface.co/tasks/fill-mask)! You will find examples and related materials.

>[!NOTE]
> In the field of `Fill-mask`, over 13,570 pre-trained models are available. 
>

[google-bert/bert-base-uncased](https://huggingface.co/google-bert/bert-base-uncased) <br/>
Pretrained model on English language using a masked language modeling (MLM) objective. It was introduced in [this paper](https://arxiv.org/abs/1810.04805) and first released in [this repository](https://github.com/google-research/bert). This model is uncased: it does not make a difference between english and English.

<br/>


**Asynchronously code example**

```Pascal
// uses HuggingFace, HuggingFace.Types, HuggingFace.Aggregator, FMX.HuggingFace.Tutorial; 

  HuggingFace.API.WaitForModel := True;

  HuggingFace.Mask.Fill(
    procedure (Params: TMaskParam)
    begin
      Params.Model('google-bert/bert-base-uncased');
      Params.Inputs('The answer to the universe is [MASK].');
      Params.Parameters(['infinite', 'big', 'amazing', 'no', '42']);
    end,
    function : TAsynMask
    begin
      Result.Sender := HFTutorial;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

## Text Classification

For more details about the `text-classification` task, check out its [dedicated page](https://huggingface.co/tasks/text-classification)! You will find examples and related materials.

>[!NOTE]
> In the field of `Text Classification`, over 77,280 pre-trained models are available. 
>

<br/>

[distilbert/distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert/distilbert-base-uncased-finetuned-sst-2-english) <br/>
This model is a fine-tune checkpoint of DistilBERT-base-uncased, fine-tuned on SST-2. This model reaches an accuracy of 91.3 on the dev set (for comparison, Bert bert-base-uncased version reaches an accuracy of 92.7). <br/>
For more details about DistilBERT, we encourage to check out this [model card](https://huggingface.co/distilbert/distilbert-base-uncased).

**Asynchronously code example**

```Pascal
// uses HuggingFace, HuggingFace.Types, HuggingFace.Aggregator, FMX.HuggingFace.Tutorial; 

  HuggingFace.WaitForModel := True;

  HuggingFace.Text.TextClassification(
    procedure (Params: TTextClassificationParam)
    begin
      Params.Model('distilbert/distilbert-base-uncased-finetuned-sst-2-english');
      Params.Inputs('I like you. I love you.');
    end,
    function : TAsynTextClassification
    begin
      Result.Sender := HFTutorial;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```
This code example returns positive or negative depending on the meaning of the prompt.

- Use the model : [papluca/xlm-roberta-base-language-detection](https://huggingface.co/papluca/xlm-roberta-base-language-detection) as a language detector.
- Use the model: [cardiffnlp/twitter-roberta-base-sentiment-latest](https://huggingface.co/cardiffnlp/twitter-roberta-base-sentiment-latest) for sentiment analysis.

<br/>

## Summarization

Summarization is the task of producing a shorter version of a document while preserving its important information. Some models can extract text from the original input, while other models can generate entirely new text.

For more details about the `summarization` task, check out its [dedicated page](https://huggingface.co/tasks/summarization)! You will find examples and related materials.

>[!NOTE]
> In the field of `Summarization`, over 2,130 pre-trained models are available. 
>

<br/>

[facebook/bart-large-cnn](https://huggingface.co/facebook/bart-large-cnn) <br/>
BART is a transformer encoder-encoder (seq2seq) model with a bidirectional (BERT-like) encoder and an autoregressive (GPT-like) decoder. BART is pre-trained by (1) corrupting text with an arbitrary noising function, and (2) learning a model to reconstruct the original text.

**Asynchronously code example**

```Pascal
// uses HuggingFace, HuggingFace.Types, HuggingFace.Aggregator, FMX.HuggingFace.Tutorial; 

  HuggingFace.WaitForModel := True;

  HuggingFace.Text.Summarization(
    procedure (Params: TSummarizationParam)
    begin
      Params.Model('facebook/bart-large-cnn');
      Params.Inputs('The tower is 324 metres (1,063 ft) tall, about the same height as an 81-storey building, and the tallest structure in Paris. Its base is square, measuring 125 metres (410 ft) on each side. During its construction, the Eiffel Tower surpassed the Washington Monument to become the tallest man-made structure in the world, a title it held for 41 years until the Chrysler Building in New York City was finished in 1930. It was the first structure to reach a height of 300 metres. Due to the addition of a broadcasting aerial at the top of the tower in 1957, it is now taller than the Chrysler Building by 5.2 metres (17 ft). Excluding transmitters, the Eiffel Tower is the second tallest free-standing structure in France after the Millau Viaduct.');
    end,
    function : TAsynSummarization
    begin
      Result.Sender := HFTutorial;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

# Common Ground Functionalities Across API Ecosystems

In the previous chapter, **Exploration Journey**, I walked through the unique features of `Hugging Face Hub APIs`, focusing on what makes them stand out. As I kept exploring, I noticed some strong overlaps with other platforms like `OpenAI`, `Anthropic`, and `Gemini`. That’s where Common Ground comes in. This chapter is about zooming out to look at those shared functionalities and seeing how these ecosystems stack up against each other. By focusing on what they have in common, we can get a clearer picture of the API landscape as a whole.

<br/>

## Embeddings

Feature extraction is the task of converting a text into a vector (often called “embedding”).

**Example applications:**
- Retrieving the most relevant documents for a query (for RAG applications).
- Reranking a list of documents based on their similarity to a query.
- Calculating the similarity between two sentences.

For more details about the `Embeddings` task, check out its [dedicated page](https://huggingface.co/tasks/feature-extraction)! You will find examples and related materials.

>[!NOTE]
> In the field of `Embeddings` over 7,400 pre-trained models are available. 
>

<br/>

[mixedbread-ai/mxbai-embed-large-v1](https://huggingface.co/mixedbread-ai/mxbai-embed-large-v1) : Produce sentence embeddings.

**Asynchronously code example**

```Pascal
// uses HuggingFace, HuggingFace.Types, HuggingFace.Aggregator, FMX.HuggingFace.Tutorial; 

  HuggingFace.API.WaitForModel := True;

  HuggingFace.Embeddings.Create(
    procedure (Params: TEmbeddingParams)
    begin
      Params.Model('mixedbread-ai/mxbai-embed-large-v1');
      Params.Inputs('Today is a sunny day and I will get some ice cream.');
    end,
    function : TAsynEmbeddings
    begin
      Result.Sender := HFTutorial;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

## Chat

Generate responses in a conversational context using a list of messages as input. This capability supports both conversational Language Models (LLMs) and Vision-Language Models (VLMs), bridging text-based and `image-to-text` functionalities. It is a specialized subtask within [`text generation`](https://huggingface.co/docs/api-inference/tasks/text-generation) and [`image-text-to-text`](https://huggingface.co/docs/api-inference/tasks/image-text-to-text) processing.

Recommended Models :

Conversational Large Language Models (LLMs)
- [google/gemma-2-2b-it](https://huggingface.co/google/gemma-2-2b-it): A robust text-generation model optimized for instruction following.
- [meta-llama/Meta-Llama-3.1-8B-Instruct](https://huggingface.co/meta-llama/Llama-3.1-8B-Instruct): A highly capable model for generating text and adhering to instructions.
- [microsoft/Phi-3-mini-4k-instruct](https://huggingface.co/microsoft/Phi-3-mini-4k-instruct): A compact yet efficient text-generation model.
- [Qwen/Qwen2.5-7B-Instruct](https://huggingface.co/Qwen/Qwen2.5-7B-Instruct): A reliable model for text generation and instruction compliance.

Conversational Vision-Language Models (VLMs)
- [meta-llama/Llama-3.2-11B-Vision-Instruct](https://huggingface.co/meta-llama/Llama-3.2-11B-Vision-Instruct): A powerful vision-language model with excellent capabilities in visual comprehension and reasoning.
- [Qwen/Qwen2-VL-7B-Instruct](https://huggingface.co/Qwen/Qwen2-VL-7B-Instruct): A strong model designed for image-text-to-text tasks.

<br/>

### Multi Turn Conversation

Generate text based on a prompt. For more details about the `text-generation` task, check out its [dedicated page](https://huggingface.co/tasks/text-generation)! You will find examples and related materials.

>[!NOTE]
> In the field of `text-generation` over 163,600 pre-trained models are available. 
>

**Synchronously code example**

```Pascal
// uses HuggingFace, HuggingFace.Types, HuggingFace.Aggregator, FMX.HuggingFace.Tutorial; 

  HuggingFace.UseCache := False;

  var Chat := HuggingFace.Chat.Completion(
    procedure (Params: TChatPayload)
    begin
      Params.Model('microsoft/Phi-3-mini-4k-instruct');
      Params.Messages([
         TPayload.User('Hello'),
         TPayload.Assistant('Great to meet you. What would you like to know?'),
         TPayload.User('I have two dogs in my house. How many paws are in my house?')
      ]);
      Params.MaxTokens(1024);
    end);
  try
    Display(Memo1, Chat);
  finally
    Chat.Free;
  end;
```

<br/>

**Asynchronously code example**

```Pascal
// uses HuggingFace, HuggingFace.Types, HuggingFace.Aggregator, FMX.HuggingFace.Tutorial; 

  HuggingFace.UseCache := False;

  HuggingFace.Chat.Completion(
    procedure (Params: TChatPayload)
    begin
      Params.Model('microsoft/Phi-3-mini-4k-instruct');
      Params.Messages([
         TPayload.User('Hello'),
         TPayload.Assistant('Great to meet you. What would you like to know?'),
         TPayload.User('I have two dogs in my house. How many paws are in my house?')
      ]);
      Params.MaxTokens(1024);
    end,
    function : TAsynChat
    begin
      Result.Sender := HFTutorial;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

### Streamed Multi Turn Conversation

**Synchronously code example**

```Pascal
// uses HuggingFace, HuggingFace.Types, HuggingFace.Aggregator, FMX.HuggingFace.Tutorial; 
  
  HuggingFace.UseCache := False;

  HuggingFace.Chat.CompletionStream(
    procedure (Params: TChatPayload)
    begin
      Params.Model('microsoft/Phi-3.5-mini-instruct');
      Params.Messages([
         TPayload.User('Hello'),
         TPayload.Assistant('Great to meet you. What would you like to know?'),
         TPayload.User('I have two dogs in my house. How many paws are in my house?')
      ]);
      Params.Stream(True);
      Params.MaxTokens(1024);
    end,
    procedure (var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
    begin
      if Assigned(Chat) and not IsDone then
        begin
          DisplayStream(HFTutorial, Chat);
          Application.ProcessMessages;
        end;
    end);
```

<br/>

**Asynchronously code example**

```Pascal
// uses HuggingFace, HuggingFace.Types, HuggingFace.Aggregator, FMX.HuggingFace.Tutorial; 

  HuggingFace.UseCache := False;

  HuggingFace.Chat.CompletionStream(
    procedure (Params: TChatPayload)
    begin
      Params.Model('microsoft/Phi-3.5-mini-instruct');
      Params.Messages([
         TPayload.User('Hello'),
         TPayload.Assistant('Great to meet you. What would you like to know?'),
         TPayload.User('I have two dogs in my house. How many paws are in my house?')
      ]);
      Params.Stream(True);
      Params.MaxTokens(1024);
    end,
    function : TAsynChatStream
    begin
      Result.Sender := HFTutorial;
      Result.OnProgress := DisplayStream;
      Result.OnError := DisplayStream;
    end);  
```

<br/>

### Vision

Models that combine image and text inputs, often referred to as `vision-language` models (VLMs), generate text outputs based on both an image and a text prompt. Unlike traditional `image-to-text` models, which are primarily designed for specific tasks like image captioning, VLMs incorporate an additional layer of versatility by accepting text prompts. Some of these models are even trained to process entire conversations as input, enabling a broader range of applications.

For more details about the `image-text-to-text` task, check out its [dedicated page](https://huggingface.co/tasks/image-text-to-text)! You will find examples and related materials.

>[!NOTE]
> In the field of `image-text-to-text` over 5,750 pre-trained models are available. 
>

<br/>

**Synchronously streamed code example**

```Pascal
// uses HuggingFace, HuggingFace.Types, HuggingFace.Aggregator, FMX.HuggingFace.Tutorial; 

  HuggingFace.UseCache := False;
  var ImageFilePath := 'https://tripfixers.com/wp-content/uploads/2019/11/eiffel-tower-with-snow.jpeg';

  HuggingFace.Chat.CompletionStream(
    procedure (Params: TChatPayload)
    begin
      Params.Model('meta-llama/Llama-3.2-11B-Vision-Instruct');
      Params.Messages([TPayload.User('Describe the image ?', [ImageFilePath])]);
      Params.Stream(True);
      Params.MaxTokens(1024);
    end,
    procedure (var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
    begin
      if Assigned(Chat) and not IsDone then
        begin
          DisplayStream(HFTutorial, Chat);
          Application.ProcessMessages;
        end;
    end);
```

<br/>

**Asynchronously streamed code example**

```Pascal
// uses HuggingFace, HuggingFace.Types, HuggingFace.Aggregator, FMX.HuggingFace.Tutorial; 

  HuggingFace.UseCache := False;
  var ImageFilePath := 'https://tripfixers.com/wp-content/uploads/2019/11/eiffel-tower-with-snow.jpeg';
  
    HuggingFace.Chat.CompletionStream(
    procedure (Params: TChatPayload)
    begin
      Params.Model('meta-llama/Llama-3.2-11B-Vision-Instruct');
      Params.Messages([TPayload.User('Describe the image ?', [ImageFilePath])]);
      Params.Stream(True);
      Params.MaxTokens(1024);
    end,
    function : TAsynChatStream
    begin
      Result.Sender := HFTutorial;
      Result.OnProgress := DisplayStream;
      Result.OnError := DisplayStream;
    end);
```

<br/>

### Use tools

What is the weather in Paris ?

The tool schema used :
```Json
  {
    "type": "object",
    "properties": {
         "location": {
             "type": "string",
             "description": "The city and department, e.g. Marseille, 13"
         },
         "unit": {
             "type": "string",
             "enum": ["celsius", "fahrenheit"]
         }
     },
     "required": ["location"]
  }
```

<br/>

1. We will use the `TWeatherReportFunction` plugin defined in the `HuggingFace.Functions.Example` unit.

```Delphi
  var Weather: IFunctionCore := TWeatherReportFunction.Create;
```

2. We then define a method to display the result of the query using the `Weather` tool.

```Delphi
procedure TMyForm.FuncExecuteStream(Sender: TObject; Text: string);
begin
  HuggingFace.WaitForModel := True;
  HuggingFace.UseCache := False;
  HuggingFace.Chat.CompletionStream(
    procedure (Params: TChatPayload)
    begin
      Params.Model('mistralai/Mixtral-8x7B-Instruct-v0.1');
      Params.Messages([
        TPayload.System('You are a fun and entertaining weather presenter.'),
        TPayload.User(Text)]);
      Params.Stream(True);
      Params.MaxTokens(1024);
    end,
    function : TAsynChatStream
    begin
      Result.Sender := HFTutorial;
      Result.OnProgress := DisplayStream;
      Result.OnError := DisplayStream;
    end);
end;
```

3. Building the query using the `Weather` tool

**Synchronously code example**

```Pascal
// uses HuggingFace, HuggingFace.Types, HuggingFace.Aggregator, FMX.HuggingFace.Tutorial, HuggingFace.Functions.Example; 

  HuggingFace.WaitForModel := True;
  var Weather: IFunctionCore := TWeatherReportFunction.Create;
  HFTutorial.Func := Weather;
  HFTutorial.FuncProc := FuncExecuteStream;

  var Chat := HuggingFace.Chat.Completion(
    procedure (Params: TChatPayload)
    begin
      Params.Model('mistralai/Mixtral-8x7B-Instruct-v0.1');
      Params.Messages([TPayload.User('What is the weather in Paris ?')]);
      Params.Tools([Weather]);
      Params.MaxTokens(1024);
    end);
  try
    Display(Memo1, Chat);
  finally
    Chat.Free;
  end;
```

<br/>

**Asynchronously code example**

```Pascal
// uses HuggingFace, HuggingFace.Types, HuggingFace.Aggregator, FMX.HuggingFace.Tutorial, HuggingFace.Functions.Example; 

  HuggingFace.WaitForModel := True;
  var Weather: IFunctionCore := TWeatherReportFunction.Create;
  HFTutorial.Func := Weather;
  HFTutorial.FuncProc := FuncExecuteStream;

  HuggingFace.Chat.Completion(
    procedure (Params: TChatPayload)
    begin
      Params.Model('mistralai/Mixtral-8x7B-Instruct-v0.1');
      Params.Messages([TPayload.User('What is the weather in Paris ?')]);
      Params.Tools([Weather]);
      Params.MaxTokens(1024);
    end,
    function : TAsynChat
    begin
      Result.Sender := HFTutorial;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

## Text Generation

Generate text based on a prompt.

If you are interested in a Chat Completion task, which generates a response based on a list of messages, check out the [`chat-completion`](#Chat) task.

For more details about the `text-generation` task, check out its [dedicated page](https://huggingface.co/tasks/text-generation)! You will find examples and related materials.

<br/>

**Synchronously code example**

```Pascal
// uses HuggingFace, HuggingFace.Types, HuggingFace.Aggregator, FMX.HuggingFace.Tutorial;

  HuggingFace.WaitForModel := True;
  HuggingFace.UseCache := False;

  var Generation := HuggingFace.Text.Generation(
    procedure (Params: TTextGenerationParam)
    begin
      Params.Model('google/gemma-2-2b-it');
      Params.Inputs('Can you please let us know more details about your');
      Params.Parameters(
        procedure (var Params: TTextGenerationParameters)
        begin
          Params.MaxNewTokens(1024);
          Params.DoSample(True);
          Params.DecoderInputDetails(True);
        end);
    end);
  try
    Display(HFTutorial, Generation);
  finally
    Generation.Free;
  end;
```

<br/>

**Asynchronously code example**

```Pascal
// uses HuggingFace, HuggingFace.Types, HuggingFace.Aggregator, FMX.HuggingFace.Tutorial;

  HuggingFace.WaitForModel := True;
  HuggingFace.UseCache := False;

  HuggingFace.Text.Generation(
    procedure (Params: TTextGenerationParam)
    begin
      Params.Model('google/gemma-2-2b-it');
      Params.Inputs('Can you please let us know more details about your');
      Params.Parameters(
        procedure (var Params: TTextGenerationParameters)
        begin
          Params.MaxNewTokens(1024);
          Params.DoSample(True);
          Params.DecoderInputDetails(True);
        end);
    end,
    function : TAsynTextGeneration
    begin
      Result.Sender := HFTutorial;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

**Asynchronously streamed code example**

```Pascal
// uses HuggingFace, HuggingFace.Types, HuggingFace.Aggregator, FMX.HuggingFace.Tutorial;

  HuggingFace.WaitForModel := True;
  HuggingFace.UseCache := False;

  HuggingFace.Text.GenerationStream(
    procedure (Params: TTextGenerationParam)
    begin
      Params.Model('google/gemma-2-2b-it');
      Params.Inputs('Can you please let us know more details about your');
      Params.Stream(True);
    end,
    function : TAsynTextGenerationStream
    begin
      Result.Sender := HFTutorial;
      Result.OnProgress := DisplayStream;
      Result.OnError := Display;
    end);
```

<br/>

## Translation

Translation is the task of converting text from one language to another.

For more details about the `translation` task, check out its [dedicated page](https://huggingface.co/tasks/translation)! You will find examples and related materials.

>[!NOTE]
> In the field of `translation` over 5,079 pre-trained models are available. 
>

<br>

**Asynchronously code example**

```Pascal
// uses HuggingFace, HuggingFace.Types, HuggingFace.Aggregator, FMX.HuggingFace.Tutorial;

  HuggingFace.WaitForModel := True;

  //French to english translation
  HuggingFace.Text.Translation(
    procedure (Params: TTranslationParam)
    begin
      Params.Model('Helsinki-NLP/opus-mt-fr-en');
      Params.Inputs('Je n''aurais pas dû abuser du chocolat, je crois que je vais le regretter.');
      Params.Parameters(
        procedure (var Params: TTranslationParameters)
        begin
          Params.SrcLang('french');
          Params.TgtLang('english');
        end);
    end,
    function : TAsynTranslation
    begin
      Result.Sender := HFTutorial;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

## Image Generation

Generate an image based on a given text prompt.

For more details about the `text-to-image` task, check out its [dedicated page](https://huggingface.co/tasks/text-to-image)! You will find examples and related materials.

>[!NOTE]
> In the field of `text-to-image` over 50,539 pre-trained models are available. 
>

<br/>

**Asynchronously code example**

```Pascal
// uses HuggingFace, HuggingFace.Types, HuggingFace.Aggregator, FMX.HuggingFace.Tutorial;

  HuggingFace.WaitForModel := True;
  HuggingFace.API.UseCache := False;
  HFTutorial.FileName := 'Quarter.png';

  HuggingFace.Text.TextToImage(
    procedure (Params: TTextToImageParam)
    begin
      Params.Model('stabilityai/stable-diffusion-3-medium-diffusers');
      Params.Inputs('A quarter dollar coin placed on a wooden floor in a close-up view');
    end,
    function : TAsynTextToImage
    begin
      Result.Sender := HFTutorial;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

## Text-to-Speech

Convert a text to an audio speech.

>[!NOTE]
> In the field of `text-to-speech` over 2,273 pre-trained models are available. 
>

<br/>

**Asynchronously code example**

```Pascal
// uses HuggingFace, HuggingFace.Types, HuggingFace.Aggregator, FMX.HuggingFace.Tutorial;

  HFTutorial.FileName := 'temp.mp3';
  HuggingFace.WaitForModel := True;

  HuggingFace.Text.TextToSpeech(
    procedure (Params: TTextToSpeechParam)
    begin
      Params.Model('facebook/mms-tts-eng');
      Params.Inputs('Hello and welcome. It''s nice to meet you.');
    end,
    function : TAsynTextToSpeech
    begin
      Result.Sender := HFTutorial;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

## Automatic Speech Recognition

Automatic Speech Recognition (ASR), often referred to as Speech to Text (STT), involves converting spoken audio into written text.

Use Cases:
- Converting a podcast into text format
- Creating a voice assistant system
- Producing subtitles for video content

For more details about the `automatic-speech-recognition` task, check out its [dedicated page](https://huggingface.co/tasks/automatic-speech-recognition)! You will find examples and related materials.

>[!NOTE]
> In the field of `speech-to-text` over 21,386 pre-trained models are available. 
>

Suggested Models:
- [openai/whisper-large-v3](https://huggingface.co/openai/whisper-large-v3): An advanced ASR model developed by OpenAI.
- [nvidia/canary-1b](https://huggingface.co/nvidia/canary-1b): A robust model supporting multilingual ASR and speech translation, designed by Nvidia.
- [pyannote/speaker-diarization-3.1](https://huggingface.co/pyannote/speaker-diarization-3.1): A highly effective model for distinguishing and labeling different speakers in audio recordings.

<br/>

**Asynchronously code example**

```Pascal
// uses HuggingFace, HuggingFace.Types, HuggingFace.Aggregator, FMX.HuggingFace.Tutorial;

  HuggingFace.API.WaitForModel := True;

  HuggingFace.Audio.AudioToText(
    procedure (Params: TAudioToTextParam)
    begin
      Params.Model('openai/whisper-large-v3-turbo');
      Params.Inputs('SpeechRecorded.wav');
      Params.GenerationParameters(
        procedure (var Params: TGenerationParameters)
        begin
          Params.MaxLength(10);
        end);
    end,
    function : TAsynAudioToText
    begin
      Result.Sender := HFTutorial;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```
Remark: To run this example, you must first record some speech text in a file named `SpeechRecorded.wav`.

# Contributing

Pull requests are welcome. If you're planning to make a major change, please open an issue first to discuss your proposed changes.

<br/>

# License

This project is licensed under the [MIT](https://choosealicense.com/licenses/mit/) License.

unit FMX.HuggingFace.Tutorial;

{ Tutorial Support Unit

   WARNING:
     This module is intended solely to illustrate the examples provided in the
     README.md file of the repository :
         https://github.com/MaxiDonkey/DelphiHuggingFace
     Under no circumstances should the methods described below be used outside
     of the examples presented on the repository's page.
}

interface

uses
  System.SysUtils, System.Classes, Winapi.Messages, FMX.Types, FMX.StdCtrls, FMX.ExtCtrls,
  FMX.Controls, FMX.Forms, Winapi.Windows, FMX.Graphics, FMX.Dialogs, FMX.Memo.Types,
  FMX.Media, FMX.Objects, FMX.Controls.Presentation, FMX.ScrollBox, FMX.Memo, System.UITypes,
  System.Types,
  HuggingFace.Types, HuggingFace.Aggregator;

type
  TToolFunc = procedure (Sender: TObject; Text: string) of object;

  TFMXHuggingFaceSender = class
  private
    FMemo1: TMemo;
    FImage1: TImage;
    FImage2: TImage;
    FUrlNext: string;
    FMediaPlayer: TMediaPlayer;
    FFunc: IFunctionCore;
    FFuncProc: TToolFunc;
    TempBitmap: TBitMap;
    FFileName: string;
    FStartMessage: string;
    FEndMessage: string;
    procedure SetFileName(const Value: string);
  public
    procedure LoadImageFromFile(const FilePath: TFileName);
    procedure Play;
    property Memo1: TMemo read FMemo1 write FMemo1;
    property Image1: TImage read FImage1 write FImage1;
    property Image2: TImage read FImage2 write FImage2;
    property UrlNext: string read FUrlNext write FUrlNext;
    property FuncProc: TToolFunc read FFuncProc write FFuncProc;
    property Func: IFunctionCore read FFunc write FFunc;
    property FileName: string read FFileName write SetFileName;
    property MediaPlayer: TMediaPlayer read FMediaPlayer write FMediaPlayer;
    property StartMessage: string read FStartMessage write FStartMessage;
    property EndMessage: string read FEndMessage write FEndMessage;
    constructor Create(const AMemo1: TMemo; const AImage1, AImage2: TImage; const AMediaPlayer: TMediaPlayer);
    destructor Destroy; override;
  end;

  TImageHelper = class helper for TImage
    procedure AssignBitmap(const Value: TBitmap);
    procedure DrawTransparentRectangle(Value: TRect; Color: TAlphaColor; Alpha: Byte);
    function HighlightObject(const Value: TRect): TRect;
  end;

  procedure Start(Sender: TObject);

  procedure Display(Sender: TObject; Value: string); overload;
  procedure Display(Sender: TObject; Value: TArray<string>); overload;
  procedure Display(Sender: TObject; Value: string; Items: TArray<Double>); overload;
  procedure Display(Sender: TObject; Value: TChat); overload;
  procedure Display(Sender: TObject; Value: TModels); overload;
  procedure Display(Sender: TObject; Value: TAudioToText); overload;
  procedure Display(Sender: TObject; Value: TEmbeddings); overload;
  procedure Display(Sender: TObject; Value: TMask); overload;
  procedure Display(Sender: TObject; Value: TImageClassification); overload;
  procedure Display(Sender: TObject; Value: TImageSegmentation); overload;
  procedure Display(Sender: TObject; Value: TObjectDetection); overload;
  procedure Display(Sender: TObject; Value: TAudioClassification); overload;
  procedure Display(Sender: TObject; Value: TQuestionAnswering); overload;
  procedure Display(Sender: TObject; Value: TSummarization); overload;
  procedure Display(Sender: TObject; Value: TTableQA); overload;
  procedure Display(Sender: TObject; Value: TTextClassification); overload;
  procedure Display(Sender: TObject; Value: TTextToImage); overload;
  procedure Display(Sender: TObject; Value: TTokenClassification); overload;
  procedure Display(Sender: TObject; Value: TTranslation); overload;
  procedure Display(Sender: TObject; Value: TZeroShotClassification); overload;
  procedure Display(Sender: TObject; Value: TTextGeneration); overload;
  procedure Display(Sender: TObject; Value: TSentimentAnalysis); overload;
  procedure Display(Sender: TObject; Value: TTextToSpeech); overload;
  procedure Display(Sender: TObject; Value: TAudioToAudio); overload;
  procedure Display(Sender: TObject; Value: TImageSegmentationItem); overload;
  procedure Display(Sender: TObject; Value: TObjectDetectionItem); overload;

  procedure DisplayStream(Sender: TObject; Value: string); overload;
  procedure DisplayStream(Sender: TObject; Value: TChat); overload;
  procedure DisplayStream(Sender: TObject; Value: TTextGeneration); overload;

var
  HFTutorial: TFMXHuggingFaceSender = nil;

implementation

uses
  System.StrUtils;

procedure Start(Sender: TObject);
begin
  Display(Sender, HFTutorial.StartMessage);
end;

procedure Display(Sender: TObject; Value: string);
var
  M: TMemo;
begin
  if Sender is TMemo then
    M := Sender as TMemo else
    M := (Sender as TFMXHuggingFaceSender).Memo1;
  M.Lines.Text := M.Text + Value + sLineBreak;
  M.ViewportPosition := PointF(M.ViewportPosition.X, M.Content.Height - M.Height);
end;

procedure Display(Sender: TObject; Value: TArray<string>);
begin
  var index := 0;
  for var Item in Value do
    begin
      if index = 0 then
        Display(Sender, Item) else
      if not Item.IsEmpty then
        Display(Sender, '    . ' + Item) else
        Display(Sender, EmptyStr);
      Inc(index);
    end;
end;

procedure Display(Sender: TObject; Value: string; Items: TArray<Double>);
begin
  Display(Sender, '    . ' + Value);
  for var Item in Items do
    Display(Sender, '      . ' + Item.ToString(ffNumber, 5, 5));
end;

procedure Display(Sender: TObject; Value: TChat);
var
  M: TMemo;
begin
  if Sender is TMemo then
    M := Sender as TMemo else
    M := (Sender as TFMXHuggingFaceSender).Memo1;
  for var Item in Value.Choices do
    begin
      if Assigned(HFTutorial.FFuncProc) then
        for var SubItem in Item.Message.ToolCalls do
          begin
            HFTutorial.FFuncProc(M, HFTutorial.Func.Execute(SubItem.&Function.Arguments));
          end;
      Display(M, Item.Message.Content);
    end;
end;

procedure Display(Sender: TObject; Value: TModels);
var
  M: TMemo;
begin
  if Sender is TMemo then
    M := Sender as TMemo else
    M := (Sender as TFMXHuggingFaceSender).Memo1;
  HFTutorial.UrlNext := Value.UrlNext;
  for var Item in Value.Items do
    begin
//      if IndexStr(Item.Inference.ToLower, ['cold', 'warm']) > -1 then
//        Display(M, Format('%s (%s)', [Item.Id, Item.Inference]))
//      else
        DisplayStream(M, Format('%s (%s) '#10, [Item.Id, Item.Inference]));
      Application.ProcessMessages;
    end;
  if Value.UrlNext.IsEmpty then
    Display(M, EmptyStr);
end;

procedure Display(Sender: TObject; Value: TAudioToText);
begin
  Display(Sender, Value.Text);
  if System.Length(Value.Chunks) > 0 then
    for var Item in Value.Chunks do
      begin
        Display(Sender, Item.Text, Item.Timestamps);
      end;
end;

procedure Display(Sender: TObject; Value: TEmbeddings);
begin
  for var Item in Value.Items do
    begin
      Display(Sender, Item.ToString);
      Application.ProcessMessages;
    end;
end;

procedure Display(Sender: TObject; Value: TMask);
begin
  for var Item in Value.Items do
    Display(Sender, [Item.Sequence, Item.TokenStr, Item.Score.ToString(ffNumber, 5, 5), Item.Token.ToString, EmptyStr]);
end;

procedure Display(Sender: TObject; Value: TImageClassification);
begin
  for var Item in Value.Items do
    Display(Sender, [Item.&Label, Item.Score.ToString(ffNumber, 5, 5)]);
end;

procedure Display(Sender: TObject; Value: TImageSegmentation);
begin
  for var Item in Value.Items do
    begin
      Display(Sender, [Item.&Label, Item.Score.ToString(ffNumber, 2, 2)]);
      Display(HFTutorial.Image2, Item);
    end;
end;

procedure Display(Sender: TObject; Value: TObjectDetection);
begin
  for var Item in Value.Items do
    begin
      Display(Sender, [Item.&Label, Item.Score.ToString(ffNumber, 2,2)]);
      Display(HFTutorial.Image1, Item);
    end;
end;

procedure Display(Sender: TObject; Value: TAudioClassification);
begin
  Display(Sender, HFTutorial.EndMessage);
  for var Item in Value.Items do
    Display(Sender, [Item.&Label, Item.Score.ToString]);
end;

procedure Display(Sender: TObject; Value: TQuestionAnswering);
begin
  if System.Length(Value.Items) = 0 then
    begin
      with Value do
        Display(Sender, [Answer, Score.ToString(ffNumber, 2,2), Start.ToString, &End.ToString]);
    end
  else
    begin
      for var Item in Value.Items do
        with Item do
          Display(Sender, [Answer, Score.ToString(ffNumber, 2,2), Start.ToString, &End.ToString]);
    end;
end;

procedure Display(Sender: TObject; Value: TSummarization);
begin
  for var Item in Value.Items do
    Display(Sender, Item.SummaryText);
end;

procedure Display(Sender: TObject; Value: TTableQA);
begin
  with Value do
    Display(Sender, [Answer, Coordinates.ToString, string.Join(', ', Cells), Aggregator]);
end;

procedure Display(Sender: TObject; Value: TTextClassification);
begin
  for var Item in Value.Items do
    for var SubItem in Item.Items do
      Display(Sender, [SubItem.&Label, SubItem.Score.ToString(ffNumber, 5, 5)]);
end;

procedure Display(Sender: TObject; Value: TTextToImage);
begin
  Display(Sender, HFTutorial.FEndMessage);
  var Stream := Value.GetStream;
  try
    HFTutorial.Image1.Bitmap.LoadFromStream(Stream);
    if not HFTutorial.FileName.IsEmpty then
      Value.SaveToFile(HFTutorial.FileName);
  finally
    Stream.Free;
  end;
end;

procedure Display(Sender: TObject; Value: TTokenClassification);
begin
  for var Item in Value.Items do
    Display(Sender,
      [Item.EntityGroup, Item.Score.ToString(ffNumber, 5, 5),
       Item.Word, Item.Start.ToString, Item.&end.ToString, Item.Entity]);
end;

procedure Display(Sender: TObject; Value: TTranslation);
begin
  for var Item in Value.Items do
    Display(HFTutorial, Item.TranslationText);
end;

procedure Display(Sender: TObject; Value: TZeroShotClassification);
begin
  Display(HFTutorial, Value.Sequence);
  var Index := 0;
  for var Item in Value.Labels do
    begin
      Display(HFTutorial, '   . ' + Item + ' : ' + Value.Scores[Index].ToString(ffNumber, 5, 5));
      Inc(Index);
    end;
end;

procedure Display(Sender: TObject; Value: TTextGeneration);
begin
  for var Item in Value.Items do
    Display(HFTutorial, Item.GeneratedText);
end;

procedure Display(Sender: TObject; Value: TSentimentAnalysis);
begin
  for var Item in Value.Items do
    begin
      for var SubItem in Item.Evals do
        begin
          Display(Sender, [SubItem.&Label, SubItem.Score.ToString(ffNumber, 4, 4)]);
        end;
    end;
end;

procedure Display(Sender: TObject; Value: TTextToSpeech);
begin
  Display(Sender, HFTutorial.EndMessage);
  if HFTutorial.FileName.IsEmpty then
    raise Exception.Create('Set filename value in HFTutorial instance');
  Value.SaveToFile(HFTutorial.FileName);
  HFTutorial.Play;
end;

procedure Display(Sender: TObject; Value: TAudioToAudio);
begin
  if HFTutorial.FileName.IsEmpty then
    raise Exception.Create('Set filename value in HFTutorial instance');
  Value.SaveToFile(HFTutorial.FileName);
  HFTutorial.Play;
end;

procedure Display(Sender: TObject; Value: TImageSegmentationItem);
begin
  var Image := Sender as TImage;
  var Stream: TStream := nil;
  try
    Stream := Value.GetStream;
    Image.Bitmap.LoadFromStream(Stream);
    ShowMessage('Next');
  finally
    Stream.Free;
  end;
end;

procedure Display(Sender: TObject; Value: TObjectDetectionItem);
begin
  var Image := Sender as TImage;
  Image.HighlightObject(Value.ToRect);
  ShowMessage('Next');
  Image.AssignBitmap(HFTutorial.TempBitmap);
end;

procedure DisplayStream(Sender: TObject; Value: string);
var
  M: TMemo;
  CurrentLine: string;
begin
  if Sender is TMemo then
    M := Sender as TMemo
  else
    M := (Sender as TFMXHuggingFaceSender).Memo1;
  var ShouldScroll := M.ViewportPosition.Y >= (M.Content.Height - M.Height - 16);
  M.Lines.BeginUpdate;
  try
    var Lines := Value.Split([#10]);
    if System.Length(Lines) > 0 then
    begin
      if M.Lines.Count > 0 then
        CurrentLine := M.Lines[M.Lines.Count - 1]
      else
        CurrentLine := EmptyStr;
      CurrentLine := CurrentLine + Lines[0];
      if M.Lines.Count > 0 then
        M.Lines[M.Lines.Count - 1] := CurrentLine
      else
        M.Lines.Add(CurrentLine);
      for var i := 1 to High(Lines) do
        M.Lines.Add(Lines[i]);
    end;
  finally
    M.Lines.EndUpdate;
  end;
  if ShouldScroll then
    M.ViewportPosition := PointF(M.ViewportPosition.X, M.Content.Height - M.Height);
end;

procedure DisplayStream(Sender: TObject; Value: TChat);
begin
  for var Item in Value.Choices do
    DisplayStream(Sender, Item.Delta.Content);
end;

procedure DisplayStream(Sender: TObject; Value: TTextGeneration);
begin
  DisplayStream(HFTutorial, Value.Delta.Text);
end;

{ TFMXHuggingFaceSender }

constructor TFMXHuggingFaceSender.Create(const AMemo1: TMemo; const AImage1,
  AImage2: TImage; const AMediaPlayer: TMediaPlayer);
begin
  inherited Create;
  FMemo1 := AMemo1;
  FImage1 := AImage1;
  FImage2 := AImage2;
  FMediaPlayer := AMediaPlayer;
  FStartMessage := 'Please wait...';
  FEndMessage := 'Process ended...';
end;

destructor TFMXHuggingFaceSender.Destroy;
begin
  TempBitmap.Free;
  inherited;
end;

procedure TFMXHuggingFaceSender.LoadImageFromFile(const FilePath: TFileName);
begin
  if not FileExists(FilePath) then
    raise Exception.CreateFmt('File not found (%s)', [FilePath]);

  if not Assigned(TempBitmap) then
    TempBitmap := TBitmap.Create;

  TempBitmap.LoadFromFile(FilePath);
  Image1.AssignBitmap(TempBitmap);
end;

procedure TFMXHuggingFaceSender.Play;
begin
  with HFTutorial.MediaPlayer do
    begin
      FileName := HFTutorial.FileName;
      Play;
    end;
end;

procedure TFMXHuggingFaceSender.SetFileName(const Value: string);
begin
  FFileName := Value;
  FMediaPlayer.Clear;
end;

{ TImageHelper }

procedure TImageHelper.AssignBitmap(const Value: TBitmap);
begin
  Bitmap.Assign(Value);
end;

procedure TImageHelper.DrawTransparentRectangle(Value: TRect; Color: TAlphaColor;
  Alpha: Byte);
type
  TRGBTripleArray = array[0..MaxInt div SizeOf(TRGBTriple) - 1] of TRGBTriple;
  PRGBTripleArray = ^TRGBTripleArray;
var
  X, Y: Integer;
  R, G, B: Byte;
  SrcColor: TAlphaColor;
  SrcR, SrcG, SrcB, SrcA: Byte;
  NewR, NewG, NewB: Byte;
  NewColor: TAlphaColor;
  BitmapData: TBitmapData;
  Bitmap: TBitmap;
begin
  R := GetRValue(Color);
  G := GetGValue(Color);
  B := GetBValue(Color);
  Bitmap := Self.Bitmap;
  if Bitmap.Map(TMapAccess.Write, BitmapData) then
  try
    for Y := Trunc(Value.Top) to Trunc(Value.Bottom) - 1 do
    begin
      for X := Trunc(Value.Left) to Trunc(Value.Right) - 1 do
      begin
        SrcColor := BitmapData.GetPixel(X, Y);
        SrcR := TAlphaColorRec(SrcColor).R;
        SrcG := TAlphaColorRec(SrcColor).G;
        SrcB := TAlphaColorRec(SrcColor).B;
        SrcA := TAlphaColorRec(SrcColor).A;
        NewR := (SrcR * (255 - Alpha) + R * Alpha) div 255;
        NewG := (SrcG * (255 - Alpha) + G * Alpha) div 255;
        NewB := (SrcB * (255 - Alpha) + B * Alpha) div 255;
        NewColor := (SrcA shl 24) or (NewR shl 16) or (NewG shl 8) or NewB;
        BitmapData.SetPixel(X, Y, NewColor);
      end;
    end;
  finally
    Bitmap.Unmap(BitmapData);
  end;
  Self.Repaint;
end;

function TImageHelper.HighlightObject(const Value: TRect): TRect;
begin
  DrawTransparentRectangle(Value, TAlphaColorRec.Aqua, 128);
end;

initialization
finalization
  if Assigned(HFTutorial) then
    HFTutorial.Free;
end.

unit HuggingFace.Aggregator;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiHuggingFace
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  HuggingFace.Hub.Support, HuggingFace.Functions.Core, HuggingFace.Image,
  HuggingFace.Mask,HuggingFace.Embeddings, HuggingFace.Audio, HuggingFace.Chat,
  HuggingFace.Text, HuggingFace.Hub.Search, HuggingFace.Schema;

type
  {$REGION 'HuggingFace.Text'}

  TQuestionAnswering = HuggingFace.Text.TQuestionAnswering;
  TAsynQuestionAnswering = HuggingFace.Text.TAsynQuestionAnswering;
  TQuestionAnsweringParam = HuggingFace.Text.TQuestionAnsweringParam;
  TQuestionAnsweringParameters = HuggingFace.Text.TQuestionAnsweringParameters;
  TQuestionAnsweringInputs = HuggingFace.Text.TQuestionAnsweringInputs;

  TSummarization = HuggingFace.Text.TSummarization;
  TAsynSummarization = HuggingFace.Text.TAsynSummarization;
  TSummarizationParam = HuggingFace.Text.TSummarizationParam;
  TSummarizationItem = HuggingFace.Text.TSummarizationItem;
  TSummarizationParameters = HuggingFace.Text.TSummarizationParameters;

  TTableQA = HuggingFace.Text.TTableQA;
  TAsynTableQA = HuggingFace.Text.TAsynTableQA;
  TTableQAParam = HuggingFace.Text.TTableQAParam;
  TRow = HuggingFace.Text.TRow;
  TTableQAInputs = HuggingFace.Text.TTableQAInputs;
  TTableQAParameters = HuggingFace.Text.TTableQAParameters;

  TTextClassification = HuggingFace.Text.TTextClassification;
  TAsynTextClassification = HuggingFace.Text.TAsynTextClassification;
  TTextClassificationParam = HuggingFace.Text.TTextClassificationParam;
  TTextClassificationParameters = HuggingFace.Text.TTextClassificationParameters;
  TTextClassificationItem = HuggingFace.Text.TTextClassificationItem;

  TTextToImage = HuggingFace.Text.TTextToImage;
  TAsynTextToImage = HuggingFace.Text.TAsynTextToImage;
  TTextToImageParam = HuggingFace.Text.TTextToImageParam;
  TTextToImageParameters = HuggingFace.Text.TTextToImageParameters;
  TTargetSizeParam = HuggingFace.Text.TTargetSizeParam;

  TTokenClassification = HuggingFace.Text.TTokenClassification;
  TAsynTokenClassification = HuggingFace.Text.TAsynTokenClassification;
  TTokenClassificationParam = HuggingFace.Text.TTokenClassificationParam;
  TTokenClassificationParameters = HuggingFace.Text.TTokenClassificationParameters;
  TTokenClassificationItem = HuggingFace.Text.TTokenClassificationItem;

  TTranslation = HuggingFace.Text.TTranslation;
  TAsynTranslation = HuggingFace.Text.TAsynTranslation;
  TTranslationParam = HuggingFace.Text.TTranslationParam;
  TTranslationParameters = HuggingFace.Text.TTranslationParameters;
  TTranslationItem = HuggingFace.Text.TTranslationItem;

  TZeroShotClassification = HuggingFace.Text.TZeroShotClassification;
  TAsynZeroShotClassification= HuggingFace.Text.TAsynZeroShotClassification;
  TZeroShotClassificationParam = HuggingFace.Text.TZeroShotClassificationParam;
  TZeroShotClassificationParameters = HuggingFace.Text.TZeroShotClassificationParameters;

  TTextGeneration = HuggingFace.Text.TTextGeneration;
  TAsynTextGeneration = HuggingFace.Text.TAsynTextGeneration;
  TAsynTextGenerationStream = HuggingFace.Text.TAsynTextGenerationStream;
  TTextGenerationParam = HuggingFace.Text.TTextGenerationParam;
  TTextGenerationParameters = HuggingFace.Text.TTextGenerationParameters;
  TTextGenerationItem = HuggingFace.Text.TTextGenerationItem;
  TBestOfSequences = HuggingFace.Text.TBestOfSequences;
  TPrefill = HuggingFace.Text.TPrefill;
  TTokens = HuggingFace.Text.TTokens;
  TDetails = HuggingFace.Text.TDetails;

  TSentimentAnalysis = HuggingFace.Text.TSentimentAnalysis;
  TAsynSentimentAnalysis = HuggingFace.Text.TAsynSentimentAnalysis;
  TSentimentAnalysisParams = HuggingFace.Text.TSentimentAnalysisParams;
  TEval = HuggingFace.Text.TEval;
  TEvals = HuggingFace.Text.TEvals;

  TTextToSpeech = HuggingFace.Text.TTextToSpeech;
  TAsynTextToSpeech = HuggingFace.Text.TAsynTextToSpeech;
  TTextToSpeechParam = HuggingFace.Text.TTextToSpeechParam;
  TTextToAudioParam = HuggingFace.Text.TTextToAudioParam;

  TTextToAudio = HuggingFace.Text.TTextToAudio;
  TAsynTextToAudio = HuggingFace.Text.TAsynTextToAudio;

  {$ENDREGION}

  {$REGION 'HuggingFace.Hub.Search'}

  TModel = HuggingFace.Hub.Search.TModel;
  TModels = HuggingFace.Hub.Search.TModels;
  TRepoModel = HuggingFace.Hub.Search.TRepoModel;
  TAsynModels = HuggingFace.Hub.Search.TAsynModels;
  TAsynRepoModel = HuggingFace.Hub.Search.TAsynRepoModel;
  TTokenizerConfig = HuggingFace.Hub.Search.TTokenizerConfig;
  TProcessorConfig = HuggingFace.Hub.Search.TProcessorConfig;
  TConfig = HuggingFace.Hub.Search.TConfig;
  TSibling = HuggingFace.Hub.Search.TSibling;
  TWidgetDataItem = HuggingFace.Hub.Search.TWidgetDataItem;
  TDataFiles = HuggingFace.Hub.Search.TDataFiles;
  TCardDataConfig = HuggingFace.Hub.Search.TCardDataConfig;
  TCardData = HuggingFace.Hub.Search.TCardData;
  TTransformersInfo = HuggingFace.Hub.Search.TTransformersInfo;
  TSafetensorsParameters = HuggingFace.Hub.Search.TSafetensorsParameters;
  TSafetensors = HuggingFace.Hub.Search.TSafetensors;
  TResultTask = HuggingFace.Hub.Search.TResultTask;
  TDataSetArgs = HuggingFace.Hub.Search.TDataSetArgs;
  TResultDataset = HuggingFace.Hub.Search.TResultDataset;
  TResultMetrics = HuggingFace.Hub.Search.TResultMetrics;
  TModelResult = HuggingFace.Hub.Search.TModelResult;
  TModelIndexItem = HuggingFace.Hub.Search.TModelIndexItem;

  {$ENDREGION}

  {$REGION 'HuggingFace.Hub.Support'}

  TFetchParams = HuggingFace.Hub.Support.TFetchParams;

  {$ENDREGION}

  {$REGION 'HuggingFace.Schema'}

  TPropertyItem = HuggingFace.Schema.TPropertyItem;
  TSchemaParams = HuggingFace.Schema.TSchemaParams;

  {$ENDREGION}

  {$REGION 'HuggingFace.Functions.Core'}

  IFunctionCore = HuggingFace.Functions.Core.IFunctionCore;
  TFunctionCore = HuggingFace.Functions.Core.TFunctionCore;

  {$ENDREGION}

  {$REGION 'HuggingFace.Chat'}

  TChat = HuggingFace.Chat.TChat;
  TChatPayload = HuggingFace.Chat.TChatPayload;
  TChoice = HuggingFace.Chat.TChoice;
  TAsynChat = HuggingFace.Chat.TAsynChat;
  TAsynChatStream = HuggingFace.Chat.TAsynChatStream;
  TContentPayload = HuggingFace.Chat.TContentPayload;
  TPayload = HuggingFace.Chat.TPayload;
  TResponseFormat = HuggingFace.Chat.TResponseFormat;
  TFunctionCalled = HuggingFace.Chat.TFunctionCalled;
  TToolCalls = HuggingFace.Chat.TToolCalls;
  TChoiceMessage = HuggingFace.Chat.TChoiceMessage;
  TTopLogprobs = HuggingFace.Chat.TTopLogprobs;
  TLogprobContent = HuggingFace.Chat.TLogprobContent;
  TLogprobs = HuggingFace.Chat.TLogprobs;
  TUsage = HuggingFace.Chat.TUsage;
  TChatEvent = HuggingFace.Chat.TChatEvent;

  {$ENDREGION}

  {$REGION 'HuggingFace.Audio'}

  TGenerationParameters = HuggingFace.Audio.TGenerationParameters;
  TRecognitionParameters = HuggingFace.Audio.TRecognitionParameters;

  TAudioChunk = HuggingFace.Audio.TAudioChunk;
  TAudioToText = HuggingFace.Audio.TAudioToText;
  TAsynAudioToText = HuggingFace.Audio.TAsynAudioToText;
  TAudioToTextParam = HuggingFace.Audio.TAudioToTextParam;

  TAudioClassification = HuggingFace.Audio.TAudioClassification;
  TAsynAudioClassification = HuggingFace.Audio.TAsynAudioClassification;
  TAudioClassificationParam = HuggingFace.Audio.TAudioClassificationParam;
  TAudioClassificationParameters = HuggingFace.Audio.TAudioClassificationParameters;
  TAudioClassificationItem = HuggingFace.Audio.TAudioClassificationItem;

  TAudioToAudio = HuggingFace.Audio.TAudioToAudio;
  TAsynAudioToAudio = HuggingFace.Audio.TAsynAudioToAudio;
  TAudioToAudioParam = HuggingFace.Audio.TAudioToAudioParam;

  {$ENDREGION}

  {$REGION 'HuggingFace.Embeddings'}

  TEmbeddings = HuggingFace.Embeddings.TEmbeddings;
  TAsynEmbeddings = HuggingFace.Embeddings.TAsynEmbeddings;
  TEmbeddingParams = HuggingFace.Embeddings.TEmbeddingParams;

  {$ENDREGION}

  {$REGION 'HuggingFace.Mask'}

  TMask = HuggingFace.Mask.TMask;
  TAsynMask = HuggingFace.Mask.TAsynMask;
  TMaskParam = HuggingFace.Mask.TMaskParam;
  TMaskParameters = HuggingFace.Mask.TMaskParameters;
  TMaskItem = HuggingFace.Mask.TMaskItem;

  {$ENDREGION}

  {$REGION 'HuggingFace.Image'}

  TImageClassification = HuggingFace.Image.TImageClassification;
  TAsynImageClassification = HuggingFace.Image.TAsynImageClassification;
  TImageClassificationParam = HuggingFace.Image.TImageClassificationParam;
  TImageClassificationItem = HuggingFace.Image.TImageClassificationItem;

  TImageSegmentation = HuggingFace.Image.TImageSegmentation;
  TAsynImageSegmentation = HuggingFace.Image.TAsynImageSegmentation;
  TImageSegmentationParam = HuggingFace.Image.TImageSegmentationParam;
  TImageSegmentationParameters = HuggingFace.Image.TImageSegmentationParameters;
  TImageSegmentationItem = HuggingFace.Image.TImageSegmentationItem;

  TObjectDetection = HuggingFace.Image.TObjectDetection;
  TAsynObjectDetection = HuggingFace.Image.TAsynObjectDetection;
  TObjectDetectionParam = HuggingFace.Image.TObjectDetectionParam;
  TObjectDetectionItem = HuggingFace.Image.TObjectDetectionItem;

  TImageToImage = HuggingFace.Image.TImageToImage;
  TAsynImageToImage = HuggingFace.Image.TAsynImageToImage;
  TImageToImageParam = HuggingFace.Image.TImageToImageParam;

  {$ENDREGION}

implementation

end.

unit HuggingFace.API.Params;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiHuggingFace
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.Classes, System.JSON, System.SysUtils, System.Types, System.RTTI,
  REST.JsonReflect, REST.Json.Interceptors, System.Generics.Collections,
  System.Threading;

type
  /// <summary>
  /// Represents a reference to a procedure that takes a single argument of type T and returns no value.
  /// </summary>
  /// <param name="T">
  /// The type of the argument that the referenced procedure will accept.
  /// </param>
  /// <remarks>
  /// This type is useful for defining callbacks or procedures that operate on a variable of type T, allowing for more flexible and reusable code.
  /// </remarks>
  TProcRef<T> = reference to procedure(var Arg: T);

  TJSONInterceptorStringToString = class(TJSONInterceptor)
    constructor Create; reintroduce;
  protected
    RTTI: TRttiContext;
  end;

  TJSONParam = class
  private
    FJSON: TJSONObject;
    procedure SetJSON(const Value: TJSONObject);
    function GetCount: Integer;

  public
    constructor Create; virtual;
    destructor Destroy; override;
    function Add(const Key: string; const Value: string): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: Integer): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: Extended): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: Boolean): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: TDateTime; Format: string): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: TJSONValue): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: TJSONParam): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<string>): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<Integer>): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<Extended>): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<TJSONValue>): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<TJSONParam>): TJSONParam; overload; virtual;
    function GetOrCreateObject(const Name: string): TJSONObject;
    function GetOrCreate<T: TJSONValue, constructor>(const Name: string): T;
    procedure Delete(const Key: string); virtual;
    procedure Clear; virtual;
    property Count: Integer read GetCount;
    function Detach: TJSONObject;
    property JSON: TJSONObject read FJSON write SetJSON;
    function ToJsonString(FreeObject: Boolean = False): string; virtual;
    function ToFormat(FreeObject: Boolean = False): string;
    function ToStringPairs: TArray<TPair<string, string>>;
    function ToStream: TStringStream;
  end;

  TJSONModelNamedParam = class(TJSONParam)
  public
    function Model(const Value: string): TJSONModelNamedParam;
  end;

  TJSONChatParam = class(TJSONModelNamedParam);

  TJSONModelParam = class(TJSONModelNamedParam);

  TCMDParam = class
  private
    FValue: string;
    procedure Check(const Name: string);
    function GetValue: string;
  public
    function Add(const Name, Value: string): TCMDParam; overload;
    function Add(const Name: string; Value: Integer): TCMDParam; overload;
    function Add(const Name: string; Value: Boolean): TCMDParam; overload;
    function Add(const Name: string; Value: Double): TCMDParam; overload;
    property Value: string read GetValue;
    constructor Create;
  end;

  TModel = class
  private
    FModel: string;
  public
    property Model: string read FModel write FModel;
  end;

const
  DATE_FORMAT = 'YYYY-MM-DD';
  TIME_FORMAT = 'HH:NN:SS';
  DATE_TIME_FORMAT = DATE_FORMAT + ' ' + TIME_FORMAT;

implementation

uses
  System.DateUtils;

{ TJSONInterceptorStringToString }

constructor TJSONInterceptorStringToString.Create;
begin
  ConverterType := ctString;
  ReverterType := rtString;
end;

{ Fetch }

type
  Fetch<T> = class
    type
      TFetchProc = reference to procedure(const Element: T);
  public
    class procedure All(const Items: TArray<T>; Proc: TFetchProc);
  end;

{ Fetch<T> }

class procedure Fetch<T>.All(const Items: TArray<T>; Proc: TFetchProc);
var
  Item: T;
begin
  for Item in Items do
    Proc(Item);
end;

{ TJSONParam }

function TJSONParam.Add(const Key, Value: string): TJSONParam;
begin
  Delete(Key);
  FJSON.AddPair(Key, Value);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: TJSONValue): TJSONParam;
begin
  Delete(Key);
  FJSON.AddPair(Key, Value);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: TJSONParam): TJSONParam;
begin
  Add(Key, TJSONValue(Value.JSON.Clone));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: TDateTime; Format: string): TJSONParam;
begin
  if Format.IsEmpty then
    Format := DATE_TIME_FORMAT;
  Add(Key, FormatDateTime(Format, System.DateUtils.TTimeZone.local.ToUniversalTime(Value)));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: Boolean): TJSONParam;
begin
  Add(Key, TJSONBool.Create(Value));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: Integer): TJSONParam;
begin
  Add(Key, TJSONNumber.Create(Value));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: Extended): TJSONParam;
begin
  Add(Key, TJSONNumber.Create(Value));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<TJSONValue>): TJSONParam;
var
  JArr: TJSONArray;
begin
  JArr := TJSONArray.Create;
  Fetch<TJSONValue>.All(Value, JArr.AddElement);
  Add(Key, JArr);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<TJSONParam>): TJSONParam;
var
  JArr: TJSONArray;
  Item: TJSONParam;
begin
  JArr := TJSONArray.Create;
  for Item in Value do
  try
    JArr.AddElement(Item.JSON);
    Item.JSON := nil;
  finally
    Item.Free;
  end;
  Add(Key, JArr);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<Extended>): TJSONParam;
var
  JArr: TJSONArray;
  Item: Extended;
begin
  JArr := TJSONArray.Create;
  for Item in Value do
    JArr.Add(Item);
  Add(Key, JArr);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<Integer>): TJSONParam;
var
  JArr: TJSONArray;
  Item: Integer;
begin
  JArr := TJSONArray.Create;
  for Item in Value do
    JArr.Add(Item);
  Add(Key, JArr);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<string>): TJSONParam;
var
  JArr: TJSONArray;
  Item: string;
begin
  JArr := TJSONArray.Create;
  for Item in Value do
    JArr.Add(Item);
  Add(Key, JArr);
  Result := Self;
end;

procedure TJSONParam.Clear;
begin
  FJSON.Free;
  FJSON := TJSONObject.Create;
end;

constructor TJSONParam.Create;
begin
  FJSON := TJSONObject.Create;
end;

procedure TJSONParam.Delete(const Key: string);
var
  Item: TJSONPair;
begin
  Item := FJSON.RemovePair(Key);
  if Assigned(Item) then
    Item.Free;
end;

destructor TJSONParam.Destroy;
begin
  if Assigned(FJSON) then
    FJSON.Free;
  inherited;
end;

function TJSONParam.GetCount: Integer;
begin
  Result := FJSON.Count;
end;

function TJSONParam.GetOrCreate<T>(const Name: string): T;
begin
  if not FJSON.TryGetValue<T>(Name, Result) then
  begin
    Result := T.Create;
    FJSON.AddPair(Name, Result);
  end;
end;

function TJSONParam.GetOrCreateObject(const Name: string): TJSONObject;
begin
  Result := GetOrCreate<TJSONObject>(Name);
end;

function TJSONParam.Detach: TJSONObject;
begin
  Result := JSON;
  JSON := nil;
  var Task: ITask := TTask.Create(
    procedure()
    begin
      Sleep(30);
      TThread.Queue(nil,
      procedure
      begin
        Self.Free;
      end);
    end
  );
  Task.Start;
end;

procedure TJSONParam.SetJSON(const Value: TJSONObject);
begin
  FJSON := Value;
end;

function TJSONParam.ToFormat(FreeObject: Boolean): string;
begin
  Result := FJSON.Format(4);
  if FreeObject then
    Free;
end;

function TJSONParam.ToJsonString(FreeObject: Boolean): string;
begin
  Result := FJSON.ToJSON;
  if FreeObject then
    Free;
end;

function TJSONParam.ToStream: TStringStream;
begin
  Result := TStringStream.Create;
  try
    Result.WriteString(ToJsonString);
    Result.Position := 0;
  except
    Result.Free;
    raise;
  end;
end;

function TJSONParam.ToStringPairs: TArray<TPair<string, string>>;
begin
  for var Pair in FJSON do
    Result := Result + [TPair<string, string>.Create(Pair.JsonString.Value, Pair.JsonValue.AsType<string>)];
end;

{ TCMDParam }

function TCMDParam.Add(const Name, Value: string): TCMDParam;
begin
  Check(Name);
  var S := Format('%s=%s', [Name, Value]);
  if FValue.IsEmpty then
    FValue := S else
    FValue := FValue + '&' + S;
  Result := Self;
end;

function TCMDParam.Add(const Name: string; Value: Integer): TCMDParam;
begin
  Result := Add(Name, Value.ToString);
end;

function TCMDParam.Add(const Name: string; Value: Boolean): TCMDParam;
begin
  Result := Add(Name, BoolToStr(Value, true));
end;

function TCMDParam.Add(const Name: string; Value: Double): TCMDParam;
begin
  Result := Add(Name, Value.ToString);
end;

procedure TCMDParam.Check(const Name: string);
begin
  if FValue.Contains(Name) then
    begin
      var Items := FValue.Split(['&']);
      FValue := EmptyStr;
      for var Item in Items do
        begin
          if not Item.StartsWith(Name) then
            begin
              if FValue.IsEmpty then
                FValue := Item else
                FValue := FValue + '&' + Item;
            end;
        end;
    end;
end;

constructor TCMDParam.Create;
begin
  FValue := EmptyStr;
end;

function TCMDParam.GetValue: string;
begin
  Result := FValue;
  if not Result.IsEmpty then
    Result := '?' + Result; // + '&page=2>; rel="last"';
end;

{ TJSONModelNamedParam }

function TJSONModelNamedParam.Model(const Value: string): TJSONModelNamedParam;
begin
  Result := TJSONModelNamedParam(Add('model', Value));
end;

end.

unit HuggingFace.API;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiHuggingFace
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.Classes, System.Net.HttpClient, System.Net.URLClient, System.Net.Mime,
  System.JSON, HuggingFace.Errors, HuggingFace.API.Params, System.SysUtils;

type
  HuggingFaceException = class(Exception)
  private
    FCode: Int64;
    FId: string;
    FName: string;
    FError: string;
    FWarnings: TArray<string>;
    FEstimatedTime: Double;
  public
    constructor Create(const ACode: Int64; const AError: TErrorCore); reintroduce; overload;
    constructor Create(const ACode: Int64; const Value: string); reintroduce; overload;
    function ToMessageString: string;
    property Code: Int64 read FCode write FCode;
    property Id: string read FId write FId;
    property Name: string read FName write FName;
    property Error: string read FError write FError;
    property Warnings: TArray<string> read FWarnings write FWarnings;
    property EstimatedTime: Double read FEstimatedTime write FEstimatedTime;
  end;

  HuggingFaceExceptionAPI = class(Exception);

  /// <summary>
  /// The server could not understand the request due to invalid syntax.
  /// Review the request format and ensure it is correct.
  /// </summary>
  HuggingFaceExceptionBadRequestError = class(HuggingFaceException);

  /// <summary>
  /// The request lacks the required 'Authorization' header, which is needed to authenticate access.
  /// </summary>
  HuggingFaceExceptionUnauthorizedError = class(HuggingFaceException);

  /// <summary>
  /// The specified engine (ID some-fake-engine) was not found.
  /// </summary>
  HuggingFaceExceptionNotFoundError = class(HuggingFaceException);

  /// <summary>
  /// The request was well-formed but could not be followed due to semantic errors.
  /// Verify the data provided for correctness and completeness.
  /// </summary>
  HuggingFaceExceptionInvalidLanguageError = class(HuggingFaceException);

  /// <summary>
  /// Too many requests were sent in a given timeframe. Implement request throttling and respect rate limits.
  /// </summary>
  HuggingFaceExceptionRateLimitExceededError = class(HuggingFaceException);

  /// <summary>
  /// The request was not successful because it lacks valid authentication credentials for the requested resource.
  /// Ensure the request includes the necessary authentication credentials and the api key is valid.
  /// </summary>
  HuggingFaceExceptionContentModerationError = class(HuggingFaceException);

  /// <summary>
  /// The requested resource could not be found. Check the request URL and the existence of the resource.
  /// </summary>
  HuggingFaceExceptionPayloadTooLargeError = class(HuggingFaceException);

  /// <summary>
  /// A generic error occurred on the server. Try the request again later or contact support if the issue persists.
  /// </summary>
  HuggingFaceExceptionInternalServerError = class(HuggingFaceException);

  HuggingFaceExceptionInvalidResponse = class(HuggingFaceException);

  THuggingFaceAPI = class
  public
    const
      URL_BASE = 'https://api-inference.huggingface.co';
  private
    FToken: string;
    FBaseUrl: string;
    FCustomHeaders: TNetHeaders;
    FUseCache: Boolean;
    FWaitForModel: Boolean;

    procedure SetToken(const Value: string);
    procedure SetBaseUrl(const Value: string);
    procedure SetUseCache(const Value: Boolean);
    procedure RaiseError(Code: Int64; Error: TErrorCore);
    procedure ParseError(const Code: Int64; const ResponseText: string);
    procedure SetCustomHeaders(const Value: TNetHeaders);
    procedure SetWaitForModel(const Value: Boolean);

  private
    function ToStringValueFor(const Value: string): string; overload;
    function ToStringValueFor(const Value: string; const Field: string): string; overload;
    function ToStringValueFor(const Value: string; const Field: TArray<string>): string; overload;

  protected
    function GetPath<TParams: TJSONParam>(const Path: string; const Value: TParams): string; //ParamProc: TProc<TParams>
    function GetHeaderValue(const KeyName: string; const Value: TNetHeaders): string;
    function GetHeaders: TNetHeaders; virtual;
    function GetClient: THTTPClient; virtual;
    function GetRequestURL(const Path: string): string;
    function Get(const Path: string; Response: TStringStream; var ResponseHeader: TNetHeaders): Integer; overload;
    function Get(const Path: string; Response: TStringStream): Integer; overload;
    function GetLink(const Link: string; Response: TStringStream; var ResponseHeader: TNetHeaders): Integer; overload;
    function Delete(const Path: string; Response: TStringStream): Integer; overload;
    function Post(const Path: string; Response: TStringStream): Integer; overload;
    function Post(const Path: string; Body: TJSONObject; Response: TStringStream; OnReceiveData: TReceiveDataCallback = nil): Integer; overload;
    function Post(const Path: string; Body: TMultipartFormData; Response: TStringStream; var ResponseHeader: TNetHeaders): Integer; overload;
    function ParseResponse<T: class, constructor>(const Code: Int64; const ResponseText: string): T; overload;
    procedure CheckAPI;
    function ArrayToObject(const Response: string): string;
  public
    function GetArray<TResult: class, constructor>(const Path: string): TResult;
    function Get<TResult: class, constructor>(const Path: string): TResult; overload;
    function Get<TResult: class, constructor>(const Path: string; var Link: string): TResult; overload;
    function Get<TResult: class, constructor; TParams: TJSONParam>(const Path: string; ParamProc: TProc<TParams>): TResult; overload;
    procedure GetFile(const Path: string; Response: TStream); overload;
    function GetLink<TResult: class, constructor>(var Link: string): TResult; overload;
    function Delete<TResult: class, constructor>(const Path: string): TResult; overload;
    function Post<TParams: TJSONParam>(const Path: string; ParamProc: TProc<TParams>; Response: TStringStream; Event: TReceiveDataCallback = nil): Boolean; overload;
    function Post<TResult: class, constructor; TParams: TJSONParam>(const Path: string; ParamProc: TProc<TParams>; RawByteFieldName: string = ''): TResult; overload;
    function Post<TResult: class, constructor>(const Path: string): TResult; overload;
    function PostForm<TResult: class, constructor; TParams: TMultipartFormData, constructor>(const Path: string; ParamProc: TProc<TParams>): TResult; overload;
    function PostForm<TResult: class, constructor; TParams: TMultipartFormData, constructor>(const Path: string; ParamProc: TProc<TParams>;
      var ResponseHeader: TNetHeaders): TResult; overload;
  public
    constructor Create; overload;
    constructor Create(const AToken: string); overload;
    destructor Destroy; override;
    property Token: string read FToken write SetToken;
    property BaseUrl: string read FBaseUrl write SetBaseUrl;
    property CustomHeaders: TNetHeaders read FCustomHeaders write SetCustomHeaders;
    property UseCache: Boolean read FUseCache write SetUseCache;
    property WaitForModel: Boolean read FWaitForModel write SetWaitForModel;
  end;

  THuggingFaceAPIRoute = class
  private
    FAPI: THuggingFaceAPI;
    procedure SetAPI(const Value: THuggingFaceAPI);
  public
    property API: THuggingFaceAPI read FAPI write SetAPI;
    constructor CreateRoute(AAPI: THuggingFaceAPI); reintroduce;
  end;

implementation

uses
  System.StrUtils, REST.Json, System.NetConsts, HuggingFace.NetEncoding.Base64;

const
  FieldsToString : TArray<string> = ['"arguments":{'];

type
  THeaderUtils = class
    class function LinkExtract(const Value: string): string;
  end;

constructor THuggingFaceAPI.Create;
begin
  inherited;
  FToken := '';
  FBaseUrl := URL_BASE;
  FUseCache := True;
  FWaitForModel := False;
end;

constructor THuggingFaceAPI.Create(const AToken: string);
begin
  Create;
  Token := AToken;
end;

destructor THuggingFaceAPI.Destroy;
begin
  inherited;
end;

function THuggingFaceAPI.Post(const Path: string; Body: TJSONObject; Response: TStringStream; OnReceiveData: TReceiveDataCallback): Integer;
var
  Headers: TNetHeaders;
  Stream: TStringStream;
  Client: THTTPClient;
begin
  CheckAPI;
  Client := GetClient;
  try
    Headers := GetHeaders + [TNetHeader.Create('Content-Type', 'application/json')];
    Stream := TStringStream.Create;
    Client.ReceiveDataCallBack := OnReceiveData;
    try
      Stream.WriteString(Body.ToJSON);
      Stream.Position := 0;
      Result := Client.Post(GetRequestURL(Path), Stream, Response, Headers).StatusCode;
    finally
      Client.ReceiveDataCallBack := nil;
      Stream.Free;
    end;
  finally
    Client.Free;
  end;
end;

function THuggingFaceAPI.Get(const Path: string; Response: TStringStream; var ResponseHeader: TNetHeaders): Integer;
begin
  Result := GetLink(GetRequestURL(Path), Response, ResponseHeader);
end;

function THuggingFaceAPI.Get(const Path: string;
  Response: TStringStream): Integer;
var
  ResponseHeader: TNetHeaders;
begin
  Result := Get(Path, Response, ResponseHeader);
end;

function THuggingFaceAPI.Post(const Path: string; Body: TMultipartFormData; Response: TStringStream;
  var ResponseHeader: TNetHeaders): Integer;
var
  Client: THTTPClient;
begin
  CheckAPI;
  Client := GetClient;
  try
    var PostResult := Client.Post(GetRequestURL(Path), Body, Response, GetHeaders);
    ResponseHeader := PostResult.Headers;
    Result := PostResult.StatusCode;
  finally
    Client.Free;
  end;
end;

function THuggingFaceAPI.Post(const Path: string; Response: TStringStream): Integer;
var
  Client: THTTPClient;
begin
  CheckAPI;
  Client := GetClient;
  try
    Result := Client.Post(GetRequestURL(Path), TStream(nil), Response, GetHeaders).StatusCode;
  finally
    Client.Free;
  end;
end;

function THuggingFaceAPI.Post<TResult, TParams>(const Path: string; ParamProc: TProc<TParams>; RawByteFieldName: string): TResult;
var
  Response: TStringStream;
  Params: TParams;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    Code := Post(GetPath<TParams>(Path, Params), Params.JSON, Response);
    case Code of
      200..299:
        begin
          if RawByteFieldName.IsEmpty then
            Result := ParseResponse<TResult>(Code, ArrayToObject(ToStringValueFor(Response.DataString)))
          else
            Result := ParseResponse<TResult>(Code, Format('{"%s":"%s"}', [RawByteFieldName, BytesToBase64(Response.Bytes)]));
        end;
      else
        Result := ParseResponse<TResult>(Code, ArrayToObject(ToStringValueFor(Response.DataString)))
    end;

  finally
    Params.Free;
    Response.Free;
  end;
end;

function THuggingFaceAPI.Post<TParams>(const Path: string; ParamProc: TProc<TParams>; Response: TStringStream; Event: TReceiveDataCallback): Boolean;
var
  Params: TParams;
  Code: Integer;
begin
  Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    Code := Post(GetPath<TParams>(Path, Params), Params.JSON, Response, Event);
    case Code of
      200..299:
        Result := True;
    else
      Result := False;
    end;
  finally
    Params.Free;
  end;
end;

function THuggingFaceAPI.Post<TResult>(const Path: string): TResult;
var
  Response: TStringStream;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Code := Post(Path, Response);
    Result := ParseResponse<TResult>(Code, Response.DataString);
  finally
    Response.Free;
  end;
end;

function THuggingFaceAPI.Delete(const Path: string; Response: TStringStream): Integer;
var
  Client: THTTPClient;
begin
  CheckAPI;
  Client := GetClient;
  try
    Result := Client.Delete(GetRequestURL(Path), Response, GetHeaders).StatusCode;
  finally
    Client.Free;
  end;
end;

function THuggingFaceAPI.Delete<TResult>(const Path: string): TResult;
var
  Response: TStringStream;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Code := Delete(Path, Response);
    Result := ParseResponse<TResult>(Code, Response.DataString);
  finally
    Response.Free;
  end;
end;

function THuggingFaceAPI.PostForm<TResult, TParams>(const Path: string;
  ParamProc: TProc<TParams>; var ResponseHeader: TNetHeaders): TResult;
begin
  var Response := TStringStream.Create('', TEncoding.UTF8);
  var Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    var Code := Post(Path, Params, Response, ResponseHeader);
    Result := ParseResponse<TResult>(Code, Response.DataString);
  finally
    Params.Free;
    Response.Free;
  end;
end;

function THuggingFaceAPI.PostForm<TResult, TParams>(const Path: string; ParamProc: TProc<TParams>): TResult;
var
  ResponseHeader: TNetHeaders;
begin
  Result := PostForm<TResult, TParams>(Path, ParamProc, ResponseHeader);
end;

function THuggingFaceAPI.Get<TResult, TParams>(const Path: string; ParamProc: TProc<TParams>): TResult;
var
  Response: TStringStream;
  Params: TParams;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    var Pairs: TArray<string> := [];
    for var Pair in Params.ToStringPairs do
      Pairs := Pairs + [Pair.Key + '=' + Pair.Value];
    var QPath := Path;
    if Length(Pairs) > 0 then
      QPath := QPath + '?' + string.Join('&', Pairs);
    Code := Get(QPath, Response);
    Result := ParseResponse<TResult>(Code, Response.DataString);
  finally
    Params.Free;
    Response.Free;
  end;
end;

function THuggingFaceAPI.Get<TResult>(const Path: string;
  var Link: string): TResult;
var
  Code: Integer;
  Response: TStringStream;
  ResponseHeader: TNetHeaders;
begin
  CustomHeaders := [TNetHeader.Create('accept', 'application/json')];
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Code := Get(Path, Response, ResponseHeader);
    Link := GetHeaderValue('link', ResponseHeader);
    Result := ParseResponse<TResult>(Code, ArrayToObject(Response.DataString));
  finally
    Response.Free;
  end;
end;

function THuggingFaceAPI.Get<TResult>(const Path: string): TResult;
var
  Response: TStringStream;
  Code: Integer;
begin
  CustomHeaders := [TNetHeader.Create('accept', 'application/json')];
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Code := Get(Path, Response);

    with TStringList.Create do
    try
      Text := Response.DataString;
      SaveToFile('Response.JSON', TEncoding.UTF8);
    finally
      Free;
    end;

    Result := ParseResponse<TResult>(Code, ArrayToObject(Response.DataString));
  finally
    Response.Free;
  end;
end;

function THuggingFaceAPI.GetArray<TResult>(const Path: string): TResult;
var
  Response: TStringStream;
  Code: Integer;
begin
  CustomHeaders := [TNetHeader.Create('accept', 'application/json')];
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Code := Get(Path, Response);
    var Data := Response.DataString.Trim([#10]);
    if Data.StartsWith('[') then
      Data := Format('{"result":%s}', [Data]);
    Result := ParseResponse<TResult>(Code, Data);
  finally
    Response.Free;
  end;
end;

function THuggingFaceAPI.GetClient: THTTPClient;
begin
  Result := THTTPClient.Create;
  Result.AcceptCharSet := 'utf-8';
end;

procedure THuggingFaceAPI.GetFile(const Path: string; Response: TStream);
var
  Code: Integer;
  Strings: TStringStream;
  Client: THTTPClient;
begin
  CheckAPI;
  Client := GetClient;
  try
    Code := Client.Get(GetRequestURL(Path), Response, GetHeaders).StatusCode;
    case Code of
      200..299:
        ; {success}
    else
      Strings := TStringStream.Create;
      try
        Response.Position := 0;
        Strings.LoadFromStream(Response);
        ParseError(Code, Strings.DataString);
      finally
        Strings.Free;
      end;
    end;
  finally
    Client.Free;
  end;
end;

function THuggingFaceAPI.GetHeaders: TNetHeaders;
begin
  Result :=
    [TNetHeader.Create('authorization', 'Bearer ' + FToken)] +
    [TNetHeader.Create('x-use-cache', BoolToStr(FUseCache, True))]+
    [TNetHeader.Create('x-wait-for-model', BoolToStr(FWaitForModel, True))]+
    FCustomHeaders;
end;

function THuggingFaceAPI.GetHeaderValue(const KeyName: string;
  const Value: TNetHeaders): string;
begin
  for var Item in Value do
    if Item.Name.ToLower = KeyName.ToLower then
      begin
        Result := Item.Value;
        case IndexStr(KeyName.ToLower, ['link']) of
          0: Result := THeaderUtils.LinkExtract(Result);
        end;
        Break;
      end;
end;

function THuggingFaceAPI.GetLink(const Link: string; Response: TStringStream;
  var ResponseHeader: TNetHeaders): Integer;
var
  Client: THTTPClient;
begin
  CheckAPI;
  Client := GetClient;
  try
    var Data := Client.Get(Link, Response, GetHeaders);
    ResponseHeader := Data.Headers;
    Result := Data.StatusCode;
  finally
    Client.Free;
  end;
end;

function THuggingFaceAPI.GetLink<TResult>(var Link: string): TResult;
var
  Response: TStringStream;
  Code: Integer;
  ResponseHeader: TNetHeaders;
begin
  CustomHeaders := [TNetHeader.Create('accept', 'application/json')];
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Code := GetLink(Link, Response, ResponseHeader);
    Link := GetHeaderValue('link', ResponseHeader);
    Result := ParseResponse<TResult>(Code, ArrayToObject(Response.DataString));
  finally
    Response.Free;
  end;
end;

function THuggingFaceAPI.GetPath<TParams>(const Path: string;
  const Value: TParams): string;
begin
  var M := TJSON.JsonToObject<TModel>(Value.JSON);
  try
    if M.Model.IsEmpty then
      Exit(Path);

    if TParams.InheritsFrom(TJSONChatParam) then
      Exit(Format('%s/%s/v1/chat/completions', [Path, M.Model]));

    if TParams.InheritsFrom(TJSONModelParam) then
      Exit(Format('%s/%s', [Path, M.Model]));

    Result := Path;
  finally
    M.Free;
  end;
end;

function THuggingFaceAPI.GetRequestURL(const Path: string): string;
begin
  Result := Format('%s/%s', [FBaseURL, Path]);
end;

function THuggingFaceAPI.ArrayToObject(const Response: string): string;
begin
  Result := Response.Replace(#10, '');
//  if Result.StartsWith('[[[') then
//    begin
//      Result := Result.Substring(2, Result.Length - 2);
//      with TStringList.Create do
//      try
//        Text := Result;
//        SaveToFile('Debug.txt', TEncoding.UTF8);
//      finally
//        Free;
//      end;
//    end;
  if Result.StartsWith('[') then
    begin
      Result := ArrayToObject(Result.Substring(1, Result.Length - 2));
      Result := Format('{"items":[%s]}', [Result])
    end
  else
    begin
      Result := Response;
    end;
end;

procedure THuggingFaceAPI.CheckAPI;
begin
  if FToken.IsEmpty then
    raise HuggingFaceExceptionAPI.Create('Token is empty!');
  if FBaseUrl.IsEmpty then
    raise HuggingFaceExceptionAPI.Create('Base url is empty!');
end;

procedure THuggingFaceAPI.RaiseError(Code: Int64; Error: TErrorCore);
begin
  case Code of
    {--- Client Error Codes }
    400:
      raise HuggingFaceExceptionBadRequestError.Create(Code, Error);
    401:
      raise HuggingFaceExceptionUnauthorizedError.Create(Code, Error);
    403:
      raise HuggingFaceExceptionContentModerationError.Create(Code, Error);
    404:
      raise HuggingFaceExceptionNotFoundError.Create(Code, Error);
    413:
      raise HuggingFaceExceptionPayloadTooLargeError.Create(Code, Error);
    422:
      raise HuggingFaceExceptionInvalidLanguageError.Create(Code, Error);
    429:
      raise HuggingFaceExceptionRateLimitExceededError.Create(Code, Error);
    {--- Server Error Codes }
    500:
      raise HuggingFaceExceptionInternalServerError.Create(Code, Error);
  else
    raise HuggingFaceException.Create(Code, Error);
  end;
end;

procedure THuggingFaceAPI.ParseError(const Code: Int64; const ResponseText: string);
var
  Error: TErrorCore;
begin
  Error := nil;
  try
    try
      Error := TJson.JsonToObject<TError>(ResponseText);
    except
      Error := nil;
    end;
    if Assigned(Error) and Assigned(Error) then
      RaiseError(Code, Error)
  finally
    if Assigned(Error) then
      Error.Free;
  end;
end;

function THuggingFaceAPI.ParseResponse<T>(const Code: Int64; const ResponseText: string): T;
begin
  Result := nil;
  case Code of
    200..299:
      try
        Result := TJson.JsonToObject<T>(ResponseText)
      except
        FreeAndNil(Result);
      end;
  else
    ParseError(Code, ResponseText);
  end;
  if not Assigned(Result) then
    raise HuggingFaceExceptionInvalidResponse.Create(Code, 'Empty or invalid response');
end;

procedure THuggingFaceAPI.SetBaseUrl(const Value: string);
begin
  FBaseUrl := Value;
end;

procedure THuggingFaceAPI.SetCustomHeaders(const Value: TNetHeaders);
begin
  FCustomHeaders := Value;
end;

procedure THuggingFaceAPI.SetToken(const Value: string);
begin
  FToken := Value;
end;

procedure THuggingFaceAPI.SetUseCache(const Value: Boolean);
begin
  FUseCache := Value;
end;

procedure THuggingFaceAPI.SetWaitForModel(const Value: Boolean);
begin
  FWaitForModel := Value;
end;

function THuggingFaceAPI.ToStringValueFor(const Value: string): string;
begin
  Result := ToStringValueFor(Value, FieldsToString);
end;

function THuggingFaceAPI.ToStringValueFor(const Value, Field: string): string;
begin
  Result := Value;
  var i := Pos(Field, Result);
  while (i > 0) and (i < Result.Length) do
    begin
      i := i + Field.Length - 1;
      Result[i] := '"';
      Inc(i);
      var j := 0;
      while (j > 0) or ((j = 0) and not (Result[i] = '}')) do
        begin
          case Result[i] of
            '{':
              Inc(j);
            '}':
              j := j - 1;
            '"':
              Result[i] := '`';
          end;
          Inc(i);
          if i > Result.Length then
            raise Exception.Create('Invalid JSON string');
        end;
      Result[i] := '"';
      i := Pos(Field, Result);
    end;
end;

function THuggingFaceAPI.ToStringValueFor(const Value: string;
  const Field: TArray<string>): string;
begin
  Result := Value;
  if Length(Field) > 0 then
    begin
      for var Item in Field do
        Result := ToStringValueFor(Result, Item);
    end;
end;

{ THuggingFaceAPIRoute }

constructor THuggingFaceAPIRoute.CreateRoute(AAPI: THuggingFaceAPI);
begin
  inherited Create;
  FAPI := AAPI;
end;

procedure THuggingFaceAPIRoute.SetAPI(const Value: THuggingFaceAPI);
begin
  FAPI := Value;
end;

{ HuggingFaceException }

constructor HuggingFaceException.Create(const ACode: Int64; const Value: string);
begin
  Code := ACode;
  inherited Create(Format('error %d: %s', [ACode, Value]));
end;

function HuggingFaceException.ToMessageString: string;
begin
  if Error.IsEmpty then
    Error := string.join(#10, Warnings)
  else
    Error := Error + #10 + string.join(#10, Warnings);
  Result := Format('error (%d)', [Code]);
  if not Name.IsEmpty then
    Result := Format('%s - type %s', [Result, Name]);
  Result := Format('%s' + sLineBreak + '%s', [Result, Error]);
  if EstimatedTime > 0 then
    Result := Format('%s Estimated time : %s', [Result, EstimatedTime.ToString(ffNumber, 2, 2)]);
end;

constructor HuggingFaceException.Create(const ACode: Int64; const AError: TErrorCore);
begin
  Code := ACode;
  Id := (AError as TError).Id;
  Name := (AError as TError).Name;
  Error := (AError as TError).Error;
  Warnings := (AError as TError).Warnings;
  EstimatedTime := (AError as TError).EstimatedTime;
  inherited Create(ToMessageString);
end;

{ THeaderUtils }

class function THeaderUtils.LinkExtract(const Value: string): string;
begin
  Result := Value.Substring(1, Value.IndexOf('>') - 1);
end;

end.

unit HuggingFace.Async.Params;

{-------------------------------------------------------------------------------

      Unit containing generic interfaces and classes for managing parameters
      across  various  asynchronous  operations.

      The HuggingFace.Async.Params  unit  provides  a set of tools for creating
      and managing  parameter  instances  using  generic  types. The primary
      components include:

      - IUseParams<T>: A generic interface for managing parameters of type T.
      - TUseParams<T>: A class  implementing  the IUseParams<T>  interface to
        encapsulate  parameter  handling.
      - TUseParamsFactory<T>: A  factory  class  for  creating  instances  of
        IUseParams<T>.

      These abstractions allow for  a flexible and  reusable  way  to  handle
      parameters  across  different  modules  and  contexts,  particularly in
      asynchronous  scenarios  such  as  chat  operations.

      Note  that  This  unit  is  designed   to  work   seamlessly  with  the
      Gemini.Chat.AsyncEvents unit,  which  relies  on  IUseParams<T> and
      TUseParamsFactory<T>  to  manage   parameters   for  asynchronous  chat
      requests.

        Github repository :  https://github.com/MaxiDonkey/DelphiHuggingFace
        Visit the Github repository for the documentation and use examples

-------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes;

type
  /// <summary>
  /// Generic interface for managing parameters of type <c>T</c>.
  /// </summary>
  /// <typeparam name="T">
  /// The type of the parameters.
  /// </typeparam>
  IUseParams<T> = interface
    ['{18566F2C-F2D9-4257-A460-D9AE8F053357}']
    /// <summary>
    /// Sets the parameters.
    /// </summary>
    /// <param name="Value">
    /// The value of the parameters to be set.
    /// </param>
    procedure SetParams(const Value: T);
    /// <summary>
    /// Gets the current parameters.
    /// </summary>
    /// <returns>
    /// The current parameters of type <c>T</c>.
    /// </returns>
    function GetParams: T;
    /// <summary>
    /// Assigns the parameters using a function.
    /// </summary>
    /// <param name="Value">
    /// A function that returns parameters of type <c>T</c>.
    /// </param>
    procedure Assign(Value: TFunc<T>);
    /// <summary>
    /// Returns the current instance as an object of type <c>TObject</c>.
    /// </summary>
    /// <returns>
    /// The instance cast to <c>TObject</c>.
    /// </returns>
    function AsSender: TObject;
    /// <summary>
    /// Provides access to the parameters as a property.
    /// </summary>
    property Param: T read GetParams write SetParams;
  end;

  /// <summary>
  /// A factory class for creating instances of <c>IUseParams</c>.
  /// </summary>
  /// <param name="T">
  /// The type of the parameters for which the instance is created.
  /// </param>
  TUseParamsFactory<T> = class
    /// <summary>
    /// Creates and returns a new instance of <c>IUseParams</c> for the specified type <c>T</c>.
    /// </summary>
    /// <returns>
    /// A new instance of <c>IUseParams&lt;T&gt;</c>.
    /// </returns>
    class function CreateInstance: IUseParams<T>; overload;
    /// <summary>
    /// Creates and returns a new instance of <c>IUseParams</c> for the specified type <c>T</c>, using the provided function.
    /// </summary>
    /// <param name="Value">
    /// A function that provides the parameter values for the instance.
    /// </param>
    /// <returns>
    /// A new instance of <c>IUseParams&lt;T&gt;</c>.
    /// </returns>
    class function CreateInstance(Value: TFunc<T>): IUseParams<T>; overload;
  end;

  /// <summary>
  /// A generic class implementing the <c>IUseParams</c> interface to manage parameters of type <c>T</c>.
  /// </summary>
  /// <param name="T">
  /// The type of the parameters.
  /// </param>
  TUseParams<T> = class(TInterfacedObject, IUseParams<T>)
  private
    FParams: T;
    /// <summary>
    /// Sets the parameters to the provided value.
    /// </summary>
    /// <param name="Value">
    /// The new parameters value.
    /// </param>
    procedure SetParams(const Value: T);
    /// <summary>
    /// Retrieves the current parameters value.
    /// </summary>
    /// <returns>
    /// The current parameters.
    /// </returns>
    function GetParams: T;
  protected
    /// <summary>
    /// Casts the instance as a <c>TObject</c> for use as the sender of events.
    /// </summary>
    /// <returns>
    /// The current instance cast to <c>TObject</c>.
    /// </returns>
    function AsSender: TObject;
    /// <summary>
    /// Assigns the parameters using a function that returns type <c>T</c>.
    /// </summary>
    /// <param name="Value">
    /// A function that sets the parameters.
    /// </param>
    procedure Assign(Value: TFunc<T>);
  public
    /// <summary>
    /// Property to get or set the parameters.
    /// </summary>
    property Params: T read GetParams write SetParams;
  end;

implementation

{ TUseParams<T> }

function TUseParams<T>.AsSender: TObject;
begin
  Result := Self;
end;

procedure TUseParams<T>.Assign(Value: TFunc<T>);
begin
  if Assigned(Value) then
    begin
      Params := Value();
    end;
end;

function TUseParams<T>.GetParams: T;
begin
  Result := FParams;
end;

procedure TUseParams<T>.SetParams(const Value: T);
begin
  FParams := Value;
end;

{ TUseParamsFactory<T> }

class function TUseParamsFactory<T>.CreateInstance: IUseParams<T>;
begin
  Result := TUseParams<T>.Create;
end;

class function TUseParamsFactory<T>.CreateInstance(
  Value: TFunc<T>): IUseParams<T>;
begin
  Result := CreateInstance;
  Result.Assign(Value);
end;

end.


unit HuggingFace.Async.Support;

{-------------------------------------------------------------------------------

      Unit containing  records for managing  asynchronous events related to
      chat requests.

      The  HuggingFace.Chat.AsyncEvents  unit  provides  definitions for the
      TAsyncParams<T>  and  TAsynStreamParams<T>  records, which  are  used
      to  handle  the lifecycle  of asynchronous chat operations, including
      starting, progressing, succeeding, and handling errors.
      These records enable non-blocking operations for chat functionalities
      and can be reused across multiple modules.

      This unit depends  on HuggingFace.Async.Params  for parameter management.
      The IUseParams<T>  and  TUseParamsFactory<T>  interfaces  and  classes
      from  HuggingFace.Params.Core  are  utilized  to  create and manage the
      parameter  instances  for  asynchronous  operations.

        Github repository :  https://github.com/MaxiDonkey/DelphiHuggingFace
        Visit the Github repository for the documentation and use examples

-------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, system.Classes, System.Threading, HuggingFace.Async.Params;

type
  /// <summary>
  /// Record used to handle asynchronous request events.
  /// </summary>
  /// <remarks>
  /// <c>TAsynCallBack</c> manages the lifecycle of an asynchronous request.
  /// It provides callbacks for different stages of the request, such as start, successful completion, or error.
  /// </remarks>
  TAsynCallBack<T> = record
  private
    FSender: TObject;
    FOnStart: TProc<TObject>;
    FOnSuccess: TProc<TObject, T>;
    FOnError: TProc<TObject, string>;
  public
    /// <summary>
    /// Object representing the sender of the asynchronous operation.
    /// </summary>
    /// <remarks>
    /// The <c>Sender</c> property is used to identify or store a reference to the object that initiated the request.
    /// This can be useful for providing context in the callback procedures.
    /// </remarks>
    property Sender: TObject read FSender write FSender;
    /// <summary>
    /// Event triggered at the start of the asynchronous request.
    /// </summary>
    /// <remarks>
    /// The <c>OnStart</c> event is called when the request begins.
    /// It can be used to initialize any required state or display a loading indicator to the user.
    /// <code>
    /// OnStart :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // Code executed at the start of the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnStart: TProc<TObject> read FOnStart write FOnStart;
    /// <summary>
    /// Event triggered at the end of the asynchronous request.
    /// </summary>
    /// <param name="Sender">
    /// Object that initiated the request, generally used for context.
    /// </param>
    /// <param name="Result">
    /// The result of type <c>T</c> returned at the end of the request.
    /// This event is used to process the final result of the asynchronous operation.
    /// </param>
    /// <remarks>
    /// The <c>OnSuccess</c> event is invoked when the process completes successfully.
    /// It can be used to perform final actions based on the received result.
    /// <code>
    /// OnSuccess :=
    ///    procedure (Sender: TObject; Result: T)
    ///    begin
    ///      // Code executed at the end of the request with the obtained result
    ///    end;
    /// </code>
    /// </remarks>
    property OnSuccess: TProc<TObject, T> read FOnSuccess write FOnSuccess;
    /// <summary>
    /// Event triggered when an error occurs during the asynchronous request.
    /// </summary>
    /// <param name="Sender">
    /// Object that initiated the request, generally used for context.
    /// </param>
    /// <param name="ErrorMessage">
    /// The error message received, which can be logged or displayed to the user.
    /// </param>
    /// <remarks>
    /// The <c>OnError</c> event is called when an error occurs during the asynchronous operation.
    /// It can be used to handle failures, display error messages, or perform any necessary cleanup actions.
    /// <code>
    /// OnError :=
    ///    procedure (Sender: TObject; ErrorMessage: string)
    ///    begin
    ///      // Code executed when an error occurs during the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnError: TProc<TObject, string> read FOnError write FOnError;
  end;

  /// <summary>
  /// Class used to manage asynchronous execution with callback events.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynCallBackExec&lt;T, U&gt;</c> class allows you to execute asynchronous operations with specified callbacks for start, completion, and error events.
  /// It encapsulates the asynchronous execution logic, handling thread management and exception handling, providing an easy way to manage the lifecycle of an asynchronous request.
  /// </remarks>
  TAsynCallBackExec<T; U: class> = class
  private
    FUse: IUseParams<T>;
    FSender: TObject;
    FOnStart: TProc<TObject>;
    FOnSuccess: TProc<TObject, U>;
    FOnError: TProc<TObject, string>;
  public
    /// <summary>
    /// Gets the <c>IUseParams&lt;T&gt;</c> interface instance used by this class.
    /// </summary>
    /// <value>
    /// An instance of <c>IUseParams&lt;T&gt;</c> that provides parameter management functionality.
    /// </value>
    property Use: IUseParams<T> read FUse;
    /// <summary>
    /// The object representing the sender of the asynchronous operation.
    /// </summary>
    /// <value>
    /// An instance of <c>TObject</c> identifying the originator of the operation.
    /// </value>
    /// <remarks>
    /// This property can be set to identify the object that initiated the asynchronous operation, which is useful in callback methods.
    /// </remarks>
    property Sender: TObject read FSender write FSender;
    /// <summary>
    /// Event triggered when the asynchronous operation starts.
    /// </summary>
    /// <value>
    /// A procedure of type <c>TProc&lt;TObject&gt;</c> to handle any setup or UI updates when the operation begins.
    /// </value>
    /// <remarks>
    /// Assign a procedure to this event to perform actions at the start of the asynchronous operation.
    /// <code>
    /// OnStart :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // Code executed at the start of the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnStart: TProc<TObject> read FOnStart write FOnStart;
    /// <summary>
    /// Event triggered when the asynchronous operation completes successfully.
    /// </summary>
    /// <value>
    /// A procedure of type <c>TProc&lt;TObject, U&gt;</c> to handle the result of the operation.
    /// </value>
    /// <remarks>
    /// Assign a procedure to this event to process the result returned by the operation.
    /// <code>
    /// OnSuccess :=
    ///    procedure (Sender: TObject; Result: T)
    ///    begin
    ///      // Code executed at the end of the request with the obtained result
    ///    end;
    /// </code>
    /// </remarks>
    property OnSuccess: TProc<TObject, U> read FOnSuccess write FOnSuccess;
    /// <summary>
    /// Event triggered when an error occurs during the asynchronous operation.
    /// </summary>
    /// <value>
    /// A procedure of type <c>TProc&lt;TObject, string&gt;</c> to handle exceptions or errors.
    /// </value>
    /// <remarks>
    /// Assign a procedure to this event to handle any exceptions or errors that occur during execution.
    /// <code>
    /// OnError :=
    ///    procedure (Sender: TObject; ErrorMessage: string)
    ///    begin
    ///      // Code executed when an error occurs during the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnError: TProc<TObject, string> read FOnError write FOnError;
    /// <summary>
    /// Executes the specified function asynchronously.
    /// </summary>
    /// <param name="Value">
    /// A function of type <c>TFunc&lt;U&gt;</c> representing the operation to execute asynchronously.
    /// </param>
    /// <remarks>
    /// This method creates and starts an asynchronous task that executes the provided function.
    /// It invokes the <c>OnStart</c> event before execution, the <c>OnSuccess</c> event upon successful completion, and the <c>OnError</c> event if an exception occurs during execution.
    /// </remarks>
    procedure Run(Value: TFunc<U>);
    /// <summary>
    /// Initializes a new instance of the <c>TAsynCallBackExec&lt;T, U&gt;</c> class with the specified parameter function.
    /// </summary>
    /// <param name="Value">
    /// A function of type <c>TFunc&lt;T&gt;</c> used to create an instance of <c>IUseParams&lt;T&gt;</c>.
    /// </param>
    /// <remarks>
    /// The constructor initializes the internal <c>IUseParams&lt;T&gt;</c> interface using the provided function.
    /// </remarks>
    constructor Create(const Value: TFunc<T>);
  end;

  /// <summary>
  /// Record used to manage asynchronous events for a streaming chat request.
  /// </summary>
  /// <remarks>
  /// <c>TAsynChatStreamParams</c> allows you to handle the lifecycle of a chat request in streaming mode.
  /// It provides callbacks for different stages such as when the request starts, progresses, succeeds, encounters an error, or needs to be canceled.
  /// </remarks>
  TAsynStreamCallBack<T> = record
  private
    FSender: TObject;
    FOnStart: TProc<TObject>;
    FOnSuccess: TProc<TObject>;
    FOnProgress: TProc<TObject, T>;
    FOnError: TProc<TObject, string>;
    FOnCancellation: TProc<TObject>;
    FOnDoCancel: TFunc<Boolean>;
  public
    /// <summary>
    /// The object representing the sender of the asynchronous operation.
    /// </summary>
    /// <remarks>
    /// The <c>Sender</c> property is used to identify or store a reference to the object that initiated the chat request,
    /// which can be useful for context within the callback procedures.
    /// </remarks>
    property Sender: TObject read FSender write FSender;
    /// <summary>
    /// Event triggered when the asynchronous chat request starts.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="Chat">
    /// The <c>TChat</c> object representing the current response chunk received from the model.
    /// This event can be used to update the user interface as new tokens are streamed in.
    /// </param>
    /// <remarks>
    /// The <c>OnStart</c> event is called when the chat request begins. It can be used to set up any initial state or display a loading indicator to the user.
    /// <code>
    /// OnStart :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // code when chat request begin
    ///    end;
    /// </code>
    /// </remarks>
    property OnStart: TProc<TObject> read FOnStart write FOnStart;
    /// <summary>
    /// Event triggered when the asynchronous chat request completes successfully.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="Chat">
    /// The <c>TChat</c> object representing the current response chunk received from the model.
    /// This event can be used to update the user interface as new tokens are streamed in.
    /// </param>
    /// <remarks>
    /// The <c>OnSuccess</c> event is invoked when the streaming process finishes successfully.
    /// It does not provide additional data, as the result is expected to have been handled progressively via the <c>OnProgress</c> event.
    /// <code>
    /// OnSuccess :=
    ///    procedure (Sender: TObject; Chat: TChat)
    ///    begin
    ///      // code when the streaming process finishes successfully
    ///    end;
    /// </code>
    /// </remarks>
    property OnSuccess: TProc<TObject> read FOnSuccess write FOnSuccess;
    /// <summary>
    /// Event triggered to handle progress during the streaming chat request.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="Chat">
    /// The <c>TChat</c> object representing the current response chunk received from the model.
    /// This event can be used to update the user interface as new tokens are streamed in.
    /// </param>
    /// <remarks>
    /// The <c>OnProgress</c> event is fired every time a new chunk of data is received during the streaming process.
    /// This allows the application to handle the response progressively as it is generated by the model.
    /// <code>
    /// OnProgress :=
    ///    procedure (Sender: TObject; Chat: TChat)
    ///    begin
    ///      // code to handle the response progressively
    ///    end;
    /// </code>
    /// </remarks>
    property OnProgress: TProc<TObject, T> read FOnProgress write FOnProgress;
    /// <summary>
    /// Event triggered when an error occurs during the asynchronous chat request.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="ErrorMessage">
    /// The error message received, which can be logged or displayed to the user.
    /// </param>
    /// <remarks>
    /// The <c>OnError</c> event is called when an error occurs during the streaming process.
    /// This can be used to handle failures, show error messages, or perform any necessary clean-up actions.
    /// <code>
    /// OnError :=
    ///    procedure (Sender: TObject; message: string)
    ///    begin
    ///      // code to handle an error occurs during the streaming process
    ///    end;
    /// </code>
    /// </remarks>
    property OnError: TProc<TObject, string> read FOnError write FOnError;
    /// <summary>
    /// Event triggered when the asynchronous chat request has been canceled.
    /// </summary>
    /// <remarks>
    /// The <c>OnCancellation</c> event is fired when the chat request is canceled by the user or the application.
    /// This can be used to perform clean-up operations or notify the user that the request has been terminated.
    /// <code>
    /// OnCancellation :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // code to handle chat request cancellation
    ///    end;
    /// </code>
    /// </remarks>
    property OnCancellation: TProc<TObject> read FOnCancellation write FOnCancellation;
    /// <summary>
    /// Function called to determine if the asynchronous chat request should be canceled.
    /// </summary>
    /// <returns>
    /// A <c>Boolean</c> value indicating whether the request should be canceled (<c>True</c>) or allowed to continue (<c>False</c>).
    /// </returns>
    /// <remarks>
    /// The <c>OnDoCancel</c> function is periodically invoked to check whether the user or application has requested to cancel the chat request.
    /// If the function returns <c>True</c>, the streaming process will be aborted.
    /// <code>
    /// OnDoCancel :=
    ///    function : Boolean
    ///    begin
    ///      Result := ... // True to stop the streaming process
    ///    end;
    /// </code>
    /// </remarks>
    property OnDoCancel: TFunc<Boolean> read FOnDoCancel write FOnDoCancel;
  end;

implementation

{ TAsynCallBackExec<T, U> }

constructor TAsynCallBackExec<T, U>.Create(const Value: TFunc<T>);
begin
  inherited Create;
  FUse := TUseParamsFactory<T>.CreateInstance(Value);
end;

procedure TAsynCallBackExec<T, U>.Run(Value: TFunc<U>);
begin
  {--- Assign callback values to internal variables for asynchrony to work properly }
  var InternalSender := Sender;
  var InternalOnStart := OnStart;
  var InternalOnSuccess := OnSuccess;
  var InternalOnError := OnError;

  var Task: ITask := TTask.Create(
          procedure()
          begin
            try
              {--- Pass the instance of the current class in case no value was specified. }
              if not Assigned(InternalSender) then
                InternalSender := Self;

              {--- Trigger OnStart callback }
              if Assigned(InternalOnStart) then
                TThread.Queue(nil,
                  procedure
                  begin
                    InternalOnStart(InternalSender);
                  end);

              {--- Processing }
              var Result := Value();

              {--- Trigger OnEnd callback when the process is done }
              TThread.Queue(nil,
                  procedure
                  begin
                    try
                      if Assigned(InternalOnSuccess) then
                        InternalOnSuccess(InternalSender, Result);
                    finally
                      {--- Makes sure to release the instance containing the data obtained
                           following processing}
                      if Assigned(Result) then
                        Result.Free;
                    end;
                  end);

            except
              on E: Exception do
                begin
                  var Error := AcquireExceptionObject;
                  try
                    var ErrorMsg := (Error as Exception).Message;

                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(InternalOnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        InternalOnError(InternalSender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
          end);
  Task.Start;
end;

end.

unit HuggingFace.Audio;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiHuggingFace
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, Rest.Json,
  REST.Json.Types, System.Net.URLClient, HuggingFace.API, HuggingFace.API.Params,
  HuggingFace.Async.Support, HuggingFace.Types;

type

  {$REGION 'Audio-To-Text'}

  TGenerationParameters = class(TJSONParam)
  public
    /// <summary>
    /// The value used to modulate the next token probabilities.
    /// </summary>
    function Temperature(const Value: Double): TGenerationParameters;
    /// <summary>
    /// The number of highest probability vocabulary tokens to keep for top-k-filtering.
    /// </summary>
    function TopK(const Value: Integer): TGenerationParameters;
    /// <summary>
    /// If set to float < 1, only the smallest set of most probable tokens with probabilities that
    /// add up to top_p or higher are kept for generation.
    /// </summary>
    function TopP(const Value: Double): TGenerationParameters;
    /// <summary>
    /// Local typicality measures how similar the conditional probability of predicting a target token
    /// next is to the expected conditional probability of predicting a random token next, given the
    /// partial text already generated. If set to float < 1, the smallest set of the most locally typical
    /// tokens with probabilities that add up to typical_p or higher are kept for generation.
    /// </summary>
    function TypicalP(const Value: Double): TGenerationParameters;
    /// <summary>
    /// If set to float strictly between 0 and 1, only tokens with a conditional probability greater
    /// than epsilon_cutoff will be sampled. In the paper, suggested values range from 3e-4 to 9e-4,
    /// depending on the size of the model.
    /// </summary>
    function EpsilonCutoff(const Value: Double): TGenerationParameters;
    /// <summary>
    /// Eta sampling is a hybrid of locally typical sampling and epsilon sampling. If set to float
    /// strictly between 0 and 1, a token is only considered if it is greater than either eta_cutoff
    /// or sqrt(eta_cutoff) * exp(-entropy(softmax(next_token_logits))). The latter term is intuitively
    /// the expected next token probability, scaled by sqrt(eta_cutoff). In the paper, suggested values
    /// range from 3e-4 to 2e-3, depending on the size of the model.
    /// </summary>
    function EtaCutoff(const Value: Double): TGenerationParameters;
    /// <summary>
    /// The maximum length (in tokens) of the generated text, including the input.
    /// </summary>
    function MaxLength(const Value: Integer): TGenerationParameters;
    /// <summary>
    /// The maximum number of tokens to generate. Takes precedence over max_length.
    /// </summary>
    function MaxNewTokens(const Value: Integer): TGenerationParameters;
    /// <summary>
    /// The minimum length (in tokens) of the generated text, including the input.
    /// </summary>
    function MinLength(const Value: Integer): TGenerationParameters;
    /// <summary>
    /// The minimum number of tokens to generate. Takes precedence over min_length.
    /// </summary>
    function MinNewTokens(const Value: Integer): TGenerationParameters;
    /// <summary>
    /// Whether to use sampling instead of greedy decoding when generating new tokens.
    /// </summary>
    function DoSample(const Value: Boolean): TGenerationParameters;
    /// <summary>
    /// Possible values: never, true, false.
    /// </summary>
    function EarlyStopping(const Value: TEarlyStopping): TGenerationParameters;
    /// <summary>
    /// Number of beams to use for beam search.
    /// </summary>
    function NumBeams(const Value: Integer): TGenerationParameters;
    /// <summary>
    /// Number of groups to divide num_beams into in order to ensure diversity among different groups
    /// of beams.
    /// </summary>
    function NumBeamGroups(const Value: Integer): TGenerationParameters;
    /// <summary>
    /// The value balances the model confidence and the degeneration penalty in contrastive search decoding.
    /// </summary>
    function PenaltyAlpha(const Value: Double): TGenerationParameters;
    /// <summary>
    /// Whether the model should use the past last key/values attentions to speed up decoding
    /// </summary>
    function UseCache(const Value: Boolean): TGenerationParameters;
  end;

  TRecognitionParameters = class(TJSONParam)
  public
    /// <summary>
    /// Whether to output corresponding timestamps with the generated text
    /// </summary>
    function ReturnTimestamps(const Value: Boolean): TRecognitionParameters;
  end;

  TAudioToTextParam = class(TJSONModelParam)
  public
    /// <summary>
    /// The input audio data as a base64-encoded string.
    /// </summary>
    /// <param name="FileName">
    /// The path and the name of the audio file
    /// </param>
    function Inputs(const FileName: string): TAudioToTextParam;
    /// <summary>
    /// Define generation parameters
    /// </summary>
    function Parameters(const Value: TJSONObject): TAudioToTextParam;
    /// <summary>
    /// Define generation parameters
    /// </summary>
    function GenerationParameters(ParamProc: TProcRef<TGenerationParameters>): TAudioToTextParam; overload;
  end;

  TAudioChunk = class
  private
    FText: string;
    FTimestamps: TArray<Double>;
  public
    /// <summary>
    /// A chunk of text identified by the model.
    /// </summary>
    property Text: string read FText write FText;
    /// <summary>
    /// The start and end timestamps corresponding with the text.
    /// </summary>
    property Timestamps: TArray<Double> read FTimestamps write FTimestamps;
  end;

  TAudioToText = class
  private
    FText: string;
    FChunks: TArray<TAudioChunk>;
  public
    /// <summary>
    /// The recognized text.
    /// </summary>
    property Text: string read FText write FText;
    /// <summary>
    /// When returnTimestamps is enabled, chunks contains a list of audio chunks identified by the model.
    /// </summary>
    property Chunks: TArray<TAudioChunk> read FChunks write FChunks;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TAudioToText</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynAudioToText</c> type extends the <c>TAsynParams&lt;TAudioToText&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynAudioToText = TAsynCallBack<TAudioToText>;

  {$ENDREGION}

  {$REGION 'Audio-Classification'}

  TAudioClassificationParameters = class(TJSONParam)
  public
    /// <summary>
    /// Possible values: sigmoid, softmax, none.
    /// </summary>
    function FunctionToApply(const Value: TFunctionClassification): TAudioClassificationParameters;
    /// <summary>
    /// When specified, limits the output to the top K most probable classes.
    /// </summary>
    function TopK(const Value: Integer): TAudioClassificationParameters;
  end;

  TAudioClassificationParam = class(TJSONModelParam)
  public
    /// <summary>
    /// The input audio data as a base64-encoded string.
    /// </summary>
    /// <param name="FileName">
    /// The path and the name of the audio file
    /// </param>
    function Inputs(const FileName: string): TAudioClassificationParam;
    /// <summary>
    /// Classification parameters
    /// </summary>
    function Parameters(const FunctionToApply: TFunctionClassification; const TopK: Integer = -1): TAudioClassificationParam; overload;
    /// <summary>
    /// Classification parameters
    /// </summary>
    function Parameters(const TopK: Integer): TAudioClassificationParam; overload;
  end;

  TAudioClassificationItem = class
  private
    FLabel: string;
    FScore: Double;
  public
    /// <summary>
    /// The predicted class label.
    /// </summary>
    property &Label: string read FLabel write FLabel;
    /// <summary>
    /// The corresponding probability.
    /// </summary>
    property Score: Double read FScore write FScore;
  end;

  TAudioClassification = class
  private
    FItems: TArray<TAudioClassificationItem>;
  public
    /// <summary>
    /// Output is an array of objects.
    /// </summary>
    property Items: TArray<TAudioClassificationItem> read FItems write FItems;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TAudioClassification</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynAudioClassification</c> type extends the <c>TAsynParams&lt;TAudioClassification&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynAudioClassification = TAsynCallBack<TAudioClassification>;

  {$ENDREGION}

  {$REGION 'Audio-To-Audio'}

  TAudioToAudioParam = class(TJSONModelParam)
  public
    /// <summary>
    /// The input audio data as a base64-encoded string.
    /// </summary>
    /// <param name="FileName">
    /// The path and the name of the audio file
    /// </param>
    function Inputs(const FileName: string): TAudioToAudioParam;
  end;

  TAudioToAudio = class
  private
    FFileName: string;
    FAudio: string;
  public
    /// <summary>
    /// Retrieves the generated audio as a <c>TStream</c>.
    /// </summary>
    /// <returns>
    /// A <c>TStream</c> containing the decoded audio data.
    /// </returns>
    /// <remarks>
    /// This method decodes the base64-encoded audio data and returns it as a stream.
    /// The caller is responsible for freeing the returned stream.
    /// </remarks>
    /// <exception cref="Exception">
    /// Raises an exception if both the audio are empty.
    /// </exception>
    function GetStream: TStream;
    /// <summary>
    /// Saves the generated audio to a file.
    /// </summary>
    /// <param name="FileName">
    /// The file path where the audio will be saved.
    /// </param>
    /// <remarks>
    /// This method decodes the base64-encoded audio data and saves it to the specified file.
    /// </remarks>
    /// <exception cref="Exception">
    /// Raises an exception if the audio data cannot be decoded or saved.
    /// </exception>
    procedure SaveToFile(const FileName: string);
    /// <summary>
    /// The base64-encoded audio data.
    /// </summary>
    property Audio: string read FAudio write FAudio;
    /// <summary>
    /// Gets the file name where the audio was saved.
    /// </summary>
    /// <value>
    /// The file path as a string.
    /// </value>
    /// <remarks>
    /// This property holds the file name specified in the last call to <c>SaveToFile</c>.
    /// </remarks>
    property FileName: string read FFileName write FFileName;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TAudioToAudio</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynAudioToAudio</c> type extends the <c>TAsynParams&lt;TAudioToAudio&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynAudioToAudio = TAsynCallBack<TAudioToAudio>;

  {$ENDREGION}

  TAudioRoute = class(THuggingFaceAPIRoute)
    /// <summary>
    /// Audio processing from the model.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TAudioToAudioParam</c> parameters.
    /// </param>
    /// <returns>
    /// A <c>TAudioToAudio</c> object containing the AudioToAudio result.
    /// </returns>
    /// <remarks>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// var Value := HuggingFace.Audio.AudioToAudio(
    ///     procedure (Params: TAudioToAudioParam)
    ///     begin
    ///       // Define parameters
    ///     end;
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function AudioToAudio(ParamProc: TProc<TAudioToAudioParam>): TAudioToAudio; overload;
    /// <summary>
    /// Audio processing from the model.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TAudioToAudioParam</c> parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns <c>TAsynAudioToText</c> to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// <para>
    /// The <c>CallBacks</c> function is invoked when the operation completes, either successfully or with an error.
    /// </para>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// HuggingFace.Audio.AudioToAudio(
    ///   procedure (Params: TAudioToAudioParam)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynAudioToAudio
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TAudioToAudio)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AudioToAudio(ParamProc: TProc<TAudioToAudioParam>; CallBacks: TFunc<TAsynAudioToAudio>); overload;
    /// <summary>
    /// Creates a transcription of the provided audio.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TAudioToTextParam</c> parameters.
    /// </param>
    /// <returns>
    /// A <c>TAudioToText</c> object containing the AudioToText result.
    /// </returns>
    /// <remarks>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// var Value := HuggingFace.Audio.AudioToText(
    ///     procedure (Params: TAudioToTextParam)
    ///     begin
    ///       // Define parameters
    ///     end;
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function AudioToText(ParamProc: TProc<TAudioToTextParam>): TAudioToText; overload;
    /// <summary>
    /// Asynchronously creates a transcription of the provided audio.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TAudioToTextParam</c> parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns <c>TAsynAudioToText</c> to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// <para>
    /// The <c>CallBacks</c> function is invoked when the operation completes, either successfully or with an error.
    /// </para>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// HuggingFace.Audio.AudioToText(
    ///   procedure (Params: TAudioToTextParam)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynAudioToText
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TAudioToText)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AudioToText(ParamProc: TProc<TAudioToTextParam>; CallBacks: TFunc<TAsynAudioToText>); overload;
    /// <summary>
    /// Audio classification is the task of assigning a label or class to a given audio.
    /// <para>
    /// NOTE: This method is <c>synchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TAudioClassificationParam</c> parameters.
    /// </param>
    /// <returns>
    /// Returns a <c>TAudioClassification</c> instance.
    /// </returns>
    /// <exception cref="HuggingFaceException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="HuggingFaceExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    ///   var Value := HuggingFace.Audio.Classification(
    ///     procedure (Params: TAudioClassificationParam)
    ///     begin
    ///       // Define parameters
    ///     end);
    ///   try
    ///     // Handle the Value
    ///   finally
    ///     Value.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Classification(ParamProc: TProc<TAudioClassificationParam>): TAudioClassification; overload;
    /// <summary>
    /// Audio classification is the task of assigning a label or class to a given audio.
    /// <para>
    /// NOTE: This method is <c>asynchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TAudioClassificationParam</c> parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns <c>TAudioClassificationParam</c> to handle the asynchronous result.
    /// </param>
    /// <exception cref="HuggingFaceException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="HuggingFaceExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line to the main OnCreate method for maximum scope.
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// HuggingFace.Audio.Classification(
    ///   procedure (Params: TAudioClassificationParam)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynAudioClassification
    ///   begin
    ///     Result.Sender := Image1;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Value: TAudioClassification)
    ///       begin
    ///         // Handle success operation
    ///       end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle error message
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure Classification(ParamProc: TProc<TAudioClassificationParam>; CallBacks: TFunc<TAsynAudioClassification>); overload;
  end;

implementation

uses
  HuggingFace.NetEncoding.Base64;

{ TAudioToTextParam }

function TAudioToTextParam.GenerationParameters(
  ParamProc: TProcRef<TGenerationParameters>): TAudioToTextParam;
begin
  if Assigned(ParamProc) then
    begin
      var Value := TGenerationParameters.Create;
      ParamProc(Value);
      Result := TAudioToTextParam(Add('generation_parameters', Value.Detach));
    end
  else Result := Self;
end;

function TAudioToTextParam.Inputs(const FileName: string): TAudioToTextParam;
begin
  Result := TAudioToTextParam(Add('inputs', EncodeBase64(FileName)));
end;

function TAudioToTextParam.Parameters(
  const Value: TJSONObject): TAudioToTextParam;
begin
  Result := TAudioToTextParam(Add('parameters', Value));
end;

{ TAudioRoute }

function TAudioRoute.AudioToAudio(
  ParamProc: TProc<TAudioToAudioParam>): TAudioToAudio;
begin
  Result := API.Post<TAudioToAudio, TAudioToAudioParam>('models', ParamProc, 'audio');
end;

procedure TAudioRoute.AudioToAudio(ParamProc: TProc<TAudioToAudioParam>;
  CallBacks: TFunc<TAsynAudioToAudio>);
begin
  with TAsynCallBackExec<TAsynAudioToAudio, TAudioToAudio>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TAudioToAudio
      begin
        Result := Self.AudioToAudio(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TAudioRoute.AudioToText(
  ParamProc: TProc<TAudioToTextParam>): TAudioToText;
begin
  Result := API.Post<TAudioToText, TAudioToTextParam>('models', ParamProc);
end;

procedure TAudioRoute.AudioToText(ParamProc: TProc<TAudioToTextParam>;
  CallBacks: TFunc<TAsynAudioToText>);
begin
  with TAsynCallBackExec<TAsynAudioToText, TAudioToText>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TAudioToText
      begin
        Result := Self.AudioToText(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TAudioRoute.Classification(
  ParamProc: TProc<TAudioClassificationParam>;
  CallBacks: TFunc<TAsynAudioClassification>);
begin
  with TAsynCallBackExec<TAsynAudioClassification, TAudioClassification>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TAudioClassification
      begin
        Result := Self.Classification(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TAudioRoute.Classification(
  ParamProc: TProc<TAudioClassificationParam>): TAudioClassification;
begin
  Result := API.Post<TAudioClassification, TAudioClassificationParam>('models', ParamProc);
end;

{ TRecognitionParameters }

function TRecognitionParameters.ReturnTimestamps(
  const Value: Boolean): TRecognitionParameters;
begin
  Result := TRecognitionParameters(Add('return_timestamps', Value));
end;

{ TGenerationParameters }

function TGenerationParameters.DoSample(
  const Value: Boolean): TGenerationParameters;
begin
  Result := TGenerationParameters(Add('do_sample', Value));
end;

function TGenerationParameters.EarlyStopping(
  const Value: TEarlyStopping): TGenerationParameters;
begin
  Result := TGenerationParameters(Add('early_stopping', Value.ToString));
end;

function TGenerationParameters.EpsilonCutoff(
  const Value: Double): TGenerationParameters;
begin
  Result := TGenerationParameters(Add('epsilon_cutoff', Value));
end;

function TGenerationParameters.EtaCutoff(
  const Value: Double): TGenerationParameters;
begin
  Result := TGenerationParameters(Add('eta_cutoff', Value));
end;

function TGenerationParameters.MaxLength(
  const Value: Integer): TGenerationParameters;
begin
  Result := TGenerationParameters(Add('max_length', Value));
end;

function TGenerationParameters.MaxNewTokens(
  const Value: Integer): TGenerationParameters;
begin
  Result := TGenerationParameters(Add('max_new_tokens', Value));
end;

function TGenerationParameters.MinLength(
  const Value: Integer): TGenerationParameters;
begin
  Result := TGenerationParameters(Add('min_length', Value));
end;

function TGenerationParameters.MinNewTokens(
  const Value: Integer): TGenerationParameters;
begin
  Result := TGenerationParameters(Add('min_new_tokens', Value));
end;

function TGenerationParameters.NumBeamGroups(
  const Value: Integer): TGenerationParameters;
begin
  Result := TGenerationParameters(Add('num_beam_groups', Value));
end;

function TGenerationParameters.NumBeams(
  const Value: Integer): TGenerationParameters;
begin
  Result := TGenerationParameters(Add('num_beams', Value));
end;

function TGenerationParameters.PenaltyAlpha(
  const Value: Double): TGenerationParameters;
begin
  Result := TGenerationParameters(Add('penalty_alpha', Value));
end;

function TGenerationParameters.Temperature(
  const Value: Double): TGenerationParameters;
begin
  Result := TGenerationParameters(Add('temperature', Value));
end;

function TGenerationParameters.TopK(
  const Value: Integer): TGenerationParameters;
begin
  Result := TGenerationParameters(Add('top_k', Value));
end;

function TGenerationParameters.TopP(
  const Value: Double): TGenerationParameters;
begin
  Result := TGenerationParameters(Add('top_p', Value));
end;

function TGenerationParameters.TypicalP(
  const Value: Double): TGenerationParameters;
begin
  Result := TGenerationParameters(Add('typical_p', Value));
end;

function TGenerationParameters.UseCache(
  const Value: Boolean): TGenerationParameters;
begin
  Result := TGenerationParameters(Add('use_cache', Value));
end;

{ TAudioToText }

destructor TAudioToText.Destroy;
begin
  for var Item in FChunks do
    Item.Free;
  inherited;
end;

{ TAudioClassificationParam }

function TAudioClassificationParam.Inputs(const FileName: string): TAudioClassificationParam;
begin
  Result := TAudioClassificationParam(Add('inputs', EncodeBase64(FileName)));
end;

function TAudioClassificationParam.Parameters(
  const FunctionToApply: TFunctionClassification;
  const TopK: Integer): TAudioClassificationParam;
begin
  var Value := TAudioClassificationParameters.Create.FunctionToApply(FunctionToApply);
  if TopK <> -1 then
    Value := Value.TopK(TopK);
  Result := TAudioClassificationParam(Add('parameters', Value.Detach));
end;

function TAudioClassificationParam.Parameters(
  const TopK: Integer): TAudioClassificationParam;
begin
  Result := TAudioClassificationParam(Add('parameters', TAudioClassificationParameters.Create.TopK(TopK).Detach));
end;

{ TAudioClassificationParameters }

function TAudioClassificationParameters.FunctionToApply(
  const Value: TFunctionClassification): TAudioClassificationParameters;
begin
  Result := TAudioClassificationParameters(Add('function_to_apply', Value.ToString));
end;

function TAudioClassificationParameters.TopK(
  const Value: Integer): TAudioClassificationParameters;
begin
  Result := TAudioClassificationParameters(Add('top_k', Value));
end;

{ TAudioClassification }

destructor TAudioClassification.Destroy;
begin
  for var Item in FItems do
    Item.Free;
  inherited;
end;

{ TAudioToAudioParam }

function TAudioToAudioParam.Inputs(const FileName: string): TAudioToAudioParam;
begin
  Result := TAudioToAudioParam(Add('inputs', EncodeBase64(FileName)));
end;

{ TAudioToAudio }

function TAudioToAudio.GetStream: TStream;
begin
  {--- Create a memory stream to write the decoded content. }
  Result := TMemoryStream.Create;
  try
    {--- Convert the base-64 string directly into the memory stream. }
    DecodeBase64ToStream(Audio, Result)
  except
    Result.Free;
    raise;
  end;
end;

procedure TAudioToAudio.SaveToFile(const FileName: string);
begin
  try
    Self.FFileName := FileName;
    {--- Perform the decoding operation and save it into the file specified by the FileName parameter. }
    DecodeBase64ToFile(Audio, FileName)
  except
    raise;
  end;
end;

end.

unit HuggingFace.Chat;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiHuggingFace
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, Rest.Json,
  REST.Json.Types, System.Net.URLClient, HuggingFace.API, HuggingFace.API.Params,
  HuggingFace.Schema, HuggingFace.Functions.Core, HuggingFace.Async.Support,
  HuggingFace.Types;

type
  TContentPayload = class(TJSONParam)
  public
    /// <summary>
    /// Text of the context.
    /// </summary>
    function Text(const Value: string): TContentPayload;
    /// <summary>
    /// Possible values: text, image_url.
    /// </summary>
    function &Type(const Value: TContentType): TContentPayload;
    /// <summary>
    /// Url of the image.
    /// </summary>
    function ImageUrl(const Value: string): TContentPayload;
  end;

  TPayload = class(TJSONParam)
  public
    /// <summary>
    /// Sets a single string as the content of the message.
    /// </summary>
    /// <param name="Value">
    /// A string representing the message content.
    /// </param>
    /// <returns>
    /// The updated <c>TPayload</c> instance, enabling method chaining.
    /// </returns>
    function Content(const Value: string): TPayload; overload;
    /// <summary>
    /// Sets a single string as the content of the message.
    /// </summary>
    /// <param name="Value">
    /// A string representing the message content.
    /// </param>
    /// <param name="Images">
    /// Array of images urls
    /// </param>
    /// <returns>
    /// The updated <c>TPayload</c> instance, enabling method chaining.
    /// </returns>
    function Content(const Value: string; const Images: TArray<string>): TPayload; overload;
    /// <summary>
    /// Specifies the role of the message sender.
    /// </summary>
    /// <param name="Value">
    /// A <c>TRoleType</c> enum value representing the role (user, assistant, system, or tool).
    /// </param>
    /// <returns>
    /// The updated <c>TPayload</c> instance, enabling method chaining.
    /// </returns>
    /// <remarks>
    /// Use this method to define the sender's role for the current message,
    /// which is critical for establishing context in multi-turn conversations.
    /// </remarks>
    function Role(const Value: TRoleType): TPayload;
    /// <summary>
    /// Name of a function
    /// </summary>
    function Name(const Value: string): TPayload;
    /// <summary>
    /// Creates a user message with the specified content.
    /// </summary>
    /// <param name="Value">
    /// The text content of the user message.
    /// </param>
    /// <returns>
    /// A <c>Payload</c> instance representing a user message.
    /// </returns>
    class function User(const Value: string): TPayload; overload;
    /// <summary>
    /// Creates a user message with text content and an array of image URLs.
    /// </summary>
    /// <param name="Value">
    /// The text content of the user message.
    /// </param>
    /// <param name="Images">
    /// An array of strings, each representing an image URL to include in the message.
    /// </param>
    /// <returns>
    /// A <c>TPayload</c> instance representing a user message with images.
    /// </returns>
    /// <remarks>
    /// This method is useful for messages containing both text and visual content.
    /// Each image URL is included in the payload as a separate JSON element.
    /// </remarks>
    class function User(const Value: string; const Images: TArray<string>): TPayload; overload;
    /// <summary>
    /// Creates an assistant message with the specified content.
    /// </summary>
    /// <param name="Value">
    /// The text content of the assistant message.
    /// </param>
    /// <returns>
    /// A <c>TPayload</c> instance representing an assistant message.
    /// </returns>
    class function Assistant(const Value: string): TPayload;
    /// <summary>
    /// Creates a system message with the specified content.
    /// </summary>
    /// <param name="Value">
    /// The text content of the system message.
    /// </param>
    /// <returns>
    /// A <c>TPayload</c> instance representing a system message.
    /// </returns>
    /// <remarks>
    /// System messages are often used for configuring the chat session or providing
    /// context before any user or assistant interactions.
    /// </remarks>
    class function System(const Value: string): TPayload; overload;
  end;

  TResponseFormat = class(TJSONParam)
  public
    /// <summary>
    /// Possible values: regex, json
    /// </summary>
    function &Type(const Value: TResponseFormatType): TResponseFormat;
    /// <summary>
    /// Depending on the type :
    /// <para>
    /// JSON : A string that represents a JSON Schema. JSON Schema is a declarative language that allows
    /// to annotate JSON documents with types and descriptions.
    /// </para>
    /// <para>
    /// REGEX : A string that represents a regular expression value.
    /// </para>
    /// </summary>
    function Value(const Value: string): TResponseFormat;
    /// <summary>
    /// Create an instance of TResponseFormat as REGEX type
    /// </summary>
    class function Regex(const Value: string): TResponseFormat;
    /// <summary>
    /// Create an instance of TResponseFormat as JSON type
    /// </summary>
    class function Json(const Value: TSchemaParams): TResponseFormat;
  end;

  TChatPayload = class(TJSONChatParam)
  public
    /// <summary>
    /// Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing
    /// frequency in the text so far, decreasing the model’s likelihood to repeat the same line verbatim.
    /// </summary>
    function FrequencyPenalty(const Value: Double): TChatPayload;
    /// <summary>
    /// Whether to return log probabilities of the output tokens or not. If true, returns the log
    /// probabilities of each output token returned in the content of message.
    /// </summary>
    function Logprobs(const Value: Boolean): TChatPayload;
    /// <summary>
    /// The maximum number of tokens that can be generated in the chat completion.
    /// </summary>
    function MaxTokens(const Value: Integer): TChatPayload;
    /// <summary>
    /// A list of messages comprising the conversation so far.
    /// </summary>
    function Messages(const Value: TArray<TPayload>): TChatPayload;
    /// <summary>
    /// Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear
    /// in the text so far, increasing the model’s likelihood to talk about new topics
    /// </summary>
    function PresencePenalty(const Value: Double): TChatPayload;
    /// <summary>
    /// Seeds the sampling for deterministic output.
    /// </summary>
    function Seed(const Value: Integer): TChatPayload;
    /// <summary>
    /// Up to 4 sequences where the API will stop generating further tokens.
    /// </summary>
    function Stop(const Value: TArray<string>): TChatPayload;
    /// <summary>
    /// Enables token streaming for partial responses.
    /// </summary>
    function Stream(const Value: Boolean): TChatPayload;
    /// <summary>
    /// If set, an additional chunk will be streamed before the data: [DONE] message. The usage field
    /// on this chunk shows the token usage statistics for the entire request, and the choices field
    /// will always be an empty array. All other chunks will also include a usage field, but with a
    /// null value.
    /// </summary>
    function StreamOptions(const Value: Boolean): TChatPayload;
    /// <summary>
    /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output
    /// more random, while lower values like 0.2 will make it more focused and deterministic.
    /// </summary>
    /// <remarks>
    /// We generally recommend altering this or top_p but not both.
    /// </remarks>
    function Temperature(const Value: Double): TChatPayload;
    /// <summary>
    /// An integer between 0 and 5 specifying the number of most likely tokens to return at each token
    /// position, each with an associated log probability. logprobs must be set to true if this parameter
    /// is used.
    /// </summary>
    function TopLogprobs(const Value: Integer): TChatPayload;
    /// <summary>
    /// An alternative to sampling with temperature, called nucleus sampling, where the model considers
    /// the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising
    /// the top 10% probability mass are considered.
    /// </summary>
    function TopP(const Value: Double): TChatPayload;
    /// <summary>
    /// Set the response_format
    /// </summary>
    function ResponseFormat(const Value: string): TChatPayload; overload;
    /// <summary>
    /// Set the response_format
    /// </summary>
    function ResponseFormat(const Value: TSchemaParams): TChatPayload; overload;
    /// <summary>
    /// Set the tool_choice
    /// </summary>
    function ToolChoice(const Value: TToolChoiceType): TChatPayload; overload;
    /// <summary>
    /// Set the tool_choice
    /// </summary>
    function ToolChoice(const Value: string): TChatPayload; overload;
    /// <summary>
    /// A prompt to be appended before the tools.
    /// </summary>
    function ToolPrompt(const Value: string): TChatPayload;
    /// <summary>
    /// A list of tools the model may call. Currently, only functions are supported as a tool. Use this
    /// to provide a list of functions the model may generate JSON inputs for.
    /// </summary>
    function Tools(const Value: TArray<IFunctionCore>): TChatPayload;
  end;

  TFunctionCalled = class
  private
    [JsonReflectAttribute(ctString, rtString, TArgsFixInterceptor)]
    FArguments: string;
    FDescription: string;
    FName: string;
  public
    /// <summary>
    /// A JSON-formatted string representing the arguments to pass to the function.
    /// </summary>
    /// <remarks>
    /// The arguments should be formatted as a JSON object, matching the expected parameters of the function.
    /// </remarks>
    property Arguments: string read FArguments write FArguments;
    /// <summary>
    /// Description of the tool called.
    /// </summary>
    property Description: string read FDescription write FDescription;
    /// <summary>
    /// The name of the function to be called.
    /// </summary>
    /// <remarks>
    /// This should match the name of a function defined in the tools available to the model.
    /// </remarks>
    property Name: string read FName write FName;
  end;

  TToolCalls = class
  private
    FId: string;
    FType: string;
    FFunction: TFunctionCalled;
  public
    /// <summary>
    /// A unique identifier for the tool call.
    /// </summary>
    /// <remarks>
    /// The identifier can be used to track or reference specific tool calls within the conversation.
    /// </remarks>
    property Id: string read FId write FId;
    /// <summary>
    /// The type of the tool being called (e.g., "function").
    /// </summary>
    /// <remarks>
    /// The type indicates the nature of the tool, such as whether it's a function call or another kind of tool.
    /// </remarks>
    property &Type: string read FType write FType;
    /// <summary>
    /// Details of the function to be called, including its name and arguments.
    /// </summary>
    /// <remarks>
    /// If the tool call is a function call, this property contains the specifics of the function invocation.
    /// </remarks>
    property &Function: TFunctionCalled read FFunction write FFunction;
    destructor Destroy; override;
  end;

  TChoiceMessage = class
  private
    FContent: string;
    [JsonReflectAttribute(ctString, rtString, TRoleTypeInterceptor)]
    FRole: TRoleType;
    [JsonNameAttribute('tool_calls')]
    FToolCalls: TArray<TToolCalls>;
  public
    /// <summary>
    /// The textual content of the message.
    /// </summary>
    /// <remarks>
    /// The content may include the assistant's response, user input, or system prompts.
    /// </remarks>
    property Content: string read FContent write FContent;
    /// <summary>
    /// The role of the message sender (e.g., user, assistant, system, tool).
    /// </summary>
    property Role: TRoleType read FRole write FRole;
    /// <summary>
    /// An array of tool calls made by the model during this message.
    /// </summary>
    /// <remarks>
    /// If the model invokes any tools (e.g., functions) during its response generation, those tool calls are recorded here.
    /// </remarks>
    property ToolCalls: TArray<TToolCalls> read FToolCalls write FToolCalls;
    destructor Destroy; override;
  end;

  TTopLogprobs = class
  private
    FLogprob: Double;
    FToken: string;
  public
    /// <summary>
    /// The log probability of the token.
    /// </summary>
    /// <remarks>
    /// Log probabilities are in natural logarithm base and represent the likelihood of the token.
    /// </remarks>
    property Logprob: Double read FLogprob write FLogprob;
    /// <summary>
    /// The token text as predicted by the model.
    /// </summary>
    property Token: string read FToken write FToken;
  end;

  TLogprobContent = class
  private
    FLogprob: Double;
    FToken: string;
    [JsonNameAttribute('top_logprobs')]
    FTopLogprobs: TTopLogprobs;
  public
    /// <summary>
    /// The log probability of the token.
    /// </summary>
    /// <remarks>
    /// Provides the likelihood of the token appearing in this context.
    /// </remarks>
    property Logprob: Double read Flogprob write Flogprob;
    /// <summary>
    /// The token text as generated in the content.
    /// </summary>
    property Token: string read FToken write FToken;
    /// <summary>
    /// An array of top alternative tokens with their log probabilities.
    /// </summary>
    /// <remarks>
    /// This allows for analysis of other tokens the model considered at this position and their respective probabilities.
    /// </remarks>
    property TopLogprobs: TTopLogprobs read FTopLogprobs write FTopLogprobs;
    destructor Destroy; override;
  end;

  TLogprobs = class
  private
    FContent: TArray<TLogprobContent>;
  public
    /// <summary>
    /// An array of log probabilities for content tokens.
    /// </summary>
    property Content: TArray<TLogprobContent> read FContent write FContent;
    destructor Destroy; override;
  end;

  TChoice = class
  private
    [JsonNameAttribute('finish_reason')]
    [JsonReflectAttribute(ctString, rtString, TFinishReasonInterceptor)]
    FFinishReason: TFinishReason;
    FIndex: Integer;
    FMessage: TChoiceMessage;
    FLogprobs: TLogprobs;
    FDelta: TChoiceMessage;
  public
    /// <summary>
    /// The reason why the model stopped generating the output.
    /// </summary>
    /// <remarks>
    /// Indicates whether the model stopped due to reaching the end of the message, hitting a stop sequence, or other reasons.
    /// </remarks>
    property FinishReason: TFinishReason read FFinishReason write FFinishReason;
    /// <summary>
    /// Index when SSE processing
    /// </summary>
    property Index: Integer read FIndex write FIndex;
    /// <summary>
    /// The message generated by the model.
    /// </summary>
    /// <remarks>
    /// Contains the actual content of the model's response.
    /// </remarks>
    property Message: TChoiceMessage read FMessage write FMessage;
    /// <summary>
    /// Incremental message content for streaming responses.
    /// </summary>
    /// <remarks>
    /// Used when responses are streamed token by token; contains the latest delta in the message.
    /// </remarks>
    property Delta: TChoiceMessage read FDelta write FDelta;
    /// <summary>
    /// The log probabilities associated with the tokens in the message.
    /// </summary>
    /// <remarks>
    /// Populated if log probabilities were requested; provides detailed token-level probability information.
    /// </remarks>
    property Logprobs: TLogprobs read FLogprobs write FLogprobs;
    destructor Destroy; override;
  end;

  TUsage = class
  private
    [JsonNameAttribute('completion_tokens')]
    FCompletionTokens: Int64;
    [JsonNameAttribute('prompt_tokens')]
    FPromptTokens: Int64;
    [JsonNameAttribute('total_tokens')]
    FTotalTokens: Int64;
  public
    /// <summary>
    /// Tokens used for the completion
    /// </summary>
    property CompletionTokens: Int64 read FCompletionTokens write FCompletionTokens;
    /// <summary>
    /// Tokens used for the context prompt
    /// </summary>
    property PromptTokens: Int64 read FPromptTokens write FPromptTokens;
    /// <summary>
    /// Sum tokens for the completion operation
    /// </summary>
    property TotalTokens: Int64 read FTotalTokens write FTotalTokens;
  end;

  TChat = class
  private
    FId: string;
    FChoices: TArray<TChoice>;
    FCreated: Int64;
    FModel: string;
    [JsonNameAttribute('system_fingerprint')]
    FSystemFingerprint: string;
    FUsage: TUsage;
  public
    /// <summary>
    /// The unique identifier for the chat completion.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// The timestamp when the completion was created.
    /// </summary>
    /// <remarks>
    /// Represented as seconds since the Unix epoch.
    /// </remarks>
    property Created: Int64 read FCreated write FCreated;
    /// <summary>
    /// An array of choices returned by the model.
    /// </summary>
    /// <remarks>
    /// Each choice represents a possible completion generated by the model.
    /// </remarks>
    property Choices: TArray<TChoice> read FChoices write FChoices;
    /// <summary>
    /// Model used when the response processing
    /// </summary>
    property Model: string read FModel write FModel;
    /// <summary>
    /// A fingerprint representing the system state.
    /// </summary>
    /// <remarks>
    /// Used for internal tracking and debugging purposes.
    /// </remarks>
    property SystemFingerprint: string read FSystemFingerprint write FSystemFingerprint;
    /// <summary>
    /// Usage information for the completion request.
    /// </summary>
    property Usage: TUsage read FUsage write FUsage;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TChat</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynChat</c> type extends the <c>TAsynParams&lt;TChat&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynChat = TAsynCallBack<TChat>;

  /// <summary>
  /// Manages asynchronous streaming chat callBacks for a chat request using <c>TChat</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynChatStream</c> type extends the <c>TAsynStreamParams&lt;TChat&gt;</c> record to support the lifecycle of an asynchronous streaming chat operation.
  /// It provides callbacks for different stages, including when the operation starts, progresses with new data chunks, completes successfully, or encounters an error.
  /// This structure is ideal for handling scenarios where the chat response is streamed incrementally, providing real-time updates to the user interface.
  /// </remarks>
  TAsynChatStream = TAsynStreamCallBack<TChat>;

  /// <summary>
  /// Represents a callback procedure used during the reception of responses from a chat request in streaming mode.
  /// </summary>
  /// <param name="Chat">
  /// The <c>TChat</c> object containing the current information about the response generated by the model.
  /// If this value is <c>nil</c>, it indicates that the data stream is complete.
  /// </param>
  /// <param name="IsDone">
  /// A boolean flag indicating whether the streaming process is complete.
  /// If <c>True</c>, it means the model has finished sending all response data.
  /// </param>
  /// <param name="Cancel">
  /// A boolean flag that can be set to <c>True</c> within the callback to cancel the streaming process.
  /// If set to <c>True</c>, the streaming will be terminated immediately.
  /// </param>
  /// <remarks>
  /// This callback is invoked multiple times during the reception of the response data from the model.
  /// It allows for real-time processing of received messages and interaction with the user interface or other systems
  /// based on the state of the data stream.
  /// When the <c>IsDone</c> parameter is <c>True</c>, it indicates that the model has finished responding,
  /// and the <c>Chat</c> parameter will be <c>nil</c>.
  /// </remarks>
  TChatEvent = reference to procedure(var Chat: TChat; IsDone: Boolean; var Cancel: Boolean);

  TChatRoute = class(THuggingFaceAPIRoute)
    /// <summary>
    /// Generate a response given a list of messages in a conversational context, supporting both
    /// conversational Language Models (LLMs) and conversational Vision-Language Models (VLMs).
    /// This is a subtask of text-generation and image-text-to-text.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TChatPayload</c> parameters.
    /// </param>
    /// <returns>
    /// A <c>TChat</c> object containing the Segmentation result.
    /// </returns>
    /// <remarks>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// var Value := HuggingFace.Chat.Completion(
    ///     procedure (Params: TChatPayload)
    ///     begin
    ///       // Define parameters
    ///     end;
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function Completion(ParamProc: TProc<TChatPayload>): TChat; overload;
    /// <summary>
    /// Generate a response given a list of messages in a conversational context, supporting both
    /// conversational Language Models (LLMs) and conversational Vision-Language Models (VLMs).
    /// This is a subtask of text-generation and image-text-to-text.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TImageSegmentationParam</c> parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns <c>TAsynChat</c> to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// <para>
    /// The <c>CallBacks</c> function is invoked when the operation completes, either successfully or with an error.
    /// </para>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// HuggingFace.Chat.Completion(
    ///   procedure (Params: TChatPayload)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynChat
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TChat)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure Completion(ParamProc: TProc<TChatPayload>; CallBacks: TFunc<TAsynChat>); overload;
    /// <summary>
    /// Generate a streamed response given a list of messages in a conversational context, supporting
    /// both conversational Language Models (LLMs) and conversational Vision-Language Models (VLMs).
    /// This is a subtask of text-generation and image-text-to-text.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TChatPayload</c> parameters.
    /// </param>
    /// <param name="Event">
    /// A callback of type <c>TChatEvent</c> that is triggered with each chunk of data received during the streaming process. It includes the current state of the <c>TChat</c> object, a flag indicating if the stream is done, and a boolean to handle cancellation.
    /// </param>
    /// <returns>
    /// Returns <c>True</c> if the streaming process started successfully, <c>False</c> otherwise.
    /// </returns>
    /// <remarks>
    /// This method initiates a chat request in streaming mode, where the response is delivered incrementally in real-time.
    /// The <c>Event</c> callback will be invoked multiple times as tokens are received.
    /// When the response is complete, the <c>IsDone</c> flag will be set to <c>True</c>, and the <c>Chat</c> object will be <c>nil</c>.
    /// The streaming process can be interrupted by setting the <c>Cancel</c> flag to <c>True</c> within the event.
    ///
    /// Example usage:
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    ///   HuggingFace.Chat.CompletionStream(
    ///     procedure (Params: TChatPayload)
    ///     begin
    ///       // Define chat parameters
    ///       Params.Stream(True);
    ///     end,
    ///
    ///     procedure(var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
    ///     begin
    ///       // Handle displaying
    ///     end);
    /// </code>
    /// </remarks>
    function CompletionStream(ParamProc: TProc<TChatPayload>; Event: TChatEvent): Boolean; overload;
    /// <summary>
    /// Generate a streamed response given a list of messages in a conversational context, supporting
    /// both conversational Language Models (LLMs) and conversational Vision-Language Models (VLMs).
    /// This is a subtask of text-generation and image-text-to-text.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TChatPayload</c> parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a <c>TAsynChatStream</c> record which contains event handlers for managing different stages of the streaming process: progress updates, success, errors, and cancellation.
    /// </param>
    /// <remarks>
    /// This procedure initiates an asynchronous chat operation in streaming mode, where tokens are progressively received and processed.
    /// The provided event handlers allow for handling progress (i.e., receiving tokens in real time), detecting success, managing errors, and enabling cancellation logic.
    /// <code>
    /// CheckBox1.Checked := False;  //Click to stop the streaming
    /// // WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// HuggingFace.Chat.CompletionStream(
    ///   procedure(Params: TChatParams)
    ///   begin
    ///     // Define chat parameters
    ///     Params.Stream(True);
    ///   end,
    ///
    ///   function: TAsynChatStream
    ///   begin
    ///     Result.Sender := Memo1; // Instance passed to callback parameter
    ///     Result.OnProgress :=
    ///         procedure (Sender: TObject; Chat: TChat)
    ///         begin
    ///           // Handle progressive updates to the chat response
    ///         end;
    ///     Result.OnSuccess :=
    ///         procedure (Sender: TObject)
    ///         begin
    ///           // Handle success when the operation completes
    ///         end;
    ///     Result.OnError :=
    ///         procedure (Sender: TObject; Value: string)
    ///         begin
    ///           // Handle error message
    ///         end;
    ///     Result.OnDoCancel :=
    ///         function: Boolean
    ///         begin
    ///           Result := CheckBox1.Checked; // Click on checkbox to cancel
    ///         end;
    ///     Result.OnCancellation :=
    ///         procedure (Sender: TObject)
    ///         begin
    ///           // Processing when process has been canceled
    ///         end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure CompletionStream(ParamProc: TProc<TChatPayload>; CallBacks: TFunc<TAsynChatStream>); overload;
  end;

implementation

uses
  System.StrUtils, System.Rtti, HuggingFace.Async.Params, System.Threading,
  HuggingFace.NetEncoding.Base64;

{ TChatPayload }

function TChatPayload.FrequencyPenalty(const Value: Double): TChatPayload;
begin
  Result := TChatPayload(Add('frequency_penalty', Value));
end;

function TChatPayload.Logprobs(const Value: Boolean): TChatPayload;
begin
  Result := TChatPayload(Add('logprobs', Value));
end;

function TChatPayload.MaxTokens(const Value: Integer): TChatPayload;
begin
  Result := TChatPayload(Add('max_tokens', Value));
end;

function TChatPayload.Messages(const Value: TArray<TPayload>): TChatPayload;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TChatPayload(Add('messages', JSONArray));
end;

function TChatPayload.PresencePenalty(const Value: Double): TChatPayload;
begin
  Result := TChatPayload(Add('presence_penalty', Value));
end;

function TChatPayload.ResponseFormat(const Value: TSchemaParams): TChatPayload;
begin
  Result := TChatPayload(Add('response_format', TResponseFormat.Json(Value).Detach));
end;

function TChatPayload.ResponseFormat(const Value: string): TChatPayload;
begin
  Result := TChatPayload(Add('response_format', TResponseFormat.Regex(Value).Detach));
end;

function TChatPayload.Seed(const Value: Integer): TChatPayload;
begin
  Result := TChatPayload(Add('seed', Value));
end;

function TChatPayload.Stop(const Value: TArray<string>): TChatPayload;
begin
  Result := TChatPayload(Add('stop', Value));
end;

function TChatPayload.Stream(const Value: Boolean): TChatPayload;
begin
  Result := TChatPayload(Add('stream', Value));
end;

function TChatPayload.StreamOptions(const Value: Boolean): TChatPayload;
begin
  Result := TChatPayload(Add('stream_options', TJSONObject.Create.AddPair('include_usage', Value)));
end;

function TChatPayload.Temperature(const Value: Double): TChatPayload;
begin
  Result := TChatPayload(Add('temperature', Value));
end;

function TChatPayload.ToolChoice(const Value: TToolChoiceType): TChatPayload;
begin
  Result := TChatPayload(Add('tool_choice', Value.ToString));
end;

function TChatPayload.ToolChoice(const Value: string): TChatPayload;
begin
  var choice := TJSONObject.Create.AddPair('function', TJSONObject.Create.AddPair('name', Value));
  Result := TChatPayload(Add('tool_choice', choice));
end;

function TChatPayload.ToolPrompt(const Value: string): TChatPayload;
begin
  Result := TChatPayload(Add('tool_prompt', Value));
end;

function TChatPayload.Tools(const Value: TArray<IFunctionCore>): TChatPayload;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.ToJson);
  Result := TChatPayload(Add('tools', JSONArray));
end;

function TChatPayload.TopLogprobs(const Value: Integer): TChatPayload;
begin
  Result := TChatPayload(Add('top_logprobs', Value));
end;

function TChatPayload.TopP(const Value: Double): TChatPayload;
begin
  Result := TChatPayload(Add('top_p', Value));
end;

{ TPayload }

function TPayload.Content(const Value: string): TPayload;
begin
  Result := TPayload(Add('content', Value));
end;

class function TPayload.Assistant(const Value: string): TPayload;
begin
  Result := TPayload.Create.Content(Value).Role(TRoleType.assistant);
end;

function TPayload.Content(const Value: string;
  const Images: TArray<string>): TPayload;
begin
  var JSONArray := TJSONArray.Create;
  JSONArray.Add(TContentPayload.Create.Text(Value).Detach);
  for var Item in Images do
    JSONArray.Add(TContentPayload.Create.ImageUrl(Item).Detach);
  Result := TPayload(Add('content', JSONArray));
end;

function TPayload.Name(const Value: string): TPayload;
begin
  Result := TPayload(Add('name', Value));
end;

function TPayload.Role(const Value: TRoleType): TPayload;
begin
  Result := TPayload(Add('role', Value.ToString));
end;

class function TPayload.System(const Value: string): TPayload;
begin
  Result := TPayload.Create.Content(Value).Role(TRoleType.system);
end;

class function TPayload.User(const Value: string;
  const Images: TArray<string>): TPayload;
begin
  Result := TPayload.Create.Content(Value, Images).Role(TRoleType.user);
end;

class function TPayload.User(const Value: string): TPayload;
begin
  Result := TPayload.Create.Content(Value).Role(TRoleType.user);
end;

{ TContentPayload }

function TContentPayload.&Type(
  const Value: TContentType): TContentPayload;
begin
  Result := TContentPayload(Add('type', Value.ToString));
end;

function TContentPayload.ImageUrl(const Value: string): TContentPayload;
begin
  if not Value.ToLower.StartsWith('http') then
    raise Exception.Create('image url not valid');
  Result := TContentPayload(Add('image_url', TJSONObject.Create.AddPair('url', Value))).&Type(image_url);
end;

function TContentPayload.Text(const Value: string): TContentPayload;
begin
  Result := TContentPayload(Add('text', Value)).&Type(TContentType.text);
end;

{ TChoice }

destructor TChoice.Destroy;
begin
  if Assigned(FMessage) then
    FMessage.Free;
  if Assigned(FLogprobs) then
    FLogprobs.Free;
  if Assigned(FDelta) then
    FDelta.Free;
  inherited;
end;

{ TChat }

destructor TChat.Destroy;
begin
  for var Item in FChoices  do
    Item.Free;
  if Assigned(FUsage) then
    FUsage.Free;
  inherited;
end;

{ TChatRoute }

procedure TChatRoute.Completion(ParamProc: TProc<TChatPayload>;
  CallBacks: TFunc<TAsynChat>);
begin
  with TAsynCallBackExec<TAsynChat, TChat>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TChat
      begin
        Result := Self.Completion(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TChatRoute.Completion(ParamProc: TProc<TChatPayload>): TChat;
begin
  Result := API.Post<TChat, TChatPayload>('models', ParamProc);
end;

procedure TChatRoute.CompletionStream(ParamProc: TProc<TChatPayload>;
  CallBacks: TFunc<TAsynChatStream>);
begin
  var CallBackParams := TUseParamsFactory<TAsynChatStream>.CreateInstance(CallBacks);

  var Sender := CallBackParams.Param.Sender;
  var OnStart := CallBackParams.Param.OnStart;
  var OnSuccess := CallBackParams.Param.OnSuccess;
  var OnProgress := CallBackParams.Param.OnProgress;
  var OnError := CallBackParams.Param.OnError;
  var OnCancellation := CallBackParams.Param.OnCancellation;
  var OnDoCancel := CallBackParams.Param.OnDoCancel;

  var Task: ITask := TTask.Create(
        procedure()
        begin
            {--- Pass the instance of the current class in case no value was specified. }
            if not Assigned(Sender) then
              Sender := Self;

            {--- Trigger OnStart callback }
            if Assigned(OnStart) then
              TThread.Queue(nil,
                procedure
                begin
                  OnStart(Sender);
                end);
            try
              var Stop := False;

              {--- Processing }
              CompletionStream(ParamProc,
                procedure (var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
                begin
                  {--- Check that the process has not been canceled }
                  if Assigned(OnDoCancel) then
                    TThread.Queue(nil,
                        procedure
                        begin
                          Stop := OnDoCancel();
                        end);
                  if Stop then
                    begin
                      {--- Trigger when processus was stopped }
                      if Assigned(OnCancellation) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnCancellation(Sender)
                        end);
                      Cancel := True;
                      Exit;
                    end;
                  if not IsDone and Assigned(Chat) then
                    begin
                      var LocalChat := Chat;
                      Chat := nil;

                      {--- Triggered when processus is progressing }
                      if Assigned(OnProgress) then
                        TThread.Synchronize(TThread.Current,
                        procedure
                        begin
                          try
                            OnProgress(Sender, LocalChat);
                          finally
                            {--- Makes sure to release the instance containing the data obtained
                                 following processing}
                            LocalChat.Free;
                          end;
                        end)
                      else
                        LocalChat.Free;
                    end
                  else
                  if IsDone then
                    begin
                      {--- Trigger OnEnd callback when the process is done }
                      if Assigned(OnSuccess) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnSuccess(Sender);
                        end);
                    end;
                end);
            except
              on E: Exception do
                begin
                  var Error := AcquireExceptionObject;
                  try
                    var ErrorMsg := (Error as Exception).Message;

                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(OnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        OnError(Sender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
        end);
  Task.Start;
end;

function TChatRoute.CompletionStream(ParamProc: TProc<TChatPayload>;
  Event: TChatEvent): Boolean;
var
  Response: TStringStream;
  RetPos: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    RetPos := 0;
    Result := API.Post<TChatPayload>('models', ParamProc, Response,
      procedure(const Sender: TObject; AContentLength: Int64; AReadCount: Int64; var AAbort: Boolean)
      var
        IsDone: Boolean;
        Data: string;
        Chat: TChat;
        TextBuffer: string;
        Line: string;
        Ret: Integer;
      begin
        try
          TextBuffer := Response.DataString;
        except
          on E: EEncodingError do
            Exit;
        end;
        repeat
          Ret := TextBuffer.IndexOf(#10, RetPos);
          if Ret < 0 then
            Continue;
          Line := TextBuffer.Substring(RetPos, Ret - RetPos);
          RetPos := Ret + 1;
          if Line.IsEmpty or Line.StartsWith(#10) then
            Continue;
          Chat := nil;
          Data := Line.Replace('data: ', '').Trim([' ', #13, #10]);
          IsDone := Data = '[DONE]';

          if not IsDone then
          try
            Chat := TJson.JsonToObject<TChat>(Data);
          except
            Chat := nil;
          end;

          try
            Event(Chat, IsDone, AAbort);
          finally
            Chat.Free;
          end;
        until Ret < 0;
      end);
    finally
      Response.Free;
    end;
end;

{ TResponseFormat }

class function TResponseFormat.Json(
  const Value: TSchemaParams): TResponseFormat;
begin
  Result := TResponseFormat.Create.Value(Value.ToJsonString(True)).&Type(TResponseFormatType.json);
end;

class function TResponseFormat.Regex(const Value: string): TResponseFormat;
begin
  Result := TResponseFormat.Create.Value(Value).&Type(TResponseFormatType.Regex);
end;

function TResponseFormat.&Type(
  const Value: TResponseFormatType): TResponseFormat;
begin
  Result := TResponseFormat(Add('type', Value.ToString));
end;

function TResponseFormat.Value(const Value: string): TResponseFormat;
begin
  Result := TResponseFormat(Add('value', Value));
end;

{ TLogprobContent }

destructor TLogprobContent.Destroy;
begin
  if Assigned(FTopLogprobs) then
    FTopLogprobs.Free;
  inherited;
end;

{ TLogprobs }

destructor TLogprobs.Destroy;
begin
  for var Item in FContent do
    Item.Free;
  inherited;
end;

{ TToolCalls }

destructor TToolCalls.Destroy;
begin
  if Assigned(FFunction) then
    FFunction.Free;
  inherited;
end;

{ TChoiceMessage }

destructor TChoiceMessage.Destroy;
begin
  for var Item in FToolCalls do
    Item.Free;
  inherited;
end;

end.

unit HuggingFace.Embeddings;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiHuggingFace
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, Rest.Json,
  REST.Json.Types, System.Net.URLClient, HuggingFace.API, HuggingFace.API.Params,
  HuggingFace.Async.Support, HuggingFace.Types;

type
  TEmbeddingParams = class(TJSONModelParam)
  public
    /// <summary>
    /// The text to embed.
    /// </summary>
    function Inputs(const Value: string): TEmbeddingParams;
    /// <summary>
    /// Normalize the return vector.
    /// </summary>
    function Normalize(const Value: Boolean): TEmbeddingParams;
    /// <summary>
    /// he name of the prompt that should be used by for encoding. If not set, no prompt will
    /// be applied. Must be a key in the sentence-transformers configuration prompts dictionary.
    /// </summary>
    /// <remarks>
    /// For example if prompt_name is “query” and the prompts is {“query”: “query: ”, …}
    /// <para>
    /// then the sentence “What is the capital of France?” will be encoded as
    /// </para>
    /// <para>
    /// “query: What is the capital of France?” because the prompt text will be prepended before
    /// any text to encode.
    /// </para>
    /// </remarks>
    function PromptName(const Value: string): TEmbeddingParams;
    /// <summary>
    /// Truncate the return vector.
    /// </summary>
    function Truncate(const Value: Boolean): TEmbeddingParams;
    /// <summary>
    /// Possible values: Left, Right.
    /// </summary>
    function TruncationDirection(const Value: TTruncationDirection): TEmbeddingParams;
  end;

  TEmbeddings = class
  private
    FItems: TArray<Double>;
  public
    /// <summary>
    /// Output is an array of double.
    /// </summary>
    property Items: TArray<Double> read FItems write FItems;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TEmbeddings</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynEmbeddings</c> type extends the <c>TAsynParams&lt;TEmbeddings&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynEmbeddings = TAsynCallBack<TEmbeddings>;

  TEmbeddingsRoute = class(THuggingFaceAPIRoute)
    /// <summary>
    /// Feature extraction is the task of converting a text into a vector (often called “embedding”).
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TEmbeddingParams</c> parameters.
    /// </param>
    /// <returns>
    /// A <c>TEmbeddings</c> object containing the Classification result.
    /// </returns>
    /// <remarks>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// var Value := HuggingFace.Embeddings.Create(
    ///     procedure (Params: TEmbeddingParams)
    ///     begin
    ///       // Define parameters
    ///     end;
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function Create(ParamProc: TProc<TEmbeddingParams>): TEmbeddings; overload;
    /// <summary>
    /// Feature extraction is the task of converting a text into a vector (often called “embedding”).
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TEmbeddingParams</c> parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns <c>TAsynEmbeddings</c> to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// <para>
    /// The <c>CallBacks</c> function is invoked when the operation completes, either successfully or with an error.
    /// </para>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// HuggingFace.Embeddings.Create(
    ///   procedure (Params: TEmbeddingParams)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynEmbeddings
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TImageClassification)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure Create(ParamProc: TProc<TEmbeddingParams>; CallBacks: TFunc<TAsynEmbeddings>); overload;
  end;

implementation

{ TEmbeddingParams }

function TEmbeddingParams.Inputs(const Value: string): TEmbeddingParams;
begin
  Result := TEmbeddingParams(Add('inputs', Value));
end;

function TEmbeddingParams.Normalize(const Value: Boolean): TEmbeddingParams;
begin
  Result := TEmbeddingParams(Add('normalize', Value));
end;

function TEmbeddingParams.PromptName(const Value: string): TEmbeddingParams;
begin
  Result := TEmbeddingParams(Add('prompt_name', Value));
end;

function TEmbeddingParams.Truncate(const Value: Boolean): TEmbeddingParams;
begin
  Result := TEmbeddingParams(Add('truncate', Value));
end;

function TEmbeddingParams.TruncationDirection(
  const Value: TTruncationDirection): TEmbeddingParams;
begin
  Result := TEmbeddingParams(Add('truncation_direction', Value.ToString));
end;

{ TEmbeddingsRoute }

function TEmbeddingsRoute.Create(
  ParamProc: TProc<TEmbeddingParams>): TEmbeddings;
begin
  Result := API.Post<TEmbeddings, TEmbeddingParams>('models', ParamProc);
end;

procedure TEmbeddingsRoute.Create(ParamProc: TProc<TEmbeddingParams>;
  CallBacks: TFunc<TAsynEmbeddings>);
begin
  with TAsynCallBackExec<TAsynEmbeddings, TEmbeddings>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TEmbeddings
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

end.

unit HuggingFace.Errors;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiHuggingFace
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  REST.Json.Types;

type
  TErrorCore = class abstract
  end;

  TError = class(TErrorCore)
  private
    FId: string;
    FName: string;
    FError: string;
    FWarnings: TArray<string>;
    [JsonNameAttribute('estimated_time')]
    FEstimatedTime: Double;
  public
    property Id: string read FId write FId;
    property Name: string read FName write FName;
    property Error: string read FError write FError;
    property Warnings: TArray<string> read FWarnings write FWarnings;
    property EstimatedTime: Double read FEstimatedTime write FEstimatedTime;
  end;

implementation


end.

unit HuggingFace.Functions.Core;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiHuggingFace
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.JSON;

type
  /// <summary>
  /// Interface defining the core structure and functionality of a function in the system.
  /// </summary>
  /// <remarks>
  /// This interface outlines the basic properties and methods that any function implementation must include.
  /// </remarks>
  IFunctionCore = interface
    ['{E54675CE-F7B0-4505-96F0-E326F0498093}']
    /// <summary>
    /// Retrieves the description of the function.
    /// </summary>
    function GetDescription: string;
    /// <summary>
    /// Retrieves the name of the function.
    /// </summary>
    function GetName: string;
    /// <summary>
    /// Retrieves the parameters required by the function, represented as a JSON schema.
    /// </summary>
    function GetParameters: string;
    /// <summary>
    /// Retrieves the type of the function, typically "function".
    /// </summary>
    function GetType: string;
    /// <summary>
    /// Executes the function with the provided arguments and returns the result as a string.
    /// </summary>
    /// <param name="Arguments">The arguments passed to the function in JSON format.</param>
    /// <returns>The result of the function execution as a string.</returns>
    function Execute(const Arguments: string): string;
     /// <summary>
    /// Converts the TFunctionCore instance to a JSON object that contains its type and representation.
    /// </summary>
    /// <returns>A JSON object representing the function instance.</returns>
    function ToJson: TJSONObject;
    /// <summary>
    /// Creates a string representation of the TFunctionCore instance in JSON format, including its description, name, and parameters.
    /// </summary>
    /// <returns>A string representation of the function in JSON format.</returns>
    function ToString: string;
    /// <summary>
    /// A brief description of the function's purpose, used by the model to determine when and how to call the function.
    /// </summary>
    property Description: string read GetDescription;
    /// <summary>
    /// The unique identifier of the function that will be called. It must only contain characters from a-z, A-Z, 0-9, underscores, or dashes, and should not exceed 64 characters in length.
    /// </summary>
    property Name: string read GetName;
    //// <summary>
    /// The parameters required by the function, specified as a JSON schema. If no parameters are required, use the schema: {"type": "object", "properties": {}}.
    /// </summary>
    property Parameters: string read GetParameters;
    /// <summary>
    /// The type of the tool. Currently, only "function" is supported.
    /// </summary>
    property &Type: string read GetType;
  end;

  /// <summary>
  /// Abstract base class for implementing core function behavior.
  /// </summary>
  /// <remarks>
  /// This class provides basic implementations for some methods and defines the structure that derived classes must follow.
  /// </remarks>
  TFunctionCore = class abstract(TinterfacedObject, IFunctionCore)
  protected
    /// <summary>
    /// Retrieves the description of the function. Derived classes must implement this method.
    /// </summary>
    function GetDescription: string; virtual; abstract;
     /// <summary>
    /// Retrieves the name of the function. Derived classes must implement this method.
    /// </summary>
    function GetName: string; virtual; abstract;
    /// <summary>
    /// Retrieves the parameters required by the function, represented as a JSON schema. Derived classes must implement this method.
    /// </summary>
    function GetParameters: string; virtual; abstract;
    /// <summary>
    /// Retrieves the type of the function, which is "function" by default.
    /// </summary>
    function GetType: string; virtual;
  public
    /// <summary>
    /// Executes the function with the provided arguments and returns the result as a string. Derived classes must implement this method.
    /// </summary>
    /// <param name="Arguments">The arguments passed to the function in JSON format.</param>
    /// <returns>The result of the function execution as a string.</returns>
    function Execute(const Arguments: string): string; virtual; abstract;
    /// <summary>
    /// Converts the TFunctionCore instance to a JSON object that contains its type and representation.
    /// </summary>
    /// <returns>A JSON object representing the function instance.</returns>
    function ToJson: TJSONObject;
    /// <summary>
    /// Creates a string representation of the TFunctionCore instance in JSON format, including its description, name, and parameters.
    /// </summary>
    /// <returns>A string representation of the function in JSON format.</returns>
    function ToString: string; override;
    /// <summary>
    /// A brief description of the function's purpose, used by the model to determine when and how to call the function.
    /// </summary>
    property Description: string read GetDescription;
    /// <summary>
    /// The unique identifier of the function that will be called. It must only contain characters from a-z, A-Z, 0-9, underscores, or dashes, and should not exceed 64 characters in length.
    /// </summary>
    property Name: string read GetName;
    /// <summary>
    /// The parameters required by the function, specified as a JSON schema. If no parameters are required, use the schema: {"type": "object", "properties": {}}.
    /// </summary>
    property Parameters: string read GetParameters;
    /// <summary>
    /// The type of the tool. Currently, only "function" is supported.
    /// </summary>
    property &Type: string read GetType;
  end;

implementation

{ TFunctionCore }

function TFunctionCore.GetType: string;
begin
  Result := 'function';
end;

function TFunctionCore.ToJson: TJSONObject;
begin
  Result := TJSONObject.Create;
  try
    Result.AddPair('type', &Type);
    Result.AddPair('function', TJSONObject.ParseJSONValue(ToString));
  except
    on E: Exception do
      begin
        Result.Free;
        raise;
      end;
  end;
end;

function TFunctionCore.ToString: string;
begin
  with TStringWriter.Create do
    try
      Write('"description": "%s",', [Description]);
      Write('"name": "%s",', [Name]);
      Write('"arguments": %s', [Parameters]);
      Result := Format('{%s}', [ToString]);
    finally
      Free;
    end;
end;

end.

unit HuggingFace.Functions.Example;

interface

uses
  System.SysUtils, HuggingFace.Functions.Core;

type
  TWeatherReportFunction = class(TFunctionCore)
  protected
    function GetDescription: string; override;
    function GetName: string; override;
    function GetParameters: string; override;
  public
    function Execute(const Arguments: string): string; override;
  end;

implementation

uses
  System.StrUtils, System.JSON;

{ TWeatherReportFunction }

function TWeatherReportFunction.Execute(const Arguments: string): string;

  procedure AddToReport(const Value: TJSONObject;
    Temperature: Integer; Forecast: TArray<string>);
  begin
    Value.AddPair('temperature', TJSONNumber.Create(Temperature));
    Value.AddPair('forecast', TJSONArray.Create(Forecast[0], Forecast[1]));
  end;

begin
  Result := EmptyStr;
  var Location := EmptyStr;
  var UnitType := EmptyStr;

  {--- Parse arguments to retrieve parameters }
  var JSON := TJSONObject.ParseJSONValue(Arguments) as TJSONObject;
  try
    if Assigned(JSON) then
    try
      Location := JSON.GetValue('location', '');
      UnitType := JSON.GetValue('unit', '');
    finally
      JSON.Free;
    end;
  except
    Location := EmptyStr;
  end;

  {--- Stop the treatment if location is empty }
  if Location.IsEmpty then
    Exit;

  {--- Build the response }
  JSON := TJSONObject.Create;
  try
    JSON.AddPair('location', Location);
    JSON.AddPair('unit', UnitType);
    case IndexStr(AnsiLowerCase(Location), [
      'paris', 'paris, 75',
      'marseille', 'marseille, 13']) of
      0,1 :
        AddToReport(JSON, 14, ['rainy', 'low visibility']);

      2,3 :
        AddToReport(JSON, 29, ['sunny', 'windy']);
    end;
    Result := JSON.ToJSON;
  finally
    JSON.Free;
  end;
end; {Execute}

function TWeatherReportFunction.GetDescription: string;
begin
  Result := 'Get the current weather in a given location.';
end;

function TWeatherReportFunction.GetName: string;
begin
  Result := 'get_weather';
end;

function TWeatherReportFunction.GetParameters: string;
begin
  Result :=
    '{'+
    '"type": "object",'+
    '"properties": {'+
         '"location": {'+
             '"type": "string",'+
             '"description": "The city and department, e.g. Marseille, 13"'+
         '},'+
         '"unit": {'+
             '"type": "string",'+
             '"enum": ["celsius", "fahrenheit"]'+
         '}'+
     '},'+
     '"required": ["location"]'+
  '}';
end;

end.

unit HuggingFace.Hub.Search;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiHuggingFace
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, Rest.Json,
  REST.Json.Types, System.Net.URLClient, HuggingFace.API, HuggingFace.API.Params,
  HuggingFace.Hub.Support, HuggingFace.Async.Support;

type
  TTokenizerConfig = class
  private
    [JsonNameAttribute('bos_token')]
    FBosToken: string;
    [JsonNameAttribute('chat_template')]
    FChatTemplate: string;
    [JsonNameAttribute('eos_token')]
    FEosToken: string;
    [JsonNameAttribute('pad_token')]
    FPadToken: string;
    [JsonNameAttribute('unk_token')]
    FUnkToken: string;
    [JsonNameAttribute('cls_token')]
    FClsToken: string;
    [JsonNameAttribute('mask_token')]
    FMaskToken: string;
    [JsonNameAttribute('sep_token')]
    FSepToken: string;
  public
    property BosToken: string read FBosToken write FBosToken;
    property ChatTemplate: string read FChatTemplate write FChatTemplate;
    property EosToken: string read FEosToken write FEosToken;
    property PadToken: string read FPadToken write FPadToken;
    property UnkToken: string read FUnkToken write FUnkToken;
    property ClsToken: string read FClsToken write FClsToken;
    property MaskToken: string read FMaskToken write FMaskToken;
    property SepToken: string read FSepToken write FSepToken;
  end;

  TProcessorConfig = class
  private
    [JsonNameAttribute('chat_template')]
    FChatTemplate: string;
  public
    property ChatTemplate: string read FChatTemplate write FChatTemplate;
  end;

  TConfig = class
  private
    FArchitectures: TArray<string>;
    [JsonNameAttribute('model_type')]
    FModelType: string;
    [JsonNameAttribute('processor_config')]
    FProcessorConfig: TProcessorConfig;
    [JsonNameAttribute('tokenizer_config')]
    FTokenizerConfig: TTokenizerConfig;
  public
    property Architectures: TArray<string> read FArchitectures write FArchitectures;
    property ModelType: string read FModelType write FModelType;
    property ProcessorConfig: TProcessorConfig read FProcessorConfig write FProcessorConfig;
    property TokenizerConfig: TTokenizerConfig read FTokenizerConfig write FTokenizerConfig;
    destructor Destroy; override;
  end;

  TSibling = class
  private
    FRfilename: string;
  public
    property Rfilename: string read FRfilename write FRfilename;
  end;

  TWidgetDataItem = class
  private
    [JsonNameAttribute('example_title')]
    FExampleTitle: string;
    FSrc: string;
  public
    property ExampleTitle: string read FExampleTitle write FExampleTitle;
    property Src: string read FSrc write FSrc;
  end;

  TDataFiles = class
  private
    FSplit: string;
    FPath: string;
  public
    property Split: string read FSplit write FSplit;
    property Path: string read FPath write FPath;
  end;

  TCardDataConfig = class
  private
    [JsonNameAttribute('config_name')]
    FConfigName: string;
    [JsonNameAttribute('data_files')]
    FDataFiles: TArray<TDataFiles>;
    FDefault: Boolean;
  public
    property ConfigName: string read FConfigName write FConfigName;
    property DataFiles: TArray<TDataFiles> read FDataFiles write FDataFiles;
    property Default: Boolean read FDefault write FDefault;
    destructor Destroy; override;
  end;

  TModelIndexItem = class;
  
  TCardData = class
  private
    FLanguage: TArray<string>;
    FTags: TArray<string>;
    FWidget: TArray<TWidgetDataItem>;
    [JsonNameAttribute('pipeline_tag')]
    FPipelineTag: string;
    FLicense: string;
    FThumbnail: string;
    FLibrary: string;
    FInference: Boolean;   
    [JsonNameAttribute('library_name')]
    FLibraryName: string;
    FDatasets: TArray<string>;
    [JsonNameAttribute('model-index')]
    FModelIndex: TArray<TModelIndexItem>;
    FMetrics: TArray<string>;
    [JsonNameAttribute('task_categories')]
    FTaskCategories: TArray<string>;
    [JsonNameAttribute('size_categories')]
    FSizeCategories: TArray<string>;
    FConfigs: TArray<TCardDataConfig>;
  public
    property Language: TArray<string> read FLanguage write FLanguage;
    property Tags: TArray<string> read FTags write FTags;
    property Widget: TArray<TWidgetDataItem> read FWidget write FWidget;
    property PipelineTag: string read FPipelineTag write FPipelineTag;
    property License: string read FLicense write FLicense;
    property Thumbnail: string read FThumbnail write FThumbnail;
    property &Library: string read FLibrary write FLibrary;
    property Inference: Boolean read FInference write FInference;
    property LibraryName: string read FLibraryName write FLibraryName;
    property Datasets: TArray<string> read FDatasets write FDatasets;
    property ModelIndex: TArray<TModelIndexItem> read FModelIndex write FModelIndex;
    property Metrics: TArray<string> read FMetrics write FMetrics;
    property TaskCategories: TArray<string> read FTaskCategories write FTaskCategories;
    property SizeCategories: TArray<string> read FSizeCategories write FSizeCategories;
    property Configs: TArray<TCardDataConfig> read FConfigs write FConfigs;
    destructor Destroy; override;
  end;

  TTransformersInfo = class
  private
    [JsonNameAttribute('auto_model')]
    FAutoModel: string;
    [JsonNameAttribute('pipeline_tag')]
    FPipelineTag: string;
    FProcessor: string;
  public
    property AutoModel: string read FAutoModel write FAutoModel;
    property PipelineTag: string read FPipelineTag write FPipelineTag;
    property Processor: string read FProcessor write FProcessor;
  end;

  TSafetensorsParameters = class
  private
    FF16: int64;
  public
    property F16: int64 read FF16 write FF16;
  end;

  TSafetensors = class
  private
    FParameters: TSafetensorsParameters;
    FTotal: Int64;
  public
    property Parameters: TSafetensorsParameters read FParameters write FParameters;
    property Total: Int64 read FTotal write FTotal;
    destructor Destroy; override;
  end;

  TResultTask = class
  private
    FName: string;
    FType: string;
  public
    property Name: string read FName write FName;
    property &Type: string read FType write FType;
  end;

  TDataSetArgs = class
  private
    FLanguage: string;
  public
    property Language: string read FLanguage write FLanguage;
  end;

  TResultDataset = class
  private
    FName: string;
    FType: string;
    FConfig: string;
    FSplit: string;
    FArgs: TDataSetArgs;
  public
    property Name: string read FName write FName;
    property &Type: string read FType write FType;
    property Config: string read FConfig write FConfig;
    property Split: string read FSplit write FSplit;
    property Args: TDataSetArgs read FArgs write FArgs;
    destructor Destroy; override;
  end;

  TResultMetrics = class
  private
    FName: string;
    FType: string;
    FValue: Double;
    FVerified: Boolean;
  public
    property Name: string read FName write FName;
    property &Type: string read FType write FType;
    property Value: Double read FValue write FValue;
    property Verified: Boolean read FVerified write FVerified;
  end;

  TModelResult = class
  private
    FTask: TResultTask;
    FDataset: TResultDataset;
    FMetrics: TArray<TResultMetrics>;
  public
    property Task: TResultTask read FTask write FTask;
    property Dataset: TResultDataset read FDataset write FDataset;
    property Metrics: TArray<TResultMetrics> read FMetrics write FMetrics;
    destructor Destroy; override;
  end;

  TModelIndexItem = class
  private
    FName: string;
    FResults: TArray<TModelResult>;
  public
    property Name: string read FName write FName;
    property Results: TArray<TModelResult> read FResults write FResults;
    destructor Destroy; override;
  end;

  TModel = class
  private
    F_id: string;
    FId: string;
    FAuthor: string;
    FGated: Boolean;
    FInference: string;
    FLastModified: string;
    FLikes: Int64;
    FTrendingScore: Int64;
    FPrivate: Boolean;
    FSha: string;
    FConfig: TConfig;
    FDownloads: Int64;
    FTags: TArray<string>;
    [JsonNameAttribute('pipeline_tag')]
    FPipelineTag: string;
    [JsonNameAttribute('library_name')]
    FLibraryName: string;
    FCreatedAt: string;
    FModelId: string;
    FSiblings: TArray<TSibling>;
  public
    property _id: string read F_id write F_id;
    property Id: string read FId write FId;
    property Author: string read FAuthor write FAuthor;
    property Gated: Boolean read FGated write FGated;
    property Inference: string read FInference write FInference;
    property LastModified: string read FLastModified write FLastModified;
    property Likes: Int64 read FLikes write FLikes;
    property TrendingScore: Int64 read FTrendingScore write FTrendingScore;
    property &Private: Boolean read FPrivate write FPrivate;
    property Sha: string read FSha write FSha;
    property Config: TConfig read FConfig write FConfig;
    property Downloads: Int64 read FDownloads write FDownloads;
    property Tags: TArray<string> read FTags write FTags;
    property PipelineTag: string read FPipelineTag write FPipelineTag;
    property LibraryName: string read FLibraryName write FLibraryName;
    property CreatedAt: string read FCreatedAt write FCreatedAt;
    property ModelId: string read FModelId write FModelId;
    property Siblings: TArray<TSibling> read FSiblings write FSiblings;
    destructor Destroy; override;
  end;

  TModels = class
  private
    FItems: TArray<TModel>;
    FUrlNext: string;
  public
    property Items: TArray<TModel> read FItems write FItems;
    property UrlNext: string read FUrlNext write FUrlNext;
    destructor Destroy; override;
  end;

  TRepoModel = class(TModel)
  private
    FDisabled: Boolean;
    FWidgetData: TArray<TWidgetDataItem>;
    [JsonNameAttribute('model-index')]
    FModelIndex: TArray<TModelIndexItem>;
    FCardData: TCardData;
    FTransformersInfo: TTransformersInfo;
    FSpaces: TArray<string>;
    FSafetensors: TSafetensors;
  public
    property Disabled: Boolean read FDisabled write FDisabled;
    property WidgetData: TArray<TWidgetDataItem> read FWidgetData write FWidgetData;
    property ModelIndex: TArray<TModelIndexItem> read FModelIndex write FModelIndex;
    property CardData: TCardData read FCardData write FCardData;
    property TransformersInfo: TTransformersInfo read FTransformersInfo write FTransformersInfo;
    property Spaces: TArray<string> read FSpaces write FSpaces;
    property Safetensors: TSafetensors read FSafetensors write FSafetensors;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TModels</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynModels</c> type extends the <c>TAsynParams&lt;TModels&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynModels = TAsynCallBack<TModels>;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TRepoModel</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynRepoModel</c> type extends the <c>TAsynParams&lt;TRepoModel&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynRepoModel = TAsynCallBack<TRepoModel>;

  THubRoute = class(THuggingFaceAPIRoute)
    /// <summary>
    /// Fetch model by ID
    /// </summary>
    /// <param name="RepoId">
    /// The model's Id to fetch
    /// </param>
    /// <returns>
    /// A <c>TRepoModel</c> object containing the model returned.
    /// </returns>
    /// <remarks>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var HFHub := THuggingFaceFactory.CreateInstance(BaererKey, True);
    /// var Value := HFHub.Hub.FetchModel('modelId');
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function FetchModel(const RepoId: string): TRepoModel; overload;
    /// <summary>
    /// Fetch model by ID
    /// </summary>
    /// <param name="RepoId">
    /// The model's Id to fetch
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns <c>TAsynRepoModel</c> to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// <para>
    /// The <c>CallBacks</c> function is invoked when the operation completes, either successfully or with an error.
    /// </para>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var HFHub := THuggingFaceFactory.CreateInstance(BaererKey, True);
    /// HFHub.Hub.FetchModel('modelId',
    ///   function : TAsynRepoModel
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TRepoModel)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure FetchModel(const RepoId: string; CallBacks: TFunc<TAsynRepoModel>); overload;
    /// <summary>
    /// Fetch a filtered list of model.
    /// </summary>
    /// <param name="UrlNext">
    /// The URL of the next page of result.
    /// <para>
    /// If Url Next is empty then the first page is fetched
    /// </para>
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TFetchParams</c> parameters.
    /// </param>
    /// <returns>
    /// A <c>TModels</c> object containing the list of fetched models.
    /// </returns>
    /// <remarks>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var HFHub := THuggingFaceFactory.CreateInstance(BaererKey, True);
    /// var Value := HFHub.Hub.FetchModels(UrlNext,
    ///     procedure (Params: TFetchParams)
    ///     begin
    ///       // Define parameters
    ///     end;
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function FetchModels(UrlNext: string; ParamProc: TProc<TFetchParams>): TModels; overload;
    /// <summary>
    /// Fetch a filtered list of model.
    /// </summary>
    /// <param name="UrlNext">
    /// The URL of the next page of result.
    /// <para>
    /// If Url Next is empty then the first page is fetched
    /// </para>
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TFetchParams</c> parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns <c>TAsynModels</c> to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// <para>
    /// The <c>CallBacks</c> function is invoked when the operation completes, either successfully or with an error.
    /// </para>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var HFHub := THuggingFaceFactory.CreateInstance(BaererKey, True);
    /// HFHub.Hub.FetchModels(UrlNext,
    ///   procedure (Params: TFetchParams)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynModels
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TModels)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure FetchModels(UrlNext: string;
      ParamProc: TProc<TFetchParams>; CallBacks: TFunc<TAsynModels>); overload;
  end;

implementation

{ TConfig }

destructor TConfig.Destroy;
begin
  if Assigned(FTokenizerConfig) then
    FTokenizerConfig.Free;
  if Assigned(FProcessorConfig) then
    FProcessorConfig.Free;
  inherited;
end;

{ TModel }

destructor TModel.Destroy;
begin
  if Assigned(FConfig) then
    FConfig.Free;
  for var Item in FSiblings do
    Item.Free;
  inherited;
end;

{ TModels }

destructor TModels.Destroy;
begin
  for var Item in FItems do
    Item.Free;
  inherited;
end;

{ THubRoute }

function THubRoute.FetchModel(const RepoId: string): TRepoModel;
begin
  Result := API.Get<TRepoModel>('api/models/' + RepoId);
end;

function THubRoute.FetchModels(UrlNext: string; ParamProc: TProc<TFetchParams>): TModels;

  procedure Fetch;
  begin
    var Params := TFetchParams.Create;
    try
      ParamProc(Params);
      Result := API.Get<TModels>('api/models' + Params.Value, UrlNext);
    finally
      Params.Free;
    end;
  end;

  procedure Next;
  begin
    Result := API.GetLink<TModels>(UrlNext);
  end;

begin
  if UrlNext.IsEmpty then
    Fetch else
    Next;
  Result.UrlNext := UrlNext;
end;

procedure THubRoute.FetchModel(const RepoId: string;
  CallBacks: TFunc<TAsynRepoModel>);
begin
  with TAsynCallBackExec<TAsynRepoModel, TRepoModel>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TRepoModel
      begin
        Result := Self.FetchModel(RepoId);
      end);
  finally
    Free;
  end;
end;

procedure THubRoute.FetchModels(UrlNext: string;
  ParamProc: TProc<TFetchParams>; CallBacks: TFunc<TAsynModels>);
begin
  with TAsynCallBackExec<TAsynModels, TModels>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TModels
      begin
        Result := Self.FetchModels(UrlNext, ParamProc);
      end);
  finally
    Free;
  end;
end;

{ TCardData }

destructor TCardData.Destroy;
begin
  for var Item in FWidget do
    Item.Free;
  for var Item in FModelIndex do
    Item.Free;
  for var Item in FConfigs do
    Item.Free;
  inherited;
end;

{ TSafetensors }

destructor TSafetensors.Destroy;
begin
  if Assigned(FParameters) then
    FParameters.Free;
  inherited;
end;

{ TModelIndexItem }

destructor TModelIndexItem.Destroy;
begin
  for var Item in FResults do
    Item.Free;
  inherited;
end;

{ TModelResult }

destructor TModelResult.Destroy;
begin
  if Assigned(FTask) then
    FTask.Free;
  if Assigned(FDataset) then
    FDataset.Free;
  for var Item in FMetrics  do
    Item.Free;
  inherited;
end;

{ TResultDataset }

destructor TResultDataset.Destroy;
begin
  if Assigned(FArgs) then
    FArgs.Free;
  inherited;
end;

{ TRepoModel }

destructor TRepoModel.Destroy;
begin
  for var Item in FWidgetData do
    Item.Free;
  for var Item in FModelIndex do
    Item.Free;  
  if Assigned(FCardData) then
    FCardData.Free;
  if Assigned(FTransformersInfo) then
    FTransformersInfo.Free;
  if Assigned(FSafetensors) then
    FSafetensors.Free;
  inherited;
end;

{ TCardDataConfig }

destructor TCardDataConfig.Destroy;
begin
  for var Item in FDataFiles do
    Item.Free;
  inherited;
end;

end.

unit HuggingFace.Hub.Support;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiHuggingFace
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, HuggingFace.API.Params;

type
  TFetchParams = class(TCMDParam)
  public
    function Search(const Value: string): TFetchParams;
    function Author(const Value: string): TFetchParams;
    function Filter(const Value: string): TFetchParams;
    function Sort(const Value: string): TFetchParams;
    function Direction(const Value: string): TFetchParams;
    function Limit(const Value: Integer): TFetchParams;
    function Full(const Value: Boolean): TFetchParams;
    function Config(const Value: Boolean): TFetchParams;
    constructor Create;
  end;

implementation

{ TFetchParams }

function TFetchParams.Author(const Value: string): TFetchParams;
begin
  Result := TFetchParams(Add('author', Value));
end;

function TFetchParams.Config(const Value: Boolean): TFetchParams;
begin
  Result := TFetchParams(Add('config', Value));
end;

constructor TFetchParams.Create;
begin
  Inherited Create;
  Limit(5);
  Full(True);
  Config(False);
end;

function TFetchParams.Direction(const Value: string): TFetchParams;
begin
  Result := TFetchParams(Add('direction', Value));
end;

function TFetchParams.Filter(const Value: string): TFetchParams;
begin
  Result := TFetchParams(Add('filter', Value));
end;

function TFetchParams.Full(const Value: Boolean): TFetchParams;
begin
  Result := TFetchParams(Add('full', Value));
end;

function TFetchParams.Limit(const Value: Integer): TFetchParams;
begin
  Result := TFetchParams(Add('limit', Value));
end;

function TFetchParams.Search(const Value: string): TFetchParams;
begin
  Result := TFetchParams(Add('search', Value));
end;

function TFetchParams.Sort(const Value: string): TFetchParams;
begin
  Result := TFetchParams(Add('sort', Value));
end;

end.

unit HuggingFace.Image;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiHuggingFace
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, Winapi.Windows, REST.JsonReflect, System.JSON,
  Rest.Json, REST.Json.Types, System.Net.URLClient, HuggingFace.API, HuggingFace.API.Params,
  HuggingFace.Async.Support, HuggingFace.Types;

type

  {$REGION 'Image Classification'}

  TImageClassificationParameters = class(TJSONParam)
  public
    /// <summary>
    /// Possible values: sigmoid, softmax, none.
    /// </summary>
    function FunctionToApply(const Value: TFunctionClassification): TImageClassificationParameters;
    /// <summary>
    /// When specified, limits the output to the top K most probable classes.
    /// </summary>
    function TopK(const Value: Integer): TImageClassificationParameters;
  end;

  TImageClassificationParam = class(TJSONModelParam)
  public
    /// <summary>
    /// The input image data as a base64-encoded string.
    /// </summary>
    /// <param name="FileName">
    /// The path and the name of the image file
    /// </param>
    function Inputs(const FileName: string): TImageClassificationParam;
    /// <summary>
    /// Classification parameters
    /// </summary>
    function parameters(const FunctionToApply: TFunctionClassification; const TopK: Integer = -1): TImageClassificationParam; overload;
    /// <summary>
    /// Set top_k Classification parameter
    /// </summary>
    function parameters(const TopK: Integer): TImageClassificationParam; overload;
  end;

  TImageClassificationItem = class
  private
    FLabel: string;
    FScore: Double;
  public
    /// <summary>
    /// The predicted class label.
    /// </summary>
    property &Label: string read FLabel write FLabel;
    /// <summary>
    /// The corresponding probability.
    /// </summary>
    property Score: Double read FScore write FScore;
  end;

  TImageClassification = class
  private
    FItems: TArray<TImageClassificationItem>;
  public
    /// <summary>
    /// Output is an array of objects.
    /// </summary>
    property Items: TArray<TImageClassificationItem> read FItems write FItems;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TImageClassification</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynImageClassification</c> type extends the <c>TAsynParams&lt;TImageClassification&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynImageClassification = TAsynCallBack<TImageClassification>;

  {$ENDREGION}

  {$REGION 'Image Segmentation'}

  TImageSegmentationParameters = class(TJSONParam)
  public
    /// <summary>
    /// Threshold to use when turning the predicted masks into binary values.
    /// </summary>
    function MaskThreshold(const Value: Double): TImageSegmentationParameters;
    /// <summary>
    /// Mask overlap threshold to eliminate small, disconnected segments.
    /// </summary>
    function OverlapMaskAreaThreshold(const Value: Double): TImageSegmentationParameters;
    /// <summary>
    /// Possible values: instance, panoptic, semantic.
    /// </summary>
    function Subtask(const Value: TSubtaskType): TImageSegmentationParameters;
    /// <summary>
    /// Probability threshold to filter out predicted masks.
    /// </summary>
    function Threshold(const Value: Double): TImageSegmentationParameters;
  end;

  TImageSegmentationParam = class(TJSONModelParam)
  public
    /// <summary>
    /// The input image data as a base64-encoded string.
    /// </summary>
    /// <param name="FileName">
    /// The path and the name of the image file
    /// </param>
    function Inputs(const FileName: string): TImageSegmentationParam;
    /// <summary>
    /// Segmentation parameters
    /// </summary>
    function Parameters(ParamProc: TProcRef<TImageSegmentationParameters>): TImageSegmentationParam;
  end;

  TJSONImageSegmentation = class
  private
    FLabel: string;
    FMask: string;
    FScore: Double;
  public
    /// <summary>
    /// The label of the predicted segment.
    /// </summary>
    property &Label: string read FLabel write FLabel;
    /// <summary>
    /// The corresponding mask as a black-and-white image (base64-encoded).
    /// </summary>
    property Mask: string read FMask write FMask;
    /// <summary>
    /// The score or confidence degree the model has.
    /// </summary>
    property Score: Double read FScore write FScore;
  end;

  TImageSegmentationItem = class(TJSONImageSegmentation)
  private
    FFileName: string;
  public
    /// <summary>
    /// Retrieves the generated image as a <c>TStream</c>.
    /// </summary>
    /// <returns>
    /// A <c>TStream</c> containing the decoded image data.
    /// </returns>
    /// <remarks>
    /// This method decodes the base64-encoded image data and returns it as a stream.
    /// The caller is responsible for freeing the returned stream.
    /// </remarks>
    /// <exception cref="Exception">
    /// Raises an exception if both the image data are empty.
    /// </exception>
    function GetStream: TStream;
    /// <summary>
    /// Saves the generated image to a file.
    /// </summary>
    /// <param name="FileName">
    /// The file path where the image will be saved.
    /// </param>
    /// <remarks>
    /// This method decodes the base64-encoded image data and saves it to the specified file.
    /// </remarks>
    /// <exception cref="Exception">
    /// Raises an exception if the image data cannot be decoded or saved.
    /// </exception>
    procedure SaveToFile(const FileName: string);
    /// <summary>
    /// Gets the file name where the image was saved.
    /// </summary>
    /// <value>
    /// The file path as a string.
    /// </value>
    /// <remarks>
    /// This property holds the file name specified in the last call to <c>SaveToFile</c>.
    /// </remarks>
    property FileName: string read FFileName write FFileName;
  end;

  TImageSegmentation = class
  private
    FItems: TArray<TImageSegmentationItem>;
  public
    /// <summary>
    /// Output is an array of objects.
    /// </summary>
    property Items: TArray<TImageSegmentationItem> read FItems write FItems;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TImageSegmentation</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynImageSegmentation</c> type extends the <c>TAsynParams&lt;TImageSegmentation&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynImageSegmentation = TAsynCallBack<TImageSegmentation>;

  {$ENDREGION}

  {$REGION 'Object Detection'}

  TObjectDetectionParam = class(TJSONModelParam)
  public
    /// <summary>
    /// The input image data as a base64-encoded string.
    /// </summary>
    /// <param name="FileName">
    /// The path and the name of the image file
    /// </param>
    function Inputs(const FileName: string): TObjectDetectionParam;
    /// <summary>
    /// The probability necessary to make a prediction.
    /// </summary>
    function Parameters(const Threshold: Double): TObjectDetectionParam;
  end;

  TObjectDetectionBox = class
  private
    FXmin: Integer;
    FXmax: Integer;
    FYmin: Integer;
    FYmax: Integer;
  public
    /// <summary>
    /// The x-coordinate of the top-left corner of the bounding box.
    /// </summary>
    property Xmin: Integer read FXmin write FXmin;
    /// <summary>
    /// The x-coordinate of the bottom-right corner of the bounding box.
    /// </summary>
    property Xmax: Integer read FXmax write FXmax;
    /// <summary>
    /// The y-coordinate of the top-left corner of the bounding box.
    /// </summary>
    property Ymin: Integer read FYmin write FYmin;
    /// <summary>
    /// The y-coordinate of the bottom-right corner of the bounding box.
    /// </summary>
    property Ymax: Integer read FYmax write FYmax;
  end;

  TObjectDetectionItem = class
  private
    FLabel: string;
    FScore: Double;
    FBox: TObjectDetectionBox;
  public
    function ToRect: TRect;
    /// <summary>
    /// The predicted label for the bounding box.
    /// </summary>
    property &Label: string read FLabel write FLabel;
    /// <summary>
    /// The associated score / probability.
    /// </summary>
    property Score: Double read FScore write FScore;
    property Box: TObjectDetectionBox read FBox write FBox;
    destructor Destroy; override;
  end;

  TObjectDetection = class
  private
    FItems: TArray<TObjectDetectionItem>;
  public
    /// <summary>
    /// Output is an array of objects.
    /// </summary>
    property Items: TArray<TObjectDetectionItem> read FItems write FItems;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TObjectDetection</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynObjectDetection</c> type extends the <c>TAsynParams&lt;TObjectDetection&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynObjectDetection = TAsynCallBack<TObjectDetection>;

  {$ENDREGION}

  {$REGION 'Image To Image'}

  TTargetSizeParam = class(TJSONParam)
  public
    function Width(const Value: Integer): TTargetSizeParam;
    function Height(const Value: Integer): TTargetSizeParam;
  end;

  TImageToImageParameters = class(TJSONParam)
  public
    /// <summary>
    /// For diffusion models. A higher guidance scale value encourages the model to generate images
    /// closely linked to the text prompt at the expense of lower image quality.
    /// </summary>
    function GuidanceScale(const Value: Double): TImageToImageParameters;
    /// <summary>
    /// One or several prompt to guide what NOT to include in image generation.
    /// </summary>
    function NegativePrompt(const Value: TArray<string>): TImageToImageParameters;
    /// <summary>
    /// For diffusion models. The number of denoising steps. More denoising steps usually lead to
    /// a higher quality image at the expense of slower inference.
    /// </summary>
    function NumInferenceSteps(const Value: Integer): TImageToImageParameters;
    /// <summary>
    /// The size in pixel of the output image.
    /// </summary>
    function TargetSize(const Width, Height: Integer): TImageToImageParameters;
  end;

  TImageToImageParam = class(TJSONModelParam)
  public
    /// <summary>
    /// The input image data as a base64-encoded string.
    /// </summary>
    /// <param name="FileName">
    /// The path and the name of the image file
    /// </param>
    function Inputs(const FileName: string): TImageToImageParam;
    /// <summary>
    /// Set parameters
    /// </summary>
    function Parameters(ParamProc: TProcRef<TImageToImageParameters>): TImageToImageParam;
  end;

  TImageToImage = class
  private
    FFileName: string;
    FImage: string;
  public
    /// <summary>
    /// Retrieves the generated image as a <c>TStream</c>.
    /// </summary>
    /// <returns>
    /// A <c>TStream</c> containing the decoded image data.
    /// </returns>
    /// <remarks>
    /// This method decodes the base64-encoded image data and returns it as a stream.
    /// The caller is responsible for freeing the returned stream.
    /// </remarks>
    /// <exception cref="Exception">
    /// Raises an exception if both the image and video data are empty.
    /// </exception>
    function GetStream: TStream;
    /// <summary>
    /// Saves the generated image to a file.
    /// </summary>
    /// <param name="FileName">
    /// The file path where the image will be saved.
    /// </param>
    /// <remarks>
    /// This method decodes the base64-encoded image data and saves it to the specified file.
    /// </remarks>
    /// <exception cref="Exception">
    /// Raises an exception if the image data cannot be decoded or saved.
    /// </exception>
    procedure SaveToFile(const FileName: string);
    /// <summary>
    /// The output image as base-64 returned
    /// </summary>
    property Image: string read FImage write FImage;
    /// <summary>
    /// Gets the file name where the image was saved.
    /// </summary>
    /// <value>
    /// The file path as a string.
    /// </value>
    /// <remarks>
    /// This property holds the file name specified in the last call to <c>SaveToFile</c>.
    /// </remarks>
    property FileName: string read FFileName write FFileName;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TImageToImage</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynImageToImage</c> type extends the <c>TAsynParams&lt;TImageToImage&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynImageToImage = TAsynCallBack<TImageToImage>;

  {$ENDREGION}

  TImageRoute = class(THuggingFaceAPIRoute)
    /// <summary>
    /// Image classification is the task of assigning a label or class to an entire image.
    /// Images are expected to have only one class for each image.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TImageClassificationParam</c> parameters.
    /// </param>
    /// <returns>
    /// A <c>TImageClassification</c> object containing the Classification result.
    /// </returns>
    /// <remarks>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// var Value := HuggingFace.Image.Classification(
    ///     procedure (Params: TImageClassificationParam)
    ///     begin
    ///       // Define parameters
    ///     end;
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function Classification(ParamProc: TProc<TImageClassificationParam>): TImageClassification; overload;
    /// <summary>
    /// Image classification is the task of assigning a label or class to an entire image.
    /// Images are expected to have only one class for each image.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TImageClassificationParam</c> parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns <c>TAsynImageClassification</c> to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// <para>
    /// The <c>CallBacks</c> function is invoked when the operation completes, either successfully or with an error.
    /// </para>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// HuggingFace.Image.Classification(
    ///   procedure (Params: TImageClassificationParam)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynImageClassification
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TImageClassification)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure Classification(ParamProc: TProc<TImageClassificationParam>;
      CallBacks: TFunc<TAsynImageClassification>); overload;
    /// <summary>
    /// Image processing from the model.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TImageToImageParam</c> parameters.
    /// </param>
    /// <returns>
    /// A <c>TImageToImage</c> object containing the ImageToImage result.
    /// </returns>
    /// <remarks>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// var Value := HuggingFace.Image.ImageToImage(
    ///     procedure (Params: TImageToImageParam)
    ///     begin
    ///       // Define parameters
    ///     end;
    /// try
    ///   WriteLn(Value.Text);
    /// finally
    ///   // Handle the Value
    /// end;
    /// </code>
    /// </remarks>
    function ImageToImage(ParamProc: TProc<TImageToImageParam>): TImageToImage; overload;
    /// <summary>
    /// Image classification is the task of assigning a label or class to an entire image.
    /// Images are expected to have only one class for each image.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TImageToImageParam</c> parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns <c>TAsynImageToImage</c> to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// <para>
    /// The <c>CallBacks</c> function is invoked when the operation completes, either successfully or with an error.
    /// </para>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// HuggingFace.Image.ImageToImage(
    ///   procedure (Params: TImageToImageParam)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynImageToImage
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TImageToImage)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure ImageToImage(ParamProc: TProc<TImageToImageParam>;
      CallBacks: TFunc<TAsynImageToImage>); overload;
    /// <summary>
    /// Object Detection models allow users to identify objects of certain defined classes.
    /// These models receive an image as input and output the images with bounding boxes and
    /// labels on detected objects.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TObjectDetectionParam</c> parameters.
    /// </param>
    /// <returns>
    /// A <c>TObjectDetection</c> object containing the ObjectDetection result.
    /// </returns>
    /// <remarks>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// var Value := HuggingFace.Image.ObjectDetection(
    ///     procedure (Params: TObjectDetectionParam)
    ///     begin
    ///       // Define parameters
    ///     end;
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function ObjectDetection(ParamProc: TProc<TObjectDetectionParam>): TObjectDetection; overload;
    /// <summary>
    /// Object Detection models allow users to identify objects of certain defined classes.
    /// These models receive an image as input and output the images with bounding boxes and
    /// labels on detected objects.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TObjectDetectionParam</c> parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns <c>TAsynObjectDetection</c> to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// <para>
    /// The <c>CallBacks</c> function is invoked when the operation completes, either successfully or with an error.
    /// </para>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// HuggingFace.Image.ObjectDetection(
    ///   procedure (Params: TObjectDetectionParam)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynObjectDetection
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TObjectDetection)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure ObjectDetection(ParamProc: TProc<TObjectDetectionParam>;
      CallBacks: TFunc<TAsynObjectDetection>); overload;
    /// <summary>
    /// Image Segmentation divides an image into segments where each pixel in the image is mapped to an object.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TImageSegmentationParam</c> parameters.
    /// </param>
    /// <returns>
    /// A <c>TImageSegmentation</c> object containing the Segmentation result.
    /// </returns>
    /// <remarks>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// var Value := HuggingFace.Image.Segmentation(
    ///     procedure (Params: TImageSegmentationParam)
    ///     begin
    ///       // Define parameters
    ///     end;
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function Segmentation(ParamProc: TProc<TImageSegmentationParam>): TImageSegmentation; overload;
    /// <summary>
    /// Image Segmentation divides an image into segments where each pixel in the image is mapped to an object.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TImageSegmentationParam</c> parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns <c>TAsynImageSegmentation</c> to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// <para>
    /// The <c>CallBacks</c> function is invoked when the operation completes, either successfully or with an error.
    /// </para>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// HuggingFace.Image.Segmentation(
    ///   procedure (Params: TImageSegmentationParam)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynImageSegmentation
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TImageSegmentation)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure Segmentation(ParamProc: TProc<TImageSegmentationParam>;
      CallBacks: TFunc<TAsynImageSegmentation>); overload;
  end;

implementation

uses
  HuggingFace.NetEncoding.Base64;

{ TImageClassificationParam }

function TImageClassificationParam.Inputs(
  const FileName: string): TImageClassificationParam;
begin
  Result := TImageClassificationParam(Add('inputs', EncodeBase64(FileName)));
end;

function TImageClassificationParam.parameters(
  const FunctionToApply: TFunctionClassification;
  const TopK: Integer): TImageClassificationParam;
begin
  var Value := TImageClassificationParameters.Create.FunctionToApply(FunctionToApply);
  if TopK <> -1 then
    Value := Value.TopK(TopK);
  Result := TImageClassificationParam(Add('parameters', Value.Detach));
end;

function TImageClassificationParam.parameters(
  const TopK: Integer): TImageClassificationParam;
begin
  Result := TImageClassificationParam(Add('parameters', TImageClassificationParameters.Create.TopK(TopK).Detach));
end;

{ TImageClassificationParameters }

function TImageClassificationParameters.FunctionToApply(
  const Value: TFunctionClassification): TImageClassificationParameters;
begin
  Result := TImageClassificationParameters(Add('function_to_apply', Value.ToString));
end;

function TImageClassificationParameters.TopK(
  const Value: Integer): TImageClassificationParameters;
begin
  Result := TImageClassificationParameters(Add('top_k', Value));
end;

{ TImageClassification }

destructor TImageClassification.Destroy;
begin
  for var Item in FItems do
    Item.Free;
  inherited;
end;

{ TImageRoute }

function TImageRoute.Classification(
  ParamProc: TProc<TImageClassificationParam>): TImageClassification;
begin
  Result := API.Post<TImageClassification, TImageClassificationParam>('models', ParamProc);
end;

procedure TImageRoute.Classification(
  ParamProc: TProc<TImageClassificationParam>;
  CallBacks: TFunc<TAsynImageClassification>);
begin
  with TAsynCallBackExec<TAsynImageClassification, TImageClassification>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TImageClassification
      begin
        Result := Self.Classification(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TImageRoute.ImageToImage(
  ParamProc: TProc<TImageToImageParam>): TImageToImage;
begin
  Result := API.Post<TImageToImage, TImageToImageParam>('models', ParamProc, 'image');
end;

procedure TImageRoute.ImageToImage(ParamProc: TProc<TImageToImageParam>;
  CallBacks: TFunc<TAsynImageToImage>);
begin
  with TAsynCallBackExec<TAsynImageToImage, TImageToImage>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TImageToImage
      begin
        Result := Self.ImageToImage(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TImageRoute.ObjectDetection(ParamProc: TProc<TObjectDetectionParam>;
  CallBacks: TFunc<TAsynObjectDetection>);
begin
  with TAsynCallBackExec<TAsynObjectDetection, TObjectDetection>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TObjectDetection
      begin
        Result := Self.ObjectDetection(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TImageRoute.ObjectDetection(
  ParamProc: TProc<TObjectDetectionParam>): TObjectDetection;
begin
  Result := API.Post<TObjectDetection, TObjectDetectionParam>('models', ParamProc);
end;

procedure TImageRoute.Segmentation(ParamProc: TProc<TImageSegmentationParam>;
  CallBacks: TFunc<TAsynImageSegmentation>);
begin
  with TAsynCallBackExec<TAsynImageSegmentation, TImageSegmentation>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TImageSegmentation
      begin
        Result := Self.Segmentation(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TImageRoute.Segmentation(
  ParamProc: TProc<TImageSegmentationParam>): TImageSegmentation;
begin
  Result := API.Post<TImageSegmentation, TImageSegmentationParam>('models', ParamProc);
end;

{ TImageSegmentationParam }

function TImageSegmentationParam.Inputs(
  const FileName: string): TImageSegmentationParam;
begin
  Result := TImageSegmentationParam(Add('inputs', EncodeBase64(FileName)));
end;

function TImageSegmentationParam.Parameters(
  ParamProc: TProcRef<TImageSegmentationParameters>): TImageSegmentationParam;
begin
  if Assigned(ParamProc) then
    begin
      var Value := TImageSegmentationParameters.Create;
      ParamProc(Value);
      Result := TImageSegmentationParam(Add('parameters', Value));
    end
  else Result := Self;
end;

{ TImageSegmentationParameters }

function TImageSegmentationParameters.MaskThreshold(
  const Value: Double): TImageSegmentationParameters;
begin
  Result := TImageSegmentationParameters(Add('mask_threshold', Value));
end;

function TImageSegmentationParameters.OverlapMaskAreaThreshold(
  const Value: Double): TImageSegmentationParameters;
begin
  Result := TImageSegmentationParameters(Add('overlap_mask_area_threshold', Value));
end;

function TImageSegmentationParameters.Subtask(
  const Value: TSubtaskType): TImageSegmentationParameters;
begin
  Result := TImageSegmentationParameters(Add('subtask', Value.ToString));
end;

function TImageSegmentationParameters.Threshold(
  const Value: Double): TImageSegmentationParameters;
begin
  Result := TImageSegmentationParameters(Add('threshold', Value));
end;

{ TImageSegmentation }

destructor TImageSegmentation.Destroy;
begin
  for var Item in FItems do
    Item.Free;
  inherited;
end;

{ TImageSegmentationItem }

function TImageSegmentationItem.GetStream: TStream;
begin
  {--- Create a memory stream to write the decoded content. }
  Result := TMemoryStream.Create;
  try
    {--- Convert the base-64 string directly into the memory stream. }
    DecodeBase64ToStream(Mask, Result)
  except
    Result.Free;
    raise;
  end;
end;

procedure TImageSegmentationItem.SaveToFile(const FileName: string);
begin
  try
    Self.FFileName := FileName;
    {--- Perform the decoding operation and save it into the file specified by the FileName parameter. }
    DecodeBase64ToFile(Mask, FileName)
  except
    raise;
  end;
end;

{ TObjectDetectionParam }

function TObjectDetectionParam.Inputs(
  const FileName: string): TObjectDetectionParam;
begin
  Result := TObjectDetectionParam(Add('inputs', EncodeBase64(FileName)));
end;

function TObjectDetectionParam.Parameters(
  const Threshold: Double): TObjectDetectionParam;
begin
  Result := TObjectDetectionParam(Add('parameters', TJSONObject.Create.AddPair('threshold', Threshold)));
end;

{ TObjectDetectionItem }

destructor TObjectDetectionItem.Destroy;
begin
  if Assigned(FBox) then
    FBox.Free;
  inherited;
end;

function TObjectDetectionItem.ToRect: TRect;
begin
  Result := Rect(Box.FXmin, Box.FYmin, Box.Xmax, Box.Ymax);
end;

{ TObjectDetection }

destructor TObjectDetection.Destroy;
begin
  for var Item in FItems do
    Item.Free;
  inherited;
end;

{ TImageToImageParam }

function TImageToImageParam.Inputs(const FileName: string): TImageToImageParam;
begin
  Result := TImageToImageParam(Add('inputs', EncodeBase64(FileName)));
end;

function TImageToImageParam.Parameters(
  ParamProc: TProcRef<TImageToImageParameters>): TImageToImageParam;
begin
  if Assigned(ParamProc) then
    begin
      var Value := TImageToImageParameters.Create;
      ParamProc(Value);
      Result := TImageToImageParam(Add('parameters', Value.Detach));
    end
  else Result := Self;
end;

{ TImageToImage }

function TImageToImage.GetStream: TStream;
begin
  {--- Create a memory stream to write the decoded content. }
  Result := TMemoryStream.Create;
  try
    {--- Convert the base-64 string directly into the memory stream. }
    DecodeBase64ToStream(Image, Result)
  except
    Result.Free;
    raise;
  end;
end;

procedure TImageToImage.SaveToFile(const FileName: string);
begin
  try
    Self.FFileName := FileName;
    {--- Perform the decoding operation and save it into the file specified by the FileName parameter. }
    DecodeBase64ToFile(Image, FileName)
  except
    raise;
  end;
end;

{ TImageToImageParameters }

function TImageToImageParameters.GuidanceScale(
  const Value: Double): TImageToImageParameters;
begin
  Result := TImageToImageParameters(Add('guidance_scale', Value));
end;

function TImageToImageParameters.NegativePrompt(
  const Value: TArray<string>): TImageToImageParameters;
begin
  Result := TImageToImageParameters(Add('negative_prompt', Value));
end;

function TImageToImageParameters.NumInferenceSteps(
  const Value: Integer): TImageToImageParameters;
begin
  Result := TImageToImageParameters(Add('num_inference_steps', Value));
end;

function TImageToImageParameters.TargetSize(const Width,
  Height: Integer): TImageToImageParameters;
begin
  var Value := TTargetSizeParam.Create.Width(Width).Height(Height);
  Result := TImageToImageParameters(Add('target_size', Value.Detach));
end;

{ TTargetSizeParam }

function TTargetSizeParam.Height(const Value: Integer): TTargetSizeParam;
begin
  Result := TTargetSizeParam(Add('height', Value));
end;

function TTargetSizeParam.Width(const Value: Integer): TTargetSizeParam;
begin
  Result := TTargetSizeParam(Add('width', Value));
end;

end.

unit HuggingFace.Mask;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiHuggingFace
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, Rest.Json,
  REST.Json.Types, System.Net.URLClient, HuggingFace.API, HuggingFace.API.Params,
  HuggingFace.Async.Support;

type
  TMaskParameters = class(TJSONParam)
  public
    /// <summary>
    /// When passed, overrides the number of predictions to return.
    /// </summary>
    function TopK(const Value: Integer): TMaskParameters;
    /// <summary>
    /// When passed, the model will limit the scores to the passed targets instead of looking up in
    /// the whole vocabulary. If the provided targets are not in the model vocab, they will be tokenized
    /// and the first resulting token will be used (with a warning, and that might be slower).
    /// </summary>
    function Targets(const Value: TArray<string>): TMaskParameters;
  end;

  TMaskParam = class(TJSONModelParam)
  public
    /// <summary>
    /// The text with masked tokens.
    /// </summary>
    function Inputs(const Value: string): TMaskParam;
    /// <summary>
    /// Set mask parameters
    /// </summary>
    function Parameters(const TopK: Integer; const Targets: TArray<string> = []): TMaskParam; overload;
    /// <summary>
    /// Set mask parameters
    /// </summary>
    function Parameters(const Targets: TArray<string>): TMaskParam; overload;
  end;

  TMaskItem = class
  private
    FSequence: string;
    FScore: Double;
    FToken: Int64;
    [JsonNameAttribute('token_str')]
    FTokenStr: string;
  public
    /// <summary>
    /// The corresponding input with the mask token prediction.
    /// </summary>
    property Sequence: string read FSequence write FSequence;
    /// <summary>
    /// The corresponding probability.
    /// </summary>
    property Score: Double read FScore write FScore;
    /// <summary>
    /// The predicted token id (to replace the masked one).
    /// </summary>
    property Token: Int64 read FToken write FToken;
    /// <summary>
    /// The predicted token (to replace the masked one).
    /// </summary>
    property TokenStr: string read FTokenStr write FTokenStr;
  end;

  TMask = class
  private
    FItems: TArray<TMaskItem>;
  public
    /// <summary>
    /// Output is an array of objects.
    /// </summary>
    property Items: TArray<TMaskItem> read FItems write FItems;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TMask</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynMask</c> type extends the <c>TAsynParams&lt;TMask&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynMask = TAsynCallBack<TMask>;

  TMaskRoute = class(THuggingFaceAPIRoute)
    /// <summary>
    /// Mask filling is the task of predicting the right word (token to be precise) in the middle of a sequence.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TMaskParam</c> parameters.
    /// </param>
    /// <returns>
    /// A <c>TMask</c> object containing the Classification result.
    /// </returns>
    /// <remarks>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// var Value := HuggingFace.Image.FillCreate(
    ///     procedure (Params: TMaskParam)
    ///     begin
    ///       // Define parameters
    ///     end;
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function Fill(ParamProc: TProc<TMaskParam>): TMask; overload;
    /// <summary>
    /// Mask filling is the task of predicting the right word (token to be precise) in the middle of a sequence.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TMaskParam</c> parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns <c>TAsynMask</c> to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// <para>
    /// The <c>CallBacks</c> function is invoked when the operation completes, either successfully or with an error.
    /// </para>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// HuggingFace.Image.Fill(
    ///   procedure (Params: TMaskParam)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynMask
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TMask)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure Fill(ParamProc: TProc<TMaskParam>; CallBacks: TFunc<TAsynMask>); overload;
  end;

implementation

{ TMaskParam }

function TMaskParam.Inputs(const Value: string): TMaskParam;
begin
  Result := TMaskParam(Add('inputs', Value));
end;

function TMaskParam.Parameters(const TopK: Integer;
  const Targets: TArray<string>): TMaskParam;
begin
  var Value := TMaskParameters.Create.TopK(TopK);
  if Length(Targets) > 0 then
    Value := Value.Targets(Targets);
  Result := TMaskParam(Add('parameters', Value.Detach));
end;

function TMaskParam.Parameters(const Targets: TArray<string>): TMaskParam;
begin
  Result := TMaskParam(Add('parameters', TMaskParameters.Create.Targets(Targets).Detach));
end;

{ TMaskParameters }

function TMaskParameters.Targets(const Value: TArray<string>): TMaskParameters;
begin
  Result := TMaskParameters(Add('targets', Value));
end;

function TMaskParameters.TopK(const Value: Integer): TMaskParameters;
begin
  Result := TMaskParameters(Add('top_k', Value));
end;

{ TMask }

destructor TMask.Destroy;
begin
  for var Item in FItems do
    Item.Free;
  inherited;
end;

{ TMaskRoute }

function TMaskRoute.Fill(ParamProc: TProc<TMaskParam>): TMask;
begin
  Result := API.Post<TMask, TMaskParam>('models', ParamProc);
end;

procedure TMaskRoute.Fill(ParamProc: TProc<TMaskParam>;
  CallBacks: TFunc<TAsynMask>);
begin
  with TAsynCallBackExec<TAsynMask, TMask>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TMask
      begin
        Result := Self.Fill(ParamProc);
      end);
  finally
    Free;
  end;
end;

end.

unit HuggingFace.NetEncoding.Base64;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiHuggingFace
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.NetEncoding, System.Net.Mime, System.IOUtils;

  /// <summary>
  /// Decodes a Base64-encoded string and writes the resulting binary data to a specified file.
  /// </summary>
  /// <param name="Base64Str">The Base64-encoded string to decode.</param>
  /// <param name="FileName">The full path and name of the file where the decoded data will be written.</param>
  /// <exception cref="Exception">
  /// Thrown if the Base64 string cannot be decoded or if there is an error writing to the specified file.
  /// </exception>
  procedure DecodeBase64ToFile(const Base64Str: string; const FileName: string);
  /// <summary>
  /// Saves a byte array to a specified file.
  /// </summary>
  /// <param name="Data">The byte array to be written to the file.</param>
  /// <param name="FileName">The full path and name of the file where the data will be saved.</param>
  /// <exception cref="Exception">
  /// Thrown if the <paramref name="Data"/> array is empty, if the existing file cannot be deleted,
  /// or if there is an error writing to the specified file.
  /// </exception>
  /// <remarks>
  /// This procedure writes the provided byte array to the specified file.
  /// If the file already exists, it will be deleted before writing the new data.
  /// Ensure that the application has the necessary permissions to write to the specified location.
  /// Use this method when you need to persist binary data, such as saving decoded files or handling raw file content.
  /// </remarks>
  procedure SaveBytesToFile(const Data: TBytes; const FileName: string);
  /// <summary>
  /// Decodes a Base64-encoded string and writes the resulting binary data to the provided stream.
  /// </summary>
  /// <param name="Base64Str">The Base64-encoded string to decode.</param>
  /// <param name="Stream">The stream where the decoded binary data will be written. The stream should be writable.</param>
  /// <exception cref="Exception">
  /// Thrown if the Base64 string cannot be decoded or if there is an error writing to the provided stream.
  /// </exception>
  /// <remarks>
  /// After decoding, the stream's position is reset to the beginning.
  /// Ensure that the stream is properly managed and freed after use to avoid memory leaks.
  /// </remarks>
  procedure DecodeBase64ToStream(const Base64Str: string; const Stream: TStream);
  /// <summary>
  /// Encodes the content of a file into a Base64-encoded string.
  /// </summary>
  /// <param name="FileLocation">The full path to the file that will be encoded.</param>
  /// <returns>A Base64-encoded string representing the content of the file.</returns>
  /// <exception cref="Exception">Thrown if the specified file does not exist at the provided location.</exception>
  /// <remarks>
  /// This method reads the file from the specified location and converts it to a Base64 string.
  /// It uses different encoding methods depending on the version of the RTL.
  /// For RTL version 35.0 and later, it uses <c>TNetEncoding.Base64String.Encode</c>,
  /// and for earlier versions, it uses <c>TNetEncoding.Base64.Encode</c>.
  /// </remarks>
  function EncodeBase64(FileLocation : string): WideString; overload;
  /// <summary>
  /// Reads the contents of a file and returns them as a byte array.
  /// </summary>
  /// <param name="FilePath">The full path to the file to be read.</param>
  /// <returns>
  /// A <c>TBytes</c> array containing the binary data from the specified file.
  /// </returns>
  /// <exception cref="Exception">
  /// Thrown if the file does not exist at the specified <paramref name="FilePath"/> or if there is an error accessing the file.
  /// </exception>
  /// <remarks>
  /// This function opens the file located at <paramref name="FilePath"/> in read-only mode and reads its entire content into a byte array.
  /// Ensure that the file path is valid and that the application has the necessary permissions to access the file.
  /// Use this function when you need to manipulate or transmit the raw binary data of a file.
  /// </remarks>
  function FileToBytes(const FilePath: string): TBytes;
  /// <summary>
  /// Reads the entire content of the provided stream and returns it as a byte array.
  /// </summary>
  /// <param name="Stream">
  /// The input <c>TStream</c> from which to read the data. The stream must be readable and properly initialized.
  /// </param>
  /// <returns>
  /// A <c>TBytes</c> array containing the binary data read from the stream.
  /// </returns>
  /// <exception cref="Exception">
  /// Thrown if there is an error reading from the stream, such as insufficient permissions or an unexpected end of stream.
  /// </exception>
  /// <remarks>
  /// This function reads all bytes from the specified <paramref name="Stream"/> and returns them as a <c>TBytes</c> array.
  /// After reading, the stream's position is reset to the beginning to allow for subsequent read operations.
  /// Ensure that the stream is properly managed and disposed of after use to prevent memory leaks or resource locking.
  /// Use this method when you need to convert stream data into a byte array for further processing or storage.
  /// </remarks>
  function StreamToBytes(const Stream: TStream): TBytes;
  /// <summary>
  /// Retrieves the MIME type of the specified file based on its location.
  /// </summary>
  /// <param name="FileLocation">The full path to the file whose MIME type is to be resolved.</param>
  /// <returns>
  /// A string representing the MIME type of the file.
  /// If the file does not exist, an exception will be raised.
  /// </returns>
  /// <exception cref="Exception">
  /// Thrown if the specified file cannot be found at the provided location.
  /// </exception>
  /// <remarks>
  /// This method checks if the specified file exists and retrieves its MIME type
  /// using the <c>TMimeTypes.Default.GetFileInfo</c> method.
  /// Ensure the provided path is valid before calling this function.
  /// </remarks>
  function ResolveMimeType(const FileLocation: string): string;
  /// <summary>
  /// Retrieves the size of the specified file in bytes.
  /// </summary>
  /// <param name="FileLocation">
  /// The full path to the file whose size is to be determined.
  /// </param>
  /// <returns>
  /// An <c>Int64</c> value representing the file size in bytes.
  /// </returns>
  /// <exception cref="Exception">
  /// Raised if the specified file cannot be accessed or does not exist at the provided location.
  /// </exception>
  /// <remarks>
  /// This function verifies the existence of the specified file and, if accessible, retrieves its size
  /// using the <c>TFile.GetSize</c> method. Ensure that the file path is valid and accessible
  /// before calling this function.
  /// </remarks>
  function FileSize(const FileLocation: string): Int64;
  /// <summary>
  /// Provides the image data as a Base64-encoded string with a MIME type or as a direct URL.
  /// </summary>
  /// <param name="FileLocation">
  /// The full path to the image file on the local filesystem or a URL.
  /// </param>
  /// <returns>
  /// A string representing the image data:
  /// <para>
  /// - If <paramref name="FileLocation"/> is a local file path, it returns a data URI with a MIME type and Base64-encoded content.
  /// </para>
  /// <para>
  /// - If <paramref name="FileLocation"/> is a URL (starting with "http"), it returns the URL as-is.
  /// </para>
  /// </returns>
  /// <exception cref="Exception">
  /// Raised if the file does not exist at the provided local file path.
  /// </exception>
  /// <remarks>
  /// This function checks if <paramref name="FileLocation"/> is a URL by verifying if it starts with "http".
  /// If it is a URL, it returns it directly as the output.
  /// For local files, it verifies the file's existence, retrieves the MIME type, and encodes the content in Base64 format
  /// to create a data URI for embedding purposes. This data URI can then be used directly in HTML or other contexts where
  /// embedded image data is required.
  /// </remarks>
  function ImageDataProvider(FileLocation : string) : WideString;

  function BytesToBase64(const Value: TBytes): WideString;

  function BytesToString(const Value: TBytes): WideString;

  function EncodeBase64(const Value: TStream): string; overload;

implementation

procedure SaveBytesToFile(const Data: TBytes; const FileName: string);
begin
  if Length(Data) = 0 then
    raise Exception.Create('Empty GLB data.');
  if FileExists(FileName) then
    begin
      DeleteFile(FileName);
      Sleep(300);
    end;
  var MemStream := TMemoryStream.Create;
  try
    MemStream.WriteBuffer(Data[0], Length(Data));
    MemStream.Position := 0;
    MemStream.SaveToFile(FileName);
  finally
    MemStream.Free;
  end;
end;

procedure DecodeBase64ToFile(const Base64Str: string; const FileName: string);
begin
  {--- Convert Base64 string to byte array for input stream }
  var Bytes := TEncoding.UTF8.GetBytes(Base64Str);

  {--- Create the flows }
  var InputStream := TBytesStream.Create(Bytes);
  var OutputStream := TFileStream.Create(FileName, fmCreate);
  try
    {--- Decode using TNetEncoding.Base64.Decode (stream) }
    TNetEncoding.Base64.Decode(InputStream, OutputStream);
  finally
    InputStream.Free;
    OutputStream.Free;
  end;
end;

procedure DecodeBase64ToStream(const Base64Str: string; const Stream: TStream);
begin
  {--- Converts the base64 string directly into the memory stream }
  var InputStream := TBytesStream.Create(TEncoding.UTF8.GetBytes(Base64Str));
    try
      TNetEncoding.Base64.Decode(InputStream, Stream);
      Stream.Position := 0;
    finally
      InputStream.Free;
    end;
end;

function EncodeBase64(FileLocation : string): WideString;
begin
  if not FileExists(FileLocation) then
    raise Exception.CreateFmt('File not found : %s', [FileLocation]);

  var Stream := TMemoryStream.Create;
  var StreamOutput := TStringStream.Create('', TEncoding.UTF8);
  try
    Stream.LoadFromFile(FileLocation);
    Stream.Position := 0;
    {$IF RTLVersion >= 35.0}
    TNetEncoding.Base64String.Encode(Stream, StreamOutput);
    {$ELSE}
    TNetEncoding.Base64.Encode(Stream, StreamOutput);
    {$ENDIF}
    Result := StreamOutput.DataString;
  finally
    Stream.Free;
    StreamOutput.Free;
  end;
end;

function FileToBytes(const FilePath: string): TBytes;
begin
  if not FileExists(FilePath) then
    raise Exception.CreateFmt('File not found : %s', [FilePath]);

  var InputFile := TFileStream.Create(FilePath, fmOpenRead or fmShareDenyNone);
  try
    Result := StreamToBytes(InputFile);
  finally
    InputFile.Free;
  end;
end;

function StreamToBytes(const Stream: TStream): TBytes;
begin
  SetLength(Result, Stream.Size);
  Stream.ReadBuffer(Result[0], Stream.Size);
  Stream.Position := 0;
end;

function ResolveMimeType(const FileLocation: string): string;
begin
  if not FileExists(FileLocation) then
    raise Exception.CreateFmt('File not found: %s', [FileLocation]);

  var LKind: TMimeTypes.TKind;
  TMimeTypes.Default.GetFileInfo(FileLocation, Result, LKind);
end;

function FileSize(const FileLocation: string): Int64;
begin
  try
    FileSize := TFile.GetSize(FileLocation);
  except
    raise;
  end;
end;

function ImageDataProvider(FileLocation : string) : WideString;
begin
  if FileLocation.ToLower.StartsWith('http') then
    Result := FileLocation
  else
  if FileExists(FileLocation) then
    Result := Format('data:%s;base64,%s', [ResolveMimeType(FileLocation), EncodeBase64(FileLocation)])
  else
    raise Exception.CreateFmt('File not found : %s', [FileLocation]);
end;

function BytesToBase64(const Value: TBytes): WideString;
begin
  if Length(Value) = 0 then
    raise Exception.Create('No data recieved.');
  var MemStream := TMemoryStream.Create;
  try
    MemStream.WriteBuffer(Value[0], Length(Value));
    MemStream.Position := 0;
    Result := EncodeBase64(MemStream);
  finally
    MemStream.Free;
  end;
end;

function BytesToString(const Value: TBytes): WideString;
begin
  if Length(Value) = 0 then
    raise Exception.Create('No data recieved.');
  var MemStream := TMemoryStream.Create;
  try
    MemStream.WriteBuffer(Value[0], Length(Value));
    MemStream.Position := 0;
    var Reader := TStreamReader.Create(MemStream, TEncoding.UTF8);
    try
      Result := Reader.ReadToEnd;
    finally
      Reader.Free;
    end;
  finally
    MemStream.Free;
  end;
end;

function EncodeBase64(const Value: TStream): string;
begin
  var Stream := TMemoryStream.Create;
  var StreamOutput := TStringStream.Create('', TEncoding.UTF8);
  try
    Stream.LoadFromStream(Value);
    Stream.Position := 0;
    {$IF RTLVersion >= 35.0}
    TNetEncoding.Base64String.Encode(Stream, StreamOutput);
    {$ELSE}
    TNetEncoding.Base64.Encode(Stream, StreamOutput);
    {$ENDIF}
    Result := StreamOutput.DataString;
  finally
    Stream.Free;
    StreamOutput.Free;
  end;
end;

end.

unit HuggingFace;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiHuggingFace
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Net.URLClient, HuggingFace.API,
  HuggingFace.Hub.Search, HuggingFace.Audio, HuggingFace.Chat, HuggingFace.Embeddings,
  HuggingFace.Mask, HuggingFace.Image, HuggingFace.Text;

type
  /// <summary>
  /// The <c>IHuggingFace</c> interface provides access to the various features and routes of the HuggingFace AI API.
  /// It serves as a comprehensive framework for automating natural language processing, vision tasks, and data retrieval workflows.
  /// </summary>
  /// <remarks>
  /// This interface should be implemented by any class that wants to provide a structured way of accessing
  /// the HuggingFace AI services. It includes methods and properties for authenticating with an API key,
  /// configuring the base URL, and accessing different API routes.
  /// </remarks>
  IHuggingFace = interface
    ['{FC8BCBFB-B1AC-45D0-AEF1-43AE35CD9D0A}']
    function GetAPI: THuggingFaceAPI;
    procedure SetToken(const Value: string);
    function GetToken: string;
    function GetBaseUrl: string;
    procedure SetBaseUrl(const Value: string);
    function GetUseCache: Boolean;
    procedure SetUseCache(const Value: Boolean);
    function GetWaitForModel: Boolean;
    procedure SetWaitForModel(const Value: Boolean);

    function GetHubRoute: THubRoute;
    function GetAudioRoute: TAudioRoute;
    function GetChatRoute: TChatRoute;
    function GetEmbeddingsRoute: TEmbeddingsRoute;
    function GetMaskRoute: TMaskRoute;
    function GetImageRoute: TImageRoute;
    function GetTextRoute: TTextRoute;

    /// <summary>
    /// The cache layer on the inference API to speed up requests. Most models can use those
    /// results as they are deterministic (meaning the outputs will be the same anyway).
    /// </summary>
    /// <remarks>
    /// If you use a nondeterministic model, you can set this parameter to prevent
    /// the caching mechanism from being used, resulting in a real new query.
    /// </remarks>
    property UseCache: Boolean read GetUseCache write SetUseCache;
    /// <summary>
    /// If the model is not ready, wait for it instead of receiving 503. It limits the number
    /// of requests required to get your inference done.
    /// </summary>
    /// <remarks>
    /// It is advised to only set this flag
    /// to true after receiving a 503 error, as it will limit hanging in your application to
    /// known places.
    /// </remarks>
    property WaitForModel: Boolean read GetWaitForModel write SetWaitForModel;
    /// <summary>
    /// This class provides tools for analyzing and transcribing audio data with applications
    /// in classification and speech recognition.
    /// </summary>
    property Audio: TAudioRoute read GetAudioRoute;
    /// <summary>
    /// This class offers functionality for generating contextually appropriate responses within
    /// conversational frameworks, supporting multimodal capabilities integrate language and visual
    /// understanding.
    /// </summary>
    property Chat: TChatRoute read GetChatRoute;
    /// <summary>
    /// It focuses on converting text into numerical representations to support data modeling and analysis.
    /// </summary>
    property Embeddings:TEmbeddingsRoute read GetEmbeddingsRoute;
    /// <summary>
    /// Bringing together advanced features to classify images, detect objects, segment pixels, and work
    /// with vision-language models.
    /// </summary>
    property Image: TImageRoute read GetImageRoute;
    /// <summary>
    /// It provides tools to complete sentences by identifying missing words.
    /// </summary>
    property Mask: TMaskRoute read GetMaskRoute;
    /// <summary>
    /// This class provides advanced tools for processing, analyzing, and generating text,
    /// images, and structured data.
    /// </summary>
    property Text: TTextRoute read GetTextRoute;
    /// <summary>
    /// This class provides API access to manage the hub, including retrieving and filtering model lists
    /// and accessing detailed model information.
    /// </summary>
    /// <remarks>
    /// Can only be used with an instance that has initialized the hub.
    /// <para>
    /// e.g TheHub := THuggingFaceFactory.CreateInstance('my_key', True);
    /// </para>
    /// </remarks>
    property Hub: THubRoute read GetHubRoute;
    /// <summary>
    /// the main API object used for making requests.
    /// </summary>
    /// <returns>
    /// An instance of THuggingFaceAPI for making API calls.
    /// </returns>
    property API: THuggingFaceAPI read GetAPI;
    /// <summary>
    /// Sets or retrieves the API token for authentication.
    /// </summary>
    property Token: string read GetToken write SetToken;
    /// <summary>
    /// Sets or retrieves the base URL for API requests.
    /// Default is https://api.HuggingFace.com/v1
    /// </summary>
    property BaseURL: string read GetBaseUrl write SetBaseUrl;
  end;

  /// <summary>
  /// The <c>THuggingFaceFactory</c> class is responsible for creating instances of
  /// the <see cref="IHuggingFace"/> interface. It provides a factory method to instantiate
  /// the interface with a provided API token and optional header configuration.
  /// </summary>
  /// <remarks>
  /// This class provides a convenient way to initialize the <see cref="IHuggingFace"/> interface
  /// by encapsulating the necessary configuration details, such as the API token and header options.
  /// By using the factory method, users can quickly create instances of <see cref="IHuggingFace"/> without
  /// manually setting up the implementation details.
  /// </remarks>
  THuggingFaceFactory = class
    /// <summary>
    /// Creates an instance of the <see cref="IHuggingFace"/> interface with the specified API token
    /// and optional header configuration.
    /// </summary>
    /// <param name="AToken">
    /// The API token as a string, required for authenticating with HuggingFace API services.
    /// </param>
    /// <param name="Option">
    /// An optional header configuration of type <see cref="THeaderOption"/> to customize the request headers.
    /// The default value is <c>THeaderOption.none</c>.
    /// </param>
    /// <returns>
    /// An instance of <see cref="IHuggingFace"/> initialized with the provided API token and header option.
    /// </returns>
    /// <remarks>
    /// Code example
    /// <code>
    /// var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// </code>
    /// WARNING : Please take care to adjust the SCOPE of the <c>HuggingFaceCloud</c> interface in you application.
    /// </remarks>
    class function CreateInstance(const AToken: string; const IsHub: Boolean = False): IHuggingFace;
  end;

  /// <summary>
  /// The THuggingFace class provides access to the various features and routes of the HuggingFace AI API.
  /// It serves as a comprehensive framework for automating natural language processing, vision tasks, and data retrieval workflows.
  /// </summary>
  /// <remarks>
  /// This class should be implemented by any class that wants to provide a structured way of accessing
  /// the HuggingFace AI services. It includes methods and properties for authenticating with an API key,
  /// configuring the base URL, and accessing different API routes.
  /// <seealso cref="THuggingFace"/>
  /// </remarks>
  THuggingFace = class(TInterfacedObject, IHuggingFace)
  strict private

  private
    FAPI: THuggingFaceAPI;
    FAudioRoute: TAudioRoute;
    FHubRoute: THubRoute;
    FChatRoute: TChatRoute;
    FEmbeddingsRoute: TEmbeddingsRoute;
    FMaskRoute: TMaskRoute;
    FImageRoute: TImageRoute;
    FTextRoute: TTextRoute;

    function GetAPI: THuggingFaceAPI;
    function GetToken: string;
    procedure SetToken(const Value: string);
    function GetBaseUrl: string;
    procedure SetBaseUrl(const Value: string);
    function GetUseCache: Boolean;
    procedure SetUseCache(const Value: Boolean);
    function GetWaitForModel: Boolean;
    procedure SetWaitForModel(const Value: Boolean);

    function GetHubRoute: THubRoute;
    function GetAudioRoute: TAudioRoute;
    function GetChatRoute: TChatRoute;
    function GetEmbeddingsRoute: TEmbeddingsRoute;
    function GetMaskRoute: TMaskRoute;
    function GetImageRoute: TImageRoute;
    function GetTextRoute: TTextRoute;

  public
    /// <summary>
    /// The cache layer on the inference API to speed up requests. Most models can use those
    /// results as they are deterministic (meaning the outputs will be the same anyway).
    /// </summary>
    /// <remarks>
    /// If you use a nondeterministic model, you can set this parameter to prevent
    /// the caching mechanism from being used, resulting in a real new query.
    /// </remarks>
    property UseCache: Boolean read GetUseCache write SetUseCache;
    /// <summary>
    /// If the model is not ready, wait for it instead of receiving 503. It limits the number
    /// of requests required to get your inference done.
    /// </summary>
    /// <remarks>
    /// It is advised to only set this flag
    /// to true after receiving a 503 error, as it will limit hanging in your application to
    /// known places.
    /// </remarks>
    property WaitForModel: Boolean read GetWaitForModel write SetWaitForModel;
    /// <summary>
    /// This class provides tools for analyzing and transcribing audio data with applications
    /// in classification and speech recognition.
    /// </summary>
    property Audio: TAudioRoute read GetAudioRoute;
    /// <summary>
    /// This class offers functionality for generating contextually appropriate responses within
    /// conversational frameworks, supporting multimodal capabilities integrate language and visual
    /// understanding.
    /// </summary>
    property Chat: TChatRoute read GetChatRoute;
    /// <summary>
    /// It focuses on converting text into numerical representations to support data modeling and analysis.
    /// </summary>
    property Embeddings:TEmbeddingsRoute read GetEmbeddingsRoute;
    /// <summary>
    /// Bringing together advanced features to classify images, detect objects, segment pixels, and work
    /// with vision-language models.
    /// </summary>
    property Image: TImageRoute read GetImageRoute;
    /// <summary>
    /// It provides tools to complete sentences by identifying missing words.
    /// </summary>
    property Mask: TMaskRoute read GetMaskRoute;
    /// <summary>
    /// This class provides advanced tools for processing, analyzing, and generating text,
    /// images, and structured data.
    /// </summary>
    property Text: TTextRoute read GetTextRoute;
    /// <summary>
    /// This class provides API access to manage the hub, including retrieving and filtering model lists
    /// and accessing detailed model information.
    /// </summary>
    /// <remarks>
    /// Can only be used with an instance that has initialized the hub.
    /// <para>
    /// e.g TheHub := THuggingFaceFactory.CreateInstance('my_key', True);
    /// </para>
    /// </remarks>
    property Hub: THubRoute read GetHubRoute;
    /// <summary>
    /// the main API object used for making requests.
    /// </summary>
    /// <returns>
    /// An instance of THuggingFaceAPI for making API calls.
    /// </returns>
    /// <summary>
    /// the main API object used for making requests.
    /// </summary>
    /// <returns>
    /// An instance of THuggingFaceAPI for making API calls.
    /// </returns>
    property API: THuggingFaceAPI read GetAPI;
    /// <summary>
    /// Sets or retrieves the API token for authentication.
    /// </summary>
    /// <param name="Value">
    /// The API token as a string.
    /// </param>
    /// <returns>
    /// The current API token.
    /// </returns>
    property Token: string read GetToken write SetToken;
    /// <summary>
    /// Sets or retrieves the base URL for API requests.
    /// Default is https://api.stability.ai
    /// </summary>
    /// <param name="Value">
    /// The base URL as a string.
    /// </param>
    /// <returns>
    /// The current base URL.
    /// </returns>
    property BaseURL: string read GetBaseUrl write SetBaseUrl;

  public
    /// <summary>
    /// Initializes a new instance of the <see cref="THuggingFace"/> class with optional header configuration.
    /// </summary>
    /// <param name="Option">
    /// An optional parameter of type <see cref="THeaderOption"/> to configure the request headers.
    /// The default value is <c>THeaderOption.none</c>.
    /// </param>
    /// <remarks>
    /// This constructor is typically used when no API token is provided initially.
    /// The token can be set later via the <see cref="Token"/> property.
    /// </remarks>
    constructor Create; overload;
    /// <summary>
    /// Initializes a new instance of the <see cref="THuggingFace"/> class with the provided API token and optional header configuration.
    /// </summary>
    /// <param name="AToken">
    /// The API token as a string, required for authenticating with the HuggingFace AI API.
    /// </param>
    /// <param name="Option">
    /// An optional parameter of type <see cref="THeaderOption"/> to configure the request headers.
    /// The default value is <c>THeaderOption.none</c>.
    /// </param>
    /// <remarks>
    /// This constructor allows the user to specify an API token at the time of initialization.
    /// </remarks>
    constructor Create(const AToken: string); overload;
    /// <summary>
    /// Releases all resources used by the current instance of the <see cref="THuggingFace"/> class.
    /// </summary>
    /// <remarks>
    /// This method is called to clean up any resources before the object is destroyed.
    /// It overrides the base <see cref="TInterfacedObject.Destroy"/> method.
    /// </remarks>
    destructor Destroy; override;
  end;

implementation

{ THuggingFace }

constructor THuggingFace.Create;
begin
  inherited Create;
  FAPI := THuggingFaceAPI.Create;
end;

constructor THuggingFace.Create(const AToken: string);
begin
  Create;
  Token := AToken;
end;

destructor THuggingFace.Destroy;
begin
  FAPI.Free;
  FHubRoute.Free;
  FAudioRoute.Free;
  FChatRoute.Free;
  FEmbeddingsRoute.Free;
  FMaskRoute.Free;
  FImageRoute.Free;
  FTextRoute.Free;
  inherited;
end;

function THuggingFace.GetAPI: THuggingFaceAPI;
begin
  Result := FAPI;
end;

function THuggingFace.GetAudioRoute: TAudioRoute;
begin
  if not Assigned(FAudioRoute) then
    FAudioRoute := TAUdioRoute.CreateRoute(API);
  Result := FAudioRoute;
end;

function THuggingFace.GetBaseUrl: string;
begin
  Result := FAPI.BaseURL;
end;

function THuggingFace.GetChatRoute: TChatRoute;
begin
  if not Assigned(FChatRoute) then
    FChatRoute := TChatRoute.CreateRoute(API);
  Result := FChatRoute;
end;

function THuggingFace.GetEmbeddingsRoute: TEmbeddingsRoute;
begin
  if not Assigned(FEmbeddingsRoute) then
    FEmbeddingsRoute := TEmbeddingsRoute.CreateRoute(API);
  Result := FEmbeddingsRoute;
end;

function THuggingFace.GetHubRoute: THubRoute;
begin
  if not Assigned(FHubRoute) then
    FHubRoute := THubRoute.CreateRoute(API);
  Result := FHubRoute;
end;

function THuggingFace.GetImageRoute: TImageRoute;
begin
  if not Assigned(FImageRoute) then
    FImageRoute := TImageRoute.CreateRoute(API);
  Result := FImageRoute;
end;

function THuggingFace.GetMaskRoute: TMaskRoute;
begin
  if not Assigned(FMaskRoute) then
    FMaskRoute := TMaskRoute.CreateRoute(API);
  Result := FMaskRoute;
end;

function THuggingFace.GetTextRoute: TTextRoute;
begin
  if not Assigned(FTextRoute) then
    FTextRoute := TTextRoute.CreateRoute(API);
  Result := FTextRoute;
end;

function THuggingFace.GetToken: string;
begin
  Result := FAPI.Token;
end;

function THuggingFace.GetUseCache: Boolean;
begin
  Result := API.UseCache;
end;

function THuggingFace.GetWaitForModel: Boolean;
begin
  Result := API.WaitForModel;
end;

procedure THuggingFace.SetBaseUrl(const Value: string);
begin
  FAPI.BaseURL := Value;
end;

procedure THuggingFace.SetToken(const Value: string);
begin
  FAPI.Token := Value;
end;

procedure THuggingFace.SetUseCache(const Value: Boolean);
begin
  API.UseCache := Value;
end;

procedure THuggingFace.SetWaitForModel(const Value: Boolean);
begin
  API.WaitForModel := Value;
end;

{ THuggingFaceFactory }

class function THuggingFaceFactory.CreateInstance(const AToken: string; const IsHub: Boolean): IHuggingFace;
begin
  Result := THuggingFace.Create(AToken);
  if IsHub then
    Result.API.BaseUrl := 'https://huggingface.co';
end;

end.

unit HuggingFace.Schema;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiHuggingFace
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, REST.Json.Types,
  HuggingFace.API.Params, HuggingFace.Types;

type
  TSchemaParams = class;

  /// <summary>
  /// Provides helper methods for creating property items in OpenAPI schema definitions.
  /// </summary>
  /// <remarks>
  /// This record simplifies the creation of property entries when building schema objects,
  /// particularly for object properties in OpenAPI specifications.
  /// </remarks>
  TPropertyItem = record
  public
    /// <summary>
    /// Creates a JSON pair representing a property in a schema object.
    /// </summary>
    /// <param name="Key">The name of the property.</param>
    /// <param name="Value">The data type of the property as a <c>TSchemaType</c>.</param>
    /// <returns>A <c>TJSONPair</c> representing the property key-value pair.</returns>
    /// <remarks>
    /// This method facilitates the addition of properties to schema objects by creating
    /// a JSON pair with the specified key and data type.
    /// </remarks>
    class function Add(Key: string; Value: TSchemaType): TJSONPair; static;
  end;

  /// <summary>
  /// Represents the Schema Object in OpenAPI, enabling the definition of input and output data types.
  /// These types can be objects, primitives, or arrays. This class provides methods to build and
  /// configure schema definitions as per the OpenAPI 3.0 Specification.
  /// </summary>
  /// <remarks>
  /// The Schema Object allows the definition of input and output data types in the OpenAPI Specification.
  /// This class provides a fluent interface to construct schema definitions programmatically.
  /// </remarks>
  TSchemaParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the data type of the schema.
    /// </summary>
    /// <param name="Value">The data type to assign to the schema, specified as a <c>TSchemaType</c> value.</param>
    /// <returns>The current <c>TSchemaParams</c> instance to allow for method chaining.</returns>
    /// <remarks>
    /// The <c>type</c> keyword is required in the Schema Object to define the data type.
    /// Valid types include <c>string</c>, <c>number</c>, <c>integer</c>, <c>boolean</c>, <c>array</c>, and <c>object</c>.
    /// </remarks>
    function &Type(const Value: TSchemaType): TSchemaParams;
    /// <summary>
    /// Specifies the format of the data type.
    /// </summary>
    /// <param name="Value">The format of the data type, as a string.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>format</c> keyword is an optional modifier to provide more fine-grained data type information.
    /// Common formats include <c>int32</c>, <c>int64</c> for <c>integer</c> types; <c>float</c>, <c>double</c>
    /// for <c>number</c> types; and <c>byte</c>, <c>binary</c>, <c>date</c>, <c>date-time</c>, <c>password</c> for <c>string</c> types.
    /// </remarks>
    function Format(const Value: string): TSchemaParams;
    /// <summary>
    /// Adds a description to the schema.
    /// </summary>
    /// <param name="Value">A brief description of the schema. Supports Markdown for formatting.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>description</c> keyword provides a description of the schema and can include examples of use.
    /// This field supports Markdown syntax for rich text representation.
    /// </remarks>
    function Description(const Value: string): TSchemaParams;
    /// <summary>
    /// Specifies whether the schema's value can be null.
    /// </summary>
    /// <param name="Value">A boolean indicating if the schema allows null values.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>nullable</c> keyword is a boolean property that indicates if the value of the schema can be null.
    /// By default, this is false.
    /// </remarks>
    function Nullable(const Value: Boolean): TSchemaParams;
    /// <summary>
    /// Specifies an enumeration of possible values.
    /// </summary>
    /// <param name="Value">An array of string values that the schema can take.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>enum</c> keyword restricts the value of the schema to a fixed set of values.
    /// The schema's type must be <c>string</c> when using enum.
    /// </remarks>
    function Enum(const Value: TArray<string>): TSchemaParams;
    /// <summary>
    /// Specifies the maximum number of items allowed in an array schema.
    /// </summary>
    /// <param name="Value">The maximum number of items as a string.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>maxItems</c> keyword applies to schemas of type <c>array</c> and restricts the maximum number
    /// of items the array can contain.
    /// </remarks>
    function MaxItems(const Value: string): TSchemaParams;
    /// <summary>
    /// Specifies the minimum number of items required in an array schema.
    /// </summary>
    /// <param name="Value">The minimum number of items as a string.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>minItems</c> keyword applies to schemas of type <c>array</c> and defines the minimum number
    /// of items the array must contain.
    /// </remarks>
    function MinItems(const Value: string): TSchemaParams;
    /// <summary>
    /// Adds a property to an object schema.
    /// </summary>
    /// <param name="Key">The name of the property.</param>
    /// <param name="Value">A <c>TSchemaParams</c> instance defining the property's schema.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>properties</c> keyword is used to define the properties of an object schema.
    /// Each property is a key-value pair where the key is the property name and the value is a schema defining the property.
    /// </remarks>
    function Properties(const Key: string; const Value: TSchemaParams): TSchemaParams; overload;
    /// <summary>
    /// Adds a property to an object schema using a parameterized procedure to configure the property's schema.
    /// </summary>
    /// <param name="Key">The name of the property.</param>
    /// <param name="ParamProc">A procedure that takes a <c>TSchemaParams</c> instance to configure the property's schema.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// This overload allows you to define the property's schema inline using a procedural configuration.
    /// </remarks>
    function Properties(const Key: string; const ParamProc: TProcRef<TSchemaParams>): TSchemaParams; overload;
    /// <summary>
    /// Adds multiple properties to an object schema.
    /// </summary>
    /// <param name="Value">An array of <c>TJSONPair</c> instances representing the properties.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// This overload allows adding multiple properties at once to the object schema.
    /// </remarks>
    function Properties(const Value: TArray<TJSONPair>): TSchemaParams; overload;
    /// <summary>
    /// Specifies which properties are required in an object schema.
    /// </summary>
    /// <param name="Value">An array of property names that are required.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>required</c> keyword lists the property names that must be included when an object instance
    /// is validated against the schema.
    /// </remarks>
    function Required(const Value: TArray<string>): TSchemaParams;
    /// <summary>
    /// Specifies the schema of the items in an array schema.
    /// </summary>
    /// <param name="Value">A <c>TSchemaParams</c> instance defining the schema of the array items.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>items</c> keyword is used in array schemas to define the schema of each item in the array.
    /// </remarks>
    function Items(const Value: TSchemaParams): TSchemaParams; overload;
    /// <summary>
    /// Specifies the schema of the items in an array schema using a parameterized procedure.
    /// </summary>
    /// <param name="ParamProc">A procedure that configures a <c>TSchemaParams</c> instance to define the array items' schema.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// This overload allows you to define the items' schema inline using a procedural configuration.
    /// </remarks>
    function Items(const ParamProc: TProcRef<TSchemaParams>): TSchemaParams; overload;
    /// <summary>
    /// Creates a new instance of <c>TSchemaParams</c>.
    /// </summary>
    /// <returns>A new <c>TSchemaParams</c> instance.</returns>
    class function New: TSchemaParams; overload;
    /// <summary>
    /// Creates and configures a new instance of <c>TSchemaParams</c> using a parameterized procedure.
    /// </summary>
    /// <param name="ParamProc">A procedure that configures the new <c>TSchemaParams</c> instance.</param>
    /// <returns>A new <c>TSchemaParams</c> instance.</returns>
    /// <remarks>
    /// This overload allows you to create and configure the instance inline.
    /// </remarks>
    class function New(const ParamProc: TProcRef<TSchemaParams>): TSchemaParams; overload;
  end;

implementation

uses
  System.StrUtils, System.Rtti, Rest.Json;

{ TSchemaParams }

function TSchemaParams.Description(const Value: string): TSchemaParams;
begin
  Result := TSchemaParams(Add('description', Value));
end;

function TSchemaParams.Enum(const Value: TArray<string>): TSchemaParams;
begin
  Result := TSchemaParams(Add('enum', Value));
end;

function TSchemaParams.Format(const Value: string): TSchemaParams;
begin
  Result := TSchemaParams(Add('format', Value));
end;

function TSchemaParams.Items(
  const ParamProc: TProcRef<TSchemaParams>): TSchemaParams;
begin
  if Assigned(ParamProc) then
    begin
      var Value := TSchemaParams.Create;
      ParamProc(Value);
      Result := Items(Value);
    end
  else Result := Self;
end;

function TSchemaParams.Items(const Value: TSchemaParams): TSchemaParams;
begin
  Result := TSchemaParams(Add('items', Value.Detach));
end;

function TSchemaParams.MaxItems(const Value: string): TSchemaParams;
begin
  Result := TSchemaParams(Add('maxItems', Value));
end;

function TSchemaParams.MinItems(const Value: string): TSchemaParams;
begin
  Result := TSchemaParams(Add('minItems', Value));
end;

class function TSchemaParams.New: TSchemaParams;
begin
  Result := TSchemaParams.Create;
end;

class function TSchemaParams.New(
  const ParamProc: TProcRef<TSchemaParams>): TSchemaParams;
begin
  Result := TSchemaParams.Create;
  if Assigned(ParamProc) then
    begin
      ParamProc(Result);
    end;
end;

function TSchemaParams.Nullable(const Value: Boolean): TSchemaParams;
begin
  Result := TSchemaParams(Add('nullable', Value.ToString));
end;

function TSchemaParams.Properties(
  const Value: TArray<TJSONPair>): TSchemaParams;
begin
  var JSONValue := TJSONObject.Create;
  for var Item in Value do
    begin
      JSONValue.AddPair(Item);
    end;
  Result := TSchemaParams(Add('properties', JSONValue));
end;

function TSchemaParams.Properties(const Key: string;
  const ParamProc: TProcRef<TSchemaParams>): TSchemaParams;
begin
  if Assigned(ParamProc) then
    begin
      var Value := TSchemaParams.Create;
      ParamProc(Value);
      Result := Properties(Key, Value);
    end
  else Result := Self;
end;

function TSchemaParams.Properties(const Key: string;
  const Value: TSchemaParams): TSchemaParams;
begin
  Result := TSchemaParams(Add(Key, Value.Detach));
end;

function TSchemaParams.Required(const Value: TArray<string>): TSchemaParams;
begin
  Result := TSchemaParams(Add('required', Value));
end;

function TSchemaParams.&Type(const Value: TSchemaType): TSchemaParams;
begin
  Result := TSchemaParams(Add('type', Value.ToString));
end;

{ TPropertyItem }

class function TPropertyItem.Add(Key: string; Value: TSchemaType): TJSONPair;
begin
  Result := TJSONPair.Create(Key, Value.ToString);
end;

end.

unit HuggingFace.Text;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiHuggingFace
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, Rest.Json,
  REST.Json.Types, System.Net.URLClient, HuggingFace.API, HuggingFace.API.Params,
  HuggingFace.Async.Support, HuggingFace.Types, HuggingFace.Chat, HuggingFace.Schema;

type
  {$REGION 'Question Answering'}

  TQuestionAnsweringInputs = class(TJSONParam)
  public
    /// <summary>
    /// The context to be used for answering the question.
    /// </summary>
    function Context(const Value: string): TQuestionAnsweringInputs;
    /// <summary>
    /// The question to be answered.
    /// </summary>
    function Question(const Value: string): TQuestionAnsweringInputs;
  end;

  TQuestionAnsweringParameters = class(TJSONParam)
  public
    /// <summary>
    /// The number of answers to return (will be chosen by order of likelihood).
    /// </summary>
    /// <remarks>
    /// Note that we return less than topk answers if there are not enough options available within
    /// the context.
    /// </remarks>
    function TopK(const Value: Integer): TQuestionAnsweringParameters;
    /// <summary>
    /// If the context is too long to fit with the question for the model, it will be split in several
    /// chunks with some overlap. This argument controls the size of that overlap.
    /// </summary>
    function DocStride(const Value: Integer): TQuestionAnsweringParameters;
    /// <summary>
    /// The maximum length of predicted answers (e.g., only answers with a shorter length are considered).
    /// </summary>
    function MaxAnswerLen(const Value: Integer): TQuestionAnsweringParameters;
    /// <summary>
    /// The maximum length of the total sentence (context + question) in tokens of each chunk passed to
    /// the model. The context will be split in several chunks (using docStride as overlap) if needed.
    /// </summary>
    function MaxSeqLen(const Value: Integer): TQuestionAnsweringParameters;
    /// <summary>
    /// The maximum length of the question after tokenization. It will be truncated if needed.
    /// </summary>
    function MaxQuestionLen(const Value: Integer): TQuestionAnsweringParameters;
    /// <summary>
    /// Whether to accept impossible as an answer.
    /// </summary>
    function HandleImpossibleAnswer(const Value: Boolean): TQuestionAnsweringParameters;
    /// <summary>
    /// Attempts to align the answer to real words. Improves quality on space separated languages.
    /// Might hurt on non-space-separated languages (like Japanese or Chinese)
    /// </summary>
    function AlignToWords(const Value: Boolean): TQuestionAnsweringParameters;
  end;

  TQuestionAnsweringParam = class(TJSONModelParam)
  public
    /// <summary>
    /// One (context, question) pair to answer.
    /// </summary>
    function Inputs(const Question: string): TQuestionAnsweringParam; overload;
    /// <summary>
    /// One (context, question) pair to answer.
    /// </summary>
    function Inputs(const Question, Context: string): TQuestionAnsweringParam; overload;
    /// <summary>
    /// Define generation parameters
    /// </summary>
    function Parameters(ParamProc: TProcRef<TQuestionAnsweringParameters>): TQuestionAnsweringParam;
  end;

  TQuestionAnsweringItem = class
  private
    FAnswer: string;
    FScore: Double;
    FStart: Integer;
    FEnd: Integer;
  public
    /// <summary>
    /// The answer to the question.
    /// </summary>
    property Answer: string read FAnswer write FAnswer;
    /// <summary>
    /// The probability associated to the answer.
    /// </summary>
    property Score: Double read FScore write FScore;
    /// <summary>
    /// The character position in the input where the answer begins.
    /// </summary>
    property Start: Integer read FStart write FStart;
    /// <summary>
    /// The character position in the input where the answer ends.
    /// </summary>
    property &End: Integer read FEnd write FEnd;
  end;

  TQuestionAnswering = class(TQuestionAnsweringItem)
  private
    FItems: TArray<TQuestionAnsweringItem>;
  public
    /// <summary>
    /// If output is an array of objects.
    /// </summary>
    property Items: TArray<TQuestionAnsweringItem> read FItems write FItems;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TQuestionAnswering</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynQuestionAnswering</c> type extends the <c>TAsynParams&lt;TQuestionAnswering&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynQuestionAnswering = TAsynCallBack<TQuestionAnswering>;

  {$ENDREGION}

  {$REGION 'Summarization'}

  TSummarizationParameters = class(TJSONParam)
  public
    /// <summary>
    /// Whether to clean up the potential extra spaces in the text output.
    /// </summary>
    function CleanUpTokenizationSpaces(const Value: Boolean): TSummarizationParameters;
    /// <summary>
    /// Possible values: do_not_truncate, longest_first, only_first, only_second.
    /// </summary>
    function Truncation(const Value: TTextTruncationType): TSummarizationParameters;
    /// <summary>
    /// Additional parametrization of the text generation algorithm.
    /// </summary>
    function GenerateParameters(const Value: TJSONObject): TSummarizationParameters;
  end;

  TSummarizationParam = class(TJSONModelParam)
  public
    /// <summary>
    /// The input text to summarize.
    /// </summary>
    function Inputs(const Value: string): TSummarizationParam;
    /// <summary>
    /// Define generation parameters
    /// </summary>
    function Parameters(ParamProc: TProcRef<TSummarizationParameters>): TSummarizationParam;
  end;

  TSummarizationItem = class
  private
    [JsonNameAttribute('summary_text')]
    FSummaryText: string;
  public
    /// <summary>
    /// The summarized text.
    /// </summary>
    property SummaryText: string read FSummaryText write FSummaryText;
  end;

  TSummarization = class
  private
    FItems: TArray<TSummarizationItem>;
  public
    property Items: TArray<TSummarizationItem> read FItems write FItems;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TSummarization</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynSummarization</c> type extends the <c>TAsynParams&lt;TSummarization&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynSummarization = TAsynCallBack<TSummarization>;

  {$ENDREGION}

  {$REGION 'Table Question Answering'}

  TRow = record
  private
    FFieldName: string;
    FValues: TArray<string>;
  public
    /// <summary>
    /// Row name of the table
    /// </summary>
    property FieldName: string read FFieldName write FFieldName;
    /// <summary>
    /// Row values of the table
    /// </summary>
    property Values: TArray<string> read FValues write FValues;
    class function Create(const FieldName: string; Values: TArray<string>): TRow; static;
  end;

  TTableQAInputs = class(TJSONParam)
  public
    /// <summary>
    /// The table to serve as context for the questions.
    /// </summary>
    function Table(const Value: TArray<TRow>): TTableQAInputs;
    /// <summary>
    /// The question to be answered about the table
    /// </summary>
    function Query(const Value: string): TTableQAInputs;
  end;

  TTableQAParameters = class(TJSONParam)
  public
    /// <summary>
    /// Possible values: do_not_pad, longest, max_length.
    /// </summary>
    function Padding(const Value: TPaddingType): TTableQAParameters;
    /// <summary>
    /// Whether to do inference sequentially or as a batch. Batching is faster, but models like SQA
    /// require the inference to be done sequentially to extract relations within sequences, given
    /// their conversational nature.
    /// </summary>
    function Sequential(const Value: Boolean): TTableQAParameters;
    /// <summary>
    /// Activates and controls truncation.
    /// </summary>
    function Truncation(const Value: Boolean): TTableQAParameters;
  end;

  TTableQAParam = class(TJSONModelParam)
  public
    /// <summary>
    /// One (table, question) pair to answer.
    /// </summary>
    function Inputs(const Query: string; const Table: TArray<TRow>): TTableQAParam;
    /// <summary>
    /// Define generation parameters
    /// </summary>
    function Parameters(ParamProc: TProcRef<TTableQAParameters>): TTableQAParam;
  end;

  TTableQA = class
  private
    FAnswer: string;
    FCoordinates: TCoordinate;
    FCells: TArray<string>;
    FAggregator: string;
  public
    /// <summary>
    /// The answer of the question given the table. If there is an aggregator, the answer will
    /// be preceded by AGGREGATOR >.
    /// </summary>
    property Answer: string read FAnswer write FAnswer;
    /// <summary>
    /// Coordinates of the cells of the answers.
    /// </summary>
    property Coordinates: TCoordinate read FCoordinates write FCoordinates;
    /// <summary>
    /// List of strings made up of the answer cell values.
    /// </summary>
    property Cells: TArray<string> read FCells write FCells;
    /// <summary>
    /// If the model has an aggregator, this returns the aggregator.
    /// </summary>
    property Aggregator: string read FAggregator write FAggregator;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TTableQA</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynTableQA</c> type extends the <c>TAsynParams&lt;TTableQA&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynTableQA = TAsynCallBack<TTableQA>;

  {$ENDREGION}

  {$REGION 'Text Classification'}

  TTextClassificationParameters = class(TJSONParam)
  public
    /// <summary>
    /// Possible values: sigmoid, softmax, none.
    /// </summary>
    function FunctionToApply(const Value: TFunctionClassification): TTextClassificationParameters;
    /// <summary>
    /// When specified, limits the output to the top K most probable classes.
    /// </summary>
    function TopK(const Value: Integer): TTextClassificationParameters;
  end;

  TTextClassificationParam = class(TJSONModelParam)
  public
    /// <summary>
    /// The text to classify.
    /// </summary>
    function Inputs(const Value: string): TTextClassificationParam;
    /// <summary>
    /// Define generation parameters
    /// </summary>
    function Parameters(const FunctionToApply: TFunctionClassification; const TopK: Integer = -1): TTextClassificationParam; overload;
    /// <summary>
    /// Define generation parameters
    /// </summary>
    function Parameters(const TopK: Integer): TTextClassificationParam; overload;
  end;

  TTextClassificationItem = class
  private
    FLabel: string;
    FScore: Double;
  public
    /// <summary>
    /// The predicted class label.
    /// </summary>
    property &Label: string read FLabel write FLabel;
    /// <summary>
    /// The corresponding probability.
    /// </summary>
    property Score: Double read FScore write FScore;
  end;

  TTextClassificationArray = class
  private
    FItems: TArray<TTextClassificationItem>;
  public
    property Items: TArray<TTextClassificationItem> read FItems write FItems;
    destructor Destroy; override;
  end;

  TTextClassification = class
  private
    FItems: TArray<TTextClassificationArray>;
  public
    property Items: TArray<TTextClassificationArray> read FItems write FItems;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TTextClassification</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynTextClassification</c> type extends the <c>TAsynParams&lt;TTextClassification&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynTextClassification = TAsynCallBack<TTextClassification>;

  {$ENDREGION}

  {$REGION 'Text to Image'}

  TTargetSizeParam = class(TJSONParam)
  public
    /// <summary>
    /// The width in pixel
    /// </summary>
    function Width(const Value: Integer): TTargetSizeParam;
    /// <summary>
    /// The height in pixel
    /// </summary>
    function Height(const Value: Integer): TTargetSizeParam;
  end;

  TTextToImageParameters = class(TJSONParam)
  public
    /// <summary>
    /// A higher guidance scale value encourages the model to generate images closely linked to
    /// the text prompt, but values too high may cause saturation and other artifacts.
    /// </summary>
    function GuidanceScale(const Value: Double): TTextToImageParameters;
    /// <summary>
    /// One or several prompt to guide what NOT to include in image generation.
    /// </summary>
    function NegativePrompt(const Value: TArray<string>): TTextToImageParameters;
    /// <summary>
    /// The number of denoising steps. More denoising steps usually lead to a higher quality image
    /// at the expense of slower inference.
    /// </summary>
    function NumInferenceSteps(const Value: Integer): TTextToImageParameters;
    /// <summary>
    /// The size in pixel of the output image
    /// </summary>
    function TargetSize(const Width, Height: Integer): TTextToImageParameters;
    /// <summary>
    /// Override the scheduler with a compatible one.
    /// </summary>
    function Scheduler(const Value: string): TTextToImageParameters;
    /// <summary>
    /// Seed for the random number generator.
    /// </summary>
    function Seed(const Value: Integer): TTextToImageParameters;
  end;

  TTextToImageParam = class(TJSONModelParam)
  public
    /// <summary>
    /// The input text data (sometimes called “prompt”)
    /// </summary>
    function Inputs(const Value: string): TTextToImageParam;
    /// <summary>
    /// The input text data (sometimes called “prompt”)
    /// </summary>
    function Prompt(const Value: string): TTextToImageParam;
    /// <summary>
    /// Define generation parameters
    /// </summary>
    function Parameters(ParamProc: TProcRef<TTextToImageParameters>): TTextToImageParam;
  end;

  TTextToImage = class
  private
    FFileName: string;
    FImage: string;
  public
    /// <summary>
    /// Retrieves the generated image as a <c>TStream</c>.
    /// </summary>
    /// <returns>
    /// A <c>TStream</c> containing the decoded image data.
    /// </returns>
    /// <remarks>
    /// This method decodes the base64-encoded image data and returns it as a stream.
    /// The caller is responsible for freeing the returned stream.
    /// </remarks>
    /// <exception cref="Exception">
    /// Raises an exception if both the image and video data are empty.
    /// </exception>
    function GetStream: TStream;
    /// <summary>
    /// Saves the generated image to a file.
    /// </summary>
    /// <param name="FileName">
    /// The file path where the image will be saved.
    /// </param>
    /// <remarks>
    /// This method decodes the base64-encoded image data and saves it to the specified file.
    /// </remarks>
    /// <exception cref="Exception">
    /// Raises an exception if the image data cannot be decoded or saved.
    /// </exception>
    procedure SaveToFile(const FileName: string);
    /// <summary>
    /// The output image as base-64 returned
    /// </summary>
    property Image: string read FImage write FImage;
    /// <summary>
    /// Gets the file name where the image was saved.
    /// </summary>
    /// <value>
    /// The file path as a string.
    /// </value>
    /// <remarks>
    /// This property holds the file name specified in the last call to <c>SaveToFile</c>.
    /// </remarks>
    property FileName: string read FFileName write FFileName;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TTextToImage</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynTextToImage</c> type extends the <c>TAsynParams&lt;TTextToImage&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynTextToImage = TAsynCallBack<TTextToImage>;

  {$ENDREGION}

  {$REGION 'Token Classification'}

  TTokenClassificationParameters = class(TJSONParam)
    /// <summary>
    /// A list of labels to ignore.
    /// </summary>
    function IgnoreLabels(const Value: TArray<string>): TTokenClassificationParameters;
    /// <summary>
    /// The number of overlapping tokens between chunks when splitting the input text.
    /// </summary>
    function Stride(const Value: Integer): TTokenClassificationParameters;
    /// <summary>
    /// One of the following: asnone, simple, first, average, max
    /// </summary>
    function AggregationStrategy(const Value: TAggregationStrategyType): TTokenClassificationParameters;
  end;

  TTokenClassificationParam = class(TJSONModelParam)
  public
    /// <summary>
    /// The input text data.
    /// </summary>
    function Inputs(const Value: string): TTokenClassificationParam;
    /// <summary>
    /// Define generation parameters
    /// </summary>
    function Parameters(ParamProc: TProcRef<TTokenClassificationParameters>): TTokenClassificationParam;
  end;

  TTokenClassificationItem = class
  private
    [JsonNameAttribute('entity_group')]
    FEntityGroup: string;
    FEntity: string;
    FScore: Double;
    FWord: string;
    FStart: Integer;
    FEnd: Integer;
  public
    /// <summary>
    /// The predicted label for a group of one or more tokens.
    /// </summary>
    property EntityGroup: string read FEntityGroup write FEntityGroup;
    /// <summary>
    /// The predicted label for a single token.
    /// </summary>
    property Entity: string read FEntity write FEntity;
    /// <summary>
    /// The associated score / probability.
    /// </summary>
    property Score: Double read FScore write FScore;
    /// <summary>
    /// The corresponding text.
    /// </summary>
    property Word: string read FWord write FWord;
    /// <summary>
    /// The character position in the input where this group begins.
    /// </summary>
    property Start: Integer read FStart write FStart;
    /// <summary>
    /// The character position in the input where this group ends.
    /// </summary>
    property &End: Integer read FEnd write FEnd;
  end;

  TTokenClassification = class
  private
    FItems: TArray<TTokenClassificationItem>;
  public
    property Items: TArray<TTokenClassificationItem> read FItems write FItems;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TTokenClassification</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynTokenClassification</c> type extends the <c>TAsynParams&lt;TTokenClassification&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynTokenClassification = TAsynCallBack<TTokenClassification>;

  {$ENDREGION}

  {$REGION 'Translation'}

  TTranslationParameters = class(TJSONParam)
  public
    /// <summary>
    /// The source language of the text. Required for models that can translate from multiple languages.
    /// </summary>
    function SrcLang(const Value: string): TTranslationParameters;
    /// <summary>
    /// Target language to translate to. Required for models that can translate to multiple languages.
    /// </summary>
    function TgtLang(const Value: string): TTranslationParameters;
    /// <summary>
    /// Whether to clean up the potential extra spaces in the text output.
    /// </summary>
    function CleanUpTokenizationSpaces(const Value: Boolean): TTranslationParameters;
    /// <summary>
    /// Possible values: do_not_truncate, longest_first, only_first, only_second.
    /// </summary>
    function Truncation(const Value: TTextTruncationType): TTranslationParameters;
    /// <summary>
    /// Additional parametrization of the text generation algorithm.
    /// </summary>
    function GenerateParameters(const Value: TJSONObject): TTranslationParameters;
  end;

  TTranslationParam = class(TJSONModelParam)
  public
    /// <summary>
    /// The text to translate.
    /// </summary>
    function Inputs(const Value: string): TTranslationParam;
    /// <summary>
    /// Define generation parameters.
    /// </summary>
    function Parameters(ParamProc: TProcRef<TTranslationParameters>): TTranslationParam;
  end;

  TTranslationItem = class
  private
    [JsonNameAttribute('translation_text')]
    FTranslationText: string;
  public
    /// <summary>
    /// The translated text.
    /// </summary>
    property TranslationText: string read FTranslationText write FTranslationText;
  end;

  TTranslation = class
  private
    FItems: TArray<TTranslationItem>;
  public
    property Items: TArray<TTranslationItem> read FItems write FItems;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TTranslation</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynTranslation</c> type extends the <c>TAsynParams&lt;TTranslation&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynTranslation = TAsynCallBack<TTranslation>;

  {$ENDREGION}

  {$REGION 'Zero-Shot Classification'}

  TZeroShotClassificationParameters = class(TJSONParam)
  public
    /// <summary>
    /// The set of possible class labels to classify the text into.
    /// </summary>
    function CandidateLabels(const Value: TArray<string>): TZeroShotClassificationParameters;
    /// <summary>
    /// The sentence used in conjunction with candidate_labels to attempt the text classification by
    /// replacing the placeholder with the candidate labels.
    /// </summary>
    function HypothesisTemplate(const Value: string): TZeroShotClassificationParameters;
    /// <summary>
    /// Whether multiple candidate labels can be true. If false, the scores are normalized such that
    /// the sum of the label likelihoods for each sequence is 1. If true, the labels are considered
    /// independent and probabilities are normalized for each candidate.
    /// </summary>
    function MultiLabel(const Value: Boolean): TZeroShotClassificationParameters;
  end;

  TZeroShotClassificationParam = class(TJSONModelParam)
  public
    /// <summary>
    /// The text to classify.
    /// </summary>
    function Inputs(const Value: string): TZeroShotClassificationParam;
    /// <summary>
    /// Define generation parameters.
    /// </summary>
    function Parameters(ParamProc: TProcRef<TZeroShotClassificationParameters>): TZeroShotClassificationParam;
  end;

  TZeroShotClassification = class
  private
    FSequence: string;
    FLabels: TArray<string>;
    FScores: TArray<Double>;
  public
    /// <summary>
    /// The input string.
    /// </summary>
    property Sequence: string read FSequence write FSequence;
    /// <summary>
    /// The predicted class label.
    /// </summary>
    property Labels: TArray<string> read FLabels write FLabels;
    /// <summary>
    /// The corresponding probability.
    /// </summary>
    property Scores: TArray<Double> read FScores write FScores;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TZeroShotClassification</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynZeroShotClassification</c> type extends the <c>TAsynParams&lt;TZeroShotClassification&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynZeroShotClassification = TAsynCallBack<TZeroShotClassification>;

  {$ENDREGION}

  {$REGION 'Text Generation'}

  TTextGenerationParameters = class(TJSONParam)
  public
    /// <summary>
    /// Lora adapter id.
    /// </summary>
    function AdapterId(const Value: string): TTextGenerationParameters;
    /// <summary>
    /// Generate best_of sequences and return the one if the highest token logprobs.
    /// </summary>
    function BestOf(const Value: Integer): TTextGenerationParameters;
    /// <summary>
    /// Whether to return decoder input token logprobs and ids.
    /// </summary>
    function DecoderInputDetails(const Value: Boolean): TTextGenerationParameters;
    /// <summary>
    /// Whether to return generation details.
    /// </summary>
    function Details(const Value: Boolean): TTextGenerationParameters;
    /// <summary>
    /// Activate logits sampling.
    /// </summary>
    function DoSample(const Value: Boolean): TTextGenerationParameters;
    /// <summary>
    /// The parameter for frequency penalty. 1.0 means no penalty Penalize new tokens based on their
    /// existing frequency in the text so far, decreasing the model’s likelihood to repeat the same
    /// line verbatim.
    /// </summary>
    function FrequencyPenalty(const Value: Double): TTextGenerationParameters;
    /// <summary>
    /// Define the grammar pattern
    /// </summary>
    function Grammar(const Value: string): TTextGenerationParameters; overload;
    /// <summary>
    /// Define the grammar pattern
    /// </summary>
    function Grammar(const Value: TSchemaParams): TTextGenerationParameters; overload;
    /// <summary>
    ///   Maximum number of tokens to generate.
    /// </summary>
    function MaxNewTokens(const Value: Integer): TTextGenerationParameters;
    /// <summary>
    /// The parameter for repetition penalty. 1.0 means no penalty. See this paper for more details.
    /// </summary>
    function RepetitionPenalty(const Value: Double): TTextGenerationParameters;
    /// <summary>
    /// Whether to prepend the prompt to the generated text.
    /// </summary>
    function ReturnFullText(const Value: Boolean): TTextGenerationParameters;
    /// <summary>
    /// Random sampling seed.
    /// </summary>
    function Seed(const Value: Integer): TTextGenerationParameters;
    /// <summary>
    /// Stop generating tokens if a member of stop is generated.
    /// </summary>
    function Stop(const Value: TArray<string>): TTextGenerationParameters;
    /// <summary>
    /// The value used to module the logits distribution.
    /// </summary>
    function Temperature(const Value: Double): TTextGenerationParameters;
    /// <summary>
    /// The number of highest probability vocabulary tokens to keep for top-k-filtering.
    /// </summary>
    function TopK(const Value: Integer): TTextGenerationParameters;
    /// <summary>
    /// The number of highest probability vocabulary tokens to keep for top-n-filtering.
    /// </summary>
    function TopNtokens(const Value: Integer): TTextGenerationParameters;
    /// <summary>
    /// Top-p value for nucleus sampling.
    /// </summary>
    function TopP(const Value: Double): TTextGenerationParameters;
    /// <summary>
    /// Truncate inputs tokens to the given size.
    /// </summary>
    function Truncate(const Value: Integer): TTextGenerationParameters;
    /// <summary>
    /// Typical Decoding mass See Typical Decoding for Natural Language Generation for more information.
    /// </summary>
    function TypicalP(const Value: Double): TTextGenerationParameters;
    /// <summary>
    /// Watermarking with A Watermark for Large Language Models.
    /// </summary>
    /// <remarks>
    /// Watermark for Large Language Model :
    /// <para>
    /// - https://arxiv.org/abs/2301.10226
    /// </para>
    /// </remarks>
    function Watermark(const Value: Boolean): TTextGenerationParameters;
  end;

  TTextGenerationParam = class(TJSONModelParam)
  public
    /// <summary>
    /// Text prompt to guide text generation
    /// </summary>
    function Inputs(const Value: string): TTextGenerationParam;
    /// <summary>
    /// Enables token streaming for partial responses.
    /// </summary>
    function Stream(const Value: Boolean): TTextGenerationParam;
    /// <summary>
    /// Define generation parameters.
    /// </summary>
    function Parameters(ParamProc: TProcRef<TTextGenerationParameters>): TTextGenerationParam;
  end;

  TPrefill = class
  private
    FId: Int64;
    FLogprob: Double;
    FText: string;
  public
    property Id: Int64 read FId write FId;
    property Logprob: Double read FLogprob write FLogprob;
    property Text: string read FText write FText;
  end;

  TTokens = class
  private
    FId: Int64;
    FLogprob: Double;
    FSpecial: Boolean;
    FText: string;
  public
    property Id: Int64 read FId write FId;
    property Logprob: Double read FLogprob write FLogprob;
    property Special: Boolean read FSpecial write FSpecial;
    property Text: string read FText write FText;
  end;

  TBestOfSequences = class
  private
    [JsonNameAttribute('finish_reason')]
    [JsonReflectAttribute(ctString, rtString, TFinishReasonInterceptor)]
    FFinishReason: TFinishReason;
    [JsonNameAttribute('generated_text')]
    FGeneratedText: string;
    [JsonNameAttribute('generated_tokens')]
    FGeneratedTokens: int64;
    FPrefill: TArray<TPrefill>;
    FTokens: TArray<TTokens>;
    [JsonNameAttribute('top_tokens')]
    FTopTokens: TArray<TTokens>;
  public
    property FinishReason: TFinishReason read FFinishReason write FFinishReason;
    property GeneratedText: string read FGeneratedText write FGeneratedText;
    property GeneratedTokens: int64 read FGeneratedTokens write FGeneratedTokens;
    property Prefill: TArray<TPrefill> read FPrefill write FPrefill;
    property Tokens: TArray<TTokens> read FTokens write FTokens;
    property TopTokens: TArray<TTokens> read FTopTokens write FTopTokens;
    destructor Destroy; override;
  end;

  TDetails = class
  private
    [JsonNameAttribute('generated_text')]
    FGeneratedText: string;
    [JsonNameAttribute('finish_reason')]
    [JsonReflectAttribute(ctString, rtString, TFinishReasonInterceptor)]
    FFinishReason: TFinishReason;
    [JsonNameAttribute('best_of_sequences')]
    FBestOfSequences: TArray<TBestOfSequences>;
    [JsonNameAttribute('generated_tokens')]
    FGeneratedTokens: Int64;
    FPrefill: TArray<TPrefill>;
    FSeed: Int64;
    FTokens: TArray<TTokens>;
    [JsonNameAttribute('top_tokens')]
    FTopTokens: TArray<TTokens>;
  public
    property GeneratedText: string read FGeneratedText write FGeneratedText;
    property FinishReason: TFinishReason read FFinishReason write FFinishReason;
    property BestOfSequences: TArray<TBestOfSequences> read FBestOfSequences write FBestOfSequences;
    property GeneratedTokens: Int64 read FGeneratedTokens write FGeneratedTokens;
    property Prefill: TArray<TPrefill> read FPrefill write FPrefill;
    property Seed: Int64 read FSeed write FSeed;
    property Tokens: TArray<TTokens> read FTokens write FTokens;
    property TopTokens: TArray<TTokens> read FTopTokens write FTopTokens;
    destructor Destroy; override;
  end;

  TTextGenerationItem = class
  private
    [JsonNameAttribute('generated_text')]
    FGeneratedText: string;
    FDetails: TDetails;
  public
    property GeneratedText: string read FGeneratedText write FGeneratedText;
    property Details: TDetails read FDetails write FDetails;
    destructor Destroy; override;
  end;

  TTextGeneration = class
  private
    FItems: TArray<TTextGenerationItem>;
    FGeneratedText: string;
    [JsonNameAttribute('token')]
    FDelta: TTokens;
  public
    /// <summary>
    /// Text result generated
    /// </summary>
    property GeneratedText: string read FGeneratedText write FGeneratedText;
    property Items: TArray<TTextGenerationItem> read FItems write FItems;
    /// <summary>
    /// Chunk generated when streaming is enabled.
    /// </summary>
    property Delta: TTokens read FDelta write FDelta;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a callback procedure used during the reception of responses from a chat request in streaming mode.
  /// </summary>
  /// <param name="Generation">
  /// The <c>TTextGeneration</c> object containing the current information about the response generated by the model.
  /// If this value is <c>nil</c>, it indicates that the data stream is complete.
  /// </param>
  /// <param name="IsDone">
  /// A boolean flag indicating whether the streaming process is complete.
  /// If <c>True</c>, it means the model has finished sending all response data.
  /// </param>
  /// <param name="Cancel">
  /// A boolean flag that can be set to <c>True</c> within the callback to cancel the streaming process.
  /// If set to <c>True</c>, the streaming will be terminated immediately.
  /// </param>
  /// <remarks>
  /// This callback is invoked multiple times during the reception of the response data from the model.
  /// It allows for real-time processing of received messages and interaction with the user interface or other systems
  /// based on the state of the data stream.
  /// When the <c>IsDone</c> parameter is <c>True</c>, it indicates that the model has finished responding,
  /// and the <c>TTextGeneration</c> parameter will be <c>nil</c>.
  /// </remarks>
  TTextGenerationEvent = reference to procedure(var Generation: TTextGeneration; IsDone: Boolean; var Cancel: Boolean);

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TTextGeneration</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynTextGeneration</c> type extends the <c>TAsynParams&lt;TTextGeneration&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynTextGeneration = TAsynCallBack<TTextGeneration>;

  /// <summary>
  /// Manages asynchronous streaming chat callBacks for a chat request using <c>TTextGeneration</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynTextGenerationStream</c> type extends the <c>TAsynStreamParams&lt;TTextGeneration&gt;</c> record to support the lifecycle of an asynchronous streaming chat operation.
  /// It provides callbacks for different stages, including when the operation starts, progresses with new data chunks, completes successfully, or encounters an error.
  /// This structure is ideal for handling scenarios where the chat response is streamed incrementally, providing real-time updates to the user interface.
  /// </remarks>
  TAsynTextGenerationStream = TAsynStreamCallBack<TTextGeneration>;

  {$ENDREGION}

  {$REGION 'Sentiment analysis'}

  TSentimentAnalysisParams = class(TJSONModelParam)
  public
    /// <summary>
    /// Text to analyse
    /// </summary>
    function Inputs(const Value: string): TSentimentAnalysisParams;
  end;

  TEval = class
  private
    FLabel: string;
    FScore: Double;
  public
    /// <summary>
    /// The predicted label.
    /// </summary>
    property &Label: string read FLabel write FLabel;
    /// <summary>
    /// The corresponding probability.
    /// </summary>
    property Score: Double read FScore write FScore;
  end;

  TEvals = class
  private
    FItems: TArray<TEval>;
  public
    /// <summary>
    /// List of evals.
    /// </summary>
    property Evals: TArray<TEval> read FItems write FItems;
    destructor Destroy; override;
  end;

  TSentimentAnalysis = class
  private
    FItems: TArray<TEvals>;
  public
    property Items: TArray<TEvals> read FItems write FItems;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TSentimentAnalysis</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynSentimentAnalysis</c> type extends the <c>TAsynParams&lt;TSentimentAnalysis&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynSentimentAnalysis = TAsynCallBack<TSentimentAnalysis>;

  {$ENDREGION}

  {$REGION 'Text-to-speech'}

  TTextToSpeechParam = class(TJSONModelParam)
  public
    /// <summary>
    /// Text prompt to analyse
    /// </summary>
    function Inputs(const Value: string): TTextToSpeechParam;
  end;

  TTextToAudioParam = class(TJSONModelParam)
  public
    /// <summary>
    /// Text prompt to analyse
    /// </summary>
    function Inputs(const Value: string): TTextToAudioParam;
  end;

  TTextToSpeech = class
  private
    FFileName: string;
    FAudio: string;
  public
    /// <summary>
    /// Retrieves the generated audio as a <c>TStream</c>.
    /// </summary>
    /// <returns>
    /// A <c>TStream</c> containing the decoded audio data.
    /// </returns>
    /// <remarks>
    /// This method decodes the base64-encoded audio data and returns it as a stream.
    /// The caller is responsible for freeing the returned stream.
    /// </remarks>
    /// <exception cref="Exception">
    /// Raises an exception if both the audio are empty.
    /// </exception>
    function GetStream: TStream;
    /// <summary>
    /// Saves the generated audio to a file.
    /// </summary>
    /// <param name="FileName">
    /// The file path where the audio will be saved.
    /// </param>
    /// <remarks>
    /// This method decodes the base64-encoded audio data and saves it to the specified file.
    /// </remarks>
    /// <exception cref="Exception">
    /// Raises an exception if the audio data cannot be decoded or saved.
    /// </exception>
    procedure SaveToFile(const FileName: string);
    /// <summary>
    /// The base64-encoded audio data.
    /// </summary>
    property Audio: string read FAudio write FAudio;
    /// <summary>
    /// Gets the file name where the audio was saved.
    /// </summary>
    /// <value>
    /// The file path as a string.
    /// </value>
    /// <remarks>
    /// This property holds the file name specified in the last call to <c>SaveToFile</c>.
    /// </remarks>
    property FileName: string read FFileName write FFileName;
  end;

  TTextToAudio = TTextToSpeech;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TTextToSpeech</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynTextToSpeech</c> type extends the <c>TAsynParams&lt;TTextToSpeech&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynTextToSpeech = TAsynCallBack<TTextToSpeech>;

  TAsynTextToAudio = TAsynTextToSpeech;

  {$ENDREGION}

  TTextRoute = class(THuggingFaceAPIRoute)
    /// <summary>
    /// Generate text based on a prompt.
    /// <para>
    /// If you are interested in a Chat Completion task, which generates a response based on
    /// a list of messages, check out the chat-completion task.
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TTextGenerationParam</c> parameters.
    /// </param>
    /// <returns>
    /// A <c>TTextGeneration</c> object containing the text generation result.
    /// </returns>
    /// <remarks>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// var Value := HuggingFace.Text.Generation(
    ///     procedure (Params: TTextGenerationParam)
    ///     begin
    ///       // Define parameters
    ///     end;
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function Generation(ParamProc: TProc<TTextGenerationParam>): TTextGeneration; overload;
    /// <summary>
    /// Generate text based on a prompt.
    /// <para>
    /// If you are interested in a Chat Completion task, which generates a response based on
    /// a list of messages, check out the chat-completion task.
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TTextGenerationParam</c> parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns <c>TAsynTextGeneration</c> to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// <para>
    /// The <c>CallBacks</c> function is invoked when the operation completes, either successfully or with an error.
    /// </para>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// HuggingFace.Text.Generation(
    ///   procedure (Params: TTextGenerationParam)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynTextGeneration
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TTextGeneration)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure Generation(ParamProc: TProc<TTextGenerationParam>;
      CallBacks: TFunc<TAsynTextGeneration>); overload;
    /// <summary>
    /// Generate a streamed text based on a prompt.
    /// <para>
    /// If you are interested in a Chat Completion task, which generates a response based on
    /// a list of messages, check out the chat-completion task.
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TTextGenerationParam</c> parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a <c>TAsynTextGenerationStream</c> record which contains event handlers for managing different stages of the streaming process: progress updates, success, errors, and cancellation.
    /// </param>
    /// <remarks>
    /// This procedure initiates an asynchronous chat operation in streaming mode, where tokens are progressively received and processed.
    /// The provided event handlers allow for handling progress (i.e., receiving tokens in real time), detecting success, managing errors, and enabling cancellation logic.
    /// <code>
    /// CheckBox1.Checked := False;  //Click to stop the streaming
    /// // WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// HuggingFace.Text.GenerationStream(
    ///   procedure(Params: TChatParams)
    ///   begin
    ///     // Define chat parameters
    ///     Params.Stream(True);
    ///   end,
    ///
    ///   function: TAsynTextGenerationStream
    ///   begin
    ///     Result.Sender := Memo1; // Instance passed to callback parameter
    ///     Result.OnProgress :=
    ///         procedure (Sender: TObject; Value: TTextGeneration)
    ///         begin
    ///           // Handle progressive updates to the chat response
    ///         end;
    ///     Result.OnSuccess :=
    ///         procedure (Sender: TObject)
    ///         begin
    ///           // Handle success when the operation completes
    ///         end;
    ///     Result.OnError :=
    ///         procedure (Sender: TObject; Value: string)
    ///         begin
    ///           // Handle error message
    ///         end;
    ///     Result.OnDoCancel :=
    ///         function: Boolean
    ///         begin
    ///           Result := CheckBox1.Checked; // Click on checkbox to cancel
    ///         end;
    ///     Result.OnCancellation :=
    ///         procedure (Sender: TObject)
    ///         begin
    ///           // Processing when process has been canceled
    ///         end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure GenerationStream(ParamProc: TProc<TTextGenerationParam>;
      CallBacks: TFunc<TAsynTextGenerationStream>); overload;
    /// <summary>
    /// Generate a streamed text based on a prompt.
    /// <para>
    /// If you are interested in a Chat Completion task, which generates a response based on
    /// a list of messages, check out the chat-completion task.
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TTextGenerationParam</c> parameters.
    /// </param>
    /// <param name="Event">
    /// A callback of type <c>TChatEvent</c> that is triggered with each chunk of data received during the streaming process. It includes the current state of the <c>TChat</c> object, a flag indicating if the stream is done, and a boolean to handle cancellation.
    /// </param>
    /// <returns>
    /// Returns <c>True</c> if the streaming process started successfully, <c>False</c> otherwise.
    /// </returns>
    /// <remarks>
    /// This method initiates a chat request in streaming mode, where the response is delivered incrementally in real-time.
    /// The <c>Event</c> callback will be invoked multiple times as tokens are received.
    /// When the response is complete, the <c>IsDone</c> flag will be set to <c>True</c>, and the <c>Chat</c> object will be <c>nil</c>.
    /// The streaming process can be interrupted by setting the <c>Cancel</c> flag to <c>True</c> within the event.
    ///
    /// Example usage:
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    ///   HuggingFace.Text.GenerationStream(
    ///     procedure (Params: TTextGenerationParam)
    ///     begin
    ///       // Define chat parameters
    ///       Params.Stream(True);
    ///     end,
    ///
    ///     procedure(var Generation: TTextGeneration; IsDone: Boolean; var Cancel: Boolean)
    ///     begin
    ///       // Handle displaying
    ///     end);
    /// </code>
    /// </remarks>
    function GenerationStream(ParamProc: TProc<TTextGenerationParam>; Event: TTextGenerationEvent): Boolean; overload;
    /// <summary>
    /// Question Answering models can retrieve the answer to a question from a given text, which is useful
    /// for searching for an answer in a document.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TQuestionAnsweringParam</c> parameters.
    /// </param>
    /// <returns>
    /// A <c>TQuestionAnswering</c> object containing the text generation result.
    /// </returns>
    /// <remarks>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// var Value := HuggingFace.Text.QuestionAnswering(
    ///     procedure (Params: TQuestionAnsweringParam)
    ///     begin
    ///       // Define parameters
    ///     end;
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function QuestionAnswering(ParamProc: TProc<TQuestionAnsweringParam>): TQuestionAnswering; overload;
    /// <summary>
    /// Question Answering models can retrieve the answer to a question from a given text, which is useful
    /// for searching for an answer in a document.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TQuestionAnsweringParam</c> parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns <c>TAsynQuestionAnswering</c> to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// <para>
    /// The <c>CallBacks</c> function is invoked when the operation completes, either successfully or with an error.
    /// </para>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// HuggingFace.Text.QuestionAnswering(
    ///   procedure (Params: TQuestionAnsweringParam)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynQuestionAnswering
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TQuestionAnswering)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure QuestionAnswering(ParamProc: TProc<TQuestionAnsweringParam>;
      CallBacks: TFunc<TAsynQuestionAnswering>); overload;
    /// <summary>
    /// Analysis of feelings or emotions from a prompt.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TSentimentAnalysisParams</c> parameters.
    /// </param>
    /// <returns>
    /// A <c>TSentimentAnalysis</c> object containing the text generation result.
    /// </returns>
    /// <remarks>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// var Value := HuggingFace.Text.SentimentAnalysis(
    ///     procedure (Params: TSentimentAnalysisParams)
    ///     begin
    ///       // Define parameters
    ///     end;
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function SentimentAnalysis(ParamProc: TProc<TSentimentAnalysisParams>): TSentimentAnalysis; overload;
    /// <summary>
    /// Analysis of feelings or emotions from a prompt.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TSentimentAnalysisParams</c> parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns <c>TAsynSentimentAnalysis</c> to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// <para>
    /// The <c>CallBacks</c> function is invoked when the operation completes, either successfully or with an error.
    /// </para>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// HuggingFace.Text.SentimentAnalysis(
    ///   procedure (Params: TSentimentAnalysisParams)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynSentimentAnalysis
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TSentimentAnalysis)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure SentimentAnalysis(ParamProc: TProc<TSentimentAnalysisParams>;
      CallBacks: TFunc<TAsynSentimentAnalysis>); overload;
    /// <summary>
    /// Summarization is the task of producing a shorter version of a document while preserving
    /// its important information. Some models can extract text from the original input, while
    /// other models can generate entirely new text.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TSummarizationParam</c> parameters.
    /// </param>
    /// <returns>
    /// A <c>TSummarization</c> object containing the text generation result.
    /// </returns>
    /// <remarks>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// var Value := HuggingFace.Text.Summarization(
    ///     procedure (Params: TSummarizationParam)
    ///     begin
    ///       // Define parameters
    ///     end;
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function Summarization(ParamProc: TProc<TSummarizationParam>): TSummarization; overload;
    /// <summary>
    /// Summarization is the task of producing a shorter version of a document while preserving
    /// its important information. Some models can extract text from the original input, while
    /// other models can generate entirely new text.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TSummarizationParam</c> parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns <c>TAsynSummarization</c> to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// <para>
    /// The <c>CallBacks</c> function is invoked when the operation completes, either successfully or with an error.
    /// </para>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// HuggingFace.Text.Summarization(
    ///   procedure (Params: TSummarizationParam)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynSummarization
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TSummarization)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure Summarization(ParamProc: TProc<TSummarizationParam>;
      CallBacks: TFunc<TAsynSummarization>); overload;
    /// <summary>
    /// Table Question Answering (Table QA) is the answering a question about an information on a given table.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TTableQAParam</c> parameters.
    /// </param>
    /// <returns>
    /// A <c>TTableQA</c> object containing the text generation result.
    /// </returns>
    /// <remarks>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// var Value := HuggingFace.Text.TableQuestionAnswering(
    ///     procedure (Params: TTableQAParam)
    ///     begin
    ///       // Define parameters
    ///     end;
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function TableQuestionAnswering(ParamProc: TProc<TTableQAParam>): TTableQA; overload;
    /// <summary>
    /// Table Question Answering (Table QA) is the answering a question about an information on a given table.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TTableQAParam</c> parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns <c>TAsynTableQA</c> to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// <para>
    /// The <c>CallBacks</c> function is invoked when the operation completes, either successfully or with an error.
    /// </para>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// HuggingFace.Text.TableQuestionAnswering(
    ///   procedure (Params: TTableQAParam)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynTableQA
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TTableQA)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure TableQuestionAnswering(ParamProc: TProc<TTableQAParam>;
      CallBacks: TFunc<TAsynTableQA>); overload;
    /// <summary>
    /// Text Classification is the task of assigning a label or class to a given text. Some use cases
    /// are sentiment analysis, natural language inference, and assessing grammatical correctness.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TTextClassificationParam</c> parameters.
    /// </param>
    /// <returns>
    /// A <c>TTextClassification</c> object containing the text generation result.
    /// </returns>
    /// <remarks>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// var Value := HuggingFace.Text.TextClassification(
    ///     procedure (Params: TTextClassificationParam)
    ///     begin
    ///       // Define parameters
    ///     end;
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function TextClassification(ParamProc: TProc<TTextClassificationParam>): TTextClassification; overload;
    /// <summary>
    /// Text Classification is the task of assigning a label or class to a given text. Some use cases
    /// are sentiment analysis, natural language inference, and assessing grammatical correctness.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TTextClassificationParam</c> parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns <c>TAsynTextClassification</c> to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// <para>
    /// The <c>CallBacks</c> function is invoked when the operation completes, either successfully or with an error.
    /// </para>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// HuggingFace.Text.TextClassification(
    ///   procedure (Params: TTextClassificationParam)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynTextClassification
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TTextClassification)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure TextClassification(ParamProc: TProc<TTextClassificationParam>;
      CallBacks: TFunc<TAsynTextClassification>); overload;
    /// <summary>
    /// Generate an image based on a given text prompt.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TTextToImageParam</c> parameters.
    /// </param>
    /// <returns>
    /// A <c>TTextToImage</c> object containing the text generation result.
    /// </returns>
    /// <remarks>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// var Value := HuggingFace.Text.TextToImage(
    ///     procedure (Params: TTextToImageParam)
    ///     begin
    ///       // Define parameters
    ///     end;
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function TextToImage(ParamProc: TProc<TTextToImageParam>): TTextToImage; overload;
    /// <summary>
    /// Generate an image based on a given text prompt.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TTextToImageParam</c> parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns <c>TAsynTextToImage</c> to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// <para>
    /// The <c>CallBacks</c> function is invoked when the operation completes, either successfully or with an error.
    /// </para>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// HuggingFace.Text.TextToImage(
    ///   procedure (Params: TTextToImageParam)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynTextToImage
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TTextToImage)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure TextToImage(ParamProc: TProc<TTextToImageParam>;
      CallBacks: TFunc<TAsynTextToImage>); overload;
    /// <summary>
    /// Generate an audio based on a given text prompt.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TTextToAudioParam</c> parameters.
    /// </param>
    /// <returns>
    /// A <c>TTextToAudio</c> object containing the text generation result.
    /// </returns>
    /// <remarks>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// var Value := HuggingFace.Text.TextToAudio(
    ///     procedure (Params: TTextToAudioParam)
    ///     begin
    ///       // Define parameters
    ///     end;
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function TextToAudio(ParamProc: TProc<TTextToAudioParam>): TTextToAudio; overload;
    /// <summary>
    /// Generate an audio based on a given text prompt.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TTextToAudioParam</c> parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns <c>TAsynTextToAudio</c> to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// <para>
    /// The <c>CallBacks</c> function is invoked when the operation completes, either successfully or with an error.
    /// </para>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// HuggingFace.Text.TextToAudio(
    ///   procedure (Params: TTextToAudioParam)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynTextToAudio
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TTextToAudio)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure TextToAudio(ParamProc: TProc<TTextToAudioParam>;
      CallBacks: TFunc<TAsynTextToAudio>); overload;
    /// <summary>
    /// Generate an speech based on a given text prompt.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TTextToAudioParam</c> parameters.
    /// </param>
    /// <returns>
    /// A <c>TTextToAudio</c> object containing the text generation result.
    /// </returns>
    /// <remarks>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// var Value := HuggingFace.Text.TextToAudio(
    ///     procedure (Params: TTextToAudioParam)
    ///     begin
    ///       // Define parameters
    ///     end;
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function TextToSpeech(ParamProc: TProc<TTextToSpeechParam>): TTextToSpeech; overload;
    /// <summary>
    /// Generate an speech based on a given text prompt.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TTextToSpeechParam</c> parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns <c>TAsynTextToSpeech</c> to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// <para>
    /// The <c>CallBacks</c> function is invoked when the operation completes, either successfully or with an error.
    /// </para>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// HuggingFace.Text.TextToSpeech(
    ///   procedure (Params: TTextToSpeechParam)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynTextToSpeech
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TTextToSpeech)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure TextToSpeech(ParamProc: TProc<TTextToSpeechParam>;
      CallBacks: TFunc<TAsynTextToSpeech>); overload;
    /// <summary>
    /// Token classification is a task in which a label is assigned to some tokens in a text.
    /// Some popular token classification subtasks are Named Entity Recognition (NER) and
    /// Part-of-Speech (PoS) tagging.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TTokenClassificationParam</c> parameters.
    /// </param>
    /// <returns>
    /// A <c>TTokenClassification</c> object containing the text generation result.
    /// </returns>
    /// <remarks>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// var Value := HuggingFace.Text.TokenClassification(
    ///     procedure (Params: TTokenClassificationParam)
    ///     begin
    ///       // Define parameters
    ///     end;
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function TokenClassification(ParamProc: TProc<TTokenClassificationParam>): TTokenClassification; overload;
    /// <summary>
    /// Token classification is a task in which a label is assigned to some tokens in a text.
    /// Some popular token classification subtasks are Named Entity Recognition (NER) and
    /// Part-of-Speech (PoS) tagging.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TTokenClassificationParam</c> parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns <c>TAsynTokenClassification</c> to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// <para>
    /// The <c>CallBacks</c> function is invoked when the operation completes, either successfully or with an error.
    /// </para>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// HuggingFace.Text.TokenClassification(
    ///   procedure (Params: TTokenClassificationParam)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynTokenClassification
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TTokenClassification)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure TokenClassification(ParamProc: TProc<TTokenClassificationParam>;
      CallBacks: TFunc<TAsynTokenClassification>); overload;
    /// <summary>
    /// Translation is the task of converting text from one language to another.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TTranslationParam</c> parameters.
    /// </param>
    /// <returns>
    /// A <c>TTranslation</c> object containing the text generation result.
    /// </returns>
    /// <remarks>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// var Value := HuggingFace.Text.Translation(
    ///     procedure (Params: TTranslationParam)
    ///     begin
    ///       // Define parameters
    ///     end;
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function Translation(ParamProc: TProc<TTranslationParam>): TTranslation; overload;
    /// <summary>
    /// Translation is the task of converting text from one language to another.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TTranslationParam</c> parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns <c>TAsynTokenClassification</c> to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// <para>
    /// The <c>CallBacks</c> function is invoked when the operation completes, either successfully or with an error.
    /// </para>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// HuggingFace.Text.Translation(
    ///   procedure (Params: TTranslationParam)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynTokenClassification
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TTranslation)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure Translation(ParamProc: TProc<TTranslationParam>;
      CallBacks: TFunc<TAsynTranslation>); overload;
    /// <summary>
    /// Zero-shot text classification is super useful to try out classification with zero code, you
    /// simply pass a sentence/paragraph and the possible labels for that sentence, and you get a result.
    /// The model has not been necessarily trained on the labels you provide, but it can still predict
    /// the correct label.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TZeroShotClassificationParam</c> parameters.
    /// </param>
    /// <returns>
    /// A <c>TZeroShotClassification</c> object containing the text generation result.
    /// </returns>
    /// <remarks>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// var Value := HuggingFace.Text.ZeroShotClassification(
    ///     procedure (Params: TZeroShotClassificationParam)
    ///     begin
    ///       // Define parameters
    ///     end;
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function ZeroShotClassification(ParamProc: TProc<TZeroShotClassificationParam>): TZeroShotClassification; overload;
    /// <summary>
    /// Zero-shot text classification is super useful to try out classification with zero code, you
    /// simply pass a sentence/paragraph and the possible labels for that sentence, and you get a result.
    /// The model has not been necessarily trained on the labels you provide, but it can still predict
    /// the correct label.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TZeroShotClassificationParam</c> parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns <c>TAsynZeroShotClassification</c> to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// <para>
    /// The <c>CallBacks</c> function is invoked when the operation completes, either successfully or with an error.
    /// </para>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var HuggingFace := THuggingFaceFactory.CreateInstance(BaererKey);
    /// HuggingFace.Text.ZeroShotClassification(
    ///   procedure (Params: TZeroShotClassificationParam)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynZeroShotClassification
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TZeroShotClassification)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure ZeroShotClassification(ParamProc: TProc<TZeroShotClassificationParam>;
      CallBacks: TFunc<TAsynZeroShotClassification>); overload;
  end;

implementation

uses
  HuggingFace.NetEncoding.Base64, System.Threading, HuggingFace.Async.Params;

{ TQuestionAnsweringInputs }

function TQuestionAnsweringInputs.Context(
  const Value: string): TQuestionAnsweringInputs;
begin
  Result := TQuestionAnsweringInputs(Add('context', Value));
end;

function TQuestionAnsweringInputs.Question(
  const Value: string): TQuestionAnsweringInputs;
begin
  Result := TQuestionAnsweringInputs(Add('question', Value));
end;

{ TQuestionAnsweringParam }

function TQuestionAnsweringParam.Inputs(const Question,
  Context: string): TQuestionAnsweringParam;
begin
  var Value := TQuestionAnsweringInputs.Create.Question(Question).Context(Context).Detach;
  Result := TQuestionAnsweringParam(Add('inputs', Value));
end;

function TQuestionAnsweringParam.Inputs(
  const Question: string): TQuestionAnsweringParam;
begin
  var Value := TQuestionAnsweringInputs.Create.Question(Question).Detach;
  Result := TQuestionAnsweringParam(Add('inputs', Value));
end;

function TQuestionAnsweringParam.Parameters(
  ParamProc: TProcRef<TQuestionAnsweringParameters>): TQuestionAnsweringParam;
begin
  if Assigned(ParamProc) then
    begin
      var Value := TQuestionAnsweringParameters.Create;
      ParamProc(Value);
      Result := TQuestionAnsweringParam(Add('parameters', Value.Detach));
    end
  else Result := Self;
end;

{ TQuestionAnsweringParameters }

function TQuestionAnsweringParameters.AlignToWords(
  const Value: Boolean): TQuestionAnsweringParameters;
begin
  Result := TQuestionAnsweringParameters(Add('align_to_words', Value));
end;

function TQuestionAnsweringParameters.DocStride(
  const Value: Integer): TQuestionAnsweringParameters;
begin
  Result := TQuestionAnsweringParameters(Add('doc_stride', Value));
end;

function TQuestionAnsweringParameters.HandleImpossibleAnswer(
  const Value: Boolean): TQuestionAnsweringParameters;
begin
  Result := TQuestionAnsweringParameters(Add('handle_impossible_answer', Value));
end;

function TQuestionAnsweringParameters.MaxAnswerLen(
  const Value: Integer): TQuestionAnsweringParameters;
begin
  Result := TQuestionAnsweringParameters(Add('max_answer_len', Value));
end;

function TQuestionAnsweringParameters.MaxQuestionLen(
  const Value: Integer): TQuestionAnsweringParameters;
begin
  Result := TQuestionAnsweringParameters(Add('max_question_len', Value));
end;

function TQuestionAnsweringParameters.MaxSeqLen(
  const Value: Integer): TQuestionAnsweringParameters;
begin
  Result := TQuestionAnsweringParameters(Add('max_seq_len', Value));
end;

function TQuestionAnsweringParameters.TopK(
  const Value: Integer): TQuestionAnsweringParameters;
begin
  Result := TQuestionAnsweringParameters(Add('top_k', Value));
end;

{ TTextRoute }

function TTextRoute.QuestionAnswering(
  ParamProc: TProc<TQuestionAnsweringParam>): TQuestionAnswering;
begin
  Result := API.Post<TQuestionAnswering, TQuestionAnsweringParam>('models', ParamProc);
end;

procedure TTextRoute.QuestionAnswering(
  ParamProc: TProc<TQuestionAnsweringParam>;
  CallBacks: TFunc<TAsynQuestionAnswering>);
begin
  with TAsynCallBackExec<TAsynQuestionAnswering, TQuestionAnswering>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TQuestionAnswering
      begin
        Result := Self.QuestionAnswering(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TTextRoute.SentimentAnalysis(
  ParamProc: TProc<TSentimentAnalysisParams>): TSentimentAnalysis;
begin
  Result := API.Post<TSentimentAnalysis, TSentimentAnalysisParams>('models', ParamProc);
end;

procedure TTextRoute.SentimentAnalysis(
  ParamProc: TProc<TSentimentAnalysisParams>;
  CallBacks: TFunc<TAsynSentimentAnalysis>);
begin
  with TAsynCallBackExec<TAsynSentimentAnalysis, TSentimentAnalysis>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TSentimentAnalysis
      begin
        Result := Self.SentimentAnalysis(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TTextRoute.Summarization(
  ParamProc: TProc<TSummarizationParam>): TSummarization;
begin
  Result := API.Post<TSummarization, TSummarizationParam>('models', ParamProc);
end;

procedure TTextRoute.Summarization(ParamProc: TProc<TSummarizationParam>;
  CallBacks: TFunc<TAsynSummarization>);
begin
  with TAsynCallBackExec<TAsynSummarization, TSummarization>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TSummarization
      begin
        Result := Self.Summarization(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TTextRoute.TableQuestionAnswering(
  ParamProc: TProc<TTableQAParam>): TTableQA;
begin
  Result := API.Post<TTableQA, TTableQAParam>('models', ParamProc);
end;

procedure TTextRoute.TableQuestionAnswering(ParamProc: TProc<TTableQAParam>;
  CallBacks: TFunc<TAsynTableQA>);
begin
  with TAsynCallBackExec<TAsynTableQA, TTableQA>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TTableQA
      begin
        Result := Self.TableQuestionAnswering(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TTextRoute.TextClassification(
  ParamProc: TProc<TTextClassificationParam>): TTextClassification;
begin
  Result := API.Post<TTextClassification, TTextClassificationParam>('models', ParamProc);
end;

procedure TTextRoute.TextClassification(
  ParamProc: TProc<TTextClassificationParam>;
  CallBacks: TFunc<TAsynTextClassification>);
begin
  with TAsynCallBackExec<TAsynTextClassification, TTextClassification>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TTextClassification
      begin
        Result := Self.TextClassification(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TTextRoute.Generation(
  ParamProc: TProc<TTextGenerationParam>): TTextGeneration;
begin
  Result := API.Post<TTextGeneration, TTextGenerationParam>('models', ParamProc);
end;

procedure TTextRoute.Generation(ParamProc: TProc<TTextGenerationParam>;
  CallBacks: TFunc<TAsynTextGeneration>);
begin
  with TAsynCallBackExec<TAsynTextGeneration, TTextGeneration>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TTextGeneration
      begin
        Result := Self.Generation(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TTextRoute.GenerationStream(ParamProc: TProc<TTextGenerationParam>;
  Event: TTextGenerationEvent): Boolean;
var
  Response: TStringStream;
  RetPos: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    RetPos := 0;
    Result := API.Post<TTextGenerationParam>('models', ParamProc, Response,
      procedure(const Sender: TObject; AContentLength: Int64; AReadCount: Int64; var AAbort: Boolean)
      var
        IsDone: Boolean;
        Data: string;
        Generation: TTextGeneration;
        TextBuffer: string;
        Line: string;
        Ret: Integer;
      begin
        try
          TextBuffer := Response.DataString;
        except
          on E: EEncodingError do
            Exit;
        end;
        repeat
          Ret := TextBuffer.IndexOf(#10, RetPos);
          if Ret < 0 then
            Continue;
          Line := TextBuffer.Substring(RetPos, Ret - RetPos);
          RetPos := Ret + 1;
          if Line.IsEmpty or Line.StartsWith(#10) then
            Continue;
          Generation := nil;
          Data := Line.Replace('data: ', '').Trim([' ', #13, #10]);
          IsDone := Data = '[DONE]';

          if not IsDone then
          try
            Generation := TJson.JsonToObject<TTextGeneration>(Data);
          except
            Generation := nil;
          end;

          try
            Event(Generation, IsDone, AAbort);
          finally
            Generation.Free;
          end;
        until Ret < 0;
      end);
    finally
      Response.Free;
    end;
end;

procedure TTextRoute.GenerationStream(ParamProc: TProc<TTextGenerationParam>;
  CallBacks: TFunc<TAsynTextGenerationStream>);
begin
  var CallBackParams := TUseParamsFactory<TAsynTextGenerationStream>.CreateInstance(CallBacks);

  var Sender := CallBackParams.Param.Sender;
  var OnStart := CallBackParams.Param.OnStart;
  var OnSuccess := CallBackParams.Param.OnSuccess;
  var OnProgress := CallBackParams.Param.OnProgress;
  var OnError := CallBackParams.Param.OnError;
  var OnCancellation := CallBackParams.Param.OnCancellation;
  var OnDoCancel := CallBackParams.Param.OnDoCancel;

  var Task: ITask := TTask.Create(
        procedure()
        begin
            {--- Pass the instance of the current class in case no value was specified. }
            if not Assigned(Sender) then
              Sender := Self;

            {--- Trigger OnStart callback }
            if Assigned(OnStart) then
              TThread.Queue(nil,
                procedure
                begin
                  OnStart(Sender);
                end);
            try
              var Stop := False;

              {--- Processing }
              GenerationStream(ParamProc,
                procedure (var Generation: TTextGeneration; IsDone: Boolean; var Cancel: Boolean)
                begin
                  {--- Check that the process has not been canceled }
                  if Assigned(OnDoCancel) then
                    TThread.Queue(nil,
                        procedure
                        begin
                          Stop := OnDoCancel();
                        end);
                  if Stop then
                    begin
                      {--- Trigger when processus was stopped }
                      if Assigned(OnCancellation) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnCancellation(Sender)
                        end);
                      Cancel := True;
                      Exit;
                    end;
                  if not IsDone and Assigned(Generation) then
                    begin
                      var LocalChat := Generation;
                      Generation := nil;

                      {--- Triggered when processus is progressing }
                      if Assigned(OnProgress) then
                        TThread.Synchronize(TThread.Current,
                        procedure
                        begin
                          try
                            OnProgress(Sender, LocalChat);
                          finally
                            {--- Makes sure to release the instance containing the data obtained
                                 following processing}
                            LocalChat.Free;
                          end;
                        end)
                      else
                        LocalChat.Free;
                    end
                  else
                  if IsDone then
                    begin
                      {--- Trigger OnEnd callback when the process is done }
                      if Assigned(OnSuccess) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnSuccess(Sender);
                        end);
                    end;
                end);
            except
              on E: Exception do
                begin
                  var Error := AcquireExceptionObject;
                  try
                    var ErrorMsg := (Error as Exception).Message;

                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(OnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        OnError(Sender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
        end);
  Task.Start;
end;

function TTextRoute.TextToAudio(
  ParamProc: TProc<TTextToAudioParam>): TTextToAudio;
begin
  Result := API.Post<TTextToAudio, TTextToAudioParam>('models', ParamProc, 'audio');
end;

procedure TTextRoute.TextToAudio(ParamProc: TProc<TTextToAudioParam>;
  CallBacks: TFunc<TAsynTextToSpeech>);
begin
  with TAsynCallBackExec<TAsynTextToSpeech, TTextToSpeech>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TTextToSpeech
      begin
        Result := Self.TextToAudio(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TTextRoute.TextToImage(
  ParamProc: TProc<TTextToImageParam>): TTextToImage;
begin
  Result := API.Post<TTextToImage, TTextToImageParam>('models', ParamProc, 'image');
end;

procedure TTextRoute.TextToImage(ParamProc: TProc<TTextToImageParam>;
  CallBacks: TFunc<TAsynTextToImage>);
begin
  with TAsynCallBackExec<TAsynTextToImage, TTextToImage>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TTextToImage
      begin
        Result := Self.TextToImage(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TTextRoute.TextToSpeech(
  ParamProc: TProc<TTextToSpeechParam>): TTextToSpeech;
begin
  Result := API.Post<TTextToSpeech, TTextToSpeechParam>('models', ParamProc, 'audio');
end;

procedure TTextRoute.TextToSpeech(ParamProc: TProc<TTextToSpeechParam>;
  CallBacks: TFunc<TAsynTextToSpeech>);
begin
  with TAsynCallBackExec<TAsynTextToSpeech, TTextToSpeech>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TTextToSpeech
      begin
        Result := Self.TextToSpeech(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TTextRoute.TokenClassification(
  ParamProc: TProc<TTokenClassificationParam>): TTokenClassification;
begin
  Result := API.Post<TTokenClassification, TTokenClassificationParam>('models', ParamProc);
end;

procedure TTextRoute.TokenClassification(
  ParamProc: TProc<TTokenClassificationParam>;
  CallBacks: TFunc<TAsynTokenClassification>);
begin
  with TAsynCallBackExec<TAsynTokenClassification, TTokenClassification>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TTokenClassification
      begin
        Result := Self.TokenClassification(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TTextRoute.Translation(
  ParamProc: TProc<TTranslationParam>): TTranslation;
begin
  Result := API.Post<TTranslation, TTranslationParam>('models', ParamProc);
end;

procedure TTextRoute.Translation(ParamProc: TProc<TTranslationParam>;
  CallBacks: TFunc<TAsynTranslation>);
begin
  with TAsynCallBackExec<TAsynTranslation, TTranslation>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TTranslation
      begin
        Result := Self.Translation(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TTextRoute.ZeroShotClassification(
  ParamProc: TProc<TZeroShotClassificationParam>): TZeroShotClassification;
begin
  Result := API.Post<TZeroShotClassification, TZeroShotClassificationParam>('models', ParamProc);
end;

procedure TTextRoute.ZeroShotClassification(
  ParamProc: TProc<TZeroShotClassificationParam>;
  CallBacks: TFunc<TAsynZeroShotClassification>);
begin
  with TAsynCallBackExec<TAsynZeroShotClassification, TZeroShotClassification>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TZeroShotClassification
      begin
        Result := Self.ZeroShotClassification(ParamProc);
      end);
  finally
    Free;
  end;
end;

{ TSummarizationParam }

function TSummarizationParam.Inputs(const Value: string): TSummarizationParam;
begin
  Result := TSummarizationParam(Add('inputs', Value));
end;

function TSummarizationParam.Parameters(
  ParamProc: TProcRef<TSummarizationParameters>): TSummarizationParam;
begin
  if Assigned(ParamProc) then
    begin
      var Value := TSummarizationParameters.Create;
      ParamProc(Value);
      Result := TSummarizationParam(Add('parameters', Value.Detach));
    end
  else Result := Self;
end;

{ TSummarizationParameters }

function TSummarizationParameters.CleanUpTokenizationSpaces(
  const Value: Boolean): TSummarizationParameters;
begin
  Result := TSummarizationParameters(Add('clean_up_tokenization_spaces', Value));
end;

function TSummarizationParameters.GenerateParameters(
  const Value: TJSONObject): TSummarizationParameters;
begin
  Result := TSummarizationParameters(Add('generate_parameters', Value));
end;

function TSummarizationParameters.Truncation(
  const Value: TTextTruncationType): TSummarizationParameters;
begin
  Result := TSummarizationParameters(Add('truncation', Value.ToString));
end;

{ TSummarization }

destructor TSummarization.Destroy;
begin
  for var Item in Fitems do
    Item.Free;
  inherited;
end;

{ TTableQAInputs }

function TTableQAInputs.Query(const Value: string): TTableQAInputs;
begin
  Result := TTableQAInputs(Add('query', Value));
end;

function TTableQAInputs.Table(const Value: TArray<TRow>): TTableQAInputs;
begin
  var JSONParam := TJSONParam.Create;
  for var Row in Value do
    JSONParam.Add(Row.FieldName, Row.Values);
  Result := TTableQAInputs(Add('table', JSONParam.Detach));
end;

{ TTableQAParam }

function TTableQAParam.Inputs(const Query: string;
  const Table: TArray<TRow>): TTableQAParam;
begin
  var Value := TTableQAInputs.Create.Query(Query).Table(Table);
  Result := TTableQAParam(Add('inputs', Value.Detach));
end;

function TTableQAParam.Parameters(
  ParamProc: TProcRef<TTableQAParameters>): TTableQAParam;
begin
  if Assigned(ParamProc) then
    begin
      var Value := TTableQAParameters.Create;
      ParamProc(Value);
      Result := TTableQAParam(Add('parameters', Value.Detach));
    end
  else Result := Self;
end;

{ TTableQAParameters }

function TTableQAParameters.Padding(
  const Value: TPaddingType): TTableQAParameters;
begin
  Result := TTableQAParameters(Add('padding', Value.ToString));
end;

function TTableQAParameters.Sequential(
  const Value: Boolean): TTableQAParameters;
begin
  Result := TTableQAParameters(Add('sequential', Value));
end;

function TTableQAParameters.Truncation(
  const Value: Boolean): TTableQAParameters;
begin
  Result := TTableQAParameters(Add('truncation', Value));
end;

{ TRow }

class function TRow.Create(const FieldName: string;
  Values: TArray<string>): TRow;
begin
  Result.FieldName := FieldName;
  Result.Values := Values;
end;

{ TTextClassificationParam }

function TTextClassificationParam.Inputs(const Value: string): TTextClassificationParam;
begin
  Result := TTextClassificationParam(Add('inputs', Value));
end;

function TTextClassificationParam.Parameters(
  const FunctionToApply: TFunctionClassification;
  const TopK: Integer): TTextClassificationParam;
begin
  var Value := TTextClassificationParameters.Create.FunctionToApply(FunctionToApply);
  if TopK <> -1 then
    Value := Value.TopK(TopK);
  Result := TTextClassificationParam(Add('parameters', Value.Detach));
end;

function TTextClassificationParam.Parameters(
  const TopK: Integer): TTextClassificationParam;
begin
  Result := TTextClassificationParam(Add('parameters', TTextClassificationParameters.Create.TopK(TopK).Detach));
end;

{ TTextClassificationParameters }

function TTextClassificationParameters.FunctionToApply(
  const Value: TFunctionClassification): TTextClassificationParameters;
begin
  Result := TTextClassificationParameters(Add('function_to_apply', Value.ToString));
end;

function TTextClassificationParameters.TopK(
  const Value: Integer): TTextClassificationParameters;
begin
  Result := TTextClassificationParameters(Add('top_k', Value));
end;

{ TTextClassification }

destructor TTextClassification.Destroy;
begin
  for var Item in FItems do
    Item.Free;
  inherited;
end;

{ TTextClassificationArray }

destructor TTextClassificationArray.Destroy;
begin
  for var Item in FItems do
    Item.Free;
  inherited;
end;

{ TTextToImageParam }

function TTextToImageParam.Inputs(const Value: string): TTextToImageParam;
begin
  Result := TTextToImageParam(Add('inputs', Value));
end;

function TTextToImageParam.Parameters(
  ParamProc: TProcRef<TTextToImageParameters>): TTextToImageParam;
begin
  if Assigned(ParamProc) then
    begin
      var Value := TTextToImageParameters.Create;
      ParamProc(Value);
      Result := TTextToImageParam(Add('parameters', Value.Detach));
    end
  else Result := Self;
end;

function TTextToImageParam.Prompt(const Value: string): TTextToImageParam;
begin
  Result := TTextToImageParam(Add('prompt', Value));
end;

{ TTextToImageParameters }

function TTextToImageParameters.GuidanceScale(
  const Value: Double): TTextToImageParameters;
begin
  Result := TTextToImageParameters(Add('guidance_scale', Value));
end;

function TTextToImageParameters.NegativePrompt(
  const Value: TArray<string>): TTextToImageParameters;
begin
  Result := TTextToImageParameters(Add('negative_prompt', Value));
end;

function TTextToImageParameters.NumInferenceSteps(
  const Value: Integer): TTextToImageParameters;
begin
  Result := TTextToImageParameters(Add('num_inference_steps', Value));
end;

function TTextToImageParameters.Scheduler(
  const Value: string): TTextToImageParameters;
begin
  Result := TTextToImageParameters(Add('scheduler', Value));
end;

function TTextToImageParameters.Seed(
  const Value: Integer): TTextToImageParameters;
begin
  Result := TTextToImageParameters(Add('seed', Value));
end;

function TTextToImageParameters.TargetSize(const Width,
  Height: Integer): TTextToImageParameters;
begin
  var Value := TTargetSizeParam.Create.Width(Width).Height(Height);
  Result := TTextToImageParameters(Add('target_size', Value.Detach));
end;

{ TTargetSizeParam }

function TTargetSizeParam.Height(const Value: Integer): TTargetSizeParam;
begin
  Result := TTargetSizeParam(Add('height', Value));
end;

function TTargetSizeParam.Width(const Value: Integer): TTargetSizeParam;
begin
  Result := TTargetSizeParam(Add('width', Value));
end;

{ TTextToImage }

function TTextToImage.GetStream: TStream;
begin
  {--- Create a memory stream to write the decoded content. }
  Result := TMemoryStream.Create;
  try
    {--- Convert the base-64 string directly into the memory stream. }
    DecodeBase64ToStream(Image, Result)
  except
    Result.Free;
    raise;
  end;
end;

procedure TTextToImage.SaveToFile(const FileName: string);
begin
  try
    Self.FFileName := FileName;
    {--- Perform the decoding operation and save it into the file specified by the FileName parameter. }
    DecodeBase64ToFile(Image, FileName)
  except
    raise;
  end;
end;

{ TTokenClassificationParam }

function TTokenClassificationParam.Inputs(const Value: string): TTokenClassificationParam;
begin
  Result := TTokenClassificationParam(Add('inputs', Value));
end;

function TTokenClassificationParam.Parameters(
  ParamProc: TProcRef<TTokenClassificationParameters>): TTokenClassificationParam;
begin
  if Assigned(ParamProc) then
    begin
      var Value := TTokenClassificationParameters.Create;
      ParamProc(Value);
      Result := TTokenClassificationParam(Add('parameters', Value.Detach));
    end
  else Result := Self;
end;

{ TTokenClassificationParameters }

function TTokenClassificationParameters.AggregationStrategy(
  const Value: TAggregationStrategyType): TTokenClassificationParameters;
begin
  Result := TTokenClassificationParameters(Add('aggregation_strategy', Value.ToString));
end;

function TTokenClassificationParameters.IgnoreLabels(
  const Value: TArray<string>): TTokenClassificationParameters;
begin
  Result := TTokenClassificationParameters(Add('ignore_labels', Value));
end;

function TTokenClassificationParameters.Stride(
  const Value: Integer): TTokenClassificationParameters;
begin
  Result := TTokenClassificationParameters(Add('stride', Value));
end;

{ TTokenClassification }

destructor TTokenClassification.Destroy;
begin
  for var Item in FItems do
    Item.Free;
  inherited;
end;

{ TTranslationParam }

function TTranslationParam.Inputs(const Value: string): TTranslationParam;
begin
  Result := TTranslationParam(Add('inputs', Value));
end;

function TTranslationParam.Parameters(
  ParamProc: TProcRef<TTranslationParameters>): TTranslationParam;
begin
  if Assigned(ParamProc) then
    begin
      var Value := TTranslationParameters.Create;
      ParamProc(Value);
      Result := TTranslationParam(Add('parameters', Value.Detach));
    end
  else Result := Self;
end;

{ TTranslationParameters }

function TTranslationParameters.CleanUpTokenizationSpaces(
  const Value: Boolean): TTranslationParameters;
begin
  Result := TTranslationParameters(Add('clean_up_tokenization_spaces', Value));
end;

function TTranslationParameters.GenerateParameters(
  const Value: TJSONObject): TTranslationParameters;
begin
  Result := TTranslationParameters(Add('generate_parameters', Value));
end;

function TTranslationParameters.SrcLang(
  const Value: string): TTranslationParameters;
begin
  Result := TTranslationParameters(Add('src_lang', Value));
end;

function TTranslationParameters.TgtLang(
  const Value: string): TTranslationParameters;
begin
  Result := TTranslationParameters(Add('tgt_lang', Value));
end;

function TTranslationParameters.Truncation(
  const Value: TTextTruncationType): TTranslationParameters;
begin
  Result := TTranslationParameters(Add('truncation', Value.ToString));
end;

{ TTranslation }

destructor TTranslation.Destroy;
begin
  for var Item in FItems do
    Item.Free;
  inherited;
end;

{ TZeroShotClassificationParam }

function TZeroShotClassificationParam.Inputs(
  const Value: string): TZeroShotClassificationParam;
begin
  Result := TZeroShotClassificationParam(Add('inputs', Value));
end;

function TZeroShotClassificationParam.Parameters(
  ParamProc: TProcRef<TZeroShotClassificationParameters>): TZeroShotClassificationParam;
begin
  if Assigned(ParamProc) then
    begin
      var Value := TZeroShotClassificationParameters.Create;
      ParamProc(Value);
      Result := TZeroShotClassificationParam(Add('parameters', Value.Detach));
    end
  else Result := Self;
end;

{ TZeroShotClassificationParameters }

function TZeroShotClassificationParameters.CandidateLabels(
  const Value: TArray<string>): TZeroShotClassificationParameters;
begin
  Result := TZeroShotClassificationParameters(Add('candidate_labels', Value));
end;

function TZeroShotClassificationParameters.HypothesisTemplate(
  const Value: string): TZeroShotClassificationParameters;
begin
  Result := TZeroShotClassificationParameters(Add('hypothesis_template', Value));
end;

function TZeroShotClassificationParameters.MultiLabel(
  const Value: Boolean): TZeroShotClassificationParameters;
begin
  Result := TZeroShotClassificationParameters(Add('multi_label', Value));
end;

{ TTextGenerationParam }

function TTextGenerationParam.Inputs(const Value: string): TTextGenerationParam;
begin
  Result := TTextGenerationParam(Add('inputs', Value));
end;

function TTextGenerationParam.Parameters(
  ParamProc: TProcRef<TTextGenerationParameters>): TTextGenerationParam;
begin
  if Assigned(ParamProc) then
    begin
      var Value := TTextGenerationParameters.Create;
      ParamProc(Value);
      Result := TTextGenerationParam(Add('parameters', Value.Detach));
    end
  else Result := Self;
end;

function TTextGenerationParam.Stream(
  const Value: Boolean): TTextGenerationParam;
begin
  Result := TTextGenerationParam(Add('stream', Value));
end;

{ TTextGenerationParameters }

function TTextGenerationParameters.AdapterId(
  const Value: string): TTextGenerationParameters;
begin
  Result := TTextGenerationParameters(Add('adapter_id', Value));
end;

function TTextGenerationParameters.BestOf(
  const Value: Integer): TTextGenerationParameters;
begin
  Result := TTextGenerationParameters(Add('best_of', Value));
end;

function TTextGenerationParameters.DecoderInputDetails(
  const Value: Boolean): TTextGenerationParameters;
begin
  Result := TTextGenerationParameters(Add('decoder_input_details', Value));
end;

function TTextGenerationParameters.Details(
  const Value: Boolean): TTextGenerationParameters;
begin
  Result := TTextGenerationParameters(Add('details', Value));
end;

function TTextGenerationParameters.DoSample(
  const Value: Boolean): TTextGenerationParameters;
begin
  Result := TTextGenerationParameters(Add('do_sample', Value));
end;

function TTextGenerationParameters.FrequencyPenalty(
  const Value: Double): TTextGenerationParameters;
begin
  Result := TTextGenerationParameters(Add('frequency_penalty', Value));
end;

function TTextGenerationParameters.Grammar(
  const Value: TSchemaParams): TTextGenerationParameters;
begin
  Result := TTextGenerationParameters(Add('grammar', TResponseFormat.Json(Value).Detach));
end;

function TTextGenerationParameters.Grammar(
  const Value: string): TTextGenerationParameters;
begin
  Result := TTextGenerationParameters(Add('grammar', TResponseFormat.Regex(Value).Detach));
end;

function TTextGenerationParameters.MaxNewTokens(
  const Value: Integer): TTextGenerationParameters;
begin
  Result := TTextGenerationParameters(Add('max_new_tokens', Value));
end;

function TTextGenerationParameters.RepetitionPenalty(
  const Value: Double): TTextGenerationParameters;
begin
  Result := TTextGenerationParameters(Add('repetition_penalty', Value));
end;

function TTextGenerationParameters.ReturnFullText(
  const Value: Boolean): TTextGenerationParameters;
begin
  Result := TTextGenerationParameters(Add('return_full_text', Value));
end;

function TTextGenerationParameters.Seed(
  const Value: Integer): TTextGenerationParameters;
begin
  Result := TTextGenerationParameters(Add('seed', Value));
end;

function TTextGenerationParameters.Stop(
  const Value: TArray<string>): TTextGenerationParameters;
begin
  Result := TTextGenerationParameters(Add('stop', Value));
end;

function TTextGenerationParameters.Temperature(
  const Value: Double): TTextGenerationParameters;
begin
  Result := TTextGenerationParameters(Add('temperature', Value));
end;

function TTextGenerationParameters.TopK(
  const Value: Integer): TTextGenerationParameters;
begin
  Result := TTextGenerationParameters(Add('top_k', Value));
end;

function TTextGenerationParameters.TopNtokens(
  const Value: Integer): TTextGenerationParameters;
begin
  Result := TTextGenerationParameters(Add('top_n_tokens', Value));
end;

function TTextGenerationParameters.TopP(
  const Value: Double): TTextGenerationParameters;
begin
  Result := TTextGenerationParameters(Add('top_p', Value));
end;

function TTextGenerationParameters.Truncate(
  const Value: Integer): TTextGenerationParameters;
begin
  Result := TTextGenerationParameters(Add('truncate', Value));
end;

function TTextGenerationParameters.TypicalP(
  const Value: Double): TTextGenerationParameters;
begin
  Result := TTextGenerationParameters(Add('typical_p', Value));
end;

function TTextGenerationParameters.Watermark(
  const Value: Boolean): TTextGenerationParameters;
begin
  Result := TTextGenerationParameters(Add('watermark', Value));
end;

{ TTextGeneration }

destructor TTextGeneration.Destroy;
begin
  for var Item in FItems do
    Item.Free;
  if Assigned(FDelta) then
    FDelta.Free;
  inherited;
end;

{ TTextGenerationItem }

destructor TTextGenerationItem.Destroy;
begin
  if Assigned(FDetails) then
    FDetails.Free;
  inherited;
end;

{ TBestOfSequences }

destructor TBestOfSequences.Destroy;
begin
  for var Item in FPrefill do
    Item.Free;
  for var Item in FTokens do
    Item.Free;
  for var Item in FTopTokens do
    Item.Free;
  inherited;
end;

{ TDetails }

destructor TDetails.Destroy;
begin
  for var Item in FBestOfSequences do
    Item.Free;
  for var Item in FPrefill do
    Item.Free;
  for var Item in FTokens do
    Item.Free;
  for var Item in FTopTokens do
    Item.Free;
  inherited;
end;

{ TSentimentAnalysisParams }

function TSentimentAnalysisParams.Inputs(
  const Value: string): TSentimentAnalysisParams;
begin
  Result := TSentimentAnalysisParams(Add('inputs', Value));
end;

{ TEvals }

destructor TEvals.Destroy;
begin
  for var Item in FItems  do
    Item.Free;
  inherited;
end;

{ TSentimentAnalysis }

destructor TSentimentAnalysis.Destroy;
begin
  for var Item in FItems do
    Item.Free;
  inherited;
end;

{ TTextToSpeechParam }

function TTextToSpeechParam.Inputs(const Value: string): TTextToSpeechParam;
begin
  Result := TTextToSpeechParam(Add('inputs', Value));
end;

{ TTextToSpeech }

function TTextToSpeech.GetStream: TStream;
begin
  {--- Create a memory stream to write the decoded content. }
  Result := TMemoryStream.Create;
  try
    {--- Convert the base-64 string directly into the memory stream. }
    DecodeBase64ToStream(Audio, Result)
  except
    Result.Free;
    raise;
  end;
end;

procedure TTextToSpeech.SaveToFile(const FileName: string);
begin
  try
    Self.FFileName := FileName;
    {--- Perform the decoding operation and save it into the file specified by the FileName parameter. }
    DecodeBase64ToFile(Audio, FileName)
  except
    raise;
  end;
end;

{ TTextToAudioParam }

function TTextToAudioParam.Inputs(
  const Value: string): TTextToAudioParam;
begin
  Result := TTextToAudioParam(Add('inputs', Value));
end;

{ TQuestionAnswering }

destructor TQuestionAnswering.Destroy;
begin
  for var Item in FItems do
    Item.Free;
  inherited;
end;

end.

unit HuggingFace.Types;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiHuggingFace
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, HuggingFace.API.Params;

type
  TCoordinate = TArray<TArray<Integer>>;

  TCoordinateHelper = record helper for TCoordinate
    function ToString: string;
  end;

  {--- Embeddings }
  TTruncationDirection = (
    left,
    right
  );

  TTruncationDirectionHelper = record helper for TTruncationDirection
    function ToString: string;
  end;

  {--- Images }
  TFunctionClassification = (
    sigmoid,
    softmax,
    none
  );

  TFunctionClassificationHelper = record helper for TFunctionClassification
    function ToString: string;
  end;

  {--- Audio }
  TEarlyStopping = (
    never,
    estrue,
    esfalse
  );

  TEarlyStoppingHelper = record helper for TEarlyStopping
    function ToString: string;
  end;

  TSubtaskType = (
    instance,
    panoptic,
    semantic
  );

  TSubtaskTypeHelper = record helper for TSubtaskType
    function ToString: string;
  end;

  {--- Chat }
  TRoleType = (
    user,
    assistant,
    system
  );

  TRoleTypeHelper = record helper for TRoleType
    function ToString: string;
    class function Create(const Value: string): TRoleType; static;
  end;

  TRoleTypeInterceptor = class(TJSONInterceptorStringToString)
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  TContentType = (
    text,
    image_url
  );

  TContentTypeHelper = record helper for TContentType
    function ToString: string;
  end;

  TResponseFormatType = (
    json,
    regex
  );

  TResponseFormatTypeHelper = record helper for TResponseFormatType
    function ToString: string;
  end;

  TToolChoiceType = (
    auto,
    tcnone,
    requiered
  );

  TToolChoiceTypeHelper = record helper for TToolChoiceType
    function ToString: string;
  end;

  TFinishReason = (
    stop,
    length,

    eos_token,
    stop_sequence
  );

  TFinishReasonHelper = record helper for TFinishReason
    function ToString: string;
    class function Create(const Value: string): TFinishReason; static;
  end;

  TFinishReasonInterceptor = class(TJSONInterceptorStringToString)
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  TArgsFixInterceptor = class(TJSONInterceptorStringToString)
  public
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  {--- Schema }
  TSchemaType = (
    TYPE_UNSPECIFIED,
    stSTRING,
    stNUMBER,
    stINTEGER,
    stBOOLEAN,
    stARRAY,
    stOBJECT
  );

  TSchemaTypeHelper = record helper for TSchemaType
    function ToString: string;
  end;

  {--- Text }
  TTextTruncationType = (
    do_not_truncate,
    longest_first,
    only_first,
    only_second
  );

  TTextTruncationTypeHelper = record helper for TTextTruncationType
    function ToString: string;
  end;

  TPaddingType = (
    do_not_pad,
    longest,
    max_length
  );

  TPaddingTypeHelper = record helper for TPaddingType
   function ToString: string;
  end;

  TAggregationStrategyType = (
    asnone,
    simple,
    first,
    average,
    max
  );

  TAggregationStrategyTypeHelper = record helper for TAggregationStrategyType
    function ToString: string;
  end;

implementation

uses
  System.StrUtils, System.Rtti;

{ TTruncationDirectionHelper }

function TTruncationDirectionHelper.ToString: string;
begin
  case Self of
    left:
      Exit('left');
    right:
      Exit('right');
  end;
end;

{ TFunctionClassificationHelper }

function TFunctionClassificationHelper.ToString: string;
begin
  case Self of
    sigmoid:
      Exit('sigmoid');
    softmax:
      Exit('softmax');
    none:
      Exit('none');
  end;
end;

{ TSubtaskTypeHelper }

function TSubtaskTypeHelper.ToString: string;
begin
  case Self of
    instance:
      Exit('instance');
    panoptic:
      Exit('panoptic');
    semantic:
      Exit('semantic');
  end;
end;

{ TEarlyStoppingHelper }

function TEarlyStoppingHelper.ToString: string;
begin
  case Self of
    never:
      Exit('never');
    estrue:
      Exit('true');
    esfalse:
      Exit('false');
  end;
end;

{ TRoleTypeHelper }

class function TRoleTypeHelper.Create(const Value: string): TRoleType;
begin
  var index := IndexStr(AnsiLowerCase(Value), ['user', 'assistant', 'system']);
  if index = -1 then
    raise Exception.Create('String role value not correct');
  Result := TRoleType(index);
end;

function TRoleTypeHelper.ToString: string;
begin
  case Self of
    user:
      Exit('user');
    assistant:
      Exit('assistant');
    system:
      Exit('system');
  end;
end;

{ TRoleTypeInterceptor }

function TRoleTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TRoleType>.ToString;
end;

procedure TRoleTypeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TRoleType.Create(Arg)));
end;

{ TContentTypeHelper }

function TContentTypeHelper.ToString: string;
begin
  case Self of
    text:
      Exit('text');
    image_url:
      Exit('image_url');
  end;
end;

{ TResponseFormatTypeHelper }

function TResponseFormatTypeHelper.ToString: string;
begin
  case Self of
    json:
      Exit('json');
    regex:
      Exit('regex');
  end;
end;

{ TToolChoiceTypeHelper }

function TToolChoiceTypeHelper.ToString: string;
begin
  case Self of
    auto:
      Exit('auto');
    tcnone:
      Exit('none');
    requiered:
      Exit('requiered');
  end;
end;

{ TFinishReasonHelper }

class function TFinishReasonHelper.Create(const Value: string): TFinishReason;
begin
  var index := IndexStr(AnsiLowerCase(Value), ['stop', 'length', 'eos_token', 'stop_sequence']);
  if index = -1 then
    raise Exception.Create('String finish reason value not correct');
  Result := TFinishReason(index);
end;

function TFinishReasonHelper.ToString: string;
begin
  case self of
    stop:
      Exit('stop');
    length:
      Exit('length');
    eos_token:
      Exit('eos_token');
    stop_sequence:
      Exit('stop_sequence');
  end;
end;

{ TFinishReasonInterceptor }

function TFinishReasonInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TFinishReason>.ToString;
end;

procedure TFinishReasonInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TFinishReason.Create(Arg)));
end;

{ TArgsFixInterceptor }

procedure TArgsFixInterceptor.StringReverter(Data: TObject; Field, Arg: string);
begin
  Arg := Format('{%s}', [Trim(Arg.Replace('`', '"').Replace(#10, ''))]);
  while Arg.Contains(', ') do Arg := Arg.Replace(', ', ',');
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, Arg.Replace(',', ', '));
end;

{ TSchemaTypeHelper }

function TSchemaTypeHelper.ToString: string;
begin
  case Self of
    TYPE_UNSPECIFIED:
      Exit('type_unspecified');
    stSTRING:
      Exit('string');
    stNUMBER:
      Exit('number');
    stINTEGER:
      Exit('integer');
    stBOOLEAN:
      Exit('boolean');
    stARRAY:
      Exit('array');
    stOBJECT:
      Exit('object');
  end;
end;

{ TTextTruncationTypeHelper }

function TTextTruncationTypeHelper.ToString: string;
begin
  case Self of
    do_not_truncate:
      Exit('do_not_truncate');
    longest_first:
      Exit('longest_first');
    only_first:
      Exit('only_first');
    only_second:
      Exit('only_second');
  end;
end;

{ TPaddingTypeHelper }

function TPaddingTypeHelper.ToString: string;
begin
  case Self of
    do_not_pad:
      Exit('do_not_pad');
    longest:
      Exit('longest');
    max_length:
      Exit('max_length');
  end;
end;

{ TCoordinateHelper }

function TCoordinateHelper.ToString: string;
begin
  Result := EmptyStr;
  for var i := 0 to High(Self) do
    if Result.IsEmpty then
      Result := Format('[%s, %s]', [Self[0][0].ToString, Self[0][1].ToString]) else
      Result := Format('%s,  [%s, %s]', [Result, Self[0][0].ToString, Self[0][1].ToString]);
end;

{ TAggregationStrategyTypeHelper }

function TAggregationStrategyTypeHelper.ToString: string;
begin
  case Self of
    asnone:
      Exit('none');
    simple:
      Exit('simple');
    first:
      Exit('first');
    average:
      Exit('average');
    max:
      Exit('max');
  end;
end;

end.

unit Vcl.HuggingFace.Tutorial;

{ Tutorial Support Unit

   WARNING:
     This module is intended solely to illustrate the examples provided in the
     README.md file of the repository :
         https://github.com/MaxiDonkey/DelphiHuggingFace
     Under no circumstances should the methods described below be used outside
     of the examples presented on the repository's page.
}

interface

uses
  System.SysUtils, System.Classes, Winapi.Messages, Vcl.StdCtrls, Vcl.ExtCtrls,
  Vcl.Controls, Vcl.Forms, Winapi.Windows, Vcl.Graphics, Vcl.Imaging.jpeg,
  Vcl.Imaging.pngimage, Vcl.Dialogs, Vcl.MPlayer,
  HuggingFace.Types, HuggingFace.Aggregator;

type
  TToolFunc = procedure (Sender: TObject; Text: string) of object;

  TVCLHuggingFaceSender = class
  private
    FMemo1: TMemo;
    FImage1: TImage;
    FImage2: TImage;
    FUrlNext: string;
    FMediaPlayer: TMediaPlayer;
    FFunc: IFunctionCore;
    FFuncProc: TToolFunc;
    TempGraphic: TGraphic;
    FFileName: string;
    FStartMessage: string;
    FEndMessage: string;
    procedure SetFileName(const Value: string);
  public
    procedure LoadImageFromFile(const FilePath: TFileName);
    procedure Play;
    property Memo1: TMemo read FMemo1 write FMemo1;
    property Image1: TImage read FImage1 write FImage1;
    property Image2: TImage read FImage2 write FImage2;
    property UrlNext: string read FUrlNext write FUrlNext;
    property FuncProc: TToolFunc read FFuncProc write FFuncProc;
    property Func: IFunctionCore read FFunc write FFunc;
    property FileName: string read FFileName write SetFileName;
    property MediaPlayer: TMediaPlayer read FMediaPlayer write FMediaPlayer;
    property StartMessage: string read FStartMessage write FStartMessage;
    property EndMessage: string read FEndMessage write FEndMessage;
    constructor Create(const AMemo1: TMemo; const AImage1, AImage2: TImage; const AMediaPlayer: TMediaPlayer);
    destructor Destroy; override;
  end;

  TImageHelper = class helper for TImage
    procedure AssignGraphic(const Value: TGraphic);
    procedure DrawTransparentRectangle(Value: TRect; Color: TColor; Alpha: Byte);
    function HighlightObject(const Value: TRect): TRect;
  end;

  procedure Start(Sender: TObject);

  procedure Display(Sender: TObject; Value: string); overload;
  procedure Display(Sender: TObject; Value: TArray<string>); overload;
  procedure Display(Sender: TObject; Value: TChat); overload;
  procedure Display(Sender: TObject; Value: TModels); overload;
  procedure Display(Sender: TObject; Value: TAudioToText); overload;
  procedure Display(Sender: TObject; Value: TEmbeddings); overload;
  procedure Display(Sender: TObject; Value: TMask); overload;
  procedure Display(Sender: TObject; Value: TImageClassification); overload;
  procedure Display(Sender: TObject; Value: TImageSegmentation); overload;
  procedure Display(Sender: TObject; Value: TObjectDetection); overload;
  procedure Display(Sender: TObject; Value: TAudioClassification); overload;
  procedure Display(Sender: TObject; Value: TQuestionAnswering); overload;
  procedure Display(Sender: TObject; Value: TSummarization); overload;
  procedure Display(Sender: TObject; Value: TTableQA); overload;
  procedure Display(Sender: TObject; Value: TTextClassification); overload;
  procedure Display(Sender: TObject; Value: TTextToImage); overload;
  procedure Display(Sender: TObject; Value: TTokenClassification); overload;
  procedure Display(Sender: TObject; Value: TTranslation); overload;
  procedure Display(Sender: TObject; Value: TZeroShotClassification); overload;
  procedure Display(Sender: TObject; Value: TTextGeneration); overload;
  procedure Display(Sender: TObject; Value: TSentimentAnalysis); overload;
  procedure Display(Sender: TObject; Value: TTextToSpeech); overload;
  procedure Display(Sender: TObject; Value: TAudioToAudio); overload;
  procedure Display(Sender: TObject; Value: TImageSegmentationItem); overload;
  procedure Display(Sender: TObject; Value: TObjectDetectionItem); overload;

  procedure DisplayStream(Sender: TObject; Value: string); overload;
  procedure DisplayStream(Sender: TObject; Value: TChat); overload;
  procedure DisplayStream(Sender: TObject; Value: TTextGeneration); overload;

var
  HFTutorial: TVCLHuggingFaceSender = nil;

implementation

uses
  System.StrUtils;

procedure Start(Sender: TObject);
begin
  Display(Sender, HFTutorial.StartMessage);
end;

procedure Display(Sender: TObject; Value: string);
var
  M: TMemo;
begin
  if Sender is TMemo then
    M := Sender as TMemo else
    M := (Sender as TVCLHuggingFaceSender).Memo1;
  M.Lines.Text := M.Text + Value + sLineBreak;
  M.Perform(WM_VSCROLL, SB_BOTTOM, 0);
end;

procedure Display(Sender: TObject; Value: TArray<string>);
begin
  var index := 0;
  for var Item in Value do
    begin
      if index = 0 then
        Display(Sender, Item) else
      if not Item.IsEmpty then
        Display(Sender, '    . ' + Item) else
        Display(Sender, EmptyStr);
      Inc(index);
    end;
end;

procedure Display(Sender: TObject; Value: TChat);
var
  M: TMemo;
begin
  if Sender is TMemo then
    M := Sender as TMemo else
    M := (Sender as TVCLHuggingFaceSender).Memo1;
  for var Item in Value.Choices do
    begin
      if Assigned(HFTutorial.FFuncProc) then
        for var SubItem in Item.Message.ToolCalls do
          begin
            HFTutorial.FFuncProc(M, HFTutorial.Func.Execute(SubItem.&Function.Arguments));
          end;
      Display(M, Item.Message.Content);
    end;
end;

procedure Display(Sender: TObject; Value: TModels);
var
  M: TMemo;
begin
  if Sender is TMemo then
    M := Sender as TMemo else
    M := (Sender as TVCLHuggingFaceSender).Memo1;
  HFTutorial.UrlNext := Value.UrlNext;
  for var Item in Value.Items do
    begin
//      if IndexStr(Item.Inference.ToLower, ['cold', 'warm']) > -1 then
//        Display(M, Format('%s (%s)', [Item.Id, Item.Inference]))
//      else
        DisplayStream(M, Format('%s (%s) '#10, [Item.Id, Item.Inference]));
    end;
  if Value.UrlNext.IsEmpty then
    Display(M, EmptyStr);
end;

procedure Display(Sender: TObject; Value: TAudioToText);
begin
  Display(Sender, Value.Text);
  if System.Length(Value.Chunks) > 0 then
    for var Item in Value.Chunks do
      begin
        Display(Sender, '  . ' + Item.Text);
        for var SubItem  in Item.Timestamps do
          Display(Sender, '     > ' + SubItem.ToString(ffNumber, 4, 4));
      end;
end;

procedure Display(Sender: TObject; Value: TEmbeddings);
begin
  for var Item in Value.Items do
    Display(Sender, Item.ToString);
end;

procedure Display(Sender: TObject; Value: TMask);
begin
  for var Item in Value.Items do
    Display(Sender, [Item.Sequence, Item.TokenStr, Item.Score.ToString, Item.Token.ToString, EmptyStr]);
end;

procedure Display(Sender: TObject; Value: TImageClassification);
begin
  for var Item in Value.Items do
    Display(Sender, [Item.&Label, Item.Score.ToString(ffNumber, 5, 5)]);
end;

procedure Display(Sender: TObject; Value: TImageSegmentation);
begin
  for var Item in Value.Items do
    begin
      Display(Sender, [Item.&Label, Item.Score.ToString(ffNumber, 2, 2)]);
      Display(HFTutorial.Image2, Item);
    end;
end;

procedure Display(Sender: TObject; Value: TObjectDetection);
begin
  for var Item in Value.Items do
    begin
      Display(Sender, [Item.&Label, Item.Score.ToString(ffNumber, 2,2)]);
      Display(HFTutorial.Image1, Item);
    end;
end;

procedure Display(Sender: TObject; Value: TAudioClassification);
begin
  for var Item in Value.Items do
    Display(Sender, [Item.&Label, Item.Score.ToString]);
end;

procedure Display(Sender: TObject; Value: TQuestionAnswering);
begin
  if System.Length(Value.Items) = 0 then
    begin
      with Value do
        Display(Sender, [Answer, Score.ToString(ffNumber, 2,2), Start.ToString, &End.ToString]);
    end
  else
    begin
      for var Item in Value.Items do
        with Item do
          Display(Sender, [Answer, Score.ToString(ffNumber, 2,2), Start.ToString, &End.ToString]);
    end;
end;

procedure Display(Sender: TObject; Value: TSummarization);
begin
  for var Item in Value.Items do
    Display(Sender, Item.SummaryText);
end;

procedure Display(Sender: TObject; Value: TTableQA);
begin
  with Value do
    Display(Sender, [Answer, Coordinates.ToString, string.Join(', ', Cells), Aggregator]);
end;

procedure Display(Sender: TObject; Value: TTextClassification);
begin
  for var Item in Value.Items do
    for var SubItem in Item.Items do
      Display(Sender, [SubItem.&Label, SubItem.Score.ToString(ffNumber, 5, 5)]);
end;

procedure Display(Sender: TObject; Value: TTextToImage);
begin
  Display(Sender, HFTutorial.FEndMessage);
  var Stream := Value.GetStream;
  try
    HFTutorial.Image1.Picture.LoadFromStream(Stream);
    if not HFTutorial.FileName.IsEmpty then
      Value.SaveToFile(HFTutorial.FileName);
  finally
    Stream.Free;
  end;
end;

procedure Display(Sender: TObject; Value: TTokenClassification);
begin
  for var Item in Value.Items do
    Display(Sender,
      [Item.EntityGroup, Item.Score.ToString(ffNumber, 5, 5),
       Item.Word, Item.Start.ToString, Item.&end.ToString, Item.Entity]);
end;

procedure Display(Sender: TObject; Value: TTranslation);
begin
  for var Item in Value.Items do
    Display(HFTutorial, Item.TranslationText);
end;

procedure Display(Sender: TObject; Value: TZeroShotClassification);
begin
  Display(HFTutorial, Value.Sequence);
  var Index := 0;
  for var Item in Value.Labels do
    begin
      Display(HFTutorial, '   . ' + Item + ' : ' + Value.Scores[Index].ToString(ffNumber, 5, 5));
      Inc(Index);
    end;
end;

procedure Display(Sender: TObject; Value: TTextGeneration);
begin
  for var Item in Value.Items do
    Display(HFTutorial, Item.GeneratedText);
end;

procedure Display(Sender: TObject; Value: TSentimentAnalysis);
begin
  for var Item in Value.Items do
    begin
      for var SubItem in Item.Evals do
        begin
          Display(Sender, [SubItem.&Label, SubItem.Score.ToString(ffNumber, 4, 4)]);
        end;
    end;
end;

procedure Display(Sender: TObject; Value: TTextToSpeech);
begin
  Display(Sender, HFTutorial.EndMessage);
  if HFTutorial.FileName.IsEmpty then
    raise Exception.Create('Set filename value in HFTutorial instance');
  Value.SaveToFile(HFTutorial.FileName);
  HFTutorial.Play;
end;

procedure Display(Sender: TObject; Value: TAudioToAudio);
begin
  if HFTutorial.FileName.IsEmpty then
    raise Exception.Create('Set filename value in HFTutorial instance');
  Value.SaveToFile(HFTutorial.FileName);
  HFTutorial.Play;
end;

procedure Display(Sender: TObject; Value: TImageSegmentationItem);
begin
  var Image := Sender as TImage;
  var Stream: TStream := nil;
  try
    Stream := Value.GetStream;
    Image.Picture.LoadFromStream(Stream);
    ShowMessage('Next');
  finally
    Stream.Free;
  end;
end;

procedure Display(Sender: TObject; Value: TObjectDetectionItem);
begin
  var Image := Sender as TImage;
  Image.HighlightObject(Value.ToRect);
  ShowMessage('Next');
  Image.AssignGraphic(HFTutorial.TempGraphic);
end;

procedure DisplayStream(Sender: TObject; Value: string);
var
  M: TMemo;
begin
  if Sender is TMemo then
    M := Sender as TMemo else
    M := (Sender as TVCLHuggingFaceSender).Memo1;
  M.Lines.Text := M.Text + Value;
  M.Perform(WM_VSCROLL, SB_BOTTOM, 0);
end;

procedure DisplayStream(Sender: TObject; Value: TChat);
begin
  for var Item in Value.Choices do
    DisplayStream(Sender, Item.Delta.Content);
end;

procedure DisplayStream(Sender: TObject; Value: TTextGeneration);
begin
  DisplayStream(HFTutorial, Value.Delta.Text);
end;

{ TVCLHuggingFaceSender }

constructor TVCLHuggingFaceSender.Create(const AMemo1: TMemo;
  const AImage1, AImage2: TImage; const AMediaPlayer: TMediaPlayer);
begin
  inherited Create;
  FMemo1 := AMemo1;
  FImage1 := AImage1;
  FImage2 := AImage2;
  FMediaPlayer := AMediaPlayer;
  FStartMessage := 'Please wait...';
  FEndMessage := 'Process ended...';
end;

destructor TVCLHuggingFaceSender.Destroy;
begin
  TempGraphic.Free;
  inherited;
end;

procedure TVCLHuggingFaceSender.LoadImageFromFile(const FilePath: TFileName);
begin
  if not FileExists(FilePath) then
    raise Exception.CreateFmt('File not found (%s)', [FilePath]);

  if Assigned(TempGraphic) then
    TempGraphic.Free;

  if SameText(ExtractFileExt(FilePath), '.jpg') or SameText(ExtractFileExt(FilePath), '.jpeg') then
    TempGraphic := TJPEGImage.Create
  else
  if SameText(ExtractFileExt(FilePath), '.png') then
    TempGraphic := TPngImage.Create
  else
    raise Exception.Create('Format d''image non pris en charge.');

  TempGraphic.LoadFromFile(FilePath);
  Image1.AssignGraphic(TempGraphic);
end;

procedure TVCLHuggingFaceSender.Play;
begin
  with HFTutorial.MediaPlayer do
    begin
      FileName := HFTutorial.FileName;
      Open;
      Play;
    end;
end;

procedure TVCLHuggingFaceSender.SetFileName(const Value: string);
begin
  FFileName := Value;
  FMediaPlayer.Close;
end;

{ TImageHelper }

procedure TImageHelper.AssignGraphic(const Value: TGraphic);
begin
  Picture.Bitmap.Assign(Value);
end;

procedure TImageHelper.DrawTransparentRectangle(Value: TRect;
  Color: TColor; Alpha: Byte);
type
  TRGBTripleArray = array[0..MaxInt div SizeOf(TRGBTriple) - 1] of TRGBTriple;
  PRGBTripleArray = ^TRGBTripleArray;
var
  X, Y: Integer;
  R, G, B: Byte;
  SrcR, SrcG, SrcB: Byte;
  Row: PRGBTripleArray;
  Bitmap: TBitmap;
begin
  R := GetRValue(Color);
  G := GetGValue(Color);
  B := GetBValue(Color);

  Bitmap := Picture.Bitmap;
  Bitmap.PixelFormat := pf24bit;

  for Y := Value.Top to Value.Bottom - 1 do
  begin
    Row := Bitmap.ScanLine[Y];
    for X := Value.Left to Value.Right - 1 do
    begin
      SrcR := Row[X].rgbtRed;
      SrcG := Row[X].rgbtGreen;
      SrcB := Row[X].rgbtBlue;

      Row[X].rgbtRed := (SrcR * (255 - Alpha) + R * Alpha) div 255;
      Row[X].rgbtGreen := (SrcG * (255 - Alpha) + G * Alpha) div 255;
      Row[X].rgbtBlue := (SrcB * (255 - Alpha) + B * Alpha) div 255;
    end;
  end;

  Invalidate;
end;

function TImageHelper.HighlightObject(const Value: TRect): TRect;
begin
  DrawTransparentRectangle(Value, clYellow, 128);
end;

initialization
finalization
  if Assigned(HFTutorial) then
    HFTutorial.Free;
end.

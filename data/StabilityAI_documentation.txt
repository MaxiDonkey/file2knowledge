# Delphi StabilityAI API

___
![GitHub](https://img.shields.io/badge/IDE%20Version-Delphi%2010.3/11/12-yellow)
![GitHub](https://img.shields.io/badge/platform-all%20platforms-green)
![GitHub](https://img.shields.io/badge/Updated%20the%2011/23/2024-blue)

<br/>
<br/>

- [Introduction](#Introduction)
    - [Who is Stability AI](#Who-is-Stability-AI)
    - [Remarks](#remarks)
- [Stability AI console](#Stability-AI-console)
- [Asynchronous callback mode management](#Asynchronous-callback-mode-management)
- [Generate](#Generate)
    - [Stable Image Ultra](#Stable-Image-Ultra)
        - [Text to image](#Text-to-image)
        - [Tools for simplifying this tutorial](#Tools-for-simplifying-this-tutorial)
        - [Image and text to image](#Image-and-text-to-image)
    - [Stable Image Core](#Stable-Image-Core)
        - [Image Core Create](#Image-Core-Create)
        - [Using a preset style](#Using-a-preset-style )
    - [Stable Diffusion](#Stable-Diffusion)
        - [Generating with a prompt](#Generating-with-a-prompt)
        - [Generating with a prompt and an image](#Generating-with-a-prompt-and-an-image)
        - [Optional Parameters](#Optional-Parameters)
    - [SDXL and SD version 1](#SDXL-and-SD-version-1)
        - [Text to image prompting](#Text-to-image-prompting)
        - [Image to image with prompt](#Image-to-image-with-prompt)
        - [Image to image with mask](#Image-to-image-with-mask)
- [Upscale](#Upscale)
    - [Conservative](#Conservative)
    - [Creative Upscale](#Creative-Upscale)
        - [Fetch async generation result](#Fetch-async-generation-result)
    - [Fast](#Fast)
- [Edit](#Edit)
    - [Erase](#Erase)
    - [Inpaint](#Inpaint)
    - [Outpaint](#Outpaint)
    - [Search and Replace](#Search-and-Replace)
    - [Search and Recolor](#Search-Recolor)
    - [Remove Background](#Remove-Background)
    - [Replace Background and Relight](#Replace-Background-and-Relight)
- [Control](#Control)
    - [Sketch](#Sketch)
    - [Structure](#Structure)
    - [Style](#Style)
- [Results](#Results)
- [3D](#3D)
- [Video](#Video)
- [Other Features of Version 1](#Other-Features-of-Version-1)
    - [Model list](#Model-list)
    - [User account](#User-account)
    - [User balance](#User-balance)
- [New features announced](#New-features-announced)
- [Contributing](#contributing)
- [License](#license)
 
<br/>
<br/>

# Introduction

## Who is Stability AI

`Stability.ai` is a well-established organization in artificial intelligence, known for its models that generate images and text from descriptions. Below is a summary of the key models they have developed, presented in chronological order of release:

Image Generation Models:

- `Stable Diffusion` (August 2022)
The first latent diffusion model, capable of generating images based on textual descriptions.

- `Stable Diffusion 2.0` (November 2022)
An updated version with improved image quality, support for higher resolutions, and additional features.

- `Stable Diffusion XL (SDXL)` (April 2023)
Focused on photorealism, this version introduced improvements in image composition and face generation.

- `Stable Diffusion 3.0` (February 2024)
Featuring a new architecture that combines diffusion transformers and flow matching, this version enhances performance for multi-subject queries and overall image quality.

- `Stable Cascade` (February 2024)
Built on the WÃ¼rstchen architecture, this model improves accuracy and efficiency in text-to-image generation.

- `Stable Diffusion 3.5` (October 2024)
Includes variants such as Stable Diffusion 3.5 Large and 3.5 Medium, offering more options for diverse generation tasks with optimized efficiency.

<br/>

## Remarks

> [!IMPORTANT]
>
> This is an unofficial library. **Stability.ai** does not provide any official library for `Delphi`.
> This repository contains `Delphi` implementation over [Stability.ai](https://platform.stability.ai/docs/api-reference/) public API.

<br/>

# Stability AI console

You can access the [Stability.ai console](https://platform.stability.ai/) to explore the available possibilities.

To obtain an API key, you need to create an account. A credit of 25 will be granted to you, and an initial key will be automatically generated. You can find this key [here](https://platform.stability.ai/account/keys).

Once you have a token, you can initialize `IStabilityAI` interface, which is an entry point to the API.

> [!NOTE]
>```Pascal
>uses StabilityAI;
>
>var Stability := TStabilityAIFactory.CreateInstance(API_KEY);
>```

>[!Warning]
> To use the examples provided in this tutorial, especially to work with asynchronous methods, I recommend defining the stability interface with the widest possible scope.
><br/>
> So, set `Stability := TStabilityAIFactory.CreateInstance(API_KEY);` in the `OnCreate` event of your application.
><br/> 
>Where `Stability: IStabilityAI;`

<br/>

# Asynchronous callback mode management

In the context of asynchronous methods, for a method that does not involve streaming, callbacks use the following generic record: `TAsynCallBack<T> = record` defined in the `StabilityAI.Async.Support.pas` unit. This record exposes the following properties:

```Pascal
   TAsynCallBack<T> = record
   ... 
       Sender: TObject;
       OnStart: TProc<TObject>;
       OnSuccess: TProc<TObject, T>;
       OnError: TProc<TObject, string>; 
```
<br/>

The name of each property is self-explanatory; if needed, refer to the internal documentation for more details.

> [!NOTE]
>In the rest of the tutorial, we will primarily use anonymous methods unless otherwise specified, as working with APIs requires it due to processing times that can sometimes be quite long.
>

<br/>

# Generate

## Stable Image Ultra

**Stable Image Ultra** use the Diffusion 3.5 model. This method is distinguished by:

- **Advanced Prompt Understanding:** Fine and precise analysis of descriptions, even complex ones.
- **Typography Mastery:** Ability to integrate readable and aesthetically pleasing text elements.
- **Complex Compositions:** Harmonious management of detailed, multi-element scenes.
- **Dynamic Lighting:** Rendering of natural, dramatic, or artistic lighting effects.
- **Vibrant Colors:** Rich palettes, dynamic nuances, and visual depth.
- **Cohesion and Structure:** Creation of balanced, well-structured images with no inconsistencies.

### Text to image

**Asynchronous Code Example**

```Pascal
//uses StabilityAI, StabilityAI.Types, StabilityAI.Common, StabilityAI.StableImage.Generate;

  Stability.StableImage.Generate.ImageUltra(
    procedure (Params: TStableImageUltra)
    begin
      Params.AspectRatio(ratio16x9);
      Params.Prompt('Lighthouse on a cliff overlooking the ocean');
      //A blurb of text describing what you do not wish to see in the output image.
      //Params.NegativePrompt('...')
      Params.OutputFormat(png);
    end,
    function : TAsynStableImage
    begin
      //Add a TImage on the form
      //Add a TMemo on the form
      Result.Sender := Image1;

      Result.OnStart :=
        procedure (Sender: TObject)
        begin
          Memo1.Lines.Text := Memo1.Text + 'The generation has started. Please wait...' + sLineBreak;
        end;

      Result.OnSuccess :=
        procedure (Sender: TObject; Image: TStableImage)
        begin
          var Stream := Image.GetStream;
          try
            Image.SaveToFile('lighthouse.png');
            //for VCL 
            Image1.Picture.LoadFromStream(Stream);
            //for FMX
            //Image1.Bitmap.LoadFromStream(Stream);
            Memo1.Lines.Text := Memo1.Text + 'Generation ended successfully' + sLineBreak;
          finally
            Stream.Free;
          end;
        end;

      Result.OnError :=
        procedure (Sender: TObject; Error: String)
        begin
          Memo1.Lines.Text := Memo1.Text + Error + sLineBreak;
        end;
    end);
```
Detailed settings on the [official documentation](https://platform.stability.ai/docs/api-reference#tag/Generate/paths/~1v2beta~1stable-image~1generate~1ultra/post)

<br/>

### Tools for simplifying this tutorial

To simplify the example codes provided in this tutorial, I have included two units in the source code: `VCL.Stability.Tutorial` and `FMX.Stability.Tutorial`. Depending on the option you choose to test the provided source code, you will need to instantiate either the `TVCLStabilitySender` or `TFMXStabilitySender` class in the application's `OnCreate` event, as follows:

>[!TIP]
>```Pascal
>//uses VCL.Stability.Tutorial;
>
>  StabilityResult := TVCLStabilitySender.Create(Memo1, Image1);
>```
>
>or
>
>```Pascal
>//uses FMX.Stability.Tutorial;
>
>  StabilityResult := TFMXStabilitySender.Create(Memo1, Image1);
>```
>

Make sure to add a `TMemo` and a `TImage` component to your form beforehand.

<br/>

### Image and text to image

It is also possible to provide a reference image to use as a starting point for generation. In this case, the `strength` parameter must be specified, as it determines the influence of the input image on the final output. A `strength` value of 0 will produce an image identical to the input, while a value of 1 indicates no influence from the initial image.

```Pascal
//uses StabilityAI, StabilityAI.Types, StabilityAI.Common, StabilityAI.StableImage.Generate, FMX.Stability.Tutorial;

  StabilityResult.FileName := 'lighthouse1.png';

  Stability.StableImage.Generate.ImageUltra(
    procedure (Params: TStableImageUltra)
    begin
      Params.AspectRatio(ratio16x9);
      Params.Prompt('There are many birds in the sky');
      Params.Image('lighthouse.png');
      Params.Strength(0.3);
      Params.OutputFormat(png);
    end,
    function : TAsynStableImage
    begin
      Result.Sender := StabilityResult;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

## Stable Image Core
**Specificity:**
- `Stable Image Core` is a text-to-image generation service designed to deliver premium quality with speed. Unlike other similar tools, it requires no expertise in "prompt engineering." Users simply describe a style, scene, or character, and the tool generates an image that aligns with their description.

<br/>

**Key Points:**
- **Premium Quality:** Produces high-quality images, perfect for creative and professional uses.
- **Ease of Use:** No need for complex prompt-writing techniques.
- **Speed:** Near-instant image generation, even for detailed descriptions.
- **Flexibility:** Handles a wide range of requests, from artistic styles to specific scenes or characters.
- **Reliability:** Delivers consistent results that align with provided descriptions without requiring adjustments.

<br/>

**Applications Inventory:**
- **Design and Creative Work:** Ideal for creating visuals for graphic design projects or illustrations.
- **Communication and Marketing:** Quickly generates eye-catching visuals for campaigns.
- **Creative Exploration:** Visualizes abstract ideas or concepts.
- **Education and Training:** Produces illustrations for courses or educational materials.
- **Rapid Prototyping:** Helps quickly design images for pitches or ongoing projects.

<br/>

### Image Core Create

**Asynchronous Code Example**

```Pascal
//uses StabilityAI, StabilityAI.Types, StabilityAI.Common, StabilityAI.StableImage.Generate, FMX.Stability.Tutorial;

  StabilityResult.FileName := 'lighthouse2.png';

  Stability.StableImage.Generate.ImageCore(
    procedure (Params: TStableImageCore)
    begin
      Params.AspectRatio(ratio16x9);
      Params.Prompt('Lighthouse on a cliff overlooking the ocean');
      Params.OutputFormat(png);
    end,
    function : TAsynStableImage
    begin
      Result.Sender := StabilityResult;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

Detailed settings on the [official documentation](https://platform.stability.ai/docs/api-reference#tag/Generate/paths/~1v2beta~1stable-image~1generate~1core/post)

<br>

### Using a preset style

You can guide the image model toward a specific style by selecting from 17 available styles.

```Pascal
//uses StabilityAI, StabilityAI.Types, StabilityAI.Common, StabilityAI.StableImage.Generate, FMX.Stability.Tutorial;

  StabilityResult.FileName := 'lighthouse3.png';

  Stability.StableImage.Generate.ImageCore(
    procedure (Params: TStableImageCore)
    begin
      Params.AspectRatio(ratio16x9);
      Params.Prompt('Lighthouse on a cliff overlooking the ocean');
      Params.StylePreset(TStylePreset.digitalArt);
      Params.OutputFormat(png);
    end,
    function : TAsynStableImage
    begin
      Result.Sender := StabilityResult;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

## Stable Diffusion

Inventory of available models

**Stable Diffusion 3.5**
- **SD3.5 Large:** Flagship model with 8 billion parameters, delivering exceptional image quality and precise prompt adherence. Ideal for professional use at 1-megapixel resolution.
- **SD3.5 Large Turbo:** A distilled version of **SD3.5 Large**, designed for fast image generation in just 4 steps, while maintaining high quality and excellent prompt fidelity. Perfect for projects requiring quick execution.
- **SD3.5 Medium:** Mid-tier model with 2.5 billion parameters, offering an optimal balance between prompt accuracy and image quality. Best suited for fast and efficient performance.

<br/>

**Stable Diffusion 3.0** (Fireworks AI)
- **SD3 Large:** Model with 8 billion parameters, providing professional-grade performance similar to **SD3.5 Large**.
- **SD3 Large Turbo:** Optimized version for faster execution while maintaining high-quality output.
- **SD3 Medium:** Model with 2 billion parameters, balancing quality and speed for less intensive use cases.

<br/>

**Key Points:**
- **Parameter Count:** Indicates the modelâs power (8B for Large, 2â2.5B for Medium).
- **Speed:** `Turbo` versions generate images faster without sacrificing quality.
- **Applications:** Large models are perfect for detailed and professional projects, while Medium models are ideal for quick, balanced tasks.

<br/>

### Generating with a prompt

This mode creates an image based solely on a textual description. The `prompt` is the only mandatory input, but an optional `aspect_ratio` parameter is available to adjust the dimensions of the resulting image.

**Asynchronous Code Example**

```Pascal
//uses StabilityAI, StabilityAI.Types, StabilityAI.Common, StabilityAI.StableImage.Generate, FMX.Stability.Tutorial;

  StabilityResult.FileName := 'lighthouse4.png';

  Stability.StableImage.Generate.Diffusion(
    procedure (Params: TStableImageDiffusion)
    begin
      Params.AspectRatio(ratio16x9);
      Params.Prompt('Lighthouse on a cliff overlooking the ocean');
      Params.OutputFormat(png);
    end,
    function : TAsynStableImage
    begin
      Result.Sender := StabilityResult;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

Detailed settings on the [official documentation](https://platform.stability.ai/docs/api-reference#tag/Generate/paths/~1v2beta~1stable-image~1generate~1sd3/post)

<br/>

### Generating with a prompt and an image

This method generates an image based on text input while using an existing image as the initial reference. The necessary parameters include:
- `prompt`: the descriptive text that guides the image generation.
- `image`: the starting image that serves as the foundation for the output.
- `strength`: determines the degree to which the starting image influences the final result.
- `mode`: should be set to "image-to-image".

**Asynchronous Code Example**

```Pascal
//uses StabilityAI, StabilityAI.Types, StabilityAI.Common, StabilityAI.StableImage.Generate, FMX.Stability.Tutorial;

  StabilityResult.FileName := 'lighthouse5.png';

  Stability.StableImage.Generate.Diffusion(
    procedure (Params: TStableImageDiffusion)
    begin
      Params.Prompt('There are many birds in the sky');
      Params.Mode(imageToImage);
      Params.Image('lighthouse4.png');
      Params.Strength(0.6);
      Params.OutputFormat(png);
    end,
    function : TAsynStableImage
    begin
      Result.Sender := StabilityResult;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

>[!NOTE]
> Note: maximum request size is 10MiB.
>

<br/>

### Optional Parameters

Both modes allow the use of these optional parameters:
- `model`: Specifies the model to utilize, such as **SD3 Large**, **SD3 Large Turbo**, or **SD3 Medium**.
- `output_format`: Determines the desired format of the resulting image.
- `seed`: Sets the randomness seed for the generation process.
- `negative_prompt`: Defines keywords to exclude from the generated image.
- `cfg_scale`: Adjusts the level of adherence to the prompt text during the diffusion process.

<br/>

## SDXL and SD version 1

### Text to image prompting

**Using SDXL 1.0:** Use `stable-diffusion-xl-1024-v1-0` as the `engine_id` for your request, and specify the dimensions (`height` and `width`) with one of the following combinations:
- **1024x1024** (default)
- **1152x896**
- **896x1152**
- **1216x832**
- **1344x768**
- **768x1344**
- **1536x640**
- **640x1536**

<br/>

**Using SD 1.6**: SD 1.6 is a flexible-resolution base model designed for generating images with non-standard aspect ratios. The model is optimized for a resolution of 512 x 512 pixels. To create outputs with a resolution of 1 megapixel, we recommend using SDXL 1.0, which is available at the same price.

To use this model, set `stable-diffusion-v1-6` as the `engine_id` in your request and ensure the `height` and `width` meet the following requirements:
- Each dimension must be at least 320 pixels.
- No dimension can exceed 1536 pixels.
- Dimensions must be in increments of 64.
- The default resolution is 512 x 512 pixels.

<br/>

**Asynchronous Code Example**

```Pascal
//uses 
//  StabilityAI, StabilityAI.Types, StabilityAI.Common, StabilityAI.StableImage.Generate, 
//  StabilityAI.Version1.SDXL1AndSD1_6, FMX.Stability.Tutorial; 

  StabilityResult.FileName := 'lighthouse6.png';

  Stability.Version1.SDXLAndSDL.TextToImage('stable-diffusion-xl-1024-v1-0',
    procedure (Params: TPayload)
    begin
      Params.TextPrompts([TPrompt.New(1, 'A lighthouse on a cliff') ]);
      Params.CfgScale(7);
      Params.Height(1216);
      Params.Width(832);
      Params.Sampler(TSamplerType.K_DPMPP_2S_ANCESTRAL);
      Params.Samples(1);
      Params.Steps(30);
    end,
    function : TAsynArtifacts
    begin
      Result.Sender := StabilityResult;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```
Detailed settings on the [official documentation](https://platform.stability.ai/docs/api-reference#tag/SDXL-1.0-and-SD1.6/operation/textToImage)

<br/>

### Image to image with prompt

**Adjusting the Degree of Transformation**
- To retain approximately 35% of the original image in the final output, you can use either of these approaches: set `init_image_mode=IMAGE_STRENGTH` with `image_strength=0.35`, or use `init_image_mode=STEP_SCHEDULE` with `step_schedule_start=0.65`. Both methods yield similar results, but the `step_schedule` mode offers additional flexibility by allowing you to specify a `step_schedule_end` value, giving more nuanced control if needed. For further details, refer to the specific parameter descriptions below.

**Asynchronous Code Example**

```Pascal
//uses 
//  StabilityAI, StabilityAI.Types, StabilityAI.Common, StabilityAI.StableImage.Generate, 
//  StabilityAI.Version1.SDXL1AndSD1_6, FMX.Stability.Tutorial; 

  StabilityResult.FileName := 'lighthouse7.png';

  Stability.Version1.SDXLAndSDL.ImageToImageWithPrompt('stable-diffusion-v1-6',
    procedure (Params: TPayloadPrompt)
    begin
      Params.TextPrompts([TPromptMultipart.New(1, 'A dog space commander') ]);
      Params.InitImage('lighthouse6.png');
      Params.ImageStrength(0.45);
      Params.CfgScale(7);
      Params.Sampler(TSamplerType.K_DPMPP_2S_ANCESTRAL);
      Params.Samples(3);
      Params.Steps(30);
    end,
    function : TAsynArtifacts
    begin
      Result.Sender := StabilityResult;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

>[!TIP]
> In our code example, the value of the Samples parameter is 3, which means that three images were generated. Only the first one is displayed. The other two were saved with indexed file names as follows: lighthouse701.png and lighthouse702.png.
>

Detailed settings on the [official documentation](https://platform.stability.ai/docs/api-reference#tag/SDXL-1.0-and-SD1.6/operation/imageToImage)

<br/>

### Image to image with mask

Modify specific parts of an image using a mask. The mask must match the dimensions and shape of the original image. This functionality also supports images with alpha channels. 

use the mÃ©tode:
```Pascal
  ImageToImageWithMask(const Model: string; ParamProc: TProc<TPayloadMask>; 
     CallBacks: TFunc<TAsynArtifacts>);
```

<br/>

# Upscale

Tools to Enhance the Size and Resolution of Your Images

**Conservative Upscaler**
- Upscale images by 20 to 40 times while preserving their original appearance, delivering outputs up to 4 megapixels. This tool works effectively even with images as small as 64x64 pixels, directly scaling them up to 4 megapixels. Choose this option when you need a straightforward 4-megapixel result.

**Creative Upscaler**
- Designed for heavily degraded images (less than 1 megapixel), this service applies a creative approach to generate high-resolution outputs with a unique touch.

**Fast Upscaler**
- This quick and efficient tool is perfect for improving the quality of compressed images, making it a great choice for social media posts and other similar uses.

 <br/>

## Conservative

Accepts images ranging in size from 64x64 pixels up to 1 megapixel and enhances their resolution to 4K. More broadly, it can upscale images by approximately 20 to 40 times while maintaining their original details. The Conservative Upscale option focuses on preserving the image's integrity with minimal modifications and is not intended for reinterpreting the image's content.

**Asynchronous Code Example**

```Pascal
//uses 
//  StabilityAI, StabilityAI.Types, StabilityAI.Common, FMX.Stability.Tutorial,
//  StabilityAI.StableImage.Upscale;

  StabilityResult.FileName := 'Upscalelighthouse1.png';

  Stability.StableImage.Upscale.Conservative(
    procedure (Params: TUpscaleConservative)
    begin
      Params.Image('lighthouse.png');
      Params.Prompt('The light house');
      Params.OutputFormat(png);
    end,
    function : TAsynStableImage
    begin
      Result.Sender := StabilityResult;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

Detailed settings on the [official documentation](https://platform.stability.ai/docs/api-reference#tag/Upscale/paths/~1v2beta~1stable-image~1upscale~1conservative/post)

<br/>

## Creative Upscale

Accepts images ranging from 64x64 pixels to a maximum of 1 megapixel, enhancing their resolution up to 4K. More broadly, it can upscale images by approximately 20 to 40 times while maintainingâand often improvingâtheir quality. The Creative Upscale feature is particularly effective for heavily degraded images, but it is not suited for photos larger than 1 megapixel, as it applies significant reinterpretation (adjustable via the creativity scale).

>[!WARNING]
> This function is labeled as asynchronous by the editor, but in reality, it doesn't behave as such for a third-party application utilizing it. It operates more like a caching mechanism for a slightly delayed processing.
>

**Asynchronous Code Example**

```Pascal
//uses 
//  StabilityAI, StabilityAI.Types, StabilityAI.Common, FMX.Stability.Tutorial,
//  StabilityAI.StableImage.Upscale;

  Stability.StableImage.Upscale.Creative(
    procedure (Params: TUpscaleCreative)
    begin
      Params.Image('lighthouse.png');
      Params.Prompt('The gray light house');
      Params.OutputFormat(png);
    end,
    function : TAsynResults
    begin
      Result.Sender := StabilityResult;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

Detailed settings on the [official documentation](https://platform.stability.ai/docs/api-reference#tag/Upscale/paths/~1v2beta~1stable-image~1upscale~1creative/post)

We retrieve the job ID, and in the next step, we need to load the image unless the status retrieved is "in-progress." In that case, the operation should be retried.

### Fetch async generation result

```Pascal
//uses 
//  StabilityAI, StabilityAI.Types, StabilityAI.Common, FMX.Stability.Tutorial,
//  StabilityAI.StableImage.Results,

  // e.g. Id ---> ea771536f066b7fd03d62384581982ecd8b54a932a6378d5809d43f6e5aa789a
  StabilityResult.FileName := 'Upscalelighthouse2.png';
  
  Stability.StableImage.Results.Fetch(StabilityResult.Id,
    function : TAsynResults
    begin
      Result.Sender := StabilityResult;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

Detailed settings on the [official documentation](https://platform.stability.ai/docs/api-reference#tag/Results/paths/~1v2beta~1results~1%7Bid%7D/get)

<br/>

## Fast

The Fast Upscaler serviceincrease image resolution by 400%. Designed for speed and efficiency, it processes images in approximately one second, making it an excellent tool for improving the clarity of compressed visuals, perfect for social media posts and various other uses.

**Asynchronous Code Example**

```Pascal
//uses 
//  StabilityAI, StabilityAI.Types, StabilityAI.Common, FMX.Stability.Tutorial,
//  StabilityAI.StableImage.Upscale;

  StabilityResult.FileName := 'Upscalelighthouse3.png';

  Stability.StableImage.Upscale.Fast(
    procedure (Params: TUpscaleFast)
    begin
      Params.Image('lighthouse.png');
      Params.OutputFormat(png);
    end,
    function : TAsynStableImage
    begin
      Result.Sender := StabilityResult;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

Detailed settings on the [official documentation](https://platform.stability.ai/docs/api-reference#tag/Upscale/paths/~1v2beta~1stable-image~1upscale~1fast/post) 

<br/>

# Edit

**Feature Inventory**
- **Erase:** Removes unwanted elements.
- **Outpaint:** Extends the image beyond its boundaries.
- **Inpaint:** Edits or replaces specific defined areas.
- **Search and Replace:** Changes objects based on textual instructions.
- **Search and Recolor:** Adjusts the colors of specific objects.
- **Remove Background:** Segments the foreground to eliminate the background.

<br/>

## Erase

The Erase service is designed to eliminate unwanted elements from images, such as imperfections on faces or objects on surfaces, using masking techniques.

`Masks` can be supplied in one of two methods:
1. Directly, by providing a separate image through the `mask` parameter.
2. Indirectly, by extracting it from the alpha channel of the image parameter.

**Asynchronous Code Example**

>[!NOTE]
>- If no specific `mask` is supplied, a mask will automatically be generated based on the image's alpha channel. Transparent areas will be subject to inpainting, while opaque regions will remain unchanged.
>- If an image with an alpha channel is provided together with a `mask`, the `mask` will override the alpha channel.
>

```Pascal
//uses 
//  StabilityAI, StabilityAI.Types, StabilityAI.Common, FMX.Stability.Tutorial,
//  StabilityAI.StableImage.Edit;

  StabilityResult.FileName := 'EraseLighthouse.png';

  Stability.StableImage.Edit.Erase(
    procedure (Params: TErase)
    begin
      Params.Image('Lighthouse.png');
      Params.OutputFormat(png);
    end,
    function: TAsynStableImage
    begin
      Result.Sender := StabilityResult;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

When a mask is provided :

>[!NOTE]
> - The input for this parameter should be a black-and-white image where the intensity of each pixel determines the strength of the inpainting effect. Darker pixels indicate minimal or no inpainting, while lighter pixels represent maximum inpainting intensity, with completely black pixels having no effect and completely white pixels applying the strongest effect.
> - If the `mask`'s dimensions differ from those of the image parameter, it will be automatically adjusted to match the image size.
>

```Pascal
  Stability.StableImage.Edit.Erase(
    procedure (Params: TErase)
    begin
      Params.Image('Lighthouse.png');
      Params.Mask('MyMask01.png');
      Params.GrowMask(6);
      Params.OutputFormat(png);
    end,
   ...
```

Detailed settings on the [official documentation](https://platform.stability.ai/docs/api-reference#tag/Edit/paths/~1v2beta~1stable-image~1edit~1erase/post)

<br/>

## Inpaint

Modify images intelligently by adding or replacing specific sections with new content, guided by a `mask` image.

This `mask` can be supplied in two ways:
- By directly providing a separate image through the mask parameter.
- By extracting it from the alpha channel of the image parameter.

```Pascal
//uses 
//  StabilityAI, StabilityAI.Types, StabilityAI.Common, FMX.Stability.Tutorial,
//  StabilityAI.StableImage.Edit;

  StabilityResult.FileName := 'InpaintLighthouse.png';

  Stability.StableImage.Edit.Inpaint(
    procedure (Params: TInpaint)
    begin
      Params.Image('Lighthouse.png');
      Params.Mask('Mask01.png');
      Params.Prompt('The lighthouse is bigger');
      Params.OutputFormat(png);
    end,
    function: TAsynStableImage
    begin
      Result.Sender := StabilityResult;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

The use of the `mask` is identical to that described with the [erase](#Erase) API.

Detailed settings on the [official documentation](https://platform.stability.ai/docs/api-reference#tag/Edit/paths/~1v2beta~1stable-image~1edit~1inpaint/post)

<br/>

## Outpaint

The Outpaint service allows for the seamless extension of an image by adding content in any direction to fill the surrounding space. Unlike other methods, whether automated or manual, this service is designed to reduce visible artifacts and avoid noticeable indications of image editing.

```Pascal
//uses 
//  StabilityAI, StabilityAI.Types, StabilityAI.Common, FMX.Stability.Tutorial,
//  StabilityAI.StableImage.Edit;

  StabilityResult.FileName := 'OutpaintLighthouse.png';

  Stability.StableImage.Edit.Outpaint(
    procedure (Params: TOutpaint)
    begin
      Params.Image('Lighthouse.png');
      Params.Right(200);
      Params.Down(400);
      Params.OutputFormat(png);
    end,
    function: TAsynStableImage
    begin
      Result.Sender := StabilityResult;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

Detailed settings on the [official documentation](https://platform.stability.ai/docs/api-reference#tag/Edit/paths/~1v2beta~1stable-image~1edit~1outpaint/post)

<br/>

## Search and Replace

The Search and Replace service offers a specialized form of inpainting that eliminates the need for a mask. Instead, users can specify an object to replace by describing it in plain language using a search_prompt. The service will then automatically detect and segment the specified object, seamlessly substituting it with the one described in the prompt.

```Pascal
//uses 
//  StabilityAI, StabilityAI.Types, StabilityAI.Common, FMX.Stability.Tutorial,
//  StabilityAI.StableImage.Edit;

  StabilityResult.FileName := 'SearchReplaceLighthouse.png';

  Stability.StableImage.Edit.SearchAndReplace(
    procedure (Params: TSearchAndReplace)
    begin
      Params.Image('Lighthouse.png');
      Params.Prompt('Replace the lighthouse');
      Params.SearchPrompt('Lighthouse');
      Params.OutputFormat(png);
    end,
    function: TAsynStableImage
    begin
      Result.Sender := StabilityResult;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

Detailed settings on the [official documentation](https://platform.stability.ai/docs/api-reference#tag/Edit/paths/~1v2beta~1stable-image~1edit~1search-and-replace/post)

<br/>

## Search and Recolor

By utilizing the Search and Recolor service, you can change the color of a specific object in an image through a simple prompt. This specialized form of inpainting doesn't require a mask. Instead, the service automatically segments the object and applies the new colors as specified in your prompt.

```Pascal
//uses 
//  StabilityAI, StabilityAI.Types, StabilityAI.Common, FMX.Stability.Tutorial,
//  StabilityAI.StableImage.Edit;

  StabilityResult.FileName := 'SearchRecolorLighthouse.png';

  Stability.StableImage.Edit.SearchAndRecolor(
    procedure (Params: TSearchAndRecolor)
    begin
      Params.Image('Lighthouse.png');
      Params.Prompt('The lighthouse is pink');
      Params.SelectPrompt('Lighthouse');
      Params.OutputFormat(png);
    end,
    function: TAsynStableImage
    begin
      Result.Sender := StabilityResult;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

Detailed settings on the [official documentation](https://platform.stability.ai/docs/api-reference#tag/Edit/paths/~1v2beta~1stable-image~1edit~1search-and-recolor/post)

<br/>

## Remove Background

The Remove Background service precisely identifies and isolates the foreground in an image, allowing for the background to be either removed or replaced as needed.

```Pascal
//uses 
//  StabilityAI, StabilityAI.Types, StabilityAI.Common, FMX.Stability.Tutorial,
//  StabilityAI.StableImage.Edit;

  StabilityResult.FileName := 'RemoveBackgroundLighthouse.png';

  Stability.StableImage.Edit.RemoveBackground(
    procedure (Params: TRemoveBackground)
    begin
      Params.Image('Lighthouse.png');
      Params.OutputFormat(png);
    end,
    function: TAsynStableImage
    begin
      Result.Sender := StabilityResult;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

Detailed settings on the [official documentation](https://platform.stability.ai/docs/api-reference#tag/Edit/paths/~1v2beta~1stable-image~1edit~1remove-background/post)

<br/>

## Replace Background and Relight

The Replace Background and Relight editing service enables to effortlessly change backgrounds using AI-generated images or their own uploads, while seamlessly adjusting lighting to complement the subject. This API offers an efficient image editing solution tailored for various industries, including e-commerce, real estate, photography, and creative endeavors.

Key features include:
- **Background Replacement:** Effortlessly remove the current background and replace it with a new one.
- **AI-Generated Backgrounds:** Generate unique backgrounds with AI based on your chosen prompts.
- **Relighting:** Fine-tune the lighting of images to correct underexposure or overexposure.
- **Customizable Inputs:** Opt for your own uploaded background or create one using AI.
- **Lighting Controls:** Adjust the reference, direction, and intensity of lighting for a polished look.

>[!WARNING]
> This function is labeled as asynchronous by the editor, but in reality, it doesn't behave as such for a third-party application utilizing it. It operates more like a caching mechanism for a slightly delayed processing.
>

```Pascal
//uses 
//  StabilityAI, StabilityAI.Types, StabilityAI.Common, FMX.Stability.Tutorial,
//  StabilityAI.StableImage.Edit;

  Stability.StableImage.Edit.ReplaceBackgroundAndRelight(
    procedure (Params: TReplaceBackgroundAndRelight)
    begin
      Params.SubjectImage('Lighthouse.png');
      Params.BackgroundPrompt('cinematic lighting');
      Params.OutputFormat(png);
    end,
    function: TAsynResults
    begin
      Result.Sender := StabilityResult;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

The API returns the ID of the ongoing task, just like the [Upscale Creative](#Creative-Upscale) API. You then need to use the [Fetch](#Fetch-async-generation-result) API, as previously mentioned.

Detailed settings on the [official documentation](https://platform.stability.ai/docs/api-reference#tag/Edit/paths/~1v2beta~1stable-image~1edit~1replace-background-and-relight/post)

<br/>

# Control

Tools for Creating Controlled Variations of Images and Sketches
- **Sketch:** This feature transforms rough sketches into polished, refined outputs with a high level of precision. For non-sketch images, it offers advanced control over the final look by utilizing the image's contour lines and edges to guide adjustments.
- **Structure:** Designed to maintain the structural integrity of an input image, this tool is ideal for sophisticated content creation tasks, such as reconstructing scenes or rendering characters based on existing models.
- **Style:** By analyzing the stylistic elements of a reference image (control image), this service generates a new image aligned with the style of the reference, guided by the user's prompt. The result is an output that mirrors the artistic essence of the original.

## Sketch

This tool is designed for development workflows involving iterative design and brainstorming. It transforms hand-drawn sketches into polished visuals with precise adjustments. Additionally, it enables fine-tuned control over the final appearance of non-sketch images by utilizing the image's contours and edges.

```Pascal
//uses 
//  StabilityAI, StabilityAI.Types, StabilityAI.Common, FMX.Stability.Tutorial,
//  StabilityAI.StableImage.Control;

  StabilityResult.FileName := 'Control01.png';

  Stability.StableImage.Control.Sketch(
    procedure (Params: TSketch)
    begin
      Params.Image('lighthouse.png');
      Params.ControlStrength(0.7);
      Params.Prompt('a medieval castle on a hill');
      Params.OutputFormat(png);
    end,
    function : TAsynStableImage
    begin
      Result.Sender := StabilityResult;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

Detailed settings on the [official documentation](https://platform.stability.ai/docs/api-reference#tag/Control/paths/~1v2beta~1stable-image~1control~1sketch/post)

<br/>

## Structure

This service is designed to generate images while preserving the structure of an input image, making it particularly useful for tasks like replicating scenes or rendering characters based on predefined models.

```Pascal
//uses 
//  StabilityAI, StabilityAI.Types, StabilityAI.Common, FMX.Stability.Tutorial,
//  StabilityAI.StableImage.Control;

  StabilityResult.FileName := 'Control02.png';

  Stability.StableImage.Control.Structure(
    procedure (Params: TStructure)
    begin
      Params.Image('lighthouse.png');
      Params.ControlStrength(0.7);
      Params.Prompt('a well manicured shrub in an english garden');
      Params.OutputFormat(png);
    end,
    function : TAsynStableImage
    begin
      Result.Sender := StabilityResult;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

Detailed settings on the [official documentation](https://platform.stability.ai/docs/api-reference#tag/Control/paths/~1v2beta~1stable-image~1control~1structure/post)

<br/>

## Style

This tool analyzes the stylistic features of a given input image (control image) and applies them to generate a new image guided by a specified prompt. The output image retains the visual style of the control image while incorporating the requested content.

```Pascal
//uses 
//  StabilityAI, StabilityAI.Types, StabilityAI.Common, FMX.Stability.Tutorial,
//  StabilityAI.StableImage.Control;

  StabilityResult.FileName := 'Control03.png';

  Stability.StableImage.Control.Style(
    procedure (Params: TStyle)
    begin
      Params.Image('lighthouse.png');
      Params.Prompt('a majestic portrait of a chicken');
      Params.Fidelity(0.7);
      Params.OutputFormat(png);
    end,
    function : TAsynStableImage
    begin
      Result.Sender := StabilityResult;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

Detailed settings on the [official documentation](https://platform.stability.ai/docs/api-reference#tag/Control/paths/~1v2beta~1stable-image~1control~1style/post)

<br/>

# Results

Tools for fetching the results of your async generations.

For using, see [Fetch async generation result](#Fetch-async-generation-result) 

<br/>

# 3D

Stable Fast 3D generates high-quality 3D assets from a single 2D input image.

See the [GLB File Format](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#glb-file-format-specification) Specification for more details.

```Pascal
//uses 
//  StabilityAI, StabilityAI.Types, StabilityAI.Common, FMX.Stability.Tutorial,
// StabilityAI.VideoAnd3D.Stable3D;

  StabilityResult.FileName := 'My_Result.gltf';

  Stability.VideoAnd3D.Model3D.Fast3D(
    procedure (Params: TStable3D)
    begin
      Params.Image('My_ImageTo3D.png');
      Params.ForegroundRatio(0.85);
    end,
    function : TAsynModel3D
    begin
      Result.Sender := StabilityResult;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

Detailed settings on the [official documentation](https://platform.stability.ai/docs/api-reference#tag/3D/paths/~1v2beta~13d~1stable-fast-3d/post)

<br/>

# Video

Use [**Stable Video Diffusion**](https://static1.squarespace.com/static/6213c340453c3f502425776e/t/655ce779b9d47d342a93c890/1700587395994/stable_video_diffusion.pdf), a latent video diffusion model, to generate a short video from an initial image.
- After calling this endpoint with the required parameters, retrieve the `ID` from the response to check the results at the `image-to-video/result/{id}` endpoint. Be sure not to poll this endpoint more than once every 10 seconds to avoid errors or rate-limiting issues.

```Pascal
//uses 
//  StabilityAI, StabilityAI.Types, StabilityAI.Common, FMX.Stability.Tutorial,
//  StabilityAI.VideoAnd3D.Video;

  Stability.VideoAnd3D.ImageToVideo.Generation(
    procedure (Params: TVideo)
    begin
      Params.Image('lighthouse1024x576.png');
    end,
    function : TAsynJobVideo
    begin
      Result.Sender := StabilityResult;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

At the end, we retrieve the ID (*e.g. d4fb4aa8301aee0b368a41b3c0a78018dfc28f1f959a3666be2e6951408fb8e3*) of the video creation task. Then, we simply retrieve the result in this way.

Detailed settings on the [official documentation](https://platform.stability.ai/docs/api-reference#tag/Image-to-Video/paths/~1v2beta~1image-to-video/post)

```Pascal
//uses 
//  StabilityAI, StabilityAI.Types, StabilityAI.Common, FMX.Stability.Tutorial,
//  StabilityAI.VideoAnd3D.Video;

  var Id := 'd4fb4aa8301aee0b368a41b3c0a78018dfc28f1f959a3666be2e6951408fb8e3';
  StabilityResult.FileName := 'lighthouse1024x576.mp4';

  Stability.VideoAnd3D.ImageToVideo.Fetch(Id,
    function : TAsynResults
    begin
      Result.Sender := StabilityResult;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

Detailed settings on the [official documentation](https://platform.stability.ai/docs/api-reference#tag/Image-to-Video/paths/~1v2beta~1image-to-video~1result~1%7Bid%7D/get)

<br/>

# Other Features of Version 1

## Model list

List the engines compatible with `Version 1` REST API endpoints.

```Pascal
//uses 
//  StabilityAI, StabilityAI.Types, StabilityAI.Common, FMX.Stability.Tutorial,
//  StabilityAI.Version1.Engines;

  Stability.Version1.Engines.List(
    function : TAsynEngines
    begin
      Result.Sender := StabilityResult;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

Detailed settings on the [official documentation](https://platform.stability.ai/docs/api-reference#tag/Engines/operation/listEngines)

<br/>

## User account

Retrieve details about the account linked to the specified API key

```Pascal
//uses 
//  StabilityAI, StabilityAI.Types, StabilityAI.Common, FMX.Stability.Tutorial,
//  StabilityAI.Version1.User;

  Stability.Version1.User.AccountDetails(
    function : TAsynAccountDetails
    begin
      Result.Sender := StabilityResult;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

Detailed settings on the [official documentation](https://platform.stability.ai/docs/api-reference#tag/User/operation/userAccount)

<br/>

## User balance

Retrieve the credit balance for the account or organization linked to the provided API key.

```Pascal
//uses 
//  StabilityAI, StabilityAI.Types, StabilityAI.Common, FMX.Stability.Tutorial,
//  StabilityAI.Version1.User;

  var Balance := Stability.Version1.User.AccountBalance;
  try
    Memo1.Lines.Text := Memo1.Text + Balance.Credits.ToString + sLineBreak;
  finally
    Balance.Free;
  end;
```

Detailed settings on the [official documentation](https://platform.stability.ai/docs/api-reference#tag/User/operation/userBalance)

<br/>

# New features announced

**Stability.ai** has announced two upcoming features:
- Language generation with its models: `Stable LLM 12B` and `Stable LLM 1.6B`.
- `Audio Stable 2.0`. You can contact Stability.ai to test this model by [sending a message](https://stability.ai/contact).

<br/>

# Contributing

Pull requests are welcome. If you're planning to make a major change, please open an issue first to discuss your proposed changes.

<br/>

# License

This project is licensed under the [MIT](https://choosealicense.com/licenses/mit/) License.

unit FMX.Stability.Tutorial;

{ Tutorial Support Unit

   WARNING:
     This module is intended solely to illustrate the examples provided in the
     README.md file of the repository :
         https://github.com/MaxiDonkey/DelphiStabilityAI.
     Under no circumstances should the methods described below be used outside
     of the examples presented on the repository's page.
}

interface

uses
  System.SysUtils, System.Classes, System.Types, FMX.Memo, FMX.Objects, FMX.Forms,
  StabilityAI.Common, StabilityAI.Version1.SDXL1AndSD1_6, StabilityAI.VideoAnd3D.Stable3D,
  StabilityAI.VideoAnd3D.Video, StabilityAI.Version1.Engines, StabilityAI.Version1.User;

type
  TFMXStabilitySender = class
  private
    FId: string;
    FMemo: TMemo;
    FImage: TImage;
    FFileName: string;
  public
    property Id: string read FId write FId;
    property Memo: TMemo read FMemo write FMemo;
    property Image: TImage read FImage write FImage;
    property FileName: string read FFileName write FFileName;
    constructor Create(const AMemo: TMemo; const AImage: TImage);
  end;

  procedure Start(Sender: TObject);
  procedure Display(Sender: TObject; Value: string); overload;
  procedure Display(Sender: TObject; Result: TStableImage); overload;
  procedure Display(Sender: TObject; Result: TArtifacts); overload;
  procedure Display(Sender: TObject; Value: TResults); overload;
  procedure Display(Sender: TObject; Value: TModel3D); overload;
  procedure Display(Sender: TObject; Value: TJobVideo); overload;
  procedure Display(Sender: TObject; Value: TEngines); overload;
  procedure Display(Sender: TObject; Value: TAccountDetails); overload;

var
  StabilityResult: TFMXStabilitySender = nil;

implementation

procedure Start(Sender: TObject);
begin
  Display(Sender, 'Request sended. Please wait....');
end;

procedure Display(Sender: TObject; Value: string);
begin
  var T := Sender as TFMXStabilitySender;
  T.Memo.Lines.Text := T.Memo.Text + Value + sLineBreak;
end;

procedure Display(Sender: TObject; Result: TStableImage);
begin
  var T := Sender as TFMXStabilitySender;
  var Stream := Result.GetStream;
  try
    if not T.FileName.IsEmpty then
      Result.SaveToFile(T.FileName);
    Display(Sender, 'Save to file : ' + T.FileName);
    {--- Display only images }
    if not Result.Image.IsEmpty then
      T.Image.Bitmap.LoadFromStream(Stream);
    Display(Sender, 'Operation ended successfully');
  finally
    Stream.Free;
  end;
end;

procedure Display(Sender: TObject; Result: TArtifacts);
begin
  var T := Sender as TFMXStabilitySender;
  var Stream := Result.Artifacts[0].GetStream;
  try
    if not T.FileName.IsEmpty then
      Result.SaveToFile(T.FileName);
    T.Image. BitMap.LoadFromStream(Stream);
    Display(Sender, 'Operation ended successfully');
  finally
    Stream.Free;
  end;
end;

procedure Display(Sender: TObject; Value: TResults); overload;
begin
  if not Value.Id.IsEmpty then
    begin
      Display(Sender, Value.Id);
      StabilityResult.Id := Value.Id;
      { Keep only the last ID of the job in progress !!!
        Please refer to the warning in the unit header. }
    end;
  if Value.Status = 'in-progress' then
    begin
      Display(Sender, 'in-progress');
      Exit;
    end;
  try
    Display(Sender, Value as TStableImage);
  except
  end;
end;

procedure Display(Sender: TObject; Value: TModel3D);
begin
  var T := Sender as TFMXStabilitySender;
  Value.SaveToFile(T.FileName);
  Display(Sender, 'Model 3d : ' + T.FileName);
end;

procedure Display(Sender: TObject; Value: TJobVideo);
begin
  Display(Sender, Value.Id);
end;

procedure Display(Sender: TObject; Value: TEngines);
begin
  for var Item in Value.Result do
    Display(Sender, Item.Name);
end;

procedure Display(Sender: TObject; Value: TAccountDetails);
begin
  Display(Sender, Value.Id);
  Display(Sender, Value.Email);
  Display(Sender, Value.ProfilePicture);
  for var Item in Value.Organizations do
    begin
      Display(Sender, Item.Id);
      Display(Sender, Item.Name);
      Display(Sender, Item.Role);
      Display(Sender, BoolToStr(Item.IsDefault, True));
    end;
end;

{ TFMXStabilitySender }

constructor TFMXStabilitySender.Create(const AMemo: TMemo;
  const AImage: TImage);
begin
  inherited Create;
  FMemo := AMemo;
  FImage := AImage;
end;

initialization
finalization
  if Assigned(StabilityResult) then
    StabilityResult.Free;
end.

unit StabilityAI.API.Params;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiStabilityAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.Classes, System.JSON, System.SysUtils, System.Types, System.RTTI,
  REST.JsonReflect, REST.Json.Interceptors, System.Generics.Collections,
  System.Threading;

type
  /// <summary>
  /// Represents a reference to a procedure that takes a single argument of type T and returns no value.
  /// </summary>
  /// <param name="T">
  /// The type of the argument that the referenced procedure will accept.
  /// </param>
  /// <remarks>
  /// This type is useful for defining callbacks or procedures that operate on a variable of type T, allowing for more flexible and reusable code.
  /// </remarks>
  TProcRef<T> = reference to procedure(var Arg: T);

  TJSONInterceptorStringToString = class(TJSONInterceptor)
    constructor Create; reintroduce;
  protected
    RTTI: TRttiContext;
  end;

  TJSONParam = class
  private
    FJSON: TJSONObject;
    procedure SetJSON(const Value: TJSONObject);
    function GetCount: Integer;

  public
    constructor Create; virtual;
    destructor Destroy; override;
    function Add(const Key: string; const Value: string): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: Integer): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: Extended): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: Boolean): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: TDateTime; Format: string): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: TJSONValue): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: TJSONParam): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<string>): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<Integer>): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<Extended>): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<TJSONValue>): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<TJSONParam>): TJSONParam; overload; virtual;
    function GetOrCreateObject(const Name: string): TJSONObject;
    function GetOrCreate<T: TJSONValue, constructor>(const Name: string): T;
    procedure Delete(const Key: string); virtual;
    procedure Clear; virtual;
    property Count: Integer read GetCount;
    function Detach: TJSONObject;
    property JSON: TJSONObject read FJSON write SetJSON;
    function ToJsonString(FreeObject: Boolean = False): string; virtual;
    function ToFormat(FreeObject: Boolean = False): string;
    function ToStringPairs: TArray<TPair<string, string>>;
    function ToStream: TStringStream;
  end;

const
  DATE_FORMAT = 'YYYY-MM-DD';
  TIME_FORMAT = 'HH:NN:SS';
  DATE_TIME_FORMAT = DATE_FORMAT + ' ' + TIME_FORMAT;

implementation

uses
  System.DateUtils;

{ TJSONInterceptorStringToString }

constructor TJSONInterceptorStringToString.Create;
begin
  ConverterType := ctString;
  ReverterType := rtString;
end;

{ Fetch }

type
  Fetch<T> = class
    type
      TFetchProc = reference to procedure(const Element: T);
  public
    class procedure All(const Items: TArray<T>; Proc: TFetchProc);
  end;

{ Fetch<T> }

class procedure Fetch<T>.All(const Items: TArray<T>; Proc: TFetchProc);
var
  Item: T;
begin
  for Item in Items do
    Proc(Item);
end;

{ TJSONParam }

function TJSONParam.Add(const Key, Value: string): TJSONParam;
begin
  Delete(Key);
  FJSON.AddPair(Key, Value);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: TJSONValue): TJSONParam;
begin
  Delete(Key);
  FJSON.AddPair(Key, Value);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: TJSONParam): TJSONParam;
begin
  Add(Key, TJSONValue(Value.JSON.Clone));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: TDateTime; Format: string): TJSONParam;
begin
  if Format.IsEmpty then
    Format := DATE_TIME_FORMAT;
  Add(Key, FormatDateTime(Format, System.DateUtils.TTimeZone.local.ToUniversalTime(Value)));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: Boolean): TJSONParam;
begin
  Add(Key, TJSONBool.Create(Value));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: Integer): TJSONParam;
begin
  Add(Key, TJSONNumber.Create(Value));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: Extended): TJSONParam;
begin
  Add(Key, TJSONNumber.Create(Value));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<TJSONValue>): TJSONParam;
var
  JArr: TJSONArray;
begin
  JArr := TJSONArray.Create;
  Fetch<TJSONValue>.All(Value, JArr.AddElement);
  Add(Key, JArr);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<TJSONParam>): TJSONParam;
var
  JArr: TJSONArray;
  Item: TJSONParam;
begin
  JArr := TJSONArray.Create;
  for Item in Value do
  try
    JArr.AddElement(Item.JSON);
    Item.JSON := nil;
  finally
    Item.Free;
  end;
  Add(Key, JArr);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<Extended>): TJSONParam;
var
  JArr: TJSONArray;
  Item: Extended;
begin
  JArr := TJSONArray.Create;
  for Item in Value do
    JArr.Add(Item);
  Add(Key, JArr);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<Integer>): TJSONParam;
var
  JArr: TJSONArray;
  Item: Integer;
begin
  JArr := TJSONArray.Create;
  for Item in Value do
    JArr.Add(Item);
  Add(Key, JArr);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<string>): TJSONParam;
var
  JArr: TJSONArray;
  Item: string;
begin
  JArr := TJSONArray.Create;
  for Item in Value do
    JArr.Add(Item);
  Add(Key, JArr);
  Result := Self;
end;

procedure TJSONParam.Clear;
begin
  FJSON.Free;
  FJSON := TJSONObject.Create;
end;

constructor TJSONParam.Create;
begin
  FJSON := TJSONObject.Create;
end;

procedure TJSONParam.Delete(const Key: string);
var
  Item: TJSONPair;
begin
  Item := FJSON.RemovePair(Key);
  if Assigned(Item) then
    Item.Free;
end;

destructor TJSONParam.Destroy;
begin
  if Assigned(FJSON) then
    FJSON.Free;
  inherited;
end;

function TJSONParam.GetCount: Integer;
begin
  Result := FJSON.Count;
end;

function TJSONParam.GetOrCreate<T>(const Name: string): T;
begin
  if not FJSON.TryGetValue<T>(Name, Result) then
  begin
    Result := T.Create;
    FJSON.AddPair(Name, Result);
  end;
end;

function TJSONParam.GetOrCreateObject(const Name: string): TJSONObject;
begin
  Result := GetOrCreate<TJSONObject>(Name);
end;

function TJSONParam.Detach: TJSONObject;
begin
  Result := JSON;
  JSON := nil;
  var Task: ITask := TTask.Create(
    procedure()
    begin
      Sleep(30);
      TThread.Queue(nil,
      procedure
      begin
        Self.Free;
      end);
    end
  );
  Task.Start;
end;

procedure TJSONParam.SetJSON(const Value: TJSONObject);
begin
  FJSON := Value;
end;

function TJSONParam.ToFormat(FreeObject: Boolean): string;
begin
  Result := FJSON.Format(4);
  if FreeObject then
    Free;
end;

function TJSONParam.ToJsonString(FreeObject: Boolean): string;
begin
  Result := FJSON.ToJSON;
  if FreeObject then
    Free;
end;

function TJSONParam.ToStream: TStringStream;
begin
  Result := TStringStream.Create;
  try
    Result.WriteString(ToJsonString);
    Result.Position := 0;
  except
    Result.Free;
    raise;
  end;
end;

function TJSONParam.ToStringPairs: TArray<TPair<string, string>>;
begin
  for var Pair in FJSON do
    Result := Result + [TPair<string, string>.Create(Pair.JsonString.Value, Pair.JsonValue.AsType<string>)];
end;

end.

unit StabilityAI.API;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiStabilityAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.Classes, System.Net.HttpClient, System.Net.URLClient, System.Net.Mime,
  System.JSON, StabilityAI.Errors, StabilityAI.API.Params, System.SysUtils;

type
  TModelDataReturned = class abstract
  private
    FContentType: string;
    FData: TBytes;
  public
    property Data: TBytes read FData write FData;
    property ContentType: string read FContentType write FContentType;
  end;

  /// <summary>
  /// See at https://console.StabilityAI.com/docs/errors
  /// </summary>
  StabilityAIException = class(Exception)
  private
    FCode: Int64;
    FId: string;
    FName: string;
    FErrors: string;
  public
    constructor Create(const ACode: Int64; const AError: TErrorCore); reintroduce; overload;
    constructor Create(const ACode: Int64; const Value: string); reintroduce; overload;
    property Code: Int64 read FCode write FCode;
    property Id: string read FId write FId;
    property Name: string read FName write FName;
    property Errors: string read FErrors write FErrors;
  end;

  StabilityAIExceptionAPI = class(Exception);

  /// <summary>
  /// The server could not understand the request due to invalid syntax.
  /// Review the request format and ensure it is correct.
  /// </summary>
  StabilityAIExceptionBadRequestError = class(StabilityAIException);

  /// <summary>
  /// The request lacks the required 'Authorization' header, which is needed to authenticate access.
  /// </summary>
  StabilityAIExceptionUnauthorizedError = class(StabilityAIException);

  /// <summary>
  /// The specified engine (ID some-fake-engine) was not found.
  /// </summary>
  StabilityAIExceptionNotFoundError = class(StabilityAIException);

  /// <summary>
  /// The request was well-formed but could not be followed due to semantic errors.
  /// Verify the data provided for correctness and completeness.
  /// </summary>
  StabilityAIExceptionInvalidLanguageError = class(StabilityAIException);

  /// <summary>
  /// Too many requests were sent in a given timeframe. Implement request throttling and respect rate limits.
  /// </summary>
  StabilityAIExceptionRateLimitExceededError = class(StabilityAIException);

  /// <summary>
  /// The request was not successful because it lacks valid authentication credentials for the requested resource.
  /// Ensure the request includes the necessary authentication credentials and the api key is valid.
  /// </summary>
  StabilityAIExceptionContentModerationError = class(StabilityAIException);

  /// <summary>
  /// The requested resource could not be found. Check the request URL and the existence of the resource.
  /// </summary>
  StabilityAIExceptionPayloadTooLargeError = class(StabilityAIException);

  /// <summary>
  /// A generic error occurred on the server. Try the request again later or contact support if the issue persists.
  /// </summary>
  StabilityAIExceptionInternalServerError = class(StabilityAIException);

  StabilityAIExceptionInvalidResponse = class(StabilityAIException);

  TStabilityAIAPI = class
  public
    const
      URL_BASE = 'https://api.stability.ai';
  private
    FToken: string;
    FBaseUrl: string;
    FClientId: string;
    FClientUserId: string;
    FClientVersion: string;
    FCustomHeaders: TNetHeaders;

    procedure SetToken(const Value: string);
    procedure SetBaseUrl(const Value: string);
    procedure RaiseError(Code: Int64; Error: TErrorCore);
    procedure ParseError(const Code: Int64; const ResponseText: string);
    procedure SetCustomHeaders(const Value: TNetHeaders);
    procedure SetClientId(const Value: string);
    procedure SetClientUserId(const Value: string);
    procedure SetClientVersion(const Value: string);
  protected
    function GetHeaderValue(const KeyName: string; const Value: TNetHeaders): string;
    function GetHeaders: TNetHeaders; virtual;
    function GetClient: THTTPClient; virtual;
    function GetRequestURL(const Path: string): string;
    function Get(const Path: string; Response: TStringStream; var ResponseHeader: TNetHeaders): Integer; overload;
    function Get(const Path: string; Response: TStringStream): Integer; overload;
    function Delete(const Path: string; Response: TStringStream): Integer; overload;
    function Post(const Path: string; Response: TStringStream): Integer; overload;
    function Post(const Path: string; Body: TJSONObject; Response: TStringStream; OnReceiveData: TReceiveDataCallback = nil): Integer; overload;
    function Post(const Path: string; Body: TMultipartFormData; Response: TStringStream; var ResponseHeader: TNetHeaders): Integer; overload;
    function ParseResponse<T: class, constructor>(const Code: Int64; const ResponseText: string): T; overload;
    function ParseResponse<T: class, constructor>(const Code: Int64; const Response: TStringStream; const ResponseHeader: TNetHeaders): T; overload;
    function ParseResponse<T: class, constructor>(const Response: TBytes; const ResponseHeader: TNetHeaders): T; overload;
    procedure CheckAPI;
  public
    function GetArray<TResult: class, constructor>(const Path: string): TResult;
    function Get<TResult: class, constructor>(const Path: string): TResult; overload;
    function Get<TResult: class, constructor; TParams: TJSONParam>(const Path: string; ParamProc: TProc<TParams>): TResult; overload;
    procedure GetFile(const Path: string; Response: TStream); overload;
    function Delete<TResult: class, constructor>(const Path: string): TResult; overload;
    function Post<TParams: TJSONParam>(const Path: string; ParamProc: TProc<TParams>; Response: TStringStream; Event: TReceiveDataCallback = nil): Boolean; overload;
    function Post<TResult: class, constructor; TParams: TJSONParam>(const Path: string; ParamProc: TProc<TParams>): TResult; overload;
    procedure Post<TParams: TJSONParam>(const Path: string; ParamProc: TProc<TParams>; Response: TStream; Event: TReceiveDataCallback = nil); overload;       //AJOUT
    function Post<TResult: class, constructor>(const Path: string): TResult; overload;
    function PostForm<TResult: class, constructor; TParams: TMultipartFormData, constructor>(const Path: string; ParamProc: TProc<TParams>): TResult; overload;
    function PostForm<TResult: class, constructor; TParams: TMultipartFormData, constructor>(const Path: string; ParamProc: TProc<TParams>;
      var ResponseHeader: TNetHeaders): TResult; overload;
  public
    constructor Create; overload;
    constructor Create(const AToken: string); overload;
    destructor Destroy; override;
    property Token: string read FToken write SetToken;
    property BaseUrl: string read FBaseUrl write SetBaseUrl;
    property ClientId: string read FClientId write SetClientId;
    property ClientUserId: string read FClientUserId write SetClientUserId;
    property ClientVersion: string read FClientVersion write SetClientVersion;
    property CustomHeaders: TNetHeaders read FCustomHeaders write SetCustomHeaders;
  end;

  TStabilityAIAPIRoute = class
  private
    FAPI: TStabilityAIAPI;
    procedure SetAPI(const Value: TStabilityAIAPI);
  public
    property API: TStabilityAIAPI read FAPI write SetAPI;
    constructor CreateRoute(AAPI: TStabilityAIAPI); reintroduce;
  end;

implementation

uses
  REST.Json, System.NetConsts;

constructor TStabilityAIAPI.Create;
begin
  inherited;
  FToken := '';
  FBaseUrl := URL_BASE;
end;

constructor TStabilityAIAPI.Create(const AToken: string);
begin
  Create;
  Token := AToken;
end;

destructor TStabilityAIAPI.Destroy;
begin
  inherited;
end;

function TStabilityAIAPI.Post(const Path: string; Body: TJSONObject; Response: TStringStream; OnReceiveData: TReceiveDataCallback): Integer;
var
  Headers: TNetHeaders;
  Stream: TStringStream;
  Client: THTTPClient;
begin
  CheckAPI;
  Client := GetClient;
  try
    Headers := GetHeaders + [TNetHeader.Create('Content-Type', 'application/json')];
    Stream := TStringStream.Create;
    Client.ReceiveDataCallBack := OnReceiveData;
    try
      Stream.WriteString(Body.ToJSON);
      Stream.Position := 0;
      Result := Client.Post(GetRequestURL(Path), Stream, Response, Headers).StatusCode;
    finally
      Client.ReceiveDataCallBack := nil;
      Stream.Free;
    end;
  finally
    Client.Free;
  end;
end;

function TStabilityAIAPI.Get(const Path: string; Response: TStringStream; var ResponseHeader: TNetHeaders): Integer;
var
  Client: THTTPClient;
begin
  CheckAPI;
  Client := GetClient;
  try
    var Data := Client.Get(GetRequestURL(Path), Response, GetHeaders);
    ResponseHeader := Data.Headers;
    Result := Data.StatusCode;
  finally
    Client.Free;
  end;
end;

function TStabilityAIAPI.Get(const Path: string;
  Response: TStringStream): Integer;
var
  ResponseHeader: TNetHeaders;
begin
  Result := Get(Path, Response, ResponseHeader);
end;

function TStabilityAIAPI.Post(const Path: string; Body: TMultipartFormData; Response: TStringStream;
  var ResponseHeader: TNetHeaders): Integer;
var
  Client: THTTPClient;
begin
  CheckAPI;
  Client := GetClient;
  try
    var PostResult := Client.Post(GetRequestURL(Path), Body, Response, GetHeaders);
    ResponseHeader := PostResult.Headers;
    Result := PostResult.StatusCode;
  finally
    Client.Free;
  end;
end;

function TStabilityAIAPI.Post(const Path: string; Response: TStringStream): Integer;
var
  Client: THTTPClient;
begin
  CheckAPI;
  Client := GetClient;
  try
    Result := Client.Post(GetRequestURL(Path), TStream(nil), Response, GetHeaders).StatusCode;
  finally
    Client.Free;
  end;
end;

procedure TStabilityAIAPI.Post<TParams>(const Path: string; ParamProc: TProc<TParams>; Response: TStream; Event: TReceiveDataCallback);
var
  Params: TParams;
  Code: Integer;
  Headers: TNetHeaders;
  Stream, Strings: TStringStream;
  Client: THTTPClient;
begin
  Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);

    CheckAPI;
    Client := GetClient;
    try
      Client.ReceiveDataCallBack := Event;
      Headers := GetHeaders + [TNetHeader.Create('Content-Type', 'application/json')];
      Stream := TStringStream.Create;
      try
        Stream.WriteString(Params.JSON.ToJSON);
        Stream.Position := 0;
        Code := Client.Post(GetRequestURL(Path), Stream, Response, Headers).StatusCode;
        case Code of
          200..299:
            ; {success}
        else
          Strings := TStringStream.Create;
          try
            Response.Position := 0;
            Strings.LoadFromStream(Response);
            ParseError(Code, Strings.DataString);
          finally
            Strings.Free;
          end;
        end;
      finally
        Client.ReceiveDataCallBack := nil;
        Stream.Free;
      end;
    finally
      Client.Free;
    end;
  finally
    Params.Free;
  end;
end;

function TStabilityAIAPI.Post<TResult, TParams>(const Path: string; ParamProc: TProc<TParams>): TResult;
var
  Response: TStringStream;
  Params: TParams;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    Code := Post(Path, Params.JSON, Response);
    Result := ParseResponse<TResult>(Code, Response.DataString);
  finally
    Params.Free;
    Response.Free;
  end;
end;

function TStabilityAIAPI.Post<TParams>(const Path: string; ParamProc: TProc<TParams>; Response: TStringStream; Event: TReceiveDataCallback): Boolean;
var
  Params: TParams;
  Code: Integer;
begin
  Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    Code := Post(Path, Params.JSON, Response, Event);
    case Code of
      200..299:
        Result := True;
    else
      Result := False;
    end;
  finally
    Params.Free;
  end;
end;

function TStabilityAIAPI.Post<TResult>(const Path: string): TResult;
var
  Response: TStringStream;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Code := Post(Path, Response);
    Result := ParseResponse<TResult>(Code, Response.DataString);
  finally
    Response.Free;
  end;
end;

function TStabilityAIAPI.Delete(const Path: string; Response: TStringStream): Integer;
var
  Client: THTTPClient;
begin
  CheckAPI;
  Client := GetClient;
  try
    Result := Client.Delete(GetRequestURL(Path), Response, GetHeaders).StatusCode;
  finally
    Client.Free;
  end;
end;

function TStabilityAIAPI.Delete<TResult>(const Path: string): TResult;
var
  Response: TStringStream;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Code := Delete(Path, Response);
    Result := ParseResponse<TResult>(Code, Response.DataString);
  finally
    Response.Free;
  end;
end;

function TStabilityAIAPI.PostForm<TResult, TParams>(const Path: string;
  ParamProc: TProc<TParams>; var ResponseHeader: TNetHeaders): TResult;
begin
  var Response := TStringStream.Create('', TEncoding.UTF8);
  var Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    var Code := Post(Path, Params, Response, ResponseHeader);
    Result := ParseResponse<TResult>(Code, Response, ResponseHeader);
  finally
    Params.Free;
    Response.Free;
  end;
end;

function TStabilityAIAPI.PostForm<TResult, TParams>(const Path: string; ParamProc: TProc<TParams>): TResult;
var
  ResponseHeader: TNetHeaders;
begin
  if not TResult.inheritsFrom(TModelDataReturned) then
    CustomHeaders := [TNetHeader.Create('accept', 'application/json')];
  Result := PostForm<TResult, TParams>(Path, ParamProc, ResponseHeader);
end;

function TStabilityAIAPI.Get<TResult, TParams>(const Path: string; ParamProc: TProc<TParams>): TResult;
var
  Response: TStringStream;
  Params: TParams;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    var Pairs: TArray<string> := [];
    for var Pair in Params.ToStringPairs do
      Pairs := Pairs + [Pair.Key + '=' + Pair.Value];
    var QPath := Path;
    if Length(Pairs) > 0 then
      QPath := QPath + '?' + string.Join('&', Pairs);
    Code := Get(QPath, Response);
    Result := ParseResponse<TResult>(Code, Response.DataString);
  finally
    Params.Free;
    Response.Free;
  end;
end;

function TStabilityAIAPI.Get<TResult>(const Path: string): TResult;
var
  Response: TStringStream;
  Code: Integer;
begin
  CustomHeaders := [TNetHeader.Create('accept', 'application/json')];
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Code := Get(Path, Response);
    Result := ParseResponse<TResult>(Code, Response.DataString);
  finally
    Response.Free;
  end;
end;

function TStabilityAIAPI.GetArray<TResult>(const Path: string): TResult;
var
  Response: TStringStream;
  Code: Integer;
begin
  CustomHeaders := [TNetHeader.Create('accept', 'application/json')];
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Code := Get(Path, Response);
    var Data := Response.DataString.Trim([#10]);
    if Data.StartsWith('[') then
      Data := Format('{"result":%s}', [Data]);
    Result := ParseResponse<TResult>(Code, Data);
  finally
    Response.Free;
  end;
end;

function TStabilityAIAPI.GetClient: THTTPClient;
begin
  Result := THTTPClient.Create;
  Result.AcceptCharSet := 'utf-8';
end;

procedure TStabilityAIAPI.GetFile(const Path: string; Response: TStream);
var
  Code: Integer;
  Strings: TStringStream;
  Client: THTTPClient;
begin
  CheckAPI;
  Client := GetClient;
  try
    Code := Client.Get(GetRequestURL(Path), Response, GetHeaders).StatusCode;
    case Code of
      200..299:
        ; {success}
    else
      Strings := TStringStream.Create;
      try
        Response.Position := 0;
        Strings.LoadFromStream(Response);
        ParseError(Code, Strings.DataString);
      finally
        Strings.Free;
      end;
    end;
  finally
    Client.Free;
  end;
end;

function TStabilityAIAPI.GetHeaders: TNetHeaders;
begin
  Result := [TNetHeader.Create('authorization', 'Bearer ' + FToken)] + FCustomHeaders;
  if not FClientId.IsEmpty then
    Result := Result + [TNetHeader.Create('stability-client-id', FClientId)];
  if not FClientUserId.IsEmpty then
    Result := Result + [TNetHeader.Create('stability-client-user-id', FClientUserId)];
  if not FClientVersion.IsEmpty then
    Result := Result + [TNetHeader.Create('stability-client-version', FClientVersion)];
end;

function TStabilityAIAPI.GetHeaderValue(const KeyName: string;
  const Value: TNetHeaders): string;
begin
  for var Item in Value do
    if Item.Name.ToLower = KeyName.ToLower then
      begin
        Result := Item.Value;
        Break;
      end;
end;

function TStabilityAIAPI.GetRequestURL(const Path: string): string;
begin
  Result := Format('%s/%s', [FBaseURL, Path]);
end;

procedure TStabilityAIAPI.CheckAPI;
begin
  if FToken.IsEmpty then
    raise StabilityAIExceptionAPI.Create('Token is empty!');
  if FBaseUrl.IsEmpty then
    raise StabilityAIExceptionAPI.Create('Base url is empty!');
end;

procedure TStabilityAIAPI.RaiseError(Code: Int64; Error: TErrorCore);
begin
  case Code of
    {--- Client Error Codes }
    400:
      raise StabilityAIExceptionBadRequestError.Create(Code, Error);
    401:
      raise StabilityAIExceptionUnauthorizedError.Create(Code, Error);
    403:
      raise StabilityAIExceptionContentModerationError.Create(Code, Error);
    404:
      raise StabilityAIExceptionNotFoundError.Create(Code, Error);
    413:
      raise StabilityAIExceptionPayloadTooLargeError.Create(Code, Error);
    422:
      raise StabilityAIExceptionInvalidLanguageError.Create(Code, Error);
    429:
      raise StabilityAIExceptionRateLimitExceededError.Create(Code, Error);
    {--- Server Error Codes }
    500:
      raise StabilityAIExceptionInternalServerError.Create(Code, Error);
  else
    raise StabilityAIException.Create(Code, Error);
  end;
end;

procedure TStabilityAIAPI.ParseError(const Code: Int64; const ResponseText: string);
var
  Error: TErrorCore;
begin
  Error := nil;
  try
    try
      Error := TJson.JsonToObject<TError>(ResponseText);
    except
      Error := nil;
    end;
    if Assigned(Error) and Assigned(Error) then
      RaiseError(Code, Error)
  finally
    if Assigned(Error) then
      Error.Free;
  end;
end;

function TStabilityAIAPI.ParseResponse<T>(const Response: TBytes;
  const ResponseHeader: TNetHeaders): T;
begin
  Result := T.Create;
  with Result as TModelDataReturned do
    begin
      FData := Response;
      FContentType := GetHeaderValue('content-type', ResponseHeader).ToLower;
    end;
end;

function TStabilityAIAPI.ParseResponse<T>(const Code: Int64;
  const Response: TStringStream; const ResponseHeader: TNetHeaders): T;
begin
  if not T.InheritsFrom(TModelDataReturned) then
    Result := ParseResponse<T>(Code, Response.DataString)
  else
    Result := ParseResponse<T>(Response.Bytes, ResponseHeader);
end;

function TStabilityAIAPI.ParseResponse<T>(const Code: Int64; const ResponseText: string): T;
begin
  Result := nil;
  case Code of
    200..299:
      try
        Result := TJson.JsonToObject<T>(ResponseText)
      except
        FreeAndNil(Result);
      end;
  else
    ParseError(Code, ResponseText);
  end;
  if not Assigned(Result) then
    raise StabilityAIExceptionInvalidResponse.Create(Code, 'Empty or invalid response');
end;

procedure TStabilityAIAPI.SetBaseUrl(const Value: string);
begin
  FBaseUrl := Value;
end;

procedure TStabilityAIAPI.SetClientId(const Value: string);
begin
  if Value.Length > 256 then
    raise Exception.CreateFmt('stability-client-id length must be lower than 256 chars : (%d)', [Value.Length]);
  FClientId := Value;
end;

procedure TStabilityAIAPI.SetClientUserId(const Value: string);
begin
  if Value.Length > 256 then
    raise Exception.CreateFmt('stability-client-user-id length must be lower than 256 chars : (%d)', [Value.Length]);
  FClientUserId := Value;
end;

procedure TStabilityAIAPI.SetClientVersion(const Value: string);
begin
  if Value.Length > 256 then
    raise Exception.CreateFmt('stability-client-version length must be lower than 256 chars : (%d)', [Value.Length]);
  FClientVersion := Value;
end;

procedure TStabilityAIAPI.SetCustomHeaders(const Value: TNetHeaders);
begin
  FCustomHeaders := Value;
end;

procedure TStabilityAIAPI.SetToken(const Value: string);
begin
  FToken := Value;
end;

{ TStabilityAIAPIRoute }

constructor TStabilityAIAPIRoute.CreateRoute(AAPI: TStabilityAIAPI);
begin
  inherited Create;
  FAPI := AAPI;
end;

procedure TStabilityAIAPIRoute.SetAPI(const Value: TStabilityAIAPI);
begin
  FAPI := Value;
end;

{ StabilityAIException }

constructor StabilityAIException.Create(const ACode: Int64; const Value: string);
begin
  Code := ACode;
  inherited Create(Format('error %d: %s', [ACode, Value]));
end;

constructor StabilityAIException.Create(const ACode: Int64; const AError: TErrorCore);
begin
  Code := ACode;
  Id := (AError as TError).Id;
  Name := (AError as TError).Name;
  Errors := Errors.Join(#10, (AError as TError).Errors);
  inherited Create(Format('error (%d) - type %s'+ sLineBreak + '%s', [Code, Name, Errors]));
end;

end.

unit StabilityAI.Async.Params;

{-------------------------------------------------------------------------------

      Unit containing generic interfaces and classes for managing parameters
      across  various  asynchronous  operations.

      The StabilityAI.Async.Params unit provides a set of tools for creating
      and managing  parameter  instances  using  generic  types. The primary
      components include:

      - IUseParams<T>: A generic interface for managing parameters of type T.
      - TUseParams<T>: A class  implementing  the IUseParams<T>  interface to
        encapsulate  parameter  handling.
      - TUseParamsFactory<T>: A  factory  class  for  creating  instances  of
        IUseParams<T>.

      These abstractions allow for  a flexible and  reusable  way  to  handle
      parameters  across  different  modules  and  contexts,  particularly in
      asynchronous  scenarios  such  as  chat  operations.

      Note  that  This  unit  is  designed   to  work   seamlessly  with  the
      StabilityAI.Chat.AsyncEvents unit, which  relies  on  IUseParams<T> and
      TUseParamsFactory<T>  to  manage   parameters   for  asynchronous  chat
      requests.

        Github repository : https://github.com/MaxiDonkey/DelphiStabilityAI
        Visit the Github repository for the documentation and use examples

-------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes;

type
  /// <summary>
  /// Generic interface for managing parameters of type <c>T</c>.
  /// </summary>
  /// <typeparam name="T">
  /// The type of the parameters.
  /// </typeparam>
  IUseParams<T> = interface
    ['{18566F2C-F2D9-4257-A460-D9AE8F053357}']
    /// <summary>
    /// Sets the parameters.
    /// </summary>
    /// <param name="Value">
    /// The value of the parameters to be set.
    /// </param>
    procedure SetParams(const Value: T);
    /// <summary>
    /// Gets the current parameters.
    /// </summary>
    /// <returns>
    /// The current parameters of type <c>T</c>.
    /// </returns>
    function GetParams: T;
    /// <summary>
    /// Assigns the parameters using a function.
    /// </summary>
    /// <param name="Value">
    /// A function that returns parameters of type <c>T</c>.
    /// </param>
    procedure Assign(Value: TFunc<T>);
    /// <summary>
    /// Returns the current instance as an object of type <c>TObject</c>.
    /// </summary>
    /// <returns>
    /// The instance cast to <c>TObject</c>.
    /// </returns>
    function AsSender: TObject;
    /// <summary>
    /// Provides access to the parameters as a property.
    /// </summary>
    property Param: T read GetParams write SetParams;
  end;

  /// <summary>
  /// A factory class for creating instances of <c>IUseParams</c>.
  /// </summary>
  /// <param name="T">
  /// The type of the parameters for which the instance is created.
  /// </param>
  TUseParamsFactory<T> = class
    /// <summary>
    /// Creates and returns a new instance of <c>IUseParams</c> for the specified type <c>T</c>.
    /// </summary>
    /// <returns>
    /// A new instance of <c>IUseParams&lt;T&gt;</c>.
    /// </returns>
    class function CreateInstance: IUseParams<T>; overload;
    /// <summary>
    /// Creates and returns a new instance of <c>IUseParams</c> for the specified type <c>T</c>, using the provided function.
    /// </summary>
    /// <param name="Value">
    /// A function that provides the parameter values for the instance.
    /// </param>
    /// <returns>
    /// A new instance of <c>IUseParams&lt;T&gt;</c>.
    /// </returns>
    class function CreateInstance(Value: TFunc<T>): IUseParams<T>; overload;
  end;

  /// <summary>
  /// A generic class implementing the <c>IUseParams</c> interface to manage parameters of type <c>T</c>.
  /// </summary>
  /// <param name="T">
  /// The type of the parameters.
  /// </param>
  TUseParams<T> = class(TInterfacedObject, IUseParams<T>)
  private
    FParams: T;
    /// <summary>
    /// Sets the parameters to the provided value.
    /// </summary>
    /// <param name="Value">
    /// The new parameters value.
    /// </param>
    procedure SetParams(const Value: T);
    /// <summary>
    /// Retrieves the current parameters value.
    /// </summary>
    /// <returns>
    /// The current parameters.
    /// </returns>
    function GetParams: T;
  protected
    /// <summary>
    /// Casts the instance as a <c>TObject</c> for use as the sender of events.
    /// </summary>
    /// <returns>
    /// The current instance cast to <c>TObject</c>.
    /// </returns>
    function AsSender: TObject;
    /// <summary>
    /// Assigns the parameters using a function that returns type <c>T</c>.
    /// </summary>
    /// <param name="Value">
    /// A function that sets the parameters.
    /// </param>
    procedure Assign(Value: TFunc<T>);
  public
    /// <summary>
    /// Property to get or set the parameters.
    /// </summary>
    property Params: T read GetParams write SetParams;
  end;

implementation

{ TUseParams<T> }

function TUseParams<T>.AsSender: TObject;
begin
  Result := Self;
end;

procedure TUseParams<T>.Assign(Value: TFunc<T>);
begin
  if Assigned(Value) then
    begin
      Params := Value();
    end;
end;

function TUseParams<T>.GetParams: T;
begin
  Result := FParams;
end;

procedure TUseParams<T>.SetParams(const Value: T);
begin
  FParams := Value;
end;

{ TUseParamsFactory<T> }

class function TUseParamsFactory<T>.CreateInstance: IUseParams<T>;
begin
  Result := TUseParams<T>.Create;
end;

class function TUseParamsFactory<T>.CreateInstance(
  Value: TFunc<T>): IUseParams<T>;
begin
  Result := CreateInstance;
  Result.Assign(Value);
end;

end.

unit StabilityAI.Async.Support;

{-------------------------------------------------------------------------------

      Unit containing  records for managing  asynchronous events related to
      chat requests.

      The  StabilityAI.Chat.AsyncEvents unit  provides  definitions for the
      TAsyncParams<T>  and  TAsynStreamParams<T>  records, which  are  used
      to  handle  the lifecycle  of asynchronous chat operations, including
      starting, progressing, succeeding, and handling errors.
      These records enable non-blocking operations for chat functionalities
      and can be reused across multiple modules.

      This unit depends on StabilityAI.Async.Params for parameter management.
      The IUseParams<T>  and  TUseParamsFactory<T>  interfaces  and  classes
      from  StabilityAI.Params.Core are  utilized  to  create and manage the
      parameter  instances  for  asynchronous  operations.

        Github repository : https://github.com/MaxiDonkey/DelphiStabilityAI
        Visit the Github repository for the documentation and use examples

-------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, system.Classes, System.Threading, StabilityAI.Async.Params;

type
  /// <summary>
  /// Record used to handle asynchronous request events.
  /// </summary>
  /// <remarks>
  /// <c>TAsynCallBack</c> manages the lifecycle of an asynchronous request.
  /// It provides callbacks for different stages of the request, such as start, successful completion, or error.
  /// </remarks>
  TAsynCallBack<T> = record
  private
    FSender: TObject;
    FOnStart: TProc<TObject>;
    FOnSuccess: TProc<TObject, T>;
    FOnError: TProc<TObject, string>;
  public
    /// <summary>
    /// Object representing the sender of the asynchronous operation.
    /// </summary>
    /// <remarks>
    /// The <c>Sender</c> property is used to identify or store a reference to the object that initiated the request.
    /// This can be useful for providing context in the callback procedures.
    /// </remarks>
    property Sender: TObject read FSender write FSender;
    /// <summary>
    /// Event triggered at the start of the asynchronous request.
    /// </summary>
    /// <remarks>
    /// The <c>OnStart</c> event is called when the request begins.
    /// It can be used to initialize any required state or display a loading indicator to the user.
    /// <code>
    /// OnStart :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // Code executed at the start of the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnStart: TProc<TObject> read FOnStart write FOnStart;
    /// <summary>
    /// Event triggered at the end of the asynchronous request.
    /// </summary>
    /// <param name="Sender">
    /// Object that initiated the request, generally used for context.
    /// </param>
    /// <param name="Result">
    /// The result of type <c>T</c> returned at the end of the request.
    /// This event is used to process the final result of the asynchronous operation.
    /// </param>
    /// <remarks>
    /// The <c>OnSuccess</c> event is invoked when the process completes successfully.
    /// It can be used to perform final actions based on the received result.
    /// <code>
    /// OnSuccess :=
    ///    procedure (Sender: TObject; Result: T)
    ///    begin
    ///      // Code executed at the end of the request with the obtained result
    ///    end;
    /// </code>
    /// </remarks>
    property OnSuccess: TProc<TObject, T> read FOnSuccess write FOnSuccess;
    /// <summary>
    /// Event triggered when an error occurs during the asynchronous request.
    /// </summary>
    /// <param name="Sender">
    /// Object that initiated the request, generally used for context.
    /// </param>
    /// <param name="ErrorMessage">
    /// The error message received, which can be logged or displayed to the user.
    /// </param>
    /// <remarks>
    /// The <c>OnError</c> event is called when an error occurs during the asynchronous operation.
    /// It can be used to handle failures, display error messages, or perform any necessary cleanup actions.
    /// <code>
    /// OnError :=
    ///    procedure (Sender: TObject; ErrorMessage: string)
    ///    begin
    ///      // Code executed when an error occurs during the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnError: TProc<TObject, string> read FOnError write FOnError;
  end;

  /// <summary>
  /// Class used to manage asynchronous execution with callback events.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynCallBackExec&lt;T, U&gt;</c> class allows you to execute asynchronous operations with specified callbacks for start, completion, and error events.
  /// It encapsulates the asynchronous execution logic, handling thread management and exception handling, providing an easy way to manage the lifecycle of an asynchronous request.
  /// </remarks>
  TAsynCallBackExec<T; U: class> = class
  private
    FUse: IUseParams<T>;
    FSender: TObject;
    FOnStart: TProc<TObject>;
    FOnSuccess: TProc<TObject, U>;
    FOnError: TProc<TObject, string>;
  public
    /// <summary>
    /// Gets the <c>IUseParams&lt;T&gt;</c> interface instance used by this class.
    /// </summary>
    /// <value>
    /// An instance of <c>IUseParams&lt;T&gt;</c> that provides parameter management functionality.
    /// </value>
    property Use: IUseParams<T> read FUse;
    /// <summary>
    /// The object representing the sender of the asynchronous operation.
    /// </summary>
    /// <value>
    /// An instance of <c>TObject</c> identifying the originator of the operation.
    /// </value>
    /// <remarks>
    /// This property can be set to identify the object that initiated the asynchronous operation, which is useful in callback methods.
    /// </remarks>
    property Sender: TObject read FSender write FSender;
    /// <summary>
    /// Event triggered when the asynchronous operation starts.
    /// </summary>
    /// <value>
    /// A procedure of type <c>TProc&lt;TObject&gt;</c> to handle any setup or UI updates when the operation begins.
    /// </value>
    /// <remarks>
    /// Assign a procedure to this event to perform actions at the start of the asynchronous operation.
    /// <code>
    /// OnStart :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // Code executed at the start of the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnStart: TProc<TObject> read FOnStart write FOnStart;
    /// <summary>
    /// Event triggered when the asynchronous operation completes successfully.
    /// </summary>
    /// <value>
    /// A procedure of type <c>TProc&lt;TObject, U&gt;</c> to handle the result of the operation.
    /// </value>
    /// <remarks>
    /// Assign a procedure to this event to process the result returned by the operation.
    /// <code>
    /// OnSuccess :=
    ///    procedure (Sender: TObject; Result: T)
    ///    begin
    ///      // Code executed at the end of the request with the obtained result
    ///    end;
    /// </code>
    /// </remarks>
    property OnSuccess: TProc<TObject, U> read FOnSuccess write FOnSuccess;
    /// <summary>
    /// Event triggered when an error occurs during the asynchronous operation.
    /// </summary>
    /// <value>
    /// A procedure of type <c>TProc&lt;TObject, string&gt;</c> to handle exceptions or errors.
    /// </value>
    /// <remarks>
    /// Assign a procedure to this event to handle any exceptions or errors that occur during execution.
    /// <code>
    /// OnError :=
    ///    procedure (Sender: TObject; ErrorMessage: string)
    ///    begin
    ///      // Code executed when an error occurs during the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnError: TProc<TObject, string> read FOnError write FOnError;
    /// <summary>
    /// Executes the specified function asynchronously.
    /// </summary>
    /// <param name="Value">
    /// A function of type <c>TFunc&lt;U&gt;</c> representing the operation to execute asynchronously.
    /// </param>
    /// <remarks>
    /// This method creates and starts an asynchronous task that executes the provided function.
    /// It invokes the <c>OnStart</c> event before execution, the <c>OnSuccess</c> event upon successful completion, and the <c>OnError</c> event if an exception occurs during execution.
    /// </remarks>
    procedure Run(Value: TFunc<U>);
    /// <summary>
    /// Initializes a new instance of the <c>TAsynCallBackExec&lt;T, U&gt;</c> class with the specified parameter function.
    /// </summary>
    /// <param name="Value">
    /// A function of type <c>TFunc&lt;T&gt;</c> used to create an instance of <c>IUseParams&lt;T&gt;</c>.
    /// </param>
    /// <remarks>
    /// The constructor initializes the internal <c>IUseParams&lt;T&gt;</c> interface using the provided function.
    /// </remarks>
    constructor Create(const Value: TFunc<T>);
  end;

  /// <summary>
  /// Record used to manage asynchronous events for a streaming chat request.
  /// </summary>
  /// <remarks>
  /// <c>TAsynChatStreamParams</c> allows you to handle the lifecycle of a chat request in streaming mode.
  /// It provides callbacks for different stages such as when the request starts, progresses, succeeds, encounters an error, or needs to be canceled.
  /// </remarks>
  TAsynStreamCallBack<T> = record
  private
    FSender: TObject;
    FOnStart: TProc<TObject>;
    FOnSuccess: TProc<TObject>;
    FOnProgress: TProc<TObject, T>;
    FOnError: TProc<TObject, string>;
    FOnCancellation: TProc<TObject>;
    FOnDoCancel: TFunc<Boolean>;
  public
    /// <summary>
    /// The object representing the sender of the asynchronous operation.
    /// </summary>
    /// <remarks>
    /// The <c>Sender</c> property is used to identify or store a reference to the object that initiated the chat request,
    /// which can be useful for context within the callback procedures.
    /// </remarks>
    property Sender: TObject read FSender write FSender;
    /// <summary>
    /// Event triggered when the asynchronous chat request starts.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="Chat">
    /// The <c>TChat</c> object representing the current response chunk received from the model.
    /// This event can be used to update the user interface as new tokens are streamed in.
    /// </param>
    /// <remarks>
    /// The <c>OnStart</c> event is called when the chat request begins. It can be used to set up any initial state or display a loading indicator to the user.
    /// <code>
    /// OnStart :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // code when chat request begin
    ///    end;
    /// </code>
    /// </remarks>
    property OnStart: TProc<TObject> read FOnStart write FOnStart;
    /// <summary>
    /// Event triggered when the asynchronous chat request completes successfully.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="Chat">
    /// The <c>TChat</c> object representing the current response chunk received from the model.
    /// This event can be used to update the user interface as new tokens are streamed in.
    /// </param>
    /// <remarks>
    /// The <c>OnSuccess</c> event is invoked when the streaming process finishes successfully.
    /// It does not provide additional data, as the result is expected to have been handled progressively via the <c>OnProgress</c> event.
    /// <code>
    /// OnSuccess :=
    ///    procedure (Sender: TObject; Chat: TChat)
    ///    begin
    ///      // code when the streaming process finishes successfully
    ///    end;
    /// </code>
    /// </remarks>
    property OnSuccess: TProc<TObject> read FOnSuccess write FOnSuccess;
    /// <summary>
    /// Event triggered to handle progress during the streaming chat request.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="Chat">
    /// The <c>TChat</c> object representing the current response chunk received from the model.
    /// This event can be used to update the user interface as new tokens are streamed in.
    /// </param>
    /// <remarks>
    /// The <c>OnProgress</c> event is fired every time a new chunk of data is received during the streaming process.
    /// This allows the application to handle the response progressively as it is generated by the model.
    /// <code>
    /// OnProgress :=
    ///    procedure (Sender: TObject; Chat: TChat)
    ///    begin
    ///      // code to handle the response progressively
    ///    end;
    /// </code>
    /// </remarks>
    property OnProgress: TProc<TObject, T> read FOnProgress write FOnProgress;
    /// <summary>
    /// Event triggered when an error occurs during the asynchronous chat request.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="ErrorMessage">
    /// The error message received, which can be logged or displayed to the user.
    /// </param>
    /// <remarks>
    /// The <c>OnError</c> event is called when an error occurs during the streaming process.
    /// This can be used to handle failures, show error messages, or perform any necessary clean-up actions.
    /// <code>
    /// OnError :=
    ///    procedure (Sender: TObject; message: string)
    ///    begin
    ///      // code to handle an error occurs during the streaming process
    ///    end;
    /// </code>
    /// </remarks>
    property OnError: TProc<TObject, string> read FOnError write FOnError;
    /// <summary>
    /// Event triggered when the asynchronous chat request has been canceled.
    /// </summary>
    /// <remarks>
    /// The <c>OnCancellation</c> event is fired when the chat request is canceled by the user or the application.
    /// This can be used to perform clean-up operations or notify the user that the request has been terminated.
    /// <code>
    /// OnCancellation :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // code to handle chat request cancellation
    ///    end;
    /// </code>
    /// </remarks>
    property OnCancellation: TProc<TObject> read FOnCancellation write FOnCancellation;
    /// <summary>
    /// Function called to determine if the asynchronous chat request should be canceled.
    /// </summary>
    /// <returns>
    /// A <c>Boolean</c> value indicating whether the request should be canceled (<c>True</c>) or allowed to continue (<c>False</c>).
    /// </returns>
    /// <remarks>
    /// The <c>OnDoCancel</c> function is periodically invoked to check whether the user or application has requested to cancel the chat request.
    /// If the function returns <c>True</c>, the streaming process will be aborted.
    /// <code>
    /// OnDoCancel :=
    ///    function : Boolean
    ///    begin
    ///      Result := ... // True to stop the streaming process
    ///    end;
    /// </code>
    /// </remarks>
    property OnDoCancel: TFunc<Boolean> read FOnDoCancel write FOnDoCancel;
  end;

implementation

{ TAsynCallBackExec<T, U> }

constructor TAsynCallBackExec<T, U>.Create(const Value: TFunc<T>);
begin
  inherited Create;
  FUse := TUseParamsFactory<T>.CreateInstance(Value);
end;

procedure TAsynCallBackExec<T, U>.Run(Value: TFunc<U>);
begin
  {--- Assign callback values to internal variables for asynchrony to work properly }
  var InternalSender := Sender;
  var InternalOnStart := OnStart;
  var InternalOnSuccess := OnSuccess;
  var InternalOnError := OnError;

  var Task: ITask := TTask.Create(
          procedure()
          begin
            try
              {--- Pass the instance of the current class in case no value was specified. }
              if not Assigned(InternalSender) then
                InternalSender := Self;

              {--- Trigger OnStart callback }
              if Assigned(InternalOnStart) then
                TThread.Queue(nil,
                  procedure
                  begin
                    InternalOnStart(InternalSender);
                  end);

              {--- Processing }
              var Result := Value();

              {--- Trigger OnEnd callback when the process is done }
              TThread.Queue(nil,
                  procedure
                  begin
                    try
                      if Assigned(InternalOnSuccess) then
                        InternalOnSuccess(InternalSender, Result);
                    finally
                      {--- Makes sure to release the instance containing the data obtained
                           following processing}
                      if Assigned(Result) then
                        Result.Free;
                    end;
                  end);

            except
              on E: Exception do
                begin
                  var Error := AcquireExceptionObject;
                  try
                    var ErrorMsg := (Error as Exception).Message;

                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(InternalOnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        InternalOnError(InternalSender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
          end);
  Task.Start;
end;

end.

unit StabilityAI.Common;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiStabilityAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Net.Mime, REST.JsonReflect, System.JSON,
  REST.Json.Types, StabilityAI.API.Params, StabilityAI.Types, StabilityAI.Async.Support;

type
  /// <summary>
  /// The reason the model stopped generating tokens.
  /// </summary>
  TFinishReason = (
    /// <summary>
    /// successful generation.
    /// </summary>
    SUCCESS,
    /// <summary>
    /// Successful generation, however the output violated our content moderation policy and has been blurred as a result.
    /// </summary>
    CONTENT_FILTERED,
    /// <summary>
    /// Only with version 1
    /// </summary>
    ERROR
  );

  TFinishReasonHelper = record helper for TFinishReason
    function ToString: string;
    class function create(const Value: string): TFinishReason; static;
  end;

  /// <summary>
  /// Interceptor class for converting <c>TFinishReason</c> values to and from their string representations in JSON serialization and deserialization.
  /// </summary>
  /// <remarks>
  /// This class is used to facilitate the conversion between the <c>TFinishReason</c> enum and its string equivalents during JSON processing.
  /// It extends the <c>TJSONInterceptorStringToString</c> class to override the necessary methods for custom conversion logic.
  /// </remarks>
  TFinishReasonInterceptor = class(TJSONInterceptorStringToString)
    /// <summary>
    /// Converts the <c>TFinishReason</c> value of the specified field to a string during JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be converted.
    /// </param>
    /// <param name="Field">
    /// The field name representing the <c>TFinishReason</c> value.
    /// </param>
    /// <returns>
    /// The string representation of the <c>TFinishReason</c> value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string back to a <c>TFinishReason</c> value for the specified field during JSON deserialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be set.
    /// </param>
    /// <param name="Field">
    /// The field name where the <c>TFinishReason</c> value will be set.
    /// </param>
    /// <param name="Arg">
    /// The string representation of the <c>TFinishReason</c> to be converted back.
    /// </param>
    /// <remarks>
    /// This method converts the string argument back to the corresponding <c>TFinishReason</c> value and assigns it to the specified field in the object.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// The <c>TStableImageCommon</c> class inherits from the <c>TMultipartFormData</c> class.
  /// </summary>
  /// <remarks>
  /// The base class <c>TMultipartFormData</c> is enriched with the following methods:
  /// <para>
  /// - function Prompt(const Value: string)
  /// </para>
  /// <para>
  /// - function NegativePrompt(const Value: string)
  /// </para>
  /// <para>
  /// - function Seed(const Value: Int64)
  /// </para>
  /// <para>
  /// - function OutputFormat(const Value: TOutPutFormat)
  /// </para>
  /// </remarks>
  TStableImageCommon = class(TMultipartFormData)
    /// <summary>
    /// What you wish to see in the output image. A strong, descriptive prompt that clearly defines elements, colors, and subjects will lead to better results.
    /// </summary>
    /// <param name="Value">
    /// [1 .. 10000] characters
    /// </param>
    /// <remarks>
    /// To control the weight of a given word use the format (word:weight), where word is the word you'd like to control the weight of and weight is a value between 0 and 1.
    /// <para>
    /// - For example: The sky was a crisp (blue:0.3) and (green:0.8) would convey a sky that was blue and green, but more green than blue.
    /// </para>
    /// </remarks>
    function Prompt(const Value: string): TStableImageCommon;
    /// <summary>
    /// A blurb of text describing what you do not wish to see in the output image.
    /// </summary>
    /// <param name="Value">
    /// [1 .. 10000] characters
    /// </param>
    /// <remarks>
    /// This is an advanced feature.
    /// </remarks>
    function NegativePrompt(const Value: string): TStableImageCommon;
    /// <summary>
    /// A specific value that is used to guide the 'randomness' of the generation
    /// </summary>
    /// <param name="Value">
    /// number [0 .. 4294967294]  (Default: 0)
    /// </param>
    /// <remarks>
    /// Omit this parameter or pass 0 to use a random seed.
    /// </remarks>
    function Seed(const Value: Int64): TStableImageCommon;
    /// <summary>
    /// Dictates the content-type of the generated image.
    /// </summary>
    /// <param name="Value">
    /// Enum: <c>jpeg</c>, <c>png</c>, <c>webp</c>
    /// </param>
    function OutputFormat(const Value: TOutPutFormat): TStableImageCommon;
  end;

  /// <summary>
  /// The <c>TStableImageRatio</c> class inherits from the <c>TStableImageCommon</c> class.
  /// </summary>
  /// <remarks>
  /// The base class <c>TStableImageCommon</c> is enriched with the following methods:
  /// <para>
  /// - function AspectRatio(const Value: TAspectRatioType)
  /// </para>
  /// </remarks>
  TStableImageRatio = class(TStableImageCommon)
    /// <summary>
    /// Controls the aspect ratio of the generated image.
    /// </summary>
    /// <param name="Value">
    /// Enum: 16:9, 1:1, 21:9, 2:3, 3:2, 4:5, 5:4, 9:16, 9:21
    /// </param>
    /// <remarks>
    /// Default: 1:1
    /// </remarks>
    function AspectRatio(const Value: TAspectRatioType): TStableImageRatio;
  end;

  /// <summary>
  /// The <c>TEditCommon</c> class inherits from the <c>TMultipartFormData</c> class.
  /// </summary>
  /// <remarks>
  /// The base class <c>TMultipartFormData</c> is enriched with the following methods:
  /// <para>
  /// - function Image(const FilePath: string)
  /// </para>
  /// <para>
  /// - function Image(const Stream: TStream; StreamFreed: Boolean = False)
  /// </para>
  /// <para>
  /// - function OutputFormat(const Value: TOutPutFormat)
  /// </para>
  /// </remarks>
  TEditCommon = class(TMultipartFormData)
    /// <summary>
    /// The image to use as the starting point for the generation.
    /// </summary>
    /// <param name="FilePath">
    /// Filename with supported format (jpeg, png, webp)
    /// </param>
    /// <remarks>
    /// <para>
    /// - Width must be between 64 and 16,384 pixels
    /// </para>
    /// <para>
    /// - Height must be between 64 and 16,384 pixels
    /// </para>
    /// <para>
    /// - Total pixel count must be at least 4,096 pixels
    /// </para>
    /// <para>
    /// - IMPORTANT: The strength parameter is required when image is provided.
    /// </para>
    /// </remarks>
    function Image(const FilePath: string): TEditCommon; overload;
    /// <summary>
    /// Adds an image to be used as the starting point for the generation process, provided as a stream.
    /// </summary>
    /// <param name="Stream">
    /// The image data in the form of a TStream. The stream must contain the image data in a supported format (e.g., JPEG, PNG, WEBP).
    /// </param>
    /// <param name="StreamFreed">
    /// A boolean value indicating whether the stream should be automatically freed after being processed.
    /// <para>
    /// - Set to <c>True</c> to allow the method to free the stream automatically after reading its contents.
    /// </para>
    /// <para>
    /// - Set to <c>False</c> if you want to manage the lifetime of the stream yourself.
    /// </para>
    /// </param>
    /// <remarks>
    /// <para>
    /// This method is useful when you already have image data in memory, as opposed to working with a file directly.
    /// </para>
    /// <para>
    /// - The image dimensions must meet the following criteria:
    ///   - Width: Between 64 and 16,384 pixels.
    ///   - Height: Between 64 and 16,384 pixels.
    ///   - Total pixel count must be at least 4,096 pixels.
    /// </para>
    /// <para>
    /// - A strength parameter is required when an image is provided for editing.
    /// </para>
    /// </remarks>
    /// <exception cref="Exception">
    /// Throws an exception if the stream is invalid or its contents do not represent a valid image in a supported format.
    /// </exception>
    function Image(const Stream: TStream; StreamFreed: Boolean = False): TEditCommon; overload;
    /// <summary>
    /// Dictates the content-type of the generated image.
    /// </summary>
    /// <param name="Value">
    /// Enum: <c>jpeg</c> <c>png webp</c>
    /// </param>
    function OutputFormat(const Value: TOutPutFormat): TEditCommon;
  end;

  /// <summary>
  /// The <c>TEditSeedCommon</c> class inherits from the <c>TEditCommon</c> class.
  /// </summary>
  /// <remarks>
  /// The base class <c>TEditCommon</c> is enriched with the following methods:
  /// <para>
  /// - function Seed(const Value: Int64)
  /// </para>
  /// </remarks>
  TEditSeedCommon = class(TEditCommon)
    /// <summary>
    /// A specific value that is used to guide the 'randomness' of the generation
    /// </summary>
    /// <param name="Value">
    /// number [0 .. 4294967294]  (Default: 0)
    /// </param>
    /// <remarks>
    /// Omit this parameter or pass 0 to use a random seed.
    /// </remarks>
    function Seed(const Value: Int64): TEditSeedCommon;
  end;

  /// <summary>
  /// The <c>TEditSeedAndGrowMaskCommon</c> class inherits from the <c>TEditSeedCommon</c> class.
  /// </summary>
  /// <remarks>
  /// The base class <c>TEditSeedCommon</c> is enriched with the following methods:
  /// <para>
  /// - function GrowMask(const Value: Integer)
  /// </para>
  /// </remarks>
  TEditSeedAndGrowMaskCommon = class(TEditSeedCommon)
    /// <summary>
    /// Grows the edges of the mask outward in all directions by the specified number of pixels. The expanded area around the mask will be blurred, which can help smooth the transition between inpainted content and the original image.
    /// </summary>
    /// <param name="Value">
    /// number [0 .. 20] (Default: 5)
    /// </param>
    /// <remarks>
    /// Try this parameter if you notice seams or rough edges around the inpainted content.
    /// <para>
    /// - NOTE : Excessive growth may obscure fine details in the mask and/or merge nearby masked regions.
    /// </para>
    /// </remarks>
    function GrowMask(const Value: Integer): TEditSeedAndGrowMaskCommon;
  end;

  /// <summary>
  /// The <c>TEditSeedAndGrowMaskAndPromtCommon</c> class inherits from the <c>TEditSeedAndGrowMaskCommon</c> class.
  /// </summary>
  /// <remarks>
  /// The base class <c>TEditSeedAndGrowMaskCommon</c> is enriched with the following methods:
  /// <para>
  /// - function Prompt(const Value: string)
  /// </para>
  /// </remarks>
  TEditSeedAndGrowMaskAndPromtCommon = class(TEditSeedAndGrowMaskCommon)
    /// <summary>
    /// What you wish to see in the output image. A strong, descriptive prompt that clearly defines elements, colors, and subjects will lead to better results.
    /// </summary>
    /// <param name="Value">
    /// [1 .. 10000] characters
    /// </param>
    /// <remarks>
    /// To control the weight of a given word use the format (word:weight), where word is the word you'd like to control the weight of and weight is a value between 0 and 1.
    /// <para>
    /// - For example: The sky was a crisp (blue:0.3) and (green:0.8) would convey a sky that was blue and green, but more green than blue.
    /// </para>
    /// </remarks>
    function Prompt(const Value: string): TEditSeedAndGrowMaskAndPromtCommon;
  end;

  /// <summary>
  /// The <c>TUpscaleCommon</c> class inherits from the <c>TStableImageCommon</c> class.
  /// </summary>
  /// <remarks>
  /// The base class <c>TStableImageCommon</c> is enriched with the following methods:
  /// <para>
  /// - function Image(const FilePath: string)
  /// </para>
  /// <para>
  /// - function Image(const Stream: TStream; StreamFreed: Boolean = False)
  /// </para>
  /// </remarks>
  TUpscaleCommon = class(TStableImageCommon)
    /// <summary>
    /// The image to use as the starting point for the generation.
    /// </summary>
    /// <param name="FilePath">
    /// Filename with supported format (jpeg, png, webp)
    /// </param>
    /// <returns>
    /// The updated <c>TStableImageUltra</c> instance.
    /// </returns>
    /// <remarks>
    /// <para>
    /// - Width must be between 64 and 16,384 pixels
    /// </para>
    /// <para>
    /// - Height must be between 64 and 16,384 pixels
    /// </para>
    /// <para>
    /// - Total pixel count must be at least 4,096 pixels
    /// </para>
    /// <para>
    /// - IMPORTANT: The strength parameter is required when image is provided.
    /// </para>
    /// </remarks>
    function Image(const FilePath: string): TUpscaleCommon; overload;
    /// <summary>
    /// Adds an image to be used as the starting point for the generation process, provided as a stream.
    /// </summary>
    /// <param name="Stream">
    /// The image data in the form of a TStream. The stream must contain the image data in a supported format (e.g., JPEG, PNG, WEBP).
    /// </param>
    /// <param name="StreamFreed">
    /// A boolean value indicating whether the stream should be automatically freed after being processed.
    /// <para>
    /// - Set to <c>True</c> to allow the method to free the stream automatically after reading its contents.
    /// </para>
    /// <para>
    /// - Set to <c>False</c> if you want to manage the lifetime of the stream yourself.
    /// </para>
    /// </param>
    /// <remarks>
    /// <para>
    /// This method is useful when you already have image data in memory, as opposed to working with a file directly.
    /// </para>
    /// <para>
    /// - The image dimensions must meet the following criteria:
    ///   - Width: Between 64 and 16,384 pixels.
    ///   - Height: Between 64 and 16,384 pixels.
    ///   - Total pixel count must be at least 4,096 pixels.
    /// </para>
    /// <para>
    /// - A strength parameter is required when an image is provided for editing.
    /// </para>
    /// </remarks>
    /// <exception cref="Exception">
    /// Throws an exception if the stream is invalid or its contents do not represent a valid image in a supported format.
    /// </exception>
    function Image(const Stream: TStream; StreamFreed: Boolean = False): TUpscaleCommon; overload;
  end;

  /// <summary>
  /// The <c>TJSONStableImage</c> class represents a JSON-serializable object that encapsulates the attributes and properties of a stable image or video generated by a model.
  /// </summary>
  /// <remarks>
  /// The <c>TJSONStableImage</c> class provides a flexible structure for handling the output of image or video generation tasks.
  /// It includes fields for base64-encoded image and video data, the reason the generation finished, and the seed value used for randomization.
  /// </remarks>
  TJSONStableImage = class
  private
    FImage: string;
    FVideo: string;
    [JsonReflectAttribute(ctString, rtString, TFinishReasonInterceptor)]
    [JsonNameAttribute('finish_reason')]
    FFinishReason: TFinishReason;
    FSeed: Int64;
  public
    /// <summary>
    /// The generated image, encoded to base64.
    /// </summary>
    property Image: string read FImage write FImage;
    /// <summary>
    /// The generated video, encoded to base64.
    /// </summary>
    property Video: string read FVideo write FVideo;
    /// <summary>
    /// The reason the generation finished.
    /// </summary>
    property FinishReason: TFinishReason read FFinishReason write FFinishReason;
    /// <summary>
    /// The seed used as random noise for this generation.
    /// </summary>
    property Seed: Int64 read FSeed write FSeed;
  end;

  /// <summary>
  /// Extends the <c>TJSONStableImage</c> class to include additional functionalities for handling stable images.
  /// </summary>
  /// <remarks>
  /// The <c>TStableImage</c> class builds upon <c>TJSONStableImage</c> by adding methods for saving generated images to files and retrieving the image or video as a stream.
  /// It is designed to simplify file and stream operations for generated content while retaining the JSON serialization capabilities of the base class.
  /// </remarks>
  TStableImage = class(TJSONStableImage)
  private
    FFileName: string;
  public
    /// <summary>
    /// Retrieves the generated image or video as a <c>TStream</c>.
    /// </summary>
    /// <returns>
    /// A <c>TStream</c> containing the decoded image or video data.
    /// </returns>
    /// <remarks>
    /// This method decodes the base64-encoded image or video data and returns it as a stream.
    /// The caller is responsible for freeing the returned stream.
    /// </remarks>
    /// <exception cref="Exception">
    /// Raises an exception if both the image and video data are empty.
    /// </exception>
    function GetStream: TStream;
    /// <summary>
    /// Saves the generated image or video to a file.
    /// </summary>
    /// <param name="FileName">
    /// The file path where the image or video will be saved.
    /// </param>
    /// <remarks>
    /// This method decodes the base64-encoded image or video data and saves it to the specified file.
    /// If the video data is not empty, it saves the video; otherwise, it saves the image.
    /// </remarks>
    /// <exception cref="Exception">
    /// Raises an exception if the image or video data cannot be decoded or saved.
    /// </exception>
    procedure SaveToFile(const FileName: string);
    /// <summary>
    /// Gets the file name where the image or video was saved.
    /// </summary>
    /// <value>
    /// The file path as a string.
    /// </value>
    /// <remarks>
    /// This property holds the file name specified in the last call to <c>SaveToFile</c>.
    /// </remarks>
    property FileName: string read FFileName;
  end;

  /// <summary>
  /// Represents the results of a generation process, extending the <c>TStableImage</c> class with additional metadata.
  /// </summary>
  /// <remarks>
  /// The <c>TResults</c> class includes properties for tracking the generation process, such as its unique identifier, status,
  /// and the base64-encoded result. This class is typically used for asynchronous operations where the generation
  /// process may be queried or monitored.
  /// </remarks>
  TResults = class(TStableImage)
  private
    FId: string;
    FStatus: string;
    FResult: string;
  public
    /// <summary>
    /// The id of a generation, typically used for async generations, that can be used to check the status of the generation or retrieve the result.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// The status of your generation.
    /// </summary>
    property Status: string read FStatus write FStatus;
    /// <summary>
    /// The result to import, encoded to base64.
    /// </summary>
    property Result: string read FResult write FResult;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TStableImage</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynStableImage</c> type extends the <c>TAsynParams&lt;TStableImage&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynStableImage = TAsynCallBack<TStableImage>;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TAsynParams&lt;TResults&gt;</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynResults</c> type extends the <c>TResults</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynResults = TAsynCallBack<TResults>;

  function Check(const FieldName, Value: string): string; overload;
  function Check(const FieldName, Value: string; Max: Integer): string; overload;
  function CheckInteger(const FieldName: string; Value, Min, Max: Integer): string; overload;
  function CheckInteger(const FieldName: string; Value, Min, Max: Int64): string; overload;
  function CheckInteger(const Value, Min, Max: Integer): Integer; overload;
  function CheckInteger(const Value, Min, Max: Int64): Int64; overload;
  function CheckFloat(const FieldName: string; Value, Min, Max: Double): string; overload;
  function CheckFloat(const Value, Min, Max: Double): Double; overload;
  function CheckMultipleOf(const Value, Min, MultipleOf: Integer): Integer;

implementation

uses
  System.StrUtils, StabilityAI.NetEncoding.Base64, StabilityAI.Consts, System.Rtti, Rest.Json;

function Check(const FieldName, Value: string): string;
begin
  Result := FieldName;
  if Value.Length > PromptMax then
    raise Exception.CreateFmt(PromptExceptionMessage, [Result, PromptMax, Value.Length]);
end;

function Check(const FieldName, Value: string; Max: Integer): string; overload;
begin
  Result := FieldName;
  if Value.Length > Max then
    raise Exception.CreateFmt(PromptExceptionMessage, [Result, Max, Value.Length]);
end;

function CheckInteger(const FieldName: string; Value, Min, Max: Int64): string; overload;
begin
  Result := FieldName;
  if (Value < Min) or (Value > Max) then
    raise Exception.CreateFmt(IntegerExceptionMessage, [Result, Min, Max, Value]);
end;

function CheckInteger(const FieldName: string; Value, Min, Max: Integer): string;
begin
  Result := FieldName;
  if (Value < Min) or (Value > Max) then
    raise Exception.CreateFmt(IntegerExceptionMessage, [Result, Min, Max, Value]);
end;

function CheckInteger(const Value, Min, Max: Integer): Integer;
begin
  Result := Value;
  if (Result < Min) or (Result > Max) then
    raise Exception.CreateFmt(FloatExceptionMessage, ['The value', Min.ToString, Max.ToString, Result.ToString]);
end;

function CheckInteger(const Value, Min, Max: Int64): Int64;
begin
  Result := Value;
  if (Result < Min) or (Result > Max) then
    raise Exception.CreateFmt(FloatExceptionMessage, ['The value', Min.ToString, Max.ToString, Result.ToString]);
end;

function CheckFloat(const FieldName: string; Value, Min, Max: Double): string; overload;
begin
  Result := FieldName;
  if (Value < Min) or (Value > Max) then
    raise Exception.CreateFmt(FloatExceptionMessage, [Result, Min.ToString, Max.ToString, FormatFloat('0.00', Value, FormatSettings)]);
end;

function CheckFloat(const Value, Min, Max: Double): Double;
begin
  Result := Value;
  if (Result < Min) or (Result > Max) then
    raise Exception.CreateFmt(FloatExceptionMessage, ['The value', Min.ToString, Max.ToString, FormatFloat('0.00', Result, FormatSettings)]);
end;

function CheckMultipleOf(const Value, Min, MultipleOf: Integer): Integer;
begin
  Result := Value;
  if (Result < Min) or (Result mod MultipleOf <> 0) then
    raise Exception.CreateFmt(MultipleOfExceptionMessage, [MultipleOf, Min, Result]);
end;

{ TFinishReasonHelper }

class function TFinishReasonHelper.create(const Value: string): TFinishReason;
begin
  var index := IndexStr(Value.ToUpper, ['SUCCESS', 'CONTENT_FILTERED', 'ERROR']);
  if index = -1 then
    raise Exception.Create(FinishReasonUnknownExceptionMessage);
  Result := TFinishReason(index);
end;

function TFinishReasonHelper.ToString: string;
begin
  case Self of
    SUCCESS:
      Exit('SUCCESS');
    CONTENT_FILTERED:
      Exit('CONTENT_FILTERED');
    {--- Only for version 1 }
    ERROR:
      Exit('ERROR');
  end;
end;

{ TFinishReasonInterceptor }

function TFinishReasonInterceptor.StringConverter(Data: TObject; Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TFinishReason>.ToString;
end;

procedure TFinishReasonInterceptor.StringReverter(Data: TObject; Field, Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TFinishReason.Create(Arg)));
end;

{ TStableImageCommon }

function TStableImageCommon.NegativePrompt(
  const Value: string): TStableImageCommon;
begin
  AddField(Check('negative_prompt', Value), Value);
  Result := Self;
end;

function TStableImageCommon.OutputFormat(
  const Value: TOutPutFormat): TStableImageCommon;
begin
  AddField('output_format', Value.ToString);
  Result := Self;
end;

function TStableImageCommon.Prompt(const Value: string): TStableImageCommon;
begin
  AddField(Check('prompt', Value), Value);
  Result := Self;
end;

function TStableImageCommon.Seed(const Value: Int64): TStableImageCommon;
begin
  AddField(CheckInteger('seed', Value, 0, SeedMax), Value.ToString);
  Result := Self;
end;

{ TStableImageRatio }

function TStableImageRatio.AspectRatio(
  const Value: TAspectRatioType): TStableImageRatio;
begin
  AddField('aspect_ratio', Value.ToString);
  Result := Self;
end;

{ TStableImage }

function TStableImage.GetStream: TStream;
begin
  {--- Create a memory stream to write the decoded content. }
  Result := TMemoryStream.Create;
  try
    {--- Convert the base-64 string directly into the memory stream. }
    if not Image.IsEmpty then
      DecodeBase64ToStream(Image, Result)
    else
    if not Video.IsEmpty then
      DecodeBase64ToStream(Image, Result)
    else
      raise Exception.Create(StreamEmptyExceptionMessage);
  except
    Result.Free;
    raise;
  end;
end;

procedure TStableImage.SaveToFile(const FileName: string);
begin
  try
    Self.FFileName := FileName;

    {--- Perform the decoding operation and save it into the file specified by the FileName parameter. }
    if not Video.IsEmpty then
      DecodeBase64ToFile(Video, FileName)
    else
      DecodeBase64ToFile(Image, FileName);
  except
    raise;
  end;
end;

{ TEditCommon }

function TEditCommon.Image(const FilePath: string): TEditCommon;
begin
  AddBytes('image', FileToBytes(FilePath), FilePath);
  Result := Self;
end;

function TEditCommon.Image(const Stream: TStream; StreamFreed: Boolean): TEditCommon;
begin
  if StreamFreed then
    {--- The stream's content is automatically freed. }
    AddStream('image', Stream, True, 'FileNameForHeader.png')
  else
    {--- You should release the stream's content. }
    AddBytes('image', StreamToBytes(Stream), 'FileNameForHeader.png');
  Result := Self;
end;

function TEditCommon.OutputFormat(const Value: TOutPutFormat): TEditCommon;
begin
  AddField('output_format', Value.ToString);
  Result := Self;
end;

{ TEditSeedCommon }

function TEditSeedCommon.Seed(const Value: Int64): TEditSeedCommon;
begin
  AddField(CheckInteger('seed', Value, 0, SeedMax), Value.ToString);
  Result := Self;
end;

{ TEditSeedAndGrowMaskCommon }

function TEditSeedAndGrowMaskCommon.GrowMask(
  const Value: Integer): TEditSeedAndGrowMaskCommon;
begin
  AddField(CheckInteger('grow_mask', Value, 0, 20), Value.ToString);
  Result := Self;
end;

{ TEditSeedAndGrowMaskAndPromtCommon }

function TEditSeedAndGrowMaskAndPromtCommon.Prompt(
  const Value: string): TEditSeedAndGrowMaskAndPromtCommon;
begin
  AddField(Check('prompt', Value), Value);
  Result := Self;
end;

{ TUpscaleCommon }

function TUpscaleCommon.Image(const FilePath: string): TUpscaleCommon;
begin
  AddBytes('image', FileToBytes(FilePath), FilePath);
  Result := Self;
end;

function TUpscaleCommon.Image(const Stream: TStream;
  StreamFreed: Boolean): TUpscaleCommon;
begin
  if StreamFreed then
    {--- The stream's content is automatically freed. }
    AddStream('image', Stream, True, 'FileNameForHeader.png')
  else
    {--- You should release the stream's content. }
    AddBytes('image', StreamToBytes(Stream), 'FileNameForHeader.png');
  Result := Self;
end;

end.

unit StabilityAI.Consts;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiStabilityAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

const
  PromptMax = 10000;
  SeedMax = 4294967294;

resourcestring
  PromptExceptionMessage = '%s too long max %d : (%d)';
  IntegerExceptionMessage = '%s must be in [%d..%d] : %d';
  FloatExceptionMessage = '%s must be in [%s..%s] : %s';
  DataFileEmptyExceptionMessage = 'No data to save.';
  StreamEmptyExceptionMessage = 'The stream is empty.';
  DataEmptyExceptionMessage = 'The model data string is empty.';
  MultipleOfExceptionMessage = 'The Value must be multiple of %d and greater than %d : %d';
  FileNameNotNullExceptionMessage = 'The filename can''t be null';
  FinishReasonUnknownExceptionMessage = 'Finish reason unkonw.';

implementation

end.

unit StabilityAI.Errors;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiStabilityAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  REST.Json.Types;

type
  TErrorCore = class abstract
  end;

  TError = class(TErrorCore)
  private
    FId: string;
    FName: string;
    FErrors: TArray<string>;
  public
    property Id: string read FId write FId;
    property Name: string read FName write FName;
    property Errors: TArray<string> read FErrors write FErrors;
  end;

implementation


end.

unit StabilityAI.NetEncoding.Base64;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiStabilityAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.NetEncoding, System.Net.Mime, System.IOUtils;

  /// <summary>
  /// Decodes a Base64-encoded string and writes the resulting binary data to a specified file.
  /// </summary>
  /// <param name="Base64Str">The Base64-encoded string to decode.</param>
  /// <param name="FileName">The full path and name of the file where the decoded data will be written.</param>
  /// <exception cref="Exception">
  /// Thrown if the Base64 string cannot be decoded or if there is an error writing to the specified file.
  /// </exception>
  procedure DecodeBase64ToFile(const Base64Str: string; const FileName: string);
  /// <summary>
  /// Saves a byte array to a specified file.
  /// </summary>
  /// <param name="Data">The byte array to be written to the file.</param>
  /// <param name="FileName">The full path and name of the file where the data will be saved.</param>
  /// <exception cref="Exception">
  /// Thrown if the <paramref name="Data"/> array is empty, if the existing file cannot be deleted,
  /// or if there is an error writing to the specified file.
  /// </exception>
  /// <remarks>
  /// This procedure writes the provided byte array to the specified file.
  /// If the file already exists, it will be deleted before writing the new data.
  /// Ensure that the application has the necessary permissions to write to the specified location.
  /// Use this method when you need to persist binary data, such as saving decoded files or handling raw file content.
  /// </remarks>
  procedure SaveBytesToFile(const Data: TBytes; const FileName: string);
  /// <summary>
  /// Decodes a Base64-encoded string and writes the resulting binary data to the provided stream.
  /// </summary>
  /// <param name="Base64Str">The Base64-encoded string to decode.</param>
  /// <param name="Stream">The stream where the decoded binary data will be written. The stream should be writable.</param>
  /// <exception cref="Exception">
  /// Thrown if the Base64 string cannot be decoded or if there is an error writing to the provided stream.
  /// </exception>
  /// <remarks>
  /// After decoding, the stream's position is reset to the beginning.
  /// Ensure that the stream is properly managed and freed after use to avoid memory leaks.
  /// </remarks>
  procedure DecodeBase64ToStream(const Base64Str: string; const Stream: TStream);
  /// <summary>
  /// Encodes the content of a file into a Base64-encoded string.
  /// </summary>
  /// <param name="FileLocation">The full path to the file that will be encoded.</param>
  /// <returns>A Base64-encoded string representing the content of the file.</returns>
  /// <exception cref="Exception">Thrown if the specified file does not exist at the provided location.</exception>
  /// <remarks>
  /// This method reads the file from the specified location and converts it to a Base64 string.
  /// It uses different encoding methods depending on the version of the RTL.
  /// For RTL version 35.0 and later, it uses <c>TNetEncoding.Base64String.Encode</c>,
  /// and for earlier versions, it uses <c>TNetEncoding.Base64.Encode</c>.
  /// </remarks>
  function EncodeBase64(FileLocation : string) : WideString;
  /// <summary>
  /// Reads the contents of a file and returns them as a byte array.
  /// </summary>
  /// <param name="FilePath">The full path to the file to be read.</param>
  /// <returns>
  /// A <c>TBytes</c> array containing the binary data from the specified file.
  /// </returns>
  /// <exception cref="Exception">
  /// Thrown if the file does not exist at the specified <paramref name="FilePath"/> or if there is an error accessing the file.
  /// </exception>
  /// <remarks>
  /// This function opens the file located at <paramref name="FilePath"/> in read-only mode and reads its entire content into a byte array.
  /// Ensure that the file path is valid and that the application has the necessary permissions to access the file.
  /// Use this function when you need to manipulate or transmit the raw binary data of a file.
  /// </remarks>
  function FileToBytes(const FilePath: string): TBytes;
  /// <summary>
  /// Reads the entire content of the provided stream and returns it as a byte array.
  /// </summary>
  /// <param name="Stream">
  /// The input <c>TStream</c> from which to read the data. The stream must be readable and properly initialized.
  /// </param>
  /// <returns>
  /// A <c>TBytes</c> array containing the binary data read from the stream.
  /// </returns>
  /// <exception cref="Exception">
  /// Thrown if there is an error reading from the stream, such as insufficient permissions or an unexpected end of stream.
  /// </exception>
  /// <remarks>
  /// This function reads all bytes from the specified <paramref name="Stream"/> and returns them as a <c>TBytes</c> array.
  /// After reading, the stream's position is reset to the beginning to allow for subsequent read operations.
  /// Ensure that the stream is properly managed and disposed of after use to prevent memory leaks or resource locking.
  /// Use this method when you need to convert stream data into a byte array for further processing or storage.
  /// </remarks>
  function StreamToBytes(const Stream: TStream): TBytes;
  /// <summary>
  /// Retrieves the MIME type of the specified file based on its location.
  /// </summary>
  /// <param name="FileLocation">The full path to the file whose MIME type is to be resolved.</param>
  /// <returns>
  /// A string representing the MIME type of the file.
  /// If the file does not exist, an exception will be raised.
  /// </returns>
  /// <exception cref="Exception">
  /// Thrown if the specified file cannot be found at the provided location.
  /// </exception>
  /// <remarks>
  /// This method checks if the specified file exists and retrieves its MIME type
  /// using the <c>TMimeTypes.Default.GetFileInfo</c> method.
  /// Ensure the provided path is valid before calling this function.
  /// </remarks>
  function ResolveMimeType(const FileLocation: string): string;
  /// <summary>
  /// Retrieves the size of the specified file in bytes.
  /// </summary>
  /// <param name="FileLocation">
  /// The full path to the file whose size is to be determined.
  /// </param>
  /// <returns>
  /// An <c>Int64</c> value representing the file size in bytes.
  /// </returns>
  /// <exception cref="Exception">
  /// Raised if the specified file cannot be accessed or does not exist at the provided location.
  /// </exception>
  /// <remarks>
  /// This function verifies the existence of the specified file and, if accessible, retrieves its size
  /// using the <c>TFile.GetSize</c> method. Ensure that the file path is valid and accessible
  /// before calling this function.
  /// </remarks>
  function FileSize(const FileLocation: string): Int64;
  /// <summary>
  /// Provides the image data as a Base64-encoded string with a MIME type or as a direct URL.
  /// </summary>
  /// <param name="FileLocation">
  /// The full path to the image file on the local filesystem or a URL.
  /// </param>
  /// <returns>
  /// A string representing the image data:
  /// <para>
  /// - If <paramref name="FileLocation"/> is a local file path, it returns a data URI with a MIME type and Base64-encoded content.
  /// </para>
  /// <para>
  /// - If <paramref name="FileLocation"/> is a URL (starting with "http"), it returns the URL as-is.
  /// </para>
  /// </returns>
  /// <exception cref="Exception">
  /// Raised if the file does not exist at the provided local file path.
  /// </exception>
  /// <remarks>
  /// This function checks if <paramref name="FileLocation"/> is a URL by verifying if it starts with "http".
  /// If it is a URL, it returns it directly as the output.
  /// For local files, it verifies the file's existence, retrieves the MIME type, and encodes the content in Base64 format
  /// to create a data URI for embedding purposes. This data URI can then be used directly in HTML or other contexts where
  /// embedded image data is required.
  /// </remarks>
  function ImageDataProvider(FileLocation : string) : WideString;

implementation

procedure SaveBytesToFile(const Data: TBytes; const FileName: string);
begin
  if Length(Data) = 0 then
    raise Exception.Create('Empty GLB data.');
  if FileExists(FileName) then
    begin
      DeleteFile(FileName);
      Sleep(300);
    end;
  var MemStream := TMemoryStream.Create;
  try
    MemStream.WriteBuffer(Data[0], Length(Data));
    MemStream.Position := 0;
    MemStream.SaveToFile(FileName);
  finally
    MemStream.Free;
  end;
end;

procedure DecodeBase64ToFile(const Base64Str: string; const FileName: string);
begin
  {--- Convert Base64 string to byte array for input stream }
  var Bytes := TEncoding.UTF8.GetBytes(Base64Str);

  {--- Create the flows }
  var InputStream := TBytesStream.Create(Bytes);
  var OutputStream := TFileStream.Create(FileName, fmCreate);
  try
    {--- Decode using TNetEncoding.Base64.Decode (stream) }
    TNetEncoding.Base64.Decode(InputStream, OutputStream);
  finally
    InputStream.Free;
    OutputStream.Free;
  end;
end;

procedure DecodeBase64ToStream(const Base64Str: string; const Stream: TStream);
begin
  {--- Converts the base64 string directly into the memory stream }
  var InputStream := TBytesStream.Create(TEncoding.UTF8.GetBytes(Base64Str));
    try
      TNetEncoding.Base64.Decode(InputStream, Stream);
      Stream.Position := 0;
    finally
      InputStream.Free;
    end;
end;

function EncodeBase64(FileLocation : string): WideString;
begin
  if not FileExists(FileLocation) then
    raise Exception.CreateFmt('File not found : %s', [FileLocation]);

  var Stream := TMemoryStream.Create;
  var StreamOutput := TStringStream.Create('', TEncoding.UTF8);
  try
    Stream.LoadFromFile(FileLocation);
    Stream.Position := 0;
    {$IF RTLVersion >= 35.0}
    TNetEncoding.Base64String.Encode(Stream, StreamOutput);
    {$ELSE}
    TNetEncoding.Base64.Encode(Stream, StreamOutput);
    {$ENDIF}
    Result := StreamOutput.DataString;
  finally
    Stream.Free;
    StreamOutput.Free;
  end;
end;

function FileToBytes(const FilePath: string): TBytes;
begin
  if not FileExists(FilePath) then
    raise Exception.CreateFmt('File not found : %s', [FilePath]);

  var InputFile := TFileStream.Create(FilePath, fmOpenRead or fmShareDenyNone);
  try
    Result := StreamToBytes(InputFile);
  finally
    InputFile.Free;
  end;
end;

function StreamToBytes(const Stream: TStream): TBytes;
begin
  SetLength(Result, Stream.Size);
  Stream.ReadBuffer(Result[0], Stream.Size);
  Stream.Position := 0;
end;

function ResolveMimeType(const FileLocation: string): string;
begin
  if not FileExists(FileLocation) then
    raise Exception.CreateFmt('File not found: %s', [FileLocation]);

  var LKind: TMimeTypes.TKind;
  TMimeTypes.Default.GetFileInfo(FileLocation, Result, LKind);
end;

function FileSize(const FileLocation: string): Int64;
begin
  try
    FileSize := TFile.GetSize(FileLocation);
  except
    raise;
  end;
end;

function ImageDataProvider(FileLocation : string) : WideString;
begin
  if FileLocation.ToLower.StartsWith('http') then
    Result := FileLocation
  else
  if FileExists(FileLocation) then
    Result := Format('data:%s;base64,%s', [ResolveMimeType(FileLocation), EncodeBase64(FileLocation)])
  else
    raise Exception.CreateFmt('File not found : %s', [FileLocation]);
end;

end.

unit StabilityAI;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiStabilityAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Net.URLClient, StabilityAI.API,
  {--- Version 2 beta }
  StabilityAI.StableImage.Generate, StabilityAI.StableImage.Upscale,
  StabilityAI.StableImage.Results, StabilityAI.StableImage.Edit,
  StabilityAI.StableImage.Control, StabilityAI.VideoAnd3D.Stable3D,
  StabilityAI.VideoAnd3D.Video,
  {--- Version 1 }
  StabilityAI.Version1.Engines, StabilityAI.Version1.SDXL1AndSD1_6,
  StabilityAI.Version1.User;

type
  TStableImage = class;
  TVideoAnd3D = class;
  TVersion1 = class;

  /// <summary>
  /// The <c>IStabilityAI</c> interface provides access to the various features and routes of the StabilityAI AI API.
  /// This interface allows interaction with different services such as agents, chat, code completion,
  /// embeddings, file management, fine-tuning, and model information.
  /// </summary>
  /// <remarks>
  /// This interface should be implemented by any class that wants to provide a structured way of accessing
  /// the StabilityAI AI services. It includes methods and properties for authenticating with an API key,
  /// configuring the base URL, and accessing different API routes.
  ///
  /// To use this interface, instantiate a class that implements it, set the required properties such as
  /// <see cref="Token"/> and <see cref="BaseURL"/>, and call the relevant methods for the desired operations.
  /// <code>
  ///   var StabilityAI: IStabilityAI := TStabilityAI.Create(API_TOKEN);
  /// </code>
  /// <seealso cref="TStabilityAI"/>
  /// </remarks>
  IStabilityAI = interface
    ['{6C323A77-2CD8-429B-BAA3-871CFF307C90}']
    function GetAPI: TStabilityAIAPI;
    procedure SetToken(const Value: string);
    function GetToken: string;
    function GetBaseUrl: string;
    procedure SetBaseUrl(const Value: string);

    function GetStableImage: TStableImage;
    function GetVideoAnd3D: TVideoAnd3D;
    function GetVersion1: TVersion1;

    /// <summary>
    /// the main API object used for making requests.
    /// </summary>
    /// <returns>
    /// An instance of TStabilityAIAPI for making API calls.
    /// </returns>
    property API: TStabilityAIAPI read GetAPI;
    /// Sets or retrieves the API token for authentication.
    /// </summary>
    /// <param name="Value">
    /// The API token as a string.
    /// </param>
    /// <returns>
    /// The current API token.
    /// </returns>
    property Token: string read GetToken write SetToken;
    /// <summary>
    /// Sets or retrieves the base URL for API requests.
    /// Default is https://api.StabilityAI.com/v1
    /// </summary>
    /// <param name="Value">
    /// The base URL as a string.
    /// </param>
    /// <returns>
    /// The current base URL.
    /// </returns>
    property BaseURL: string read GetBaseUrl write SetBaseUrl;
    /// <summary>
    /// REST v2beta API service
    /// </summary>
    /// <remarks>
    /// The REST v2beta API service is becoming the primary API service for the Stability Platform. All AI services available through other APIs (gRPC, REST v1, REST v2alpha) will continue to be maintained; however, these APIs will no longer receive new features or parameters.
    /// </remarks>
    property StableImage: TStableImage read GetStableImage;
    /// <summary>
    /// API for 3D and ultra-short videos.
    /// </summary>
    /// <remarks>
    /// These APIs enable 3D creation in the gLTF format from an image or the production of a 5-second video, also based on an image.
    /// </remarks>
    property VideoAnd3D: TVideoAnd3D read GetVideoAnd3D;
    /// <summary>
    /// REST v1 API service
    /// </summary>
    /// <remarks>
    /// Eventually these APIs should disappear.
    /// </remarks>
    property Version1: TVersion1 read GetVersion1;
  end;

  /// <summary>
  /// The <c>TStabilityAIFactory</c> class is responsible for creating instances of
  /// the <see cref="IStabilityAI"/> interface. It provides a factory method to instantiate
  /// the interface with a provided API token and optional header configuration.
  /// </summary>
  /// <remarks>
  /// This class provides a convenient way to initialize the <see cref="IStabilityAI"/> interface
  /// by encapsulating the necessary configuration details, such as the API token and header options.
  /// By using the factory method, users can quickly create instances of <see cref="IStabilityAI"/> without
  /// manually setting up the implementation details.
  /// </remarks>
  TStabilityAIFactory = class
    /// <summary>
    /// Creates an instance of the <see cref="IStabilityAI"/> interface with the specified API token
    /// and optional header configuration.
    /// </summary>
    /// <param name="AToken">
    /// The API token as a string, required for authenticating with StabilityAI API services.
    /// </param>
    /// <param name="Option">
    /// An optional header configuration of type <see cref="THeaderOption"/> to customize the request headers.
    /// The default value is <c>THeaderOption.none</c>.
    /// </param>
    /// <returns>
    /// An instance of <see cref="IStabilityAI"/> initialized with the provided API token and header option.
    /// </returns>
    /// <remarks>
    /// Code example
    /// <code>
    /// var StabilityAICloud := TStabilityAIFactory.CreateInstance(BaererKey);
    ///
    /// </code>
    /// WARNING : Please take care to adjust the SCOPE of the <c>StabilityAICloud</c> interface in you application.
    /// </remarks>
    class function CreateInstance(const AToken: string): IStabilityAI;
  end;

  TStabilityAI = class;

  TStableImageCore = class
  private
    FOwner: TStabilityAI;
  public
    constructor Create(const AOwner: TStabilityAI);
  end;

  /// <summary>
  /// The <c>TStableImage</c> class provides tools and methods for image generation, editing, upscaling,
  /// and controlled variation using StabilityAI's Stable Diffusion models. This class acts as a core
  /// component for image-based operations within the StabilityAI API.
  /// </summary>
  /// <remarks>
  /// This class includes features to generate new images, upscale existing images, edit images using
  /// various techniques, and apply precise control over variations.
  /// It supports different models for diverse creative needs, from photorealistic outputs to quick
  /// concept ideation.
  /// <para>
  /// - Image Generation: Generate photorealistic or concept images using text prompts.
  /// </para>
  /// <para>
  /// - Image Upscaling: Enhance image resolution using multiple upscaling techniques.
  /// </para>
  /// <para>
  /// - Image Editing: Modify images with tools such as inpainting, outpainting, object erasure,
  /// and color manipulation.
  /// </para>
  /// <para>
  /// - Controlled Variations: Generate precise variations of images using sketching, structure, or
  /// style-based approaches.
  /// </para>
  /// This class relies on API routes provided by <c>TStabilityAI</c> for all operations.
  /// </remarks>
  TStableImage = class(TStableImageCore)
  private
    FGenerateRoute: TGenerateRoute;
    FUpscaleRoute: TUpscaleRoute;
    FEditRoute: TEditRoute;
    FControlRoute: TControlRoute;
    FResultsRoute: TResultsRoute;
    function GetGenerateRoute: TGenerateRoute;
    function GetUpscaleRoute: TUpscaleRoute;
    function GetEditRoute: TEditRoute;
    function GetControlRoute: TControlRoute;
    function GetResultsRoute: TResultsRoute;
  public
    /// <summary>
    /// Tools designed to create fresh images from text descriptions or to produce variations of existing images.
    /// </summary>
    /// <remarks>
    /// <para>
    /// - Stable Image Ultra: Photorealistic outputs for professional and large-scale use.
    /// </para>
    /// <para>
    /// - Stable Image Core: Fast, affordable generation for quick concept ideation.
    /// </para>
    /// <para>
    /// - Stable Diffusion 3 et 3.5: Versatile models for high-quality, high-volume digital assets.
    /// </para>
    /// </remarks>
    property Generate: TGenerateRoute read GetGenerateRoute;
    /// <summary>
    /// Versatile upscaling solutions: fast, precise, and creatively enhanced results.
    /// </summary>
    /// <remarks>
    /// <para>
    /// - Fast Upscaler: Quick 4x resolution boost for compressed images.
    /// </para>
    /// <para>
    /// - Conservative Upscaler: Precise upscale to 4 megapixels with minimal changes.
    /// </para>
    /// <para>
    /// - Creative Upscaler: Enhances degraded images creatively to high resolution.
    /// </para>
    /// </remarks>
    property Upscale: TUpscaleRoute read GetUpscaleRoute;
    /// <summary>
    /// Tools for modifying your own images and those that are generated.
    /// </summary>
    /// <remarks>
    /// <para>
    /// - Erase: Removes unwanted objects using image masks.
    /// </para>
    /// <para>
    /// - Outpaint: Extends images by adding content in any direction.
    /// </para>
    /// <para>
    /// - Inpaint: Replaces specified areas with content based on a mask.
    /// </para>
    /// <para>
    /// - Search and Replace: Replaces objects using prompts, no mask needed.
    /// </para>
    /// <para>
    /// - Search and Recolor: Changes object colors based on prompts
    /// </para>
    /// <para>
    /// - Remove Background: Segments and removes backgrounds accurately.
    /// </para>
    /// </remarks>
    property Edit: TEditRoute read GetEditRoute;
    /// <summary>
    /// Tools designed to create precise and controlled variations of existing images or sketches.
    /// </summary>
    /// <remarks>
    /// <para>
    /// - Sketch: Refines sketches or manipulates images using contours.
    /// </para>
    /// <para>
    /// - Structure: Preserves image structure for recreations or character rendering
    /// </para>
    /// <para>
    /// - Style: Applies control image styles to guided image creation
    /// </para>
    /// </remarks>
    property Control: TControlRoute read GetControlRoute;
    /// <summary>
    /// Methods for retrieving the outcomes of your asynchronous processes.
    /// </summary>
    property Results: TResultsRoute read GetResultsRoute;
    destructor Destroy; override;
  end;

  /// <summary>
  /// The <c>TVideoAnd3D</c> class provides advanced tools and methods for generating 3D models and
  /// creating short videos based on images using StabilityAI's cutting-edge AI capabilities.
  /// This class extends the StabilityAI API's functionality to include 3D and video-based outputs.
  /// </summary>
  /// <remarks>
  /// This class enables the creation of realistic 3D assets and high-quality short video sequences
  /// using input images or prompts. It supports various formats and techniques to deliver outputs
  /// optimized for creative and professional use cases.
  /// <para>
  /// - 3D Model Generation: Generate 3D assets in glTF binary format, ready for integration into
  /// compatible 3D applications.
  /// </para>
  /// <para>
  /// - Video Creation: Create short, high-quality video clips from images or text-based prompts using
  /// advanced video diffusion models.
  /// </para>
  /// The generated outputs are suitable for applications in game development, animation, virtual
  /// reality, and creative content production. This class relies on StabilityAI's <c>TStabilityAI</c>
  /// API routes for all its operations.
  /// </remarks>
  TVideoAnd3D = class(TStableImageCore)
  private
    FModel3DRoute: TModel3DRoute;
    FVideoRoute: TVideoRoute;
    function GetModel3DRoute: TModel3DRoute;
    function GetVideoRoute: TVideoRoute;
  public
    /// <summary>
    /// Advanced 3D Asset Generation from 2D Input
    /// </summary>
    /// <remarks>
    /// The files generated through "Advanced 3D Asset Generation from 2D Input" are in the model/gltf-binary format. The output is a binary blob containing a fully integrated glTF asset, ready for use in compatible 3D applications and platforms.
    /// </remarks>
    property Model3D: TModel3DRoute read GetModel3DRoute;
    /// <summary>
    /// Creating a short video starting from an initial image using Stable Video Diffusion, a latent video diffusion model.
    /// </summary>
    /// <remarks>
    /// Using Stable Video Diffusion the cutting-edge latent video diffusion model for high-resolution text-to-video and image-to-video generation, emphasizing systematic training stages and high-quality dataset curation for superior video synthesis.
    /// </remarks>
    property ImageToVideo: TVideoRoute read GetVideoRoute;
    destructor Destroy; override;
  end;

  /// <summary>
  /// The <c>TVersion1</c> class provides access to StabilityAI's Version 1 API endpoints,
  /// including tools for image generation, engine enumeration, and user account management.
  /// This class supports legacy features and models like SDXL 1.0 and SD1.6 for generating high-quality
  /// images.
  /// </summary>
  /// <remarks>
  /// This class enables interaction with StabilityAI's Version 1 REST API, allowing users to:
  /// <para>
  /// - Image Generation: Create images using the SDXL 1.0 and SD1.6 models, suitable for diverse use cases
  /// such as concept design and photorealistic rendering.
  /// </para>
  /// <para>
  /// - Engine Enumeration: Discover and manage available engines compatible with Version 1 endpoints.
  /// </para>
  /// <para>
  /// - User Account Management: Access account information, view balances, and manage organization-level
  /// settings.
  /// </para>
  /// While this API is considered legacy, it remains a reliable choice for projects leveraging older models
  /// or requiring specific features only available in Version 1. For newer features, consider transitioning
  /// to Version 2 APIs.
  /// </remarks>
  TVersion1 = class(TStableImageCore)
  private
    FVersion1Route: TVersion1Route;
    FEnginesRoute: TEnginesRoute;
    FUserRoute: TUserRoute;
    function GetVersion1Route: TVersion1Route;
    function GetEnginesRoute: TEnginesRoute;
    function GetUserRoute: TUserRoute;
  public
    /// <summary>
    /// Generate images using SDXL 1.0 or SD1.6.
    /// </summary>
    property SDXLAndSDL: TVersion1Route read GetVersion1Route;
    /// <summary>
    /// Enumerate engines that work with 'Version 1' REST API endpoints.
    /// </summary>
    property Engines: TEnginesRoute read GetEnginesRoute;
    /// <summary>
    /// Manage your Stability account, and view account/organization balances.
    /// </summary>
    property User:TUserRoute read GetUserRoute;
    destructor Destroy; override;
  end;

  /// <summary>
  /// The TStabilityAI class provides access to the various features and routes of the StabilityAI AI API.
  /// This class allows interaction with different services such as agents, chat, code completion,
  /// embeddings, file management, fine-tuning, and model information.
  /// </summary>
  /// <remarks>
  /// This class should be implemented by any class that wants to provide a structured way of accessing
  /// the StabilityAI AI services. It includes methods and properties for authenticating with an API key,
  /// configuring the base URL, and accessing different API routes.
  /// <seealso cref="TStabilityAI"/>
  /// </remarks>
  TStabilityAI = class(TInterfacedObject, IStabilityAI)
  strict private

  private
    FAPI: TStabilityAIAPI;
    FStableImage: TStableImage;
    FVideoAnd3D: TVideoAnd3D;
    FVersion1: TVersion1;

    function GetAPI: TStabilityAIAPI;
    function GetToken: string;
    procedure SetToken(const Value: string);
    function GetBaseUrl: string;
    procedure SetBaseUrl(const Value: string);
    function GetStableImage: TStableImage;
    function GetVideoAnd3D: TVideoAnd3D;
    function GetVersion1: TVersion1;
  public
    /// <summary>
    /// the main API object used for making requests.
    /// </summary>
    /// <returns>
    /// An instance of TStabilityAIAPI for making API calls.
    /// </returns>
    property API: TStabilityAIAPI read GetAPI;
    /// <summary>
    /// Sets or retrieves the API token for authentication.
    /// </summary>
    /// <param name="Value">
    /// The API token as a string.
    /// </param>
    /// <returns>
    /// The current API token.
    /// </returns>
    property Token: string read GetToken write SetToken;
    /// <summary>
    /// Sets or retrieves the base URL for API requests.
    /// Default is https://api.stability.ai
    /// </summary>
    /// <param name="Value">
    /// The base URL as a string.
    /// </param>
    /// <returns>
    /// The current base URL.
    /// </returns>
    property BaseURL: string read GetBaseUrl write SetBaseUrl;

  public
    /// <summary>
    /// Initializes a new instance of the <see cref="TStabilityAI"/> class with optional header configuration.
    /// </summary>
    /// <param name="Option">
    /// An optional parameter of type <see cref="THeaderOption"/> to configure the request headers.
    /// The default value is <c>THeaderOption.none</c>.
    /// </param>
    /// <remarks>
    /// This constructor is typically used when no API token is provided initially.
    /// The token can be set later via the <see cref="Token"/> property.
    /// </remarks>
    constructor Create; overload;
    /// <summary>
    /// Initializes a new instance of the <see cref="TStabilityAI"/> class with the provided API token and optional header configuration.
    /// </summary>
    /// <param name="AToken">
    /// The API token as a string, required for authenticating with the StabilityAI AI API.
    /// </param>
    /// <param name="Option">
    /// An optional parameter of type <see cref="THeaderOption"/> to configure the request headers.
    /// The default value is <c>THeaderOption.none</c>.
    /// </param>
    /// <remarks>
    /// This constructor allows the user to specify an API token at the time of initialization.
    /// </remarks>
    constructor Create(const AToken: string); overload;
    /// <summary>
    /// Releases all resources used by the current instance of the <see cref="TStabilityAI"/> class.
    /// </summary>
    /// <remarks>
    /// This method is called to clean up any resources before the object is destroyed.
    /// It overrides the base <see cref="TInterfacedObject.Destroy"/> method.
    /// </remarks>
    destructor Destroy; override;
  end;

implementation

{ TStabilityAI }

constructor TStabilityAI.Create;
begin
  inherited Create;
  FAPI := TStabilityAIAPI.Create;
  FStableImage := TStableImage.Create(Self);
  FVideoAnd3D := TVideoAnd3D.Create(Self);
  FVersion1 := TVersion1.Create(Self);
end;

constructor TStabilityAI.Create(const AToken: string);
begin
  Create;
  Token := AToken;
end;

destructor TStabilityAI.Destroy;
begin
  FAPI.Free;

  FStableImage.Free;
  FVideoAnd3D.Free;
  FVersion1.Free;
  inherited;
end;

function TStabilityAI.GetAPI: TStabilityAIAPI;
begin
  Result := FAPI;
end;

function TStabilityAI.GetBaseUrl: string;
begin
  Result := FAPI.BaseURL;
end;

function TStabilityAI.GetStableImage: TStableImage;
begin
  Result := FStableImage;
end;

function TStabilityAI.GetToken: string;
begin
  Result := FAPI.Token;
end;

function TStabilityAI.GetVersion1: TVersion1;
begin
  Result := FVersion1;
end;

function TStabilityAI.GetVideoAnd3D: TVideoAnd3D;
begin
  Result := FVideoAnd3D;
end;

procedure TStabilityAI.SetBaseUrl(const Value: string);
begin
  FAPI.BaseURL := Value;
end;

procedure TStabilityAI.SetToken(const Value: string);
begin
  FAPI.Token := Value;
end;

{ TStabilityAIFactory }

class function TStabilityAIFactory.CreateInstance(const AToken: string): IStabilityAI;
begin
  Result := TStabilityAI.Create(AToken);
end;

{ TStableImage }

destructor TStableImage.Destroy;
begin
  FGenerateRoute.Free;
  FUpscaleRoute.Free;
  FEditRoute.Free;
  FControlRoute.Free;
  FResultsRoute.Free;
  inherited;
end;

function TStableImage.GetControlRoute: TControlRoute;
begin
  if not Assigned(FControlRoute) then
    FControlRoute := TControlRoute.CreateRoute(FOwner.API);
  Result := FControlRoute;
end;

function TStableImage.GetEditRoute: TEditRoute;
begin
  if not Assigned(FEditRoute) then
    FEditRoute := TEditRoute.CreateRoute(FOwner.API);
  Result := FEditRoute;
end;

function TStableImage.GetGenerateRoute: TGenerateRoute;
begin
  if not Assigned(FGenerateRoute) then
    FGenerateRoute := TGenerateRoute.CreateRoute(FOwner.API);
  Result := FGenerateRoute;
end;

function TStableImage.GetResultsRoute: TResultsRoute;
begin
  if not Assigned(FResultsRoute) then
    FResultsRoute := TResultsRoute.CreateRoute(FOwner.API);
  Result := FResultsRoute;
end;

function TStableImage.GetUpscaleRoute: TUpscaleRoute;
begin
  if not Assigned(FUpscaleRoute) then
    FUpscaleRoute := TUpscaleRoute.CreateRoute(FOwner.API);
  Result := FUpscaleRoute;
end;

{ TStableImageCore }

constructor TStableImageCore.Create(const AOwner: TStabilityAI);
begin
  inherited Create;
  FOwner := AOwner;
end;

{ TVideoAnd3D }

destructor TVideoAnd3D.Destroy;
begin
  FModel3DRoute.Free;
  FVideoRoute.Free;
  inherited;
end;

function TVideoAnd3D.GetModel3DRoute: TModel3DRoute;
begin
  if not Assigned(FModel3DRoute) then
    FModel3DRoute := TModel3DRoute.CreateRoute(FOwner.API);
  Result := FModel3DRoute;
end;

function TVideoAnd3D.GetVideoRoute: TVideoRoute;
begin
  if not Assigned(FVideoRoute) then
    FVideoRoute := TVideoRoute.CreateRoute(FOwner.API);
  Result := FVideoRoute;
end;

{ TVersion1 }

destructor TVersion1.Destroy;
begin
  FVersion1Route.Free;
  FEnginesRoute.Free;
  FUserRoute.Free;
  inherited;
end;

function TVersion1.GetEnginesRoute: TEnginesRoute;
begin
  if not Assigned(FEnginesRoute) then
    FEnginesRoute := TEnginesRoute.CreateRoute(FOwner.API);
  Result := FEnginesRoute;
end;

function TVersion1.GetUserRoute: TUserRoute;
begin
  if not Assigned(FUSerRoute) then
    FUSerRoute := TUSerRoute.CreateRoute(FOwner.API);
  Result := FUSerRoute;
end;

function TVersion1.GetVersion1Route: TVersion1Route;
begin
  if not Assigned(FVersion1Route) then
    FVersion1Route := TVersion1Route.CreateRoute(FOwner.API);
  Result := FVersion1Route;
end;

end.

unit StabilityAI.StableImage.Control;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiStabilityAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Net.Mime, REST.JsonReflect, System.JSON,
  REST.Json.Types, StabilityAI.API, StabilityAI.Common;

type
  /// <summary>
  /// The <c>TSketch</c> class provides an interface for interacting with sketch enhancement APIs.
  /// It facilitates brainstorming design projects and precise iterations by converting rough sketches into refined outputs.
  /// </summary>
  /// <remarks>
  /// <c>TSketch</c> manages configuration parameters for various sketch-based design APIs, simplifying the creation of hand-drawn sketches or manipulating contours and edges of non-sketch images.
  /// The class utilizes anonymous methods to supply these parameters to functions using the associated APIs, allowing for easy customization and rapid prototyping.
  /// </remarks>
  TSketch = class(TStableImageCommon)
    /// <summary>
    /// An image whose style you wish to use as the foundation for a generation.
    /// </summary>
    /// <param name="FilePath">
    /// Supported format (jpeg, png, webp)
    /// </param>
    /// <remarks>
    /// <para>
    /// - Every side must be at least 64 pixels
    /// </para>
    /// <para>
    /// - The total pixel count cannot exceed 9,437,184 pixels (e.g. 3072x3072, 4096x2304, etc.)
    /// </para>
    /// <para>
    /// Image aspect rotio :
    /// - Must be between 1:2.5 and 2.5:1 (i.e. cannot be too tall or too wide)
    /// </para>
    /// </remarks>
    function Image(const FilePath: string): TSketch; overload;
    /// <summary>
    /// An image whose style you wish to use as the foundation for a generation.
    /// </summary>
    /// <param name="Stream">
    /// A stream containing the image data. Supported formats include JPEG, PNG, and WEBP.
    /// </param>
    /// <param name="StreamFreed">
    /// Indicates whether the stream should be automatically freed after use. Defaults to False.
    /// </param>
    /// <remarks>
    /// <para>
    /// - Every side must be at least 64 pixels.
    /// </para>
    /// <para>
    /// - The total pixel count cannot exceed 9,437,184 pixels (e.g., 3072x3072, 4096x2304, etc.).
    /// </para>
    /// <para>
    /// Image aspect ratio:
    /// - Must be between 1:2.5 and 2.5:1 (i.e., cannot be too tall or too wide).
    /// </para>
    /// </remarks>
    function Image(const Stream: TStream; StreamFreed: Boolean = False): TSketch; overload;
    /// <summary>
    /// How much influence, or control, the image has on the generation.
    /// </summary>
    /// <param name="Value">
    /// Number: [0 .. 1] (Default: 0.7)
    /// </param>
    /// <remarks>
    /// Represented as a float between 0 and 1, where 0 is the least influence and 1 is the maximum.
    /// </remarks>
    function ControlStrength(const Value: Double): TSketch;
    constructor Create; reintroduce;
  end;

  /// <summary>
  /// The <c>TStructure</c> class encapsulates a series of APIs that specialize in generating images while preserving the structure of an input image.
  /// This class provides a convenient interface for managing parameters that are crucial for recreating complex scenes or rendering character models.
  /// </summary>
  /// <remarks>
  /// <c>TStructure</c> is designed to facilitate advanced content creation by wrapping API interactions within anonymous methods.
  /// These methods are used to seamlessly supply parameters to other routines that rely on these APIs, ensuring the integrity and structure of the original image are maintained.
  /// The class is especially valuable for scenarios where precise image recreation or character rendering is required, making it an essential tool for high-level creative processes.
  /// </remarks>
  TStructure = TSketch;

  /// <summary>
  /// The <c>TSyle</c> class represent a service that extracts stylistic elements from a control image and guides the generation of an output image accordingly.
  /// </summary>
  /// <remarks>
  /// The <c>TStyle</c> class manages the parameters for the image style extraction and creation service, encapsulating them into an anonymous method.
  /// This approach provides a convenient and modular way to provide the necessary configuration to the API methods that utilize these services.
  /// The generated image maintains the stylistic qualities of the control image while incorporating the visual content based on the given prompt.
  /// </remarks>
  TStyle = class(TStableImageRatio)
    /// <summary>
    /// An image whose style you wish to use as the foundation for a generation.
    /// </summary>
    /// <param name="FilePath">
    /// Supported format (jpeg, png, webp)
    /// </param>
    /// <returns>
    /// The updated <c>TStyle</c> instance.
    /// </returns>
    /// <remarks>
    /// <para>
    /// - Every side must be at least 64 pixels
    /// </para>
    /// <para>
    /// - The total pixel count cannot exceed 9,437,184 pixels (e.g. 3072x3072, 4096x2304, etc.)
    /// </para>
    /// <para>
    /// Image aspect rotio :
    /// - Must be between 1:2.5 and 2.5:1 (i.e. cannot be too tall or too wide)
    /// </para>
    /// </remarks>
    function Image(const FilePath: string): TStyle; overload;
    /// <summary>
    /// Sets the image to be used as the foundation for a generation from a stream.
    /// </summary>
    /// <param name="Stream">
    /// A <c>TStream</c> containing the image data.
    /// Supported formats include JPEG, PNG, and WEBP.
    /// </param>
    /// <param name="StreamFreed">
    /// Indicates whether the stream should be automatically freed after use.
    /// Set to <c>True</c> to free the stream automatically, or <c>False</c> to manage the stream's lifecycle manually.
    /// </param>
    /// <returns>
    /// The updated <c>TStyle</c> instance.
    /// </returns>
    /// <remarks>
    /// <para>
    /// - Every side of the image must be at least 64 pixels.
    /// </para>
    /// <para>
    /// - The total pixel count cannot exceed 9,437,184 pixels (e.g., 3072x3072, 4096x2304, etc.).
    /// </para>
    /// <para>
    /// - Image aspect ratio must be between 1:2.5 and 2.5:1, meaning the image cannot be excessively tall or wide.
    /// </para>
    /// </remarks>
    function Image(const Stream: TStream; StreamFreed: Boolean = False): TStyle; overload;
    /// <summary>
    /// How closely the output image's style resembles the input image's style.
    /// </summary>
    /// <param name="Value">
    /// Number: [0 .. 1] (Default: 0.5)
    /// </param>
    function Fidelity(const Value: Double): TStyle;
    constructor Create; reintroduce;
  end;

  /// <summary>
  /// The <c>TControlRoute</c> class provides an interface for advanced image processing services.
  /// This class wraps the functionality for three core services:
  /// </summary>
  /// <remarks>
  /// <para>
  /// <c>Sketch</c> - Enhances rough sketches into refined images.
  /// </para>
  /// <para>
  /// <c>Structure</c> - Preserves and recreates the structural integrity of input images, ideal for complex scenes or models.
  /// </para>
  /// <para>
  /// <c>Style</c> - Extracts stylistic elements from an image and applies them to new outputs.
  /// </para>
  /// <para>
  /// The <c>TControlRoute</c> class is part of the Stability AI image generation ecosystem, providing an easy-to-use
  /// interface for integrating the platform's advanced image manipulation capabilities.
  /// </para>
  /// <para>
  /// Each method supports both synchronous and asynchronous operations, catering to different programming needs:
  /// </para>
  /// <para>
  /// Synchronous methods return the generated image directly upon completion.
  /// </para>
  /// <para>
  /// Asynchronous methods leverage callbacks to handle success and error states, making them suitable for
  /// applications requiring non-blocking operations.
  /// </para>
  /// </remarks>
  TControlRoute = class(TStabilityAIAPIRoute)
    /// <summary>
    /// This service offers an ideal solution for design projects that require brainstorming and frequent iterations. It upgrades rough hand-drawn sketches to refined outputs with precise control. For non-sketch images, it allows detailed manipulation of the final appearance by leveraging the contour lines and edges within the image.
    /// <para>
    /// NOTE: This method is <c>synchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as image, the prompt etc.
    /// </param>
    /// <returns>
    /// Returns a <c>TStableImage</c> object that contains image base-64 generated.
    /// </returns>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    ///   var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    ///   var Data := Stability.StableImage.Control.Sketch(
    ///     procedure (Params: TSketch)
    ///     begin
    ///       Params.OutputFormat(png);
    ///       // Move on to the other parameters.
    ///     end);
    ///   var Stream := Data.GetStream;
    ///   try
    ///     //--- Save image
    ///     Data.SaveToFile(FileName);
    ///     //--- Display image
    ///     Image1.Picture.LoadFromStream(Stream);
    ///   finally
    ///     Data.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Sketch(ParamProc: TProc<TSketch>): TStableImage; overload;
    /// <summary>
    /// This service offers an ideal solution for design projects that require brainstorming and frequent iterations. It upgrades rough hand-drawn sketches to refined outputs with precise control. For non-sketch images, it allows detailed manipulation of the final appearance by leveraging the contour lines and edges within the image.
    /// <para>
    /// NOTE: This method is <c>asynchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as image, the prompt etc.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for asynchronous image creation, such as <c>onSuccess</c> and <c>onError</c>.
    /// </param>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line to the main OnCreate method for maximum scope.
    /// // var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    /// Stability.StableImage.Control.Sketch(
    ///   procedure (Params: TSketch)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynStableImage
    ///   begin
    ///     Result.Sender := Image1;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Image: TStableImage)
    ///       begin
    ///         // Handle success operation
    ///       end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle error message
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure Sketch(ParamProc: TProc<TSketch>; CallBacks: TFunc<TAsynStableImage>); overload;
    /// <summary>
    /// This service excels in generating images by maintaining the structure of an input image, making it especially valuable for advanced content creation scenarios such as recreating scenes or rendering characters from models.
    /// <para>
    /// NOTE: This method is <c>synchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as image, the prompt etc.
    /// </param>
    /// <returns>
    /// Returns a <c>TStableImage</c> object that contains image base-64 generated.
    /// </returns>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    ///   var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    ///   var Data := Stability.StableImage.Control.Structure(
    ///     procedure (Params: TStructure)
    ///     begin
    ///       Params.OutputFormat(png);
    ///       // Move on to the other parameters.
    ///     end);
    ///   var Stream := Data.GetStream;
    ///   try
    ///     //--- Save image
    ///     Data.SaveToFile(FileName);
    ///     //--- Display image
    ///     Image1.Picture.LoadFromStream(Stream);
    ///   finally
    ///     Data.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Structure(ParamProc: TProc<TStructure>): TStableImage; overload;
    /// <summary>
    /// This service excels in generating images by maintaining the structure of an input image, making it especially valuable for advanced content creation scenarios such as recreating scenes or rendering characters from models.
    /// <para>
    /// NOTE: This method is <c>asynchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as image, the prompt etc.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for asynchronous image creation, such as <c>onSuccess</c> and <c>onError</c>.
    /// </param>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line to the main OnCreate method for maximum scope.
    /// // var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    /// Stability.StableImage.Control.Structure(
    ///   procedure (Params: TStructure)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynStableImage
    ///   begin
    ///     Result.Sender := Image1;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Image: TStableImage)
    ///       begin
    ///         // Handle success operation
    ///       end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle error message
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure Structure(ParamProc: TProc<TStructure>; CallBacks: TFunc<TAsynStableImage>); overload;
    /// <summary>
    /// This service extracts stylistic elements from an input image (control image) and uses it to guide the creation of an output image based on the prompt. The result is a new image in the same style as the control image.
    /// <para>
    /// NOTE: This method is <c>synchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as image, the prompt etc.
    /// </param>
    /// <returns>
    /// Returns a <c>TStableImage</c> object that contains image base-64 generated.
    /// </returns>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    ///   var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    ///   var Data := Stability.StableImage.Control.Style(
    ///     procedure (Params: TStyle)
    ///     begin
    ///       Params.OutputFormat(png);
    ///       // Move on to the other parameters.
    ///     end);
    ///   var Stream := Data.GetStream;
    ///   try
    ///     //--- Save image
    ///     Data.SaveToFile(FileName);
    ///     //--- Display image
    ///     Image1.Picture.LoadFromStream(Stream);
    ///   finally
    ///     Data.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Style(ParamProc: TProc<TStyle>): TStableImage; overload;
    /// <summary>
    /// This service extracts stylistic elements from an input image (control image) and uses it to guide the creation of an output image based on the prompt. The result is a new image in the same style as the control image.
    /// <para>
    /// NOTE: This method is <c>asynchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as image, the prompt etc.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for asynchronous image creation, such as <c>onSuccess</c> and <c>onError</c>.
    /// </param>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line to the main OnCreate method for maximum scope.
    /// // var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    /// Stability.StableImage.Control.Style(
    ///   procedure (Params: TStyle)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynStableImage
    ///   begin
    ///     Result.Sender := Image1;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Image: TStableImage)
    ///       begin
    ///         // Handle success operation
    ///       end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle error message
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure Style(ParamProc: TProc<TStyle>; CallBacks: TFunc<TAsynStableImage>); overload;
  end;

implementation

uses
  System.StrUtils, StabilityAI.NetEncoding.Base64, StabilityAI.Async.Support;

{ TSketch }

function TSketch.ControlStrength(const Value: Double): TSketch;
begin
  AddField(CheckFloat('control_strength', Value, 0, 1), Value.ToString);
  Result := Self;
end;

constructor TSketch.Create;
begin
  inherited Create(True);
end;

function TSketch.Image(const FilePath: string): TSketch;
begin
  AddBytes('image', FileToBytes(FilePath), FilePath);
  Result := Self;
end;

function TSketch.Image(const Stream: TStream; StreamFreed: Boolean): TSketch;
begin
  if StreamFreed then
    {--- The stream's content is automatically freed. }
    AddStream('image', Stream, True, 'FileNameForHeader.png')
  else
    {--- You should release the stream's content. }
    AddBytes('image', StreamToBytes(Stream), 'FileNameForHeader.png');
  Result := Self;
end;

{ TStyle }

constructor TStyle.Create;
begin
  inherited Create(True);
end;

function TStyle.Fidelity(const Value: Double): TStyle;
begin
  AddField(CheckFloat('fidelity', Value, 0, 1), Value.ToString);
  Result := Self;
end;

function TStyle.Image(const FilePath: string): TStyle;
begin
  AddBytes('image', FileToBytes(FilePath), FilePath);
  Result := Self;
end;

function TStyle.Image(const Stream: TStream; StreamFreed: Boolean): TStyle;
begin
  if StreamFreed then
    {--- The stream's content is automatically freed. }
    AddStream('image', Stream, True, 'FileNameForHeader.png')
  else
    {--- You should release the stream's content. }
    AddBytes('image', StreamToBytes(Stream), 'FileNameForHeader.png');
  Result := Self;
end;

{ TControlRoute }

function TControlRoute.Sketch(ParamProc: TProc<TSketch>): TStableImage;
begin
  Result := API.PostForm<TStableImage, TSketch>('v2beta/stable-image/control/sketch', ParamProc);
end;

procedure TControlRoute.Sketch(ParamProc: TProc<TSketch>; CallBacks: TFunc<TAsynStableImage>);
begin
  with TAsynCallBackExec<TAsynStableImage, TStableImage>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TStableImage
      begin
        Result := Self.Sketch(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TControlRoute.Structure(ParamProc: TProc<TStructure>): TStableImage;
begin
  Result := API.PostForm<TStableImage, TStructure>('v2beta/stable-image/control/structure', ParamProc);
end;

procedure TControlRoute.Structure(ParamProc: TProc<TStructure>; CallBacks: TFunc<TAsynStableImage>);
begin
  with TAsynCallBackExec<TAsynStableImage, TStableImage>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TStableImage
      begin
        Result := Self.Structure(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TControlRoute.Style(ParamProc: TProc<TStyle>): TStableImage;
begin
  Result := API.PostForm<TStableImage, TStyle>('v2beta/stable-image/control/style', ParamProc);
end;

procedure TControlRoute.Style(ParamProc: TProc<TStyle>; CallBacks: TFunc<TAsynStableImage>);
begin
  with TAsynCallBackExec<TAsynStableImage, TStableImage>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TStableImage
      begin
        Result := Self.Style(ParamProc);
      end);
  finally
    Free;
  end;
end;

end.

unit StabilityAI.StableImage.Edit;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiStabilityAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Net.Mime, REST.JsonReflect, System.JSON,
  REST.Json.Types, StabilityAI.API, StabilityAI.Types, StabilityAI.Common;

type
  /// <summary>
  /// <c>TErase</c> is a class designed to manage parameters for the Erase image manipulation service.
  /// This service is used to remove unwanted objects from images by utilizing image masks.
  /// </summary>
  /// <remarks>
  /// <c>TErase</c> centralizes parameter handling for the Erase API, allowing for efficient reuse through anonymous methods that can be directly passed to API-consuming functions.
  /// The masks used to remove unwanted elements can be provided either explicitly via a separate image or derived from the alpha channel of the main image parameter.
  /// This class simplifies the process of configuring and managing mask-related parameters for consistent image editing operations.
  /// </remarks>
  TErase = class(TEditSeedAndGrowMaskCommon)
    /// <summary>
    /// Controls the strength of the inpainting process on a per-pixel basis, either via a second image (passed into this parameter) or via the alpha channel of the image parameter.
    /// </summary>
    /// <param name="FilePath">
    /// Filename provided
    /// </param>
    /// <remarks>
    /// <para>
    /// - <c>Mask Input Overview</c>
    /// The mask should be a black-and-white image where pixel brightness determines inpainting strength: black means no effect, white means full strength. If the mask size differs from the image, it will be resized automatically.
    /// </para>
    /// <para>
    /// - <c>Alpha Channel Support</c>
    /// If no mask is provided, the alpha channel of the image will be used to create one. Transparent areas will be inpainted, and opaque areas will remain unchanged. If both an alpha channel and a mask are given, the mask takes priority.
    /// </para>
    /// </remarks>
    function Mask(const FilePath: string): TErase; overload;
    /// <summary>
    /// An image stream containing the mask used to control the strength of the inpainting process.
    /// </summary>
    /// <param name="Stream">
    /// A <c>TStream</c> containing the mask image. Supported formats include JPEG, PNG, and WEBP.
    /// </param>
    /// <param name="StreamFreed">
    /// Indicates whether the stream should be automatically freed after processing.
    /// Set to <c>True</c> if the method should take ownership and free the stream,
    /// or <c>False</c> if the caller will manage the stream's lifecycle.
    /// Default is <c>False</c>.
    /// </param>
    /// <returns>
    /// The updated <c>TErase</c> instance.
    /// </returns>
    /// <remarks>
    /// <para>
    /// <c>Mask Input Overview:</c>
    /// The mask should be a black-and-white image where pixel brightness determines inpainting strength:
    /// black means no effect, white means full strength. If the mask size differs from the image, it will be resized automatically.
    /// </para>
    /// <para>
    /// <c>Alpha Channel Support:</c>
    /// If no mask is provided, the alpha channel of the image will be used to create one.
    /// Transparent areas will be inpainted, and opaque areas will remain unchanged.
    /// If both an alpha channel and a mask are given, the mask takes priority.
    /// </para>
    /// <para>
    /// If <c>StreamFreed</c> is set to <c>True</c>, the method will automatically free the stream after processing.
    /// If set to <c>False</c>, the caller is responsible for freeing the stream to prevent memory leaks.
    /// </para>
    /// </remarks>
    function Mask(const Stream: TStream; StreamFreed: Boolean = False): TErase; overload;
    constructor Create; reintroduce;
  end;

  /// <summary>
  /// <c>TInpaint</c> is a class that facilitates intelligent modification of images by filling in or replacing specified areas with contextually relevant content.
  /// It uses a mask image to determine which areas of the original image should be altered.
  /// </summary>
  /// <remarks>
  /// <c>TInpaint</c> manages the parameters required for image inpainting operations, providing a structured way to supply these parameters via anonymous methods to functions utilizing the inpainting API.
  /// The mask used for inpainting can be provided explicitly through a separate image or derived from the alpha channel of the original image. This approach supports seamless integration with inpainting services, ensuring precise and effective modifications to selected image areas.
  /// </remarks>
  TInpaint = class(TEditSeedAndGrowMaskAndPromtCommon)
    /// <summary>
    /// A blurb of text describing what you do not wish to see in the output image.
    /// </summary>
    /// <param name="Value">
    /// string [1 .. 10000] characters
    /// </param>
    /// <remarks>
    /// This is an advanced feature.
    /// </remarks>
    function NegativePrompt(const Value: string): TInpaint;
    /// <summary>
    /// Controls the strength of the inpainting process on a per-pixel basis, either via a second image (passed into this parameter) or via the alpha channel of the image parameter.
    /// </summary>
    /// <param name="FilePath">
    /// Filename provided
    /// </param>
    /// <remarks>
    /// <para>
    /// - <c>Mask Input Overview</c>
    /// The mask should be a black-and-white image where pixel brightness determines inpainting strength: black means no effect, white means full strength. If the mask size differs from the image, it will be resized automatically.
    /// </para>
    /// <para>
    /// - <c>Alpha Channel Support</c>
    /// If no mask is provided, the alpha channel of the image will be used to create one. Transparent areas will be inpainted, and opaque areas will remain unchanged. If both an alpha channel and a mask are given, the mask takes priority.
    /// </para>
    /// </remarks>
    function Mask(const FilePath: string): TInpaint; overload;
    /// <summary>
    /// Controls the strength of the inpainting process using an image stream.
    /// </summary>
    /// <param name="Stream">
    /// A <c>TStream</c> containing the mask image. Supported formats include JPEG, PNG, and WEBP.
    /// </param>
    /// <param name="StreamFreed">
    /// Indicates whether the stream should be automatically freed after processing.
    /// Set to <c>True</c> if the method should take ownership and free the stream,
    /// or <c>False</c> if the caller will manage the stream's lifecycle.
    /// Default is <c>False</c>.
    /// </param>
    /// <returns>
    /// The updated <c>TInpaint</c> instance.
    /// </returns>
    /// <remarks>
    /// <para>
    /// <c>Mask Input Overview:</c>
    /// </para>
    /// <para>
    /// The mask should be a black-and-white image where pixel brightness determines inpainting strength:
    /// black means no effect, white means full strength. If the mask size differs from the image, it will be resized automatically.
    /// </para>
    /// <para>
    /// <c>Alpha Channel Support:</c>
    /// If no mask is provided, the alpha channel of the image will be used to create one.
    /// Transparent areas will be inpainted, and opaque areas will remain unchanged.
    /// If both an alpha channel and a mask are given, the mask takes priority.
    /// </para>
    /// <para>
    /// If <c>StreamFreed</c> is set to <c>True</c>, the method will automatically free the stream after processing.
    /// If set to <c>False</c>, the caller is responsible for freeing the stream to prevent memory leaks.
    /// </para>
    /// </remarks>
    function Mask(const Stream: TStream; StreamFreed: Boolean = False): TInpaint; overload;
    constructor Create; reintroduce;
  end;

  /// <summary>
  /// <c>TOutpaint</c> is a class designed to manage and configure parameters for the Outpaint service, which extends existing images by filling additional space seamlessly in any direction.
  /// This class aims to facilitate efficient expansion of images while minimizing visible artifacts or signs of modification.
  /// </summary>
  /// <remarks>
  /// <c>TOutpaint</c> centralizes the handling of parameters for the Outpaint API, enabling the use of anonymous methods to pass these parameters to API-consuming functions.
  /// The approach ensures that extending an image's boundaries can be performed with minimal manual configuration, preserving consistency and visual integrity in the output.
  /// </remarks>
  TOutpaint = class(TEditSeedCommon)
    /// <summary>
    /// The number of pixels to outpaint on the left side of the image.
    /// </summary>
    /// <param name="Value">
    /// integer [ 0 .. 2000 ] (Default: 0)
    /// </param>
    /// <remarks>
    /// At least one outpainting direction must be supplied with a non-zero value.
    /// </remarks>
    function Left(const Value: Integer): TOutpaint;
    /// <summary>
    /// The number of pixels to outpaint on the right side of the image.
    /// </summary>
    /// <param name="Value">
    /// integer [ 0 .. 2000 ] (Default: 0)
    /// </param>
    /// <remarks>
    /// At least one outpainting direction must be supplied with a non-zero value.
    /// </remarks>
    function Right(const Value: Integer): TOutpaint;
    /// <summary>
    /// The number of pixels to outpaint on the top of the image.
    /// </summary>
    /// <param name="Value">
    /// integer [ 0 .. 2000 ] (Default: 0)
    /// </param>
    /// <remarks>
    /// At least one outpainting direction must be supplied with a non-zero value.
    /// </remarks>
    function Up(const Value: Integer): TOutpaint;
    /// <summary>
    /// The number of pixels to outpaint on the bottom of the image.
    /// </summary>
    /// <param name="Value">
    /// integer [ 0 .. 2000 ] (Default: 0)
    /// </param>
    /// <remarks>
    /// At least one outpainting direction must be supplied with a non-zero value.
    /// </remarks>
    function Down(const Value: Integer): TOutpaint;
    /// <summary>
    /// Controls the likelihood of creating additional details not heavily conditioned by the init image.
    /// </summary>
    /// <param name="Value">
    /// Number: [0 .. 1]  (Default: 0.5)
    /// </param>
    function Creativity(const Value: Double): TOutpaint;
    /// <summary>
    /// What you wish to see in the output image. A strong, descriptive prompt that clearly defines elements, colors, and subjects will lead to better results.
    /// </summary>
    /// <param name="Value">
    /// string [1 .. 10000] characters
    /// </param>
    /// <remarks>
    /// To control the weight of a given word use the format (word:weight), where word is the word you'd like to control the weight of and weight is a value between 0 and 1.
    /// <para>
    /// - For example: The sky was a crisp (blue:0.3) and (green:0.8) would convey a sky that was blue and green, but more green than blue.
    /// </para>
    /// </remarks>
    function Prompt(const Value: string): TOutpaint;
    constructor Create; reintroduce;
  end;

  /// <summary>
  /// <c>TSearchAndReplace</c> is a class designed to manage the parameters for the Search and Replace image inpainting service.
  /// This service allows users to locate and replace objects in an image using simple language, without requiring manual masking.
  /// </summary>
  /// <remarks>
  /// <c>TSearchAndReplace</c> centralizes the parameter management for the Search and Replace API suite. By encapsulating these parameters into a structured class, the parameters can be efficiently reused and supplied as anonymous methods to API-consuming functions.
  /// This design approach simplifies the process of object replacement in images, enabling users to use a search prompt to specify objects for automatic segmentation and replacement.
  /// </remarks>
  TSearchAndReplace = class(TEditSeedAndGrowMaskAndPromtCommon)
    /// <summary>
    /// Short description of what to inpaint in the image.
    /// </summary>
    /// <param name="Value">
    /// string [1 .. 10000] characters
    /// </param>
    function SelectPrompt(const Value: string): TSearchAndReplace;
    /// <summary>
    /// A blurb of text describing what you do not wish to see in the output image.
    /// </summary>
    /// <param name="Value">
    /// string [1 .. 10000] characters
    /// </param>
    /// <remarks>
    /// This is an advanced feature.
    /// </remarks>
    function NegativePrompt(const Value: string): TSearchAndReplace;
    constructor Create; reintroduce;
  end;

  /// <summary>
  /// <c>TSearchAndRecolor</c> is a class designed to manage and provide parameters for the Search and Recolor service, enabling automated object segmentation and color modification within an image.
  /// This service offers an inpainting-like functionality without requiring manual masks, allowing recoloring of specific image elements based solely on a textual prompt.
  /// </summary>
  /// <remarks>
  /// <c>TSearchAndRecolor</c> encapsulates the parameters required by the Search and Recolor API suite. The class enables straightforward reuse of parameters by wrapping them into anonymous methods, which can be directly passed to functions that interact with the API.
  /// By automating object segmentation and recoloring, this service allows users to specify desired colors for particular image elements efficiently, enhancing usability without manual mask creation.
  /// </remarks>
  TSearchAndRecolor = TSearchAndReplace;

  /// <summary>
  /// <c>TRemoveBackground</c> is a class designed to manage parameters for the Remove Background service, which accurately segments the foreground from an image and removes or modifies the background as required.
  /// </summary>
  /// <remarks>
  /// <c>TRemoveBackground</c> provides a structured approach to managing the parameters required by the Remove Background API. By encapsulating these parameters into a cohesive class, it facilitates seamless reuse and efficient integration with functions that utilize these APIs through anonymous methods.
  /// This design aims to simplify the handling of image segmentation tasks while ensuring accurate control over background removal and modification processes.
  /// </remarks>
  TRemoveBackground = class(TEditCommon)
    constructor Create; reintroduce;
  end;

  /// <summary>
  /// <c>TRemoveBackground</c> is a class that manages the parameters for the Replace Background and Relight image editing service.
  /// It enables background replacement, AI background generation, and lighting adjustments to create cohesive and visually enhanced images.
  /// </summary>
  /// <remarks>
  /// TRemoveBackground centralizes parameter handling for the Replace Background and Relight API suite, allowing efficient use of these services through anonymous methods.
  /// This class provides a flexible framework for background removal, replacement, and relighting operations, supporting various input options such as uploaded images or AI-generated backgrounds.
  /// Additionally, it includes features for refining light direction, strength, and reference to achieve realistic and visually consistent results.
  /// </remarks>
  TReplaceBackgroundAndRelight = class(TMultipartFormData)
    /// <summary>
    /// An image containing the subject that you wish to change background and relight.
    /// </summary>
    /// <param name="FilePath">
    /// Filename with supported format (jpeg, png, webp)
    /// </param>
    /// <returns>
    /// The updated <c>TStableImageUltra</c> instance.
    /// </returns>
    /// <remarks>
    /// Validation Rules:
    /// <para>
    /// - Every side must be at least 64 pixels
    /// </para>
    /// <para>
    /// - Total pixel count must be between 4,096 and 9,437,184 pixels
    /// </para>
    /// <para>
    /// - The aspect ratio must be between 1:2.5 and 2.5:1
    /// </para>
    /// </remarks>
    function SubjectImage(const FilePath: string): TReplaceBackgroundAndRelight; overload;
    /// <summary>
    /// An image stream containing the subject that you wish to change the background and relight.
    /// </summary>
    /// <param name="Stream">
    /// A <c>TStream</c> containing the subject image. Supported formats include JPEG, PNG, and WEBP.
    /// </param>
    /// <param name="StreamFreed">
    /// Indicates whether the stream should be automatically freed after processing.
    /// Set to <c>True</c> if the method should take ownership and free the stream,
    /// or <c>False</c> if the caller will manage the stream's lifecycle.
    /// Default is <c>False</c>.
    /// </param>
    /// <returns>
    /// The updated <c>TReplaceBackgroundAndRelight</c> instance.
    /// </returns>
    /// <remarks>
    /// <para>
    /// <c>Validation Rules:</c>
    /// </para>
    /// <para>
    /// - Every side of the image must be at least 64 pixels.
    /// </para>
    /// <para>
    /// - Total pixel count must be between 4,096 and 9,437,184 pixels.
    /// </para>
    /// <para>
    /// - The aspect ratio must be between 1:2.5 and 2.5:1.
    /// </para>
    /// <para>
    /// If <c>StreamFreed</c> is set to <c>True</c>, the method will automatically free the stream after processing.
    /// If set to <c>False</c>, the caller is responsible for freeing the stream to prevent memory leaks.
    /// </para>
    /// </remarks>
    function SubjectImage(const Stream: TStream; StreamFreed: Boolean = False): TReplaceBackgroundAndRelight; overload;
    /// <summary>
    /// An image whose style you wish to use in the background. Similar to the Control: Style API, stylistic elements from this image are added to the background.
    /// </summary>
    /// <param name="FilePath">
    /// Filename with supported format (jpeg, png, webp)
    /// </param>
    /// <returns>
    /// The updated <c>TStableImageUltra</c> instance.
    /// </returns>
    /// <remarks>
    /// Validation Rules:
    /// <para>
    /// - Every side must be at least 64 pixels
    /// </para>
    /// <para>
    /// - Total pixel count must be between 4,096 and 9,437,184 pixels
    /// </para>
    /// </remarks>
    function BackgroundReference(const FilePath: string): TReplaceBackgroundAndRelight; overload;
    /// <summary>
    /// An image stream whose style you wish to use in the background. Similar to the Control: Style API, stylistic elements from this image are added to the background.
    /// </summary>
    /// <param name="Stream">
    /// A <c>TStream</c> containing the background reference image. Supported formats include JPEG, PNG, and WEBP.
    /// </param>
    /// <param name="StreamFreed">
    /// Indicates whether the stream should be automatically freed after processing.
    /// Set to <c>True</c> if the method should take ownership and free the stream,
    /// or <c>False</c> if the caller will manage the stream's lifecycle.
    /// Default is <c>False</c>.
    /// </param>
    /// <returns>
    /// The updated <c>TReplaceBackgroundAndRelight</c> instance.
    /// </returns>
    /// <remarks>
    /// <para>
    /// <c>Validation Rules:</c>
    /// </para>
    /// <para>
    /// - Every side of the image must be at least 64 pixels.
    /// </para>
    /// <para>
    /// - Total pixel count must be between 4,096 and 9,437,184 pixels.
    /// </para>
    /// </remarks>
    function BackgroundReference(const Stream: TStream; StreamFreed: Boolean = False): TReplaceBackgroundAndRelight; overload;
    /// <summary>
    /// What you wish to see in the background of the output image.
    /// </summary>
    /// <param name="Value">
    /// [1 .. 10000] characters
    /// </param>
    /// <remarks>
    /// This could be a description of the desired background scene, or just a description of the lighting if modifying the light source through light_source_direction or light_reference.
    /// <para>
    /// - IMPORTANT : either <c>background_reference</c> or <c>background_prompt</c> must be provided.
    /// </para>
    /// </remarks>
    function BackgroundPrompt(const Value: string): TReplaceBackgroundAndRelight;
    /// <summary>
    /// Description of the subject. Use this to prevent elements of the background from bleeding into the subject.
    /// </summary>
    /// <param name="Value">
    /// [1 .. 10000] characters
    /// </param>
    /// <remarks>
    ///  For example, if you find your subject is turning green with a forest in the background, try putting a short description of the subject in this field.
    /// </remarks>
    function ForegroundPrompt(const Value: string): TReplaceBackgroundAndRelight;
    /// <summary>
    /// A blurb of text describing what you do not wish to see in the output image.
    /// </summary>
    /// <param name="Value">
    /// [1 .. 10000] characters
    /// </param>
    /// <remarks>
    /// This is an advanced feature.
    /// </remarks>
    function NegativePrompt(const Value: string): TReplaceBackgroundAndRelight;
    /// <summary>
    /// How much to overlay the original subject to exactly match the original image.
    /// </summary>
    /// <param name="Value">
    /// Number: [0 .. 1] (Default 0.6)
    /// </param>
    /// <remarks>
    /// A 1.0 is an exact pixel match for the subject, and 0.0 is a close match but will have new lighting qualities. This is an advanced feature.
    /// </remarks>
    function PreserveOriginalSubject(const Value: Double): TReplaceBackgroundAndRelight;
    /// <summary>
    /// Controls the generated background to have the same depth as the original subject image.
    /// </summary>
    /// <param name="Value">
    /// Number: [0 .. 1] (Default 0.5)
    /// </param>
    /// <remarks>
    /// This is an advanced feature.
    /// </remarks>
    function OriginalBackgroundDepth(const Value: Double): TReplaceBackgroundAndRelight;
    /// <summary>
    /// Whether to keep the background of the original image.
    /// </summary>
    /// <param name="Value">
    /// Enum: false, true (Default false)
    /// </param>
    /// <remarks>
    /// When this is on, the background will have different lighting than the original image that changes based on the other parameters in this API.
    /// </remarks>
    function KeepOriginalBackground(const Value: Boolean): TReplaceBackgroundAndRelight;
    /// <summary>
    /// Direction of the light source.
    /// </summary>
    /// <param name="Value">
    /// Enum: <c>above</c>, <c>below</c>, <c>left</c>, <c>right</c>,
    /// </param>
    function LightSourceDirection(const Value: TLightSourceDirection): TReplaceBackgroundAndRelight;
    /// <summary>
    /// An image with the desired lighting. Lighter sections of the light_reference image will correspond to sections with brighter lighting in the output image.
    /// </summary>
    /// <param name="FilePath">
    /// Filename with supported format (jpeg, png, webp)
    /// </param>
    /// <returns>
    /// The updated <c>TStableImageUltra</c> instance.
    /// </returns>
    /// <remarks>
    /// Validation Rules:
    /// <para>
    /// - Every side must be at least 64 pixels
    /// </para>
    /// <para>
    /// - Total pixel count must be between 4,096 and 9,437,184 pixels
    /// </para>
    /// </remarks>
    function LightReference(const FilePath: string): TReplaceBackgroundAndRelight; overload;
    /// <summary>
    /// An image stream providing the desired lighting reference for the output image.
    /// </summary>
    /// <param name="Stream">
    /// A <c>TStream</c> containing the lighting reference image. Supported formats include JPEG, PNG, and WEBP.
    /// </param>
    /// <param name="StreamFreed">
    /// Indicates whether the stream should be automatically freed after processing.
    /// Set to <c>True</c> if the method should take ownership and free the stream,
    /// or <c>False</c> if the caller will manage the stream's lifecycle.
    /// Default is <c>False</c>.
    /// </param>
    /// <returns>
    /// The updated <c>TReplaceBackgroundAndRelight</c> instance.
    /// </returns>
    /// <remarks>
    /// <para>
    /// <c>Validation Rules:</c>
    /// </para>
    /// <para>
    /// - Every side of the image must be at least 64 pixels.
    /// </para>
    /// <para>
    /// - Total pixel count must be between 4,096 and 9,437,184 pixels.
    /// </para>
    /// <para>
    /// - The aspect ratio must be between 1:2.5 and 2.5:1.
    /// </para>
    /// <para>
    /// If <c>StreamFreed</c> is set to <c>True</c>, the method will automatically free the stream after processing.
    /// If set to <c>False</c>, the caller is responsible for freeing the stream to prevent memory leaks.
    /// </para>
    /// </remarks>
    function LightReference(const Stream: TStream; StreamFreed: Boolean = False): TReplaceBackgroundAndRelight; overload;
    /// <summary>
    /// If using <c>light_reference_image</c> or <c>light_source_direction</c>, controls the strength of the light source. 1.0 is brighter and 0.0 is dimmer. This is an advanced feature.
    /// </summary>
    /// <param name="Value">
    /// Number: [0 .. 1] (Default 0.3)
    /// </param>
    /// <remarks>
    /// IMPORTANT : Use of this parameter requires <c>light_reference</c> or <c>light_source_direction</c> to be provided.
    /// </remarks>
    function LightSourceStrength(const Value: Double): TReplaceBackgroundAndRelight;
    /// <summary>
    /// A specific value that is used to guide the 'randomness' of the generation
    /// </summary>
    /// <param name="Value">
    /// number [0 .. 4294967294]  (Default: 0)
    /// </param>
    /// <remarks>
    /// Omit this parameter or pass 0 to use a random seed.
    /// </remarks>
    function Seed(const Value: Int64): TReplaceBackgroundAndRelight;
    /// <summary>
    /// Dictates the content-type of the generated image.
    /// </summary>
    /// <param name="Value">
    /// Enum: <c>jpeg</c>, <c>png</c>, <c>webp</c>
    /// </param>
    function OutputFormat(const Value: TOutPutFormat): TReplaceBackgroundAndRelight;
    constructor Create; reintroduce;
  end;

  /// <summary>
  /// <c>TEditRoute</c> is a class providing access to various image editing services through Stability AI's API.
  /// </summary>
  /// <remarks>
  /// <c>TEditRoute</c> encapsulates a variety of image manipulation features such as erasing objects, inpainting, outpainting,
  /// replacing or recoloring elements, and relighting scenes. It serves as a comprehensive interface to interact with these
  /// functionalities through both synchronous and asynchronous methods. This class is specifically designed to simplify
  /// integration and streamline the workflow for developers by centralizing API calls for all supported image editing operations.
  /// Each editing service is implemented as a distinct function or procedure in this class, supporting parameterized
  /// configuration through anonymous methods. Developers can customize image transformation parameters dynamically and
  /// seamlessly integrate them into their applications with ease. Error handling mechanisms are in place to address any
  /// issues during API interaction.
  /// Below are the main services provided by this class:
  /// <para>- Erase: Remove unwanted elements from images using masks.</para>
  /// <para>- Inpaint: Intelligently modify selected regions of an image based on masks.</para>
  /// <para>- Outpaint: Expand images by generating content in any direction.</para>
  /// <para>- Search and Replace: Identify and replace objects in an image without needing masks.</para>
  /// <para>- Search and Recolor: Modify the color of objects in an image based on a prompt.</para>
  /// <para>- Remove Background: Segment the foreground from the background and apply modifications.</para>
  /// <para>- Replace Background and Relight: Replace backgrounds and relight scenes to achieve cohesive output.</para>
  /// This class is designed to be flexible and reusable, offering both synchronous methods for immediate results and asynchronous
  /// methods for enhanced responsiveness in applications with heavy processing or user interaction.
  /// </remarks>
  TEditRoute = class(TStabilityAIAPIRoute)
    /// <summary>
    /// The Erase service allows you to eliminate undesired elements, like imperfections on portraits or objects on desks, by utilizing image masking techniques.
    /// <para>
    /// The mask can be supplied in one of two forms:
    /// </para>
    /// <para>
    /// - By explicitly providing a separate image through the <c>mask</c> parameter.
    /// </para>
    /// <para>
    /// - By extracting it from the alpha channel of the <c>image</c> parameter.
    /// </para>
    /// <para>
    /// The resolution of the generated image will be 4 megapixels.
    /// </para>
    /// <para>
    /// NOTE: This method is <c>synchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as image, the mask, the seed, the the format of the output image.
    /// </param>
    /// <returns>
    /// Returns a <c>TStableImage</c> object that contains image base-64 generated.
    /// </returns>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// The <c>Erase</c> method sends an image editing request to remove unwanted objects from an image, such as blemishes on portraits or items on desks, using image masks.  The returned <c>TStableImage</c> object contains the model's edited response, including multiple choices if available.
    /// <code>
    ///   var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    ///   var Data := Stability.StableImage.Edit.Erase(
    ///     procedure (Params: TErase)
    ///     begin
    ///       Params.OutputFormat(png);
    ///       // Move on to the other parameters.
    ///     end);
    ///   var Stream := Data.GetStream;
    ///   try
    ///     //--- Save image
    ///     Data.SaveToFile(FileName);
    ///     //--- Display image
    ///     Image1.Picture.LoadFromStream(Stream);
    ///   finally
    ///     Data.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Erase(ParamProc: TProc<TErase>): TStableImage; overload;
    /// <summary>
    /// The Erase service allows you to eliminate undesired elements, like imperfections on portraits or objects on desks, by utilizing image masking techniques.
    /// <para>
    /// The mask can be supplied in one of two forms:
    /// </para>
    /// <para>
    /// - By explicitly providing a separate image through the <c>mask</c> parameter.
    /// </para>
    /// <para>
    /// - By extracting it from the alpha channel of the <c>image</c> parameter.
    /// </para>
    /// <para>
    /// The resolution of the generated image will be 4 megapixels.
    /// </para>
    /// <para>
    /// NOTE: This method is <c>asynchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as image, the mask, the seed, the the format of the output image.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for asynchronous image creation, such as <c>onSuccess</c> and <c>onError</c>.
    /// </param>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// The <c>Erase</c> method sends an image editing request to remove unwanted objects from an image, such as blemishes on portraits or items on desks, using image masks.
    /// <code>
    /// // WARNING - Move the following line to the main OnCreate method for maximum scope.
    /// // var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    /// Stability.StableImage.Edit.Erase(
    ///   procedure (Params: TErase)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynStableImage
    ///   begin
    ///     Result.Sender := Image1;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Image: TStableImage)
    ///       begin
    ///         // Handle success operation
    ///       end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle error message
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure Erase(ParamProc: TProc<TErase>; CallBacks: TFunc<TAsynStableImage>); overload;
    /// <summary>
    /// Intelligently modify images by filling in or replacing specified areas with new content based on the content of a "mask" image.
    /// <para>
    /// The mask is provided in one of two ways:
    /// </para>
    /// <para>
    /// - Explicitly passing in a separate image via the mask parameter
    /// </para>
    /// <para>
    /// - Derived from the alpha channel of the image parameter.
    /// </para>
    /// <para>
    /// The resolution of the generated image will be 4 megapixels.
    /// </para>
    /// <para>
    /// NOTE: This method is <c>synchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as image, the mask, the seed, the the format of the output image.
    /// </param>
    /// <returns>
    /// Returns a <c>TStableImage</c> object that contains image base-64 generated.
    /// </returns>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    ///   var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    ///   var Data := Stability.StableImage.Edit.Inpaint(
    ///     procedure (Params: TInpaint)
    ///     begin
    ///       Params.OutputFormat(png);
    ///       // Move on to the other parameters.
    ///     end);
    ///   var Stream := Data.GetStream;
    ///   try
    ///     //--- Save image
    ///     Data.SaveToFile(FileName);
    ///     //--- Display image
    ///     Image1.Picture.LoadFromStream(Stream);
    ///   finally
    ///     Data.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Inpaint(ParamProc: TProc<TInpaint>): TStableImage; overload;
    /// <summary>
    /// Intelligently modify images by filling in or replacing specified areas with new content based on the content of a "mask" image.
    /// <para>
    /// The mask is provided in one of two ways:
    /// </para>
    /// <para>
    /// - Explicitly passing in a separate image via the mask parameter
    /// </para>
    /// <para>
    /// - Derived from the alpha channel of the image parameter.
    /// </para>
    /// <para>
    /// The resolution of the generated image will be 4 megapixels.
    /// </para>
    /// <para>
    /// NOTE: This method is <c>synchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as image, the mask, the seed, the the format of the output image.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for asynchronous image creation, such as <c>onSuccess</c> and <c>onError</c>.
    /// </param>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// The <c>Erase</c> method sends an image editing request to remove unwanted objects from an image, such as blemishes on portraits or items on desks, using image masks.
    /// <code>
    /// // WARNING - Move the following line to the main OnCreate method for maximum scope.
    /// // var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    /// Stability.StableImage.Edit.Inpaint(
    ///   procedure (Params: TInpaint)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynStableImage
    ///   begin
    ///     Result.Sender := Image1;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Image: TStableImage)
    ///       begin
    ///         // Handle success operation
    ///       end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle error message
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure Inpaint(ParamProc: TProc<TInpaint>; CallBacks: TFunc<TAsynStableImage>); overload;
    /// <summary>
    /// The Outpaint service inserts additional content in an image to fill in the space in any direction.
    /// Compared to other automated or manual attempts to expand the content in an image, the Outpaint service
    /// should minimize artifacts and signs that the original image has been edited.
    /// <para>
    /// NOTE: This method is <c>synchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as image, the the format of the output image etc.
    /// </param>
    /// <returns>
    /// Returns a <c>TStableImage</c> object that contains image base-64 generated.
    /// </returns>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    ///   var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    ///   var Data := Stability.StableImage.Edit.Outpaint(
    ///     procedure (Params: TOutpaint)
    ///     begin
    ///       Params.OutputFormat(png);
    ///       // Move on to the other parameters.
    ///     end);
    ///   var Stream := Data.GetStream;
    ///   try
    ///     //--- Save image
    ///     Data.SaveToFile(FileName);
    ///     //--- Display image
    ///     Image1.Picture.LoadFromStream(Stream);
    ///   finally
    ///     Data.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Outpaint(ParamProc: TProc<TOutpaint>): TStableImage; overload;
    /// <summary>
    /// The Outpaint service inserts additional content in an image to fill in the space in any direction.
    /// Compared to other automated or manual attempts to expand the content in an image, the Outpaint service
    /// should minimize artifacts and signs that the original image has been edited.
    /// <para>
    /// NOTE: This method is <c>asynchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as image, the the format of the output image etc.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for asynchronous image creation, such as <c>onSuccess</c> and <c>onError</c>.
    /// </param>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line to the main OnCreate method for maximum scope.
    /// // var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    /// Stability.StableImage.Edit.Outpaint(
    ///   procedure (Params: TOutpaint)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynStableImage
    ///   begin
    ///     Result.Sender := Image1;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Image: TStableImage)
    ///       begin
    ///         // Handle success operation
    ///       end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle error message
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure Outpaint(ParamProc: TProc<TOutpaint>; CallBacks: TFunc<TAsynStableImage>); overload;
    /// <summary>
    /// The Search and Replace service is a specific version of inpainting that does not require a mask.
    /// Instead, users can leverage a <c>search_prompt</c> to identify an object in simple language to be replaced.
    /// The service will automatically segment the object and replace it with the object requested in the prompt.
    /// <para>
    /// NOTE: This method is <c>synchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as image, the the format of the output image etc.
    /// </param>
    /// <returns>
    /// Returns a <c>TStableImage</c> object that contains image base-64 generated.
    /// </returns>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    ///   var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    ///   var Data := Stability.StableImage.Edit.SearchAndReplace(
    ///     procedure (Params: TSearchAndReplace)
    ///     begin
    ///       Params.OutputFormat(png);
    ///       // Move on to the other parameters.
    ///     end);
    ///   var Stream := Data.GetStream;
    ///   try
    ///     //--- Save image
    ///     Data.SaveToFile(FileName);
    ///     //--- Display image
    ///     Image1.Picture.LoadFromStream(Stream);
    ///   finally
    ///     Data.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function SearchAndReplace(ParamProc: TProc<TSearchAndReplace>): TStableImage; overload;
    /// <summary>
    /// The Search and Replace service is a specific version of inpainting that does not require a mask.
    /// Instead, users can leverage a <c>search_prompt</c> to identify an object in simple language to be replaced.
    /// The service will automatically segment the object and replace it with the object requested in the prompt.
    /// <para>
    /// NOTE: This method is <c>asynchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as image, the the format of the output image etc.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for asynchronous image creation, such as <c>onSuccess</c> and <c>onError</c>.
    /// </param>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line to the main OnCreate method for maximum scope.
    /// // var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    /// Stability.StableImage.Edit.SearchAndReplace(
    ///   procedure (Params: TSearchAndReplace)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynStableImage
    ///   begin
    ///     Result.Sender := Image1;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Image: TStableImage)
    ///       begin
    ///         // Handle success operation
    ///       end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle error message
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure SearchAndReplace(ParamProc: TProc<TSearchAndReplace>; CallBacks: TFunc<TAsynStableImage>); overload;
    /// <summary>
    /// The Search and Recolor service provides the ability to change the color of a specific object in
    /// an image using a prompt. This service is a specific version of inpainting that does not require
    /// a mask. The Search and Recolor service will automatically segment the object and recolor it
    /// using the colors requested in the prompt.
    /// <para>
    /// NOTE: This method is <c>synchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as image, the the format of the output image etc.
    /// </param>
    /// <returns>
    /// Returns a <c>TStableImage</c> object that contains image base-64 generated.
    /// </returns>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    ///   var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    ///   var Data := Stability.StableImage.Edit.SearchAndRecolor(
    ///     procedure (Params: TSearchAndRecolor)
    ///     begin
    ///       Params.OutputFormat(png);
    ///       // Move on to the other parameters.
    ///     end);
    ///   var Stream := Data.GetStream;
    ///   try
    ///     //--- Save image
    ///     Data.SaveToFile(FileName);
    ///     //--- Display image
    ///     Image1.Picture.LoadFromStream(Stream);
    ///   finally
    ///     Data.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function SearchAndRecolor(ParamProc: TProc<TSearchAndRecolor>): TStableImage; overload;
    /// <summary>
    /// The Search and Recolor service provides the ability to change the color of a specific object in
    /// an image using a prompt. This service is a specific version of inpainting that does not require
    /// a mask. The Search and Recolor service will automatically segment the object and recolor it
    /// using the colors requested in the prompt.
    /// <para>
    /// NOTE: This method is <c>asynchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as image, the the format of the output image etc.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for asynchronous image creation, such as <c>onSuccess</c> and <c>onError</c>.
    /// </param>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line to the main OnCreate method for maximum scope.
    /// // var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    /// Stability.StableImage.Edit.SearchAndRecolor(
    ///   procedure (Params: TSearchAndRecolor)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynStableImage
    ///   begin
    ///     Result.Sender := Image1;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Image: TStableImage)
    ///       begin
    ///         // Handle success operation
    ///       end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle error message
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure SearchAndRecolor(ParamProc: TProc<TSearchAndRecolor>; CallBacks: TFunc<TAsynStableImage>); overload;
    /// <summary>
    /// The Remove Background service accurately segments the foreground from an image and implements and removes the background.
    /// <para>
    /// NOTE: This method is <c>synchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as image, etc
    /// </param>
    /// <returns>
    /// Returns a <c>TStableImage</c> object that contains image base-64 generated.
    /// </returns>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    ///   var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    ///   var Data := Stability.StableImage.Edit.RemoveBackground(
    ///     procedure (Params: TRemoveBackground)
    ///     begin
    ///       Params.OutputFormat(png);
    ///       // Move on to the other parameters.
    ///     end);
    ///   var Stream := Data.GetStream;
    ///   try
    ///     //--- Save image
    ///     Data.SaveToFile(FileName);
    ///     //--- Display image
    ///     Image1.Picture.LoadFromStream(Stream);
    ///   finally
    ///     Data.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function RemoveBackground(ParamProc: TProc<TRemoveBackground>): TStableImage; overload;
    /// <summary>
    /// The Remove Background service accurately segments the foreground from an image and implements and removes the background.
    /// <para>
    /// NOTE: This method is <c>asynchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as image, the format of the output image etc.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for asynchronous image creation, such as <c>onSuccess</c> and <c>onError</c>.
    /// </param>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line to the main OnCreate method for maximum scope.
    /// // var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    /// Stability.StableImage.Edit.RemoveBackground(
    ///   procedure (Params: TRemoveBackground)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynStableImage
    ///   begin
    ///     Result.Sender := Image1;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Image: TStableImage)
    ///       begin
    ///         // Handle success operation
    ///       end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle error message
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure RemoveBackground(ParamProc: TProc<TRemoveBackground>; CallBacks: TFunc<TAsynStableImage>); overload;
    /// <summary>
    /// The Replace Background and Relight edit service lets users swap backgrounds with AI-generated or uploaded images while adjusting lighting to match the subject. This new API provides a streamlined image editing solution and can serve e-commerce, real estate, photography, and creative projects.
    /// <para>
    /// Some of the things you can do include:
    /// </para>
    /// <para>
    /// - Background Replacement: Remove existing background and add new ones.
    /// </para>
    /// <para>
    /// - AI Background Generation: Create new backgrounds using AI generated images based on prompts.
    /// </para>
    /// <para>
    /// - Relighting: Adjust lighting in images that are under or overexposed.
    /// </para>
    /// <para>
    /// - Flexible Inputs: Use your own background image or generate one.
    /// </para>
    /// <para>
    /// - Lighting Adjustments: Modify light reference, direction, and strength.
    /// </para>
    /// <para>
    /// NOTE: This method is <c>synchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as image, etc
    /// </param>
    /// <returns>
    /// Returns a <c>TResults</c> object that contains ID of the task.
    /// </returns>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    ///   var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    ///   var Data := Stability.StableImage.Edit.ReplaceBackgroundAndRelight(
    ///     procedure (Params: TReplaceBackgroundAndRelight)
    ///     begin
    ///       Params.OutputFormat(png);
    ///       // Move on to the other parameters.
    ///     end);
    ///   try
    ///     ShowMessage(Data.Id);
    ///     // Display the Id
    ///     // e.g. ea771536f066b7fd03d62384581982ecd8b54a932a6378d5809d43f6e5aa789a
    ///   finally
    ///     Data.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function ReplaceBackgroundAndRelight(ParamProc: TProc<TReplaceBackgroundAndRelight>): TResults; overload;
    /// <summary>
    /// The Replace Background and Relight edit service lets users swap backgrounds with AI-generated or uploaded images while adjusting lighting to match the subject. This new API provides a streamlined image editing solution and can serve e-commerce, real estate, photography, and creative projects.
    /// <para>
    /// Some of the things you can do include:
    /// </para>
    /// <para>
    /// - Background Replacement: Remove existing background and add new ones.
    /// </para>
    /// <para>
    /// - AI Background Generation: Create new backgrounds using AI generated images based on prompts.
    /// </para>
    /// <para>
    /// - Relighting: Adjust lighting in images that are under or overexposed.
    /// </para>
    /// <para>
    /// - Flexible Inputs: Use your own background image or generate one.
    /// </para>
    /// <para>
    /// - Lighting Adjustments: Modify light reference, direction, and strength.
    /// </para>
    /// <para>
    /// NOTE: This method is <c>asynchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as image, the the format of the output image etc.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for asynchronous image creation, such as <c>onSuccess</c> and <c>onError</c>.
    /// </param>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line to the main OnCreate method for maximum scope.
    /// // var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    /// Stability.StableImage.Edit.ReplaceBackgroundAndRelight(
    ///   procedure (Params: TReplaceBackgroundAndRelight)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynResults
    ///   begin
    ///     Result.Sender := My_Object;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Job: TResults)
    ///       begin
    ///         // Handle success operation
    ///         ShowMessage(Job.Id);
    ///         // Display the Id
    ///         // e.g. ea771536f066b7fd03d62384581982ecd8b54a932a6378d5809d43f6e5aa789a
    ///       end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle error message
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure ReplaceBackgroundAndRelight(ParamProc: TProc<TReplaceBackgroundAndRelight>; CallBacks: TFunc<TAsynResults>); overload;
  end;

implementation

uses
  StabilityAI.NetEncoding.Base64, StabilityAI.Consts, StabilityAI.Async.Support;

{ TEditRoute }

function TEditRoute.Erase(ParamProc: TProc<TErase>): TStableImage;
begin
  Result := API.PostForm<TStableImage, TErase>('v2beta/stable-image/edit/erase', ParamProc);
end;

procedure TEditRoute.Erase(ParamProc: TProc<TErase>; CallBacks: TFunc<TAsynStableImage>);
begin
  with TAsynCallBackExec<TAsynStableImage, TStableImage>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TStableImage
      begin
        Result := Self.Erase(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TEditRoute.Inpaint(ParamProc: TProc<TInpaint>): TStableImage;
begin
  Result := API.PostForm<TStableImage, TInpaint>('v2beta/stable-image/edit/inpaint', ParamProc);
end;

procedure TEditRoute.Inpaint(ParamProc: TProc<TInpaint>; CallBacks: TFunc<TAsynStableImage>);
begin
  with TAsynCallBackExec<TAsynStableImage, TStableImage>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TStableImage
      begin
        Result := Self.Inpaint(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TEditRoute.Outpaint(ParamProc: TProc<TOutpaint>): TStableImage;
begin
  Result := API.PostForm<TStableImage, TOutpaint>('v2beta/stable-image/edit/outpaint', ParamProc);
end;

procedure TEditRoute.Outpaint(ParamProc: TProc<TOutpaint>; CallBacks: TFunc<TAsynStableImage>);
begin
  with TAsynCallBackExec<TAsynStableImage, TStableImage>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TStableImage
      begin
        Result := Self.Outpaint(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TEditRoute.RemoveBackground(ParamProc: TProc<TRemoveBackground>): TStableImage;
begin
  Result := API.PostForm<TStableImage, TRemoveBackground>('v2beta/stable-image/edit/remove-background', ParamProc);
end;

procedure TEditRoute.RemoveBackground(ParamProc: TProc<TRemoveBackground>; CallBacks: TFunc<TAsynStableImage>);
begin
  with TAsynCallBackExec<TAsynStableImage, TStableImage>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TStableImage
      begin
        Result := Self.RemoveBackground(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TEditRoute.ReplaceBackgroundAndRelight(
  ParamProc: TProc<TReplaceBackgroundAndRelight>): TResults;
begin
  Result := API.PostForm<TResults, TReplaceBackgroundAndRelight>('v2beta/stable-image/edit/replace-background-and-relight', ParamProc);
end;

procedure TEditRoute.ReplaceBackgroundAndRelight(
  ParamProc: TProc<TReplaceBackgroundAndRelight>;
  CallBacks: TFunc<TAsynResults>);
begin
  with TAsynCallBackExec<TAsynResults, TResults>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TResults
      begin
        Result := Self.ReplaceBackgroundAndRelight(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TEditRoute.SearchAndRecolor(ParamProc: TProc<TSearchAndRecolor>): TStableImage;
begin
  Result := API.PostForm<TStableImage, TSearchAndRecolor>('v2beta/stable-image/edit/search-and-recolor', ParamProc);
end;

procedure TEditRoute.SearchAndRecolor(ParamProc: TProc<TSearchAndRecolor>;
  CallBacks: TFunc<TAsynStableImage>);
begin
  with TAsynCallBackExec<TAsynStableImage, TStableImage>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TStableImage
      begin
        Result := Self.SearchAndRecolor(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TEditRoute.SearchAndReplace(ParamProc: TProc<TSearchAndReplace>): TStableImage;
begin
  Result := API.PostForm<TStableImage, TSearchAndReplace>('v2beta/stable-image/edit/search-and-replace', ParamProc);
end;

procedure TEditRoute.SearchAndReplace(ParamProc: TProc<TSearchAndReplace>;
  CallBacks: TFunc<TAsynStableImage>);
begin
  with TAsynCallBackExec<TAsynStableImage, TStableImage>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TStableImage
      begin
        Result := Self.SearchAndReplace(ParamProc);
      end);
  finally
    Free;
  end;
end;

{ TRemoveBackground }

constructor TRemoveBackground.Create;
begin
  inherited Create(True);
end;

{ TErase }

constructor TErase.Create;
begin
  inherited Create;
end;

function TErase.Mask(const FilePath: string): TErase;
begin
  AddBytes('mask', FileToBytes(FilePath), FilePath);
  Result := Self;
end;

function TErase.Mask(const Stream: TStream; StreamFreed: Boolean): TErase;
begin
  if StreamFreed then
    {--- The stream's content is automatically freed. }
    AddStream('mask', Stream, True, 'FileNameForHeader.png')
  else
    {--- You should release the stream's content. }
    AddBytes('mask', StreamToBytes(Stream), 'FileNameForHeader.png');
  Result := Self;
end;

{ TInpaint }

constructor TInpaint.Create;
begin
  inherited Create(True);
end;

function TInpaint.Mask(const FilePath: string): TInpaint;
begin
  AddBytes('mask', FileToBytes(FilePath), FilePath);
  Result := Self;
end;

function TInpaint.Mask(const Stream: TStream; StreamFreed: Boolean): TInpaint;
begin
  if StreamFreed then
    {--- The stream's content is automatically freed. }
    AddStream('mask', Stream, True, 'FileNameForHeader.png')
  else
    {--- You should release the stream's content. }
    AddBytes('mask', StreamToBytes(Stream), 'FileNameForHeader.png');
  Result := Self;
end;

function TInpaint.NegativePrompt(const Value: string): TInpaint;
begin
  AddField(Check('negative_prompt', Value), Value);
  Result := Self;
end;

{ TOutpaint }

constructor TOutpaint.Create;
begin
  inherited Create(True);
end;

function TOutpaint.Creativity(const Value: Double): TOutpaint;
begin
  AddField(CheckFloat('creativity', Value, 0, 1), Value.ToString);
  Result := Self;
end;

function TOutpaint.Down(const Value: Integer): TOutpaint;
begin
  AddField(CheckInteger('down', Value, 0 ,2000), Value.ToString);
  Result := Self;
end;

function TOutpaint.Left(const Value: Integer): TOutpaint;
begin
  AddField(CheckInteger('left', Value, 0 ,2000), Value.ToString);
  Result := Self;
end;

function TOutpaint.Prompt(const Value: string): TOutpaint;
begin
  AddField(Check('prompt', Value), Value);
  Result := Self;
end;

function TOutpaint.Right(const Value: Integer): TOutpaint;
begin
  AddField(CheckInteger('right', Value, 0 ,2000), Value.ToString);
  Result := Self;
end;

function TOutpaint.Up(const Value: Integer): TOutpaint;
begin
  AddField(CheckInteger('up', Value, 0 ,2000), Value.ToString);
  Result := Self;
end;

{ TSearchAndReplace }

constructor TSearchAndReplace.Create;
begin
  inherited Create(True);
end;

function TSearchAndReplace.NegativePrompt(
  const Value: string): TSearchAndReplace;
begin
  AddField(Check('negative_prompt', Value), Value);
  Result := Self;
end;

function TSearchAndReplace.SelectPrompt(const Value: string): TSearchAndReplace;
begin
  AddField(Check('select_prompt', Value), Value);
  Result := Self;
end;

{ TReplaceBackgroundAndRelight }

function TReplaceBackgroundAndRelight.BackgroundPrompt(
  const Value: string): TReplaceBackgroundAndRelight;
begin
  AddField(Check('background_prompt', Value), Value);
  Result := Self;
end;

function TReplaceBackgroundAndRelight.BackgroundReference(
  const FilePath: string): TReplaceBackgroundAndRelight;
begin
  AddBytes('background_reference', FileToBytes(FilePath), FilePath);
  Result := Self;
end;

function TReplaceBackgroundAndRelight.BackgroundReference(const Stream: TStream;
  StreamFreed: Boolean): TReplaceBackgroundAndRelight;
begin
  if StreamFreed then
    {--- The stream's content is automatically freed. }
    AddStream('background_reference', Stream, True, 'FileNameForHeader.png')
  else
    {--- You should release the stream's content. }
    AddBytes('background_reference', StreamToBytes(Stream), 'FileNameForHeader.png');
  Result := Self;
end;

constructor TReplaceBackgroundAndRelight.Create;
begin
  inherited Create(True);
end;

function TReplaceBackgroundAndRelight.ForegroundPrompt(
  const Value: string): TReplaceBackgroundAndRelight;
begin
  AddField(Check('foreground_prompt', Value), Value);
  Result := Self;
end;

function TReplaceBackgroundAndRelight.KeepOriginalBackground(
  const Value: Boolean): TReplaceBackgroundAndRelight;
begin
  AddField('keep_original_background', BoolToStr(Value, True).ToLower);
  Result := Self;
end;

function TReplaceBackgroundAndRelight.LightReference(
  const FilePath: string): TReplaceBackgroundAndRelight;
begin
  AddBytes('light_reference', FileToBytes(FilePath), FilePath);
  Result := Self;
end;

function TReplaceBackgroundAndRelight.LightReference(const Stream: TStream;
  StreamFreed: Boolean): TReplaceBackgroundAndRelight;
begin
  if StreamFreed then
    {--- The stream's content is automatically freed. }
    AddStream('light_reference', Stream, True, 'FileNameForHeader.png')
  else
    {--- You should release the stream's content. }
    AddBytes('light_reference', StreamToBytes(Stream), 'FileNameForHeader.png');
  Result := Self;
end;

function TReplaceBackgroundAndRelight.LightSourceDirection(
  const Value: TLightSourceDirection): TReplaceBackgroundAndRelight;
begin
  AddField('light_source_direction', Value.ToString);
  Result := Self;
end;

function TReplaceBackgroundAndRelight.LightSourceStrength(
  const Value: Double): TReplaceBackgroundAndRelight;
begin
  AddField(CheckFloat('light_source_strength', Value, 0 ,1), Value.ToString);
  Result := Self;
end;

function TReplaceBackgroundAndRelight.NegativePrompt(
  const Value: string): TReplaceBackgroundAndRelight;
begin
  AddField(Check('negative_prompt', Value), Value);
  Result := Self;
end;

function TReplaceBackgroundAndRelight.OriginalBackgroundDepth(
  const Value: Double): TReplaceBackgroundAndRelight;
begin
  AddField(CheckFloat('original_background_depth', Value, 0 ,1), Value.ToString);
  Result := Self;
end;

function TReplaceBackgroundAndRelight.OutputFormat(
  const Value: TOutPutFormat): TReplaceBackgroundAndRelight;
begin
  AddField('output_format', Value.ToString);
  Result := Self;
end;

function TReplaceBackgroundAndRelight.PreserveOriginalSubject(
  const Value: Double): TReplaceBackgroundAndRelight;
begin
  AddField(CheckFloat('preserve_original_subject', Value, 0 ,1), Value.ToString);
  Result := Self;
end;

function TReplaceBackgroundAndRelight.Seed(
  const Value: Int64): TReplaceBackgroundAndRelight;
begin
  AddField(CheckInteger('seed', Value, 0, SeedMax), Value.ToString);
  Result := Self;
end;

function TReplaceBackgroundAndRelight.SubjectImage(
  const FilePath: string): TReplaceBackgroundAndRelight;
begin
  AddBytes('subject_image', FileToBytes(FilePath), FilePath);
  Result := Self;
end;

function TReplaceBackgroundAndRelight.SubjectImage(const Stream: TStream;
  StreamFreed: Boolean): TReplaceBackgroundAndRelight;
begin
  if StreamFreed then
    {--- The stream's content is automatically freed. }
    AddStream('subject_image', Stream, True, 'FileNameForHeader.png')
  else
    {--- You should release the stream's content. }
    AddBytes('subject_image', StreamToBytes(Stream), 'FileNameForHeader.png');
  Result := Self;
end;

end.

unit StabilityAI.StableImage.Generate;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiStabilityAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Net.Mime, REST.JsonReflect, System.JSON,
  REST.Json.Types, StabilityAI.API, StabilityAI.API.Params, StabilityAI.Types,
  StabilityAI.Common;

type
  /// <summary>
  /// The <c>TStableImageUltra</c> class is designed to manage and streamline the parameters for the most advanced text-to-image generation service, Stable Image Ultra.
  /// This class facilitates the creation of high-quality images by providing seamless integration with the Stable Diffusion 3.5 model and beyond.
  /// </summary>
  /// <remarks>
  /// <c>TStableImageUltra</c> centralizes the parameter handling for the Stable Image Ultra API suite. By encapsulating parameters into a structured class, it enables efficient reuse through anonymous methods that can be directly passed to API-consuming functions.
  /// This design approach improves cohesion, reduces boilerplate code, and makes managing complex prompt settings for typography, lighting, and composition more intuitive.
  /// </remarks>
  TStableImageUltra = class(TStableImageRatio)
  public
    /// <summary>
    /// The image to use as the starting point for the generation.
    /// </summary>
    /// <param name="FilePath">
    /// Filename with supported format (jpeg, png, webp)
    /// </param>
    /// <returns>
    /// The updated <c>TStableImageUltra</c> instance.
    /// </returns>
    /// <remarks>
    /// <para>
    /// - Width must be between 64 and 16,384 pixels
    /// </para>
    /// <para>
    /// - Height must be between 64 and 16,384 pixels
    /// </para>
    /// <para>
    /// - Total pixel count must be at least 4,096 pixels
    /// </para>
    /// <para>
    /// - IMPORTANT: The strength parameter is required when image is provided.
    /// </para>
    /// </remarks>
    function Image(const FilePath: string): TStableImageUltra; overload;
    /// <summary>
    /// Sets the image to use as the starting point for the generation using a stream.
    /// </summary>
    /// <param name="Stream">
    /// A <c>TStream</c> containing the image data in a supported format (JPEG, PNG, WEBP).
    /// </param>
    /// <param name="StreamFreed">
    /// A <c>Boolean</c> indicating whether the stream should be automatically freed after use.
    /// Defaults to <c>False</c>.
    /// </param>
    /// <returns>
    /// The updated <c>TStableImageUltra</c> instance.
    /// </returns>
    /// <remarks>
    /// <para>
    /// - Width must be between 64 and 16,384 pixels.
    /// </para>
    /// <para>
    /// - Height must be between 64 and 16,384 pixels.
    /// </para>
    /// <para>
    /// - Total pixel count must be at least 4,096 pixels.
    /// </para>
    /// <para>
    /// - <strong>IMPORTANT:</strong> The <c>strength</c> parameter is required when an image is provided.
    /// </para>
    /// </remarks>
    function Image(const Stream: TStream; StreamFreed: Boolean = False): TStableImageUltra; overload;
    /// <summary>
    /// Sometimes referred to as denoising, this parameter controls how much influence the image parameter has on the generated image.
    /// </summary>
    /// <param name="paramname">
    /// number [0 .. 1]
    /// </param>
    /// <returns>
    /// The updated <c>TStableImageUltra</c> instance.
    /// </returns>
    /// <remarks>
    /// A value of 0 would yield an image that is identical to the input. A value of 1 would be as if you passed in no image at all.
    /// <para>
    /// - Important: This parameter is required when image is provided.
    /// </para>
    /// </remarks>
    function Strength(const Value: Double): TStableImageUltra;
    constructor Create; reintroduce;
  end;

  /// <summary>
  /// The <c>TStableImageCore</c> class is designed to manage and streamline the parameters for the Stable Image Core text-to-image generation service.
  /// It provides access to high-quality, fast image generation without requiring extensive prompt engineering.
  /// </summary>
  /// <remarks>
  /// <c>TStableImageCore</c> centralizes parameter management for the Stable Image Core API suite, allowing easy reuse through anonymous methods that can be supplied directly to API-consuming functions.
  /// This approach facilitates simple and intuitive usage, enabling rapid scene, style, or character creation without requiring the user to manually adjust intricate settings.
  /// </remarks>
  TStableImageCore = class(TStableImageRatio)
  public
    /// <summary>
    /// Guides the image model towards a particular style.
    /// </summary>
    /// <param name="paramname">
    /// Enum: <c>model3d</c>, <c>analogFilm</c>, <c>anime</c>, <c>cinematic</c>, <c>comicBook</c>,
    /// <c>digitalArt</c>, <c>enhance</c>, <c>fantasyArt</c>, <c>isometric</c>, <c>lineArt</c>,
    /// <c>lowPoly</c>, <c>modelingCompound</c>, <c>neonPunk</c>, <c>origami</c>, <c>photographic</c>,
    /// <c>pixelArt</c>, <c>tileTexture</c>
    /// </param>
    /// <returns>
    /// The updated <c>TStableImageCore</c> instance.
    /// </returns>
    function StylePreset(const Value: TStylePreset): TStableImageCore;
    constructor Create; reintroduce;
  end;

  /// <summary>
  /// The <c>TStableImageDiffusion</c> class is designed to manage and streamline parameter handling for Stable Diffusion 3.0 and 3.5 models, enabling efficient text-to-image generation through APIs.
  /// This class supports various versions, including Stable Diffusion 3.5 Large, Large Turbo, and Medium, providing flexibility for high-quality, performance-oriented image generation tasks.
  /// </summary>
  /// <remarks>
  /// <c>TStableImageDiffusion</c> centralizes parameter management for Stable Diffusion APIs, enabling the creation of efficient anonymous methods that integrate seamlessly with API-consuming functions.
  /// The class allows users to easily access capabilities across Stable Diffusion 3.5 and 3.0 models, including the highly detailed 8 billion parameter models and faster Turbo versions.
  /// This design ensures optimal control over prompt adherence, generation speed, and image quality, tailored to different professional use cases at various resolutions.
  /// </remarks>
  TStableImageDiffusion = class(TStableImageUltra)
  public
    /// <summary>
    /// Controls whether this is a text-to-image or image-to-image generation
    /// </summary>
    /// <param name="Value">
    /// Enum: <c>imageToImage</c>, <c>textToImage</c>, (Default: textToImage)
    /// </param>
    /// <returns>
    /// The updated <c>TStableImageDiffusion</c> instance.
    /// </returns>
    /// <remarks>
    /// <para>
    /// - <c>textToImage</c> requires only the <c>prompt</c> parameter
    /// </para>
    /// <para>
    /// - <c>imageToImage</c> requires the <c>prompt</c>, <c>image</c>, and <c>strength</c> parameters
    /// </para>
    /// </remarks>
    function Mode(const Value: TGenerationMode): TStableImageDiffusion;
    /// <summary>
    /// The model to use for generation.
    /// </summary>
    /// <param name="Value">
    /// Enum: sd3-large, sd3-large-turbo, sd3-medium, sd3.5-large, sd3.5-large-turbo, sd3.5-medium
    /// </param>
    /// <returns>
    /// The updated <c>TStableImageDiffusion</c> instance.
    /// </returns>
    /// <remarks>
    /// Default: sd35large
    /// <para>
    /// - Enum: <c>sd3Large</c>, <c>sd3LargeTurbo</c>, <c>sd3Medium</c>, <c>sd35Large</c>, <c>sd35LargeTurbo</c>, <c>sd35Medium</c>
    /// </para>
    /// </remarks>
    function Model(const Value: TDiffusionModelType): TStableImageDiffusion;
    /// <summary>
    /// How strictly the diffusion process adheres to the prompt text
    /// </summary>
    /// <param name="Value">
    /// number [1 .. 10]
    /// </param>
    /// <returns>
    /// The updated <c>TStableImageDiffusion</c> instance.
    /// </returns>
    /// <remarks>
    /// Higher values keep your image closer to your prompt
    /// </remarks>
    function CfgScale(const Value: Integer): TStableImageDiffusion;
    constructor Create; reintroduce;
  end;

  /// <summary>
  /// The <c>TGenerateRoute</c> class provides methods to interact with the StabilityAI API for image generation.
  /// It serves as an entry point to create high-quality images using Stable Diffusion models, offering both
  /// synchronous and asynchronous methods tailored to various use cases and performance needs.
  /// </summary>
  /// <remarks>
  /// <para>
  /// The <c>TGenerateRoute</c> class encapsulates API calls for generating images with different resolutions,
  /// styles, and configurations using Stable Diffusion 3.x and 3.5 models. It includes functionalities for
  /// defining image parameters, handling image streams, and utilizing asynchronous callbacks for non-blocking
  /// operations.
  /// </para>
  /// <para>
  /// By leveraging the <c>TGenerateRoute</c> methods, developers can create images programmatically, save them
  /// to files, or directly use them in their applications. The API is highly customizable, allowing fine-tuning
  /// of parameters like output format, image strength, style presets, and model types.
  /// </para>
  /// </remarks>
  TGenerateRoute = class(TStabilityAIAPIRoute)
    /// <summary>
    /// Create an image with 1 megapixel resolution. The default resolution is 1024x1024.
    /// <para>
    /// Model used: Stable Diffusion 3.5
    /// </para>
    /// <para>
    /// NOTE: This method is <c>synchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as aspect ratio, keywords of what you do not wish to see in the output image, the the format of the output image, etc.
    /// </param>
    /// <returns>
    /// Returns a <c>TStableImage</c> object that contains image base-64 generated.
    /// </returns>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// The <c>ImageUltra</c> method sends a image creation request and waits for the full response. The returned <c>TStableImage</c> object contains the model's generated response, including multiple choices if available.
    /// <code>
    ///   var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    ///   var Ultra := Stability.StableImage.Generate.ImageUltra(
    ///     procedure (Params: TStableImageUltra)
    ///     begin
    ///       Params.OutputFormat(png);
    ///       // Move on to the other parameters.
    ///     end);
    ///   var Stream := Ultra.GetStream;
    ///   try
    ///     //--- Save image
    ///     Ultra.SaveToFile(FileName);
    ///     //--- Display image
    ///     Image1.Picture.LoadFromStream(Stream);
    ///   finally
    ///     Ultra.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function ImageUltra(ParamProc: TProc<TStableImageUltra>): TStableImage; overload;
    /// <summary>
    /// Create an image with 1 megapixel resolution. The default resolution is 1024x1024.
    /// <para>
    /// Model used: Stable Diffusion 3.5
    /// </para>
    /// <para>
    /// NOTE: This method is <c>asynchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as aspect ratio, keywords of what you do not wish to see in the output image, the the format of the output image, etc.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for asynchronous image creation, such as <c>onSuccess</c> and <c>onError</c>.
    /// </param>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// This procedure initiates an asynchronous request to generate an image creation based on the provided parameters. The response or error is handled by the provided callBacks.
    /// <code>
    /// // WARNING - Move the following line to the main OnCreate method for maximum scope.
    /// // var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    /// Stability.StableImage.Generate.ImageUltra(
    ///   procedure (Params: TStableImageUltra)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynStableImage
    ///   begin
    ///     Result.Sender := Image1;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Image: TStableImage)
    ///       begin
    ///         // Handle success operation
    ///       end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle error message
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure ImageUltra(ParamProc: TProc<TStableImageUltra>; CallBacks: TFunc<TAsynStableImage>); overload;
    /// <summary>
    /// Generate an image at high speed with a resolution of 1.5 megapixels. You can request a specific style, scene, or character.
    /// <para>
    /// Model used: Stable Diffusion 3
    /// </para>
    /// <para>
    /// NOTE: This method is <c>synchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as aspect ratio, keywords of what you do not wish to see in the output image, the the format of the output image, etc.
    /// </param>
    /// <returns>
    /// Returns a <c>TStableImage</c> object that contains image base-64 generated.
    /// </returns>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// The <c>ImageCore</c> method sends a image creation request and waits for the full response. The returned <c>TStableImage</c> object contains the model's generated response, including multiple choices if available.
    /// <code>
    ///   var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    ///   var Core := Stability.StableImage.Generate.ImageCore(
    ///     procedure (Params: TStableImageCore)
    ///     begin
    ///       Params.OutputFormat(png);
    ///       // Move on to the other parameters.
    ///     end);
    ///   var Stream := Core.GetStream;
    ///   try
    ///     //--- Save image
    ///     Core.SaveToFile(FileName);
    ///     //--- Display image
    ///     Image1.Picture.LoadFromStream(Stream);
    ///   finally
    ///     Core.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function ImageCore(ParamProc: TProc<TStableImageCore>): TStableImage; overload;
    /// <summary>
    /// Generate an image at high speed with a resolution of 1.5 megapixels. You can request a specific style, scene, or character.
    /// <para>
    /// Model used: Stable Diffusion 3
    /// </para>
    /// <para>
    /// NOTE: This method is <c>asynchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as aspect ratio, keywords of what you do not wish to see in the output image, the the format of the output image, etc.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for asynchronous image creation, such as <c>onSuccess</c> and <c>onError</c>.
    /// </param>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// This procedure initiates an asynchronous request to generate an image creation based on the provided parameters. The response or error is handled by the provided callBacks.
    /// <code>
    /// // WARNING - Move the following line to the main OnCreate method for maximum scope.
    /// // var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    /// Stability.StableImage.Generate.ImageCore(
    ///   procedure (Params: TStableImageCore)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynStableImage
    ///   begin
    ///     Result.Sender := Image1;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Image: TStableImage)
    ///       begin
    ///         // Handle success operation
    ///       end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle error message
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure ImageCore(ParamProc: TProc<TStableImageCore>; CallBacks: TFunc<TAsynStableImage>); overload;
    /// <summary>
    /// Generate an image at high speed with a resolution of 1 megapixels. The default resolution is 1024x1024.
    /// <para>
    /// The model can be chosen from:
    /// </para>
    /// <para>
    /// - Stable Diffusion 3.5 Large: At 8 billion parameters
    /// </para>
    /// <para>
    /// - Stable Diffusion 3.5 Large Turbo: At 8 billion parameters
    /// </para>
    /// <para>
    /// - Stable Diffusion 3.5 Medium: With 2.5 billion parameters
    /// </para>
    /// <para>
    /// - SD3 Large: the 8 billion parameter model
    /// </para>
    /// <para>
    /// - SD3 Large Turbo: the 8 billion parameter model with a faster inference time
    /// </para>
    /// <para>
    /// - SD3 Medium: the 2 billion parameter model
    /// </para>
    /// <para>
    /// NOTE: This method is <c>synchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as aspect ratio, keywords of what you do not wish to see in the output image, the the format of the output image, etc.
    /// </param>
    /// <returns>
    /// Returns a <c>TStableImage</c> object that contains image base-64 generated.
    /// </returns>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// The <c>Diffusion</c> method sends a image creation request and waits for the full response. The returned <c>TStableImage</c> object contains the model's generated response, including multiple choices if available.
    /// <code>
    ///   var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    ///   var Diffusion := Stability.StableImage.Generate.Diffusion(
    ///     procedure (Params: TStableImageDiffusion)
    ///     begin
    ///       Params.OutputFormat(png);
    ///       // Move on to the other parameters.
    ///     end);
    ///   var Stream := Diffusion.GetStream;
    ///   try
    ///     //--- Save image
    ///     Diffusion.SaveToFile(FileName);
    ///     //--- Display image
    ///     Image1.Picture.LoadFromStream(Stream);
    ///   finally
    ///     Diffusion.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Diffusion(ParamProc: TProc<TStableImageDiffusion>): TStableImage; overload;
    /// <summary>
    /// Generate an image at high speed with a resolution of 1 megapixels. The default resolution is 1024x1024.
    /// <para>
    /// The model can be chosen from:
    /// </para>
    /// <para>
    /// - Stable Diffusion 3.5 Large: At 8 billion parameters
    /// </para>
    /// <para>
    /// - Stable Diffusion 3.5 Large Turbo: At 8 billion parameters
    /// </para>
    /// <para>
    /// - Stable Diffusion 3.5 Medium: With 2.5 billion parameters
    /// </para>
    /// <para>
    /// - SD3 Large: the 8 billion parameter model
    /// </para>
    /// <para>
    /// - SD3 Large Turbo: the 8 billion parameter model with a faster inference time
    /// </para>
    /// <para>
    /// - SD3 Medium: the 2 billion parameter model
    /// </para>
    /// <para>
    /// NOTE: This method is <c>asynchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as aspect ratio, keywords of what you do not wish to see in the output image, the the format of the output image, etc.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for asynchronous image creation, such as <c>onSuccess</c> and <c>onError</c>.
    /// </param>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// This procedure initiates an asynchronous request to generate an image creation based on the provided parameters. The response or error is handled by the provided callBacks.
    /// <code>
    /// // WARNING - Move the following line to the main OnCreate method for maximum scope.
    /// // var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    /// Stability.StableImage.Generate.Diffusion(
    ///   procedure (Params: TStableImageDiffusion)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynStableImage
    ///   begin
    ///     Result.Sender := Image1;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Image: TStableImage)
    ///       begin
    ///         // Handle success operation
    ///       end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle error message
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure Diffusion(ParamProc: TProc<TStableImageDiffusion>; CallBacks: TFunc<TAsynStableImage>); overload;
  end;

implementation

uses
  System.StrUtils, StabilityAI.NetEncoding.Base64, StabilityAI.Consts,
  StabilityAI.Async.Support;

{ TStableImageUltra }

constructor TStableImageUltra.Create;
begin
  inherited Create(True);
end;

function TStableImageUltra.Image(const FilePath: string): TStableImageUltra;
begin
  AddBytes('image', FileToBytes(FilePath), FilePath);
  Result := Self;
end;

function TStableImageUltra.Image(const Stream: TStream;
  StreamFreed: Boolean): TStableImageUltra;
begin
  if StreamFreed then
    {--- The stream's content is automatically freed. }
    AddStream('image', Stream, True, 'FileNameForHeader.png')
  else
    {--- You should release the stream's content. }
    AddBytes('image', StreamToBytes(Stream), 'FileNameForHeader.png');
  Result := Self;
end;

function TStableImageUltra.Strength(const Value: Double): TStableImageUltra;
begin
  AddField(CheckFloat('strength', Value, 0, 1), Value.ToString);
  Result := Self;
end;

{ TStableImageCore }

constructor TStableImageCore.Create;
begin
  inherited Create(True);
end;

function TStableImageCore.StylePreset(
  const Value: TStylePreset): TStableImageCore;
begin
  AddField('style_preset', Value.ToString);
  Result := Self;
end;

{ TStableImageDiffusion }

function TStableImageDiffusion.CfgScale(
  const Value: Integer): TStableImageDiffusion;
begin
  AddField(CheckInteger('cfg_scale', Value, 0, 10), Value.ToString);
  Result := Self;
end;

constructor TStableImageDiffusion.Create;
begin
  inherited Create;
end;

function TStableImageDiffusion.Mode(
  const Value: TGenerationMode): TStableImageDiffusion;
begin
  AddField('mode', Value.ToString);
  Result := Self;
end;

function TStableImageDiffusion.Model(
  const Value: TDiffusionModelType): TStableImageDiffusion;
begin
  AddField('model', Value.ToString);
  Result := Self;
end;

{ TGenerateRoute }

function TGenerateRoute.Diffusion(
  ParamProc: TProc<TStableImageDiffusion>): TStableImage;
begin
  Result := API.PostForm<TStableImage, TStableImageDiffusion>('v2beta/stable-image/generate/sd3', ParamProc);
end;

procedure TGenerateRoute.Diffusion(ParamProc: TProc<TStableImageDiffusion>;
  CallBacks: TFunc<TAsynStableImage>);
begin
  with TAsynCallBackExec<TAsynStableImage, TStableImage>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TStableImage
      begin
        Result := Self.Diffusion(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TGenerateRoute.ImageCore(ParamProc: TProc<TStableImageCore>;
  CallBacks: TFunc<TAsynStableImage>);
begin
  with TAsynCallBackExec<TAsynStableImage, TStableImage>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TStableImage
      begin
        Result := Self.ImageCore(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TGenerateRoute.ImageCore(
  ParamProc: TProc<TStableImageCore>): TStableImage;
begin
  Result := API.PostForm<TStableImage, TStableImageCore>('v2beta/stable-image/generate/core', ParamProc);
end;

function TGenerateRoute.ImageUltra(
  ParamProc: TProc<TStableImageUltra>): TStableImage;
begin
  Result := API.PostForm<TStableImage, TStableImageUltra>('v2beta/stable-image/generate/ultra', ParamProc);
end;

procedure TGenerateRoute.ImageUltra(ParamProc: TProc<TStableImageUltra>;
  CallBacks: TFunc<TAsynStableImage>);
begin
  with TAsynCallBackExec<TAsynStableImage, TStableImage>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TStableImage
      begin
        Result := Self.ImageUltra(ParamProc);
      end);
  finally
    Free;
  end;
end;

end.

unit StabilityAI.StableImage.Results;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiStabilityAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Net.Mime, REST.JsonReflect, System.JSON,
  REST.Json.Types, StabilityAI.API, StabilityAI.Common;

type
  /// <summary>
  /// Provides tools to retrieve and manage the results of asynchronous or cached image generation tasks
  /// performed by StabilityAI's API.
  /// </summary>
  /// <remarks>
  /// This class contains methods to check the status of image creation tasks and retrieve results.
  /// It supports both synchronous and asynchronous approaches, offering flexibility depending on the use case.
  /// Results are stored for 24 hours after generation. After this period, results are deleted and cannot be retrieved.
  /// </remarks>
  TResultsRoute = class(TStabilityAIAPIRoute)
    /// <summary>
    /// Tools to retrieve the results of your asynchronous (or cached) builds.
    /// <para>
    /// NOTE: This method is <c>synchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ResultId">
    /// The id of a generation, typically used for async generations, that can be used to check the status of the generation or retrieve the result.
    /// <para>
    /// string = 64 characters
    /// </para>
    /// <para>
    /// Example: a6dc6c6e20acda010fe14d71f180658f2896ed9b4ec25aa99a6ff06c796987c4
    /// </para>
    /// <para>
    /// Results are stored for 24 hours after generation. After that, the results are deleted.
    /// </para>
    /// </param>
    /// <returns>
    /// Returns a <c>TResults</c> object that contains <c>Id</c>, <c>Status</c> and and possibly an <c>image</c>.
    /// </returns>
    /// <remarks>
    /// The <c>Fetch</c> method sends a request to check the status of an image creation task. The returned <c>TResults</c> object contains the creation task ID and the status <c>in progress</c> if the process is not yet complete. Otherwise, the image is retrieved in base-64 format.
    /// <code>
    ///   var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    ///   var Fetch := Stability.StableImage.Results.Fetch(ID);
    ///   try
    ///     if not (Fetch.Status = 'in-progress') then
    ///       //The image is loaded
    ///       var Stream := Fetch.GetStream;
    ///       //Do something
    ///   finally
    ///     Stream.Free;
    ///     Fetch.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Fetch(const ResultId: string): TResults; overload;
    /// <summary>
    /// Tools to retrieve the results of your asynchronous (or cached) builds.
    /// <para>
    /// NOTE: This method is <c>asynchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ResultId">
    /// The id of a generation, typically used for async generations, that can be used to check the status of the generation or retrieve the result.
    /// <para>
    /// string = 64 characters
    /// </para>
    /// <para>
    /// Example: a6dc6c6e20acda010fe14d71f180658f2896ed9b4ec25aa99a6ff06c796987c4
    /// </para>
    /// <para>
    /// Results are stored for 24 hours after generation. After that, the results are deleted.
    /// </para>
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for asynchronous image creation, such as <c>onSuccess</c> and <c>onError</c>.
    /// </param>
    /// <remarks>
    /// The <c>Fetch</c> method sends a request to check the status of an image creation task. If the status is different from <c>in-progress</c>, then the corresponding image is loaded.
    /// <code>
    /// // WARNING - Move the following line to the main OnCreate method for maximum scope.
    /// // var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    /// Stability.StableImage.Results.Fetch(Id,
    ///   function : TAsynResults
    ///   begin
    ///     Result.Sender := Image1;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; FetchResult: TResults)
    ///       begin
    ///         // Handle success operation
    ///       end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle error message
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure Fetch(const ResultId: string; CallBacks: TFunc<TAsynResults>); overload;
  end;

implementation

uses
  StabilityAI.Consts, StabilityAI.Async.Support;

{ TResultsRoute }

function TResultsRoute.Fetch(const ResultId: string): TResults;
begin
  Result := API.Get<TResults>('v2beta/results/' + ResultId);
  if Assigned(Result) then
    begin
      if not (Result.status = 'in-progress') and not Result.Result.IsEmpty then
        begin
          {--- Documentation not compliant because it does not state that Fetch reloads a Result field
               and not the image field of the TStableImage class }
          Result.Image := Result.Result;
        end;
    end;
end;


procedure TResultsRoute.Fetch(const ResultId: string; CallBacks: TFunc<TAsynResults>);
begin
  with TAsynCallBackExec<TAsynResults, TResults>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TResults
      begin
        Result := Self.Fetch(ResultId);
      end);
  finally
    Free;
  end;
end;

end.

unit StabilityAI.StableImage.Upscale;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiStabilityAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Net.Mime, REST.JsonReflect, System.JSON,
  REST.Json.Types, StabilityAI.API, StabilityAI.Types, StabilityAI.Common;

type
  /// <summary>
  /// The <c>TUpscaleConservative</c> class manages parameters for the Conservative Upscale API, enabling the upscaling of images from small sizes (64x64) to 4K resolution while preserving the original content.
  /// The upscaling factor ranges from approximately 20 to 40 times, ensuring minimal alterations to the source image.
  /// </summary>
  /// <remarks>
  /// TUpscaleConservative is designed to provide efficient parameter handling for the Conservative Upscale API, focusing on maintaining the fidelity and integrity of the original image during the upscaling process.
  /// This class encapsulates the necessary parameters and allows for their reuse through anonymous methods that can be supplied directly to API functions, ensuring a streamlined and precise approach to image enhancement.
  /// This upscaling process is intended for scenarios where accurate reproduction of the original image is critical, and creative modifications are not desired.
  /// </remarks>
  TUpscaleConservative = class(TUpscaleCommon)
    /// <summary>
    /// Controls the likelihood of creating additional details not heavily conditioned by the init image.
    /// </summary>
    /// <param name="Value">
    /// number (Creativity) [0.2 .. 0.5]  (Default: 0.35)
    /// </param>
    function Creativity(const Value: Double): TUpscaleCommon;
    constructor Create; reintroduce;
  end;

  /// <summary>
  /// The <c>TUpscaleCreative</c> class manages parameters for the Creative Upscale API, designed to upscale images from a low resolution (between 64x64 and 1 megapixel) to 4K resolution.
  /// It is capable of performing significant upscaling (approximately 20-40 times), while preserving or enhancing image quality, particularly for degraded images.
  /// </summary>
  /// <remarks>
  /// <c>TUpscaleCreative</c> facilitates the handling of parameters for the Creative Upscale API through anonymous methods, simplifying the process of parameter management and reuse.
  /// This class is intended for upscaling images that require heavy reimagining, especially when dealing with highly degraded images. It should not be used for high-quality photographs (1 megapixel or above), as it introduces substantial creative modifications, adjustable through the creativity scale parameter.
  /// </remarks>
  TUpscaleCreative = class(TUpscaleCommon)
    /// <summary>
    /// Indicates how creative the model should be when upscaling an image. Higher values will result in more details being added to the image during upscaling.
    /// </summary>
    /// <param name="Value">
    /// number (Creativity) [0 .. 0.35]  (Default: 0.3)
    /// </param>
    function Creativity(const Value: Double): TUpscaleCommon;
    constructor Create; reintroduce;
  end;

  /// <summary>
  /// The <c>TUpscaleFast</c> class is designed to manage and facilitate the parameters for the Fast Upscaler service, which enhances image resolution by 4x using predictive and generative AI.
  /// It is optimized for lightweight, fast processing, suitable for applications where quick enhancement of image quality is required.
  /// </summary>
  /// <remarks>
  /// <c>TUpscaleFast</c> centralizes the handling of parameters for the Fast Upscaler API, enabling efficient reuse by providing these settings through anonymous methods to API-consuming functions.
  /// This class is ideal for scenarios where rapid upscaling is necessary, such as improving the quality of compressed images for social media or similar use cases, without sacrificing performance.
  /// </remarks>
  TUpscaleFast = class(TMultipartFormData)
    /// <summary>
    /// The image to use as the starting point for the generation.
    /// </summary>
    /// <param name="FilePath">
    /// Filename with supported format (jpeg, png, webp)
    /// </param>
    /// <returns>
    /// The updated <c>TStableImageUltra</c> instance.
    /// </returns>
    /// <remarks>
    /// <para>
    /// - Width must be between 64 and 16,384 pixels
    /// </para>
    /// <para>
    /// - Height must be between 64 and 16,384 pixels
    /// </para>
    /// <para>
    /// - Total pixel count must be at least 4,096 pixels
    /// </para>
    /// <para>
    /// - IMPORTANT: The strength parameter is required when image is provided.
    /// </para>
    /// </remarks>
    function Image(const FilePath: string): TUpscaleFast; overload;
    /// <summary>
    /// Sets the image to use as the starting point for the upscaling process from a stream.
    /// </summary>
    /// <param name="Stream">
    /// A <c>TStream</c> containing the image data. Supported formats include JPEG, PNG, and WEBP.
    /// </param>
    /// <param name="StreamFreed">
    /// A Boolean value indicating whether the stream should be automatically freed after use.
    /// If set to <c>True</c>, the stream will be freed; otherwise, you are responsible for managing the stream's memory.
    /// </param>
    /// <returns>
    /// The updated <c>TUpscaleFast</c> instance.
    /// </returns>
    /// <remarks>
    /// <para>
    /// - Width must be between 64 and 16,384 pixels.
    /// </para>
    /// <para>
    /// - Height must be between 64 and 16,384 pixels.
    /// </para>
    /// <para>
    /// - Total pixel count must be at least 4,096 pixels.
    /// </para>
    /// <para>
    /// - IMPORTANT: The strength parameter is required when an image is provided.
    /// </para>
    /// </remarks>
    function Image(const Stream: TStream; StreamFreed: Boolean = False): TUpscaleFast; overload;
    /// <summary>
    /// Dictates the content-type of the generated image.
    /// </summary>
    /// <param name="Value">
    /// Enum: <c>jpeg</c> <c>png webp</c>
    /// </param>
    function OutputFormat(const Value: TOutPutFormat): TUpscaleFast;
    constructor Create; reintroduce;
  end;

  /// <summary>
  /// The <c>TUpscaleRoute</c> class provides access to Stability AI's image upscaling APIs, enabling image resolution enhancement through various upscaling modes such as Conservative, Creative, and Fast.
  /// </summary>
  /// <remarks>
  /// The <c>TUpscaleRoute</c> class offers a structured interface to interact with the Stability AI platform's image upscaling capabilities.
  /// It allows developers to:
  /// <para>
  /// - Perform conservative upscaling for minimal alteration of original images while significantly increasing resolution.
  /// </para>
  /// <para>
  /// - Utilize creative upscaling to enhance and reimagine degraded images with controlled creativity.
  /// </para>
  /// <para>
  /// - Opt for fast upscaling for quick resolution improvement, particularly suitable for low-latency applications.
  /// </para>
  /// Each method supports synchronous and asynchronous execution, offering flexibility for different application scenarios.
  /// </remarks>
  TUpscaleRoute = class(TStabilityAIAPIRoute)
    /// <summary>
    /// Takes images between 64x64 and 1 megapixel and upscales them all the way to 4K resolution. Put more generally, it can upscale images ~20-40x times while preserving all aspects. Conservative Upscale minimizes alterations to the image and should not be used to reimagine an image.
    /// <para>
    /// NOTE: This method is <c>synchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as image, the prompt etc.
    /// </param>
    /// <returns>
    /// Returns a <c>TStableImage</c> object that contains image base-64 generated.
    /// </returns>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    ///   var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    ///   var Data := Stability.StableImage.Upscale.Conservative(
    ///     procedure (Params: TUpscaleConservative)
    ///     begin
    ///       Params.OutputFormat(png);
    ///       // Move on to the other parameters.
    ///     end);
    ///   var Stream := Data.GetStream;
    ///   try
    ///     //--- Save image
    ///     Data.SaveToFile(FileName);
    ///     //--- Display image
    ///     Image1.Picture.LoadFromStream(Stream);
    ///   finally
    ///     Data.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Conservative(ParamProc: TProc<TUpscaleConservative>): TStableImage; overload;
    /// <summary>
    /// Takes images between 64x64 and 1 megapixel and upscales them all the way to 4K resolution. Put more generally, it can upscale images ~20-40x times while preserving all aspects. Conservative Upscale minimizes alterations to the image and should not be used to reimagine an image.
    /// <para>
    /// NOTE: This method is <c>asynchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as image, the prompt etc.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for asynchronous image creation, such as <c>onSuccess</c> and <c>onError</c>.
    /// </param>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line to the main OnCreate method for maximum scope.
    /// // var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    /// Stability.StableImage.Upscale.Conservative(
    ///   procedure (Params: TUpscaleConservative)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynStableImage
    ///   begin
    ///     Result.Sender := Image1;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Image: TStableImage)
    ///       begin
    ///         // Handle success operation
    ///       end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle error message
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure Conservative(ParamProc: TProc<TUpscaleConservative>; CallBacks: TFunc<TAsynStableImage>); overload;
    /// <summary>
    /// Takes images between 64x64 and 1 megapixel and upscales them all the way to 4K resolution. Put more generally, it can upscale images ~20-40x times while preserving, and often enhancing, quality. Creative Upscale works best on highly degraded images and is not for photos of 1mp or above as it performs heavy reimagining (controlled by creativity scale).
    /// <para>
    /// NOTE: This method is <c>synchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as image, the prompt etc.
    /// </param>
    /// <returns>
    /// Returns a <c>TResults</c> object that contains Id of the task.
    /// </returns>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    ///   var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    ///   var Data := Stability.StableImage.Upscale.Creative(
    ///     procedure (Params: TUpscaleCreative)
    ///     begin
    ///       Params.OutputFormat(png);
    ///       // Move on to the other parameters.
    ///     end);
    ///   var Stream := Data.GetStream;
    ///   try
    ///     //--- Save image
    ///     Data.SaveToFile(FileName);
    ///     //--- Display image
    ///     Image1.Picture.LoadFromStream(Stream);
    ///   finally
    ///     Data.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Creative(ParamProc: TProc<TUpscaleCreative>): TResults; overload;
    /// <summary>
    /// Takes images between 64x64 and 1 megapixel and upscales them all the way to 4K resolution. Put more generally, it can upscale images ~20-40x times while preserving, and often enhancing, quality. Creative Upscale works best on highly degraded images and is not for photos of 1mp or above as it performs heavy reimagining (controlled by creativity scale).
    /// <para>
    /// NOTE: This method is <c>asynchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as image, the prompt etc.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for asynchronous image creation, such as <c>onSuccess</c> and <c>onError</c>.
    /// </param>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line to the main OnCreate method for maximum scope.
    /// // var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    /// Stability.StableImage.Upscale.Creative(
    ///   procedure (Params: TUpscaleCreative)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynResults
    ///   begin
    ///     Result.Sender := Image1;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Data: TResults)
    ///       begin
    ///         // Handle success operation
    ///       end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle error message
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure Creative(ParamProc: TProc<TUpscaleCreative>; CallBacks: TFunc<TAsynResults>); overload;
    /// <summary>
    /// Our Fast Upscaler service enhances image resolution by 4x using predictive and generative AI. This lightweight and fast service (processing in ~1 second) is ideal for enhancing the quality of compressed images, making it suitable for social media posts and other applications.
    /// <para>
    /// NOTE: This method is <c>synchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as image, the prompt etc.
    /// </param>
    /// <returns>
    /// Returns a <c>TStableImage</c> object that contains image base-64 generated.
    /// </returns>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    ///   var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    ///   var Data := Stability.StableImage.Upscale.Fast(
    ///     procedure (Params: TUpscaleFast)
    ///     begin
    ///       Params.OutputFormat(png);
    ///       // Move on to the other parameters.
    ///     end);
    ///   var Stream := Data.GetStream;
    ///   try
    ///     //--- Save image
    ///     Data.SaveToFile(FileName);
    ///     //--- Display image
    ///     Image1.Picture.LoadFromStream(Stream);
    ///   finally
    ///     Data.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Fast(ParamProc: TProc<TUpscaleFast>): TStableImage; overload;
    /// <summary>
    /// Our Fast Upscaler service enhances image resolution by 4x using predictive and generative AI. This lightweight and fast service (processing in ~1 second) is ideal for enhancing the quality of compressed images, making it suitable for social media posts and other applications.
    /// <para>
    /// NOTE: This method is <c>asynchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as image, the prompt etc.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for asynchronous image creation, such as <c>onSuccess</c> and <c>onError</c>.
    /// </param>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line to the main OnCreate method for maximum scope.
    /// // var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    /// Stability.StableImage.Upscale.Fast(
    ///   procedure (Params: TUpscaleFast)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynStableImage
    ///   begin
    ///     Result.Sender := Image1;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Image: TStableImage)
    ///       begin
    ///         // Handle success operation
    ///       end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle error message
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure Fast(ParamProc: TProc<TUpscaleFast>; CallBacks: TFunc<TAsynStableImage>); overload;
  end;

implementation

uses
  StabilityAI.NetEncoding.Base64, StabilityAI.Async.Support;

{ TUpscaleConservative }

constructor TUpscaleConservative.Create;
begin
  inherited Create(True);
end;

function TUpscaleConservative.Creativity(const Value: Double): TUpscaleCommon;
begin
  AddField(CheckFloat('creativity', Value, 0.2, 0.5), Value.ToString);
  Result := Self;
end;

{ TUpscaleCreative }

constructor TUpscaleCreative.Create;
begin
  inherited Create(True);
end;

function TUpscaleCreative.Creativity(const Value: Double): TUpscaleCommon;
begin
  AddField(CheckFloat('creativity', Value, 0, 0.35), Value.ToString);
  Result := Self;
end;

{ TUpscaleFast }

constructor TUpscaleFast.Create;
begin
  inherited Create(True);
end;

function TUpscaleFast.Image(const FilePath: string): TUpscaleFast;
begin
  AddBytes('image', FileToBytes(FilePath), FilePath);
  Result := Self;
end;

function TUpscaleFast.Image(const Stream: TStream;
  StreamFreed: Boolean): TUpscaleFast;
begin
  if StreamFreed then
    {--- The stream's content is automatically freed. }
    AddStream('image', Stream, True, 'FileNameForHeader.png')
  else
    {--- You should release the stream's content. }
    AddBytes('image', StreamToBytes(Stream), 'FileNameForHeader.png');
  Result := Self;
end;

function TUpscaleFast.OutputFormat(const Value: TOutPutFormat): TUpscaleFast;
begin
  AddField('output_format', Value.ToString);
  Result := Self;
end;

{ TUpscaleRoute }

function TUpscaleRoute.Conservative(ParamProc: TProc<TUpscaleConservative>): TStableImage;
begin
  Result := API.PostForm<TStableImage, TUpscaleConservative>('v2beta/stable-image/upscale/conservative', ParamProc);
end;

procedure TUpscaleRoute.Conservative(ParamProc: TProc<TUpscaleConservative>;
  CallBacks: TFunc<TAsynStableImage>);
begin
  with TAsynCallBackExec<TAsynStableImage, TStableImage>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TStableImage
      begin
        Result := Self.Conservative(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TUpscaleRoute.Creative(ParamProc: TProc<TUpscaleCreative>): TResults;
begin
  Result := API.PostForm<TResults, TUpscaleCreative>('v2beta/stable-image/upscale/creative', ParamProc);
end;

procedure TUpscaleRoute.Creative(ParamProc: TProc<TUpscaleCreative>;
  CallBacks: TFunc<TAsynResults>);
begin
  with TAsynCallBackExec<TAsynResults, TResults>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TResults
      begin
        Result := Self.Creative(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TUpscaleRoute.Fast(ParamProc: TProc<TUpscaleFast>): TStableImage;
begin
  Result := API.PostForm<TStableImage, TUpscaleFast>('v2beta/stable-image/upscale/fast', ParamProc);
end;

procedure TUpscaleRoute.Fast(ParamProc: TProc<TUpscaleFast>;
  CallBacks: TFunc<TAsynStableImage>);
begin
  with TAsynCallBackExec<TAsynStableImage, TStableImage>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TStableImage
      begin
        Result := Self.Fast(ParamProc);
      end);
  finally
    Free;
  end;
end;

end.

unit StabilityAI.Types;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiStabilityAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

{--- Types only for versions greater than 1 }

type
  /// <summary>
  /// Styles to guide the model
  /// </summary>
  /// <remarks>
  /// Enum: <c>model3d</c>, <c>analogFilm</c>, <c>anime</c>, <c>cinematic</c>, <c>comicBook</c>,
  /// <c>digitalArt</c>, <c>enhance</c>, <c>fantasyArt</c>, <c>isometric</c>, <c>lineArt</c>,
  /// <c>lowPoly</c>, <c>modelingCompound</c>, <c>neonPunk</c>, <c>origami</c>, <c>photographic</c>,
  /// <c>pixelArt</c>, <c>tileTexture</c>
  /// </remarks>
  TStylePreset = (
    model3d,
    analogFilm,
    anime,
    cinematic,
    comicBook,
    digitalArt,
    enhance,
    fantasyArt,
    isometric,
    lineArt,
    lowPoly,
    modelingCompound,
    neonPunk,
    origami,
    photographic,
    pixelArt,
    tileTexture
  );

  TStylePresetHelper = record helper for TStylePreset
    function ToString: string;
  end;

  /// <summary>
  /// Stable Diffusion 3.0 models
  /// </summary>
  /// <remarks>
  /// Enum: <c>sd3Large</c>, <c>sd3LargeTurbo</c>, <c>sd3Medium</c>, <c>sd35Large</c>, <c>sd35LargeTurbo</c>, <c>sd35Medium</c>
  /// </remarks>
  TDiffusionModelType = (
    sd3Large,
    sd3LargeTurbo,
    sd3Medium,
    sd35Large,
    sd35LargeTurbo,
    sd35Medium
  );

  TDiffusionModelTypeHelper = record helper for TDiffusionModelType
    function ToString: string;
  end;

  /// <summary>
  /// Support for image building
  /// </summary>
  /// <remarks>
  /// Enum: <c>imageToImage</c>, <c>textToImage</c>
  /// </remarks>
  TGenerationMode = (
    imageToImage,
    textToImage
  );

  TGenerationModeHelper = record helper for TGenerationMode
    function ToString: string;
  end;

  /// <summary>
  /// Output format for the resulting image
  /// </summary>
  /// <remarks>
  /// Enum: <c>jpeg</c>, <c>png</c>, <c>webp</c>
  /// </remarks>
  TOutPutFormat = (
    jpeg,
    png,
    webp
  );

  TOutPutFormatHelper = record helper for TOutPutFormat
    function ToString: string;
  end;

  /// <summary>
  /// Aspect ratio of the generated image
  /// </summary>
  /// <remarks>
  /// Enum: <c>ratio16x9</c>, <c>ratio1x1</c>, <c>ratio21x9</c>, <c>ratio2x3</c>, <c>ratio3x2</c>,
  /// <c>ratio4x5</c>, <c>ratio5x4</c>, <c>ratio9x16</c>, <c>ratio9x21</c>
  /// </remarks>
  TAspectRatioType = (
    ratio16x9,
    ratio1x1,
    ratio21x9,
    ratio2x3,
    ratio3x2,
    ratio4x5,
    ratio5x4,
    ratio9x16,
    ratio9x21
  );

  TAspectRatioTypeHelper = record helper for TAspectRatioType
    function ToString: string;
  end;

  /// <summary>
  /// Direction of the light source.
  /// </summary>
  /// <remarks>
  /// Enum: <c>above</c>, <c>below</c>, <c>left</c>, <c>right</c>
  /// </remarks>
  TLightSourceDirection = (
    above,
    below,
    left,
    right
  );

  TLightSourceDirectionHelper = record helper for TLightSourceDirection
    function ToString: string;
  end;

  /// <summary>
  /// Resolutions of the textures used for both the albedo (color) map and the normal map.
  /// </summary>
  /// <summary>
  /// Enum: <c>r1024</c>, <c>r2048</c>, <c>r512</c>
  /// </summary>
  TTextureResolutionType = (
    r1024,
    r2048,
    r512
  );

  TTextureResolutionTypeHelper = record helper for TTextureResolutionType
    function ToString: string;
  end;

  /// <summary>
  /// Remeshing algorithm types.
  /// </summary>
  /// <remarks>
  /// Enum: <c>none</c>, <c>quad</c>, <c>triangle</c>
  /// </remarks>
  TRemeshType = (
    none,
    quad,
    triangle
  );

  TRemeshTypeHelper = record helper for TRemeshType
    function ToString: string;
  end;

implementation

{ TStylePresetHelper }

function TStylePresetHelper.ToString: string;
begin
  case Self of
    model3d:
      Exit('3d-model');
    analogFilm:
      Exit('analog-film');
    anime:
      Exit('anime');
    cinematic:
      Exit('cinematic');
    comicBook:
      Exit('comic-book');
    digitalArt:
      Exit('digital-art');
    enhance:
      Exit('enhance');
    fantasyArt:
      Exit('fantasy-art');
    isometric:
      Exit('isometric');
    lineArt:
      Exit('line-art');
    lowPoly:
      Exit('low-poly');
    modelingCompound:
      Exit('modeling-compound');
    neonPunk:
      Exit('neon-punk');
    origami:
      Exit('origami');
    photographic:
      Exit('photographic');
    pixelArt:
      Exit('pixel-art');
    tileTexture:
      Exit('tile-texture');
  end;
end;

{ TDiffusionModelTypeHelper }

function TDiffusionModelTypeHelper.ToString: string;
begin
  case Self of
    sd3Large:
      Exit('sd3-large');
    sd3LargeTurbo:
      Exit('sd3-large-turbo');
    sd3Medium:
      Exit('sd3-medium');
    sd35Large:
      Exit('sd3.5-large');
    sd35LargeTurbo:
      Exit('sd3.5-large-turbo');
    sd35Medium:
      Exit('sd3.5-medium');
  end;
end;

{ TOutPutFormatHelper }

function TOutPutFormatHelper.ToString: string;
begin
  case Self of
    jpeg:
      Exit('jpeg');
    png:
      Exit('png');
    webp:
      Exit('webp');
  end;
end;

{ TAspectRatioTypeHelper }

function TAspectRatioTypeHelper.ToString: string;
begin
  case Self of
    ratio16x9:
      Exit('16:9');
    ratio1x1:
      Exit('1:1');
    ratio21x9:
      Exit('21:9');
    ratio2x3:
      Exit('2:3');
    ratio3x2:
      Exit('3:2');
    ratio4x5:
      Exit('4:5');
    ratio5x4:
      Exit('5:4');
    ratio9x16:
      Exit('9:16');
    ratio9x21:
      Exit('16:9');
  end;
end;

{ TLightSourceDirectionHelper }

function TLightSourceDirectionHelper.ToString: string;
begin
  case Self of
    above:
      Exit('above');
    below:
      Exit('below');
    left:
      Exit('left');
    right:
      Exit('right');
  end;
end;

{ TGenerationModeHelper }

function TGenerationModeHelper.ToString: string;
begin
  case self of
    imageToImage:
      Exit('image-to-image');
    textToImage:
      Exit('text-to-image');
  end;
end;

{ TTextureResolutionTypeHelper }

function TTextureResolutionTypeHelper.ToString: string;
begin
  case Self of
    r1024:
      Exit('1024');
    r2048:
      Exit('2048');
    r512:
      Exit('512');
  end;
end;

{ TRemeshTypeHelper }

function TRemeshTypeHelper.ToString: string;
begin
  case Self of
    none:
      Exit('none');
    quad:
      Exit('quad');
    triangle:
      Exit('triangle');
  end;
end;

end.

unit StabilityAI.Version1.Engines;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiStabilityAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Net.Mime, REST.JsonReflect, System.JSON,
  REST.Json.Types, StabilityAI.API, StabilityAI.API.Params, StabilityAI.Async.Support;

type
  /// <summary>
  /// Model specialization.
  /// </summary>
  TTypeKind = (
    AUDIO,
    CLASSIFICATION,
    PICTURE,
    STORAGE,
    TEXT,
    VIDEO
  );

  FTypeKindHelper = record helper for TTypeKind
    function ToString: string;
    class function Create(const Value: string): TTypeKind; static;
  end;

  /// <summary>
  /// Interceptor class for converting <c>TTypeKind</c> values to and from their string representations in JSON serialization and deserialization.
  /// </summary>
  /// <remarks>
  /// This class is used to facilitate the conversion between the <c>TTypeKind</c> enum and its string equivalents during JSON processing.
  /// It extends the <c>TJSONInterceptorStringToString</c> class to override the necessary methods for custom conversion logic.
  /// </remarks>
  TTypeKindInterceptor = class(TJSONInterceptorStringToString)
    /// <summary>
    /// Converts the <c>TTypeKind</c> value of the specified field to a string during JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be converted.
    /// </param>
    /// <param name="Field">
    /// The field name representing the <c>TTypeKind</c> value.
    /// </param>
    /// <returns>
    /// The string representation of the <c>TTypeKind</c> value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string back to a <c>TTypeKind</c> value for the specified field during JSON deserialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be set.
    /// </param>
    /// <param name="Field">
    /// The field name where the <c>TTypeKind</c> value will be set.
    /// </param>
    /// <param name="Arg">
    /// The string representation of the <c>TTypeKind</c> to be converted back.
    /// </param>
    /// <remarks>
    /// This method converts the string argument back to the corresponding <c>TTypeKind</c> value and assigns it to the specified field in the object.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Represents an engine with its unique identifier, name, description, and type.
  /// </summary>
  /// <remarks>
  /// The <c>TEngine</c> class encapsulates metadata about an engine, including its unique identifier,
  /// display name, description, and the type of content it produces.
  /// It is commonly used for managing engine information within StabilityAI integrations.
  /// </remarks>
  TEngine = class
  private
    FId: string;
    FName: string;
    FDescription: string;
    [JsonReflectAttribute(ctString, rtString, TTypeKindInterceptor)]
    FType: TTypeKind;
  public
    /// <summary>
    /// Unique identifier for the engine
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Name of the engine
    /// </summary>
    property Name: string read FName write FName;
    /// <summary>
    /// Description of th model
    /// </summary>
    property Description: string read FDescription write FDescription;
    /// <summary>
    /// The type of content this engine produces
    /// </summary>
    /// <remarks>
    /// Enum: <c>AUDIO</c>, <c>CLASSIFICATION</c>, <c>PICTURE</c>, <c>STORAGE</c>, <c>TEXT</c>, <c>VIDEO</c>
    /// </remarks>
    property &Type: TTypeKind read FType write FType;
  end;

  /// <summary>
  /// Represents a collection of engines.
  /// </summary>
  /// <remarks>
  /// The <c>TEngines</c> class is a container for multiple <c>TEngine</c> instances.
  /// It is typically used to store and manage the results of queries or operations that retrieve multiple engines.
  /// </remarks>
  TEngines = class
  private
    FResult: TArray<TEngine>;
  public
    /// <summary>
    /// Gets or sets the array of engines contained in this collection.
    /// </summary>
    /// <remarks>
    /// The <c>Result</c> property provides access to the list of <c>TEngine</c> objects stored in this collection.
    /// Each object in the array represents an individual engine with its respective metadata.
    /// </remarks>
    property Result: TArray<TEngine> read FResult write FResult;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TEngines</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynEngines</c> type extends the <c>TAsynParams&lt;TEngines&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynEngines = TAsynCallBack<TEngines>;

  /// <summary>
  /// Represents the API route for managing StabilityAI engines.
  /// </summary>
  /// <remarks>
  /// The <c>TEnginesRoute</c> class provides methods for retrieving a list of engines available to the user or organization.
  /// It supports both synchronous and asynchronous operations to cater to different usage scenarios.
  /// </remarks>
  TEnginesRoute = class(TStabilityAIAPIRoute)
    /// <summary>
    /// List all engines available to your organization/user
    /// <para>
    /// NOTE: This method is <c>synchronous</c>
    /// </para>
    /// </summary>
    /// <returns>
    /// Returns a <c>TEngines</c> object that contains model informations.
    /// </returns>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    ///   var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    ///   var Data := Stability.Version1.Engines.List;
    ///   try
    ///     for var Item in Data.Result do
    ///       showMesage(Item.Name);
    ///   finally
    ///     Data.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function List: TEngines; overload;
    /// <summary>
    /// List all engines available to your organization/user
    /// <para>
    /// NOTE: This method is <c>asynchronous</c>
    /// </para>
    /// </summary>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for asynchronous image creation, such as <c>onSuccess</c> and <c>onError</c>.
    /// </param>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line to the main OnCreate method for maximum scope.
    /// // var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    /// Stability.Version1.Engines.List(
    ///   function : TAsynEngines
    ///   begin
    ///     Result.Sender := my_obj;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Data: TEngines)
    ///       begin
    ///         // Handle success operation
    ///       end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle error message
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure List(CallBacks: TFunc<TAsynEngines>); overload;
  end;

implementation

uses
  System.StrUtils, System.Rtti, Rest.Json;

{ FTypeKindHelper }

class function FTypeKindHelper.Create(const Value: string): TTypeKind;
begin
  var index := IndexStr(Value.ToUpper, ['AUDIO', 'CLASSIFICATION', 'PICTURE', 'STORAGE', 'TEXT', 'VIDEO']);
  if index = -1 then
    raise Exception.Create('Type kind unknown.');
  Result := TTypeKind(index);
end;

function FTypeKindHelper.ToString: string;
begin
  case Self of
    AUDIO:
      Exit('AUDIO');
    CLASSIFICATION:
      Exit('CLASSIFICATION');
    PICTURE:
      Exit('PICTURE');
    STORAGE:
      Exit('STORAGE');
    TEXT:
      Exit('TEXT');
    VIDEO:
      Exit('VIDEO');
  end;
end;

{ TTypeKindInterceptor }

function TTypeKindInterceptor.StringConverter(Data: TObject; Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TTypeKind>.ToString;
end;

procedure TTypeKindInterceptor.StringReverter(Data: TObject; Field, Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TTypeKind.Create(Arg)));
end;

{ TEnginesRoute }

procedure TEnginesRoute.List(CallBacks: TFunc<TAsynEngines>);
begin
  with TAsynCallBackExec<TAsynEngines, TEngines>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TEngines
      begin
        Result := Self.List;
      end);
  finally
    Free;
  end;
end;

function TEnginesRoute.List: TEngines;
begin
  Result := API.GetArray<TEngines>('v1/engines/list');
end;

{ TEngines }

destructor TEngines.Destroy;
begin
  for var Item in FResult do
    Item.Free;
  inherited;
end;

end.

unit StabilityAI.Version1.SDXL1AndSD1_6;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiStabilityAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Net.Mime, REST.JsonReflect, System.JSON,
  REST.Json.Types, StabilityAI.API, StabilityAI.API.Params, StabilityAI.Types,
  StabilityAI.Common, StabilityAI.Async.Support;

type
  /// <summary>
  /// CLIP guidance preset, use with ancestral sampler for best results.
  /// </summary>
  /// <remarks>
  /// FAST_BLUE, FAST_GREEN, NONE, SIMPLE, SLOW, SLOWER, SLOWEST
  /// </remarks>
  TClipGuidancePresetType = (
    FAST_BLUE,
    FAST_GREEN,
    NONE,
    SIMPLE,
    SLOW,
    SLOWER,
    SLOWEST
  );

  TClipGuidancePresetTypeHelper = record helper for TClipGuidancePresetType
    function ToString: string;
  end;

  /// <summary>
  /// Available Samplers
  /// </summary>
  /// <remarks>
  /// DDIM, DDPM, K_DPMPP_2M, K_DPMPP_2S_ANCESTRAL, K_DPM_2, K_DPM_2_ANCESTRAL, K_EULER, K_EULER_ANCESTRAL, K_HEUN, K_LMS
  /// </remarks>
  TSamplerType = (
    DDIM,
    DDPM,
    K_DPMPP_2M,
    K_DPMPP_2S_ANCESTRAL,
    K_DPM_2,
    K_DPM_2_ANCESTRAL,
    K_EULER,
    K_EULER_ANCESTRAL,
    K_HEUN,
    K_LMS
   );

  TSamplerTypeHelper = record helper for TSamplerType
    function ToString: string;
  end;

  /// <summary>
  /// Used to control how much influence the <c>init_image</c> has on the result
  /// </summary>
  /// <remarks>
  /// IMAGE_STRENGTH, STEP_SCHEDULE
  /// </remarks>
  TInitImageMode = (
    IMAGE_STRENGTH,
    STEP_SCHEDULE
  );

  TInitImageModeHelper = record helper for TInitImageMode
    function ToString: string;
  end;

  /// <summary>
  /// Type of mask to detemines where to source the mask
  /// </summary>
  /// <remarks>
  /// <c>MASK_IMAGE_WHITE</c>, <c>MASK_IMAGE_BLACK</c>, <c>INIT_IMAGE_ALPHA</c>
  /// </remarks>
  TMaskSource = (
    /// <summary>
    /// Use the white pixels of the mask_image as the mask, where white pixels are completely replaced and black pixels are unchanged
    /// </summary>
    MASK_IMAGE_WHITE,
    /// <summary>
    /// Use the black pixels of the mask_image as the mask, where black pixels are completely replaced and white pixels are unchanged
    /// </summary>
    MASK_IMAGE_BLACK,
    /// <summary>
    /// Use the alpha channel of the init_image as the mask, where fully transparent pixels are completely replaced and fully opaque pixels are unchanged
    /// </summary>
    INIT_IMAGE_ALPHA
  );

  TMaskSourceHelper = record helper for TMaskSource
    function ToString: string;
  end;

  /// <summary>
  /// Represents a prompt used in Stable Diffusion APIs for image generation.
  /// </summary>
  /// <remarks>
  /// This class provides methods to define a textual prompt and assign weights to it.
  /// Prompts can influence the content of generated images, where higher weights
  /// increase the prominence of the associated text in the final output.
  /// Use negative weights for negative prompts to reduce the influence of undesired elements.
  /// </remarks>
  TPrompt = class(TJSONParam)
  public
    /// <summary>
    /// The prompt itself.
    /// </summary>
    /// <param name="Value">
    /// string <= 2000 characters
    /// </param>
    function Text(const Value: string): TPrompt;
    /// <summary>
    /// Weight of the prompt (use negative numbers for negative prompts)
    /// </summary>
    /// <param name="Value">
    /// number <float>
    /// </param>
    function Weight(const Value: Double): TPrompt;
    /// <summary>
    /// Creates a new instance of the <c>TPrompt</c> class with the specified text.
    /// </summary>
    /// <param name="Value">
    /// The text of the prompt. Must be a string of 2000 characters or fewer.
    /// </param>
    /// <returns>
    /// A new <c>TPrompt</c> instance with the specified text.
    /// </returns>
    class function New(const Value: string): TPrompt; overload; static;
    /// <summary>
    /// Creates a new instance of the <c>TPrompt</c> class with the specified text and weight.
    /// </summary>
    /// <param name="Weight">
    /// The weight of the prompt. Use positive values to increase the influence
    /// of the prompt and negative values for negative prompts.
    /// </param>
    /// <param name="Value">
    /// The text of the prompt. Must be a string of 2000 characters or fewer.
    /// </param>
    /// <returns>
    /// A new <c>TPrompt</c> instance with the specified text and weight.
    /// </returns>
    class function New(const Weight: Double; const Value: string): TPrompt; overload; static;
  end;

  /// <summary>
  /// Represents a collection of methods and properties for handling parameters used to interact with Stable Diffusion APIs.
  /// </summary>
  /// <remarks>
  /// The <c>TPayload</c> class is designed to encapsulate the different configurations needed to interface with the Stable Diffusion APIs,
  /// such as SDXL 1.0 and SD 1.6. This class allows parameters to be provided in a structured manner using anonymous methods, making it
  /// flexible and reusable when generating prompts for different API requests. It abstracts the complexity of parameter management,
  /// providing a consistent interface for initiating image generation processes.
  /// </remarks>
  TPayload = class(TJSONParam)
  public
    /// <summary>
    /// An array of text prompts to use for generation.
    /// </summary>
    function TextPrompts(const Value: TArray<TPrompt>): TPayload;
    /// <summary>
    /// Height of the image to generate, in pixels, in an increment divisible by 64.
    /// </summary>
    /// <param name="Value">
    /// integer (DiffuseImageHeight) multiple of 64 >= 128
    /// <para>
    /// Default: 512
    /// </para>
    /// </param>
    function Height(const Value: Integer): TPayload;
    /// <summary>
    /// Width of the image to generate, in pixels, in an increment divisible by 64.
    /// </summary>
    /// <param name="Value">
    /// integer (DiffuseImageWidth) multiple of 64 >= 128
    /// <para>
    /// Default: 512
    /// </para>
    /// </param>
    function Width(const Value: Integer): TPayload;
    /// <summary>
    /// How strictly the diffusion process adheres to the prompt text (higher values keep your image closer to your prompt)
    /// </summary>
    /// <param name="Value">
    /// Number: (CfgScale) [0 .. 35]
    /// <para>
    /// Default: 7
    /// </para>
    /// </param>
    function CfgScale(const Value: Double): TPayload;
    /// <summary>
    /// Set the clip guidance preset
    /// </summary>
    /// <param name="Value">
    /// Enum: <c>FAST_BLUE</c>, <c>FAST_GREEN</c>, <c>NONE</c>, <c>SIMPLE</c>, <c>SLOW</c>, <c>SLOWER</c>, <c>SLOWEST</c>
    /// <para>
    /// Default: <c>NONE</c>
    /// </para>
    /// </param>
    function ClipGuidancePreset(const Value: TClipGuidancePresetType): TPayload;
    /// <summary>
    /// Select sampler to use for the diffusion process.
    /// </summary>
    /// <param name="Value">
    /// Enum: DDIM, DDPM, K_DPMPP_2M, K_DPMPP_2S_ANCESTRAL, K_DPM_2, K_DPM_2_ANCESTRAL, K_EULER, K_EULER_ANCESTRAL, K_HEUN, K_LMS
    /// </param>
    /// <remarks>
    /// If this value is omitted it will automatically select an appropriate sampler for you.
    /// </remarks>
    function Sampler(const Value: TSamplerType): TPayload;
    /// <summary>
    /// Number of images to generate
    /// </summary>
    /// <param name="Value">
    /// Integer: [1 .. 10]
    /// <para>
    /// Default: 1
    /// </para>
    /// </param>
    function Samples(const Value: Integer): TPayload;
    /// <summary>
    /// A specific value that is used to guide the 'randomness' of the generation
    /// </summary>
    /// <param name="Value">
    /// number [0 .. 4294967294]  (Default: 0)
    /// </param>
    /// <remarks>
    /// Omit this parameter or pass 0 to use a random seed.
    /// </remarks>
    function Seed(const Value: Int64): TPayload;
    /// <summary>
    /// Number of diffusion steps to run.
    /// </summary>
    /// <param name="Value">
    /// Integer: [10 .. 50]
    /// <para>
    /// Default: 30
    /// </para>
    /// </param>
    function Steps(const Value: Integer): TPayload;
    /// <summary>
    /// Pass in a style preset to guide the image model towards a particular style.
    /// </summary>
    /// <param name="Value">
    /// Enum: <c>3d-model</c> <c>analog-film</c> <c>anime</c> <c>cinematic</c> <c>comic-book</c> <c>digital-art</c> <c>enhance</c> <c>fantasy-art</c> <c>isometric</c> <c>line-art</c> <c>low-poly</c> <c>modeling-compound</c> <c>neon-punk</c> <c>origami</c> <c>photographic</c> <c>pixel-art</c> <c>tile-texture</c>
    /// </param>
    /// <remarks>
    /// This list of style presets is subject to change.
    /// </remarks>
    function StylePreset(const Value: TStylePreset): TPayload;
    /// <summary>
    /// Extra parameters passed to the engine. These parameters are used for in-development or experimental features and may change without warning
    /// </summary>
    /// <param name="Value">
    /// A JSON object
    /// </param>
    /// <remarks>
    /// So please use with caution.
    /// </remarks>
    function Extras(const Value: TJSONObject): TPayload;
  end;

  /// <summary>
  /// Represents a multipart prompt used in Stable Diffusion APIs for image generation.
  /// </summary>
  /// <remarks>
  /// This class allows the definition of text prompts and their associated weights
  /// for use in multipart form submissions. Each prompt influences the generation
  /// process based on its weight, where higher weights emphasize the importance of
  /// the associated text, and negative weights suppress undesired elements.
  /// Use this class for scenarios that require multipart payloads for image generation APIs.
  /// </remarks>
  TPromptMultipart = class
  private
    FText: string;
    FWeight: Double;
  public
    /// <summary>
    /// The prompt itself.
    /// </summary>
    /// <param name="Value">
    /// string <= 2000 characters
    /// </param>
    property Text: string read FText write FText;
    /// <summary>
    /// Weight of the prompt (use negative numbers for negative prompts)
    /// </summary>
    /// <param name="Value">
    /// number <float>
    /// </param>
    property Weight: Double read FWeight write FWeight;
    /// <summary>
    /// Creates a new instance of the <c>TPromptMultipart</c> class with the specified text.
    /// </summary>
    /// <param name="Text">
    /// The text of the prompt. Must be a string of 2000 characters or fewer.
    /// </param>
    /// <returns>
    /// A new <c>TPromptMultipart</c> instance with the specified text.
    /// </returns>
    class function New(const Text: string): TPromptMultipart; overload;
    /// <summary>
    /// Creates a new instance of the <c>TPromptMultipart</c> class with the specified text and weight.
    /// </summary>
    /// <param name="Weight">
    /// The weight of the prompt. Use positive values to increase the influence
    /// of the prompt and negative values for negative prompts.
    /// </param>
    /// <param name="Value">
    /// The text of the prompt. Must be a string of 2000 characters or fewer.
    /// </param>
    /// <returns>
    /// A new <c>TPromptMultipart</c> instance with the specified text and weight.
    /// </returns>
    class function New(const Weight: Double; const Value: string): TPromptMultipart; overload;
  end;

  /// <summary>
  /// Represents a common payload structure for interacting with Stable Diffusion APIs.
  /// </summary>
  /// <remarks>
  /// This class encapsulates common parameters and methods required to generate
  /// images using Stable Diffusion APIs. It supports configurations such as
  /// text prompts, initialization images, sampling methods, and style presets.
  /// The flexible interface allows for detailed customization of the image generation process.
  /// </remarks>
  TPlayloadCommon = class(TMultipartFormData)
    /// <summary>
    /// An array of text prompts to use for generation.
    /// </summary>
    function TextPrompts(const Value: TArray<TPromptMultipart>): TPlayloadCommon;
    /// <summary>
    /// Image used to initialize the diffusion process, in lieu of random noise.
    /// </summary>
    /// <param name="FilePath">
    /// Filename with supported format (jpeg, png, webp)
    /// </param>
    function InitImage(const FilePath: string): TPlayloadCommon; overload;
    /// <summary>
    /// Image used to initialize the diffusion process, in lieu of random noise.
    /// </summary>
    /// <param name="Stream">
    /// The image data in the form of a TStream. The stream must contain the image data in a supported format (e.g., JPEG, PNG, WEBP).
    /// </param>
    /// <param name="StreamFreed">
    /// A boolean value indicating whether the stream should be automatically freed after being processed.
    /// <para>
    /// - Set to <c>True</c> to allow the method to free the stream automatically after reading its contents.
    /// </para>
    /// <para>
    /// - Set to <c>False</c> if you want to manage the lifetime of the stream yourself.
    /// </para>
    /// </param>
    function InitImage(const Stream: TStream; StreamFreed: Boolean = False): TPlayloadCommon; overload;
    /// <summary>
    /// How strictly the diffusion process adheres to the prompt text (higher values keep your image closer to your prompt)
    /// </summary>
    /// <param name="Value">
    /// Number: (CfgScale) [0 .. 35]
    /// <para>
    /// Default: 7
    /// </para>
    /// </param>
    function CfgScale(const Value: Double): TPlayloadCommon;
    /// <summary>
    /// Set the clip guidance preset
    /// </summary>
    /// <param name="Value">
    /// Enum: <c>FAST_BLUE</c>, <c>FAST_GREEN</c>, <c>NONE</c>, <c>SIMPLE</c>, <c>SLOW</c>, <c>SLOWER</c>, <c>SLOWEST</c>
    /// <para>
    /// Default: <c>NONE</c>
    /// </para>
    /// </param>
    function ClipGuidancePreset(const Value: TClipGuidancePresetType): TPlayloadCommon;
    /// <summary>
    /// Number of images to generate
    /// </summary>
    /// <param name="Value">
    /// Integer: [1 .. 10]
    /// <para>
    /// Default: 1
    /// </para>
    /// </param>
    function Sampler(const Value: TSamplerType): TPlayloadCommon;
    /// <summary>
    /// A specific value that is used to guide the 'randomness' of the generation
    /// </summary>
    /// <param name="Value">
    /// number [0 .. 4294967294]  (Default: 0)
    /// </param>
    /// <remarks>
    /// Omit this parameter or pass 0 to use a random seed.
    /// </remarks>
    function Samples(const Value: Integer): TPlayloadCommon;
    /// <summary>
    /// A specific value that is used to guide the 'randomness' of the generation
    /// </summary>
    /// <param name="Value">
    /// number [0 .. 4294967294]  (Default: 0)
    /// </param>
    /// <remarks>
    /// Omit this parameter or pass 0 to use a random seed.
    /// </remarks>
    function Seed(const Value: Int64): TPlayloadCommon;
    /// <summary>
    /// Number of diffusion steps to run.
    /// </summary>
    /// <param name="Value">
    /// Integer: [10 .. 50]
    /// <para>
    /// Default: 30
    /// </para>
    /// </param>
    function Steps(const Value: Integer): TPlayloadCommon;
    /// <summary>
    /// Pass in a style preset to guide the image model towards a particular style.
    /// </summary>
    /// <param name="Value">
    /// Enum: <c>3d-model</c> <c>analog-film</c> <c>anime</c> <c>cinematic</c> <c>comic-book</c> <c>digital-art</c> <c>enhance</c> <c>fantasy-art</c> <c>isometric</c> <c>line-art</c> <c>low-poly</c> <c>modeling-compound</c> <c>neon-punk</c> <c>origami</c> <c>photographic</c> <c>pixel-art</c> <c>tile-texture</c>
    /// </param>
    /// <remarks>
    /// This list of style presets is subject to change.
    /// </remarks>
    function StylePreset(const Value: TStylePreset): TPlayloadCommon;
    /// <summary>
    /// Extra parameters passed to the engine. These parameters are used for in-development or experimental features and may change without warning
    /// </summary>
    /// <param name="Value">
    /// A JSON object
    /// </param>
    /// <remarks>
    /// So please use with caution.
    /// </remarks>
    function Extras(const Value: TJSONObject): TPlayloadCommon;
  end;

  /// <summary>
  /// Represents a payload manager for API prompts used to generate images from existing images using text prompts.
  /// </summary>
  /// <remarks>
  /// This class is designed to facilitate interaction with APIs that generate images based on initial input images and textual prompts.
  /// It supports configuration of strength parameters, such as <c>image_strength</c> or <c>step_schedule</c>, allowing control over how much of the original image is preserved during the generation process.
  /// Use <c>TPayloadPrompt</c> to manage and prepare the necessary parameters, encapsulating them in anonymous methods to be used by other methods interacting with the underlying API.
  /// Note that these APIs only work with Version 1 engines.
  /// </remarks>
  TPayloadPrompt = class(TPlayloadCommon)
    /// <summary>
    /// Whether to use image_strength or step_schedule_* to control how much influence the init_image has on the result.
    /// </summary>
    /// <param name="Value">
    /// Enum: IMAGE_STRENGTH, STEP_SCHEDULE
    /// <para>
    /// Default: IMAGE_STRENGTH
    /// </para>
    /// </param>
    function InitImageMode(const Value: TInitImageMode): TPayloadPrompt;
    /// <summary>
    /// How much influence the init_image has on the diffusion process.
    /// </summary>
    /// <param name="Value">
    /// Number: [0 .. 1]
    /// <para>
    /// Default: 0.35
    /// </para>
    /// </param>
    function ImageStrength(const Value: Double): TPayloadPrompt;
    /// <summary>
    /// Skips a proportion of the start of the diffusion steps, allowing the init_image to influence the final generated image.
    /// </summary>
    /// <param name="Value">
    /// Number: [0 .. 1]
    /// <para>
    /// Default: 0.65
    /// </para>
    /// </param>
    /// <remarks>
    /// Lower values will result in more influence from the init_image, while higher values will result in more influence from the diffusion steps. (e.g. a value of 0 would simply return you the init_image, where a value of 1 would return you a completely different image.)
    /// </remarks>
    function StepScheduleStart(const Value: Double): TPayloadPrompt;
    /// <summary>
    /// Skips a proportion of the end of the diffusion steps, allowing the init_image to influence the final generated image.
    /// </summary>
    /// <param name="Value">
    /// Number: [0 .. 1]
    /// </param>
    /// <remarks>
    /// Lower values will result in more influence from the init_image, while higher values will result in more influence from the diffusion steps.
    /// </remarks>
    function StepScheduleEnd(const Value: Double): TPayloadPrompt;
    constructor Create; reintroduce;
  end;

  /// <summary>
  /// Represents the payload required to manage image modifications using a mask for the image-to-image API.
  /// This class is used to encapsulate and manage the parameters for selectively altering portions of an image.
  /// </summary>
  /// <remarks>
  /// The <c>TPayloadMask</c> class facilitates the creation of payload data, which includes managing image and mask parameters.
  /// It is designed to work with Version 1 engines of the image API and allows the parameters to be provided through anonymous methods to the API interaction functions.
  /// The class abstracts the complexity of setting image parameters, ensuring correct format and consistency, especially when dealing with alpha channels and masked image transformations.
  /// </remarks>
  TPayloadMask = class(TPlayloadCommon)
    /// <summary>
    /// For any given pixel, the mask determines the strength of generation on a linear scale. This parameter determines where to source the mask from
    /// </summary>
    /// <param name="Value">
    /// Enum: <c>MASK_IMAGE_WHITE</c>, <c>MASK_IMAGE_BLACK</c>, <c>INIT_IMAGE_ALPHA</c>
    /// </param>
    /// <remarks>
    /// <para>
    /// - <c>MASK_IMAGE_WHITE</c> will use the white pixels of the mask_image as the mask, where white pixels are completely replaced and black pixels are unchanged
    /// </para>
    /// <para>
    /// - <c>MASK_IMAGE_BLACK</c> will use the black pixels of the mask_image as the mask, where black pixels are completely replaced and white pixels are unchanged
    /// </para>
    /// <para>
    /// - <c>INIT_IMAGE_ALPHA</c> will use the alpha channel of the init_image as the mask, where fully transparent pixels are completely replaced and fully opaque pixels are unchanged
    /// </para>
    /// </remarks>
    function MaskSource(const Value: TMaskSource): TPayloadMask;
    /// <summary>
    /// Optional grayscale mask that allows for influence over which pixels are eligible for diffusion and at what strength. Must be the same dimensions as the init_image. Use the <c>mask_source</c> option to specify whether the white or black pixels should be inpainted.
    /// </summary>
    /// <param name="FilePath">
    /// Filename with supported format (jpeg, png, webp)
    /// </param>
    function MaskImage(const FilePath: string): TPayloadMask; overload;
    /// <summary>
    /// Optional grayscale mask that allows for influence over which pixels are eligible for diffusion and at what strength. Must be the same dimensions as the init_image. Use the <c>mask_source</c> option to specify whether the white or black pixels should be inpainted.
    /// </summary>
    /// <param name="Stream">
    /// The image data in the form of a TStream. The stream must contain the image data in a supported format (e.g., JPEG, PNG, WEBP).
    /// </param>
    /// <param name="StreamFreed">
    /// A boolean value indicating whether the stream should be automatically freed after being processed.
    /// <para>
    /// - Set to <c>True</c> to allow the method to free the stream automatically after reading its contents.
    /// </para>
    /// <para>
    /// - Set to <c>False</c> if you want to manage the lifetime of the stream yourself.
    /// </para>
    /// </param>
    function MaskImage(const Stream: TStream; StreamFreed: Boolean = False): TPayloadMask; overload;
    constructor Create; reintroduce;
  end;

  /// <summary>
  /// Represents an artifact generated by the Stable Diffusion API.
  /// </summary>
  /// <remarks>
  /// This class <c>TJSONArtifact</c> encapsulates information about an artifact, such as its image data encoded in base64,
  /// the reason for the artifact's creation, and the associated seed. Artifacts are typically generated
  /// as the result of image creation processes.
  /// </remarks>
  TJSONArtifact = class
  private
    FBase64: string;
    [JsonReflectAttribute(ctString, rtString, TFinishReasonInterceptor)]
    FFinishReason: TFinishReason;
    FSeed: Int64;
  public
    /// <summary>
    /// A string containing the Base64-encoded image data.
    /// </summary>
    property Base64: string read FBase64 write FBase64;
    /// <summary>
    /// Values can indicate success, an error, or that content was filtered.
    /// <para>
    /// Enum: <c>CONTENT_FILTERED</c>, <c>ERROR</c>, <c>SUCCESS</c>
    /// </para>
    /// </summary>
    property FinishReason: TFinishReason read FFinishReason write FFinishReason;
    /// <summary>
    /// An <c>Int64</c> representing the seed used in the generation process.
    /// </summary>
    /// <remarks>
    /// This seed can be reused to replicate the artifact during image generation.
    /// </remarks>
    property Seed: Int64 read FSeed write FSeed;
  end;

  /// <summary>
  /// Represents an artifact in the Stable Diffusion API system.
  /// </summary>
  /// <remarks>
  /// This class is designed to handle individual artifacts generated by the Stable Diffusion image generation process.
  /// Each artifact typically corresponds to an image that can be encoded in Base64 format.
  /// </remarks>
  TArtifact = class(TJSONArtifact)
  private
    FFileName: string;
  public
    /// <summary>
    /// Retrieves the artifact's image as a stream.
    /// </summary>
    /// <returns>
    /// A <c>TStream</c> containing the decoded image data.
    /// </returns>
    /// <remarks>
    /// Use this method to manipulate the image data programmatically.
    /// </remarks>
    /// <exception cref="Exception">
    /// Raised if the Base64 content is empty.
    /// </exception>
    function GetStream: TStream;
    /// <summary>
    /// Saves the artifact's image to a specified file.
    /// </summary>
    /// <param name="FileName">
    /// The name of the file to save the image to, including its path and extension.
    /// </param>
    /// <remarks>
    /// This method decodes the Base64-encoded image and writes it to a file.
    /// </remarks>
    /// <exception cref="Exception">
    /// Raised if the Base64 content is empty.
    /// </exception>
    procedure SaveToFile(const FileName: string);
    /// <summary>
    /// The filename associated with this artifact.
    /// </summary>
    /// <remarks>
    /// This property holds the name of the file where the artifact's image is saved or will be saved.
    /// </remarks>
    property FileName: string read FFileName;
  end;

  /// <summary>
  /// Represents a collection of artifacts generated by the Stable Diffusion API system.
  /// </summary>
  /// <remarks>
  /// This class encapsulates a list of artifacts, typically corresponding to multiple images generated in a single API request.
  /// Each artifact is represented by a <c>TArtifact</c> instance.
  /// </remarks>
  TJSONArtifacts = class
  private
    FArtifacts: TArray<TArtifact>;
  public
    /// <summary>
    /// Collection of artifacts generated during the image generation process.
    /// </summary>
    /// <remarks>
    /// Access this property to retrieve the individual artifacts.
    /// </remarks>
    property Artifacts: TArray<TArtifact> read FArtifacts write FArtifacts;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a collection of artifacts generated by the Stable Diffusion API.
  /// </summary>
  /// <remarks>
  /// This class encapsulates a set of artifacts, typically representing multiple generated images.
  /// It provides methods to save all artifacts to files and manage their associated metadata, such as file paths and extensions.
  /// </remarks>
  TArtifacts = class(TJSONArtifacts)
  private
    FFilePath: string;
    FExtension: string;
    FFileName: string;
  protected
    function GetFilePath(index: Integer): string;
    procedure SetFilePath(const Value: string);
  public
    /// <summary>
    /// Saves all artifacts in the collection to files.
    /// </summary>
    /// <param name="FileName">
    /// The base filename for saving the artifacts. Files will be named with indexed suffixes if multiple artifacts exist.
    /// </param>
    /// <remarks>
    procedure SaveToFile(const FileName: string);
    /// <summary>
    /// The file path for a specific artifact by index.
    /// </summary>
    /// <param name="index">
    /// The index of the artifact within the collection.
    /// </param>
    /// <returns>
    property FilePath[index: Integer]: string read GetFilePath;
    /// <summary>
    /// The base filename used for saving artifacts.
    /// </summary>
    /// <remarks>
    /// This property holds the name of the base file used when saving artifacts to disk.
    /// </remarks>
    property FileName: string read FFileName;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TArtifacts</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynArtifacts</c> type extends the <c>TAsynParams&lt;TArtifacts&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynArtifacts = TAsynCallBack<TArtifacts>;

  /// <summary>
  /// Represents the primary class for interacting with Version 1 routes of the StabilityAI API.
  /// </summary>
  /// <remarks>
  /// This class provides a set of methods for generating images using Stable Diffusion models.
  /// The supported operations include text-to-image generation, image-to-image modification with prompts, and masked image editing.
  /// It supports both synchronous and asynchronous calls, allowing for flexibility in different application scenarios.
  /// Each method allows parameter customization to control the output, including model selection, prompt definitions, image dimensions, and sampling options.
  /// </remarks>
  TVersion1Route = class(TStabilityAIAPIRoute)
    /// <summary>
    /// VERSION 1: Generate an image from a text prompt.
    /// <para>
    /// NOTE: This method is <c>synchronous</c>
    /// </para>
    /// </summary>
    /// <param name="Model">
    /// Id of the model to use for creation job
    /// <para>
    /// Enum: SDXL 1.0 <c>stable-diffusion-xl-1024-v1-0</c>, SD 1.6 <c>stable-diffusion-v1-6</c>
    /// </para>
    /// </param>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, keywords of what you do not wish to see in the output image, etc.
    /// </param>
    /// <returns>
    /// Returns a <c>TArtifacts</c> object that contains image base-64 generated (image/png).
    /// </returns>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// The <c>TextToImage</c> method sends a image creation request and waits for the full response. The returned <c>TArtifacts</c> object contains the model's generated response, including multiple choices if available.
    /// <code>
    ///   var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    ///   var Image := Stability.Version1.SDXLAndSDL.TextToImage(Model,
    ///     procedure (Params: TPayload)
    ///     begin
    ///       // Move on to the other parameters.
    ///     end);
    ///   var Stream := Image.Artifacts[0].GetStream;
    ///   try
    ///     //--- Save image
    ///     Image.SaveToFile(FileName);
    ///     //--- Display image
    ///     Image1.Picture.LoadFromStream(Stream);
    ///   finally
    ///     Image.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function TextToImage(const Model: string; ParamProc: TProc<TPayload>): TArtifacts; overload;
    /// <summary>
    /// VERSION 1: Generate an image from a text prompt.
    /// <para>
    /// NOTE: This method is <c>asynchronous</c>
    /// </para>
    /// </summary>
    /// <param name="Model">
    /// Id of the model to use for creation job
    /// <para>
    /// Enum: SDXL 1.0 <c>stable-diffusion-xl-1024-v1-0</c>, SD 1.6 <c>stable-diffusion-v1-6</c>
    /// </para>
    /// </param>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, keywords of what you do not wish to see in the output image, the the format of the output image, etc.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for asynchronous image creation, such as <c>onSuccess</c> and <c>onError</c>.
    /// </param>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// This procedure initiates an asynchronous request to generate an image creation based on the provided parameters. The response or error is handled by the provided callBacks.
    /// <code>
    /// // WARNING - Move the following line to the main OnCreate method for maximum scope.
    /// // var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    /// Stability.Version1.SDXLAndSDL.TextToImage(Model,
    ///   procedure (Params: TPayload)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynArtifacts
    ///   begin
    ///     Result.Sender := Image1;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Image: TArtifacts)
    ///       begin
    ///         // Handle success operation
    ///       end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle error message
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure TextToImage(const Model: string; ParamProc: TProc<TPayload>;
      CallBacks: TFunc<TAsynArtifacts>); overload;
    /// <summary>
    /// VERSION 1: Produce an image from an existing image using a text prompt.
    /// <para>
    /// NOTE: This method is <c>synchronous</c>
    /// </para>
    /// </summary>
    /// <param name="Model">
    /// Id of the model to use for creation job
    /// <para>
    /// Enum: SDXL 1.0 <c>stable-diffusion-xl-1024-v1-0</c>, SD 1.6 <c>stable-diffusion-v1-6</c>
    /// </para>
    /// </param>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, keywords of what you do not wish to see in the output image, etc.
    /// </param>
    /// <returns>
    /// Returns a <c>TArtifacts</c> object that contains image base-64 generated (image/png).
    /// </returns>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// The <c>ImageToImageWithPrompt</c> method sends a image creation request and waits for the full response. The returned <c>TArtifacts</c> object contains the model's generated response, including multiple choices if available.
    /// <code>
    ///   var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    ///   var Image := Stability.Version1.SDXLAndSDL.ImageToImageWithPrompt(Model,
    ///     procedure (Params: TPayloadPrompt)
    ///     begin
    ///       // Move on to the other parameters.
    ///     end);
    ///   var Stream := Image.Artifacts[0].GetStream;
    ///   try
    ///     //--- Save image
    ///     Image.SaveToFile(FileName);
    ///     //--- Display image
    ///     Image1.Picture.LoadFromStream(Stream);
    ///   finally
    ///     Image.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function ImageToImageWithPrompt(const Model: string; ParamProc: TProc<TPayloadPrompt>): TArtifacts; overload;
    /// <summary>
    /// VERSION 1: Produce an image from an existing image using a text prompt.
    /// <para>
    /// NOTE: This method is <c>asynchronous</c>
    /// </para>
    /// </summary>
    /// <param name="Model">
    /// Id of the model to use for creation job
    /// <para>
    /// Enum: SDXL 1.0 <c>stable-diffusion-xl-1024-v1-0</c>, SD 1.6 <c>stable-diffusion-v1-6</c>
    /// </para>
    /// </param>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, keywords of what you do not wish to see in the output image, the the format of the output image, etc.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for asynchronous image creation, such as <c>onSuccess</c> and <c>onError</c>.
    /// </param>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// This procedure initiates an asynchronous request to generate an image creation based on the provided parameters. The response or error is handled by the provided callBacks.
    /// <code>
    /// // WARNING - Move the following line to the main OnCreate method for maximum scope.
    /// // var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    /// Stability.Version1.SDXLAndSDL.ImageToImageWithPrompt(Model,
    ///   procedure (Params: TPayloadPrompt)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynArtifacts
    ///   begin
    ///     Result.Sender := Image1;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Image: TArtifacts)
    ///       begin
    ///         // Handle success operation
    ///       end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle error message
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure ImageToImageWithPrompt(const Model: string; ParamProc: TProc<TPayloadPrompt>;
      CallBacks: TFunc<TAsynArtifacts>); overload;
    /// <summary>
    /// VERSION 1: Selectively modify portions of an image using a <c>mask</c>. The mask must be the same shape and size as the init <c>image</c>. This endpoint also supports image parameters with alpha channels. See below for more details.
    /// <para>
    /// NOTE: This method is <c>synchronous</c>
    /// </para>
    /// </summary>
    /// <param name="Model">
    /// Id of the model to use for creation job
    /// <para>
    /// Enum: SDXL 1.0 <c>stable-diffusion-xl-1024-v1-0</c>, SD 1.6 <c>stable-diffusion-v1-6</c>
    /// </para>
    /// </param>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, keywords of what you do not wish to see in the output image, etc.
    /// </param>
    /// <returns>
    /// Returns a <c>TArtifacts</c> object that contains image base-64 generated (image/png).
    /// </returns>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// The <c>ImageToImageWithMask</c> method sends a image creation request and waits for the full response. The returned <c>TArtifacts</c> object contains the model's generated response, including multiple choices if available.
    /// <code>
    ///   var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    ///   var Image := Stability.Version1.SDXLAndSDL.ImageToImageWithMask(Model,
    ///     procedure (Params: TPayloadMask)
    ///     begin
    ///       // Move on to the other parameters.
    ///     end);
    ///   var Stream := Image.Artifacts[0].GetStream;
    ///   try
    ///     //--- Save image
    ///     Image.SaveToFile(FileName);
    ///     //--- Display image
    ///     Image1.Picture.LoadFromStream(Stream);
    ///   finally
    ///     Image.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function ImageToImageWithMask(const Model: string; ParamProc: TProc<TPayloadMask>): TArtifacts; overload;
    /// <summary>
    /// VERSION 1: Selectively modify portions of an image using a <c>mask</c>. The mask must be the same shape and size as the init <c>image</c>. This endpoint also supports image parameters with alpha channels. See below for more details.
    /// <para>
    /// NOTE: This method is <c>asynchronous</c>
    /// </para>
    /// </summary>
    /// <param name="Model">
    /// Id of the model to use for creation job
    /// <para>
    /// Enum: SDXL 1.0 <c>stable-diffusion-xl-1024-v1-0</c>, SD 1.6 <c>stable-diffusion-v1-6</c>
    /// </para>
    /// </param>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, keywords of what you do not wish to see in the output image, the the format of the output image, etc.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for asynchronous image creation, such as <c>onSuccess</c> and <c>onError</c>.
    /// </param>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// This procedure initiates an asynchronous request to generate an image creation based on the provided parameters. The response or error is handled by the provided callBacks.
    /// <code>
    /// // WARNING - Move the following line to the main OnCreate method for maximum scope.
    /// // var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    /// Stability.Version1.SDXLAndSDL.ImageToImageWithMask(Model,
    ///   procedure (Params: TPayloadMask)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynArtifacts
    ///   begin
    ///     Result.Sender := Image1;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Image: TArtifacts)
    ///       begin
    ///         // Handle success operation
    ///       end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle error message
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure ImageToImageWithMask(const Model: string; ParamProc: TProc<TPayloadMask>;
      CallBacks: TFunc<TAsynArtifacts>); overload;
  end;

implementation

uses
  System.IOUtils, StabilityAI.Consts, StabilityAI.NetEncoding.Base64;

{ TClipGuidancePresetTypeHelper }

function TClipGuidancePresetTypeHelper.ToString: string;
begin
  case Self of
    FAST_BLUE:
      Exit('FAST_BLUE');
    FAST_GREEN:
      Exit('FAST_GREEN');
    NONE:
      Exit('NONE');
    SIMPLE:
      Exit('SIMPLE');
    SLOW:
      Exit('SLOW');
    SLOWER:
      Exit('SLOWER');
    SLOWEST:
      Exit('SLOWEST');
  end;
end;

{ TSamplerTypeHelper }

function TSamplerTypeHelper.ToString: string;
begin
  case Self of
    DDIM:
      Exit('DDIM');
    DDPM:
      Exit('DDPM');
    K_DPMPP_2M:
      Exit('K_DPMPP_2M');
    K_DPMPP_2S_ANCESTRAL:
      Exit('K_DPMPP_2S_ANCESTRAL');
    K_DPM_2:
      Exit('K_DPM_2');
    K_DPM_2_ANCESTRAL:
      Exit('K_DPM_2_ANCESTRAL');
    K_EULER:
      Exit('K_EULER');
    K_EULER_ANCESTRAL:
      Exit('K_EULER_ANCESTRAL');
    K_HEUN:
      Exit('K_HEUN');
    K_LMS:
      Exit('K_LMS');
  end;
end;

{ TPrompt }

class function TPrompt.New(const Value: string): TPrompt;
begin
  Result := TPrompt.Create.Text(Value);
end;

class function TPrompt.New(const Weight: Double;
  const Value: string): TPrompt;
begin
  Result := New(Value).Weight(Weight);
end;

function TPrompt.Text(const Value: string): TPrompt;
begin
  Result := TPrompt(Add(Check('text', Value, 2000), Value));
end;

function TPrompt.Weight(const Value: Double): TPrompt;
begin
  Result := TPrompt(Add('weight', Value));
end;

{ TPayload }

function TPayload.CfgScale(const Value: Double): TPayload;
begin
  Result := TPayload(Add('cfg_scale', CheckFloat(Value, 0.0, 35.0)));
end;

function TPayload.ClipGuidancePreset(
  const Value: TClipGuidancePresetType): TPayload;
begin
  Result := TPayload(Add('clip_guidance_preset', Value.ToString));
end;

function TPayload.Extras(const Value: TJSONObject): TPayload;
begin
  Result := TPayload(Add('extras', Value));
end;

function TPayload.Height(const Value: Integer): TPayload;
begin
  Result := TPayload(Add('height', CheckMultipleOf(Value, 128, 64)));
end;

function TPayload.Sampler(const Value: TSamplerType): TPayload;
begin
  Result := TPayload(Add('sampler', Value.ToString));
end;

function TPayload.Samples(const Value: Integer): TPayload;
begin
  Result := TPayload(Add('samples', CheckInteger(Value, 1, 10)));
end;

function TPayload.Seed(const Value: Int64): TPayload;
begin
  Result := TPayload(Add('seed', CheckInteger(Value, 0, SeedMax)));
end;

function TPayload.Steps(const Value: Integer): TPayload;
begin
  Result := TPayload(Add('steps', CheckInteger(Value, 10, 50)));
end;

function TPayload.StylePreset(const Value: TStylePreset): TPayload;
begin
  Result := TPayload(Add('style_preset', Value.ToString));
end;

function TPayload.TextPrompts(const Value: TArray<TPrompt>): TPayload;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TPayload(Add('text_prompts', JSONArray));
end;

function TPayload.Width(const Value: Integer): TPayload;
begin
  Result := TPayload(Add('width', CheckMultipleOf(Value, 128, 64)));
end;

{ TArtifact }

function TArtifact.GetStream: TStream;
begin
  {--- Create a memory stream to write the decoded content. }
  Result := TMemoryStream.Create;
  try
    {--- Convert the base-64 string directly into the memory stream. }
    if not Base64.IsEmpty then
      DecodeBase64ToStream(Base64, Result)
    else
      raise Exception.Create(StreamEmptyExceptionMessage);
  except
    Result.Free;
    raise;
  end;
end;

procedure TArtifact.SaveToFile(const FileName: string);
begin
  try
    Self.FFileName := FileName;

    {--- Perform the decoding operation and save it into the file specified by the FileName parameter. }
    if not Base64.IsEmpty then
      DecodeBase64ToFile(Base64, FileName)
    else
      raise Exception.Create(DataFileEmptyExceptionMessage);
  except
    raise;
  end;
end;

{ TVersion1Route }

procedure TVersion1Route.ImageToImageWithMask(const Model: string; ParamProc: TProc<TPayloadMask>;
  CallBacks: TFunc<TAsynArtifacts>);
begin
  with TAsynCallBackExec<TAsynArtifacts, TArtifacts>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TArtifacts
      begin
        Result := Self.ImageToImageWithMask(Model, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TVersion1Route.ImageToImageWithPrompt(const Model: string;
  ParamProc: TProc<TPayloadPrompt>;
  CallBacks: TFunc<TAsynArtifacts>);
begin
  with TAsynCallBackExec<TAsynArtifacts, TArtifacts>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TArtifacts
      begin
        Result := Self.ImageToImageWithPrompt(Model, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TVersion1Route.TextToImage(const Model: string;
  ParamProc: TProc<TPayload>; CallBacks: TFunc<TAsynArtifacts>);
begin
  with TAsynCallBackExec<TAsynArtifacts, TArtifacts>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TArtifacts
      begin
        Result := Self.TextToImage(Model, ParamProc);
      end);
  finally
    Free;
  end;
end;

function TVersion1Route.ImageToImageWithMask(const Model: string;
  ParamProc: TProc<TPayloadMask>): TArtifacts;
begin
  Result := API.PostForm<TArtifacts, TPayloadMask>(Format('v1/generation/%s/image-to-image/masking', [Model]), ParamProc);
end;

function TVersion1Route.ImageToImageWithPrompt(const Model: string;
  ParamProc: TProc<TPayloadPrompt>): TArtifacts;
begin
  Result := API.PostForm<TArtifacts, TPayloadPrompt>(Format('v1/generation/%s/image-to-image', [Model]), ParamProc);
end;

function TVersion1Route.TextToImage(const Model: string;
  ParamProc: TProc<TPayload>): TArtifacts;
begin
  Result := API.Post<TArtifacts, TPayload>(Format('v1/generation/%s/text-to-image', [Model]), ParamProc);
end;

{ TArtifacts }

function TArtifacts.GetFilePath(index: Integer): string;
begin
  if FFilePath.IsEmpty then
    raise Exception.Create(FileNameNotNullExceptionMessage);
  Result := Format('%s%s%s', [FFilePath, index.ToString.PadLeft(2, '0'), FExtension]);
end;

procedure TArtifacts.SaveToFile(const FileName: string);
begin
  {--- Save data to files, indexing them as necessary, for each artifact. }
  SetFilePath(FileName);
  var index := 0;
  for var Item in Artifacts do
    begin
      if index = 0 then
        Item.SaveToFile(FileName) else
        Item.SaveToFile(FilePath[index]);
      Inc(index);
    end;
end;

procedure TArtifacts.SetFilePath(const Value: string);
begin
  FFileName := Value;
  FExtension := ExtractFileExt(Value);
  FFilePath := TPath.ChangeExtension(Value, '');
  FFilePath := FFilePath.Substring(0, FFilePath.Length-1);
end;

{ TPayloadPrompt }

constructor TPayloadPrompt.Create;
begin
  inherited Create(True);
end;

function TPayloadPrompt.ImageStrength(
  const Value: Double): TPayloadPrompt;
begin
  AddField(CheckFloat('image_strength', Value, 0, 1), Value.ToString);
  Result := Self;
end;

function TPayloadPrompt.InitImageMode(
  const Value: TInitImageMode): TPayloadPrompt;
begin
  AddField('init_image_mode', Value.ToString);
  Result := Self;
end;

function TPayloadPrompt.StepScheduleEnd(
  const Value: Double): TPayloadPrompt;
begin
  AddField(CheckFloat('step_schedule_end', Value, 0, 1), Value.ToString);
  Result := Self;
end;

function TPayloadPrompt.StepScheduleStart(
  const Value: Double): TPayloadPrompt;
begin
  AddField(CheckFloat('step_schedule_start', Value, 0, 1), Value.ToString);
  Result := Self;
end;

{ TJSONArtifacts }

destructor TJSONArtifacts.Destroy;
begin
  for var Item in FArtifacts do
    Item.Free;
  inherited;
end;

{ TPromptMultipart }

class function TPromptMultipart.New(const Text: string): TPromptMultipart;
begin
  Result := TPromptMultipart.Create;
  Result.Text := Text;
end;

class function TPromptMultipart.New(const Weight: Double;
  const Value: string): TPromptMultipart;
begin
  Result := New(Value);
  Result.Weight := Weight;
end;

{ TInitImageModeHelper }

function TInitImageModeHelper.ToString: string;
begin
  case Self of
    IMAGE_STRENGTH:
      Exit('IMAGE_STRENGTH');
    STEP_SCHEDULE:
      Exit('STEP_SCHEDULE');
  end;
end;

{ TMaskSourceHelper }

function TMaskSourceHelper.ToString: string;
begin
  case Self of
    MASK_IMAGE_WHITE:
      Exit('MASK_IMAGE_WHITE');
    MASK_IMAGE_BLACK:
      Exit('MASK_IMAGE_BLACK');
    INIT_IMAGE_ALPHA:
      Exit('INIT_IMAGE_ALPHA');
  end;
end;

{ TPayloadMask }

constructor TPayloadMask.Create;
begin
  inherited Create(True);
end;

function TPayloadMask.MaskImage(const FilePath: string): TPayloadMask;
begin
  AddBytes('mask_image', FileToBytes(FilePath), FilePath);
  Result := Self;
end;

function TPayloadMask.MaskImage(const Stream: TStream;
  StreamFreed: Boolean): TPayloadMask;
begin
  if StreamFreed then
    {--- The stream's content is automatically freed. }
    AddStream('mask_image', Stream, True, 'FileNameForHeader.png')
  else
    {--- You should release the stream's content. }
    AddBytes('mask_image', StreamToBytes(Stream), 'FileNameForHeader.png');
  Result := Self;
end;

function TPayloadMask.MaskSource(const Value: TMaskSource): TPayloadMask;
begin
  AddField('mask_source', Value.ToString);
  Result := Self;
end;

{ TPlayloadCommon }

function TPlayloadCommon.CfgScale(const Value: Double): TPlayloadCommon;
begin
  AddField(CheckFloat('cfg_scale', Value, 0, 35), Value.ToString);
  Result := Self;
end;

function TPlayloadCommon.ClipGuidancePreset(
  const Value: TClipGuidancePresetType): TPlayloadCommon;
begin
  AddField('clip_guidance_preset', Value.ToString);
  Result := Self;
end;

function TPlayloadCommon.Extras(const Value: TJSONObject): TPlayloadCommon;
begin
  AddField('extras', Value.ToString);
  Result := Self;
end;

function TPlayloadCommon.InitImage(const FilePath: string): TPlayloadCommon;
begin
  AddBytes('init_image', FileToBytes(FilePath), FilePath);
  Result := Self;
end;

function TPlayloadCommon.InitImage(const Stream: TStream;
  StreamFreed: Boolean): TPlayloadCommon;
begin
  if StreamFreed then
    {--- The stream's content is automatically freed. }
    AddStream('init_image', Stream, True, 'FileNameForHeader.png')
  else
    {--- You should release the stream's content. }
    AddBytes('init_image', StreamToBytes(Stream), 'FileNameForHeader.png');
  Result := Self;
end;

function TPlayloadCommon.Sampler(const Value: TSamplerType): TPlayloadCommon;
begin
  AddField('sampler', Value.ToString);
  Result := Self;
end;

function TPlayloadCommon.Samples(const Value: Integer): TPlayloadCommon;
begin
  AddField(CheckInteger('samples', Value, 1, 10), Value.ToString);
  Result := Self;
end;

function TPlayloadCommon.Seed(const Value: Int64): TPlayloadCommon;
begin
  AddField(CheckInteger('seed', Value, 0, SeedMax), Value.ToString);
  Result := Self;
end;

function TPlayloadCommon.Steps(const Value: Integer): TPlayloadCommon;
begin
  AddField(CheckInteger('steps', Value, 10, 50), Value.ToString);
  Result := Self;
end;

function TPlayloadCommon.StylePreset(
  const Value: TStylePreset): TPlayloadCommon;
begin
  AddField('style_preset', Value.ToString);
  Result := Self;
end;

function TPlayloadCommon.TextPrompts(
  const Value: TArray<TPromptMultipart>): TPlayloadCommon;
begin
  var index := 0;
  for var Item in Value do
    begin
      AddField(Format('text_prompts[%d][text]', [index]), Item.Text);
      AddField(Format('text_prompts[%d][weight]', [index]), Item.Weight.ToString);
      Item.Free;
      Inc(Index);
    end;
  Result := Self;
end;

end.

unit StabilityAI.Version1.User;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiStabilityAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Net.Mime, REST.JsonReflect, System.JSON,
  REST.Json.Types, StabilityAI.API, StabilityAI.API.Params, StabilityAI.Async.Support;

type
  /// <summary>
  /// Represents an organization associated with a user in the StabilityAI API.
  /// </summary>
  /// <remarks>
  /// This class encapsulates information about an organization, including its ID, name, role,
  /// and whether it is the default organization for the user.
  /// </remarks>
  TOrganization = class
  private
    FId: string;
    FName: string;
    FRole: string;
    [JsonNameAttribute('is_default')]
    FIsDefault: Boolean;
  public
    /// <summary>
    /// The organization's ID
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// The organization's name
    /// </summary>
    property Name: string read FName write FName;
    /// <summary>
    /// The organization's role
    /// </summary>
    property Role: string read FRole write FRole;
    /// <summary>
    /// True: if is the default organization
    /// </summary>
    property IsDefault: Boolean read FIsDefault write FIsDefault;
  end;

  /// <summary>
  /// Represents the details of a user's account in the StabilityAI API.
  /// </summary>
  /// <remarks>
  /// This class provides access to user-related information such as the user's unique ID,
  /// email, associated organizations, and profile picture.
  /// </remarks>
  TAccountDetails = class
  private
    FId: string;
    FEmail: string;
    FOrganizations: TArray<TOrganization>;
    [JsonNameAttribute('profile_picture')]
    FProfilePicture: string;
  public
    /// <summary>
    /// The user's ID
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// The user's email
    /// </summary>
    property Email: string read FEmail write FEmail;
    /// <summary>
    /// The user's organizations
    /// </summary>
    property Organizations: TArray<TOrganization> read FOrganizations write FOrganizations;
    /// <summary>
    /// The user's profile picture
    /// </summary>
    property ProfilePicture: string read FProfilePicture write FProfilePicture;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents the account balance associated with the API key in the StabilityAI system.
  /// </summary>
  /// <remarks>
  /// This class provides information about the available credits in the user's account or organization.
  /// </remarks>
  TAccountBalance = class
  private
    FCredits: Double;
  public
    /// <summary>
    /// The balance of the account/organization associated with the API key
    /// </summary>
    property Credits: Double read FCredits write FCredits;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TAccountDetails</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynAccountDetails</c> type extends the <c>TAsynParams&lt;TAccountDetails&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynAccountDetails = TAsynCallBack<TAccountDetails>;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TAccountBalance</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynAccountBalance</c> type extends the <c>TAsynParams&lt;TAccountBalance&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynAccountBalance = TAsynCallBack<TAccountBalance>;

  /// <summary>
  /// Provides methods to interact with user-related endpoints of the StabilityAI API.
  /// </summary>
  /// <remarks>
  /// This class offers synchronous and asynchronous methods for retrieving account details
  /// and account balance information associated with the provided API key. It is designed
  /// for both blocking and non-blocking workflows, making it suitable for various application requirements.
  /// </remarks>
  TUserRoute = class(TStabilityAIAPIRoute)
    /// <summary>
    /// Get information about the account associated with the provided API key
    /// <para>
    /// NOTE: This method is <c>synchronous</c>
    /// </para>
    /// </summary>
    /// <returns>
    /// Returns a <c>TAccountDetails</c> object that contains account informations.
    /// </returns>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    ///   var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    ///   var Data := Stability.Version1.User.AccountDetails;
    ///   try
    ///     for var Itel in Data.Result do
    ///       //display details account informations
    ///   finally
    ///     Data.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function AccountDetails: TAccountDetails; overload;
    /// <summary>
    /// Get information about the account associated with the provided API key
    /// <para>
    /// NOTE: This method is <c>asynchronous</c>
    /// </para>
    /// </summary>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for asynchronous image creation, such as <c>onSuccess</c> and <c>onError</c>.
    /// </param>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line to the main OnCreate method for maximum scope.
    /// // var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    /// Stability.Version1.User.AccountDetails(
    ///   function : TAsynAccountDetails
    ///   begin
    ///     Result.Sender := my_obj;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Data: TAccountDetails)
    ///       begin
    ///         // Handle success operation
    ///       end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle error message
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AccountDetails(CallBacks: TFunc<TAsynAccountDetails>); overload;
    /// <summary>
    /// Get the credit balance of the account/organization associated with the API key
    /// <para>
    /// NOTE: This method is <c>synchronous</c>
    /// </para>
    /// </summary>
    /// <returns>
    /// Returns a <c>TAccountBalance</c> object that contains balance information.
    /// </returns>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    ///   var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    ///   var Data := Stability.Version1.User.AccountBalance;
    ///   try
    ///     //display balanceinformation
    ///   finally
    ///     Data.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function AccountBalance: TAccountBalance; overload;
    /// <summary>
    /// Get the credit balance of the account/organization associated with the API key
    /// <para>
    /// NOTE: This method is <c>asynchronous</c>
    /// </para>
    /// </summary>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for asynchronous image creation, such as <c>onSuccess</c> and <c>onError</c>.
    /// </param>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line to the main OnCreate method for maximum scope.
    /// // var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    /// Stability.Version1.User.AccountBalance(
    ///   function : TAsynAccountBalance
    ///   begin
    ///     Result.Sender := my_obj;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Data: TAccountBalance)
    ///       begin
    ///         // Handle success operation
    ///       end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle error message
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AccountBalance(CallBacks: TFunc<TAsynAccountBalance>); overload;
  end;

implementation

uses
  Rest.Json;

{ TAccountDetails }

destructor TAccountDetails.Destroy;
begin
  for var Item in FOrganizations do
    Item.Free;
  inherited;
end;

{ TUserRoute }

function TUserRoute.AccountBalance: TAccountBalance;
begin
  Result := API.Get<TAccountBalance>('v1/user/balance');
end;

procedure TUserRoute.AccountBalance(CallBacks: TFunc<TAsynAccountBalance>);
begin
  with TAsynCallBackExec<TAsynAccountBalance, TAccountBalance>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TAccountBalance
      begin
        Result := Self.AccountBalance;
      end);
  finally
    Free;
  end;
end;

function TUserRoute.AccountDetails: TAccountDetails;
begin
  Result := API.Get<TAccountDetails>('v1/user/account');
end;

procedure TUserRoute.AccountDetails(CallBacks: TFunc<TAsynAccountDetails>);
begin
  with TAsynCallBackExec<TAsynAccountDetails, TAccountDetails>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TAccountDetails
      begin
        Result := Self.AccountDetails;
      end);
  finally
    Free;
  end;
end;

end.

unit StabilityAI.VideoAnd3D.Stable3D;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiStabilityAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Net.Mime, REST.JsonReflect, System.JSON,
  REST.Json.Types, StabilityAI.API, StabilityAI.Types, StabilityAI.Async.Support;

type
  /// <summary>
  /// <c>TStable3D</c> is a class that manages parameters for generating high-quality 3D assets from a single 2D input image.
  /// This class acts as a configuration layer, simplifying interaction with the Stable Fast 3D APIs.
  /// </summary>
  /// <remarks>
  /// The <c>TStable3D</c> class is designed to handle the setup of parameters required for invoking the API methods.
  /// It encapsulates these parameters and provides them as anonymous methods to ensure seamless integration
  /// with functions that leverage the Stable Fast 3D API. This approach enhances reusability and abstracts
  /// the complexity involved in preparing the input data, making it easier to adapt and extend the model generation pipeline.
  /// </remarks>
  TStable3D = class(TMultipartFormData)
    /// <summary>
    /// The image to generate a 3D model from.
    /// </summary>
    /// <param name="FilePath">
    /// Filename with supported format (jpeg, png, webp)
    /// </param>
    /// <returns>
    /// The updated <c>TStableImageUltra</c> instance.
    /// </returns>
    /// <remarks>
    /// <para>
    /// - Every side must be at least 64 pixels
    /// </para>
    /// <para>
    /// - Total pixel count must be between 4,096 and 4,194,304 pixels
    /// </para>
    /// </remarks>
    function Image(const FilePath: string): TStable3D; overload;
    /// <summary>
    /// The image to generate a 3D model from.
    /// </summary>
    /// <param name="Stream">
    /// The image data in the form of a TStream. The stream must contain the image data in a supported format (e.g., JPEG, PNG, WEBP).
    /// </param>
    /// <param name="StreamFreed">
    /// A boolean value indicating whether the stream should be automatically freed after being processed.
    /// <para>
    /// - Set to <c>True</c> to allow the method to free the stream automatically after reading its contents.
    /// </para>
    /// <para>
    /// - Set to <c>False</c> if you want to manage the lifetime of the stream yourself.
    /// </para>
    /// </param>
    /// <remarks>
    /// <para>
    /// This method is useful when you already have image data in memory, as opposed to working with a file directly.
    /// </para>
    /// <para>
    /// - The image dimensions must meet the following criteria:
    ///   - Every side must be at least 64 pixels
    ///   - Total pixel count must be between 4,096 and 4,194,304 pixels
    /// </para>
    /// <para>
    /// - A strength parameter is required when an image is provided for editing.
    /// </para>
    /// </remarks>
    /// <exception cref="Exception">
    /// Throws an exception if the stream is invalid or its contents do not represent a valid image in a supported format.
    /// </exception>
    function Image(const Stream: TStream; StreamFreed: Boolean = False): TStable3D; overload;
    /// <summary>
    /// Determines the resolution of the textures used for both the albedo (color) map and the normal map.
    /// </summary>
    /// <param name="Value">
    /// Enum: 1024, 2048, 512 (Default: 1024)
    /// </param>
    /// <remarks>
    /// The resolution is specified in pixels, and a higher value corresponds to a higher level of detail in the textures, allowing for more intricate and precise rendering of surfaces. However, increasing the resolution also results in larger asset sizes, which may impact loading times and performance. 1024 is a good default value and rarely requires changing.
    /// </remarks>
    function TextureResolution(const Value: TTextureResolutionType): TStable3D;
    /// <summary>
    /// Controls the amount of padding around the object to be processed within the frame.
    /// </summary>
    /// <param name="Value">
    /// Number: [0.1 .. 1] (Default: 0.85)
    /// </param>
    /// <remarks>
    /// This ratio determines the relative size of the object compared to the total frame size. A higher ratio means less padding and a larger object, while a lower ratio increases the padding, effectively reducing the objectâs size within the frame. This can be useful when a long and narrow object, such as a car or bus, is viewed from the front (the narrow side). Here, lowering the foreground ratio might help prevent the generated 3D assets from appearing squished or distorted. The default value of 0.85 is good for most objects.
    /// </remarks>
    function ForegroundRatio(const Value: Double): TStable3D;
    /// <summary>
    /// Controls the remeshing algorithm used to generate the 3D model.
    /// </summary>
    /// <param name="Value">
    /// Enum: <c>none</c>, <c>quad</c>, <c>triangle</c>  (Default: <c>none</c>)
    /// </param>
    /// <remarks>
    /// The remeshing algorithm determines how the 3D model is constructed from the input image. The default value of "none" means that the model is generated without remeshing, which is suitable for most use cases. The "triangle" option generates a model with triangular faces, while the "quad" option generates a model with quadrilateral faces. The "quad" option is useful when the 3D model will be used in DCC tools such as Maya or Blender.
    /// </remarks>
    function Remesh(const Value: TRemeshType): TStable3D;
    /// <summary>
    /// If specified, the result will have approximately this many vertices (and consequently fewer faces) in the simplified mesh.
    /// </summary>
    /// <param name="paramname">
    /// Number: [-1 .. 20000] (Default: -1)
    /// </param>
    /// <remarks>
    /// Setting this value to -1 (the default value) means that a limit is not set.
    /// </remarks>
    function VertexCount(const Value: Double): TStable3D;
    constructor Create; reintroduce;
  end;

  /// <summary>
  /// The <c>TModel3D</c> class represents a 3D model generated using the Stable3D API.
  /// </summary>
  /// <remarks>
  /// <para>
  /// This class extends <c>TModelDataReturned</c> to include additional methods and properties specifically tailored for managing and interacting with 3D models.
  /// </para>
  /// <para>
  /// The <c>TModel3D</c> class provides functionality to save the generated 3D model to a file and retrieve its file name.
  /// It decodes base64-encoded data and ensures the resulting file is compatible with common 3D formats such as GLTF.
  /// </para>
  /// </remarks>
  TModel3D = class(TModelDataReturned)
  private
    FFileName: string;
  public
    /// <summary>
    /// Saves the generated 3D object to a file.
    /// </summary>
    /// <param name="FileName">
    /// The path to the file where the 3D model will be saved.
    /// </param>
    /// <remarks>
    /// This method decodes the base64 encoded data and saves it to the specified file.
    /// </remarks>
    /// <exception cref="Exception">
    /// Throws an exception if the image or video data cannot be decoded or saved.
    /// </exception>
    function SaveToFile(const FileName: string): string;
    /// <summary>
    /// Gets the name of the file where the 3D model was saved.
    /// </summary>
    /// <value>
    /// The path to the file as a string.
    /// </value>
    /// <remarks>
    /// This property contains the file name specified in the last call to <c>SaveToFile</c>.
    /// </remarks>
    property FileName: string read FFileName;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TAsynParams&lt;TModel3D&gt;</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynModel3D</c> type extends the <c>TModel3D</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynModel3D = TAsynCallBack<TModel3D>;

  /// <summary>
  /// The <c>TModel3DRoute</c> class is a specialized API route class designed for interacting with Stable Fast 3D APIs.
  /// </summary>
  /// <remarks>
  /// <para>
  /// This class provides methods to generate high-quality 3D assets from single 2D input images. It supports both synchronous
  /// and asynchronous operations, allowing seamless integration into applications that require either immediate results or
  /// non-blocking execution.
  /// </para>
  /// <para>
  /// The synchronous <c>Fast3D</c> method processes the 2D input and directly returns a 3D model.
  /// For asynchronous use cases, an overload of the <c>Fast3D</c> method accepts callback functions to handle
  /// success, error, and start events, enabling efficient handling of long-running operations.
  /// </para>
  /// <para>
  /// The generated 3D models are returned as glTF assets in binary format, including the required buffers, images, and JSON.
  /// These outputs are compatible with modern 3D modeling tools and workflows.
  /// </para>
  /// </remarks>
  TModel3DRoute = class(TStabilityAIAPIRoute)
    /// <summary>
    /// Stable Fast 3D generates high-quality 3D assets from a single 2D input image.
    /// <para>
    /// The output is a binary blob that includes a glTF asset, including JSON, buffers, and images.
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as image, the mask, the seed, the the format of the output image.
    /// </param>
    /// <returns>
    /// Returns a <c>TModel3D</c> object that contains 3D model base-64 generated.
    /// <para>
    /// - model/gltf-binary
    /// </para>
    /// </returns>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    ///   var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    ///   var Data := Stability.VideoAnd3D.Model3D.Fast3D(
    ///     procedure (Params: TStable3D)
    ///     begin
    ///       // Define parameters.
    ///     end);
    ///   var Stream := Data.GetStream;
    ///   try
    ///     //--- Save 3d model as .gLTF file
    ///     Data.SaveToFile(FileName);
    ///   finally
    ///     Data.Free;
    ///     Stream.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Fast3D(ParamProc: TProc<TStable3D>): TModel3D; overload;
    /// <summary>
    /// Stable Fast 3D generates high-quality 3D assets from a single 2D input image.
    /// <para>
    /// NOTE: This method is <c>asynchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as image, the the format of the output image etc.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for asynchronous image creation, such as <c>onSuccess</c> and <c>onError</c>.
    /// </param>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line to the main OnCreate method for maximum scope.
    /// // var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    /// Stability.VideoAnd3D.Model3D.Fast3D(
    ///   procedure (Params: TStable3D)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynModel3D
    ///   begin
    ///     Result.Sender := Image1;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Data: TModel3D)
    ///       begin
    ///         // Handle success operation
    ///         //--- Save 3d model as .gLTF file
    ///       end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle error message
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure Fast3D(ParamProc: TProc<TStable3D>; CallBacks: TFunc<TAsynModel3D>); overload;
  end;

implementation

uses
  StabilityAI.NetEncoding.Base64, StabilityAI.Consts, StabilityAI.Common;

{ TStable3D }

constructor TStable3D.Create;
begin
  inherited Create(True);
end;

function TStable3D.ForegroundRatio(const Value: Double): TStable3D;
begin
  AddField(CheckFloat('foreground_ratio', Value, 0.1, 1), Value.ToString);
  Result := Self;
end;

function TStable3D.Image(const FilePath: string): TStable3D;
begin
  AddBytes('image', FileToBytes(FilePath), FilePath);
  Result := Self;
end;

function TStable3D.Image(const Stream: TStream;
  StreamFreed: Boolean): TStable3D;
begin
  if StreamFreed then
    {--- The stream's content is automatically freed. }
    AddStream('image', Stream, True, 'FileNameForHeader.png')
  else
    {--- You should release the stream's content. }
    AddBytes('image', StreamToBytes(Stream), 'FileNameForHeader.png');
  Result := Self;
end;

function TStable3D.Remesh(const Value: TRemeshType): TStable3D;
begin
  AddField('remesh', Value.ToString);
  Result := Self;
end;

function TStable3D.TextureResolution(
  const Value: TTextureResolutionType): TStable3D;
begin
  AddField('texture_resolution', Value.ToString);
  Result := Self;
end;

function TStable3D.VertexCount(const Value: Double): TStable3D;
begin
  AddField(CheckFloat('vertex_count', Value, -1, 20000), Value.ToString);
  Result := Self;
end;

{ TModel3D }

function TModel3D.SaveToFile(const FileName: string): string;
begin
  if ContentType <> 'model/gltf-binary' then
    raise Exception.CreateFmt('Incompatible format return : (%s)', [ContentType]);

  try
    FFileName := FileName;
    SaveBytesToFile(Data, FileName);
  except
    raise;
  end;
end;

{ TModel3DRoute }

procedure TModel3DRoute.Fast3D(
  ParamProc: TProc<TStable3D>; CallBacks: TFunc<TAsynModel3D>);
begin
  with TAsynCallBackExec<TAsynModel3D, TModel3D>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TModel3D
      begin
        Result := Self.Fast3D(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TModel3DRoute.Fast3D(ParamProc: TProc<TStable3D>): TModel3D;
begin
  Result := API.PostForm<TModel3D, TStable3D>('v2beta/3d/stable-fast-3d', ParamProc);
end;

end.

unit StabilityAI.VideoAnd3D.Video;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiStabilityAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Net.Mime, REST.JsonReflect, System.JSON,
  REST.Json.Types, StabilityAI.API, StabilityAI.Common, StabilityAI.Async.Support;

type
  /// <summary>
  /// The <c>TVideo</c> class provides functionality to create short, high-quality video clips from images or text-based prompts.
  /// It leverages advanced video diffusion models, allowing users to easily generate content for applications in game development, animation, virtual reality, and creative content production.
  /// </summary>
  /// <remarks>
  /// This class <c>TVideo</c> is responsible for managing parameters related to the API calls, encapsulating them in an intuitive manner.
  /// The parameters are prepared and provided through anonymous methods, ensuring seamless integration with other methods that call these APIs.
  /// The TVideo class abstracts the complexity of parameter management, making it easier for developers to generate creative video outputs without dealing with low-level implementation details.
  /// </remarks>
  TVideo = class(TMultipartFormData)
    /// <summary>
    /// The source image used in the video generation process.
    /// </summary>
    /// <param name="FilePath">
    /// Filename with supported format (jpeg, png, webp)
    /// </param>
    /// <returns>
    /// The updated <c>TStableImageUltra</c> instance.
    /// </returns>
    /// <remarks>
    /// Supported Dimensions:
    /// <para>
    /// - 1024x576
    /// </para>
    /// <para>
    /// - 576x1024
    /// </para>
    /// <para>
    /// - 768x768
    /// </para>
    /// </remarks>
    function Image(const FilePath: string): TVideo; overload;
    /// <summary>
    /// The source image used in the video generation process.
    /// </summary>
    /// <param name="Stream">
    /// The image data in the form of a TStream. The stream must contain the image data in a supported format (e.g., JPEG, PNG, WEBP).
    /// </param>
    /// <param name="StreamFreed">
    /// A boolean value indicating whether the stream should be automatically freed after being processed.
    /// <para>
    /// - Set to <c>True</c> to allow the method to free the stream automatically after reading its contents.
    /// </para>
    /// <para>
    /// - Set to <c>False</c> if you want to manage the lifetime of the stream yourself.
    /// </para>
    /// </param>
    /// <remarks>
    /// Supported Dimensions:
    /// <para>
    /// - 1024x576
    /// </para>
    /// <para>
    /// - 576x1024
    /// </para>
    /// <para>
    /// - 768x768
    /// </para>
    /// </remarks>
    function Image(const Stream: TStream; StreamFreed: Boolean = False): TVideo; overload;
    /// <summary>
    /// A specific value that is used to guide the 'randomness' of the generation
    /// </summary>
    /// <param name="Value">
    /// number [0 .. 4294967294]  (Default: 0)
    /// </param>
    /// <remarks>
    /// Omit this parameter or pass 0 to use a random seed.
    /// </remarks>
    function Seed(const Value: Int64): TVideo;
    /// <summary>
    /// How strongly the video sticks to the original image.
    /// </summary>
    /// <param name="Value">
    /// Number: [0 .. 10] (Default: 1.8)
    /// </param>
    /// <remarks>
    /// Use lower values to allow the model more freedom to make changes and higher values to correct motion distortions.
    /// </remarks>
    function CfgScale(const Value: Double): TVideo;
    /// <summary>
    /// This parameter corresponds to the motion_bucket_id parameter from the paper.
    /// </summary>
    /// <param name="Value">
    /// Number: [ 1 .. 255 ] (Default: 127)
    /// </param>
    /// <remarks>
    /// Lower values generally result in less motion in the output video, while higher values generally result in more motion.
    /// </remarks>
    function MotionBucketId(const Value: Double): TVideo;
    constructor Create; reintroduce;
  end;

  /// <summary>
  /// The <c>TJobVideo</c> class represents a video generation job.
  /// It encapsulates the unique identifier (<c>Id</c>) for tracking the video generation process.
  /// </summary>
  /// <remarks>
  /// This class provides a simple interface for managing video generation jobs.
  /// The <c>Id</c> property can be used to retrieve results or monitor the progress of a job.
  /// Use this class in conjunction with the <c>TVideoRoute</c> to handle video generation tasks efficiently.
  /// </remarks>
  TJobVideo = class
  private
    FId: string;
  public
    /// <summary>
    /// A string representing the job's unique identifier.
    /// </summary>
    property Id: string read FId write FId;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TJobVideo</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynJobVideo</c> type extends the <c>TAsynParams&lt;TJobVideo&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynJobVideo = TAsynCallBack<TJobVideo>;

  /// <summary>
  /// The <c>TVideoRoute</c> class manages video generation processes using Stable Video Diffusion models.
  /// </summary>
  /// <remarks>
  /// This class serves as the primary interface for generating videos from images or text-based prompts.
  /// It provides both synchronous and asynchronous methods for video creation and result retrieval.
  /// Use this class to handle video generation efficiently, including parameter setup and API communication.
  /// </remarks>
  TVideoRoute = class(TStabilityAIAPIRoute)
    /// <summary>
    /// Generate a short video based on an initial image with Stable Video Diffusion, a latent video diffusion model.
    /// <para>
    /// After invoking this endpoint with the required parameters, use the id in the response to poll for results at the image-to-video/result/{id} endpoint. Rate-limiting or other errors may occur if you poll more than once every 10 seconds.
    /// </para>
    /// <para>
    /// NOTE: This method is <c>synchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as image, the mask, the seed, the the format of the output image.
    /// </param>
    /// <returns>
    /// Returns a <c>TJobVideo</c> object that contains then ID of the task.
    /// </returns>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    ///   var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    ///   var Data := Stability.VideoAnd3D.ImageToVideo.Generation(
    ///     procedure (Params: TVideo)
    ///     begin
    ///       // Define parameters.
    ///     end);
    ///   try
    ///     ShowMessage(Data.Id);
    ///   finally
    ///     Data.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Generation(ParamProc: TProc<TVideo>): TJobVideo; overload;
    /// <summary>
    /// Generate a short video based on an initial image with Stable Video Diffusion, a latent video diffusion model.
    /// <para>
    /// After invoking this endpoint with the required parameters, use the id in the response to poll for results at the image-to-video/result/{id} endpoint. Rate-limiting or other errors may occur if you poll more than once every 10 seconds.
    /// </para>
    /// <para>
    /// NOTE: This method is <c>asynchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the image creation, such as image, the the format of the output image etc.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for asynchronous image creation, such as <c>onSuccess</c> and <c>onError</c>.
    /// </param>
    /// <exception cref="StabilityAIException">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="StabilityAIExceptionBadRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line to the main OnCreate method for maximum scope.
    /// // var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    /// Stability.VideoAnd3D.ImageToVideo.Generation(
    ///   procedure (Params: TVideo)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynJobVideo
    ///   begin
    ///     Result.Sender := my_obj;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Data: TJobVideo)
    ///       begin
    ///         // Handle success operation
    ///         ShowMessage(Data.Id);
    ///       end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle error message
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure Generation(ParamProc: TProc<TVideo>; CallBacks: TFunc<TAsynJobVideo>); overload;
    /// <summary>
    /// Fetch the result of an image-to-video generation by ID.
    /// <para>
    /// Make sure to use the same API key to fetch the generation result that you used to create the generation, otherwise you will receive a 404 response.
    /// </para>
    /// <para>
    /// NOTE: This method is <c>synchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ResultId">
    /// The id of a generation, typically used for async generations, that can be used to check the status of the generation or retrieve the result.
    /// <para>
    /// string = 64 characters
    /// </para>
    /// <para>
    /// - Example: d4fb4aa8301aee0b368a41b3c0a78018dfc28f1f959a3666be2e6951408fb8e3
    /// </para>
    /// <para>
    /// - Results are stored for 24 hours after generation. After that, the results are deleted and you will need to re-generate your video.
    /// </para>
    /// </param>
    /// <returns>
    /// Returns a <c>TResults</c> object that contains <c>Id</c>, <c>Status</c> and and possibly a <c>video</c>.
    /// </returns>
    /// <remarks>
    /// <code>
    ///   var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    ///   var Fetch := Stability.VideoAnd3D.ImageToVideo.Fetch(ID);
    ///   try
    ///     if not (Fetch.Status = 'in-progress') then
    ///       //The video is loaded
    ///       Fetch.SaveToFile('file as .mp4')
    ///   finally
    ///     Fetch.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Fetch(const ResultId: string): TResults; overload;
    /// <summary>
    /// Fetch the result of an image-to-video generation by ID.
    /// <para>
    /// Make sure to use the same API key to fetch the generation result that you used to create the generation, otherwise you will receive a 404 response.
    /// </para>
    /// <para>
    /// NOTE: This method is <c>synchronous</c>
    /// </para>
    /// </summary>
    /// <param name="ResultId">
    /// The id of a generation, typically used for async generations, that can be used to check the status of the generation or retrieve the result.
    /// <para>
    /// string = 64 characters
    /// </para>
    /// <para>
    /// Example: d4fb4aa8301aee0b368a41b3c0a78018dfc28f1f959a3666be2e6951408fb8e3
    /// </para>
    /// <para>
    /// Results are stored for 24 hours after generation. After that, the results are deleted.
    /// </para>
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for asynchronous image creation, such as <c>onSuccess</c> and <c>onError</c>.
    /// </param>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line to the main OnCreate method for maximum scope.
    /// // var Stability := TStabilityAIFactory.CreateInstance(BaererKey);
    /// Stability.VideoAnd3D.ImageToVideo.Fetch(Id,
    ///   function : TAsynResults
    ///   begin
    ///     Result.Sender := my_object;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Data: TResults)
    ///       begin
    ///         // Handle success operation
    ///         Data.SaveToFile('file as .mp4')
    ///       end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle error message
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure Fetch(const ResultId: string; CallBacks: TFunc<TAsynResults>); overload;
  end;

implementation

uses
  StabilityAI.NetEncoding.Base64, StabilityAI.Consts;

{ TVideo }

function TVideo.CfgScale(const Value: Double): TVideo;
begin
  AddField(CheckFloat('cfg_scale', Value, 0, 10), Value.ToString);
  Result := Self;
end;

constructor TVideo.Create;
begin
  inherited Create(True);
end;

function TVideo.Image(const FilePath: string): TVideo;
begin
  AddBytes('image', FileToBytes(FilePath), FilePath);
  Result := Self;
end;

function TVideo.Image(const Stream: TStream; StreamFreed: Boolean): TVideo;
begin
  if StreamFreed then
    {--- The stream's content is automatically freed. }
    AddStream('image', Stream, True, 'FileNameForHeader.png')
  else
    {--- You should release the stream's content. }
    AddBytes('image', StreamToBytes(Stream), 'FileNameForHeader.png');
  Result := Self;
end;

function TVideo.MotionBucketId(const Value: Double): TVideo;
begin
  AddField(CheckFloat('motion_bucket_id', Value, 1, 255), Value.ToString);
  Result := Self;
end;

function TVideo.Seed(const Value: Int64): TVideo;
begin
  AddField(CheckInteger('seed', Value, 0, SeedMax), Value.ToString);
  Result := Self;
end;

{ TVideoRoute }

function TVideoRoute.Fetch(const ResultId: string): TResults;
begin
  Result := API.Get<TResults>('v2beta/image-to-video/result/' + ResultId);
end;

procedure TVideoRoute.Fetch(const ResultId: string; CallBacks: TFunc<TAsynResults>);
begin
  with TAsynCallBackExec<TAsynResults, TResults>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TResults
      begin
        Result := Self.Fetch(ResultId);
      end);
  finally
    Free;
  end;
end;

function TVideoRoute.Generation(ParamProc: TProc<TVideo>): TJobVideo;
begin
  Result := API.PostForm<TJobVideo, TVideo>('v2beta/image-to-video', ParamProc);
end;

procedure TVideoRoute.Generation(ParamProc: TProc<TVideo>;
  CallBacks: TFunc<TAsynJobVideo>);
begin
  with TAsynCallBackExec<TAsynJobVideo, TJobVideo>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TJobVideo
      begin
        Result := Self.Generation(ParamProc);
      end);
  finally
    Free;
  end;
end;

end.

unit VCL.Stability.Tutorial;

{ Tutorial Support Unit

   WARNING:
     This module is intended solely to illustrate the examples provided in the
     README.md file of the repository :
         https://github.com/MaxiDonkey/DelphiStabilityAI.
     Under no circumstances should the methods described below be used outside
     of the examples presented on the repository's page.
}

interface

uses
  System.SysUtils, System.Classes, Vcl.StdCtrls, Vcl.ExtCtrls, Vcl.Controls, Vcl.Forms,
  StabilityAI.Common, StabilityAI.Version1.SDXL1AndSD1_6, StabilityAI.VideoAnd3D.Stable3D,
  StabilityAI.VideoAnd3D.Video, StabilityAI.Version1.Engines, StabilityAI.Version1.User;

type
  TVCLStabilitySender = class
  private
    FId: string;
    FMemo: TMemo;
    FImage: TImage;
    FFileName: string;
  public
    property Id: string read FId write FId;
    property Memo: TMemo read FMemo write FMemo;
    property Image: TImage read FImage write FImage;
    property FileName: string read FFileName write FFileName;
    constructor Create(const AMemo: TMemo; const AImage: TImage);
  end;

  procedure Start(Sender: TObject);
  procedure Display(Sender: TObject; Value: string); overload;
  procedure Display(Sender: TObject; Result: TStableImage); overload;
  procedure Display(Sender: TObject; Result: TArtifacts); overload;
  procedure Display(Sender: TObject; Value: TResults); overload;
  procedure Display(Sender: TObject; Value: TModel3D); overload;
  procedure Display(Sender: TObject; Value: TJobVideo); overload;
  procedure Display(Sender: TObject; Value: TEngines); overload;
  procedure Display(Sender: TObject; Value: TAccountDetails); overload;

var
  StabilityResult: TVCLStabilitySender = nil;

implementation

procedure Start(Sender: TObject);
begin
  Display(Sender, 'Request sended. Please wait...');
end;

procedure Display(Sender: TObject; Value: string);
begin
  var T := Sender as TVCLStabilitySender;
  T.Memo.Lines.Text := T.Memo.Text + Value + sLineBreak;
end;

procedure Display(Sender: TObject; Result: TStableImage);
begin
  var T := Sender as TVclStabilitySender;
  var Stream := Result.GetStream;
  try
    if not T.FileName.IsEmpty then
      Result.SaveToFile(T.FileName);
    Display(Sender, 'Save to file : ' + T.FileName);
    {--- Display only images }
    if not Result.Image.IsEmpty then
      T.Image.Picture.LoadFromStream(Stream);
    Display(Sender, 'Operation ended successfully');
  finally
    Stream.Free;
  end;
end;

procedure Display(Sender: TObject; Result: TArtifacts);
begin
  var T := Sender as TVCLStabilitySender;
  var Stream := Result.Artifacts[0].GetStream;
  try
    if not T.FileName.IsEmpty then
      Result.SaveToFile(T.FileName);
    T.Image.Picture.LoadFromStream(Stream);
    Display(Sender, 'Operation ended successfully');
  finally
    Stream.Free;
  end;
end;

procedure Display(Sender: TObject; Value: TResults); overload;
begin
  if not Value.Id.IsEmpty then
    begin
      Display(Sender, Value.Id);
      StabilityResult.Id := Value.Id;
      { Keep only the last ID of the job in progress !!!
        Please refer to the warning in the unit header. }
    end;
  if Value.Status = 'in-progress' then
    begin
      Display(Sender, 'in-progress');
      Exit;
    end;
  try
    Display(Sender, Value as TStableImage);
  except
  end;
end;

procedure Display(Sender: TObject; Value: TModel3D);
begin
  var T := Sender as TVCLStabilitySender;
  Value.SaveToFile(T.FileName);
  Display(Sender, 'Model 3d : ' + T.FileName);
end;

procedure Display(Sender: TObject; Value: TJobVideo);
begin
  Display(Sender, Value.Id);
end;

procedure Display(Sender: TObject; Value: TEngines);
begin
  for var Item in Value.Result do
    Display(Sender, Item.Name);
end;

procedure Display(Sender: TObject; Value: TAccountDetails);
begin
  Display(Sender, Value.Id);
  Display(Sender, Value.Email);
  Display(Sender, Value.ProfilePicture);
  for var Item in Value.Organizations do
    begin
      Display(Sender, Item.Id);
      Display(Sender, Item.Name);
      Display(Sender, Item.Role);
      Display(Sender, BoolToStr(Item.IsDefault, True));
    end;
end;

{ TVCLStabilitySender }

constructor TVCLStabilitySender.Create(const AMemo: TMemo;
  const AImage: TImage);
begin
  inherited Create;
  FMemo := AMemo;
  FImage := AImage;
end;

initialization
finalization
  if Assigned(StabilityResult) then
    StabilityResult.Free;
end.

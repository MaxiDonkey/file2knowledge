# Delphi MistralAI API

___
![GitHub](https://img.shields.io/badge/IDE%20Version-Delphi%2010.3/11/12-yellow)
![GitHub](https://img.shields.io/badge/platform-all%20platforms-green)
![GitHub](https://img.shields.io/badge/Updated%20on%20january%203,%202025-blue)

<br/>
<br/>

- [Introduction](#Introduction)
- [Changelog](https://github.com/MaxiDonkey/DelphiMistralAI/blob/main/Changelog.md)
- [Remarks](#remarks)
- [Wrapper Tools Info](#Wrapper-Tools-Info)
    - [Tools for simplifying this tutorial](#Tools-for-simplifying-this-tutorial)
    - [Asynchronous callback mode management](#Asynchronous-callback-mode-management)
    - [Simplified Unit Declaration](#Simplified-Unit-Declaration) 
- [Usage](#usage)
    - [Initialization](#initialization)
    - [Models](#models)
        - [Retrieve the list of models](#Retrieve-the-list-of-models)
        - [Retrieve Model](#Retrieve-Model)
        - [Fine tuned Models](#Fine-tuned-Models)
    - [Embeddings](#embeddings)
    - [Chats](#chats)
        - [Synchronous](#Synchronous)
            - [Not Streamed](#Not-Streamed)
            - [Streamed](#Streamed)
        - [Asynchronous](#Asynchronous)
            - [Asynchronous Not Streamed](#Asynchronous-Not-Streamed)
            - [Asynchronous Streamed](#Asynchronous-Streamed)
    - [Vision](#vision)
        - [Passing an Image URL](#Passing-an-image-url)
        - [Passing a Base64 Encoded Image](#Passing-a-base64-encoded-image)	
    - [Function calling](#function-calling)
        - [The weather in Paris](#The-weather-in-Paris)
    - [JSON mode](#JSON-mode)
    - [Code generation](#Code-generation)
        - [Before using](#Before-using)
        - [Codestral initialization](#Codestral-initialization)
        - [Code completion](#Code-completion)
        - [Streamed Code completion](#Streamed-code-completion)
        - [Fill in the middle](#Fill-in-the-middle)
        - [Stop tokens](#Stop-tokens)
        - [End points](#End-points)
    - [Files](#Files)
        - [List of files](#[List-of-files)
        - [File Retrieve](#File-Retrieve)
        - [File Upload](#File-Upload)
        - [File Delete](#File-Delete)
        - [File Download](#File-Download)
    - [Fine-tuning](#Fine-tuning)
        - [Create a Fine-tuning Job](#Create-a-Fine-tuning-Job)
        - [Delete a Fine-tuned Model](#Delete-a-Fine-tuned-Model)
        - [List of Fine-tune Job](#List-of-Fine-tune-Job)
        - [Retrieve a Fine-tune Job](#Retrieve-a-Fine-tune-Job)
        - [Start a Fine-tune Job](#Start-a-Fine-tune-Job)
        - [Cancel a Fine-tune Job](#Cancel-a-Fine-tune-Job)
    - [Moderation](#Moderation)
        - [Raw-text endpoint](#Raw-text-endpoint)
        - [Conversational endpoint](#Conversational-endpoint)
    - [Batch Inference](#Batch-Inference)
        - [Batch List](#Batch-List)
        - [Batch Job Create](#Batch-Job-Create)
        - [Batch Job Cancel](#Batch-Job-Cancel)
        - [Batch Job Retrieve](#Batch-Job-Retrieve)
        - [Batch Job Result File](#Fatch-Job-Result-File)
    - [Agents](#Agents)
- [Contributing](#contributing)
- [License](#license)

<br/>
<br/>


# Introduction

Welcome to the Unofficial **Delphi MistralAI API Library**
This library is designed to provide a seamless `Delphi` interface for interacting with the `MistralAI public API`. It simplifies the integration of advanced natural language processing capabilities into your `Delphi` applications. Whether your goal is text generation, creating embeddings, leveraging chat models, managing batch jobs, performing text evaluation with classifiers for moderation, or generating code, this library offers a streamlined and efficient solution to meet your needs.

**MistralAI** is a powerful natural language processing API that enables developers to incorporate advanced AI functionalities into their applications. For more details, visit the [official MistralAI documentation](https://docs.mistral.ai/api/).

<br/>

# Remarks 

> [!IMPORTANT]
>
> This is an unofficial library. **MistralAI** does not provide any official library for `Delphi`.
> This repository contains `Delphi` implementation over [MistralAI](https://docs.mistral.ai/api/) public API.

<br/>

# Wrapper Tools Info

This section provides brief notifications and explanations about the tools available to simplify the presentation and understanding of the wrapper's functions in the tutorial.

<br>

## Tools for simplifying this tutorial

To streamline the code examples provided in this tutorial and facilitate quick implementation, two units have been included in the source code: `MistralAI.Tutorial.VCL` and `MistralAI.Tutorial.FMX`. Depending on the platform you choose to test the provided source code, you will need to instantiate either the `TVCLTutorialHub` or `TFMXTutorialHub` class in the application's OnCreate event, as demonstrated below:

>[!TIP]
>```Pascal
> //uses MistralAI.Tutorial.VCL;
> TutorialHub := TVCLTutorialHub.Create(Memo1, Memo2, Button1);
>```


or

>[!TIP]
>```Pascal
> //uses MistralAI.Tutorial.FMX;
> TutorialHub := TFMXTutorialHub.Create(Memo1, Memo2, Button1);
>```

Make sure to add two `TMemo` and a `TButton` component to your form beforehand.

The `TButton` will allow the interruption of any streamed reception.

<br/>

## Asynchronous callback mode management

In the context of asynchronous methods, for a method that does not involve streaming, callbacks use the following generic record: `TAsyncCallBack<T> = record` defined in the `MistralAI.Async.Support.pas` unit. This record exposes the following properties:

```Pascal
   TAsyncCallBack<T> = record
   ... 
       Sender: TObject;
       OnStart: TProc<TObject>;
       OnSuccess: TProc<TObject, T>;
       OnError: TProc<TObject, string>; 
```
<br/>

For methods requiring streaming, callbacks use the generic record `TAsyncStreamCallBack<T> = record`, also defined in the `MistralAI.Async.Support.pas` unit. This record exposes the following properties:

```Pascal
   TAsyncCallBack<T> = record
   ... 
       Sender: TObject;
       OnStart: TProc<TObject>;
       OnSuccess: TProc<TObject>;
       OnProgress: TProc<TObject, T>;
       OnError: TProc<TObject, string>;
       OnCancellation: TProc<TObject>;
       OnDoCancel: TFunc<Boolean>;
```

The name of each property is self-explanatory; if needed, refer to the internal documentation for more details.

>[!NOTE]
> All methods managed by the wrapper are designed to support both synchronous and asynchronous execution modes. This dual-mode functionality ensures greater flexibility for users, allowing them to choose the approach that best suits their application's requirements and workflow.

<br/>

## Simplified Unit Declaration

To streamline the use of the API wrapper, the process for declaring units has been simplified. Regardless of the methods being utilized, you only need to reference the following two core units:

```Pascal
  uses
    MistralAI, MistralAI.Types;
```

If required, you may also include the `MistralAI.Schema` unit or any plugin units developed for specific function calls (e.g., `MistralAI.Functions.Example`). This simplification ensures a more intuitive and efficient integration process for developers.

<br/>

# Usage

## Initialization

To initialize the API instance, you need to [obtain an API token from MistralAI](https://console.mistral.ai/api-keys/).

Once you have a token, you can initialize `IMistralAI` interface, which is an entry point to the API.

```Pascal
uses MistralAI;

var MistralAI := TMistralAIFactory.CreateInstance(API_TOKEN);
```

<br/>

When instantiating the interface managing the TMistralAI type class, the CodestralSpec specification can be specified in the create constructor.

The resulting interface will handle both `CodeStral` functionality as well as chat-type interactions.

```Pascal
uses MistralAI;

var CodingModel := TMistralAIFactory.CreateInstance(API_TOKEN, [CodestralSpec]);
```

>[!Warning]
> To use the examples provided in this tutorial, especially to work with asynchronous methods, I recommend defining the `MistralAI` and `CodingModel`  interfaces with the widest possible scope.
> <br/>
> So, set 
> - `MistralAI := TMistralAIFactory.CreateInstance(API_TOKEN);`  and 
> - `CodingModel := TMistralAIFactory.CreateInstance(API_TOKEN, [CodestralSpec]);`  
> in the `OnCreate` event of your application.
> <br/>
> Having previously declared  MistralAI: IMistralAI; and CodingModel: IMistralAI;
>

<br/>

## Models

The `Model` unit manages not only the models provided by `MistralAI` but also those that have been fine-tuned for specific use cases. This flexibility ensures seamless integration and utilization of both pre-trained and customized models.

For more details on the available models, please refer to the [Models Documentation](https://docs.mistral.ai/models/)

### Retrieve the list of models

**Synchronously code example :**

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  var Models := MistralAI.Models.List;
    try
      Display(TutorialHub, Models);
    finally
      Models.Free;
    end;
```

**Asynchronously code example :**

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  MistralAI.Models.AsyncList(
    function : TAsynModels
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```
<br/>

### Retrieve Model

**Synchronously code example :**

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  var Model := MistralAI.Models.Retrieve('mistral-large-2407');
  try
    Display(TutorialHub, Model);
  finally
    Model.Free;
  end;
```

**Asynchronously code example :**

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  MistralAI.Models.AsyncRetrieve('mistral-large-2407',
    function : TAsynModel
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

### Fine tuned Models

Fine-tuned models can be managed through various operations, including deletion, renaming, archiving, and unarchiving. To perform these actions, the following functions are available in both synchronous and asynchronous modes:

**Synchronous Mode:** 
```Pascal
- function Delete(const ModelId: string): TModelDeletion;
- function Update(const ModelId: string; ParamProc: TProc<TModelParams>): TFineTunedModel;
- function Archive(const ModelId: string): TArchivingModel;
- function Unarchive(const ModelId: string): TArchivingModel;
```

**Asynchronous Mode:** 
```Pascal
- procedure AsyncDelete(const ModelId: string; const CallBacks: TFunc<TAsynModelDeletion>);
- procedure AsyncUpdate(const ModelId: string; ParamProc: TProc<TModelParams>;
      const CallBacks: TFunc<TAsynFineTuneModel>);
- procedure AsyncArchive(const ModelId: string; const CallBacks: TFunc<TAsynArchivingModel>);
- procedure AsyncUnarchive(const ModelId: string; const CallBacks: TFunc<TAsynArchivingModel>);
```

These functions provide a flexible and comprehensive approach to maintaining and organizing fine-tuned models.

<br>

## Embeddings

Embeddings make it possible to vectorize one or more texts in order, for example, to calculate the similarity between sentences. Each vector resulted will be of dimension 1024. This vector representation captures deep semantic aspects of texts, allowing for more nuanced comparisons.
Distance measures such as cosine, Euclidean distance or other custom measures can be applied to these embeddings. 

See also [tokenization](https://docs.mistral.ai/guides/tokenization/) at the MistralAI web site.

**Synchronously code example :**

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  var Embeddings := MistralAI.Embeddings.Create(
    procedure (Params: TEmbeddingParams)
    begin
      Params.Input(['aba', 'bbb']);
    end);
  try
    Display(TutorialHub, Embeddings);
  finally
    Embeddings.Free;
  end;
```

<br/>

**Asynchronously**, we proceed as follows:

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  MistralAI.Embeddings.AsyncCreate(
    procedure (Params: TEmbeddingParams)
    begin
      Params.Input([ 'Text to vectorize' ]);
    end,
    function : TAsyncEmbeddings
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);  
```

<br/>

## Chats

Using the API to create and maintain conversations. You have the option to either wait for a complete response or receive the response sequentially (Streaming mode).

See also [Prompting Capabilities](https://docs.mistral.ai/guides/prompting_capabilities/) at the MistralAI web site.

<br/>

### Synchronous

#### Not Streamed

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  var Chat := MistralAI.Chat.Create(
    procedure (Params: TChatParams)
    begin
      Params.Model('mistral-tiny');
      Params.Messages([Payload.User('Explain to me what joual is for Quebecers.')]);
      Params.MaxTokens(1024);
    end);
  try
    Display(Memo1, Chat);
  finally
    Chat.Free;
  end;
```

<br/>

#### Streamed

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  MistralAI.Chat.CreateStream(
    procedure(Params: TChatParams)
    begin
      Params.Model('mistral-large-latest');
      Params.Messages([
          Payload.System('You are a teacher for 8 year old children, you have to adapt your language to your students.'),
          Payload.User('Explain to me what joual is for Quebecers.')]);
      Params.MaxTokens(1024);
      Params.Stream;
    end,
    procedure(var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
    begin
      if (not IsDone) and Assigned(Chat) then
        begin
          DisplayStream(Memo1, Chat);
        end;
    end);
```

<br/>

### Asynchronous

You can use asynchronous methods for text completion or chat tasks. For this, you need to use the two methods

 1. `procedure AsyncCreate(ParamProc: TProc<TChatParams>; Events: TFunc<TAsynChat>)`

 2. `procedure AsyncCreateStream(ParamProc: TProc<TChatParams>; Events: TFunc<TAsynChatStream>)`

as follows :

#### Asynchronous Not Streamed

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  MistralAI.Chat.ASyncCreate(
    procedure (Params: TChatParams)
    begin
      Params.Model('mistral-tiny');
      Params.Messages([Payload.User('Explain to me what joual is for Quebecers.')]);
      Params.MaxTokens(1024);
    end,
    function : TAsynChat
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);  
```
<br/>

#### Asynchronous Streamed


```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  MistralAI.Chat.ASyncCreateStream(
    procedure(Params: TChatParams)
    begin
      Params.Model('mistral-large-latest');
      Params.Messages([
          Payload.System('You are a literature professor for graduate students and you often mention Jack Kerouac.'),
          Payload.User('Explain to me what joual is for Quebecers.')]);
      Params.MaxTokens(1024);
      Params.Stream;
    end,
    function : TAsynChatStream
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnProgress := DisplayStream;
      Result.OnSuccess := Display;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
      Result.OnError := Display;
    end);
```

<br/>

## Vision

The latest Pixtral 12B adds vision capabilities, allowing to analyze both images and text, expanding its potential for applications requiring multimodal understanding.
See also [official documentation](https://docs.mistral.ai/capabilities/vision/).

To support both synchronous and asynchronous completion methods, we focused on generating the appropriate payload for message parameters. An overloaded version of the `TChatMessagePayload.User` class function was added, allowing users to include a dynamic array of text elements—either URLs or file paths—alongside the user's text content. Internally, this data is processed to ensure the correct operation of the vision system in both synchronous and asynchronous contexts.

<br/>

### Passing an Image URL

**Synchronously code example :**

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  // png, jpeg, gif and webp formats are supported
  var Ref1 := 'https://tripfixers.com/wp-content/uploads/2019/11/eiffel-tower-with-snow.jpeg';
  var Ref2 := 'https://assets.visitorscoverage.com/production/wp-content/uploads/2024/04/AdobeStock_626542468-min-1024x683.jpeg';

  var Vision := MistralAI.Chat.Create(
    procedure (Params: TChatParams)
    begin
      Params.Model('pixtral-12b-2409');
      Params.Messages([Payload.User('what are the differences between two images?', [Ref1, Ref2])]);
      Params.MaxTokens(1024);
    end);
  try
    Display(TutorialHub, Vision);
  finally
    Vision.Free;
  end;
```

**Asynchronously code example :**

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  // png, jpeg, gif and webp formats are supported
  var Ref1 := 'https://tripfixers.com/wp-content/uploads/2019/11/eiffel-tower-with-snow.jpeg';
  var Ref2 := 'https://assets.visitorscoverage.com/production/wp-content/uploads/2024/04/AdobeStock_626542468-min-1024x683.jpeg';

  MistralAI.Chat.ASyncCreate(
    procedure (Params: TChatParams)
    begin
      Params.Model('pixtral-12b-2409');
      Params.Messages([Payload.User('what are the differences between two images?', [Ref1, Ref2])]);
      Params.MaxTokens(1024);
    end,
    function : TAsynChat
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

### Passing a Base64 Encoded Image

**Synchronously code example :**

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  // png, jpeg, gif and webp formats are supported
  var Ref := 'D:\My_folder\Images\my_image.png';  

  var Vision := MistralAI.Chat.Create(
    procedure (Params: TChatParams)
    begin
      Params.Model('pixtral-12b-2409');
      Params.Messages([Payload.User('Describe the image', [Ref])]);
      Params.MaxTokens(1024);
    end);
  try
    Display(TutorialHub, Vision);  
  finally
    Vision.Free;
  end;  
```

**Asynchronously code example :**

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  MistralAI.Chat.ASyncCreate(
    procedure (Params: TChatParams)
    begin
      Params.Model('pixtral-12b-2409');
      Params.Messages([PayLoad.User('Describe the image', [Ref])]);
      Params.MaxTokens(1024);
    end,
    function : TAsynChat
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

>[!NOTE]
> Since the goal is to use the chat API, you can adapt these examples for scenarios involving streamed responses.

<br/>

## Function calling

Function calling allows Mistral models to connect to external tools. By integrating Mistral models with external tools such as user defined functions or APIs, users can easily build applications catering to specific use cases and practical problems. 

See also [documentation](https://docs.mistral.ai/capabilities/function_calling/) at the MistralAI web site.

>[!WARNING]
> While this technology is powerful, it also carries potential risks. We strongly advise incorporating user confirmation processes before executing real-world actions on behalf of users, such as sending emails, posting online, making purchases, etc.
>
In the following section, we will explore the use of the tools through a practical example: *What’s the weather like in Paris?*

### The weather in Paris

The tool schema used :
```Json
  {
    "type": "object",
    "properties": {
         "location": {
             "type": "string",
             "description": "The city and department, e.g. Marseille, 13"
         },
         "unit": {
             "type": "string",
             "enum": ["celsius", "fahrenheit"]
         }
     },
     "required": ["location"]
  }
```

<br/>

1. We will use the `TWeatherReportFunction` plugin defined in the `MistralAI.Functions.Example` unit.

```Delphi
// uses MistralAI.Functions.Example;

  var WeatherFunc: IFunctionCore := TWeatherReportFunction.Create;
```
<br/>

2. We then define a method to display the result of the query using the `Weather` tool.

```Delphi
procedure TMyForm.CalledFunction(const Value: TCalledFunction; Func: IFunctionCore);
begin
  var ArgResult := Func.Execute(Value.&Function.Arguments);

  MistralAI.Chat.AsyncCreateStream(
    procedure (Params: TChatParams)
    begin
      Params.Model('open-mixtral-8x22b-2404');
      Params.Messages([
        PayLoad.System('Respond like a star weather presenter on a prime-time TV channel.'),
        Payload.User(ArgResult)
      ]);
      Params.Stream(True);
      Params.MaxTokens(1024);
    end,
    function : TAsynChatStream
    begin
      Result.Sender := TutorialHub;
      Result.OnProgress := DisplayStream;
      Result.OnSuccess := Display;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
      Result.OnError := Display;
    end);
end;
```
<br/>

3. Building the query using the `Weather` tool

**Synchronously code example**

```Pascal
// MistralAI, MistralAI.Types, MistralAI.Functions.Example, MistralAI.Tutorial.FMX, MistralAI.Functions.Example;

  var WeatherFunc: IFunctionCore := TWeatherReportFunction.Create;

  TutorialHub.Tool := WeatherFunc; //For tutorial tool use only
  TutorialHub.ToolCall := CalledFunction; // For tutorial tool use only

  var Chat := MistralAI.Chat.Create(
    procedure (Params: TChatParams)
    begin
      Params.Model('mistral-large-latest');
      Params.Messages([TChatMessagePayload.User('What''s the weather like in Paris?')]);
      Params.Tools([TChatMessageTool.Add(WeatherFunc)]);
      Params.ToolChoice(auto);
      Params.MaxTokens(1024);
    end);
  try
    Display(TutorialHub, Chat);
  finally
    Chat.Free;
  end;
```

**Asynchronously code example**

```Pascal
// MistralAI, MistralAI.Types, MistralAI.Functions.Example, MistralAI.Tutorial.FMX, MistralAI.Functions.Example;

  var WeatherFunc: IFunctionCore := TWeatherReportFunction.Create;

  TutorialHub.Tool := WeatherFunc; //For tutorial tool use only
  TutorialHub.ToolCall := CalledFunction; // For tutorial tool use only

  MistralAI.Chat.ASyncCreate(
    procedure (Params: TChatParams)
    begin
      Params.Model('mistral-large-latest');
      Params.Messages([TChatMessagePayload.User('What''s the weather like in Paris?')]);
      Params.Tools([TChatMessageTool.Add(WeatherFunc)]);
      Params.ToolChoice(auto);
      Params.MaxTokens(1024);
    end,
    function : TAsynChat
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```
<br/>

>[!NOTE]
>If we examine the `display` method in detail in this case, we notice that it takes into account the `FinishReason` flag and checks whether it is assigned the value `TFinishReason.tool_calls`. If so, the function is evaluated using the arguments obtained from the prompt.
>
>```Pascal
> procedure Display(Sender: TObject; Value: TChat);
> begin
>   for var Item in Value.Choices do
>    if Item.FinishReason = TFinishReason.tool_calls then
>      begin
>         if Assigned(TutorialHub.ToolCall) then
>           TutorialHub.ToolCall(Item.Message.ToolsCalls[0], TutorialHub.Tool);
>       end
>     else
>       begin
>         Display(Sender, Item.Message.Content);
>       end;
> end;
>```

## JSON mode

Users have the option to set response_format to {"type": "json_object"} to enable JSON mode. It's important to explicitly ask the model to generate JSON output in your message. Currently, JSON mode is available for all of the models through API.

Refer to the [official documentation](https://docs.mistral.ai/capabilities/json_mode/)

```Pascal
// MistralAI, MistralAI.Types, MistralAI.Functions.Example, MistralAI.Tutorial.FMX;

  var Chat := MistralAI.Chat.Create(
    procedure (Params: TChatParams)
    begin
      Params.Model('mistral-tiny');
      Params.Messages([Payload.User('--- my request ---')]);
      Params.ResponseFormat(); //Enable JSON mode 
      Params.MaxTokens(1024);
    end);
  try
    Display(TutorialHub, Chat);
  finally
    Chat.Free;
  end;
```

<br/>

## Code generation

**Codestral** is an advanced generative model optimized for code generation, including **fill-in-the-middle** and code completion. Trained on over 80 programming languages, it performs well on both common and rare languages.
See also [Code generation](https://docs.mistral.ai/capabilities/code_generation/) at the MistralAI web site.

<br/>

### Before using

To utilize the Delphi classes managing the **Codestral** function, you are required to create a new KEY on the ***Mistral.ai website***. Please note that obtaining this key necessitates providing a valid phone number. 
Go to this address to create a key for using **Codestral** [Key creation](https://console.mistral.ai/codestral)

> [!TIP]
> In the above examples we use synchronous methods. Here is the asynchronous equivalent :
>
>  - `procedure AsyncCreate(ParamProc: TProc<TCodestralParams>; CallBacks: TFunc<TAsynCode>);`
>
>  - `procedure AsyncCreateStream(ParamProc: TProc<TCodestralParams>; CallBacks: TFunc<TAsynCodeStream>);`
>

<br/>

### Codestral initialization

When instantiating the interface managing the ***TMistralAI*** type class, the `CodestralSpec` specification must be specified in the `create` constructor.

The resulting interface will handle both **CodeStral** functionality as well as chat-type interactions.

```Pascal
uses MistralAI;

var CodingModel: IMistralAI := TMistralAI.Create(API_TOKEN, [CodestralSpec]);
```

You can also use the factory:
> [!NOTE]
> ```Pascal
> uses MistralAI;
>
> var CodingModel := TMistralAIFactory.CreateInstance(API_TOKEN, [CodestralSpec]);
> ```

<br/>

### Code completion

**Synchronously code example**

```Pascal
// MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  TutorialHub.Memo2.Text := CodeBefore; // For tutorial tool use only

  var Codestral := CodingModel.Codestral.Create(
    procedure (Params: TCodestralParams)
    begin
      Params.Model('codestral-latest');
      Params.Prompt(CodeBefore);
      Params.MaxTokens(1024);
    end);
  try
    Display(TutorialHub, CodeStral);
  finally
    Codestral.Free;
  end;
```

**Asynchronously code example**

```Pascal
// MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  TutorialHub.Memo2.Text := CodeBefore; // For tutorial tool use only

  CodingModel.Codestral.AsyncCreate(
    procedure (Params: TCodestralParams)
    begin
      Params.Model('codestral-latest');
      Params.Prompt(CodeBefore);
      Params.MaxTokens(1024);
    end,
    function : TAsynCode
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);  
```

<br/>

### Streamed Code completion

**Synchronously code example**

```Pascal
// MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  TutorialHub.Memo2.Text := CodeBefore; // For tutorial tool use only

  CodingModel.Codestral.CreateStream(
    procedure(Params: TCodestralParams)
    begin
      Params.Model('codestral-latest');
      Params.Prompt(CodeBefore);
      Params.MaxTokens(1024);
      Params.Stream;
    end,
    procedure(var Code: TCodestral; IsDone: Boolean; var Cancel: Boolean)
    begin
      if (not IsDone) and Assigned(Code) then
        begin
          DisplayStream(TutorialHub, Code);
        end
    end);
```

**Asynchronously code example**

```Pascal
// MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  TutorialHub.Memo2.Text := CodeBefore; // For tutorial tool use only

  CodingModel.Codestral.ASyncCreateStream(
    procedure(Params: TCodestralParams)
    begin
      Params.Model('codestral-latest');
      Params.Prompt(CodeBefore);
      Params.MaxTokens(1024);
      Params.Stream;
    end,
    function : TAsynCodeStream
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnProgress := DisplayStream;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
      Result.OnError := Display;
    end);
```

<br/>

### Fill in the middle

This feature allows users to set the beginning of their code with a `prompt` and to specify the end of the code using an optional `suffix` and an optional `stop` condition. The Codestral model will then produce the code that seamlessly fits between these markers, making it perfect for tasks that need a particular segment of code to be created.

```Pascal
// MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  TutorialHub.Memo2.Text := string.Join(sLineBreak, [CodeBefore, '//Insert code here'+sLineBreak, CodeAfter]); // For tutorial tool use only

  CodingModel.Codestral.ASyncCreateStream(
    procedure(Params: TCodestralParams)
    begin
      Params.Model('codestral-latest');
      Params.Prompt(CodeBefore);
      Params.Suffix(CodeAfter);
      Params.MaxTokens(1024);
      Params.Stream;
    end,
    function : TAsynCodeStream
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnProgress := DisplayStream;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
      Result.OnError := Display;
    end); 
```

The model will create the intermediate code completing the codes provided to the `prompt` and `suffix` parameters.

<br/>

### Stop tokens

It is advisable to include stop tokens when integrating with IDE autocomplete to ensure the model doesn't provide overly verbose output.

```Pascal
// MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  TutorialHub.Memo2.Text := string.Join(sLineBreak, [CodeBefore, '//Insert code here'+sLineBreak, CodeAfter]); // For tutorial tool use only

  CodingModel.Codestral.ASyncCreateStream(
    procedure(Params: TCodestralParams)
    begin
      Params.Model('codestral-latest');
      Params.Prompt(CodeBefore);
      Params.Suffix(CodeAfter);
      Params.MaxTokens(1024);
      Params.Stream;
      Params.Stop(['\n\n']); // <-- Include here the strings responsible for stopping processing
    end,
    function : TAsynCodeStream
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnProgress := DisplayStream;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
      Result.OnError := Display;
    end); 
```

<br/>

### End points

**Codestral** can be used directly to generate code using the endpoint: `https://codestral.mistral.ai/v1/fim/completions`, and for chat interactions with the endpoint: `https://codestral.mistral.ai/v1/chat/completions`.

However, it is crucial to understand that chat usage requires using only the **"codestral-latest"** model or similar. In other words, with the endpoint `https://codestral.mistral.ai/v1/chat/completions`, a model such as **"open-mixtral-8x22b-2404"** or similar cannot be used; instead, **"codestral-latest" should be preferred**.

```Pascal
// MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  CodingModel.Chat.ASyncCreate(
    procedure (Params: TChatParams)
    begin
      Params.Model('codestral-latest');
      Params.Messages([Payload.User('Define the term "decorum"')]);
      Params.MaxTokens(1024);
    end,
    function : TAsynChat
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

## Files

File management APIs are especially useful for `fine-tuning` and `batch` processing operations.
- For fine-tuning, they allow uploading the data files required for training and testing a model to be fine-tuned. These dataset files can also be listed for review.
- For batch processing, files can be uploaded, retrieved, or deleted. Once the processing is complete, a result file is generated, which can then be downloaded via the APIs.

>[!NOTE]
> In the following section on file management, all code examples will be presented in asynchronous mode to enhance readability and simplify comprehension.
>

### List of files

To retrieve the list of files, proceed as follows.

1. The list can be paginated, and you can also specify the number of items to return as a parameter. Below is an example of code to display the first page:

```Pascal
// MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  TutorialHub.Page := 0; // For tutorial tool use only

  MistralAI.&File.ASyncList(
    procedure (Params: TListParams)
    begin
      Params.PageSize(4);
    end,
    function : TAsynFiles
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

2. To navigate to the next page, use the following code:

```Pascal
// MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  TutorialHub.NextPage; // For tutorial tool use only

  MistralAI.&File.ASyncList(
    procedure (Params: TListParams)
    begin
      Params.Page(TutorialHub.Page);
      Params.PageSize(4);
    end,
    function : TAsynFiles
    begin
      Result.Sender := TutorialHub;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

### File Retrieve

To locate a file, you need to know its ID, which can be retrieved by displaying the list of files.

```Pascal
// MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  TutorialHub.FileId := Id; //e.g. 982d2bbc-adbb-4c6e-b072-5aec973b4c86

  MistralAI.&File.ASyncRetrieve(TutorialHub.FileId,
    function : TAsynFile
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);  
```

<br/>

### File Upload

It is essential to populate the Purpose field to specify the category to which the file to be uploaded belongs. This can be, for instance, fine-tune or batch.

```Pascal
// MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  TutorialHub.FileName := 'Z:\my_folder\my_file.jsonl'; // For tutorial tool use only

  MistralAI.&File.AsyncUpload(
    procedure (Params: TUploadParams)
    begin
      //Params.Purpose(TFilePurpose.finetune);
      //  or
      //Params.Purpose(TFilePurpose.batch);
      Params.&File(TutorialHub.FileName);
    end,
    function : TAsynFile
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

### File Delete

```Pascal
// MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  TutorialHub.FileId := Id; //e.g. 982d2bbc-adbb-4c6e-b072-5aec973b4c86

  MistralAI.&File.ASyncDelete(TutorialHub.FileId,
    function : TAsynFilesDelete
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

### File Download

Used to download a file generated following batch processing. To obtain the file ID, you need to view the list of available files. Alternatively, the ID can also be retrieved directly from the platform.

```Pascal
// MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  TutorialHub.FileId := Id; //e.g. 982d2bbc-adbb-4c6e-b072-5aec973b4c86
  TutorialHub.FileOverride := True;
  TutorialHub.FileName := 'ResultFile.jsonl';

  MistralAI.&File.ASyncDownload(TutorialHub.FileId,
    function : TAsynDownLoadFile
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);  
```

<br/>

## Fine-tuning

When choosing between prompt engineering and fine-tuning for an AI model, it's advisable to start with prompt engineering due to its speed and lower resource requirements. Fine-tuning, however, offers better performance and alignment with specific tasks, making it ideal for specialized applications and cost reduction.

See also [Fine-tuning description](https://docs.mistral.ai/capabilities/finetuning/) at the **MistralAI** web site.

> [!TIP]
> Synchronous and asynchronous methods also exist for fine-tuning as well as file handling. See the TFilesRoute class in the MistralAI.Files unit and the TFineTuningRoute class in the MistralAI.FineTunings unit

<br/>

Data should be stored in **JSON** Lines files `(.jsonl)`, where each line corresponds to a separate **JSON object**. This format enables efficient storage of multiple **JSON objects**.

The datasets must adhere to an instruction-following format that simulates a conversation between a user and an assistant. Each JSON record should either contain only messages exchanged between the user and the assistant (referred to as ***"Default Instruct"***), or include additional logic for function calls (referred to as ***"Function-calling Instruct"***). 

See also [Default Instruct](https://docs.mistral.ai/capabilities/finetuning/#1-default-instruct) and [Function-calling Instruct](https://docs.mistral.ai/capabilities/finetuning/#2-function-calling-instruct)

**`Warning:`**
Please remember to remove any line breaks if you copy and paste the examples provided by Mistral AI for the "Dataset Format."

### Create a Fine-tuning Job

The next step involves creating a fine-tuning job.

- **model**: Select the specific model you wish to fine-tune, with options being "open-mistral-7b" and "mistral-small-latest".
- **training_files**: Provide a set of training file IDs, which can include one or multiple files.
- **validation_files**: Provide a set of validation file IDs, which can include one or multiple files.
- **hyperparameters**: Adjust the two available hyperparameters, "trainingₛtep" and "learning_rate", according to your preferences.


The List/Retrieve/Cancel methods are also available to manage Jobs. And for the last two functions you will have to provide the job ID as a parameter.

**Important Notice**

As of July 2024, the only fine-tunable models at Mistral are                 
  - `open-mistral-7b (v0.3)`,                                               
  - `mistral-small-latest` (`mistral-small-2402`),                            
  - `codestral-latest` (`codestral-2405`),                                    
  - `open-mistral-nemo` and ,                                               
  - `mistral-large-latest` (`mistral-large-2407`)

**Example**

**Synchronously code example**

```Pascal
// MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  var FineTuneJob := MistralAI.FineTuning.CreateJob(
    procedure (Params: TFineTuningJobParams)
    begin
      Params.Model('open-mistral-7b'); //Fine Tuneable Models : Enum "open-mistral-7b", "mistral-small-latest
      Params.TrainingFiles([Id_TrainingFile1, Id_TrainingFile2, ... ]);
      Params.ValidationFiles([Id_ValidationFile1, Id_ValidationFile2, ... ]);
      Params.Suffix('ft-model-01');  //less than 18 characters
      Params.Hyperparameters(
        procedure (var Params: THyperparametersParams)
        begin
          Params.TrainingSteps(10);
          Params.LearningRate(0.0005);
        end);
    end
  );
  try
    Display(TutorialHub, FineTuneJob);  
  finally
    FineTuneJob.Free;
  end;
```

<br/>

### Delete a Fine-tuned Model

`Note`: The method in charge of deleting a fine tuned model is found in the `MistralAI.Models.pas` unit.

```Pascal
// MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  with MistralAI.Models.Delete('Id_Model_to_delete') do
  try
    ShowMessage('Model Deleted');
  finally
    Free;
  end;
```

<br/>

### List of Fine-tune Job

```Pascal
// MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  MistralAI.FineTuning.ASyncList(
    procedure (Params: TFineTuningJobListParams)
    begin
      Params.Page(100);
    end,
    function : TAsynListFineTuningJobs
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

>[!NOTE]
> You can use the pagination method described in the [`File List` section](#List-of-files).
>

<br/>

### Retrieve a Fine-tune Job

```Pascal
// MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  TutorialHub.JobId := Id; //e.g. 982d2bbc-adbb-4c6e-b072-5aec973b4c86

  MistralAI.FineTuning.ASyncRetrieve(TutorialHub.JobId,
    function : TAsynJobOutProgress
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

### Start a Fine-tune Job

```Pascal
// MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  TutorialHub.JobId := Id; //e.g. 982d2bbc-adbb-4c6e-b072-5aec973b4c86

  MistralAI.FineTuning.ASyncStart(TutorialHub.JobId,
    function : TAsynJobOutProgress
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

### Cancel a Fine-tune Job

```Pascal
// MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  TutorialHub.JobId := Id; //e.g. 982d2bbc-adbb-4c6e-b072-5aec973b4c86

  MistralAI.FineTuning.ASyncCancel(TutorialHub.JobId,
    function : TAsynJobOutProgress
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

>[!WARNING]
> The APIs do not provide the ability to delete a fine-tuning job, and this limitation also applies to the platform. Consequently, creating a large number of jobs could become problematic over time.
>

<br/>

## Moderation

The moderation service, leveraging the advanced Mistral Moderation model—a classifier built on the Ministral 8B 24.10 framework—empowers users to identify harmful text content across multiple policy dimensions.

The service offers two distinct endpoints: one designed for the classification of raw text and another specifically tailored for conversational content. Further details are provided below.
- **Raw-text endpoint:** `https://api.mistral.ai/v1/moderations`
- **Conversational endpoint:** `https://api.mistral.ai/v1/chat/moderations`

>[!NOTE]
> This note is sourced from the official MistralAI documentation.
>
> The policy threshold is determined based on the optimal performance of our internal test set. You can use the raw score or adjust the threshold according to your specific use cases.
>
> We intend to continually improve the underlying model of the moderation endpoint. Custom policies that depend on category_scores can require recalibration.
>

Refer to the [official documentation](https://docs.mistral.ai/capabilities/guardrailing/) about moderation.

<br/>

### Raw-text endpoint

In this example, only the categories requiring moderation consideration are displayed.

```Pascal
// MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  var Str := '...text to classify...';
  Display(TutorialHub, Str);

  MistralAI.Classifiers.ASyncModeration(
    procedure (Params: TModerationParams)
    begin
      Params.Model('mistral-moderation-latest');
      Params.Input(Str);
    end,
    function : TAsynModeration
    begin
      Result.Sender := TutorialHub;
      Result.OnSuccess := DisplayEx;
      Result.OnError := Display;
    end);
```

<br/>

### Conversational endpoint

In this example, all moderation categories are displayed.

```Pascal
// MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  var Str := '...text to classify...';
  Display(TutorialHub, Str);

  MistralAI.Classifiers.ASyncModerationChat(
    procedure (Params: TModerationChatParams)
    begin
      Params.Model('mistral-moderation-latest');
      Params.Input([Payload.User(Str)]);
    end,
    function : TAsynModeration
    begin
      Result.Sender := TutorialHub;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

## Batch Inference

The batch processing feature allows sending a large number of requests simultaneously to various endpoints (chat, embeddings, moderations, etc.). Each batch contains uniquely identified requests and is processed asynchronously. This enables tracking the progress of the processing, accessing results once completed, and handling potential timeouts.

Requests can be customized using metadata, and it is possible to view or cancel ongoing processes. Final results are available as downloadable files and remain accessible afterward.

This approach provides more efficient management of high volumes of requests without imposing a strict limit on the number of batches, while adhering to an overall limit on pending requests. It is particularly useful for automating and consolidating processing, especially in cases of large-scale or repetitive requests.

Refer to the [official documentation](https://docs.mistral.ai/capabilities/batch/).

<br/>

### Batch List

The list of batch processes can be retrieved using the following API. The pagination mechanism described for the [file list](#List-of-files) can also be used.

```Pascal
// MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  MistralAI.Batch.ASyncList(
    procedure (Params: TBatchJobListParams)
    begin
      Params.PageSize(100);
    end,
    function : TAsynBatchJobList
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

// Synchronously code
//  var List := MistralAI.Batch.List(
//    procedure (Params: TBatchJobListParams)
//    begin
//      Params.PageSize(100);
//    end);
//  try
//    Display(TutorialHub, List);
//  finally
//    List.Free;
//  end;
```

<br/>

### Batch Job Create

We take the batch given in the example on the official site

Here's an example of how to structure a batch request:

```Json
{"custom_id": "0", "body": {"max_tokens": 100, "messages": [{"role": "user", "content": "What is the best French cheese?"}]}}
{"custom_id": "1", "body": {"max_tokens": 100, "messages": [{"role": "user", "content": "What is the best French wine?"}]}}
```

<br/>

1. Save this text in a file and name it as you prefer.
2. Next, upload the file using the code provided in the [File Upload section](#File-Upload).
3. Be sure to set the value of Purpose to batch.
4. Note the file ID after it has been uploaded, as this `ID` will be required when creating the batch processing job.

<br/>

```Pascal
// MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  MistralAI.Batch.ASyncCreateJob(
    procedure (Params: TBatchJobParams)
    begin
      Params.InputFiles([ID]);
      Params.Model('mistral-large-latest');
      Params.Endpoint(TEndPointType.epChatCompletion);
      Params.Metadata(TJSONObject.Create.AddPair('job_type', 'texting'));
    end,
    function : TAsynBatchJob
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

// Synchronously code
//  var Value := MistralAI.Batch.CreateJob(
//    procedure (Params: TBatchJobParams)
//    begin
//      Params.InputFiles([ID]);
//      Params.Model('mistral-large-latest');
//      Params.Endpoint(TEndPointType.epChatCompletion);
//      Params.Metadata(TJSONObject.Create.AddPair('job_type', 'texting'));
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

>[!NOTE]
> Note: The following metadata was specified during creation as a label: 
>```Json
> {"job_type": "texting"}
>```

<br/>

### Batch Job Cancel

A job can be interrupted as long as it is still being processed. To perform this action, ensure that you have obtained the job ID beforehand, then use the following code:

```Pascal
// MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  TutorialHub.BatchId := ID; //e.g. 982d2bbc-adbb-4c6e-b072-5aec973b4c86

  MistralAI.Batch.ASyncCancel(TutorialHub.BatchId,
    function : TAsynBatchJob
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

// Synchronously code
//  var Value := MistralAI.Batch.Cancel(TutorialHub.BatchId);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br/>

### Batch Job Retrieve

A batch can be retrieved using its ID, allowing you to check its status to track progress or obtain the ID of the file generated at the end of the process containing the expected results. To do so, use the following code:

```Pascal
// MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  TutorialHub.BatchId := ID; //e.g. 982d2bbc-adbb-4c6e-b072-5aec973b4c86

  MistralAI.Batch.ASyncRetrieve(TutorialHub.BatchId,
    function : TAsynBatchJob
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

// Synchronously code
//  var Value := MistralAI.Batch.Retrieve(TutorialHub.BatchId);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br/>

### Batch Job Result File

If the batch processing completes successfully, an ID pointing to a file containing the results is provided. This ID can be accessed through the OutputFile field of the TBatchJob class.
In this case, you can use the [File Download API](#File-Download), demonstrated in this code example, to retrieve the file.
Alternatively, you can download the file directly from the platform.

<br/>

>[!WARNING]
> The APIs do not support the deletion of batch jobs, and this limitation extends to the platform itself. As a result, creating a large number of batch jobs over time may lead to management challenges.
>

<br/>

## Agents

The official documentation provided by Mistral regarding agents is available [here](https://docs.mistral.ai/capabilities/agents/).

> [!TIP]
> The execution of an agent can be done both synchronously and asynchronously. See the class `TAgentRoute` in the **MistralAI.Agents** unit.

<br/>

Before using this asynchronous code and after adapting it to your specific needs, you must create an agent on the platform and retrieve its `ID`.

```Pascal
// MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  MistralAI.Agent.AsyncCreateStream(
    procedure (Params: TAgentParams)
    begin
      Params.MaxTokens(1024);
      Params.Messages([
        Payload.User('Content_1')
        ]);
      Params.AgentId('Agent_Id');
      Params.Stream;
    end,
    function : TAsynChatStream
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnProgress := DisplayStream;
      Result.OnError := Display;
    end);
```

<br/>

> [!WARNING]
> As of 08/13/2024, only the API for executing an agent is available; however, no API for creating an agent has been made available.  
>
> (See the [***MistralAI.Agents.pas***](https://github.com/MaxiDonkey/DelphiMistralAI/blob/main/source/MistralAI.Agents.pas) unit)
>
> To create an agent you must go through the [platform](https://console.mistral.ai/build/agents/new)

<br/>

# Contributing

Pull requests are welcome. If you're planning to make a major change, please open an issue first to discuss your proposed changes.

<br/>

# License

This project is licensed under the [MIT](https://choosealicense.com/licenses/mit/) License.

unit MistralAI.Agents;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, System.Threading,
  REST.Json.Types, MistralAI.API.Params, MistralAI.API, MistralAI.Functions.Core,
  MistralAI.Functions.Tools, MistralAI.Chat, MistralAI.Params.Core,
  MistralAI.Async.Support, MistralAI.Types;

type
  /// <summary>
  /// Alias for <c>TChatMessagePayload</c>, representing an agent message payload.
  /// </summary>
  TAgentMessagePayload = TChatMessagePayload;

  /// <summary>
  /// Represents the parameters used to configure an agent request.
  /// </summary>
  /// <remarks>
  /// Use this class to set various options for the agent, such as model configuration, messages, and other settings.
  /// </remarks>
  TAgentParams = class(TJSONParam)
    /// <summary>
    /// Sets the maximum number of tokens to generate in the completion.
    /// The token count of your prompt plus <c>max_tokens</c> cannot exceed the model's context length.
    /// </summary>
    /// <param name="Value">
    /// The maximum number of tokens to generate in the completion.
    /// </param>
    /// <returns>
    /// An instance of <c>TAgentParams</c> with the <c>MaxTokens</c> parameter set.
    /// </returns>
    function MaxTokens(const Value: Integer): TAgentParams;
    /// <summary>
    /// Enables or disables streaming of partial progress.
    /// </summary>
    /// <param name="Value">
    /// Set to <c>True</c> to enable streaming mode; otherwise, set to <c>False</c>.
    /// </param>
    /// <returns>
    /// An instance of <c>TAgentParams</c> with the <c>Stream</c> parameter set.
    /// </returns>
    /// <remarks>
    /// Default is <c>False</c>. When streaming is enabled, partial progress is sent as data-only server-side events.
    /// </remarks>
    function Stream(const Value: Boolean = True): TAgentParams;
    /// <summary>
    /// Sets a string token at which to stop text generation.
    /// </summary>
    /// <param name="Value">
    /// A string token at which to stop the text generation.
    /// </param>
    /// <returns>
    /// An instance of <c>TAgentParams</c> with the <c>Stop</c> parameter set.
    /// </returns>
    function Stop(const Value: string): TAgentParams; overload;
    /// <summary>
    /// Sets an array of string tokens at which to stop text generation.
    /// </summary>
    /// <param name="Value">
    /// An array of string tokens at which to stop the text generation.
    /// </param>
    /// <returns>
    /// An instance of <c>TAgentParams</c> with the <c>Stop</c> parameter set.
    /// </returns>
    function Stop(const Value: TArray<string>): TAgentParams; overload;
    /// <summary>
    /// Sets the seed for random sampling to produce deterministic results.
    /// </summary>
    /// <param name="Value">
    /// The seed value for random sampling.
    /// </param>
    /// <returns>
    /// An instance of <c>TAgentParams</c> with the <c>RandomSeed</c> parameter set.
    /// </returns>
    function RandomSeed(const Value: Integer): TAgentParams;
    /// <summary>
    /// Sets the messages to generate completions for, encoded as a list of dictionaries with role and content.
    /// </summary>
    /// <param name="Value">
    /// An array of <c>TAgentMessagePayload</c> representing the messages in the conversation.
    /// </param>
    /// <returns>
    /// An instance of <c>TAgentParams</c> with the <c>Messages</c> parameter set.
    /// </returns>
    function Messages(const Value: TArray<TChatMessagePayload>): TAgentParams;
    /// <summary>
    /// Specifies the format that the model must output.
    /// </summary>
    /// <param name="Value">
    /// Specifies the desired response format type. For example, 'json_object' to enforce JSON output.
    /// </param>
    /// <returns>
    /// An instance of <c>TAgentParams</c> with the <c>ResponseFormat</c> parameter set.
    /// </returns>
    /// <remarks>
    /// Default value is { "type": "text" } if <c>ResponseFormat</c> is not called.
    /// </remarks>
    function ResponseFormat(const Value: string = 'json_object'): TAgentParams;
    /// <summary>
    /// Sets the list of available tools for the model.
    /// </summary>
    /// <param name="Value">
    /// An array of <c>TChatMessageTool</c> representing the available tools for the model.
    /// </param>
    /// <returns>
    /// An instance of <c>TAgentParams</c> with the <c>Tools</c> parameter set.
    /// </returns>
    function Tools(const Value: TArray<TChatMessageTool>): TAgentParams;
    /// <summary>
    /// Specifies if and how functions are called during the conversation.
    /// </summary>
    /// <param name="Value">
    /// Specifies how tools are used during the conversation. Options are <c>none</c>, <c>auto</c>, or <c>any</c>.
    /// </param>
    /// <returns>
    /// An instance of <c>TAgentParams</c> with the <c>ToolChoice</c> parameter set.
    /// </returns>
    /// <remarks>
    /// Default is <c>auto</c>. If set to <c>none</c>, the model will not call a function. If set to <c>auto</c>, the model can choose to generate a message or call a function. If set to <c>any</c>, the model is forced to call a function.
    /// </remarks>
    function ToolChoice(const Value: TToolChoice): TAgentParams;  overload;
    /// <summary>
    /// Configures how the model interacts when required is on.
    /// </summary>
    /// <param name="Value">
    /// The <c>TToolChoice</c> setting for function interaction, with a default of "auto".
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function ToolChoice(const FunctionName: string): TChatParams; overload;
    /// <summary>
    /// Presence_penalty determines how much the model penalizes the repetition of words or phrases
    /// </summary>
    /// <param name="Value">
    /// number (Presence Penalty) [ -2 .. 2 ]; Default: 0
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// A higher presence penalty encourages the model to use a wider variety of words and phrases,
    /// making the output more diverse and creative.
    /// </remarks>
    function PresencePenalty(const Value: Double): TAgentParams;
    /// <summary>
    /// Frequency_penalty penalizes the repetition of words based on their frequency in the generated text.
    /// </summary>
    /// <param name="Value">
    /// number (Presence Penalty) [ -2 .. 2 ]; Default: 0
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// A higher frequency penalty discourages the model from repeating words that have already appeared
    /// frequently in the output, promoting diversity and reducing repetition.
    /// </remarks>
    function FrequencyPenalty(const Value: Double): TAgentParams;
    /// <summary>
    /// Number of completions to return for each request, input tokens are only billed once.
    /// </summary>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function N(const Value: Integer): TAgentParams;
    /// <summary>
    /// Sets the ID of the agent to use for this completion.
    /// </summary>
    /// <param name="Value">
    /// The identifier of the agent to be used for the completion.
    /// </param>
    /// <returns>
    /// An instance of <c>TAgentParams</c> with the <c>AgentId</c> parameter set.
    /// </returns>
    function AgentId(const Value: string): TAgentParams;
  end;

  /// <summary>
  /// Provides methods to interact with agents, including creating completions and handling asynchronous operations.
  /// </summary>
  /// <remarks>
  /// Use this class to manage agent interactions, including synchronous and asynchronous requests.
  /// </remarks>
  TAgentRoute = class(TMistralAIAPIRoute)
  public
    /// <summary>
    /// Initiates an asynchronous request to create an agent completion based on the provided parameters.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the parameters for the agent request, such as model selection, messages, and other parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for the asynchronous agent operation, such as on success and on error.
    /// </param>
    /// <remarks>
    /// This procedure initiates an asynchronous request to generate a chat completion based on the provided parameters. The response or error is handled by the provided callbacks.
    /// <code>
    /// // Example usage:
    /// MistralAI.Agent.AsyncCreate(
    ///   procedure(Params: TAgentParams)
    ///   begin
    ///     // Define agent parameters
    ///   end,
    ///   function: TAsynAgent
    ///   begin
    ///     Result.OnSuccess :=
    ///        procedure(Sender: TObject; Agent: TAgent)
    ///        begin
    ///         // Handle success
    ///        end;
    ///     Result.OnError :=
    ///        procedure(Sender: TObject; const ErrorMsg: string)
    ///        begin
    ///          // Handle error
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncCreate(ParamProc: TProc<TAgentParams>; CallBacks: TFunc<TAsynChat>);
    /// <summary>
    /// Creates an asynchronous streaming agent completion request.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the agent request, including the model, messages, and additional options such as max tokens and streaming mode.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a <c>TAsynAgentStream</c> record which contains event handlers for managing different stages of the streaming process: progress updates, success, errors, and cancellation.
    /// </param>
    /// <remarks>
    /// This procedure initiates an asynchronous chat operation in streaming mode, where tokens are progressively received and processed.
    /// The provided event handlers allow for handling progress (i.e., receiving tokens in real time), detecting success, managing errors, and enabling cancellation logic.
    /// <code>
    /// // Example usage:
    /// MistralAI.Agent.AsyncStreamCreate(
    ///   procedure(Params: TAgentParams)
    ///   begin
    ///     // Define agent parameters
    ///   end,
    ///   function: TAsynAgentStream
    ///   begin
    ///     Result.OnProgress :=
    ///        procedure (Sender: TObject; Chat : TChat)
    ///        begin
    ///          // Handle progress
    ///        end;
    ///     Result.OnSuccess :=
    ///        procedure(Sender: TObject)
    ///        begin
    ///         // Handle success
    ///        end;
    ///     Result.OnError :=
    ///        procedure(Sender: TObject; const ErrorMsg: string)
    ///        begin
    ///          // Handle error
    ///        end;
    ///     Result.OnDoCancel :=
    ///        function : Boolean
    ///        begin
    ///          Result := CheckBox1.Checked; // Click the CheckBox to cancel
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncCreateStream(ParamProc: TProc<TAgentParams>; CallBacks: TFunc<TAsynChatStream>);
    /// <summary>
    /// Creates a completion for an agent synchronously.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the parameters for the agent request.
    /// </param>
    /// <returns>
    /// An instance of <c>TAgent</c> containing the completion result.
    /// </returns>
    /// <exception cref="MistralAIExceptionAPI"> MistralAIExceptionAPI </exception>
    /// <exception cref="MistralAIExceptionInvalidRequestError"> MistralAIExceptionInvalidRequestError </exception>
    /// <remarks>
    /// This function sends a synchronous request to create an agent completion based on the provided parameters.
    ///
    /// <code>
    ///   var Agent := MistralAI.Agent.Create(
    ///     procedure (Params: TAgentParams)
    ///     begin
    ///       // Define agent parameters
    ///     end);
    ///   try
    ///     for var Choice in Agent.Choices do
    ///       WriteLn(Choice.Message.Content);
    ///   finally
    ///     Agent.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Create(ParamProc: TProc<TAgentParams>): TChat;
    /// <summary>
    /// Creates a completion for an agent with a streamed response.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the parameters for the agent request.
    /// </param>
    /// <param name="Event">
    /// An event handler to process each streamed response.
    /// </param>
    /// <returns>
    /// <c>True</c> if the streaming was successful; otherwise, <c>False</c>.
    /// </returns>
    /// <remarks>
    /// The <c>Agent</c> object will be <c>nil</c> when all data is received.
    ///
    /// <code>
    ///    MistralAI.Agent.Create(
    ///     procedure (Params: TAgentParams)
    ///     begin
    ///       // Define agent parameters
    ///     end,
    ///
    ///     procedure(var Agent: TAgent; IsDone: Boolean; var Cancel: Boolean)
    ///     begin
    ///       // handle displaying
    ///     end);
    /// </code>
    /// </remarks>
    function CreateStream(ParamProc: TProc<TAgentParams>; Event: TChatEvent): Boolean;
  end;

implementation

uses
  system.StrUtils, Rest.Json;

{ TAgentParams }

function TAgentParams.AgentId(const Value: string): TAgentParams;
begin
  Result := TAgentParams(Add('agent_id', Value));
end;

function TAgentParams.FrequencyPenalty(const Value: Double): TAgentParams;
begin
  Result := TAgentParams(Add('frequency_penalty', Value));
end;

function TAgentParams.MaxTokens(const Value: Integer): TAgentParams;
begin
  Result := TAgentParams(Add('max_tokens', Value));
end;

function TAgentParams.Messages(
  const Value: TArray<TChatMessagePayload>): TAgentParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TAgentParams(Add('messages', JSONArray));
end;

function TAgentParams.N(const Value: Integer): TAgentParams;
begin
  Result := TAgentParams(Add('n', Value));
end;

function TAgentParams.PresencePenalty(const Value: Double): TAgentParams;
begin
  Result := TAgentParams(Add('presence_penalty', Value));
end;

function TAgentParams.RandomSeed(const Value: Integer): TAgentParams;
begin
  Result := TAgentParams(Add('random_seed', Value));
end;

function TAgentParams.ResponseFormat(const Value: string): TAgentParams;
begin
  var JSON := TJSONObject.Create;
  JSON.AddPair('type', Value);
  Result := TAgentParams(Add('response_format', JSON));
end;

function TAgentParams.Stop(const Value: TArray<string>): TAgentParams;
begin
  Result := TAgentParams(Add('stop', Value));
end;

function TAgentParams.Stop(const Value: string): TAgentParams;
begin
  Result := TAgentParams(Add('stop', Value));
end;

function TAgentParams.Stream(const Value: Boolean): TAgentParams;
begin
  Result := TAgentParams(Add('stream', Value));
end;

function TAgentParams.ToolChoice(const Value: TToolChoice): TAgentParams;
begin
  Result := TAgentParams(Add('tool_choice', Value.ToString));
end;

function TAgentParams.ToolChoice(const FunctionName: string): TChatParams;
begin
  var Tool := TJSONParam.Create
        .Add('type', 'function')
        .Add('function', TJSONObject.Create
          .AddPair('Name', FunctionName));
  Result := TChatParams(Add('tool_choice', Tool.Detach));
end;

function TAgentParams.Tools(
  const Value: TArray<TChatMessageTool>): TAgentParams;
var
  Item: TChatMessageTool;
  Items: TJSONArray;
begin
  Items := TJSONArray.Create;
  try
    for Item in Value do
      begin
        Items.Add(Item.ToJson);
      end;
    Result := TAgentParams(Add('tools', Items));
  except
    on E: Exception do
      begin
        Items.Free;
        raise;
      end;
  end;
end;

{ TAgentRoute }

procedure TAgentRoute.AsyncCreate(ParamProc: TProc<TAgentParams>;
  CallBacks: TFunc<TAsynChat>);
begin
  with TAsyncCallBackExec<TAsynChat, TChat>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TChat
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TAgentRoute.AsyncCreateStream(ParamProc: TProc<TAgentParams>;
  CallBacks: TFunc<TAsynChatStream>);
begin
  var CallBackParams := TUseParamsFactory<TAsynChatStream>.CreateInstance(CallBacks);

  var Sender := CallBackParams.Param.Sender;
  var OnStart := CallBackParams.Param.OnStart;
  var OnSuccess := CallBackParams.Param.OnSuccess;
  var OnProgress := CallBackParams.Param.OnProgress;
  var OnError := CallBackParams.Param.OnError;
  var OnCancellation := CallBackParams.Param.OnCancellation;
  var OnDoCancel := CallBackParams.Param.OnDoCancel;

  var Task: ITask := TTask.Create(
          procedure()
          begin
            {--- Pass the instance of the current class in case no value was specified. }
            if not Assigned(Sender) then
              Sender := Self;

            {--- Trigger OnStart callback }
            if Assigned(OnStart) then
              TThread.Queue(nil,
                procedure
                begin
                  OnStart(Sender);
                end);
            try
              var Stop := False;

              {--- Processing }
              CreateStream(ParamProc,
                procedure (var Agent: TChat; IsDone: Boolean; var Cancel: Boolean)
                begin
                  {--- Check that the process has not been canceled }
                  if Assigned(OnDoCancel) then
                    TThread.Queue(nil,
                        procedure
                        begin
                          Stop := OnDoCancel();
                        end);
                  if Stop then
                    begin
                      {--- Trigger when processus was stopped }
                      if Assigned(OnCancellation) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnCancellation(Sender)
                        end);
                      Cancel := True;
                      Exit;
                    end;
                  if not IsDone and Assigned(Agent) then
                    begin
                      var LocalAgent := Agent;
                      Agent := nil;

                      {--- Triggered when processus is progressing }
                      if Assigned(OnProgress) then
                        TThread.Synchronize(TThread.Current,
                        procedure
                        begin
                          try
                            OnProgress(Sender, LocalAgent);
                          finally
                            {--- Makes sure to release the instance containing the data obtained
                                 following processing}
                            LocalAgent.Free;
                          end;
                        end);
                    end
                  else
                  if IsDone then
                    begin
                      {--- Trigger OnEnd callback when the process is done }
                      if Assigned(OnSuccess) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnSuccess(Sender);
                        end);
                    end;
                end);
            except
              on E: Exception do
                begin
                  var Error := AcquireExceptionObject;
                  try
                    var ErrorMsg := (Error as Exception).Message;

                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(OnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        OnError(Sender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
          end);
  Task.Start;
end;

function TAgentRoute.Create(ParamProc: TProc<TAgentParams>): TChat;
begin
  Result := API.Post<TChat, TAgentParams>('agents/completions', ParamProc);
end;

function TAgentRoute.CreateStream(ParamProc: TProc<TAgentParams>;
  Event: TChatEvent): Boolean;
var
  Response: TStringStream;
  RetPos: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    RetPos := 0;
    Result := API.Post<TAgentParams>('agents/completions', ParamProc, Response,
      procedure(const Sender: TObject; AContentLength: Int64; AReadCount: Int64; var AAbort: Boolean)
      var
        IsDone: Boolean;
        Data: string;
        Agent: TChat;
        TextBuffer: string;
        Line: string;
        Ret: Integer;
      begin
        try
          TextBuffer := Response.DataString;
        except
          on E: EEncodingError do
            Exit;
        end;

        repeat
          Ret := TextBuffer.IndexOf(#10, RetPos);
          if Ret < 0 then
            Continue;
          Line := TextBuffer.Substring(RetPos, Ret - RetPos);
          RetPos := Ret + 1;

          if Line.IsEmpty or Line.StartsWith(#10) then
            Continue;
          Agent := nil;
          Data := Line.Replace('data: ', '').Trim([' ', #13, #10]);
          IsDone := Data = '[DONE]';

          if not IsDone then
          try
            Agent := TJson.JsonToObject<TChat>(Data);
          except
            Agent := nil;
          end;

          try
            Event(Agent, IsDone, AAbort);
          finally
            Agent.Free;
          end;
        until Ret < 0;

      end);
  finally
    Response.Free;
  end;
end;

end.

unit MistralAI.API.Params;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.Classes, System.JSON, System.SysUtils, System.Types, System.RTTI,
  REST.JsonReflect, REST.Json.Interceptors, System.Generics.Collections,
  System.Threading;

type
  TJSONInterceptorStringToString = class(TJSONInterceptor)
    constructor Create; reintroduce;
  protected
    RTTI: TRttiContext;
  end;

type
  /// <summary>
  /// Represents a reference to a procedure that takes a single argument of type T and returns no value.
  /// </summary>
  /// <param name="T">
  /// The type of the argument that the referenced procedure will accept.
  /// </param>
  /// <remarks>
  /// This type is useful for defining callbacks or procedures that operate on a variable of type T, allowing for more flexible and reusable code.
  /// </remarks>
  TProcRef<T> = reference to procedure(var Arg: T);

  TJSONParam = class
  private
    FJSON: TJSONObject;
    procedure SetJSON(const Value: TJSONObject);
    function GetCount: Integer;

  public
    constructor Create; virtual;
    destructor Destroy; override;
    function Add(const Key: string; const Value: string): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: Integer): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: Extended): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: Boolean): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: TDateTime; Format: string): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: TJSONValue): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: TJSONParam): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<string>): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<Integer>): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<Extended>): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<TJSONValue>): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<TJSONParam>): TJSONParam; overload; virtual;
    function GetOrCreateObject(const Name: string): TJSONObject;
    function GetOrCreate<T: TJSONValue, constructor>(const Name: string): T;
    procedure Delete(const Key: string); virtual;
    procedure Clear; virtual;
    property Count: Integer read GetCount;
    function Detach: TJSONObject;
    property JSON: TJSONObject read FJSON write SetJSON;
    function ToJsonString(FreeObject: Boolean = False): string; virtual;
    function ToFormat(FreeObject: Boolean = False): string;
    function ToStringPairs: TArray<TPair<string, string>>;
    function ToStream: TStringStream;
  end;

  TUrlParam = class
  private
    FValue: string;
    procedure Check(const Name: string);
    function GetValue: string;
  public
    function Add(const Name, Value: string): TUrlParam; overload;
    function Add(const Name: string; Value: Integer): TUrlParam; overload;
    function Add(const Name: string; Value: Boolean): TUrlParam; overload;
    function Add(const Name: string; Value: Double): TUrlParam; overload;
    function Add(const Name: string; Value: TArray<string>): TUrlParam; overload;
    property Value: string read GetValue;
    constructor Create; virtual;
  end;

const
  DATE_FORMAT = 'YYYY-MM-DD';
  TIME_FORMAT = 'HH:NN:SS';
  DATE_TIME_FORMAT = DATE_FORMAT + ' ' + TIME_FORMAT;

implementation

uses
  System.DateUtils;

{ TJSONInterceptorStringToString }

constructor TJSONInterceptorStringToString.Create;
begin
  ConverterType := ctString;
  ReverterType := rtString;
end;

{ Fetch }

type
  Fetch<T> = class
    type
      TFetchProc = reference to procedure(const Element: T);
  public
    class procedure All(const Items: TArray<T>; Proc: TFetchProc);
  end;

{ Fetch<T> }

class procedure Fetch<T>.All(const Items: TArray<T>; Proc: TFetchProc);
var
  Item: T;
begin
  for Item in Items do
    Proc(Item);
end;

{ TJSONParam }

function TJSONParam.Add(const Key, Value: string): TJSONParam;
begin
  Delete(Key);
  FJSON.AddPair(Key, Value);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: TJSONValue): TJSONParam;
begin
  Delete(Key);
  FJSON.AddPair(Key, Value);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: TJSONParam): TJSONParam;
begin
  Add(Key, TJSONValue(Value.JSON.Clone));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: TDateTime; Format: string): TJSONParam;
begin
  if Format.IsEmpty then
    Format := DATE_TIME_FORMAT;
  Add(Key, FormatDateTime(Format, System.DateUtils.TTimeZone.local.ToUniversalTime(Value)));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: Boolean): TJSONParam;
begin
  Add(Key, TJSONBool.Create(Value));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: Integer): TJSONParam;
begin
  Add(Key, TJSONNumber.Create(Value));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: Extended): TJSONParam;
begin
  Add(Key, TJSONNumber.Create(Value));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<TJSONValue>): TJSONParam;
var
  JArr: TJSONArray;
begin
  JArr := TJSONArray.Create;
  Fetch<TJSONValue>.All(Value, JArr.AddElement);
  Add(Key, JArr);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<TJSONParam>): TJSONParam;
var
  JArr: TJSONArray;
  Item: TJSONParam;
begin
  JArr := TJSONArray.Create;
  for Item in Value do
  try
    JArr.AddElement(Item.JSON);
    Item.JSON := nil;
  finally
    Item.Free;
  end;
  Add(Key, JArr);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<Extended>): TJSONParam;
var
  JArr: TJSONArray;
  Item: Extended;
begin
  JArr := TJSONArray.Create;
  for Item in Value do
    JArr.Add(Item);
  Add(Key, JArr);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<Integer>): TJSONParam;
var
  JArr: TJSONArray;
  Item: Integer;
begin
  JArr := TJSONArray.Create;
  for Item in Value do
    JArr.Add(Item);
  Add(Key, JArr);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<string>): TJSONParam;
var
  JArr: TJSONArray;
  Item: string;
begin
  JArr := TJSONArray.Create;
  for Item in Value do
    JArr.Add(Item);
  Add(Key, JArr);
  Result := Self;
end;

procedure TJSONParam.Clear;
begin
  FJSON.Free;
  FJSON := TJSONObject.Create;
end;

constructor TJSONParam.Create;
begin
  FJSON := TJSONObject.Create;
end;

procedure TJSONParam.Delete(const Key: string);
var
  Item: TJSONPair;
begin
  Item := FJSON.RemovePair(Key);
  if Assigned(Item) then
    Item.Free;
end;

destructor TJSONParam.Destroy;
begin
  if Assigned(FJSON) then
    FJSON.Free;
  inherited;
end;

function TJSONParam.Detach: TJSONObject;
begin
  Result := JSON;
  JSON := nil;
  var Task: ITask := TTask.Create(
    procedure()
    begin
      Sleep(30);
      TThread.Queue(nil,
      procedure
      begin
        Self.Free;
      end);
    end
  );
  Task.Start;
end;

function TJSONParam.GetCount: Integer;
begin
  Result := FJSON.Count;
end;

function TJSONParam.GetOrCreate<T>(const Name: string): T;
begin
  if not FJSON.TryGetValue<T>(Name, Result) then
  begin
    Result := T.Create;
    FJSON.AddPair(Name, Result);
  end;
end;

function TJSONParam.GetOrCreateObject(const Name: string): TJSONObject;
begin
  Result := GetOrCreate<TJSONObject>(Name);
end;

procedure TJSONParam.SetJSON(const Value: TJSONObject);
begin
  FJSON := Value;
end;

function TJSONParam.ToFormat(FreeObject: Boolean): string;
begin
  Result := FJSON.Format(4);
  if FreeObject then
    Free;
end;

function TJSONParam.ToJsonString(FreeObject: Boolean): string;
begin
  Result := FJSON.ToJSON;
  if FreeObject then
    Free;
end;

function TJSONParam.ToStream: TStringStream;
begin
  Result := TStringStream.Create;
  try
    Result.WriteString(ToJsonString);
    Result.Position := 0;
  except
    Result.Free;
    raise;
  end;
end;

function TJSONParam.ToStringPairs: TArray<TPair<string, string>>;
begin
  for var Pair in FJSON do
    Result := Result + [TPair<string, string>.Create(Pair.JsonString.Value, Pair.JsonValue.AsType<string>)];
end;

{ TUrlParam }

function TUrlParam.Add(const Name, Value: string): TUrlParam;
begin
  Check(Name);
  var S := Format('%s=%s', [Name, Value]);
  if FValue.IsEmpty then
    FValue := S else
    FValue := FValue + '&' + S;
  Result := Self;
end;

function TUrlParam.Add(const Name: string; Value: Integer): TUrlParam;
begin
  Result := Add(Name, Value.ToString);
end;

function TUrlParam.Add(const Name: string; Value: Boolean): TUrlParam;
begin
  Result := Add(Name, BoolToStr(Value, true));
end;

function TUrlParam.Add(const Name: string; Value: Double): TUrlParam;
begin
  Result := Add(Name, Value.ToString);
end;

procedure TUrlParam.Check(const Name: string);
begin
  if FValue.Contains(Name) then
    begin
      var Items := FValue.Split(['&']);
      FValue := EmptyStr;
      for var Item in Items do
        begin
          if not Item.StartsWith(Name) then
            begin
              if FValue.IsEmpty then
                FValue := Item else
                FValue := FValue + '&' + Item;
            end;
        end;
    end;
end;

constructor TUrlParam.Create;
begin
  FValue := EmptyStr;
end;

function TUrlParam.GetValue: string;
begin
  Result := FValue;
  if not Result.IsEmpty then
    Result := '?' + Result;
end;

function TUrlParam.Add(const Name: string; Value: TArray<string>): TUrlParam;
begin
  Result := Add(Name, string.Join(',', Value).Replace(#32, #0));
end;

end.

unit MistralAI.API;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.Classes, System.Net.HttpClient, System.Net.URLClient, System.Net.Mime,
  System.JSON, MistralAI.API.Params, MistralAI.Errors, System.SysUtils;

type
  MistralAIException = class(Exception)
  private
    FCode: Int64;
    FMsg: string;
  public
    constructor Create(const ACode: Int64; const AError: TErrorCore); reintroduce; overload;
    constructor Create(const ACode: Int64; const Value: string); reintroduce; overload;
    property Code: Int64 read FCode write FCode;
    property Msg: string read FMsg write FMsg;
  end;

  MistralAIValidationException = class(Exception)
  private
    FCode: Int64;
  protected
    function DetailItemToStr(const Value: TDetail): string;
    function LocToStr(const Value: TArray<string>): string;
    function ToText(const AError: TError422): string;
    function TypeToStr(const Value: string): string;
  public
    constructor Create(const ACode: Int64; const AError: TErrorCore); reintroduce;
    property Code: Int64 read FCode write FCode;
  end;

  /// <summary>
  /// The `MistralAIExceptionAPI` class represents a generic API-related exception.
  /// It is thrown when there is an issue with the API configuration or request process,
  /// such as a missing API token, invalid base URL, or other configuration errors.
  /// This class serves as a base for more specific API exceptions.
  /// </summary>
  MistralAIExceptionAPI = class(Exception);

  /// <summary>
  /// An InvalidRequestError indicates that your request was malformed or
  /// missing some required parameters, such as a token or an input.
  /// This could be due to a typo, a formatting error, or a logic error in your code.
  /// </summary>
  MistralAIExceptionInvalidRequestError = class(MistralAIException);

  /// <summary>
  /// A `RateLimitError` indicates that you have hit your assigned rate limit.
  /// This means that you have sent too many tokens or requests in a given period of time,
  /// and our services have temporarily blocked you from sending more.
  /// </summary>
  MistralAIExceptionRateLimitError = class(MistralAIException);

  /// <summary>
  /// An `AuthenticationError` indicates that your API key or token was invalid,
  /// expired, or revoked. This could be due to a typo, a formatting error, or a security breach.
  /// </summary>
  MistralAIExceptionAuthenticationError = class(MistralAIException);

  /// <summary>
  /// This error message indicates that your account is not part of an organization
  /// </summary>
  MistralAIExceptionPermissionError = class(MistralAIException);

  /// <summary>
  /// This error message indicates that our servers are experiencing high
  /// traffic and are unable to process your request at the moment
  /// </summary>
  MistralAIExceptionTryAgain = class(MistralAIException);

  /// <summary>
  /// This error occurs when a request to the API can not be processed. This is a client-side error,
  /// meaning the problem is with the request itself, and not the API.
  /// </summary>
  MistralUnprocessableEntityError = class(MistralAIValidationException);

  /// <summary>
  /// An `InvalidResponse` error occurs when the API response is either empty or not in the expected format.
  /// This error indicates that the API did not return a valid response that can be processed, possibly due to a server-side issue,
  /// a malformed request, or unexpected input data.
  /// </summary>
  MistralAIExceptionInvalidResponse = class(MistralAIException);

  TMistralAIAPI = class
  public
    const
      URL_BASE = 'https://api.mistral.ai/v1';
      URL_BASE_CODESTRAL = 'https://codestral.mistral.ai/v1';
  private
    FHTTPClient: THTTPClient;
    FToken: string;
    FBaseUrl: string;
    FOrganization: string;
    FCustomHeaders: TNetHeaders;
    procedure SetToken(const Value: string);
    procedure SetBaseUrl(const Value: string);
    procedure SetOrganization(const Value: string);
    procedure RaiseError(Code: Int64; Error: TErrorCore);
    procedure ParseError(const Code: Int64; const ResponseText: string);
    procedure SetCustomHeaders(const Value: TNetHeaders);

  private
    function JSONValueAsString(const Value: string): string; overload;
    function JSONValueAsString(const Value: string; const Field: string): string; overload;
    function JSONValueAsString(const Value: string; const Field: TArray<string>): string; overload;

  protected
    function GetHeaders: TNetHeaders;
    function GetRequestURL(const Path: string): string;
    function Get(const Path: string; Response: TStringStream): Integer; overload;
    function Delete(const Path: string; Response: TStringStream): Integer; overload;
    function Post(const Path: string; Response: TStringStream): Integer; overload;
    function Post(const Path: string; Body: TJSONObject; Response: TStringStream; OnReceiveData: TReceiveDataCallback = nil): Integer; overload;
    function Post(const Path: string; Body: TMultipartFormData; Response: TStringStream): Integer; overload;
    function Patch(const Path: string; Body: TJSONObject; Response: TStringStream; OnReceiveData: TReceiveDataCallback = nil): Integer; overload;
    function ParseResponse<T: class, constructor>(const Code: Int64; const ResponseText: string): T;
    procedure CheckAPI;

  public
    function Get<TResult: class, constructor>(const Path: string; const MetadataAsObject: Boolean = False): TResult; overload;
    function Get<TResult: class, constructor; TParams: TUrlParam>(const Path: string; ParamProc: TProc<TParams>; const MetadataAsObject: Boolean = False): TResult; overload;
    function GetFile(const Path: string; Response: TStream): Integer; overload;
    function GetFile<TResult: class, constructor>(const Path: string; const JSONFieldName: string = 'data'): TResult; overload;
    function Delete<TResult: class, constructor>(const Path: string): TResult; overload;
    function Post<TParams: TJSONParam>(const Path: string; ParamProc: TProc<TParams>; Response: TStringStream; Event: TReceiveDataCallback): Boolean; overload;
    function Post<TResult: class, constructor; TParams: TJSONParam>(const Path: string; ParamProc: TProc<TParams>; const MetadataAsObject: Boolean = False): TResult; overload;
    function Patch<TResult: class, constructor; TParams: TJSONParam>(const Path: string; ParamProc: TProc<TParams>; const MetadataAsObject: Boolean = False): TResult; overload;
    function Post<TResult: class, constructor>(const Path: string; const MetadataAsObject: Boolean = False): TResult; overload;
    function PostForm<TResult: class, constructor; TParams: TMultipartFormData, constructor>(const Path: string; ParamProc: TProc<TParams>): TResult; overload;

  public
    constructor Create; overload;
    constructor Create(const AToken: string); overload;
    destructor Destroy; override;
    property Token: string read FToken write SetToken;
    property BaseUrl: string read FBaseUrl write SetBaseUrl;
    property Organization: string read FOrganization write SetOrganization;
    property Client: THTTPClient read FHTTPClient;
    property CustomHeaders: TNetHeaders read FCustomHeaders write SetCustomHeaders;
  end;

  TMistralAIAPIRoute = class
  private
    FAPI: TMistralAIAPI;
    procedure SetAPI(const Value: TMistralAIAPI);
  public
    property API: TMistralAIAPI read FAPI write SetAPI;
    constructor CreateRoute(AAPI: TMistralAIAPI); reintroduce;
  end;

implementation

uses
  System.StrUtils, REST.Json, MistralAI.NetEncoding.Base64;

const
  JSONFieldsToString : TArray<string> = ['"metadata": {'];

constructor TMistralAIAPI.Create;
begin
  inherited;
  FHTTPClient := THTTPClient.Create;
  FToken := EmptyStr;
  FBaseUrl := URL_BASE;
end;

constructor TMistralAIAPI.Create(const AToken: string);
begin
  Create;
  Token := AToken;
end;

destructor TMistralAIAPI.Destroy;
begin
  FHTTPClient.Free;
  inherited;
end;

function TMistralAIAPI.Post(const Path: string; Body: TJSONObject; Response: TStringStream; OnReceiveData: TReceiveDataCallback): Integer;
var
  Headers: TNetHeaders;
  Stream: TStringStream;
begin
  CheckAPI;
  Headers := GetHeaders + [TNetHeader.Create('Content-Type', 'application/json')];
  Headers := Headers + [TNetHeader.Create('Accept', 'application/json')];
  Stream := TStringStream.Create;
  FHTTPClient.ReceiveDataCallBack := OnReceiveData;
  try
    Stream.WriteString(Body.ToJSON);
    Stream.Position := 0;
    Result := FHTTPClient.Post(GetRequestURL(Path), Stream, Response, Headers).StatusCode;
  finally
    FHTTPClient.ReceiveDataCallBack := nil;
    Stream.Free;
  end;
end;

function TMistralAIAPI.Get(const Path: string; Response: TStringStream): Integer;
var
  Headers: TNetHeaders;
begin
  CheckAPI;
  Headers := GetHeaders;
  Result := FHTTPClient.Get(GetRequestURL(Path), Response, Headers).StatusCode;
end;

function TMistralAIAPI.Post(const Path: string; Body: TMultipartFormData; Response: TStringStream): Integer;
var
  Headers: TNetHeaders;
begin
  CheckAPI;
  Headers := GetHeaders;
  Result := FHTTPClient.Post(GetRequestURL(Path), Body, Response, Headers).StatusCode;
end;

function TMistralAIAPI.Post(const Path: string; Response: TStringStream): Integer;
var
  Headers: TNetHeaders;
  Stream: TStringStream;
begin
  CheckAPI;
  Headers := GetHeaders;
  Stream := nil;
  try
    Result := FHTTPClient.Post(GetRequestURL(Path), Stream, Response, Headers).StatusCode;
  finally
  end;
end;

function TMistralAIAPI.Post<TResult, TParams>(const Path: string; ParamProc: TProc<TParams>; const MetadataAsObject: Boolean): TResult;
var
  Response: TStringStream;
  Params: TParams;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    Code := Post(Path, Params.JSON, Response);
    if MetadataAsObject then
      {--- Returns Metadata as JSON object }
      Result := ParseResponse<TResult>(Code, Response.DataString) else
      {--- Returns Metadata as string }
      Result := ParseResponse<TResult>(Code, JSONValueAsString(Response.DataString));
  finally
    Params.Free;
    Response.Free;
  end;
end;

function TMistralAIAPI.Post<TParams>(const Path: string; ParamProc: TProc<TParams>; Response: TStringStream; Event: TReceiveDataCallback): Boolean;
var
  Params: TParams;
  Code: Integer;
begin
  Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    Code := Post(Path, Params.JSON, Response, Event);
    case Code of
      200..299:
        Result := True;
    else
      begin
        Result := False;
        var Recieved := TStringStream.Create;
        try
          Response.Position := 0;
          Recieved.LoadFromStream(Response);
          ParseError(Code, Recieved.DataString);
        finally
          Recieved.Free;
        end;
      end;
    end;
  finally
    Params.Free;
  end;
end;

function TMistralAIAPI.Post<TResult>(const Path: string; const MetadataAsObject: Boolean): TResult;
var
  Response: TStringStream;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Code := Post(Path, Response);
    if MetadataAsObject then
      Result := ParseResponse<TResult>(Code, Response.DataString) else
      Result := ParseResponse<TResult>(Code, JSONValueAsString(Response.DataString));
  finally
    Response.Free;
  end;
end;

function TMistralAIAPI.Delete(const Path: string; Response: TStringStream): Integer;
var
  Headers: TNetHeaders;
begin
  CheckAPI;
  Headers := GetHeaders;
  Result := FHTTPClient.Delete(GetRequestURL(Path), Response, Headers).StatusCode;
end;

function TMistralAIAPI.Delete<TResult>(const Path: string): TResult;
var
  Response: TStringStream;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Code := Delete(Path, Response);
    Result := ParseResponse<TResult>(Code, Response.DataString);
  finally
    Response.Free;
  end;
end;

function TMistralAIAPI.PostForm<TResult, TParams>(const Path: string; ParamProc: TProc<TParams>): TResult;
var
  Response: TStringStream;
  Params: TParams;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    Code := Post(Path, Params, Response);
    Result := ParseResponse<TResult>(Code, Response.DataString);
  finally
    Params.Free;
    Response.Free;
  end;
end;

procedure TMistralAIAPI.RaiseError(Code: Int64; Error: TErrorCore);
begin
  case Code of
    429:
      raise MistralAIExceptionRateLimitError.Create(Code, Error);
    400, 404, 415:
      raise MistralAIExceptionInvalidRequestError.Create(Code, Error);
    401:
      raise MistralAIExceptionAuthenticationError.Create(Code, Error);
    403:
      raise MistralAIExceptionPermissionError.Create(Code, Error);
    409:
      raise MistralAIExceptionTryAgain.Create(Code, Error);
    422:
      raise MistralUnprocessableEntityError.Create(Code, Error);
  else
    raise MistralAIException.Create(Code, Error);
  end;
end;

function TMistralAIAPI.Get<TResult, TParams>(const Path: string;
  ParamProc: TProc<TParams>; const MetadataAsObject: Boolean): TResult;
var
  Response: TStringStream;
  Code: Integer;
  Params: TParams;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    Code := Get(Path + Params.Value, Response);
    if MetadataAsObject then
      Result := ParseResponse<TResult>(Code, Response.DataString) else
      Result := ParseResponse<TResult>(Code, JSONValueAsString(Response.DataString));
  finally
    Response.Free;
    Params.Free;
  end;
end;

function TMistralAIAPI.Get<TResult>(const Path: string; const MetadataAsObject: Boolean): TResult;
var
  Response: TStringStream;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Code := Get(Path, Response);
    if MetadataAsObject then
      Result := ParseResponse<TResult>(Code, Response.DataString) else
      Result := ParseResponse<TResult>(Code, JSONValueAsString(Response.DataString));
  finally
    Response.Free;
  end;
end;

function TMistralAIAPI.GetFile<TResult>(const Path: string; const JSONFieldName: string):TResult;
var
  Stream: TStringStream;
  Temp: TStringStream;
  Code: Integer;
begin
  Stream := TStringStream.Create;
  try
    Code := GetFile(Path, Stream);
    Stream.Position := 0;
    Temp := TStringStream.Create(BytesToString(Stream.Bytes).TrimRight([#0]));
    try
      Result := ParseResponse<TResult>(Code, Format('{"%s":"%s"}', [JSONFieldName, EncodeBase64(Temp)]));
    finally
      Temp.Free;
    end;
  finally
    Stream.Free;
  end;
end;

function TMistralAIAPI.GetFile(const Path: string; Response: TStream): Integer;
var
  Headers: TNetHeaders;
begin
  CheckAPI;
  Headers := GetHeaders;
  Result := FHTTPClient.Get(GetRequestURL(Path), Response, Headers).StatusCode;
  case Result of
    200..299:
       {success};
    else
      begin
        var Recieved := TStringStream.Create;
        try
          Response.Position := 0;
          Recieved.LoadFromStream(Response);
          ParseError(Result, Recieved.DataString);
        finally
          Recieved.Free;
        end;
      end;
  end;
end;

function TMistralAIAPI.GetHeaders: TNetHeaders;
begin
  Result := [TNetHeader.Create('Authorization', 'Bearer ' + FToken)] + FCustomHeaders;
end;

function TMistralAIAPI.GetRequestURL(const Path: string): string;
begin
  Result := FBaseURL + '/';
  Result := Result + Path;
end;

procedure TMistralAIAPI.CheckAPI;
begin
  if FToken.IsEmpty then
    raise MistralAIExceptionAPI.Create('Token is empty!');
  if FBaseUrl.IsEmpty then
    raise MistralAIExceptionAPI.Create('Base url is empty!');
end;

procedure TMistralAIAPI.ParseError(const Code: Int64; const ResponseText: string);
var
  Error: TErrorCore;
begin
  Error := nil;
  try
    try
      case Code of
        422 : Error := TJson.JsonToObject<TError422>(ResponseText);
        else
          Error := TJson.JsonToObject<TError>(ResponseText);
      end;
    except
      Error := nil;
    end;
    if Assigned(Error) then
      RaiseError(Code, Error);
  finally
    if Assigned(Error) then
      Error.Free;
  end;
end;

function TMistralAIAPI.ParseResponse<T>(const Code: Int64; const ResponseText: string): T;
begin
  Result := nil;
  case Code of
    200..299:
      try
        Result := TJson.JsonToObject<T>(ResponseText);
      except
        Result := nil;
      end;
    else
      ParseError(Code, ResponseText);
  end;
  if not Assigned(Result) then
    raise MistralAIExceptionInvalidResponse.Create(Code, 'Empty or invalid response');
end;

function TMistralAIAPI.Patch(const Path: string; Body: TJSONObject;
  Response: TStringStream; OnReceiveData: TReceiveDataCallback): Integer;
var
  Headers: TNetHeaders;
  Stream: TStringStream;
begin
  CheckAPI;
  Headers := GetHeaders + [TNetHeader.Create('Content-Type', 'application/json')];
  Headers := Headers + [TNetHeader.Create('Accept', 'application/json')];
  Stream := TStringStream.Create;
  FHTTPClient.ReceiveDataCallBack := OnReceiveData;
  try
    Stream.WriteString(Body.ToJSON);
    Stream.Position := 0;
    Result := FHTTPClient.Patch(GetRequestURL(Path), Stream, Response, Headers).StatusCode;
  finally
    FHTTPClient.ReceiveDataCallBack := nil;
    Stream.Free;
  end;
end;

function TMistralAIAPI.Patch<TResult, TParams>(const Path: string;
  ParamProc: TProc<TParams>; const MetadataAsObject: Boolean): TResult;
var
  Response: TStringStream;
  Params: TParams;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    Code := Patch(Path, Params.JSON, Response);
    if MetadataAsObject then
      Result := ParseResponse<TResult>(Code, Response.DataString) else
      Result := ParseResponse<TResult>(Code, JSONValueAsString(Response.DataString));
  finally
    Params.Free;
    Response.Free;
  end;
end;

procedure TMistralAIAPI.SetBaseUrl(const Value: string);
begin
  FBaseUrl := Value;
end;

procedure TMistralAIAPI.SetCustomHeaders(const Value: TNetHeaders);
begin
  FCustomHeaders := Value;
end;

procedure TMistralAIAPI.SetOrganization(const Value: string);
begin
  FOrganization := Value;
end;

procedure TMistralAIAPI.SetToken(const Value: string);
begin
  FToken := Value;
end;

function TMistralAIAPI.JSONValueAsString(const Value: string;
  const Field: TArray<string>): string;
begin
  Result := Value;
  if Length(Field) > 0 then
    begin
      for var Item in Field do
        Result := JSONValueAsString(Result, Item);
    end;
end;

function TMistralAIAPI.JSONValueAsString(const Value, Field: string): string;
begin
  Result := Value;
  var i := Pos(Field, Result);
  while (i > 0) and (i < Result.Length) do
    begin
      i := i + Field.Length - 1;
      Result[i] := '"';
      Inc(i);
      var j := 0;
      while (j > 0) or ((j = 0) and not (Result[i] = '}')) do
        begin
          case Result[i] of
            '{':
              Inc(j);
            '}':
              j := j - 1;
            '"':
              Result[i] := '`';
          end;
          Inc(i);
          if i > Result.Length then
            raise Exception.Create('Invalid JSON string');
        end;
      Result[i] := '"';
      i := Pos(Field, Result);
    end;
end;

function TMistralAIAPI.JSONValueAsString(const Value: string): string;
begin
  Result := JSONValueAsString(Value, JSONFieldsToString);
end;

{ MistralAIException }

constructor MistralAIException.Create(const ACode: Int64; const AError: TErrorCore); //TError);
begin
  var Error := AError as TError;

  Code := ACode;
  if Error.Detail <> EmptyStr then
    Msg := Error.Detail
  else
  if Error.Message <> EmptyStr then
    Msg := Error.Message;
  if Error.RequestID <> EmptyStr then
    Msg := Format('%s for request %s', [Msg, Error.RequestID]);

  inherited Create(Format('error %d: %s', [ACode, Msg]));
end;

constructor MistralAIException.Create(const ACode: Int64; const Value: string);
begin
  Code := ACode;
  Msg := Value;
  inherited Create(Format('error %d: %s', [ACode, Msg]));
end;

{ TMistralAIAPIRoute }

constructor TMistralAIAPIRoute.CreateRoute(AAPI: TMistralAIAPI);
begin
  inherited Create;
  FAPI := AAPI;
end;

procedure TMistralAIAPIRoute.SetAPI(const Value: TMistralAIAPI);
begin
  FAPI := Value;
end;

{ MistralAIValidationException }

constructor MistralAIValidationException.Create(const ACode: Int64;
  const AError: TErrorCore);
begin
  var Error := AError as TError422;
  Code := ACode;
  if Length(Error.Detail) > 0 then
    inherited Create(Format('error %d: %s ', [ACode, TypeToStr(Error.Detail[0].Msg)]))
  else
    {--- WARNING ---
         Problem with errors generated by Mistral.
         (Detail & Message: inconsistent. Pending correction)}
    if Length(Error.Message.Detail) > 0 then
       inherited Create(
          Format('error %d: %s '+ sLineBreak +' %s',
                 [ACode, TypeToStr(Error.&Type), ToText(Error)]) )
    else
      inherited Create(Format('error %d: %s ', [ACode, 'Detail not captured']));
end;

function MistralAIValidationException.DetailItemToStr(
  const Value: TDetail): string;
begin
  Result := Format('   %s (%s) --- %s '+sLineBreak, [LocToStr(Value.Loc), Value.Input, Value.Msg])
end;

function MistralAIValidationException.LocToStr(
  const Value: TArray<string>): string;
begin
  Result := EmptyStr;
  for var S in Value do
    if IndexStr(S, ['body']) = -1 then
      begin
        if Result <> EmptyStr then
          Result := Result + '.' + S else
          Result := S;
      end;
end;

function MistralAIValidationException.ToText(
  const AError: TError422): string;
begin
  Result := EmptyStr;
  for var Item in AError.Message.Detail do
    begin
      if Result <> EmptyStr then
        Result := Format('%s %s', [Result, DetailItemToStr(Item)]) else
        Result := DetailItemToStr(Item);
    end;
end;

function MistralAIValidationException.TypeToStr(const Value: string): string;
begin
  Result := StringReplace(Value, '_', ' ', [rfReplaceAll, rfIgnoreCase]);
end;

end.

unit MistralAI.Async.Support;

{-------------------------------------------------------------------------------

      Unit containing  records for managing  asynchronous events related to
      chat requests.

      The  MistralAI.Chat.AsyncEvents  unit  provides  definitions for  the
      TAsyncParams<T>  and  TAsynStreamParams<T>  records, which  are  used
      to  handle  the lifecycle  of asynchronous chat operations, including
      starting, progressing, succeeding, and handling errors.
      These records enable non-blocking operations for chat functionalities
      and can be reused across multiple modules.

      This unit depends  on MistralAI.Params.Core  for parameter management.
      The IUseParams<T>  and  TUseParamsFactory<T>  interfaces  and  classes
      from  MistralAI.Params.Core  are  utilized  to  create  and manage the
      parameter  instances  for  asynchronous  operations.

        Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
        Visit the Github repository for the documentation and use examples

-------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, system.Classes, System.Threading, MistralAI.Params.Core;

type
  /// <summary>
  /// Record used to handle asynchronous request events.
  /// </summary>
  /// <remarks>
  /// <c>TAsyncCallBack</c> manages the lifecycle of an asynchronous request.
  /// It provides callbacks for different stages of the request, such as start, successful completion, or error.
  /// </remarks>
  TAsyncCallBack<T> = record
  private
    FSender: TObject;
    FOnStart: TProc<TObject>;
    FOnSuccess: TProc<TObject, T>;
    FOnError: TProc<TObject, string>;
  public
    /// <summary>
    /// Object representing the sender of the asynchronous operation.
    /// </summary>
    /// <remarks>
    /// The <c>Sender</c> property is used to identify or store a reference to the object that initiated the request.
    /// This can be useful for providing context in the callback procedures.
    /// </remarks>
    property Sender: TObject read FSender write FSender;
    /// <summary>
    /// Event triggered at the start of the asynchronous request.
    /// </summary>
    /// <remarks>
    /// The <c>OnStart</c> event is called when the request begins.
    /// It can be used to initialize any required state or display a loading indicator to the user.
    /// <code>
    /// OnStart :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // Code executed at the start of the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnStart: TProc<TObject> read FOnStart write FOnStart;
    /// <summary>
    /// Event triggered at the end of the asynchronous request.
    /// </summary>
    /// <param name="Sender">
    /// Object that initiated the request, generally used for context.
    /// </param>
    /// <param name="Result">
    /// The result of type <c>T</c> returned at the end of the request.
    /// This event is used to process the final result of the asynchronous operation.
    /// </param>
    /// <remarks>
    /// The <c>OnSuccess</c> event is invoked when the process completes successfully.
    /// It can be used to perform final actions based on the received result.
    /// <code>
    /// OnSuccess :=
    ///    procedure (Sender: TObject; Result: T)
    ///    begin
    ///      // Code executed at the end of the request with the obtained result
    ///    end;
    /// </code>
    /// </remarks>
    property OnSuccess: TProc<TObject, T> read FOnSuccess write FOnSuccess;
    /// <summary>
    /// Event triggered when an error occurs during the asynchronous request.
    /// </summary>
    /// <param name="Sender">
    /// Object that initiated the request, generally used for context.
    /// </param>
    /// <param name="ErrorMessage">
    /// The error message received, which can be logged or displayed to the user.
    /// </param>
    /// <remarks>
    /// The <c>OnError</c> event is called when an error occurs during the asynchronous operation.
    /// It can be used to handle failures, display error messages, or perform any necessary cleanup actions.
    /// <code>
    /// OnError :=
    ///    procedure (Sender: TObject; ErrorMessage: string)
    ///    begin
    ///      // Code executed when an error occurs during the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnError: TProc<TObject, string> read FOnError write FOnError;
  end;

  /// <summary>
  /// Class used to manage asynchronous execution with callback events.
  /// </summary>
  /// <remarks>
  /// The <c>TAsyncCallBackExec&lt;T, U&gt;</c> class allows you to execute asynchronous operations with specified callbacks for start, completion, and error events.
  /// It encapsulates the asynchronous execution logic, handling thread management and exception handling, providing an easy way to manage the lifecycle of an asynchronous request.
  /// </remarks>
  TAsyncCallBackExec<T; U: class> = class
  private
    FUse: IUseParams<T>;
    FSender: TObject;
    FOnStart: TProc<TObject>;
    FOnSuccess: TProc<TObject, U>;
    FOnError: TProc<TObject, string>;
  public
    /// <summary>
    /// Gets the <c>IUseParams&lt;T&gt;</c> interface instance used by this class.
    /// </summary>
    /// <value>
    /// An instance of <c>IUseParams&lt;T&gt;</c> that provides parameter management functionality.
    /// </value>
    property Use: IUseParams<T> read FUse;
    /// <summary>
    /// The object representing the sender of the asynchronous operation.
    /// </summary>
    /// <value>
    /// An instance of <c>TObject</c> identifying the originator of the operation.
    /// </value>
    /// <remarks>
    /// This property can be set to identify the object that initiated the asynchronous operation, which is useful in callback methods.
    /// </remarks>
    property Sender: TObject read FSender write FSender;
    /// <summary>
    /// Event triggered when the asynchronous operation starts.
    /// </summary>
    /// <value>
    /// A procedure of type <c>TProc&lt;TObject&gt;</c> to handle any setup or UI updates when the operation begins.
    /// </value>
    /// <remarks>
    /// Assign a procedure to this event to perform actions at the start of the asynchronous operation.
    /// <code>
    /// OnStart :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // Code executed at the start of the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnStart: TProc<TObject> read FOnStart write FOnStart;
    /// <summary>
    /// Event triggered when the asynchronous operation completes successfully.
    /// </summary>
    /// <value>
    /// A procedure of type <c>TProc&lt;TObject, U&gt;</c> to handle the result of the operation.
    /// </value>
    /// <remarks>
    /// Assign a procedure to this event to process the result returned by the operation.
    /// <code>
    /// OnSuccess :=
    ///    procedure (Sender: TObject; Result: T)
    ///    begin
    ///      // Code executed at the end of the request with the obtained result
    ///    end;
    /// </code>
    /// </remarks>
    property OnSuccess: TProc<TObject, U> read FOnSuccess write FOnSuccess;
    /// <summary>
    /// Event triggered when an error occurs during the asynchronous operation.
    /// </summary>
    /// <value>
    /// A procedure of type <c>TProc&lt;TObject, string&gt;</c> to handle exceptions or errors.
    /// </value>
    /// <remarks>
    /// Assign a procedure to this event to handle any exceptions or errors that occur during execution.
    /// <code>
    /// OnError :=
    ///    procedure (Sender: TObject; ErrorMessage: string)
    ///    begin
    ///      // Code executed when an error occurs during the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnError: TProc<TObject, string> read FOnError write FOnError;
    /// <summary>
    /// Executes the specified function asynchronously.
    /// </summary>
    /// <param name="Value">
    /// A function of type <c>TFunc&lt;U&gt;</c> representing the operation to execute asynchronously.
    /// </param>
    /// <remarks>
    /// This method creates and starts an asynchronous task that executes the provided function.
    /// It invokes the <c>OnStart</c> event before execution, the <c>OnSuccess</c> event upon successful completion, and the <c>OnError</c> event if an exception occurs during execution.
    /// </remarks>
    procedure Run(Value: TFunc<U>);
    /// <summary>
    /// Initializes a new instance of the <c>TAsyncCallBackExec&lt;T, U&gt;</c> class with the specified parameter function.
    /// </summary>
    /// <param name="Value">
    /// A function of type <c>TFunc&lt;T&gt;</c> used to create an instance of <c>IUseParams&lt;T&gt;</c>.
    /// </param>
    /// <remarks>
    /// The constructor initializes the internal <c>IUseParams&lt;T&gt;</c> interface using the provided function.
    /// </remarks>
    constructor Create(const Value: TFunc<T>);
  end;

  /// <summary>
  /// Record used to manage asynchronous events for a streaming chat request.
  /// </summary>
  /// <remarks>
  /// <c>TAsynChatStreamParams</c> allows you to handle the lifecycle of a chat request in streaming mode.
  /// It provides callbacks for different stages such as when the request starts, progresses, succeeds, encounters an error, or needs to be canceled.
  /// </remarks>
  TAsyncStreamCallBack<T> = record
  private
    FSender: TObject;
    FOnStart: TProc<TObject>;
    FOnSuccess: TProc<TObject>;
    FOnProgress: TProc<TObject, T>;
    FOnError: TProc<TObject, string>;
    FOnCancellation: TProc<TObject>;
    FOnDoCancel: TFunc<Boolean>;
  public
    /// <summary>
    /// The object representing the sender of the asynchronous operation.
    /// </summary>
    /// <remarks>
    /// The <c>Sender</c> property is used to identify or store a reference to the object that initiated the chat request,
    /// which can be useful for context within the callback procedures.
    /// </remarks>
    property Sender: TObject read FSender write FSender;
    /// <summary>
    /// Event triggered when the asynchronous chat request starts.
    /// </summary>
    /// <remarks>
    /// The <c>OnStart</c> event is called when the chat request begins. It can be used to set up any initial state or display a loading indicator to the user.
    /// <code>
    /// OnStart :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // code when chat request begin
    ///    end;
    /// </code>
    /// </remarks>
    property OnStart: TProc<TObject> read FOnStart write FOnStart;
    /// <summary>
    /// Event triggered when the asynchronous chat request completes successfully.
    /// </summary>
    /// <remarks>
    /// The <c>OnSuccess</c> event is invoked when the streaming process finishes successfully.
    /// It does not provide additional data, as the result is expected to have been handled progressively via the <c>OnProgress</c> event.
    /// <code>
    /// OnSuccess :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // code when the streaming process finishes successfully
    ///    end;
    /// </code>
    /// </remarks>
    property OnSuccess: TProc<TObject> read FOnSuccess write FOnSuccess;
    /// <summary>
    /// Event triggered to handle progress during the streaming chat request.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="Chat">
    /// The <c>TChat</c> object representing the current response chunk received from the model.
    /// This event can be used to update the user interface as new tokens are streamed in.
    /// </param>
    /// <remarks>
    /// The <c>OnProgress</c> event is fired every time a new chunk of data is received during the streaming process.
    /// This allows the application to handle the response progressively as it is generated by the model.
    /// <code>
    /// OnProgress :=
    ///    procedure (Sender: TObject; Chat: TChat)
    ///    begin
    ///      // code to handle the response progressively
    ///    end;
    /// </code>
    /// </remarks>
    property OnProgress: TProc<TObject, T> read FOnProgress write FOnProgress;
    /// <summary>
    /// Event triggered when an error occurs during the asynchronous chat request.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="ErrorMessage">
    /// The error message received, which can be logged or displayed to the user.
    /// </param>
    /// <remarks>
    /// The <c>OnError</c> event is called when an error occurs during the streaming process.
    /// This can be used to handle failures, show error messages, or perform any necessary clean-up actions.
    /// <code>
    /// OnError :=
    ///    procedure (Sender: TObject; message: string)
    ///    begin
    ///      // code to handle an error occurs during the streaming process
    ///    end;
    /// </code>
    /// </remarks>
    property OnError: TProc<TObject, string> read FOnError write FOnError;
    /// <summary>
    /// Event triggered when the asynchronous chat request has been canceled.
    /// </summary>
    /// <remarks>
    /// The <c>OnCancellation</c> event is fired when the chat request is canceled by the user or the application.
    /// This can be used to perform clean-up operations or notify the user that the request has been terminated.
    /// <code>
    /// OnCancellation :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // code to handle chat request cancellation
    ///    end;
    /// </code>
    /// </remarks>
    property OnCancellation: TProc<TObject> read FOnCancellation write FOnCancellation;
    /// <summary>
    /// Function called to determine if the asynchronous chat request should be canceled.
    /// </summary>
    /// <returns>
    /// A <c>Boolean</c> value indicating whether the request should be canceled (<c>True</c>) or allowed to continue (<c>False</c>).
    /// </returns>
    /// <remarks>
    /// The <c>OnDoCancel</c> function is periodically invoked to check whether the user or application has requested to cancel the chat request.
    /// If the function returns <c>True</c>, the streaming process will be aborted.
    /// <code>
    /// OnDoCancel :=
    ///    function : Boolean
    ///    begin
    ///      Result := ... // True to stop the streaming process
    ///    end;
    /// </code>
    /// </remarks>
    property OnDoCancel: TFunc<Boolean> read FOnDoCancel write FOnDoCancel;
  end;

implementation

{ TAsyncCallBackExec<T, U> }

constructor TAsyncCallBackExec<T, U>.Create(const Value: TFunc<T>);
begin
  inherited Create;
  FUse := TUseParamsFactory<T>.CreateInstance(Value);
end;

procedure TAsyncCallBackExec<T, U>.Run(Value: TFunc<U>);
begin
  {--- Assign callback values to internal variables for asynchrony to work properly }
  var InternalSender := Sender;
  var InternalOnStart := OnStart;
  var InternalOnSuccess := OnSuccess;
  var InternalOnError := OnError;

  var Task: ITask := TTask.Create(
          procedure()
          begin
            try
              {--- Pass the instance of the current class in case no value was specified. }
              if not Assigned(InternalSender) then
                InternalSender := Self;

              {--- Trigger OnStart callback }
              if Assigned(InternalOnStart) then
                TThread.Queue(nil,
                  procedure
                  begin
                    InternalOnStart(InternalSender);
                  end);

              {--- Processing }
              var Result := Value();

              {--- Trigger OnEnd callback when the process is done }
              TThread.Queue(nil,
                  procedure
                  begin
                    try
                      if Assigned(InternalOnSuccess) then
                        InternalOnSuccess(InternalSender, Result);
                    finally
                      {--- Makes sure to release the instance containing the data obtained
                           following processing}
                      if Assigned(Result) then
                        Result.Free;
                    end;
                  end);

            except
              on E: Exception do
                begin
                  var Error := AcquireExceptionObject;
                  try
                    var ErrorMsg := (Error as Exception).Message;

                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(InternalOnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        InternalOnError(InternalSender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
          end);
  Task.Start;
end;

end.

unit MistralAI.Batch;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, REST.Json.Types,
  System.NetEncoding, System.Net.Mime, MistralAI.API.Params, MistralAI.API,
  MistralAI.Async.Support, MistralAI.Types;

type
  /// <summary>
  /// Represents a class for constructing and managing query parameters to list batch jobs in the MistralAI API.
  /// </summary>
  /// <remarks>
  /// This class provides methods to define filters such as page size, model name, creation date, and batch status,
  /// allowing precise control over the listing of batch jobs.
  /// </remarks>
  TBatchJobListParams = class(TUrlParam)
  public
    /// <summary>
    /// Sets the page number for pagination in the batch job list query.
    /// </summary>
    /// <param name="Value">
    /// The page number to retrieve (e.g., 1 for the first page).
    /// </param>
    /// <returns>
    /// Returns the instance of <c>TBatchJobListParams</c> for method chaining.
    /// </returns>
    function Page(const Value: Integer): TBatchJobListParams;
    /// <summary>
    /// Sets the number of items per page for pagination in the batch job list query.
    /// </summary>
    /// <param name="Value">
    /// The number of items to retrieve per page.
    /// </param>
    /// <returns>
    /// Returns the instance of <c>TBatchJobListParams</c> for method chaining.
    /// </returns>
    function PageSize(const Value: Integer): TBatchJobListParams;
    /// <summary>
    /// Filters the batch job list by the name of the model used for processing.
    /// </summary>
    /// <param name="Value">
    /// The model name to filter batch jobs (e.g., "mistral-small-latest").
    /// </param>
    /// <returns>
    /// Returns the instance of <c>TBatchJobListParams</c> for method chaining.
    /// </returns>
    function Model(const Value: string): TBatchJobListParams;
    /// <summary>
    /// Filters the batch job list by custom metadata associated with the batch.
    /// </summary>
    /// <param name="Value">
    /// The metadata key or value to filter batch jobs.
    /// </param>
    /// <returns>
    /// Returns the instance of <c>TBatchJobListParams</c> for method chaining.
    /// </returns>
    function Metadata(const Value: string): TBatchJobListParams;
    /// <summary>
    /// Filters the batch job list to include only jobs created after the specified timestamp.
    /// </summary>
    /// <param name="Value">
    /// A string representing the timestamp (e.g., ISO 8601 format).
    /// </param>
    /// <returns>
    /// Returns the instance of <c>TBatchJobListParams</c> for method chaining.
    /// </returns>
    function CreatedAfter(const Value: string): TBatchJobListParams;
    /// <summary>
    /// Filters the batch job list to include only jobs created by the current user.
    /// </summary>
    /// <param name="Value">
    /// A boolean value indicating whether to filter jobs by the current user.
    /// </param>
    /// <returns>
    /// Returns the instance of <c>TBatchJobListParams</c> for method chaining.
    /// </returns>
    function CreatedByMe(const Value: Boolean): TBatchJobListParams;
    /// <summary>
    /// Filters the batch job list by the current status of the jobs.
    /// </summary>
    /// <param name="Value">
    /// The status of the batch jobs to filter (e.g., <c>QUEUED</c>, <c>RUNNING</c>, <c>SUCCESS</c>, etc.).
    /// </param>
    /// <returns>
    /// Returns the instance of <c>TBatchJobListParams</c> for method chaining.
    /// </returns>
    function Status(const Value: TBatchStatus): TBatchJobListParams;
  end;

  /// <summary>
  /// Represents a class for managing parameters required to create a batch job for the MistralAI API.
  /// This class, <c>TBatchJobParams</c>, extends <c>TJSONParam</c> to construct and handle JSON payloads for batch job creation.
  ///</summary>
  ///<remarks>
  /// A batch job consists of multiple API requests, each identified by a unique <c>custom_id</c>.
  /// This class simplifies the process of defining the parameters and generating the required JSON payloads for a batch job.
  ///</remarks>
  TBatchJobParams = class(TJSONParam)
  public
    /// <summary>
    /// A list of the batch input file IDs.
    /// </summary>
    function InputFiles(const Value: TArray<string>): TBatchJobParams;
    /// <summary>
    /// Currently support <c>/v1/embeddings</c>, <c>/v1/chat/completions</c>, <c>/v1/fim/completions</c>, <c>/v1/moderations</c>, <c>/v1/chat/moderations</c>.
    /// </summary>
    function Endpoint(const Value: TEndPointType): TBatchJobParams;
    /// <summary>
    /// Model used for batch job process.
    /// </summary>
    function Model(const Value: string): TBatchJobParams;
    /// <summary>
    /// Optional custom metadata for the batch.
    /// </summary>
    /// <remarks>
    /// property name*: string [ 1 ... 512 ] characters
    /// <para>
    /// additional property
    /// </para>
    /// </remarks>
    function Metadata(const Value: TJSONObject): TBatchJobParams; overload;
    /// <summary>
    /// Optional custom metadata for the batch.
    /// </summary>
    /// <remarks>
    /// property name*: string [ 1 ... 512 ] characters
    /// <para>
    /// additional property
    /// </para>
    /// </remarks>
    function Metadata(const Value: TJSONParam): TBatchJobParams; overload;
    /// <summary>
    /// Batch generation can take up to 24 hours, although it might finish earlier.
    /// </summary>
    /// <remarks>
    /// <para>
    /// - Please note that processing speeds may be adjusted based on current demand and the volume of
    /// your request. Your batch results will only be accessible once the entire batch processing is
    /// complete.
    /// </para>
    /// <para>
    /// - Users can set timeout_hours when creating a job, which specifies the number of hours after
    /// which the job should expire. It defaults to 24 hours and cannot exceed this limit at present.
    /// This means that batches will expire if processing does not complete within 24 hours. This is
    /// subject to change in the future.
    /// </para>
    /// </remarks>
    function TimeoutHours(const Value: Integer): TBatchJobParams;
  end;

  /// <summary>
  /// Represents a class for capturing error information related to batch job processing in the MistralAI API.
  /// </summary>
  /// <remarks>
  /// This class provides details about errors encountered during batch job processing, including error messages and counts.
  /// </remarks>
  TBatchJobListDataError = class
  private
    FMessage: string;
    FCount: Int64;
  public
    /// <summary>
    /// Gets or sets the error message describing the issue encountered during batch job processing.
    /// </summary>
    /// <value>
    /// A string representing the error message (e.g., "Invalid input file format").
    /// </value>
    property &Message: string read FMessage write FMessage;
    /// <summary>
    /// Gets or sets the count of occurrences for this specific error.
    /// </summary>
    /// <value>
    /// An integer representing the number of times this error was encountered.
    /// </value>
    property Count: Int64 read FCount write FCount;
  end;

  /// <summary>
  /// Represents a batch job in the MistralAI API.
  /// </summary>
  /// <remarks>
  /// A batch job contains details about the processing status, input files, model used, metadata, and
  /// the results of the batch operation.
  /// </remarks>
  TBatchJob = class
  private
    FId: string;
    FObjet: string;
    [JsonNameAttribute('input_files')]
    FInputFiles: TArray<string>;
    [JsonReflectAttribute(ctString, rtString, TMetadataInterceptor)]
    FMetadata: string;
    [JsonReflectAttribute(ctString, rtString, TEndPointTypeInterceptor)]
    FEndpoint: TEndPointType;
    FModel: string;
    [JsonNameAttribute('output_file')]
    FOutputFile: string;
    [JsonNameAttribute('error_file')]
    FErrorFile: string;
    FErrors: TArray<TBatchJobListDataError>;
    [JsonReflectAttribute(ctString, rtString, TBatchStatusInterceptor)]
    FStatus: TBatchStatus;
    [JsonNameAttribute('created_at')]
    FCreatedAt: Int64;
    [JsonNameAttribute('total_requests')]
    FTotalRequests: Int64;
    [JsonNameAttribute('completed_requests')]
    FCompletedRequests: Int64;
    [JsonNameAttribute('succeeded_requests')]
    FSucceededRequests: Int64;
    [JsonNameAttribute('failed_requests')]
    FFailedRequests: Int64;
    [JsonNameAttribute('started_at')]
    FStartedAt: Int64;
    [JsonNameAttribute('completed_at')]
    FCompletedAt: Int64;
  public
    /// <summary>
    /// The unique identifier for the batch job.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// The name or description of the batch job.
    /// </summary>
    property &Objet: string read FObjet write FObjet;
    /// <summary>
    /// An array of file IDs used as input for the batch job.
    /// </summary>
    property InputFiles: TArray<string> read FInputFiles write FInputFiles;
    /// <summary>
    /// Custom metadata associated with the batch job.
    /// </summary>
    property Metadata: string read FMetadata write FMetadata;
    /// <summary>
    /// The endpoint used for the batch job (e.g., <c>/v1/chat/completions</c>).
    /// </summary>
    property Endpoint: TEndPointType read FEndpoint write FEndpoint;
    /// <summary>
    /// The model used for processing the batch job.
    /// </summary>
    property Model: string read FModel write FModel;
    /// <summary>
    /// The file ID of the output file containing the results of the batch job.
    /// </summary>
    property OutputFile: string read FOutputFile write FOutputFile;
    /// <summary>
    /// The file ID of the error file containing details of any errors during processing.
    /// </summary>
    property ErrorFile: string read FErrorFile write FErrorFile;
    /// <summary>
    /// An array of error details, including messages and counts, for the batch job.
    /// </summary>
    property Errors: TArray<TBatchJobListDataError> read FErrors write FErrors;
    /// <summary>
    /// The current status of the batch job (e.g., <c>QUEUED</c>, <c>RUNNING</c>, <c>SUCCESS</c>, <c>FAILED</c>).
    /// </summary>
    property Status: TBatchStatus read FStatus write FStatus;
    /// <summary>
    /// The timestamp (in Unix time) when the batch job was created.
    /// </summary>
    property CreatedAt: Int64 read FCreatedAt write FCreatedAt;
    /// <summary>
    /// The total number of requests in the batch job.
    /// </summary>
    property TotalRequests: Int64 read FTotalRequests write FTotalRequests;
     /// <summary>
    /// The number of requests that have been completed so far.
    /// </summary>
    property CompletedRequests: Int64 read FCompletedRequests write FCompletedRequests;
    /// <summary>
    /// The number of requests that succeeded during batch processing.
    /// </summary>
    property SucceededRequests: Int64 read FSucceededRequests write FSucceededRequests;
    /// <summary>
    /// The number of requests that failed during batch processing.
    /// </summary>
    property FailedRequests: Int64 read FFailedRequests write FFailedRequests;
    /// <summary>
    /// The timestamp (in Unix time) when the batch job started processing.
    /// </summary>
    property StartedAt: Int64 read FStartedAt write FStartedAt;
    /// <summary>
    /// The timestamp (in Unix time) when the batch job completed processing.
    /// </summary>
    property CompletedAt: Int64 read FCompletedAt write FCompletedAt;
    /// <summary>
    /// Frees the memory allocated for the batch job, including associated error details.
    /// </summary>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a collection of batch jobs in the MistralAI API.
  /// </summary>
  /// <remarks>
  /// This class contains a list of batch jobs along with metadata about the collection,
  /// such as the total number of jobs and the object type.
  /// </remarks>
  TBatchJobList = class
  private
    FData: TArray<TBatchJob>;
    FObject: string;
    FTotal: Int64;
  public
    /// <summary>
    /// An array of batch jobs included in the list.
    /// </summary>
    property Data: TArray<TBatchJob> read FData write FData;
    /// <summary>
    /// The object type for the batch job list (e.g., <c>"batch_job_list"</c>).
    /// </summary>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// The total number of batch jobs available in the list.
    /// </summary>
    property Total: Int64 read FTotal write FTotal;
    /// <summary>
    /// Frees the memory allocated for the batch job list, including associated batch jobs.
    /// </summary>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Asynchronous callback parameters for operations returning a single <c>TBatchJob</c>.
  /// </summary>
  /// <remarks>
  /// Used when performing asynchronous operations that return a <c>TBatchJob</c> instance.
  /// </remarks>
  TAsynBatchJob = TAsyncCallBack<TBatchJob>;

  /// <summary>
  /// Asynchronous callback parameters for operations returning a single <c>TBatchJobList</c>.
  /// </summary>
  /// <remarks>
  /// Used when performing asynchronous operations that return a <c>TBatchJobList</c> instance.
  /// </remarks>
  TAsynBatchJobList = TAsyncCallBack<TBatchJobList>;

  /// <summary>
  /// Provides methods for interacting with the batch job routes in the MistralAI API.
  /// </summary>
  /// <remarks>
  /// This class enables the creation, retrieval, listing, and cancellation of batch jobs.
  /// It also supports both synchronous and asynchronous operations.
  /// </remarks>
  TBatchRoute = class(TMistralAIAPIRoute)
    /// <summary>
    /// Asynchronously creates a new batch job.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the parameters for the batch job using a <c>TBatchJobParams</c> instance.
    /// </param>
    /// <param name="CallBacks">
    /// A function to handle the asynchronous callback, returning a <c>TAsynBatchJob</c>.
    /// </param>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// // var MistralAI := TMistralAIFactory.CreateInstance(BaererKey);
    ///
    /// MistralAI.AsyncCreateJob(
    ///   procedure (Params: TBatchJobParams)
    ///   begin
    ///     // Define parameters for the batch job
    ///   end,
    ///
    ///   function: TAsynBatchJob
    ///   begin
    ///     Result.Sender := my_display_component;
    ///
    ///     Result.OnStart :=
    ///       procedure (Sender: TObject)
    ///       begin
    ///         // Handle the start
    ///       end;
    ///
    ///     Result.OnSuccess :=
    ///       procedure (Sender: TObject; Value: TBatchJob)
    ///       begin
    ///         // Handle the success result
    ///       end;
    ///
    ///     Result.OnError :=
    ///       procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle errors
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncCreateJob(ParamProc: TProc<TBatchJobParams>; CallBacks: TFunc<TAsynBatchJob>);
     /// <summary>
    /// Asynchronously retrieves a list of batch jobs.
    /// </summary>
    /// <param name="CallBacks">
    /// A function to handle the asynchronous callback, returning a <c>TAsynBatchJobList</c>.
    /// </param>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// // var MistralAI := TMistralAIFactory.CreateInstance(BaererKey);
    ///
    /// MistralAI.AsyncList(
    ///   function: TAsynBatchJobList
    ///   begin
    ///     Result.Sender := my_display_component;
    ///
    ///     Result.OnStart :=
    ///       procedure (Sender: TObject)
    ///       begin
    ///         // Handle the start
    ///       end;
    ///
    ///     Result.OnSuccess :=
    ///       procedure (Sender: TObject; Value: TBatchJobList)
    ///       begin
    ///         // Handle the successful retrieval
    ///       end;
    ///
    ///     Result.OnError :=
    ///       procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle errors
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncList(CallBacks: TFunc<TAsynBatchJobList>); overload;
    /// <summary>
    /// Asynchronously retrieves a filtered list of batch jobs.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the filter parameters using a <c>TBatchJobListParams</c> instance.
    /// </param>
    /// <param name="CallBacks">
    /// A function to handle the asynchronous callback, returning a <c>TAsynBatchJobList</c>.
    /// </param>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// // var MistralAI := TMistralAIFactory.CreateInstance(BaererKey);
    ///
    /// MistralAI.AsyncList(
    ///   procedure (Params: TBatchJobListParams)
    ///   begin
    ///     // Define parameters for filtering batch jobs
    ///   end,
    ///
    ///   function: TAsynBatchJobList
    ///   begin
    ///     Result.Sender := my_display_component;
    ///
    ///     Result.OnStart :=
    ///       procedure (Sender: TObject)
    ///       begin
    ///         // Handle the start
    ///       end;
    ///
    ///     Result.OnSuccess :=
    ///       procedure (Sender: TObject; Value: TBatchJobList)
    ///       begin
    ///         // Handle the successful retrieval
    ///       end;
    ///
    ///     Result.OnError :=
    ///       procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle errors
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncList(ParamProc: TProc<TBatchJobListParams>; CallBacks: TFunc<TAsynBatchJobList>); overload;
    /// <summary>
    /// Asynchronously retrieves the details of a specific batch job.
    /// </summary>
    /// <param name="BatchId">
    /// The unique identifier of the batch job to retrieve.
    /// </param>
    /// <param name="CallBacks">
    /// A function to handle the asynchronous callback, returning a <c>TAsynBatchJob</c>.
    /// </param>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// // var MistralAI := TMistralAIFactory.CreateInstance(BaererKey);
    ///
    /// MistralAI.AsyncRetrieve('batch-id-123',
    ///   function: TAsynBatchJob
    ///   begin
    ///     Result.Sender := my_display_component;
    ///
    ///     Result.OnStart :=
    ///       procedure (Sender: TObject)
    ///       begin
    ///         // Handle the start
    ///       end;
    ///
    ///     Result.OnSuccess :=
    ///       procedure (Sender: TObject; Value: TBatchJob)
    ///       begin
    ///         // Handle the successful retrieval of the batch job
    ///       end;
    ///
    ///     Result.OnError :=
    ///       procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle errors
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncRetrieve(const BatchId: string; CallBacks: TFunc<TAsynBatchJob>);
    /// <summary>
    /// Asynchronously cancels a specific batch job.
    /// </summary>
    /// <param name="BatchId">
    /// The unique identifier of the batch job to cancel.
    /// </param>
    /// <param name="CallBacks">
    /// A function to handle the asynchronous callback, returning a <c>TAsynBatchJob</c>.
    /// </param>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// // var MistralAI := TMistralAIFactory.CreateInstance(BaererKey);
    ///
    /// MistralAI.AsyncCancel('batch-id-456',
    ///   function: TAsynBatchJob
    ///   begin
    ///     Result.Sender := my_display_component;
    ///
    ///     Result.OnStart :=
    ///       procedure (Sender: TObject)
    ///       begin
    ///         // Handle the start
    ///       end;
    ///
    ///     Result.OnSuccess :=
    ///       procedure (Sender: TObject; Value: TBatchJob)
    ///       begin
    ///         // Handle the successful cancellation of the batch job
    ///       end;
    ///
    ///     Result.OnError :=
    ///       procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle errors
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncCancel(const BatchId: string; CallBacks: TFunc<TAsynBatchJob>);
    /// <summary>
    /// Creates a new batch job.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the parameters for the batch job using a <c>TBatchJobParams</c> instance.
    /// </param>
    /// <returns>
    /// Returns the created <c>TBatchJob</c> instance.
    /// </returns>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// // var MistralAI := TMistralAIFactory.CreateInstance(BaererKey);
    ///
    /// var Value := MistralAI.Batch.CreateJob(
    ///   procedure (Params: TBatchJobParams)
    ///   begin
    ///     // Define parameters for the batch job
    ///   end);
    /// try
    ///   // Do something with the created batch job
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function CreateJob(ParamProc: TProc<TBatchJobParams>): TBatchJob;
    /// <summary>
    /// Retrieves a list of batch jobs.
    /// </summary>
    /// <returns>
    /// Returns a <c>TBatchJobList</c> containing all available batch jobs.
    /// </returns>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// // var MistralAI := TMistralAIFactory.CreateInstance(BaererKey);
    ///
    /// var Value := MistralAI.Batch.List;
    /// try
    ///   // Do something
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function List: TBatchJobList; overload;
    /// <summary>
    /// Retrieves a filtered list of batch jobs.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the filter parameters using a <c>TBatchJobListParams</c> instance.
    /// </param>
    /// <returns>
    /// Returns a <c>TBatchJobList</c> containing the filtered batch jobs.
    /// </returns>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// // var MistralAI := TMistralAIFactory.CreateInstance(BaererKey);
    ///
    /// var Value := MistralAI.Batch.List(
    ///   procedure (Params: TBatchJobListParams)
    ///   begin
    ///     // Define parameters for the batch job
    ///   end);
    /// try
    ///   // Do something with the created batch job
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function List(ParamProc: TProc<TBatchJobListParams>): TBatchJobList; overload;
    /// <summary>
    /// Retrieves the details of a specific batch job.
    /// </summary>
    /// <param name="BatchId">
    /// The unique identifier of the batch job to retrieve.
    /// </param>
    /// <returns>
    /// Returns the <c>TBatchJob</c> instance corresponding to the given batch ID.
    /// </returns>
    /// <remarks>
     /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// // var MistralAI := TMistralAIFactory.CreateInstance(BaererKey);
    ///
    /// var Job := MistralAI.Batch.Retrieve('batch-id-456');
    /// try
    ///   // Work with the retrieved batch job
    /// finally
    ///   Job.Free;
    /// end;
    /// </code>
    /// </remarks>
    function Retrieve(const BatchId: string): TBatchJob;
    /// <summary>
    /// Cancels a specific batch job.
    /// </summary>
    /// <param name="BatchId">
    /// The unique identifier of the batch job to cancel.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TBatchJob</c> instance after cancellation.
    /// </returns>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// // var MistralAI := TMistralAIFactory.CreateInstance(BaererKey);
    ///
    /// var CanceledJob := MistralAI.Batch.Cancel('batch-id-789');
    /// try
    ///   // Handle the cancellation result
    /// finally
    ///   CanceledJob.Free;
    /// end;
    /// </code>
    /// </remarks>
    function Cancel(const BatchId: string): TBatchJob;
  end;

implementation

{ TBatchJobListParams }

function TBatchJobListParams.CreatedAfter(
  const Value: string): TBatchJobListParams;
begin
  Result := TBatchJobListParams(Add('created_after', Value));
end;

function TBatchJobListParams.CreatedByMe(
  const Value: Boolean): TBatchJobListParams;
begin
  Result := TBatchJobListParams(Add('created_by_me', Value));
end;

function TBatchJobListParams.Metadata(const Value: string): TBatchJobListParams;
begin
  Result := TBatchJobListParams(Add('metadata', Value));
end;

function TBatchJobListParams.Model(const Value: string): TBatchJobListParams;
begin
  Result := TBatchJobListParams(Add('model', Value));
end;

function TBatchJobListParams.Page(const Value: Integer): TBatchJobListParams;
begin
  Result := TBatchJobListParams(Add('page', Value));
end;

function TBatchJobListParams.PageSize(
  const Value: Integer): TBatchJobListParams;
begin
  Result := TBatchJobListParams(Add('page_size', Value));
end;

function TBatchJobListParams.Status(
  const Value: TBatchStatus): TBatchJobListParams;
begin
  Result := TBatchJobListParams(Add('status', Value.ToString));
end;

{ TBatchJob }

destructor TBatchJob.Destroy;
begin
  for var Item in FErrors do
    Item.Free;
  inherited;
end;

{ TBatchJobList }

destructor TBatchJobList.Destroy;
begin
  for var Item in FData do
    Item.Free;
  inherited;
end;

{ TBatchRoute }

procedure TBatchRoute.AsyncCancel(const BatchId: string;
  CallBacks: TFunc<TAsynBatchJob>);
begin
  with TAsyncCallBackExec<TAsynBatchJob, TBatchJob>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TBatchJob
      begin
        Result := Self.Cancel(BatchId);
      end);
  finally
    Free;
  end;
end;

procedure TBatchRoute.AsyncCreateJob(ParamProc: TProc<TBatchJobParams>;
  CallBacks: TFunc<TAsynBatchJob>);
begin
  with TAsyncCallBackExec<TAsynBatchJob, TBatchJob>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TBatchJob
      begin
        Result := Self.CreateJob(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TBatchRoute.AsyncList(ParamProc: TProc<TBatchJobListParams>;
  CallBacks: TFunc<TAsynBatchJobList>);
begin
  with TAsyncCallBackExec<TAsynBatchJobList, TBatchJobList>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TBatchJobList
      begin
        Result := Self.List(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TBatchRoute.AsyncList(CallBacks: TFunc<TAsynBatchJobList>);
begin
  with TAsyncCallBackExec<TAsynBatchJobList, TBatchJobList>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TBatchJobList
      begin
        Result := Self.List;
      end);
  finally
    Free;
  end;
end;

procedure TBatchRoute.AsyncRetrieve(const BatchId: string;
  CallBacks: TFunc<TAsynBatchJob>);
begin
  with TAsyncCallBackExec<TAsynBatchJob, TBatchJob>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TBatchJob
      begin
        Result := Self.Retrieve(BatchId);
      end);
  finally
    Free;
  end;
end;

function TBatchRoute.Cancel(const BatchId: string): TBatchJob;
begin
  Result := API.Post<TBatchJob>(Format('batch/jobs/%s/cancel', [BatchId]));
end;

function TBatchRoute.CreateJob(ParamProc: TProc<TBatchJobParams>): TBatchJob;
begin
  Result := API.Post<TBatchJob, TBatchJobParams>('batch/jobs', ParamProc);
end;

function TBatchRoute.List: TBatchJobList;
begin
  Result := API.Get<TBatchJobList>('batch/jobs');
end;

function TBatchRoute.List(ParamProc: TProc<TBatchJobListParams>): TBatchJobList;
begin
  Result := API.Get<TBatchJobList, TBatchJobListParams>('batch/jobs', ParamProc);
end;

function TBatchRoute.Retrieve(const BatchId: string): TBatchJob;
begin
  Result := API.Get<TBatchJob>(Format('batch/jobs/%s', [BatchId]));
end;

{ TBatchJobParams }

function TBatchJobParams.Endpoint(const Value: TEndPointType): TBatchJobParams;
begin
  Result := TBatchJobParams(Add('endpoint', Value.ToString));
end;

function TBatchJobParams.InputFiles(
  const Value: TArray<string>): TBatchJobParams;
begin
  Result := TBatchJobParams(Add('input_files', Value));
end;

function TBatchJobParams.Metadata(const Value: TJSONObject): TBatchJobParams;
begin
  Result := TBatchJobParams(Add('metadata', Value));
end;

function TBatchJobParams.Metadata(const Value: TJSONParam): TBatchJobParams;
begin
  Result := TBatchJobParams(Add('metadata', Value.Detach));
end;

function TBatchJobParams.Model(const Value: string): TBatchJobParams;
begin
  Result := TBatchJobParams(Add('model', Value));
end;

function TBatchJobParams.TimeoutHours(const Value: Integer): TBatchJobParams;
begin
  Result := TBatchJobParams(Add('timeout_hours', Value));
end;

end.

unit MistralAI.Chat;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, System.Threading,
  REST.Json.Types, System.NetEncoding, System.Net.Mime, MistralAI.API.Params,
  MistralAI.API, MistralAI.Functions.Core, MistralAI.Functions.Tools,
  MistralAI.Async.Support, MistralAI.Params.Core, MistralAI.Types;

type
  /// <summary>
  /// Represents a message payload that includes an image, identified by a URL or a base-64 encoded string.
  /// </summary>
  /// <remarks>
  /// This class is used to encapsulate details of an image message, including its source (URL or base-64 string)
  /// and additional descriptive information. It extends <c>TJSONParam</c> for JSON serialization and integration with APIs.
  /// </remarks>
  /// <example>
  /// This class can be utilized to construct structured image messages for communication in chat systems.
  /// </example>
  TMessageImageURL = class(TJSONParam)
  public
    /// <summary>
    /// Url or base-64 string
    /// </summary>
    function Url(const Value: string): TMessageImageURL;
    /// <summary>
    /// Detail string
    /// </summary>
    function Detail(const Value: string): TMessageImageURL;
  end;

  /// <summary>
  /// Represents the content of a message, which can be either text or an image URL.
  /// </summary>
  /// <remarks>
  /// This class is used to define the structure and type of content within a message,
  /// such as textual data or image references. It extends <c>TJSONParam</c> for
  /// seamless JSON serialization and integration with APIs.
  /// </remarks>
  TMessageContent = class(TJSONParam)
  public
    /// <summary>
    /// Type of the content: text or image_url
    /// </summary>
    function &Type(const Value: TContentType): TMessageContent;
    /// <summary>
    /// Text when type is text
    /// </summary>
    function Text(const Value: string): TMessageContent;
    /// <summary>
    /// Url or base-64 string when type is image_url
    /// </summary>
    function ImageUrl(const Url: string): TMessageContent; overload;
    /// <summary>
    /// Url or base-64 string when type is image_url
    /// </summary>
    function ImageUrl(const Url: string; const Detail: string): TMessageContent; overload;
  end;

  /// <summary>
  /// Represents the metadata and arguments of a function invoked during a chat interaction.
  /// </summary>
  /// <remarks>
  /// This class is used to define the structure of function calls, including the function's name and its associated arguments.
  /// It is designed to be serialized into JSON format for integration with APIs or other systems requiring structured function data.
  /// </remarks>
  TFunctionCalled = class(TJSONParam)
  public
    /// <summary>
    /// The name of the function called
    /// </summary>
    function Name(const Value: string): TFunctionCalled;
    /// <summary>
    /// The arguments returned by the function called
    /// </summary>
    function Arguments(const Value: string): TFunctionCalled;
  end;

  /// <summary>
  /// Represents a tool call configuration used in chat-based operations.
  /// </summary>
  /// <remarks>
  /// This class is designed to define and manage tool calls within chat contexts, including
  /// their type, identifier, and associated functions. It integrates with <c>TJSONParam</c>
  /// for seamless serialization and API interactions.
  /// </remarks>
  TToolCalls = class(TJSONParam)
  public
    /// <summary>
    /// Tool calls id
    /// </summary>
    function Id(const Value: string): TToolCalls;
    /// <summary>
    /// Tool calls type: Default: "function"
    /// </summary>
    function &Type(const Value: TToolType): TToolCalls;
    /// <summary>
    /// Represents the object function called
    /// </summary>
    function Func(const Name: string; Arguments: string): TToolCalls;
    /// <summary>
    /// Create a new <c>TtoolCalls</c> instance
    /// </summary>
    class function New(Id, Name, Arguments: string): TToolCalls; overload;
    /// <summary>
    /// Create a new <c>TtoolCalls</c> instance
    /// </summary>
    class function New(Name, Arguments: string): TToolCalls; overload;
  end;

  /// <summary>
  /// Represents the payload structure for a chat message in the context of a conversation.
  /// </summary>
  /// <remarks>
  /// This class encapsulates the essential elements of a chat message, including its role, content,
  /// and associated metadata. It extends <c>TJSONParam</c>, enabling seamless integration with JSON-based
  /// APIs for chat functionalities. This class is a foundational building block for managing the flow of
  /// conversations between users, systems, and assistants.
  /// </remarks>
  TChatMessagePayload = class(TJSONParam)
  public
    /// <summary>
    /// Gets or sets the role of the message.
    /// </summary>
    /// <remarks>
    /// The <c>Role</c> property determines who is sending the message. It can be a "user" (representing the end user), an "assistant" (representing an AI or bot),
    /// or "system" (representing system-level messages). This property is essential for contextualizing the content of the message within the chat.
    /// </remarks>
    function Role(const Value: TMessageRole): TChatMessagePayload;
    /// <summary>
    /// Gets or sets the content of the message.
    /// </summary>
    /// <remarks>
    /// The <c>Content</c> property contains the actual message text. This is a required field and cannot be empty, as it represents the core information being exchanged
    /// in the chat, whether it's from the user, the assistant, or the system.
    /// </remarks>
    function Content(const Value: string): TChatMessagePayload; overload;
    /// <summary>
    /// Gets or sets the content of the message.
    /// </summary>
    /// <remarks>
    /// The <c>Content</c> property contains the actual message text. This is a required field and cannot be empty, as it represents the core information being exchanged
    /// in the chat, whether it's from the user, the assistant, or the system.
    /// </remarks>
    function Content(const Value: TArray<string>): TChatMessagePayload; overload;
    /// <summary>
    /// Gets or sets the content of the message.
    /// </summary>
    /// <remarks>
    /// The <c>Content</c> property contains the actual message text. This is a required field and cannot be empty, as it represents the core information being exchanged
    /// in the chat, whether it's from the user, the assistant, or the system.
    /// </remarks>
    function Content(const Kind: TContentType; const Value: string; const Detail: string = ''): TChatMessagePayload; overload;
    /// <summary>
    /// Gets or sets the content of the message.
    /// </summary>
    /// <remarks>
    /// The <c>Content</c> property contains the actual message text. This is a required field and cannot be empty, as it represents the core information being exchanged
    /// in the chat, whether it's from the user, the assistant, or the system.
    /// </remarks>
    function Content(const Value: TJSONArray): TChatMessagePayload; overload;
    /// <summary>
    /// Set prefix value
    /// </summary>
    function Prefix(const Value: Boolean): TChatMessagePayload;
    /// <summary>
    /// Set a tool_calls with an array of functions
    /// </summary>
    function ToolCalls(const Value: TArray<TToolCalls>): TChatMessagePayload; overload;
    /// <summary>
    /// Creates a new chat message payload with the role of the assistant.
    /// </summary>
    /// <param name="Value">
    /// The content of the message that the assistant is sending.
    /// </param>
    /// <param name="Prefix">
    /// Use prefix or no.
    /// </param>
    /// <returns>
    /// A <c>TChatMessagePayload</c> instance with the role set to "assistant" and the provided content.
    /// </returns>
    /// <remarks>
    /// This method is a convenience for creating assistant messages. Use this method when the assistant needs to respond to the user or system.
    /// </remarks>
    class function Assistant(const Value: string; const Prefix: Boolean = False): TChatMessagePayload; overload;
    /// <summary>
    /// Creates a new chat message payload with the role of the assistant and includes associated vision sources.
    /// </summary>
    /// <param name="Value">
    /// The content of the message that the user is sending.
    /// </param>
    /// <param name="Url">
    /// An array of strings representing vision sources.
    /// </param>
    /// <returns>
    /// A <c>TChatMessagePayload</c> instance with the role set to "user", the provided content, and the specified vision sources.
    /// </returns>
    /// <remarks>
    /// This method is used to create messages from the user's perspective that include both text content and optional vision sources.
    /// The vision sources can be URLs or Base64-encoded images, and they are used to enhance the message with visual information.
    /// </remarks>
    class function Assistant(const Value: string; const Url: TArray<string>; const Prefix: Boolean = False): TChatMessagePayload; overload;
    /// <summary>
    /// Creates a new chat message payload with the role of the assistant and includes tool calls.
    /// </summary>
    /// <param name="Value">
    /// The content of the message that the user is sending.
    /// </param>
    /// <param name="Func">
    /// An array of strings representing tool calls sources.
    /// </param>
    /// <returns>
    /// A <c>TChatMessagePayload</c> instance with the role set to "user", the provided content, and the specified vision sources.
    /// </returns>
    /// <remarks>
    /// This method is used to create messages from the user's perspective that include both text content and optional vision sources.
    /// The vision sources can be URLs or Base64-encoded images, and they are used to enhance the message with visual information.
    /// </remarks>
    class function Assistant(const Value: string; const Func: TArray<TToolCalls>; const Prefix: Boolean = False): TChatMessagePayload; overload;
    /// <summary>
    /// Creates a new chat message payload with the role of the assistant and includes associated vision sources and tool calls.
    /// </summary>
    /// <param name="Value">
    /// The content of the message that the user is sending.
    /// </param>
    /// <param name="Url">
    /// An array of strings representing vision sources.
    /// </param>
    /// </param>
    /// <param name="Func">
    /// An array of strings representing tool calls sources.
    /// </param>
    /// <returns>
    /// A <c>TChatMessagePayload</c> instance with the role set to "user", the provided content, and the specified vision sources.
    /// </returns>
    /// <remarks>
    /// This method is used to create messages from the user's perspective that include both text content and optional vision sources.
    /// The vision sources can be URLs or Base64-encoded images, and they are used to enhance the message with visual information.
    /// </remarks>
    class function Assistant(const Value: string; const Url: TArray<string>;
      const Func: TArray<TToolCalls>; const Prefix: Boolean = False): TChatMessagePayload; overload;
    /// <summary>
    /// Creates a new chat message payload with the role of the system.
    /// </summary>
    /// <param name="Value">
    /// The content of the system message.
    /// </param>
    /// <returns>
    /// A <c>TChatMessagePayload</c> instance with the role set to "system" and the provided content.
    /// </returns>
    /// <remarks>
    /// This method is used to create system-level messages, which may be used for notifications, warnings, or other system-related interactions.
    /// </remarks>
    class function System(const Value: string): TChatMessagePayload; overload;
    /// <summary>
    /// Creates a new chat message payload with the role of the system.
    /// </summary>
    /// <param name="Value">
    /// The content of the system message.
    /// </param>
    /// <returns>
    /// A <c>TChatMessagePayload</c> instance with the role set to "system" and the provided content.
    /// </returns>
    /// <remarks>
    /// This method is used to create system-level messages, which may be used for notifications, warnings, or other system-related interactions.
    /// </remarks>
    class function System(const Value: TArray<string>): TChatMessagePayload; overload;
    /// <summary>
    /// Creates a new chat message payload with the role of the user.
    /// </summary>
    /// <param name="Value">
    /// The content of the message that the user is sending.
    /// </param>
    /// <returns>
    /// A <c>TChatMessagePayload</c> instance with the role set to "user" and the provided content.
    /// </returns>
    /// <remarks>
    /// This method is used to create messages from the user's perspective, typically representing inputs or queries in the conversation.
    /// </remarks>
    class function User(const Value: string): TChatMessagePayload; overload;
    /// <summary>
    /// Creates a new chat message payload with the role of the user and includes associated vision sources.
    /// </summary>
    /// <param name="Value">
    /// The content of the message that the user is sending.
    /// </param>
    /// <param name="Url">
    /// An array of strings representing vision sources.
    /// </param>
    /// <returns>
    /// A <c>TChatMessagePayload</c> instance with the role set to "user", the provided content, and the specified vision sources.
    /// </returns>
    /// <remarks>
    /// This method is used to create messages from the user's perspective that include both text content and optional vision sources.
    /// The vision sources can be URLs or Base64-encoded images, and they are used to enhance the message with visual information.
    /// </remarks>
    class function User(const Value: string; const Url: TArray<string>): TChatMessagePayload; overload;
  end;

  /// <summary>
  /// Represents the payload structure for a chat message in the context of a conversation.
  /// </summary>
  /// <remarks>
  /// This class encapsulates the essential elements of a chat message, including its role, content,
  /// and associated metadata. It extends <c>TJSONParam</c>, enabling seamless integration with JSON-based
  /// APIs for chat functionalities. This class is a foundational building block for managing the flow of
  /// conversations between users, systems, and assistants.
  /// </remarks>
  PayLoad = TChatMessagePayload;

  /// <summary>
  /// The <c>TChatParams</c> class represents the set of parameters used to configure a chat interaction with an AI model.
  /// </summary>
  /// <remarks>
  /// This class allows you to define various settings that control how the model behaves, including which model to use, how many tokens to generate,
  /// what kind of messages to send, and how the model should handle its output. By using this class, you can fine-tune the AI's behavior and response format
  /// based on your application's specific needs.
  /// <para>
  /// It inherits from <c>TJSONParam</c>, which provides methods for handling and serializing the parameters as JSON, allowing seamless integration
  /// with JSON-based APIs.
  /// </para>
  /// <code>
  /// var
  ///   Params: TChatParams;
  /// begin
  ///   Params := TChatParams.Create
  ///     .Model('my_model')
  ///     .MaxTokens(100)
  ///     .Messages([TChatMessagePayload.User('Hello!')])
  ///     .ResponseFormat('json_object')
  ///     .Temperature(0.7)
  ///     .TopP(1)
  ///     .SafePrompt(True);
  /// end;
  /// </code>
  /// This example shows how to instantiate and configure a <c>TChatParams</c> object for interacting with an AI model.
  /// </remarks>
  TChatParams = class(TJSONParam)
    /// <summary>
    /// Specifies the identifier of the model to use.
    /// Currently compatible with "mistral-tiny" or "mistral-large-latest".
    /// </summary>
    /// <param name="Value">
    /// The model ID to be used for the completion.
    /// Ensure that the specified model is supported and correctly spelled.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// This parameter is required and determines which model will process the request.
    /// </remarks>
    function Model(const Value: string): TChatParams;
    /// <summary>
    /// Sets the maximum number of tokens to generate in the completion.
    /// The total token count of your prompt plus <c>max_tokens</c> cannot exceed the model's context length.
    /// </summary>
    /// <param name="Value">
    /// The maximum number of tokens to generate.
    /// Choose an appropriate value based on your prompt length to avoid exceeding the model's limit.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function MaxTokens(const Value: Integer): TChatParams;
    /// <summary>
    /// Provides the prompt(s) for the model to generate completions from, structured as a list of messages with roles (user, assistant, system) and content.
    /// </summary>
    /// <param name="Value">An array of <c>TChatMessagePayload</c> representing the messages in the conversation.</param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// The first message should have either a "user" or "system" role to initiate the conversation properly.
    /// </remarks>
    function Messages(const Value: TArray<TChatMessagePayload>): TChatParams;
    /// <summary>
    /// Specifies the format in which the model should return the response. This can include formats like JSON or plain text.
    /// </summary>
    /// <param name="Value">The desired response format, with the default being <c>"json_object"</c>.</param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// If not specified, the default value is <c>{ "type": "text" }</c>. When using JSON mode, it's necessary to instruct the model to produce JSON explicitly through the system or user messages.
    /// </remarks>
    function ResponseFormat(const Value: string = 'json_object'): TChatParams;
    /// <summary>
    /// Specifies whether to stream back partial progress as server-sent events (SSE).
    /// If <c>true</c>, tokens are sent as they become available.
    /// If <c>false</c>, the server will hold the request open until timeout or completion.
    /// </summary>
    /// <param name="Value">
    /// A boolean value indicating whether to enable streaming. Default is <c>true</c>, meaning streaming is enabled by default.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function Stream(const Value: Boolean = True): TChatParams;
    /// <summary>
    /// Sets the sampling temperature to use for the model's output.
    /// Higher values like 0.8 make the output more random, while lower values like 0.2 make it more focused and deterministic.
    /// </summary>
    /// <param name="Value">
    /// The temperature value between 0.0 and 1.0. Default is 0.7.
    /// A temperature of 0 makes the model deterministic, while a temperature of 1 allows for maximum creativity.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function Temperature(const Value: Single): TChatParams;
    /// <summary>
    /// Sets the nucleus sampling probability mass for the model (Top-p).
    /// For example, 0.1 means only the tokens comprising the top 10% probability mass are considered.
    /// </summary>
    /// <param name="Value">
    /// The <c>top_p</c> value between 0.0 and 1.0. Default is 1.
    /// Lower values limit the model to consider only the most probable options.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function TopP(const Value: Single): TChatParams;
    /// <summary>
    /// Determines whether a safety prompt should be injected automatically before the conversation starts.
    /// </summary>
    /// <param name="Value">
    /// A boolean indicating whether to enable the safety prompt. Default is <c>False</c>.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function SafePrompt(const Value: Boolean = False): TChatParams;
    /// <summary>
    /// Specifies a list of tools that the model can use to generate structured outputs such as JSON inputs for function calls.
    /// </summary>
    /// <param name="Value">
    /// An array of <c>TChatMessageTool</c> representing the tools available to the model.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// These tools can include functions that the model can utilize when generating output. For example, they can help the model produce structured data for specific tasks.
    /// </remarks>
    function Tools(const Value: TArray<TChatMessageTool>): TChatParams; overload;
    /// <summary>
    /// Specifies a list of tools that the model can use to generate structured outputs such as JSON inputs for function calls.
    /// </summary>
    /// <param name="Value">
    /// An array of <c>IFunctionCore</c> representing the tools available to the model.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// These tools can include functions that the model can utilize when generating output. For example, they can help the model produce structured data for specific tasks.
    /// </remarks>
    function Tools(const Value: TArray<IFunctionCore>): TChatParams; overload;
    /// <summary>
    /// Configures how the model interacts with functions. This can either prevent, allow, or require function calls depending on the setting.
    /// </summary>
    /// <param name="Value">
    /// The <c>TToolChoice</c> setting for function interaction, with a default of "auto".
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// If set to <c>none</c>, the model will not call any functions and will generate a message instead. If set to <c>auto</c>, the model can choose between generating a message or calling a function. If set to <c>any</c>, the model is required to call a function.
    /// </remarks>
    function ToolChoice(const Value: TToolChoice): TChatParams; overload;
    /// <summary>
    /// Configures how the model interacts when required is on.
    /// </summary>
    /// <param name="Value">
    /// The <c>TToolChoice</c> setting for function interaction, with a default of "auto".
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function ToolChoice(const FunctionName: string): TChatParams; overload;
    /// <summary>
    /// Sets the random seed for deterministic results during sampling.
    /// </summary>
    /// <param name="Value">An integer value to be used as the seed.</param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// Providing a random seed ensures that multiple calls with the same parameters produce the same results, useful for testing or reproducible outcomes.
    /// </remarks>
    function RandomSeed(const Value: Integer): TChatParams;
    /// <summary>
    /// Stop (string)
    /// Stop generation if this token is detected. Or if one of these tokens is detected when providing an array
    /// </summary>
    /// <param name="Value">
    /// The string that causes the stop
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function Stop(const Value: string): TChatParams; overload;
    /// <summary>
    /// Stop Array of Stop (strings) (Stop)
    /// Stop generation if this token is detected. Or if one of these tokens is detected when providing an array
    /// </summary>
    /// <param name="Value">
    /// The array of string that causes the stop
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function Stop(const Value: TArray<string>): TChatParams; overload;
    /// <summary>
    /// Presence_penalty determines how much the model penalizes the repetition of words or phrases
    /// </summary>
    /// <param name="Value">
    /// number (Presence Penalty) [ -2 .. 2 ]; Default: 0
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// A higher presence penalty encourages the model to use a wider variety of words and phrases,
    /// making the output more diverse and creative.
    /// </remarks>
    function PresencePenalty(const Value: Double): TChatParams;
    /// <summary>
    /// Frequency_penalty penalizes the repetition of words based on their frequency in the generated text.
    /// </summary>
    /// <param name="Value">
    /// number (Presence Penalty) [ -2 .. 2 ]; Default: 0
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// A higher frequency penalty discourages the model from repeating words that have already appeared
    /// frequently in the output, promoting diversity and reducing repetition.
    /// </remarks>
    function FrequencyPenalty(const Value: Double): TChatParams;
    /// <summary>
    /// Number of completions to return for each request, input tokens are only billed once.
    /// </summary>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function N(const Value: Integer): TChatParams;
  end;

  /// <summary>
  /// Represents the token usage statistics for a chat interaction, including the number of tokens
  /// used in the prompt, the completion, and the total number of tokens consumed.
  /// </summary>
  /// <remarks>
  /// The <c>TChatUsage</c> class provides insight into the number of tokens used during a chat interaction.
  /// This information is critical for understanding the cost of a request when using token-based billing systems
  /// or for monitoring the model's behavior in terms of input (prompt) and output (completion) size.
  /// </remarks>
  TChatUsage = class
  private
    [JsonNameAttribute('prompt_tokens')]
    FPrompt_tokens: Int64;
    [JsonNameAttribute('completion_tokens')]
    FCompletion_tokens: Int64;
    [JsonNameAttribute('total_tokens')]
    FTotal_tokens: Int64;
  public
    /// <summary>
    /// The number of tokens consumed by the prompt in the chat request.
    /// </summary>
    /// <remarks>
    /// This property tracks how many tokens were used for the initial input prompt sent to the model.
    /// It's useful for understanding how much of the token limit is being consumed by the user's query or system instructions.
    /// </remarks>
    property PromptTokens: Int64 read FPrompt_tokens write FPrompt_tokens;
    /// <summary>
    /// The number of tokens consumed by the completion generated by the model.
    /// </summary>
    /// <remarks>
    /// The <c>CompletionTokens</c> property tracks how many tokens were used in the response generated by the model.
    /// This helps in determining the token cost of the AI's output relative to the prompt size.
    /// </remarks>
    property CompletionTokens: Int64 read FCompletion_tokens write FCompletion_tokens;
    /// <summary>
    /// The total number of tokens used for the entire chat request, including both the prompt and the completion.
    /// </summary>
    /// <remarks>
    /// The <c>TotalTokens</c> property provides the overall token usage for a single request, which is the sum of the tokens
    /// from the prompt and the completion. This value is critical for tracking token consumption and ensuring it stays within
    /// model limitations or pricing thresholds.
    /// </remarks>
    property TotalTokens: Int64 read FTotal_tokens write FTotal_tokens;
  end;

  /// <summary>
  /// Represents a chat message exchanged between participants (user, assistant, or system) in a conversation.
  /// </summary>
  /// <remarks>
  /// The <c>TChatMessage</c> class encapsulates the essential information of a message within a chat application, including:
  /// - The role of the sender (user, assistant, or system).
  /// - The content of the message itself.
  /// - Optionally, a list of tool calls that may be required to complete the message response.
  /// This class is fundamental for managing the flow of a conversation, allowing the system to track who said what and what actions need to be taken.
  /// </remarks>
  TChatMessage = class
  private
    FRole: string;
    FContent: string;
    [JsonNameAttribute('tool_calls')]
    FToolsCalls: TArray<TCalledFunction>;
    FPrefix: Boolean;
  public
    /// <summary>
    /// The role of the author of this message, indicating the sender (e.g., user, assistant, or system).
    /// </summary>
    /// <remarks>
    /// The <c>Role</c> property identifies the participant responsible for the message. Common values are "user" for messages sent by the user,
    /// "assistant" for responses generated by the AI, or "system" for control messages.
    /// </remarks>
    property Role: string read FRole write FRole;
    /// <summary>
    /// The contents of the message.
    /// </summary>
    /// <remarks>
    /// The <c>Content</c> property stores the actual message text. This can include user inputs, assistant-generated replies, or system instructions.
    /// </remarks>
    property Content: string read FContent write FContent;
    /// <summary>
    /// A list of tool calls to be executed for query completion.
    /// </summary>
    /// <remarks>
    /// The <c>ToolsCalls</c> property contains a list of functions or tools that need to be invoked to process the current query further.
    /// This is typically used when the assistant needs to call external APIs or perform specific actions before delivering a final response.
    /// </remarks>
    property ToolsCalls: TArray<TCalledFunction> read FToolsCalls write FToolsCalls;
    /// <summary>
    /// Prefix of the content.
    /// </summary>
    /// <remarks>
    property Prefix: Boolean read FPrefix write FPrefix;
    /// <summary>
    /// Destructor to release any resources used by this instance.
    /// </summary>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a single completion option generated by the AI model during a chat interaction.
  /// </summary>
  /// <remarks>
  /// The <c>TChatChoices</c> class stores the results of the AI model's response to a user prompt. Each instance of this class represents one of potentially
  /// many choices that the model could return. This includes:
  /// - An index identifying the choice.
  /// - A message generated by the model.
  /// - Optional deltas for streamed responses.
  /// - The reason the model stopped generating tokens.
  /// This class is useful when multiple potential responses are generated and evaluated, or when streaming responses incrementally.
  /// </remarks>
  TChatChoices = class
  private
    FIndex: Int64;
    FMessage: TChatMessage;
    [JsonReflectAttribute(ctString, rtString, TFinishReasonInterceptor)]
    FFinish_reason: TFinishReason;
    FDelta: TChatMessage;
  public
    /// <summary>
    /// The index of the choice in the list of possible choices generated by the model.
    /// </summary>
    /// <remarks>
    /// The <c>Index</c> property helps identify the position of this particular choice in a set of choices provided by the AI model.
    /// This is useful when multiple options are generated for completion, and each one is referenced by its index.
    /// </remarks>
    property Index: Int64 read FIndex write FIndex;
    /// <summary>
    /// A chat completion message generated by the AI model.
    /// </summary>
    /// <remarks>
    /// The <c>Message</c> property contains the message that the model generated based on the provided prompt or conversation context.
    /// This is typically a complete message representing the AI's response to a user or system message.
    /// </remarks>
    property Message: TChatMessage read FMessage write FMessage;
    /// <summary>
    /// A chat completion delta representing partial responses generated during streaming.
    /// </summary>
    /// <remarks>
    /// The <c>Delta</c> property holds an incremental message (or delta) when the model sends streamed responses.
    /// This allows the model to progressively generate and deliver a response before it is fully completed.
    /// </remarks>
    property Delta: TChatMessage read FDelta write FDelta;
    /// <summary>
    /// The reason the model stopped generating tokens.
    /// </summary>
    /// <remarks>
    /// The <c>FinishReason</c> property indicates why the model ceased generating further tokens. This could be due to reaching a natural stop point
    /// in the conversation, hitting a token limit, or encountering a stop sequence provided by the user.
    /// </remarks>
    property FinishReason: TFinishReason read FFinish_reason write FFinish_reason;
    /// <summary>
    /// Destructor to clean up resources used by the <c>TChatChoices</c> instance.
    /// </summary>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a chat completion response generated by an AI model, containing the necessary metadata,
  /// the generated choices, and usage statistics.
  /// </summary>
  /// <remarks>
  /// The <c>TChat</c> class encapsulates the results of a chat request made to an AI model.
  /// It contains details such as a unique identifier, the model used, when the completion was created,
  /// the choices generated by the model, and token usage statistics.
  /// This class is crucial for managing the results of AI-driven conversations and understanding the
  /// underlying usage and response characteristics of the AI.
  /// </remarks>
  TChat = class
  private
    FId: string;
    FObject: string;
    FCreated: Int64;
    FModel: string;
    FChoices: TArray<TChatChoices>;
    FUsage: TChatUsage;
  public
    /// <summary>
    /// A unique identifier for the chat completion.
    /// </summary>
    /// <remarks>
    /// The <c>Id</c> property stores a unique string that identifies the specific chat completion request.
    /// This is useful for tracking and managing chat sessions or retrieving the results of a particular interaction.
    /// </remarks>
    property Id: string read FId write FId;
    /// <summary>
    /// The object type, which is always "chat.completion".
    /// </summary>
    /// <remarks>
    /// The <c>Object</c> property describes the type of the response. For chat completions, this value is always "chat.completion",
    /// providing a clear indication of the response type when working with multiple object types in a system.
    /// </remarks>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// The Unix timestamp (in seconds) of when the chat completion was created.
    /// </summary>
    /// <remarks>
    /// The <c>Created</c> property contains a Unix timestamp indicating when the AI generated the chat completion. This is
    /// useful for logging, auditing, or ordering chat completions chronologically.
    /// </remarks>
    property Created: Int64 read FCreated write FCreated;
    /// <summary>
    /// The model used for the chat completion.
    /// </summary>
    /// <remarks>
    /// The <c>Model</c> property specifies which AI model was used to generate the chat completion. This can be helpful
    /// when comparing results across different models or tracking which model versions are producing responses.
    /// </remarks>
    property Model: string read FModel write FModel;
    /// <summary>
    /// A list of chat completion choices generated by the model.
    /// </summary>
    /// <remarks>
    /// The <c>Choices</c> property holds an array of <c>TChatChoices</c> objects, which represent the different response options
    /// generated by the AI model. There may be multiple choices if the request asked for more than one completion.
    /// </remarks>
    property Choices: TArray<TChatChoices> read FChoices write FChoices;
    /// <summary>
    /// Usage statistics for the completion request, including token counts for the prompt and completion.
    /// </summary>
    /// <remarks>
    /// The <c>Usage</c> property contains information about the number of tokens consumed during the request, including the
    /// tokens used in the prompt and those generated in the completion. This data is important for monitoring API usage and costs.
    /// </remarks>
    property Usage: TChatUsage read FUsage write FUsage;
    /// <summary>
    /// Destructor to clean up resources used by this <c>TChat</c> instance.
    /// </summary>
    /// <remarks>
    /// The destructor ensures that any allocated resources, such as the memory for the array of choices or usage statistics, are
    /// properly released when the object is no longer needed.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TChat</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynChat</c> type extends the <c>TAsynParams&lt;TChat&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynChat = TAsyncCallBack<TChat>;

  /// <summary>
  /// Manages asynchronous streaming chat callBacks for a chat request using <c>TChat</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynChatStream</c> type extends the <c>TAsynStreamParams&lt;TChat&gt;</c> record to support the lifecycle of an asynchronous streaming chat operation.
  /// It provides callbacks for different stages, including when the operation starts, progresses with new data chunks, completes successfully, or encounters an error.
  /// This structure is ideal for handling scenarios where the chat response is streamed incrementally, providing real-time updates to the user interface.
  /// </remarks>
  TAsynChatStream = TAsyncStreamCallBack<TChat>;

  /// <summary>
  /// Represents a callback procedure used during the reception of responses from a chat request in streaming mode.
  /// </summary>
  /// <param name="Chat">
  /// The <c>TChat</c> object containing the current information about the response generated by the model.
  /// If this value is <c>nil</c>, it indicates that the data stream is complete.
  /// </param>
  /// <param name="IsDone">
  /// A boolean flag indicating whether the streaming process is complete.
  /// If <c>True</c>, it means the model has finished sending all response data.
  /// </param>
  /// <param name="Cancel">
  /// A boolean flag that can be set to <c>True</c> within the callback to cancel the streaming process.
  /// If set to <c>True</c>, the streaming will be terminated immediately.
  /// </param>
  /// <remarks>
  /// This callback is invoked multiple times during the reception of the response data from the model.
  /// It allows for real-time processing of received messages and interaction with the user interface or other systems
  /// based on the state of the data stream.
  /// When the <c>IsDone</c> parameter is <c>True</c>, it indicates that the model has finished responding,
  /// and the <c>Chat</c> parameter will be <c>nil</c>.
  /// </remarks>
  TChatEvent = reference to procedure(var Chat: TChat; IsDone: Boolean; var Cancel: Boolean);

  /// <summary>
  /// The <c>TChatRoute</c> class inherits from <c>TMistralAIAPIRoute</c> and provides an interface for managing various interactions with the chat API.
  /// It supports creating chat completion requests in synchronous, asynchronous, and streaming modes, offering mechanisms to handle responses generated by the model.
  /// </summary>
  /// <remarks>
  /// This class facilitates sending messages to a chat model, receiving responses, and managing them, whether synchronously or asynchronously.
  /// The primary methods in the class are:
  /// <para>
  /// - <c>Create</c> : Sends a chat request and waits for a full response.
  /// </para>
  /// <para>
  /// - <c>AsyncCreate</c> : Performs an asynchronous chat completion request with event handling.
  /// </para>
  /// <para>
  /// - <c>CreateStream</c> : Initiates a chat completion request in streaming mode, receiving tokens progressively.
  /// </para>
  /// <para>
  /// - <c>ASyncCreateStream</c> : Performs an asynchronous request in streaming mode with event handling.
  /// </para>
  /// Each method allows configuring model parameters, setting input messages, managing token limits, and including callbacks for processing responses or errors.
  /// </remarks>
  TChatRoute = class(TMistralAIAPIRoute)
  public
    /// <summary>
    /// Create an asynchronous completion for chat message
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the parameters for the chat request, such as model selection, messages, and other parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for the asynchronous chat completion, such as on success and on error.
    /// </param>
    /// <remarks>
    /// This procedure initiates an asynchronous request to generate a chat completion based on the provided parameters. The response or error is handled by the provided callBacks.
    /// <code>
    /// MistralAI.Chat.AsyncCreate(
    ///   procedure (Params: TChatParams)
    ///   begin
    ///     // Define chat parameters
    ///   end,
    ///   function: TAsynChat
    ///   begin
    ///     Result.Sender := Memo1;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Chat: TChat)
    ///     begin
    ///       var M := Sender as TMemo; // Because Result.Sender = Memo1
    ///       // Handle success operation
    ///     end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Value: string)
    ///     begin
    ///       // Handle error message
    ///     end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncCreate(ParamProc: TProc<TChatParams>; CallBacks: TFunc<TAsynChat>);
    /// <summary>
    /// Creates an asynchronous streaming chat completion request.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the chat request, including the model, messages, and additional options such as max tokens and streaming mode.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a <c>TAsynChatStream</c> record which contains event handlers for managing different stages of the streaming process: progress updates, success, errors, and cancellation.
    /// </param>
    /// <remarks>
    /// This procedure initiates an asynchronous chat operation in streaming mode, where tokens are progressively received and processed.
    /// The provided event handlers allow for handling progress (i.e., receiving tokens in real time), detecting success, managing errors, and enabling cancellation logic.
    /// <code>
    /// MistralAI.Chat.AsyncCreateStream(
    ///   procedure(Params: TChatParams)
    ///   begin
    ///     // Define chat parameters
    ///     Params.Stream;
    ///   end,
    ///
    ///   function: TAsynChatStream
    ///   begin
    ///     Result.Sender := Memo1; // Instance passed to callback parameter
    ///     Result.OnProgress :=
    ///         procedure (Sender: TObject; Chat: TChat)
    ///         begin
    ///           // Handle progressive updates to the chat response
    ///         end;
    ///     Result.OnSuccess :=
    ///         procedure (Sender: TObject)
    ///         begin
    ///           // Handle success when the operation completes
    ///         end;
    ///     Result.OnError :=
    ///         procedure (Sender: TObject; Value: string)
    ///         begin
    ///           // Handle error message
    ///         end;
    ///     Result.OnDoCancel :=
    ///         function: Boolean
    ///         begin
    ///           Result := CheckBox1.Checked; // Click on checkbox to cancel
    ///         end;
    ///     Result.OnCancellation :=
    ///         procedure (Sender: TObject)
    ///         begin
    ///           // Processing when process has been canceled
    ///         end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncCreateStream(ParamProc: TProc<TChatParams>;
      CallBacks: TFunc<TAsynChatStream>);
    /// <summary>
    /// Creates a completion for the chat message using the provided parameters.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the chat request, such as selecting the model, providing messages, setting token limits, etc.
    /// </param>
    /// <returns>
    /// Returns a <c>TChat</c> object that contains the chat response, including the choices generated by the model.
    /// </returns>
    /// <exception cref="MistralAIExceptionAPI">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="MistralAIExceptionInvalidRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// The <c>Create</c> method sends a chat completion request and waits for the full response. The returned <c>TChat</c> object contains the model's generated response, including multiple choices if available.
    ///
    /// Example usage:
    /// <code>
    ///   MistralAI := TMistralAIFactory.CreateInstance(BaererKey);
    ///   var Chat := MistralAI.Chat.Create(
    ///     procedure (Params: TChatParams)
    ///     begin
    ///       // Define chat parameters
    ///     end);
    ///   try
    ///     for var Choice in Chat.Choices do
    ///       WriteLn(Choice.Message.Content);
    ///   finally
    ///     Chat.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Create(ParamProc: TProc<TChatParams>): TChat;
    /// <summary>
    /// Creates a chat message completion with a streamed response.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the chat request, such as selecting the model, providing messages, and adjusting other settings like token limits or temperature.
    /// </param>
    /// <param name="Event">
    /// A callback of type <c>TChatEvent</c> that is triggered with each chunk of data received during the streaming process. It includes the current state of the <c>TChat</c> object, a flag indicating if the stream is done, and a boolean to handle cancellation.
    /// </param>
    /// <returns>
    /// Returns <c>True</c> if the streaming process started successfully, <c>False</c> otherwise.
    /// </returns>
    /// <remarks>
    /// This method initiates a chat request in streaming mode, where the response is delivered incrementally in real-time.
    /// The <c>Event</c> callback will be invoked multiple times as tokens are received.
    /// When the response is complete, the <c>IsDone</c> flag will be set to <c>True</c>, and the <c>Chat</c> object will be <c>nil</c>.
    /// The streaming process can be interrupted by setting the <c>Cancel</c> flag to <c>True</c> within the event.
    ///
    /// Example usage:
    /// <code>
    ///   MistralAI.Chat.CreateStream(
    ///     procedure (Params: TChatParams)
    ///     begin
    ///       // Define chat parameters
    ///     end,
    ///
    ///     procedure(var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
    ///     begin
    ///       // Handle displaying
    ///     end
    ///   );
    /// </code>
    /// </remarks>
    function CreateStream(ParamProc: TProc<TChatParams>; Event: TChatEvent): Boolean;
  end;

implementation

uses
  system.StrUtils, Rest.Json, System.Rtti, MistralAI.NetEncoding.Base64;

{ TChatParams }

function TChatParams.FrequencyPenalty(const Value: Double): TChatParams;
begin
  Result := TChatParams(Add('frequency_penalty', Value));
end;

function TChatParams.MaxTokens(const Value: Integer): TChatParams;
begin
  Result := TChatParams(Add('max_tokens', Value));
end;

function TChatParams.Messages(const Value: TArray<TChatMessagePayload>): TChatParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TChatParams(Add('messages', JSONArray));
end;

function TChatParams.Model(const Value: string): TChatParams;
begin
  Result := TChatParams(Add('model', Value));
end;

function TChatParams.N(const Value: Integer): TChatParams;
begin
  Result := TChatParams(Add('n', Value));
end;

function TChatParams.PresencePenalty(const Value: Double): TChatParams;
begin
  Result := TChatParams(Add('presence_penalty', Value));
end;

function TChatParams.RandomSeed(const Value: Integer): TChatParams;
begin
  Result := TChatParams(Add('random_seed', Value));
end;

function TChatParams.ResponseFormat(const Value: string): TChatParams;
begin
  var JSON := TJSONObject.Create;
  JSON.AddPair('type', Value);
  Result := TChatParams(Add('response_format', JSON));
end;

function TChatParams.SafePrompt(const Value: Boolean): TChatParams;
begin
  Result := TChatParams(Add('safe_prompt', Value));
end;

function TChatParams.Stop(const Value: string): TChatParams;
begin
  Result := TChatParams(Add('stop', Value));
end;

function TChatParams.Stop(const Value: TArray<string>): TChatParams;
begin
  Result := TChatParams(Add('stop', Value));
end;

function TChatParams.Stream(const Value: Boolean): TChatParams;
begin
  Result := TChatParams(Add('stream', Value));
end;

function TChatParams.Temperature(const Value: Single): TChatParams;
begin
  Result := TChatParams(Add('temperature', Value));
end;

function TChatParams.ToolChoice(const Value: TToolChoice): TChatParams;
begin
  Result := TChatParams(Add('tool_choice', Value.ToString));
end;

function TChatParams.ToolChoice(const FunctionName: string): TChatParams;
begin
  var Tool := TJSONParam.Create
        .Add('type', 'function')
        .Add('function', TJSONObject.Create
          .AddPair('Name', FunctionName));
  Result := TChatParams(Add('tool_choice', Tool.Detach));
end;

function TChatParams.Tools(const Value: TArray<IFunctionCore>): TChatParams;
var
  Arr: TArray<TChatMessageTool>;
begin
  for var Item in Value do
    Arr := Arr + [TChatMessageTool.Add(Item)];
  Result := Tools(Arr);
end;

function TChatParams.Tools(const Value: TArray<TChatMessageTool>): TChatParams;
var
  Item: TChatMessageTool;
  Items: TJSONArray;
begin
  Items := TJSONArray.Create;
  try
    for Item in Value do
      begin
        Items.Add(Item.ToJson);
      end;
    Result := TChatParams(Add('tools', Items));
  except
    on E: Exception do
      begin
        Items.Free;
        raise;
      end;
  end;
end;

function TChatParams.TopP(const Value: Single): TChatParams;
begin
  Result := TChatParams(Add('top_p', Value));
end;

{ TChatChoices }

destructor TChatChoices.Destroy;
begin
  if Assigned(FMessage) then
    FMessage.Free;
  if Assigned(FDelta) then
    FDelta.Free;
  inherited;
end;

{ TChat }

destructor TChat.Destroy;
begin
  if Assigned(FUsage) then
    FUsage.Free;
  for var Item in FChoices do
    Item.Free;
  inherited;
end;

{ TChatRoute }

procedure TChatRoute.AsyncCreate(ParamProc: TProc<TChatParams>;
  CallBacks: TFunc<TAsynChat>);
begin
  with TAsyncCallBackExec<TAsynChat, TChat>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TChat
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TChatRoute.AsyncCreateStream(ParamProc: TProc<TChatParams>;
  CallBacks: TFunc<TAsynChatStream>);
begin
  var CallBackParams := TUseParamsFactory<TAsynChatStream>.CreateInstance(CallBacks);

  var Sender := CallBackParams.Param.Sender;
  var OnStart := CallBackParams.Param.OnStart;
  var OnSuccess := CallBackParams.Param.OnSuccess;
  var OnProgress := CallBackParams.Param.OnProgress;
  var OnError := CallBackParams.Param.OnError;
  var OnCancellation := CallBackParams.Param.OnCancellation;
  var OnDoCancel := CallBackParams.Param.OnDoCancel;

  var Task: ITask := TTask.Create(
          procedure()
          begin
            {--- Pass the instance of the current class in case no value was specified. }
            if not Assigned(Sender) then
              Sender := Self;

            {--- Trigger OnStart callback }
            if Assigned(OnStart) then
              TThread.Queue(nil,
                procedure
                begin
                  OnStart(Sender);
                end);
            try
              var Stop := False;

              {--- Processing }
              CreateStream(ParamProc,
                procedure (var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
                begin
                  {--- Check that the process has not been canceled }
                  if Assigned(OnDoCancel) then
                    TThread.Queue(nil,
                        procedure
                        begin
                          Stop := OnDoCancel();
                        end);
                  if Stop then
                    begin
                      {--- Trigger when processus was stopped }
                      if Assigned(OnCancellation) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnCancellation(Sender)
                        end);
                      Cancel := True;
                      Exit;
                    end;
                  if not IsDone and Assigned(Chat) then
                    begin
                      var LocalChat := Chat;
                      Chat := nil;

                      {--- Triggered when processus is progressing }
                      if Assigned(OnProgress) then
                        TThread.Synchronize(TThread.Current,
                        procedure
                        begin
                          try
                            OnProgress(Sender, LocalChat);
                          finally
                            {--- Makes sure to release the instance containing the data obtained
                                 following processing}
                            LocalChat.Free;
                          end;
                        end)
                     else
                       LocalChat.Free;
                    end
                  else
                  if IsDone then
                    begin
                      {--- Trigger OnEnd callback when the process is done }
                      if Assigned(OnSuccess) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnSuccess(Sender);
                        end);
                    end;
                end);
            except
              on E: Exception do
                begin
                  var Error := AcquireExceptionObject;
                  try
                    var ErrorMsg := (Error as Exception).Message;

                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(OnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        OnError(Sender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
          end);
  Task.Start;
end;

function TChatRoute.Create(ParamProc: TProc<TChatParams>): TChat;
begin
  Result := API.Post<TChat, TChatParams>('chat/completions', ParamProc);
end;

function TChatRoute.CreateStream(ParamProc: TProc<TChatParams>;
  Event: TChatEvent): Boolean;
var
  Response: TStringStream;
  RetPos: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    RetPos := 0;
    Result := API.Post<TChatParams>('chat/completions', ParamProc, Response,
      procedure(const Sender: TObject; AContentLength: Int64; AReadCount: Int64; var AAbort: Boolean)
      var
        IsDone: Boolean;
        Data: string;
        Chat: TChat;
        TextBuffer: string;
        Line: string;
        Ret: Integer;
      begin
        try
          TextBuffer := Response.DataString;
        except
          on E: EEncodingError do
            Exit;
        end;

        repeat
          Ret := TextBuffer.IndexOf(#10, RetPos);
          if Ret < 0 then
            Continue;
          Line := TextBuffer.Substring(RetPos, Ret - RetPos);
          RetPos := Ret + 1;

          if Line.IsEmpty or Line.StartsWith(#10) then
            Continue;
          Chat := nil;
          Data := Line.Replace('data: ', '').Trim([' ', #13, #10]);
          IsDone := Data = '[DONE]';

          if not IsDone then
          try
            Chat := TJson.JsonToObject<TChat>(Data);
          except
            Chat := nil;
          end;

          try
            Event(Chat, IsDone, AAbort);
          finally
            Chat.Free;
          end;
        until Ret < 0;

      end);
  finally
    Response.Free;
  end;
end;

{ TChatMessage }

destructor TChatMessage.Destroy;
begin
  for var Tool in FToolsCalls do
    Tool.Free;
  inherited;
end;

{ TChatMessagePayload }

function TChatMessagePayload.Content(const Value: string): TChatMessagePayload;
begin
  Result := TChatMessagePayload(Add('content', Value));
end;

class function TChatMessagePayload.Assistant(const Value: string; const Prefix: Boolean): TChatMessagePayload;
begin
  Result := TChatMessagePayload.Create.Role(TMessageRole.assistant).Content(Value).Prefix(Prefix);
end;

function TChatMessagePayload.Content(const Kind: TContentType; const Value,
  Detail: string): TChatMessagePayload;
begin
  var MessageContent := TMessageContent.Create.&Type(Kind);
  case Kind of
    text:
      MessageContent := MessageContent.Text(Value);
    image_url:
      MessageContent := MessageContent.ImageUrl(Value, Detail);
  end;
  Result := TChatMessagePayload(Add('content', MessageContent.Detach));
end;

class function TChatMessagePayload.Assistant(const Value: string;
  const Url: TArray<string>; const Prefix: Boolean): TChatMessagePayload;
begin
  var JSONArray := TJSONArray.Create;
  JSONArray.Add(TMessageContent.Create.&Type(TContentType.text).Text(Value).Detach);
  for var Item in Url do
    JSONArray.Add(TMessageContent.Create.&Type(TContentType.image_url).ImageUrl(UrlCheck(Item)).Detach);
  Result := TChatMessagePayload.Create.Role(TMessageRole.assistant).Content(JSONArray).Prefix(Prefix);
end;

class function TChatMessagePayload.Assistant(const Value: string;
  const Func: TArray<TToolCalls>; const Prefix: Boolean): TChatMessagePayload;
begin
  Result := TChatMessagePayload.Create.Role(TMessageRole.assistant).Content(Value).ToolCalls(Func).Prefix(Prefix);
end;

function TChatMessagePayload.Content(const Value: TJSONArray): TChatMessagePayload;
begin
  Result := TChatMessagePayload(Add('content', Value));
end;

function TChatMessagePayload.Content(
  const Value: TArray<string>): TChatMessagePayload;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(TJSONObject.Create.AddPair('type', 'text').AddPair('text', Item));
  Result := TChatMessagePayload(Add('content', JSONArray));
end;

function TChatMessagePayload.Prefix(const Value: Boolean): TChatMessagePayload;
begin
  Result := TChatMessagePayload(Add('prefix', Value));
end;

function TChatMessagePayload.Role(const Value: TMessageRole): TChatMessagePayload;
begin
  Result := TChatMessagePayload(Add('role', Value.ToString));
end;

class function TChatMessagePayload.System(
  const Value: TArray<string>): TChatMessagePayload;
begin
  Result := TChatMessagePayload.Create.Role(TMessageRole.system).Content(Value);
end;

class function TChatMessagePayload.System(const Value: string): TChatMessagePayload;
begin
  Result := TChatMessagePayload.Create.Role(TMessageRole.system).Content(Value);
end;

function TChatMessagePayload.ToolCalls(
  const Value: TArray<TToolCalls>): TChatMessagePayload;
begin
  if Length(Value) = 0 then
    Exit(Self);

  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TChatMessagePayload(Add('tool_calls', JSONArray));
end;

class function TChatMessagePayload.User(const Value: string;
  const Url: TArray<string>): TChatMessagePayload;
begin
  var JSONArray := TJSONArray.Create;
  JSONArray.Add(TMessageContent.Create.&Type(TContentType.text).Text(Value).Detach);
  for var Item in Url do
    JSONArray.Add(TMessageContent.Create.&Type(TContentType.image_url).ImageUrl(UrlCheck(Item)).Detach);
  Result := TChatMessagePayload.Create.Role(TMessageRole.user).Content(JSONArray);
end;

class function TChatMessagePayload.User(const Value: string): TChatMessagePayload;
begin
  Result := TChatMessagePayload.Create.Role(TMessageRole.user).Content(Value);
end;

class function TChatMessagePayload.Assistant(const Value: string;
  const Url: TArray<string>;
  const Func: TArray<TToolCalls>;
  const Prefix: Boolean = False): TChatMessagePayload;
begin
  Result := User(Value, Url);
  Result := Result.ToolCalls(Func).Prefix(Prefix);
end;

{ TMessageContent }

function TMessageContent.ImageUrl(const Url: string): TMessageContent;
begin
  Result := TMessageContent(Add('image_url', Url));
end;

function TMessageContent.ImageUrl(const Url, Detail: string): TMessageContent;
begin
  var Value := TMessageImageURL.Create.Url(Url);
  if not Detail.IsEmpty then
    Value := Value.Detail(Detail);
  Result := TMessageContent(Add('image_url', Value.Detach));
end;

function TMessageContent.Text(const Value: string): TMessageContent;
begin
  Result := TMessageContent(Add('text', Value));
end;

function TMessageContent.&Type(const Value: TContentType): TMessageContent;
begin
  Result := TMessageContent(Add('type', Value.ToString));
end;

{ TMessageImageURL }

function TMessageImageURL.Detail(const Value: string): TMessageImageURL;
begin
  Result := TMessageImageURL(Add('detail', Value));
end;

function TMessageImageURL.Url(const Value: string): TMessageImageURL;
begin
  Result := TMessageImageURL(Add('url', Value));
end;

{ TToolCalls }

function TToolCalls.&Type(const Value: TToolType): TToolCalls;
begin
  Result := TToolCalls(Add('type', Value.ToString));
end;

function TToolCalls.Func(const Name: string; Arguments: string): TToolCalls;
begin
  var Value := TFunctionCalled.Create.Name(Name).Arguments(Arguments);
  Result := TToolCalls(Add('function', Value.Detach));
end;

function TToolCalls.Id(const Value: string): TToolCalls;
begin
  Result := TToolCalls(Add('id', Value));
end;

class function TToolCalls.New(Name, Arguments: string): TToolCalls;
begin
  Result := TToolCalls.Create.Func(Name, Arguments);
end;

class function TToolCalls.New(Id, Name, Arguments: string): TToolCalls;
begin
  Result := TToolCalls.Create.Id(Id).Func(Name, Arguments);
end;

{ TFunctionCalled }

function TFunctionCalled.Arguments(const Value: string): TFunctionCalled;
begin
  Result := TFunctionCalled(Add('arguments', Value));
end;

function TFunctionCalled.Name(const Value: string): TFunctionCalled;
begin
  Result := TFunctionCalled(Add('name', Value));
end;

end.

unit MistralAI.Classifiers;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, System.Threading,
  REST.Json.Types, System.NetEncoding, MistralAI.API.Params, MistralAI.API,
  MistralAI.Chat, MistralAI.Functions.Tools, MistralAI.Params.Core,
  MistralAI.Async.Support, MistralAI.Types;

type
  /// <summary>
  /// <c>TModerationParams</c> class to manage params for guardrails in a text.
  /// </summary>
  /// <remarks>
  /// The policy threshold is determined based on the optimal performance of oan internal test set.
  /// You can use the raw score or adjust the threshold according to your specific use cases.
  /// </remarks>
  TModerationParams = class(TJSONParam)
  public
    /// <summary>
    /// Text submitted for moderation
    /// </summary>
    /// <returns>
    /// The updated <c>TModerationParams</c> instance.
    /// </returns>
    function Input(const Value: string): TModerationParams; overload;
    /// <summary>
    /// Array of text submitted for moderation
    /// </summary>
    /// <returns>
    /// The updated <c>TModerationParams</c> instance.
    /// </returns>
    function Input(const Value: TArray<string>): TModerationParams; overload;
    /// <summary>
    /// Model for guardraile (e.g. mistral-moderation-latest)
    /// </summary>
    /// <returns>
    /// The updated <c>TModerationParams</c> instance.
    /// </returns>
    function Model(const Value: string): TModerationParams;
  end;

  /// <summary>
  /// <c>TModerationChatParams</c> class to manage params for guardrails in a chat generation.
  /// </summary>
  /// <remarks>
  /// The policy threshold is determined based on the optimal performance of oan internal test set.
  /// You can use the raw score or adjust the threshold according to your specific use cases.
  /// </remarks>
  TModerationChatParams = class(TJSONParam)
  public
    /// <summary>
    /// Provides the prompt(s) for the model to generate completions from, structured as a list of messages with roles (user, assistant, system) and content.
    /// </summary>
    /// <param name="Value">An array of <c>TChatMessagePayload</c> representing the messages in the conversation.</param>
    /// <returns>
    /// The updated <c>TModerationChatParams</c> instance.
    /// </returns>
    function Input(const Value: TArray<TChatMessagePayload>): TModerationChatParams;
    /// <summary>
    /// Model for guardraile (e.g. mistral-moderation-latest)
    /// </summary>
    /// <returns>
    /// The updated <c>TModerationChatParams</c> instance.
    /// </returns>
    function Model(const Value: string): TModerationChatParams;
  end;

  /// <summary>
  /// <c>TModerationCategories</c> class defines the categories for moderation checks.
  /// </summary>
  /// <remarks>
  /// This class provides a structured representation of the moderation categories
  /// used to evaluate the content against predefined guardrails. Each property corresponds
  /// to a specific moderation category and indicates whether the content violates that category.
  /// </remarks>
  TModerationCategories = class
  private
    FSexual: Boolean;
    FHate_and_discrimination: Boolean;
    FViolence_and_threats: Boolean;
    FDangerous_and_criminal_content: Boolean;
    FSelfharm: Boolean;
    FHealth: Boolean;
    FFinancial: Boolean;
    FLaw: Boolean;
    FPii: Boolean;
  public
    /// <summary>
    /// Indicates whether the content depicts or promotes explicit sexual material.
    /// </summary>
    /// <remarks>
    /// This includes content explicitly describing sexual activities, nudity, or solicitation for
    /// sexual purposes. Educational or medical content about sexual health in a non-explicit,
    /// informational context is generally exempted.
    /// </remarks>
    property Sexual: Boolean read FSexual write FSexual;
    /// <summary>
    /// Indicates whether the content expresses prejudice or advocates discrimination.
    /// </summary>
    /// <remarks>
    /// This category covers content that targets individuals or groups based on protected
    /// characteristics such as race, ethnicity, religion, gender, sexual orientation, or disability.
    /// </remarks>
    property Hate_and_discrimination: Boolean read FHate_and_discrimination write FHate_and_discrimination;
    /// <summary>
    /// Indicates whether the content glorifies, incites, or threatens physical violence.
    /// </summary>
    /// <remarks>
    /// This includes content that graphically describes injury or death, issues explicit threats,
    /// or provides instructions for carrying out violent acts.
    /// </remarks>
    property Violence_and_threats: Boolean read FViolence_and_threats write FViolence_and_threats;
    /// <summary>
    /// Indicates whether the content promotes dangerous or illegal activities.
    /// </summary>
    /// <remarks>
    /// This category includes guidance on creating weapons, encouragement of extreme risk-taking behaviors,
    /// and promotion of illegal activities such as fraud or drug trafficking.
    /// </remarks>
    property Dangerous_and_criminal_content: Boolean read FDangerous_and_criminal_content write FDangerous_and_criminal_content;
    /// <summary>
    /// Indicates whether the content promotes self-harm or related behaviors.
    /// </summary>
    /// <remarks>
    /// This includes encouragement or glorification of deliberate self-injury, suicide, eating disorders,
    /// or other self-destructive behaviors.
    /// </remarks>
    property Selfharm: Boolean read FSelfharm write FSelfharm;
    /// <summary>
    /// Indicates whether the content contains or elicits medical advice.
    /// </summary>
    /// <remarks>
    /// This applies to detailed or tailored medical advice that is not appropriate for non-expert contexts.
    /// </remarks>
    property Health: Boolean read FHealth write FHealth;
    /// <summary>
    /// Indicates whether the content contains or elicits financial advice.
    /// </summary>
    /// <remarks>
    /// This applies to detailed or tailored financial advice that may not align with ethical or legal standards.
    /// </remarks>
    property Financial: Boolean read FFinancial write FFinancial;
    /// <summary>
    /// Indicates whether the content contains or elicits legal advice.
    /// </summary>
    /// <remarks>
    /// This applies to detailed or tailored legal advice that should not be provided in a general context.
    /// </remarks>
    property Law: Boolean read FLaw write FLaw;
    /// <summary>
    /// Indicates whether the content involves personal identifying information (PII).
    /// </summary>
    /// <remarks>
    /// This category applies to content requesting, sharing, or attempting to elicit PII such as names,
    /// addresses, phone numbers, or financial account details.
    /// </remarks>
    property Pii: Boolean read FPii write FPii;
  end;

  /// <summary>
  /// <c>TModerationScores</c> class defines the scoring system for moderation categories.
  /// </summary>
  /// <remarks>
  /// This class provides a structured representation of the scores associated with each moderation category.
  /// Each property contains a numerical value indicating the likelihood that the content violates the corresponding category.
  /// </remarks>
  TModerationScores = class
  private
    FSexual: Double;
    FHate_and_discrimination: Double;
    FViolence_and_threats: Double;
    FDangerous_and_criminal_content: Double;
    FSelfharm: Double;
    FHealth: Double;
    FFinancial: Double;
    FLaw: Double;
    FPii: Double;
  public
    /// <summary>
    /// Numerical score indicating the likelihood of explicit sexual content.
    /// </summary>
    /// <remarks>
    /// Higher scores suggest a higher probability that the content explicitly depicts or promotes
    /// sexual activities, nudity, or solicitation for sexual purposes.
    /// </remarks>
    property Sexual: Double read FSexual write FSexual;
    /// <summary>
    /// Numerical score indicating the likelihood of hateful or discriminatory content.
    /// </summary>
    /// <remarks>
    /// Higher scores suggest a higher probability that the content targets individuals or groups based
    /// on protected characteristics such as race, ethnicity, religion, gender, or sexual orientation.
    /// </remarks>
    property Hate_and_discrimination: Double read FHate_and_discrimination write FHate_and_discrimination;
    /// <summary>
    /// Numerical score indicating the likelihood of violent or threatening content.
    /// </summary>
    /// <remarks>
    /// Higher scores suggest a higher probability that the content glorifies, incites, or threatens
    /// physical violence or provides instructions for violent acts.
    /// </remarks>
    property Violence_and_threats: Double read FViolence_and_threats write FViolence_and_threats;
    /// <summary>
    /// Numerical score indicating the likelihood of dangerous or illegal content.
    /// </summary>
    /// <remarks>
    /// Higher scores suggest a higher probability that the content promotes or provides instructions
    /// for illegal or haza
    property Dangerous_and_criminal_content: Double read FDangerous_and_criminal_content write FDangerous_and_criminal_content;
    /// <summary>
    /// Numerical score indicating the likelihood of content promoting self-harm.
    /// </summary>
    /// <remarks>
    /// Higher scores suggest a higher probability that the content encourages or glorifies
    /// deliberate self-injury, suicide, or other self-destructive behaviors.
    /// </remarks>
    property Selfharm: Double read FSelfharm write FSelfharm;
    /// <summary>
    /// Numerical score indicating the likelihood of content containing medical advice.
    /// </summary>
    /// <remarks>
    /// Higher scores suggest a higher probability that the content contains or attempts to elicit
    /// detailed or tailored medical advice.
    /// </remarks>
    property Health: Double read FHealth write FHealth;
    /// <summary>
    /// Numerical score indicating the likelihood of content containing financial advice.
    /// </summary>
    /// <remarks>
    /// Higher scores suggest a higher probability that the content contains or attempts to elicit
    /// detailed or tailored financial advice.
    /// </remarks>
    property Financial: Double read FFinancial write FFinancial;
    /// <summary>
    /// Numerical score indicating the likelihood of content containing legal advice.
    /// </summary>
    /// <remarks>
    /// Higher scores suggest a higher probability that the content contains or attempts to elicit
    /// detailed or tailored legal advice.
    /// </remarks>
    property Law: Double read FLaw write FLaw;
    /// <summary>
    /// Numerical score indicating the likelihood of content involving personal identifying information (PII).
    /// </summary>
    /// <remarks>
    /// Higher scores suggest a higher probability that the content requests, shares, or attempts
    /// to elicit personal information such as names, addresses, phone numbers, or financial details.
    /// </remarks>
    property Pii: Double read FPii write FPii;
  end;

  /// <summary>
  /// Represents a warning item in the moderation results, containing the category and its associated score.
  /// </summary>
  /// <remarks>
  /// This record is used to store information about a specific moderation category violation,
  /// including the category name and the numerical score indicating the likelihood of the violation.
  /// </remarks>
  TWarningItem = record
  private
    FCategory: string;
    FScore: Double;
  public
    /// <summary>
    /// Gets or sets the name of the moderation category.
    /// </summary>
    /// <value>
    /// A <c>string</c> representing the name of the category, such as "Sexual" or "Hate_and_discrimination."
    /// </value>
    property Category: string read FCategory write FCategory;
    /// <summary>
    /// Gets or sets the numerical score indicating the likelihood of a violation in the category.
    /// </summary>
    /// <value>
    /// A <c>Double</c> representing the likelihood score, where higher values indicate a greater likelihood of a violation.
    /// </value>
    property Score: Double read FScore write FScore;
    /// <summary>
    /// Creates a new instance of <c>TWarningItem</c> with the specified category and score.
    /// </summary>
    /// <param name="Category">
    /// The name of the moderation category.
    /// </param>
    /// <param name="Score">
    /// The numerical score associated with the category.
    /// </param>
    /// <returns>
    /// A new <c>TWarningItem</c> instance containing the specified category and score.
    /// </returns>
    class function Create(const Category: string; const Score: Double): TWarningItem; static;
  end;

  /// <summary>
  /// <c>TModerationResult</c> class represents the results of a moderation check.
  /// </summary>
  /// <remarks>
  /// This class contains information about the moderation categories and their associated scores.
  /// It provides a detailed breakdown of whether content violates predefined moderation categories
  /// and the likelihood of such violations.
  /// </remarks>
  TModerationResult = class
  strict private
    function GetWarning: Boolean;
  private
    FCategories: TModerationCategories;
    FCategory_scores: TModerationScores;
  public
    /// <summary>
    /// Retrieves an array of warning items for categories that have been flagged as violations.
    /// </summary>
    /// <remarks>
    /// This method analyzes the moderation results and returns a list of warning items,
    /// where each item contains the category name and its associated score. Only categories
    /// with a flagged status (true) in the moderation result are included in the returned array.
    /// </remarks>
    /// <returns>
    /// An array of <c>TWarningItem</c> instances, each representing a flagged moderation category
    /// along with its likelihood score.
    /// </returns>
    function Warnings: TArray<TWarningItem>;
    /// <summary>
    /// Contains the categories indicating whether the content violates specific moderation guardrails.
    /// </summary>
    /// <remarks>
    /// Each property within <c>TModerationCategories</c> indicates whether a particular category is violated.
    /// These categories include areas such as sexual content, hate speech, violence, and others.
    /// </remarks>
    property Categories: TModerationCategories read FCategories write FCategories;
    /// <summary>
    /// Contains the scores for each moderation category, indicating the likelihood of violations.
    /// </summary>
    /// <remarks>
    /// Each property within <c>TModerationScores</c> represents a numerical score. Higher scores suggest
    /// a greater probability that the content violates the corresponding category.
    /// </remarks>
    property Scores: TModerationScores read FCategory_scores write FCategory_scores;
    /// <summary>
    /// Returns true if at least one of the moderation categories is active.
    /// </summary>
    property Warning: Boolean read GetWarning;
    /// <summary>
    /// Destructor for the <c>TModerationResult</c> class.
    /// </summary>
    /// <remarks>
    /// Ensures proper cleanup of dynamically allocated resources, including the
    /// <c>Categories</c> and <c>Scores</c> objects.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// <c>TModeration</c> class represents the overall result of a moderation request.
  /// </summary>
  /// <remarks>
  /// This class provides a high-level summary of the moderation operation,
  /// including the request ID, the model used for moderation, and the detailed results
  /// for each category and score. It is the main structure returned by the moderation API.
  /// </remarks>
  TModeration = class
  private
    FId: string;
    FModel: string;
    FResults: TArray<TModerationResult>;
  public
    /// <summary>
    /// Unique identifier for the moderation request.
    /// </summary>
    /// <remarks>
    /// This property is useful for tracking or referencing specific moderation operations.
    /// </remarks>
    property Id: string read FId write FId;
    /// <summary>
    /// Name of the model used to process the moderation request.
    /// </summary>
    /// <remarks>
    /// Typically, this is the versioned name of the moderation model, such as
    /// "mistral-moderation-latest".
    /// </remarks>
    property Model: string read FModel write FModel;
    /// <summary>
    /// Array of detailed moderation results.
    /// </summary>
    /// <remarks>
    /// Each element in this array represents a separate result for a moderation check,
    /// containing both category flags and likelihood scores.
    /// </remarks>
    property Results: TArray<TModerationResult> read FResults write FResults;
    /// <summary>
    /// Destructor for the <c>TModeration</c> class.
    /// </summary>
    /// <remarks>
    /// Ensures proper cleanup of dynamically allocated resources, particularly the array
    /// of <c>TModerationResult</c> objects.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TModeration</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynModeration</c> type extends the <c>TAsynParams&lt;TModeration&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynModeration = TAsyncCallBack<TModeration>;

  /// <summary>
  /// <c>TClassifiersRoute</c> class provides an interface to interact with the MistralAI API for moderation tasks.
  /// </summary>
  /// <remarks>
  /// This class serves as a route handler for moderation-related operations, including both synchronous and asynchronous processing.
  /// It allows developers to send text or chat messages for moderation and receive structured feedback on their compliance with predefined guardrails.
  /// The available methods support various moderation scenarios, including text and conversational data.
  /// </remarks>
  TClassifiersRoute = class(TMistralAIAPIRoute)
    /// <summary>
    /// Submit a text for moderation
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TModerationParams</c> parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns <c>TAsynModeration</c> to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// <para>
    /// The <c>CallBacks</c> function is invoked when the operation completes, either successfully or with an error.
    /// </para>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var MistralAI := TMistralAIFactory.CreateInstance(BaererKey);
    /// MistralAI.AsynModeration(
    ///   procedure (Params: TModerationParams)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynModeration
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TModeration)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncModeration(ParamProc: TProc<TModerationParams>; CallBacks: TFunc<TAsynModeration>);
    /// <summary>
    /// Submit a text in a chat generation system for moderation.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TModerationChatParams</c> parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns <c>TAsynModeration</c> to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// <para>
    /// The <c>CallBacks</c> function is invoked when the operation completes, either successfully or with an error.
    /// </para>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var MistralAI := TMistralAIFactory.CreateInstance(BaererKey);
    /// MistralAI.AsynModerationChat(
    ///   procedure (Params: TModerationChatParams)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynModeration
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TModeration)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncModerationChat(ParamProc: TProc<TModerationChatParams>; CallBacks: TFunc<TAsynModeration>);
    /// <summary>
    /// Submit a text for moderation
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TModerationParams</c> parameters.
    /// </param>
    /// <returns>
    /// A <c>TModeration</c> object containing the AudioToAudio result.
    /// </returns>
    /// <remarks>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var MistralAI := TMistralAIFactory.CreateInstance(BaererKey);
    /// var Value := MistralAI.Moderation(
    ///     procedure (Params: TModerationParams)
    ///     begin
    ///       // Define parameters
    ///     end;
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function Moderation(ParamProc: TProc<TModerationParams>): TModeration;
    /// <summary>
    /// Submit a text in a chat generation system for moderation.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TModerationChatParams</c> parameters.
    /// </param>
    /// <returns>
    /// A <c>TModeration</c> object containing the AudioToAudio result.
    /// </returns>
    /// <remarks>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var MistralAI := TMistralAIFactory.CreateInstance(BaererKey);
    /// var Value := MistralAI.ModerationChat(
    ///     procedure (Params: TModerationChatParams)
    ///     begin
    ///       // Define parameters
    ///     end;
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function ModerationChat(ParamProc: TProc<TModerationChatParams>): TModeration;
  end;

implementation

{ TModerationParams }

function TModerationParams.Input(const Value: string): TModerationParams;
begin
  Result := TModerationParams(Add('input', Value));
end;

function TModerationParams.Input(
  const Value: TArray<string>): TModerationParams;
begin
  Result := TModerationParams(Add('input', Value));
end;

function TModerationParams.Model(const Value: string): TModerationParams;
begin
  Result := TModerationParams(Add('model', Value));
end;

{ TModerationResult }

destructor TModerationResult.Destroy;
begin
  if Assigned(FCategories) then
    FCategories.Free;
  if Assigned(FCategory_scores) then
    FCategory_scores.Free;
  inherited;
end;

function TModerationResult.GetWarning: Boolean;
begin
  Result := Categories.Sexual or Categories.FHate_and_discrimination or
    Categories.Violence_and_threats or Categories.Dangerous_and_criminal_content or
    Categories.Selfharm or Categories.Health or Categories.FFinancial or
    Categories.Law or Categories.Pii;
end;

function TModerationResult.Warnings: TArray<TWarningItem>;
begin
  if Categories.Sexual then
    Result := Result + [TWarningItem.Create(Classifiers[0], Scores.Sexual)];
  if Categories.Hate_and_discrimination then
    Result := Result + [TWarningItem.Create(Classifiers[1], Scores.Hate_and_discrimination)];
  if Categories.Violence_and_threats then
    Result := Result + [TWarningItem.Create(Classifiers[2], Scores.Violence_and_threats)];
  if Categories.Dangerous_and_criminal_content then
    Result := Result + [TWarningItem.Create(Classifiers[3], Scores.Dangerous_and_criminal_content)];
  if Categories.Selfharm then
    Result := Result + [TWarningItem.Create(Classifiers[4], Scores.Selfharm)];
  if Categories.Health then
    Result := Result + [TWarningItem.Create(Classifiers[5], Scores.Health)];
  if Categories.Financial then
    Result := Result + [TWarningItem.Create(Classifiers[6], Scores.Financial)];
  if Categories.Law then
    Result := Result + [TWarningItem.Create(Classifiers[7], Scores.Law)];
  if Categories.Pii then
    Result := Result + [TWarningItem.Create(Classifiers[8], Scores.Pii)];
end;

{ TModeration }

destructor TModeration.Destroy;
begin
  for var Item in FResults do
    Item.Free;
  inherited;
end;

{ TClassifiersRoute }

procedure TClassifiersRoute.AsyncModeration(ParamProc: TProc<TModerationParams>;
  CallBacks: TFunc<TAsynModeration>);
begin
  with TAsyncCallBackExec<TAsynModeration, TModeration>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TModeration
      begin
        Result := Self.Moderation(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TClassifiersRoute.AsyncModerationChat(
  ParamProc: TProc<TModerationChatParams>; CallBacks: TFunc<TAsynModeration>);
begin
  with TAsyncCallBackExec<TAsynModeration, TModeration>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TModeration
      begin
        Result := Self.ModerationChat(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TClassifiersRoute.Moderation(
  ParamProc: TProc<TModerationParams>): TModeration;
begin
  Result := API.Post<TModeration, TModerationParams>('moderations', ParamProc);
end;

function TClassifiersRoute.ModerationChat(
  ParamProc: TProc<TModerationChatParams>): TModeration;
begin
  Result := API.Post<TModeration, TModerationChatParams>('chat/moderations', ParamProc);
end;

{ TModerationChatParams }

function TModerationChatParams.Input(
  const Value: TArray<TChatMessagePayload>): TModerationChatParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TModerationChatParams(Add('input', JSONArray));
end;

function TModerationChatParams.Model(
  const Value: string): TModerationChatParams;
begin
  Result := TModerationChatParams(Add('model', Value));
end;

{ TWarningItem }

class function TWarningItem.Create(const Category: string;
  const Score: Double): TWarningItem;
begin
  Result.Category := Category;
  Result.Score := Score;
end;

end.

unit MistralAI.Codestral;


{-------------------------------------------------------------------------------

   **Important Notice**

   To utilize the classes managing the Codestral function, you are required to
   create a new KEY on the Mistral.ai website. Please note that obtaining this
   key necessitates providing a valid phone number.

   https://console.mistral.ai/codestral

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

-------------------------------------------------------------------------------}


interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, REST.Json.Types,
  System.Threading, MistralAI.API.Params, MistralAI.API, MistralAI.Async.Support,
  MistralAI.Params.Core, MistralAI.Functions.Tools, MistralAI.Types;

type
  /// <summary>
  /// The <c>TCodestralParams</c> class represents the set of parameters used to configure the behavior and output generation of the Codestral model.
  /// </summary>
  /// <remarks>
  /// This class allows you to define various settings that control how the model generates completions, including which model to use, the temperature of the output,
  /// and how many tokens to generate. By using this class, you can customize the model's response and fine-tune its behavior to suit the specific requirements of your application.
  /// <para>
  /// It inherits from <c>TJSONParam</c>, which provides methods for handling and serializing the parameters as JSON, enabling easy integration
  /// with JSON-based APIs. The parameters include options for setting prompts, suffixes, streaming preferences, and random seeds, among others.
  /// </para>
  /// <code>
  /// var
  ///   Params: TCodestralParams;
  /// begin
  ///   Params := TCodestralParams.Create
  ///     .Model('codestral-latest')
  ///     .Prompt('Generate a code snippet')
  ///     .MaxTokens(100)
  ///     .Temperature(0.7)
  ///     .TopP(0.9)
  ///     .Stop(['\n\n'])
  ///     .Stream(True);          // or Stream();
  /// end;
  /// </code>
  /// This example demonstrates how to instantiate and configure a <c>TCodestralParams</c> object to generate a code snippet using the Codestral model.
  /// </remarks>
  TCodestralParams = class(TJSONParam)
    /// <summary>
    /// Sets the text or code to be completed by the model.
    /// </summary>
    /// <param name="Value">
    /// The prompt text or code that the model should complete.
    /// This parameter is required and serves as the starting point for the model's generation.
    /// </param>
    /// <returns>
    /// The updated <c>TCodestralParams</c> instance.
    /// </returns>
    /// <remarks>
    /// The <c>Prompt</c> parameter is mandatory and provides the initial context that the model will use to generate a response.
    /// </remarks>
    function Prompt(const Value: string): TCodestralParams;
    /// <summary>
    /// Sets an optional suffix that provides additional context for the model.
    /// If both a prompt and a suffix are provided, the model will generate text to fill the space between them.
    /// </summary>
    /// <param name="Value">
    /// The suffix text that follows the content generated by the model.
    /// This helps guide the model on how to conclude the generation.
    /// </param>
    /// <returns>
    /// The updated <c>TCodestralParams</c> instance.
    /// </returns>
    function Suffix(const Value: string): TCodestralParams;
    /// <summary>
    /// Specifies the identifier of the model to use.
    /// Currently compatible with "codestral-2405" or "codestral-latest".
    /// </summary>
    /// <param name="Value">
    /// The model ID to be used for the completion.
    /// Ensure that the specified model is supported and correctly spelled.
    /// </param>
    /// <returns>
    /// The updated <c>TCodestralParams</c> instance.
    /// </returns>
    /// <remarks>
    /// This parameter is required and determines which model will process the request.
    /// </remarks>
    function Model(const Value: string): TCodestralParams;
    /// <summary>
    /// Sets the sampling temperature to use for the model's output.
    /// Higher values like 0.8 make the output more random, while lower values like 0.2 make it more focused and deterministic.
    /// </summary>
    /// <param name="Value">
    /// The temperature value between 0.0 and 1.0. Default is 0.7.
    /// A temperature of 0 makes the model deterministic, while a temperature of 1 allows for maximum creativity.
    /// </param>
    /// <returns>
    /// The updated <c>TCodestralParams</c> instance.
    /// </returns>
    function Temperature(const Value: Single): TCodestralParams;
    /// <summary>
    /// Sets the nucleus sampling probability mass for the model (Top-p).
    /// For example, 0.1 means only the tokens comprising the top 10% probability mass are considered.
    /// </summary>
    /// <param name="Value">
    /// The <c>top_p</c> value between 0.0 and 1.0. Default is 1.
    /// Lower values limit the model to consider only the most probable options.
    /// </param>
    /// <returns>
    /// The updated <c>TCodestralParams</c> instance.
    /// </returns>
    function TopP(const Value: Single): TCodestralParams;
    /// <summary>
    /// Sets the maximum number of tokens to generate in the completion.
    /// The total token count of your prompt plus <c>max_tokens</c> cannot exceed the model's context length.
    /// </summary>
    /// <param name="Value">
    /// The maximum number of tokens to generate.
    /// Choose an appropriate value based on your prompt length to avoid exceeding the model's limit.
    /// </param>
    /// <returns>
    /// The updated <c>TCodestralParams</c> instance.
    /// </returns>
    function MaxTokens(const Value: Integer): TCodestralParams;
    /// <summary>
    /// Sets the minimum number of tokens to generate in the completion.
    /// The model will continue generating tokens until this minimum is reached, unless a stop sequence is encountered.
    /// </summary>
    /// <param name="Value">
    /// The minimum number of tokens the model should generate.
    /// Use this parameter to ensure a response of a certain minimum length.
    /// </param>
    /// <returns>
    /// The updated <c>TCodestralParams</c> instance.
    /// </returns>
    function MinTokens(const Value: Integer): TCodestralParams;
    /// <summary>
    /// Specifies whether to stream back partial progress as server-sent events (SSE).
    /// If <c>true</c>, tokens are sent as they become available.
    /// If <c>false</c>, the server will hold the request open until timeout or completion.
    /// </summary>
    /// <param name="Value">
    /// A boolean value indicating whether to enable streaming. Default is <c>true</c>, meaning streaming is enabled by default.
    /// </param>
    /// <returns>
    /// The updated <c>TCodestralParams</c> instance.
    /// </returns>
    function Stream(const Value: Boolean = True): TCodestralParams;
    /// <summary>
    /// Sets the seed for random sampling. If specified, different calls with the same seed will produce deterministic results.
    /// </summary>
    /// <param name="Value">
    /// The seed value to use for random sampling.
    /// This can be useful for reproducing results during debugging or testing.
    /// </param>
    /// <returns>
    /// The updated <c>TCodestralParams</c> instance.
    /// </returns>
    function RandomSeed(const Value: Integer): TCodestralParams;
    /// <summary>
    /// Sets the tokens or sequences that will stop the generation process when detected.
    /// </summary>
    /// <param name="Value">
    /// A strings representing the stop tokens or sequences.
    /// Use this parameter to indicate when the model should stop generating, such as specifying a sequence like "\n\n".
    /// </param>
    /// <returns>
    /// The updated <c>TCodestralParams</c> instance.
    /// </returns>
    function Stop(const Value: string): TCodestralParams; overload;
    /// <summary>
    /// Sets the tokens or sequences that will stop the generation process when detected.
    /// </summary>
    /// <param name="Value">
    /// An array of strings representing the stop tokens or sequences.
    /// Use this parameter to indicate when the model should stop generating, such as specifying a sequence like "\n\n".
    /// </param>
    /// <returns>
    /// The updated <c>TCodestralParams</c> instance.
    /// </returns>
    function Stop(const Value: TArray<string>): TCodestralParams; overload;
  end;

  /// <summary>
  /// Represents the token usage statistics for a request, including the number of tokens used in the prompt,
  /// the completion, and the total number of tokens consumed.
  /// </summary>
  /// <remarks>
  /// The <c>TCodestralUsage</c> class provides information on the number of tokens utilized during a request.
  /// This data is essential for understanding the token cost associated with a request, particularly in contexts
  /// where token-based billing is employed, or for monitoring the model's behavior in terms of input and output sizes.
  /// </remarks>
  TCodestralUsage = class
  private
    [JsonNameAttribute('prompt_tokens')]
    FPrompt_tokens: Int64;
    [JsonNameAttribute('completion_tokens')]
    FCompletion_tokens: Int64;
    [JsonNameAttribute('total_tokens')]
    FTotal_tokens: Int64;
  public
    /// <summary>
    /// The number of tokens consumed by the prompt in the request.
    /// </summary>
    /// <remarks>
    /// This property indicates how many tokens were used for the initial input prompt sent to the model.
    /// It helps to assess the portion of the token budget consumed by the user's input or system instructions.
    /// </remarks>
    property PromptTokens: Int64 read FPrompt_tokens write FPrompt_tokens;
    /// <summary>
    /// The number of tokens consumed by the completion generated by the model.
    /// </summary>
    /// <remarks>
    /// The <c>CompletionTokens</c> property tracks the number of tokens used in the model's response.
    /// This is useful for analyzing the token cost of the model's output in relation to the input size.
    /// </remarks>
    property CompletionTokens: Int64 read FCompletion_tokens write FCompletion_tokens;
    /// <summary>
    /// The total number of tokens used for the entire request, including both the prompt and the completion.
    /// </summary>
    /// <remarks>
    /// The <c>TotalTokens</c> property provides the cumulative token usage for a single request,
    /// combining both prompt and completion tokens. This value is crucial for monitoring overall token consumption
    /// and ensuring compliance with token limits or pricing considerations.
    /// </remarks>
    property TotalTokens: Int64 read FTotal_tokens write FTotal_tokens;
  end;

  /// <summary>
  /// Represents a message exchanged in a conversation, containing the role of the sender and the message content.
  /// </summary>
  /// <remarks>
  /// The <c>TCodestralMessage</c> class captures the essential details of a message in a chat interaction,
  /// including the role of the sender (e.g., user or assistant) and the content of the message.
  /// This class is fundamental for managing and interpreting the flow of a conversation, providing context on who sent
  /// the message and what was communicated.
  /// </remarks>
  TCodestralMessage = class
  private
    FRole: string;
    FContent: string;
    [JsonNameAttribute('tool_calls')]
    FToolsCalls: TArray<TCalledFunction>;
    FPrefix: Boolean;
  public
    /// <summary>
    /// The role of the author of this message.
    /// </summary>
    /// <remarks>
    /// The <c>Role</c> property specifies the participant who authored the message. It typically has values like "user" for user input
    /// or "assistant" for responses generated by the AI. This property helps in distinguishing the source of the message within the conversation.
    /// </remarks>
    property Role: string read FRole write FRole;
    /// <summary>
    /// The content of the message.
    /// </summary>
    /// <remarks>
    /// The <c>Content</c> property holds the actual message text. This can be a user query, an AI-generated response, or other relevant information
    /// exchanged during the conversation.
    /// </remarks>
    property Content: string read FContent write FContent;
    /// <summary>
    /// A list of tool calls to be executed for query completion.
    /// </summary>
    /// <remarks>
    /// The <c>ToolsCalls</c> property contains a list of functions or tools that need to be invoked to process the current query further.
    /// This is typically used when the assistant needs to call external APIs or perform specific actions before delivering a final response.
    /// </remarks>
    property ToolsCalls: TArray<TCalledFunction> read FToolsCalls write FToolsCalls;
    /// <summary>
    /// The returned prefix: True or False
    /// </summary>
    property Prefix: Boolean read FPrefix write FPrefix;
    /// <summary>
    /// Destructor to release any resources used by this instance.
    /// </summary>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a single completion option generated by the AI model during a chat or completion interaction.
  /// </summary>
  /// <remarks>
  /// The <c>TCodestralChoices</c> class encapsulates the details of a single choice made by the AI model.
  /// Each instance of this class represents one possible response that the model could generate.
  /// This includes:
  /// - An index indicating the position of this choice among multiple options.
  /// - A complete message response generated by the model.
  /// - Optional deltas representing partial responses in the case of streamed outputs.
  /// - The reason why the model stopped generating tokens.
  /// This class is useful when evaluating multiple response options or handling streaming outputs that build over time.
  /// </remarks>
  TCodestralChoices = class
  private
    FIndex: Int64;
    FMessage: TCodestralMessage;
    [JsonReflectAttribute(ctString, rtString, TCodestralFinishReasonInterceptor)]
    FFinish_reason: TCodestralFinishReason;
    FDelta: TCodestralMessage;
  public
    /// <summary>
    /// Represents the position of this choice within the list of available choices generated by the model.
    /// </summary>
    /// <remarks>
    /// The <c>Index</c> property identifies the index of this particular choice in the set of choices provided by the model.
    /// This helps differentiate between multiple possible responses generated during a completion.
    /// </remarks>
    property Index: Int64 read FIndex write FIndex;
    /// <summary>
    /// The full completion message generated by the AI model based on the provided input or conversation context.
    /// </summary>
    /// <remarks>
    /// The <c>Message</c> property contains the complete message that represents the model's response.
    /// This is typically a detailed reply generated in response to a user prompt or system directive.
    /// </remarks>
    property Message: TCodestralMessage read FMessage write FMessage;
    /// <summary>
    /// A partial message (delta) generated by the model during streaming responses.
    /// </summary>
    /// <remarks>
    /// The <c>Delta</c> property holds incremental content provided when the model streams its response.
    /// This allows for progressively building the final response before it is fully completed.
    /// </remarks>
    property Delta: TCodestralMessage read FDelta write FDelta;
    /// <summary>
    /// Indicates the reason why the model stopped generating tokens.
    /// </summary>
    /// <remarks>
    /// The <c>FinishReason</c> property describes why the generation process ceased. This could be due to reaching a natural end of the response,
    /// hitting a specified stop sequence, or encountering a model constraint like a token limit.
    /// </remarks>
    property FinishReason: TCodestralFinishReason read FFinish_reason write FFinish_reason;
    /// <summary>
    /// Destructor to release resources held by the <c>TCodestralChoices</c> instance.
    /// </summary>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a codestral completion response generated by an AI model, containing metadata,
  /// generated choices, and usage statistics.
  /// </summary>
  /// <remarks>
  /// The <c>TCodestral</c> class encapsulates the results of a completion request made to an AI model.
  /// It includes details such as a unique identifier, the model used, when the completion was created,
  /// the choices generated by the model, and usage statistics.
  /// This class is essential for managing and understanding the results of AI-driven completions,
  /// as well as tracking the underlying usage and response characteristics.
  /// </remarks>
  TCodestral = class
  private
    FId: string;
    FObject: string;
    FCreated: Int64;
    FModel: string;
    FChoices: TArray<TCodestralChoices>;
    FUsage: TCodestralUsage;
  public
    /// <summary>
    /// A unique identifier for the codestral completion.
    /// </summary>
    /// <remarks>
    /// The <c>Id</c> property stores a unique string that identifies the specific codestral completion request.
    /// This is useful for tracking and managing individual completions or retrieving the results of a particular request.
    /// </remarks>
    property Id: string read FId write FId;
    /// <summary>
    /// The object type, which is always "codestral.completion".
    /// </summary>
    /// <remarks>
    /// The <c>Object</c> property describes the type of the response. For codestral completions, this value is always "codestral.completion",
    /// providing a clear indication of the response type when working with multiple object types in a system.
    /// </remarks>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// The Unix timestamp (in seconds) of when the codestral completion was created.
    /// </summary>
    /// <remarks>
    /// The <c>Created</c> property contains a Unix timestamp indicating when the AI generated the codestral completion.
    /// This is useful for logging, auditing, or ordering completions chronologically.
    /// </remarks>
    property Created: Int64 read FCreated write FCreated;
    /// <summary>
    /// The model used for the codestral completion.
    /// </summary>
    /// <remarks>
    /// The <c>Model</c> property specifies which AI model was used to generate the codestral completion. This can be helpful
    /// when comparing results across different models or tracking which model versions are producing responses.
    /// </remarks>
    property Model: string read FModel write FModel;
    /// <summary>
    /// A list of codestral completion choices generated by the model.
    /// </summary>
    /// <remarks>
    /// The <c>Choices</c> property holds an array of <c>TCodestralChoices</c> objects, representing different response options
    /// generated by the AI model. There may be multiple choices if the request specified more than one completion.
    /// </remarks>
    property Choices: TArray<TCodestralChoices> read FChoices write FChoices;
    /// <summary>
    /// Usage statistics for the completion request, including token counts for the prompt and completion.
    /// </summary>
    /// <remarks>
    /// The <c>Usage</c> property provides information about the number of tokens consumed during the request, including those
    /// used in the prompt and those generated in the completion. This data is important for monitoring API usage and costs.
    /// </remarks>
    property Usage: TCodestralUsage read FUsage write FUsage;
    /// <summary>
    /// Destructor to clean up resources used by this <c>TCodestral</c> instance.
    /// </summary>
    /// <remarks>
    /// The destructor ensures that any allocated resources, such as the memory for the array of choices or usage statistics, are
    /// properly released when the object is no longer needed.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous chat events for a chat request using <c>TCodestral</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynCode</c> type extends the <c>TAsynParams&lt;TCodestral&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynCode = TAsyncCallBack<TCodestral>;

  /// <summary>
  /// Manages asynchronous streaming chat events for a chat request using <c>TCodestral</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynCodeStream</c> type extends the <c>TAsynStreamParams&lt;TCodestral&gt;</c> record to support the lifecycle of an asynchronous streaming chat operation.
  /// It provides callbacks for different stages, including when the operation starts, progresses with new data chunks, completes successfully, or encounters an error.
  /// This structure is ideal for handling scenarios where the chat response is streamed incrementally, providing real-time updates to the user interface.
  /// </remarks>
  TAsynCodeStream = TAsyncStreamCallBack<TCodestral>;

  /// <summary>
  /// Represents a callback procedure used during the reception of responses from a codestral request in streaming mode.
  /// </summary>
  /// <param name="Codestral">
  /// The <c>TCodestral</c> object containing the current information about the response generated by the model.
  /// If this value is <c>nil</c>, it indicates that the data stream is complete.
  /// </param>
  /// <param name="IsDone">
  /// A boolean flag indicating whether the streaming process is complete.
  /// If <c>True</c>, it means the model has finished sending all response data.
  /// </param>
  /// <param name="Cancel">
  /// A boolean flag that can be set to <c>True</c> within the callback to cancel the streaming process.
  /// If set to <c>True</c>, the streaming will be terminated immediately.
  /// </param>
  /// <remarks>
  /// This callback is invoked multiple times during the reception of the response data from the model.
  /// It allows for real-time processing of received messages and interaction with the user interface or other systems
  /// based on the state of the data stream.
  /// When the <c>IsDone</c> parameter is <c>True</c>, it indicates that the model has finished responding,
  /// and the <c>Codestral</c> parameter will be <c>nil</c>.
  /// </remarks>
  TCodestralEvent = reference to procedure(var Codestral: TCodestral; IsDone: Boolean; var Cancel: Boolean);

  /// <summary>
  /// The <c>TCodestralRoute</c> class inherits from <c>TMistralAIAPIRoute</c> and provides an interface for managing various interactions with the codestral API.
  /// It supports creating codestral completion requests in synchronous, asynchronous, and streaming modes, offering mechanisms to handle responses generated by the model.
  /// </summary>
  /// <remarks>
  /// This class facilitates sending messages to a codestral model, receiving responses, and managing them, whether synchronously or asynchronously.
  /// The primary methods in the class are:
  /// <list type="bullet">
  /// <item>
  /// <term><c>Create</c></term>
  /// <description>Sends a codestral request and waits for a full response.</description>
  /// </item>
  /// <item>
  /// <term><c>AsyncCreate</c></term>
  /// <description>Performs an asynchronous codestral completion request with event handling.</description>
  /// </item>
  /// <item>
  /// <term><c>CreateStream</c></term>
  /// <description>Initiates a codestral completion request in streaming mode, receiving tokens progressively.</description>
  /// </item>
  /// <item>
  /// <term><c>ASyncCreateStream</c></term>
  /// <description>Performs an asynchronous request in streaming mode with event handling.</description>
  /// </item>
  /// </list>
  /// Each method allows configuring model parameters, setting input messages, managing token limits, and including callbacks for processing responses or errors.
  /// </remarks>
  TCodestralRoute = class(TMistralAIAPIRoute)
  public
    /// <summary>
    /// Creates an asynchronous completion for codestral message.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the parameters for the codestral request, such as model selection, messages, and other parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for the asynchronous codestral completion, such as on success and on error.
    /// </param>
    /// <remarks>
    /// This procedure initiates an asynchronous request to generate a codestral completion based on the provided parameters. The response or error is handled by the provided callBacks.
    /// <code>
    /// MistralAI.Codestral.AsyncCreate(
    ///   procedure (Params: TChatParams)
    ///   begin
    ///     // Define codestral parameters
    ///   end,
    ///
    ///   function: TAsynCode
    ///   begin
    ///     Result.Sender := Memo1;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Chat: TChat)
    ///     begin
    ///       var M := Sender as TMemo; // Because Result.Sender = Memo1
    ///       // Handle success operation
    ///     end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Value: string)
    ///     begin
    ///       // Handle error message
    ///     end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncCreate(ParamProc: TProc<TCodestralParams>; CallBacks: TFunc<TAsynCode>);
    /// <summary>
    /// Creates an asynchronous streaming codestral completion request.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the codestral request, including the model, messages, and additional options such as max tokens and streaming mode.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a <c>TAsynCodeStream</c> record which contains event handlers for managing different stages of the streaming process: progress updates, success, errors, and cancellation.
    /// </param>
    /// <remarks>
    /// This procedure initiates an asynchronous codestral operation in streaming mode, where tokens are progressively received and processed.
    /// The provided event handlers allow for handling progress (i.e., receiving tokens in real time), detecting success, managing errors, and enabling cancellation logic.
    /// <code>
    /// MistralAI.CodeStral.AsyncCreateStream(
    ///   procedure(Params: TChatParams)
    ///   begin
    ///     // Define codestral parameters
    ///     Params.Stream;
    ///   end,
    ///
    ///   function: TAsynCodeStream
    ///   begin
    ///     Result.Sender := Memo1; // Instance passed to callback parameter
    ///     Result.OnProgress :=
    ///         procedure (Sender: TObject; Chat: TChat)
    ///         begin
    ///           // Handle progressive updates to the chat response
    ///         end;
    ///     Result.OnSuccess :=
    ///         procedure (Sender: TObject)
    ///         begin
    ///           // Handle success when the operation completes
    ///         end;
    ///     Result.OnError :=
    ///         procedure (Sender: TObject; Value: string)
    ///         begin
    ///           // Handle error message
    ///         end;
    ///     Result.OnDoCancel :=
    ///         function: Boolean
    ///         begin
    ///           Result := CheckBox1.Checked; // Click on checkbox to cancel
    ///         end;
    ///     Result.OnCancellation :=
    ///         procedure (Sender: TObject)
    ///         begin
    ///           // Processing when process has been canceled
    ///         end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncCreateStream(ParamProc: TProc<TCodestralParams>; CallBacks: TFunc<TAsynCodeStream>);
    /// <summary>
    /// Creates a completion for the codestral message using the provided parameters.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the codestral request, such as selecting the model, providing messages, setting token limits, etc.
    /// </param>
    /// <returns>
    /// Returns a <c>TCodestral</c> object that contains the codestral response, including the choices generated by the model.
    /// </returns>
    /// <exception cref="MistralAIExceptionAPI">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="MistralAIExceptionInvalidRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// The <c>Create</c> method sends a codestral completion request and waits for the full response. The returned <c>TCodestral</c> object contains the model's generated response, including multiple choices if available.
    /// Example usage:
    /// <code>
    ///   var Codestral := MistralAI.Codestral.Create(
    ///     procedure (Params: TCodestralParams)
    ///     begin
    ///       // Define codestral parameters
    ///     end);
    ///   try
    ///     for var Choice in Codestral.Choices do
    ///       WriteLn(Choice.Message.Content);
    ///   finally
    ///     Codestral.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Create(ParamProc: TProc<TCodestralParams>): TCodestral;
    /// <summary>
    /// Creates a codestral message completion with a streamed response.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the codestral request, such as selecting the model, providing messages, and adjusting other settings like token limits or temperature.
    /// </param>
    /// <param name="Event">
    /// A callback of type <c>TCodestralEvent</c> that is triggered with each chunk of data received during the streaming process. It includes the current state of the <c>TCodestral</c> object, a flag indicating if the stream is done, and a boolean to handle cancellation.
    /// </param>
    /// <returns>
    /// Returns <c>True</c> if the streaming process started successfully, <c>False</c> otherwise.
    /// </returns>
    /// <remarks>
    /// This method initiates a codestral request in streaming mode, where the response is delivered incrementally in real-time.
    /// The <c>Event</c> callback will be invoked multiple times as tokens are received.
    /// When the response is complete, the <c>IsDone</c> flag will be set to <c>True</c>, and the <c>Codestral</c> object will be <c>nil</c>.
    /// The streaming process can be interrupted by setting the <c>Cancel</c> flag to <c>True</c> within the event.
    /// Example usage:
    /// <code>
    ///   MistralAI.Codestral.CreateStream(
    ///     procedure (Params: TCodestralParams)
    ///     begin
    ///       // Define codestral parameters
    ///     end,
    ///
    ///     procedure(var Codestral: TCodestral; IsDone: Boolean; var Cancel: Boolean)
    ///     begin
    ///       // Handle displaying
    ///     end
    ///   );
    /// </code>
    /// </remarks>
    function CreateStream(ParamProc: TProc<TCodestralParams>; Event: TCodestralEvent): Boolean;
  end;

implementation

uses
  System.StrUtils, Rest.Json, System.Rtti;

{ TCodestralParams }

function TCodestralParams.MaxTokens(const Value: Integer): TCodestralParams;
begin
  Result := TCodestralParams(Add('max_tokens', Value));
end;

function TCodestralParams.MinTokens(const Value: Integer): TCodestralParams;
begin
  Result := TCodestralParams(Add('min_tokens', Value));
end;

function TCodestralParams.Model(const Value: string): TCodestralParams;
begin
  Result := TCodestralParams(Add('model', Value));
end;

function TCodestralParams.Prompt(const Value: string): TCodestralParams;
begin
  Result := TCodestralParams(Add('prompt', Value));
end;

function TCodestralParams.RandomSeed(const Value: Integer): TCodestralParams;
begin
  Result := TCodestralParams(Add('random_seed', Value));
end;

function TCodestralParams.Stop(const Value: TArray<string>): TCodestralParams;
var
  Items: TJSONArray;
begin
  Items := TJSONArray.Create;
  try
    for var Item in Value do
      begin
        Items.Add(Item);
      end;
  except
    Items.Free;
    raise;
  end;
  Result := TCodestralParams(Add('stop', Items));
end;

function TCodestralParams.Stop(const Value: string): TCodestralParams;
begin
  Result := TCodestralParams(Add('stop', Value));
end;

function TCodestralParams.Stream(const Value: Boolean): TCodestralParams;
begin
  Result := TCodestralParams(Add('stream', Value));
end;

function TCodestralParams.Suffix(const Value: string): TCodestralParams;
begin
  Result := TCodestralParams(Add('suffix', Value));
end;

function TCodestralParams.Temperature(const Value: Single): TCodestralParams;
begin
  Result := TCodestralParams(Add('temperature', Value));
end;

function TCodestralParams.TopP(const Value: Single): TCodestralParams;
begin
  Result := TCodestralParams(Add('top_p', Value));
end;

{ TCodestralChoices }

destructor TCodestralChoices.Destroy;
begin
  if Assigned(FMessage) then
    FMessage.Free;
  if Assigned(FDelta) then
    FDelta.Free;
  inherited;
end;

{ TCodestral }

destructor TCodestral.Destroy;
begin
  if Assigned(FUsage) then
    FUsage.Free;
  for var Item in FChoices do
    Item.Free;
  inherited;
end;

{ TCodestralRoute }

procedure TCodestralRoute.AsyncCreate(ParamProc: TProc<TCodestralParams>;
  CallBacks: TFunc<TAsynCode>);
begin
  with TAsyncCallBackExec<TAsynCode, TCodestral>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TCodestral
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TCodestralRoute.AsyncCreateStream(ParamProc: TProc<TCodestralParams>;
  CallBacks: TFunc<TAsynCodeStream>);
begin
  var CallBackParams := TUseParamsFactory<TAsynCodeStream>.CreateInstance(CallBacks);

  var Sender := CallBackParams.Param.Sender;
  var OnStart := CallBackParams.Param.OnStart;
  var OnSuccess := CallBackParams.Param.OnSuccess;
  var OnProgress := CallBackParams.Param.OnProgress;
  var OnError := CallBackParams.Param.OnError;
  var OnCancellation := CallBackParams.Param.OnCancellation;
  var OnDoCancel := CallBackParams.Param.OnDoCancel;

  var Task: ITask := TTask.Create(
          procedure()
          begin
            {--- Pass the instance of the current class in case no value was specified. }
            if not Assigned(Sender) then
              Sender := Self;

            {--- Trigger OnStart callback }
            if Assigned(OnStart) then
              TThread.Queue(nil,
                procedure
                begin
                  OnStart(Sender);
                end);
            try
              var Stop := False;

              {--- Processing }
              CreateStream(ParamProc,
                procedure (var Code: TCodestral; IsDone: Boolean; var Cancel: Boolean)
                begin
                  {--- Check that the process has not been canceled }
                  if Assigned(OnDoCancel) then
                    TThread.Queue(nil,
                        procedure
                        begin
                          Stop := OnDoCancel();
                        end);
                  if Stop then
                    begin
                      {--- Trigger when processus was stopped }
                      if Assigned(OnCancellation) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnCancellation(Sender)
                        end);
                      Cancel := True;
                      Exit;
                    end;
                  if not IsDone and Assigned(Code) then
                    begin
                      var LocalCode := Code;
                      Code := nil;

                      {--- Triggered when processus is progressing }
                      if Assigned(OnProgress) then
                        TThread.Synchronize(TThread.Current,
                        procedure
                        begin
                          try
                            OnProgress(Sender, LocalCode);
                          finally
                            {--- Makes sure to release the instance containing the data obtained
                                 following processing}
                            LocalCode.Free;
                          end;
                        end)
                      else
                        LocalCode.Free;
                    end
                  else
                  if IsDone then
                    begin
                      {--- Trigger OnEnd callback when the process is done }
                      if Assigned(OnSuccess) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnSuccess(Sender);
                        end);
                    end;
                end);
            except
              on E: Exception do
                begin
                  var Error := AcquireExceptionObject;
                  try
                    var ErrorMsg := (Error as Exception).Message;

                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(OnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        OnError(Sender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
          end);
  Task.Start;
end;

function TCodestralRoute.Create(
  ParamProc: TProc<TCodestralParams>): TCodestral;
begin
  Result := API.Post<TCodestral, TCodestralParams>('fim/completions', ParamProc);
end;

function TCodestralRoute.CreateStream(ParamProc: TProc<TCodestralParams>;
  Event: TCodestralEvent): Boolean;
var
  Response: TStringStream;
  RetPos: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    RetPos := 0;
    Result := API.Post<TCodestralParams>('fim/completions', ParamProc, Response,
      procedure(const Sender: TObject; AContentLength: Int64; AReadCount: Int64; var AAbort: Boolean)
      var
        IsDone: Boolean;
        Data: string;
        Code: TCodestral;
        TextBuffer: string;
        Line: string;
        Ret: Integer;
      begin
        try
          TextBuffer := Response.DataString;
        except
          on E: EEncodingError do
            Exit;
        end;

        repeat
          Ret := TextBuffer.IndexOf(#10, RetPos);
          if Ret < 0 then
            Continue;
          Line := TextBuffer.Substring(RetPos, Ret - RetPos);
          RetPos := Ret + 1;

          if Line.IsEmpty or Line.StartsWith(#10) then
            Continue;
          Code := nil;
          Data := Line.Replace('data: ', '').Trim([' ', #13, #10]);
          IsDone := Data = '[DONE]';

          if not IsDone then
          try
            Code := TJson.JsonToObject<TCodestral>(Data);
          except
            Code := nil;
          end;

          try
            Event(Code, IsDone, AAbort);
          finally
            Code.Free;
          end;
        until Ret < 0;

      end);
  finally
    Response.Free;
  end;
end;

{ TCodestralMessage }

destructor TCodestralMessage.Destroy;
begin
  for var Item in FToolsCalls do
    Item.Free;
  inherited;
end;

end.

unit MistralAI.Embeddings;

{-------------------------------------------------------------------------------

      Github repository : https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, REST.Json.Types, MistralAI.API.Params, MistralAI.API,
  MistralAI.Async.Support;

type
  /// <summary>
  /// Represents the parameters for an embedding request.
  /// </summary>
  /// <remarks>
  /// Use this class to specify the input text and other parameters for generating embeddings.
  /// </remarks>
  TEmbeddingParams = class(TJSONParam)
    /// <summary>
    /// Sets the ID of the model to use for this request.
    /// </summary>
    /// <param name="Value">
    /// The model ID to be used for embedding.
    /// </param>
    /// <returns>
    /// The current instance of <c>TEmbeddingParams</c> for method chaining.
    /// </returns>
    /// <remarks>
    /// Use this method to specify the model that will generate the embeddings.
    /// </remarks>
    function Model(const Value: string): TEmbeddingParams;
    /// <summary>
    /// Sets the input text for which to generate an embedding.
    /// </summary>
    /// <param name="Value">
    /// The input text as a string.
    /// </param>
    /// <returns>
    /// The current instance of <c>TEmbeddingParams</c> for method chaining.
    /// </returns>
    /// <remarks>
    /// Use this method to specify a single string input for embedding.
    /// </remarks>
    function Input(const Value: string): TEmbeddingParams; overload;
    /// <summary>
    /// Sets multiple input texts for which to generate embeddings.
    /// </summary>
    /// <param name="Value">
    /// An array of input texts.
    /// </param>
    /// <returns>
    /// The current instance of <c>TEmbeddingParams</c> for method chaining.
    /// </returns>
    /// <remarks>
    /// Use this method to specify multiple strings as inputs for embeddings.
    /// </remarks>
    function Input(const Value: TArray<string>): TEmbeddingParams; overload;
    /// <summary>
    /// Sets the format of the output data.
    /// </summary>
    /// <param name="Value">
    /// The desired output format (e.g., 'float').
    /// </param>
    /// <returns>
    /// The current instance of <c>TEmbeddingParams</c> for method chaining.
    /// </returns>
    /// <remarks>
    /// Use this method to specify the output format of the embeddings.
    /// </remarks>
    function Encoding_format(const Value: string): TEmbeddingParams;
    /// <summary>
    /// Initializes a new instance of the <c>TEmbeddingParams</c> class with default values.
    /// </summary>
    /// <remarks>
    /// The default model is set to 'mistral-embed' and encoding format to 'float'.
    /// </remarks>
    constructor Create; override;
  end;

  /// <summary>
  /// Represents token usage statistics for an embedding request.
  /// </summary>
  /// <remarks>
  /// Contains information about the number of tokens used in the request.
  /// </remarks>
  TEmbeddingUsage = class
  private
    [JsonNameAttribute('prompt_tokens')]
    FPrompt_tokens: Int64;
    [JsonNameAttribute('total_tokens')]
    FTotal_tokens: Int64;
  public
    /// <summary>
    /// The number of tokens used in the input text.
    /// </summary>
    property PromptTokens: Int64 read FPrompt_tokens write FPrompt_tokens;
    /// <summary>
    /// The total number of tokens consumed during the embedding request.
    /// </summary>
    property TotalTokens: Int64 read FTotal_tokens write FTotal_tokens;
  end;

  /// <summary>
  /// Represents an embedding result for a single input.
  /// </summary>
  /// <remarks>
  /// Contains the embedding vector and associated metadata for a single input text.
  /// </remarks>
  TEmbeddingData = class
  private
    FIndex: Int64;
    FObject: string;
    FEmbedding: TArray<Double>;
  public
    /// <summary>
    /// The index of the embedding in the list of embeddings.
    /// </summary>
    property Index: Int64 read FIndex write FIndex;
    /// <summary>
    /// The object type, which is always "embedding".
    /// </summary>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// The embedding vector, which is a list of floats. The length of the vector depends on the model as listed in the embedding guide.
    /// </summary>
    property Embedding: TArray<Double> read FEmbedding write FEmbedding;
  end;

  /// <summary>
  /// Represents the response from an embedding request.
  /// </summary>
  /// <remarks>
  /// Contains the embeddings, model information, and usage statistics returned by the API.
  /// </remarks>
  TEmbeddings = class
  private
    FId: string;
    FObject: string;
    FData: TArray<TEmbeddingData>;
    FModel: string;
    FUsage: TEmbeddingUsage;
  public
    /// <summary>
    /// The unique identifier for the embedding response.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// The object type of the response (e.g., 'list').
    /// </summary>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// The list of embedding data for each input.
    /// </summary>
    property Data: TArray<TEmbeddingData> read FData write FData;
    /// <summary>
    /// The token usage statistics for the embedding request.
    /// </summary>
    property Usage: TEmbeddingUsage read FUsage write FUsage;
    /// <summary>
    /// The model used to generate the embeddings.
    /// </summary>
    property Model: string read FModel write FModel;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents the asynchronous callback parameters for embedding requests.
  /// </summary>
  /// <remarks>
  /// Used to handle asynchronous responses for embedding operations.
  /// </remarks>
  TAsyncEmbeddings = TAsyncCallBack<TEmbeddings>;

  /// <summary>
  /// Provides methods for creating embedding requests.
  /// </summary>
  /// <remarks>
  /// Contains synchronous and asynchronous methods to generate embeddings using the API.
  /// <code>
  /// // Example usage:
  /// var
  ///   EmbeddingsRoute: TEmbeddingsRoute;
  ///   EmbeddingsResult: TEmbeddings;
  /// begin
  ///   EmbeddingsRoute := TEmbeddingsRoute.Create;
  ///   EmbeddingsResult := EmbeddingsRoute.Create(
  ///     procedure(Params: TEmbeddingParams)
  ///     begin
  ///       Params.Input('Your input text here');
  ///     end);
  ///   // Use EmbeddingsResult as needed
  /// end;
  /// </code>
  /// </remarks>
  TEmbeddingsRoute = class(TMistralAIAPIRoute)
  public
    /// <summary>
    /// Initiates an asynchronous embedding request.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to set up the embedding parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns the asynchronous callback parameters.
    /// </param>
    /// <remarks>
    /// Use this method to perform an embedding request without blocking the main thread.
    /// <code>
    ///   // Example usage:
    ///   MistralAI.Embeddings.AsyncCreate(
    ///     procedure(Params: TEmbeddingParams)
    ///     begin
    ///       Params.Input('Your input text here');
    ///     end,
    ///
    ///     function: TAsyncEmbeddings
    ///     begin
    ///       Result.OnSuccess :=
    ///         procedure(Sender: TObject; Embeddings: TEmbeddings)
    ///         begin
    ///           // Handle successful embedding result
    ///         end;
    ///
    ///       Result.OnError :=
    ///         procedure(Sender: TObject; E: Exception)
    ///         begin
    ///           // Handle error
    ///         end;
    ///     end);
    /// </code>
    /// </remarks>
    procedure AsyncCreate(ParamProc: TProc<TEmbeddingParams>;
      const CallBacks: TFunc<TAsyncEmbeddings>);
    /// <summary>
    /// Performs a synchronous embedding request and returns the result.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to set up the embedding parameters.
    /// </param>
    /// <returns>
    /// An instance of <c>TEmbeddings</c> containing the embedding results.
    /// </returns>
    /// <remarks>
    /// Use this method to perform an embedding request that blocks until the response is received.
    /// <code>
    ///   // Example usage:
    ///   var Embeddings := MistralAI.Embeddings.Create(
    ///     procedure(Params: TEmbeddingParams)
    ///     begin
    ///       Params.Input(['Your input text here']);
    ///     end);
    ///    try
    ///      // Use Embeddings as needed
    ///    finally
    ///      Embeddings.Free;
    ///    end;
    /// </code>
    /// </remarks>
    function Create(ParamProc: TProc<TEmbeddingParams>): TEmbeddings;
  end;

implementation

{ TEmbeddingParams }

constructor TEmbeddingParams.Create;
begin
  inherited;
  Model('mistral-embed');
  encoding_format('float');
end;

function TEmbeddingParams.Encoding_format(
  const Value: string): TEmbeddingParams;
begin
  Result := TEmbeddingParams(Add('encoding_format', Value));
end;

function TEmbeddingParams.Input(const Value: string): TEmbeddingParams;
begin
  Result := TEmbeddingParams(Add('input', Value));
end;

function TEmbeddingParams.Input(const Value: TArray<string>): TEmbeddingParams;
begin
  Result := TEmbeddingParams(Add('input', Value));
end;

function TEmbeddingParams.Model(const Value: string): TEmbeddingParams;
begin
  Result := TEmbeddingParams(Add('model', Value));
end;

{ TEmbeddings }

destructor TEmbeddings.Destroy;
begin
  FUsage.Free;
  for var Item in FData do
    Item.Free;
  inherited;
end;

{ TEmbeddingsRoute }

procedure TEmbeddingsRoute.AsyncCreate(ParamProc: TProc<TEmbeddingParams>;
  const CallBacks: TFunc<TAsyncEmbeddings>);
begin
  with TAsyncCallBackExec<TAsyncEmbeddings, TEmbeddings>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TEmbeddings
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TEmbeddingsRoute.Create(
  ParamProc: TProc<TEmbeddingParams>): TEmbeddings;
begin
  Result := API.Post<TEmbeddings, TEmbeddingParams>('embeddings', ParamProc);
end;

end.

unit MistralAI.Errors;

{-------------------------------------------------------------------------------

      Github repository : https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  REST.Json.Types;

type
  TErrorCore = class abstract
  end;

  TError = class(TErrorCore)
  private
    [JsonNameAttribute('message')]
    FMessage: string;
    [JsonNameAttribute('detail')]
    FDetail: string;
    [JsonNameAttribute('request_id')]
    FRequestID: string;
  public
    property Message: string read FMessage write FMessage;
    property Detail: string read FDetail write FDetail;
    property RequestID: string read FRequestID write FRequestID;
  end;

  TCTX = class
  private
    [JsonNameAttribute('le')]
    FLe: Double;
  public
    property Le: Double read FLe write FLe;
  end;

  TDetail = class
  private
    [JsonNameAttribute('loc')]
    FLoc: TArray<string>;
    [JsonNameAttribute('msg')]
    FMsg: string;
    [JsonNameAttribute('type')]
    FType: string;
    [JsonNameAttribute('input')]
    FInput: string;
    [JsonNameAttribute('ctx')]
    FCTX: TCTX;
  public
    property Loc: TArray<string> read FLoc write FLoc;
    property Msg: string read FMsg write FMsg;
    property &Type: string read FType write FType;
    property Input: string read FInput write FInput;
    property CTX: TCTX read FCTX write FCTX;
    destructor Destroy; override;
  end;

  TMessage422 = class
  private
    [JsonNameAttribute('detail')]
    FDetail: TArray<TDetail>;
  public
    property Detail: TArray<TDetail> read FDetail write FDetail;
    destructor Destroy; override;
  end;

  TError422 = class(TErrorCore)
  private
     [JsonNameAttribute('object')]
     FObject: string;
     [JsonNameAttribute('message')]    // NOTE : Should't exists
     FMessage: TMessage422;
     [JsonNameAttribute('type')]
     FType: string;
     [JsonNameAttribute('param')]
     FParam: string;
     [JsonNameAttribute('code')]
     FCode: string;
     [JsonNameAttribute('detail')]
     FDetail: TArray<TDetail>;
  public
    property &Object: string read FObject write FObject;
    {--- "Message" Property that should not exist according to API documentation.
         But some 422 errors use this property.}
    property Message: TMessage422 read FMessage write FMessage;
    property &Type: string read FType write FType;
    property Param: string read FParam write FParam;
    property Code: string read FCode write FCode;
    property Detail: TArray<TDetail> read FDetail write FDetail;
    destructor Destroy; override;
  end;

implementation

{ TError422 }

destructor TError422.Destroy;
begin
  if Assigned(FMessage) then
    FMessage.Free;
  if Assigned(FDetail) then
    for var Item in FDetail do
      Item.Free;
  inherited;
end;

{ TDetail }

destructor TDetail.Destroy;
begin
  if Assigned(FCTX) then
    FCTX.Free;
  inherited;
end;

{ TMessage422 }

destructor TMessage422.Destroy;
begin
  for var Item in Detail do
    Item.Free;
  inherited;
end;

end.

unit MistralAI.Files;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.Classes, System.SysUtils, REST.JsonReflect, REST.Json.Types, System.Net.Mime,
  System.Threading, MistralAI.API.Params, MistralAI.API, MistralAI.Async.Support,
  MistralAI.Types;

type
  /// <summary>
  /// Parameters for uploading a file.
  /// </summary>
  /// <remarks>
  /// This class is used to construct the multipart form data for file uploads.
  /// Example usage:
  /// <code>
  /// var
  ///   UploadParams: TUploadParams;
  /// begin
  ///   UploadParams := TUploadParams.Create;
  ///   try
  ///     UploadParams.File('path/to/file.jsonl');
  ///     UploadParams.Purpose(TFilePurpose.finetune);
  ///     // Use UploadParams with the API upload method
  ///   finally
  ///     UploadParams.Free;
  ///   end;
  /// end;
  /// </code>
  /// </remarks>
  TUploadParams = class(TMultipartFormData)
    /// <summary>
    /// Adds a file to be uploaded from a file name.
    /// </summary>
    /// <param name="FileName">
    /// The name of the file to upload.
    /// </param>
    /// <returns>
    /// The current <c>TUploadParams</c> instance.
    /// </returns>
    /// <remarks>
    /// Example:
    /// <code>
    /// UploadParams.File('path/to/file.jsonl');
    /// </code>
    /// </remarks>
    function &File(const FileName: string): TUploadParams; overload;
    /// <summary>
    /// Adds a file to be uploaded from a stream.
    /// </summary>
    /// <param name="Stream">
    /// The stream containing the file data.
    /// </param>
    /// <param name="FileName">
    /// The name of the file.
    /// </param>
    /// <returns>
    /// The current <c>TUploadParams</c> instance.
    /// </returns>
    /// <remarks>
    /// Example:
    /// <code>
    /// var
    ///   FileStream: TFileStream;
    /// begin
    ///   FileStream := TFileStream.Create('path/to/file.jsonl', fmOpenRead);
    ///   try
    ///     UploadParams.File(FileStream, 'file.jsonl');
    ///   finally
    ///     FileStream.Free;
    ///   end;
    /// end;
    /// </code>
    /// </remarks>
    function &File(const Stream: TStream; const FileName: string): TUploadParams; overload;
    /// <summary>
    /// Sets the intended purpose of the uploaded file.
    /// </summary>
    /// <param name="Value">
    /// The purpose as a string. Only 'fine-tune' is accepted for now.
    /// </param>
    /// <returns>
    /// The current <c>TUploadParams</c> instance.
    /// </returns>
    /// <remarks>
    /// Example:
    /// <code>
    /// UploadParams.Purpose('fine-tune');
    /// </code>
    /// </remarks>
    function Purpose(const Value: string): TUploadParams; overload;
    /// <summary>
    /// Sets the intended purpose of the uploaded file.
    /// </summary>
    /// <param name="Value">
    /// The purpose as a <c>TFilePurpose</c> value.
    /// </param>
    /// <returns>
    /// The current <c>TUploadParams</c> instance.
    /// </returns>
    /// <remarks>
    /// Example:
    /// <code>
    /// UploadParams.Purpose(TFilePurpose.finetune);
    /// </code>
    /// </remarks>
    function Purpose(const Value: TFilePurpose): TUploadParams; overload;
    /// <summary>
    /// Creates a new instance of <c>TUploadParams</c>.
    /// </summary>
    /// <remarks>
    /// Initializes the multipart form data with ownership set to True.
    /// </remarks>
    constructor Create;  reintroduce;
  end;

  /// <summary>
  /// Represents the parameters for listing files with specific criteria.
  /// </summary>
  /// <remarks>
  /// This class is used to configure and pass parameters when listing files from the API.
  /// It provides methods to set pagination, filtering, and searching options.
  /// </remarks>
  TListParams = class(TUrlParam)
  public
    /// <summary>
    /// Sets the intended page in the returned list.
    /// </summary>
    /// <param name="Value">
    /// Integer type size value. Default 0
    /// </param>
    /// <returns>
    /// The current <c>TListParams</c> instance.
    /// </returns>
    function Page(const Value: Integer): TListParams;
    /// <summary>
    /// Sets the intended page size of the returned list.
    /// </summary>
    /// <param name="Value">
    /// Integer type size value. Default 100
    /// </param>
    /// <returns>
    /// The current <c>TListParams</c> instance.
    /// </returns>
    function PageSize(const Value: Integer): TListParams;
    /// <summary>
    /// Sets the intended sample_type of the listed file.
    /// </summary>
    /// <param name="Value">
    /// The sample_type as a <c>TSampleType</c> value.
    /// </param>
    /// <returns>
    /// The current <c>TListParams</c> instance.
    /// </returns>
    function SampleType(const Value: TArray<TSampleType>): TListParams;
    /// <summary>
    /// Sets the intended source of the listed file.
    /// </summary>
    /// <param name="Value">
    /// The source as a <c>TSourceType</c> value.
    /// </param>
    /// <returns>
    /// The current <c>TListParams</c> instance.
    /// </returns>
    function Source(const Value: TArray<TSourceType>): TListParams;
    /// <summary>
    /// Sets the intended search of the listed file.
    /// </summary>
    /// <param name="Value">
    /// The search as a <c>string</c> type value.
    /// </param>
    /// <returns>
    /// The current <c>TListParams</c> instance.
    /// </returns>
    function Search(const Value: string): TListParams;
    /// <summary>
    /// Sets the intended purpose of the listed file.
    /// </summary>
    /// <param name="Value">
    /// The purpose as a <c>TFilePurpose</c> value.
    /// </param>
    /// <returns>
    /// The current <c>TListParams</c> instance.
    /// </returns>
    function Purpose(const Value: TFilePurpose): TListParams;
  end;

  /// <summary>
  /// Represents a file in the Mistral AI system.
  /// </summary>
  /// <remarks>
  /// This class contains properties that represent the attributes of a file as returned by the API.
  /// </remarks>
  TFile = class
  private
    FBytes: Int64;
    [JsonNameAttribute('created_at')]
    FCreated_at: Int64;
    FFilename: string;
    FId: string;
    FObject: string;
    [JsonReflectAttribute(ctString, rtString, TFilePurposeInterceptor)]
    FPurpose: TFilePurpose;
    [JsonReflectAttribute(ctString, rtString, TSampleTypeInterceptor)]
    [JsonNameAttribute('sample_type')]
    FSampleType: TSampleType;
    [JsonNameAttribute('num_lines')]
    FNumLines: Int64;
    [JsonReflectAttribute(ctString, rtString, TSourceTypeInterceptor)]
    FSource: TSourceType;
    FDeleted: Boolean;
  public
    /// <summary>
    /// The size (in bytes) of the file.
    /// </summary>
    property Bytes: Int64 read FBytes write FBytes;
    /// <summary>
    /// The UNIX timestamp (in seconds) when the file was created.
    /// </summary>
    /// <remarks>
    /// You can convert this to a TDateTime using standard Delphi functions.
    /// Example:
    /// <code>
    /// var
    ///   CreationDate: TDateTime;
    /// begin
    ///   CreationDate := UnixToDateTime(File.CreatedAt);
    /// end;
    /// </code>
    /// </remarks>
    property CreatedAt: Int64 read FCreated_at write FCreated_at;
    /// <summary>
    /// The name of the uploaded file.
    /// </summary>
    property FileName: string read FFilename write FFilename;
    /// <summary>
    /// The unique identifier of the file.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// The object type, which is always 'file'.
    /// </summary>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// The intended purpose of the file.
    /// </summary>
    property Purpose: TFilePurpose read FPurpose write FPurpose;
    /// <summary>
    /// Enum: "pretrain" "instruct" "batch_request" "batch_result" "batch_error"
    /// </summary>
    property SampleType: TSampleType read FSampleType write FSampleType;
    /// <summary>
    /// Num lines returned
    /// </summary>
    property NumLines: Int64 read FNumLines write FNumLines;
    /// <summary>
    /// Enum: "upload" "repository" "mistral"
    /// </summary>
    property Source: TSourceType read FSource write FSource;
    /// <summary>
    /// Indicator when file retrieving only
    /// </summary>
    property Deleted: Boolean read FDeleted write FDeleted;
  end;

  /// <summary>
  /// Represents a collection of files.
  /// </summary>
  /// <remarks>
  /// This class is used to hold a list of files as returned by the API.
  /// Example usage:
  /// <code>
  /// var
  ///   Files: TFiles;
  ///   FileItem: TFile;
  /// begin
  ///   Files := FilesRoute.List;
  ///   try
  ///     for FileItem in Files.Data do
  ///     begin
  ///       // Process each file
  ///     end;
  ///   finally
  ///     Files.Free;
  ///   end;
  /// end;
  /// </code>
  /// </remarks>
  TFiles = class
  private
    FData: TArray<TFile>;
    FObject: string;
    FTotal: Int64;
  public
    /// <summary>
    /// An array of <c>TFile</c> objects representing the files.
    /// </summary>
    property Data: TArray<TFile> read FData write FData;
    /// <summary>
    /// The object type, which is always 'list'.
    /// </summary>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// The total returned
    /// </summary>
    property Total: Int64 read FTotal write FTotal;
    /// <summary>
    /// Destroys the <c>TFiles</c> instance and frees associated resources.
    /// </summary>
    /// <remarks>
    /// This destructor ensures that all <c>TFile</c> instances in the Data array are properly freed.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents the result of a file deletion operation.
  /// </summary>
  /// <remarks>
  /// Contains information about the deletion status and the ID of the deleted file.
  /// </remarks>
  TDeletedResult = class
  private
    [JsonNameAttribute('deleted')]
    FDeleted: Boolean;
    [JsonNameAttribute('id')]
    FId: string;
    [JsonNameAttribute('object')]
    FObject: string;
  public
    /// <summary>
    /// Indicates whether the file was successfully deleted.
    /// </summary>
    property Deleted: Boolean read FDeleted write FDeleted;
    /// <summary>
    /// The unique identifier of the deleted file.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// The object type, which is always 'file'.
    /// </summary>
    property &Object: string read FObject write FObject;
  end;

  /// <summary>
  /// Represents a downloaded file, providing functionality to access and save its data.
  /// </summary>
  /// <remarks>
  /// This class encapsulates a downloaded file and provides methods to retrieve its data as a stream
  /// or save it to a file. The file data is expected to be in a base64-encoded format.
  /// </remarks>
  TDownLoadFile = class
  private
    FData: string;
    FFileName: string;
  public
    /// <summary>
    /// Gets the file name where the data was saved.
    /// </summary>
    /// <value>
    /// The file path as a string.
    /// </value>
    /// <remarks>
    /// This property holds the file name specified in the last call to <c>SaveToFile</c>.
    /// </remarks>
    property FileName: string read FFileName write FFileName;
    /// <summary>
    /// Retrieves the downloaded file as a <c>TStream</c>.
    /// </summary>
    /// <returns>
    /// A <c>TStream</c> containing the decoded image data.
    /// </returns>
    /// <remarks>
    /// This method decodes the base64-encoded data and returns it as a stream.
    /// The caller is responsible for freeing the returned stream.
    /// </remarks>
    /// <exception cref="Exception">
    /// Raises an exception data field is empty.
    /// </exception>
    function GetStream: TStream;
    /// <summary>
    /// Saves the gdownloaded file to a file.
    /// </summary>
    /// <param name="FileName">
    /// The file path to save data.
    /// </param>
    /// <remarks>
    /// This method decodes the base64-encoded data and saves it to the specified file.
    /// </remarks>
    /// <exception cref="Exception">
    /// Raises an exception if the data cannot be decoded or saved.
    /// </exception>
    procedure SaveToFile(const FileName: string; const FailIfExists: Boolean = True);
    /// <summary>
    /// File downloaded as base64-encoded data
    /// </summary>
    property Data: string read FData write FData;
  end;

  /// <summary>
  /// Asynchronous callback parameters for operations returning a single <c>TFile</c>.
  /// </summary>
  /// <remarks>
  /// Used when performing asynchronous operations that return a <c>TFile</c> instance.
  /// </remarks>
  TAsynFile = TAsyncCallBack<TFile>;

  /// <summary>
  /// Asynchronous callback parameters for operations returning <c>TFiles</c>.
  /// </summary>
  /// <remarks>
  /// Used when performing asynchronous operations that return a <c>TFiles</c> instance.
  /// </remarks>
  TAsynFiles = TAsyncCallBack<TFiles>;

  /// <summary>
  /// Asynchronous callback parameters for file deletion operations.
  /// </summary>
  /// <remarks>
  /// Used when performing asynchronous operations that return a <c>TDeletedResult</c> instance.
  /// </remarks>
  TAsynFilesDelete = TAsyncCallBack<TDeletedResult>;

  /// <summary>
  /// Asynchronous callback parameters for file download operations.
  /// </summary>
  /// <remarks>
  /// Used when performing asynchronous operations that return a <c>TDownLoadFile</c> instance.
  /// </remarks>
  TAsynDownLoadFile = TAsyncCallBack<TDownLoadFile>;

  /// <summary>
  /// Provides methods to interact with the Mistral AI Files API.
  /// </summary>
  /// <remarks>
  /// This class includes both synchronous and asynchronous methods for file operations.
  /// Example usage:
  /// <code>
  /// var
  ///   FilesRoute: TFilesRoute;
  ///   FileInfo: TFile;
  /// begin
  ///   FilesRoute := TFilesRoute.Create(APIInstance);
  ///   try
  ///     FileInfo := FilesRoute.Retrieve('file_id');
  ///     // Process FileInfo
  ///   finally
  ///     FilesRoute.Free;
  ///     FileInfo.Free;
  ///   end;
  /// end;
  /// </code>
  /// </remarks>
  TFilesRoute = class(TMistralAIAPIRoute)
    /// <summary>
    /// Asynchronously deletes a file.
    /// </summary>
    /// <param name="FileId">
    /// The unique identifier of the file to delete.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns the asynchronous callback parameters.
    /// </param>
    /// <remarks>
    /// Example:
    /// <code>
    /// MistralAI.File.AsyncDelete(
    ///   'file_id',
    ///   function: TAsynFilesDelete
    ///   begin
    ///     Result.OnSuccess :=
    ///       procedure(Sender: TObject; DeletedResult: TDeletedResult)
    ///       begin
    ///         // Handle successful deletion
    ///       end;
    ///
    ///     Result.OnError :=
    ///       procedure(Sender: TObject; ErrorMsg: string)
    ///       begin
    ///         // Handle error
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncDelete(const FileId: string; const CallBacks: TFunc<TAsynFilesDelete>);
    /// <summary>
    /// Asynchronously download a file.
    /// </summary>
    /// <param name="FileId">
    /// The unique identifier of the file to download.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns the asynchronous callback parameters.
    /// </param>
    /// <remarks>
    /// Example:
    /// <code>
    /// MistralAI.File.AsynDownload(
    ///   'file_id',
    ///   function: TAsynDownLoadFile
    ///   begin
    ///     Result.OnSuccess :=
    ///       procedure(Sender: TObject; Value: TDownLoadFile)
    ///       begin
    ///         // Handle successful deletion
    ///       end;
    ///
    ///     Result.OnError :=
    ///       procedure(Sender: TObject; ErrorMsg: string)
    ///       begin
    ///         // Handle error
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncDownload(const FileId: string; const CallBacks: TFunc<TAsynDownLoadFile>);
    /// <summary>
    /// Asynchronously retrieves the list of files belonging to the user's organization.
    /// </summary>
    /// <param name="CallBacks">
    /// A function that returns the asynchronous callback parameters.
    /// </param>
    /// <remarks>
    /// Example:
    /// <code>
    /// MistralAI.File.AsyncList(
    ///   function: TAsynFiles
    ///   begin
    ///     Result.OnSuccess :=
    ///       procedure(Sender: TObject; Files: TFiles)
    ///       begin
    ///         // Process files
    ///       end;
    ///
    ///     Result.OnError :=
    ///       procedure(Sender: TObject; ErrorMsg: string)
    ///       begin
    ///         // Handle error
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncList(CallBacks: TFunc<TAsynFiles>); overload;
    /// <summary>
    /// Asynchronously retrieves the list of files belonging to the user's organization.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the <c>TListParams</c> for the upload.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns the asynchronous callback parameters.
    /// </param>
    /// <remarks>
    /// Example:
    /// <code>
    /// MistralAI.File.AsyncList(
    ///   function: TAsynFiles
    ///   begin
    ///     Result.OnSuccess :=
    ///       procedure(Sender: TObject; Files: TFiles)
    ///       begin
    ///         // Process files
    ///       end;
    ///
    ///     Result.OnError :=
    ///       procedure(Sender: TObject; ErrorMsg: string)
    ///       begin
    ///         // Handle error
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncList(ParamProc: TProc<TListParams>; CallBacks: TFunc<TAsynFiles>); overload;
    /// <summary>
    /// Asynchronously retrieves information about a specific file.
    /// </summary>
    /// <param name="FileId">
    /// The unique identifier of the file to retrieve.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns the asynchronous callback parameters.
    /// </param>
    /// <remarks>
    /// Example:
    /// <code>
    /// MistralAI.File.AsyncRetrieve(
    ///   'file_id',
    ///   function: TAsynFile
    ///   begin
    ///     Result.OnSuccess :=
    ///       procedure(Sender: TObject; FileInfo: TFile)
    ///       begin
    ///         // Process FileInfo
    ///       end;
    ///
    ///     Result.OnError :=
    ///       procedure(Sender: TObject; ErrorMsg: string)
    ///       begin
    ///         // Handle error
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncRetrieve(const FileId: string; const CallBacks: TFunc<TAsynFile>);
    /// <summary>
    /// Asynchronously uploads a file that can be used across various endpoints.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the <c>TUploadParams</c> for the upload.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns the asynchronous callback parameters.
    /// </param>
    /// <remarks>
    /// The size of individual files can be a maximum of 512 MB. The Fine-tuning API only supports .jsonl files. Please contact support if you need to increase these storage limits.
    /// Example:
    /// <code>
    /// MistralAI.File.AsyncUpload(
    ///   procedure(Params: TUploadParams)
    ///   begin
    ///     Params.File('path/to/file.jsonl');
    ///     Params.Purpose(TFilePurpose.finetune);
    ///   end,
    ///   function: TAsynFile
    ///   begin
    ///     Result.OnSuccess :=
    ///       procedure(Sender: TObject; UploadedFile: TFile)
    ///       begin
    ///         // Process UploadedFile
    ///       end;
    ///
    ///     Result.OnError :=
    ///       procedure(Sender: TObject; ErrorMsg: string)
    ///       begin
    ///         // Handle error
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure ASyncUpload(ParamProc: TProc<TUploadParams>; const CallBacks: TFunc<TAsynFile>);
    /// <summary>
    /// Deletes a file.
    /// </summary>
    /// <param name="FileId">
    /// The unique identifier of the file to delete.
    /// </param>
    /// <returns>
    /// A <c>TDeletedResult</c> instance representing the result of the deletion.
    /// </returns>
    /// <remarks>
    /// Example:
    /// <code>
    ///   with MistralAI.File.Delete('file_id');
    ///   try
    ///     if Deleted then
    ///       ShowMessage('file deleted');
    ///   finally
    ///     Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Delete(const FileId: string): TDeletedResult;
    /// <summary>
    /// Download a file.
    /// </summary>
    /// <param name="FileId">
    /// The unique identifier of the file to delete.
    /// </param>
    /// <returns>
    /// A <c>TDownLoadFile</c> instance representing the result of the download.
    /// </returns>
    /// <remarks>
    /// Example:
    /// <code>
    ///   with MistralAI.File.Download('file_id');
    ///   try
    ///     //do something
    ///   finally
    ///     Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Download(const FileId: string): TDownLoadFile;
    /// <summary>
    /// Retrieves the list of files belonging to the user's organization.
    /// </summary>
    /// <returns>
    /// A <c>TFiles</c> instance containing the list of files.
    /// </returns>
    /// <remarks>
    /// Example:
    /// <code>
    ///   var Files := MistralAI.File.List;
    ///   try
    ///     // Process files
    ///   finally
    ///     Files.Free;
    /// end;
    /// </code>
    /// </remarks>
    function List: TFiles; overload;
    /// <summary>
    /// Retrieves the list of files belonging to the user's organization.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the <c>TListParams</c> for the upload.
    /// </param>
    /// <returns>
    /// A <c>TFiles</c> instance containing the list of files.
    /// </returns>
    /// <remarks>
    /// Example:
    /// <code>
    ///   var Files := MistralAI.File.List(
    ///     procedure (Params: TListParams)
    ///     begin
    ///       // Set parameters
    ///     end);
    ///   try
    ///     // Process files
    ///   finally
    ///     Files.Free;
    /// end;
    /// </code>
    /// </remarks>
    function List(ParamProc: TProc<TListParams>): TFiles; overload;
    /// <summary>
    /// Retrieves information about a specific file.
    /// </summary>
    /// <param name="FileId">
    /// The unique identifier of the file to retrieve.
    /// </param>
    /// <returns>
    /// A <c>TFile</c> instance containing the file information.
    /// </returns>
    /// <remarks>
    /// Example:
    /// <code>
    ///   var FileInfo := MistralAI.File.Retrieve('file_id');
    ///   try
    ///     // Process FileInfo
    ///   finally
    ///     FileInfo.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Retrieve(const FileId: string): TFile;
    /// <summary>
    /// Uploads a file that can be used across various endpoints.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the <c>TUploadParams</c> for the upload.
    /// </param>
    /// <returns>
    /// A <c>TFile</c> instance representing the uploaded file.
    /// </returns>
    /// <remarks>
    /// The size of individual files can be a maximum of 512 MB. The Fine-tuning API only supports .jsonl files. Please contact support if you need to increase these storage limits.
    /// Example:
    /// <code>
    ///   var UploadedFile := MistralAI.File.Upload(
    ///     procedure(Params: TUploadParams)
    ///     begin
    ///       Params.File('path/to/file.jsonl');
    ///       Params.Purpose(TFilePurpose.finetune);
    ///     end);
    ///   try
    ///     // Process UploadedFile
    ///   finally
    ///     UploadedFile.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Upload(ParamProc: TProc<TUploadParams>): TFile;
  end;

implementation

uses
  System.StrUtils, Rest.Json, System.Rtti, MistralAI.NetEncoding.Base64, Vcl.Dialogs;

{ TUploadParams }

function TUploadParams.&File(const FileName: string): TUploadParams;
begin
  AddFile('file', FileName);
  Result := Self;
end;

constructor TUploadParams.Create;
begin
  inherited Create(True);
end;

function TUploadParams.&File(const Stream: TStream;
  const FileName: string): TUploadParams;
begin
  {$IF RTLVersion >= 36.0}
  AddStream('file', Stream, True, FileName);
  {$ELSE}
  AddStream('file', Stream, FileName);
  {$ENDIF}
  Result := Self;
end;

function TUploadParams.Purpose(const Value: string): TUploadParams;
begin
  AddField('purpose', Value);
  Result := Self;
end;

function TUploadParams.Purpose(const Value: TFilePurpose): TUploadParams;
begin
  Result := Purpose(Value.ToString);
end;

{ TFilesRoute }

procedure TFilesRoute.AsyncDelete(const FileId: string;
  const CallBacks: TFunc<TAsynFilesDelete>);
begin
  with TAsyncCallBackExec<TAsynFilesDelete, TDeletedResult>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TDeletedResult
      begin
        Result := Delete(FileId);
      end);
  finally
    Free;
  end;
end;

procedure TFilesRoute.AsyncList(ParamProc: TProc<TListParams>; CallBacks: TFunc<TAsynFiles>);
begin
  with TAsyncCallBackExec<TAsynFiles, TFiles>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TFiles
      begin
        Result := List(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TFilesRoute.AsyncList(CallBacks: TFunc<TAsynFiles>);
begin
  with TAsyncCallBackExec<TAsynFiles, TFiles>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TFiles
      begin
        Result := List;
      end);
  finally
    Free;
  end;
end;

procedure TFilesRoute.AsyncRetrieve(const FileId: string;
  const CallBacks: TFunc<TAsynFile>);
begin
  with TAsyncCallBackExec<TAsynFile, TFile>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TFile
      begin
        Result := Retrieve(FileId);
      end);
  finally
    Free;
  end;
end;

procedure TFilesRoute.ASyncUpload(ParamProc: TProc<TUploadParams>;
  const CallBacks: TFunc<TAsynFile>);
begin
  with TAsyncCallBackExec<TAsynFile, TFile>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TFile
      begin
        Result := Upload(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TFilesRoute.AsyncDownload(const FileId: string;
  const CallBacks: TFunc<TAsynDownLoadFile>);
begin
  with TAsyncCallBackExec<TAsynDownLoadFile, TDownLoadFile>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TDownLoadFile
      begin
        Result := Self.Download(FileId);
      end);
  finally
    Free;
  end;
end;

function TFilesRoute.Delete(const FileId: string): TDeletedResult;
begin
  Result := API.Delete<TDeletedResult>('files/' + FileId);
end;

function TFilesRoute.Download(const FileId: string): TDownLoadFile;
begin
  Result := API.GetFile<TDownLoadFile>(Format('files/%s/content', [FileId]));
end;

function TFilesRoute.List: TFiles;
begin
  Result := API.Get<TFiles>('files');
end;

function TFilesRoute.List(ParamProc: TProc<TListParams>): TFiles;
begin
  Result := API.Get<TFiles, TListParams>('files', ParamProc);
end;

function TFilesRoute.Retrieve(const FileId: string): TFile;
begin
  Result := API.Get<TFile>('files/' + FileId);
end;

function TFilesRoute.Upload(ParamProc: TProc<TUploadParams>): TFile;
begin
  Result := API.PostForm<TFile, TUploadParams>('files', ParamProc);
end;

{ TFiles }

destructor TFiles.Destroy;
begin
  for var Item in FData do
    if Assigned(Item) then
      Item.Free;
  inherited;
end;

{ TListParams }

function TListParams.Page(const Value: Integer): TListParams;
begin
  Result := TListParams(Add('page', Value));
end;

function TListParams.PageSize(const Value: Integer): TListParams;
begin
  Result := TListParams(Add('page_size', Value));
end;

function TListParams.Purpose(const Value: TFilePurpose): TListParams;
begin
  Result := TListParams(Add('purpose', Value.ToString));
end;

function TListParams.SampleType(const Value: TArray<TSampleType>): TListParams;
begin
  var Param: TArray<string> := [];
  for var Item in Value do
    Param := Param + [Item.ToString];
  Result := TListParams(Add('sample_type', Param));
end;

function TListParams.Search(const Value: string): TListParams;
begin
  Result := TListParams(Add('search', Value));
end;

function TListParams.Source(const Value: TArray<TSourceType>): TListParams;
begin
  var Param: TArray<string> := [];
  for var Item in Value do
    Param := Param + [Item.ToString];
  Result := TListParams(Add('source', Param));
end;

{ TDownLoadFile }

function TDownLoadFile.GetStream: TStream;
begin
  {--- Create a memory stream to write the decoded content. }
  Result := TMemoryStream.Create;
  try
    {--- Convert the base-64 string directly into the memory stream. }
    DecodeBase64ToStream(Data, Result)
  except
    Result.Free;
    raise;
  end;
end;

procedure TDownLoadFile.SaveToFile(const FileName: string; const FailIfExists: Boolean);
begin
  if FileExists(FileName) and FailIfExists then
    raise Exception.CreateFmt('The file "%s" already exists and has not been overwritten.', [FileName]);
  try
    Self.FFileName := FileName;
    {--- Perform the decoding operation and save it into the file specified by the FileName parameter. }
    DecodeBase64ToFile(Data, FileName)
  except
    raise;
  end;
end;

end.

unit MistralAI.FineTunings;

{-------------------------------------------------------------------------------

  **Important Notice**
                                                                                                                                                            |
  To monitor and track the progress of fine-tuning using Wandb.ai tools,
  you are required to register on the Wandb website at   https://wandb.ai/site.

  Registration is necessary to obtain the API key needed for "job" integration
  (TJobIntegrationsParam).

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

-------------------------------------------------------------------------------}

interface

uses
  System.Classes, System.SysUtils, REST.JsonReflect, System.JSON, REST.Json.Types,
  MistralAI.API.Params, MistralAI.API, MistralAI.Types, MistralAI.Async.Support;

type
  /// <summary>
  /// Represents the parameters for listing fine-tuning jobs.
  /// </summary>
  /// <remarks>
  /// Allows filtering and pagination of fine-tuning jobs when retrieving them via the API.
  /// </remarks>
  TFineTuningJobListParams = class(TURLParam)
    /// <summary>
    /// Sets the page number of the results to be returned.
    /// </summary>
    /// <param name="Value">
    /// The page number (starting from 0).
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobListParams"/> instance with the updated page number.
    /// </returns>
    /// <remarks> Default: 0 </remarks>
    function Page(const Value: Int64): TFineTuningJobListParams;
    /// <summary>
    /// Sets the number of items to return per page.
    /// </summary>
    /// <param name="Value">
    /// The number of items per page.
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobListParams"/> instance with the updated page size.
    /// </returns>
    /// <remarks> Default: 100 </remarks>
    function PageSize(const Value: Int64): TFineTuningJobListParams;
    /// <summary>
    /// Filters the fine-tuning jobs by model name.
    /// </summary>
    /// <param name="Value">
    /// The model name used for fine-tuning to filter on.
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobListParams"/> instance with the updated model filter.
    /// </returns>
    function Model(const Value: string): TFineTuningJobListParams;
    /// <summary>
    /// Filters the fine-tuning jobs by their current status.
    /// </summary>
    /// <param name="Value">
    /// The current job state to filter on.
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobListParams"/> instance with the updated status filter.
    /// </returns>
    function Status(const Value: TFineTuningJobStatus): TFineTuningJobListParams;
    /// <summary>
    /// Filters the fine-tuning jobs created after a specific date/time.
    /// </summary>
    /// <param name="Value">
    /// The date/time (ISO 8601 format) to filter on.
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobListParams"/> instance with the updated creation date filter.
    /// </returns>
    function CreatedAfter(const Value: string): TFineTuningJobListParams;
    /// <summary>
    /// Filters to only include jobs created by the API caller.
    /// </summary>
    /// <param name="Value">
    /// Set to <c>true</c> to include only jobs created by the API caller.
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobListParams"/> instance with the updated creator filter.
    /// </returns>
    /// <remarks> Default: false </remarks>
    function CreatedByMe(const Value: Boolean = True): TFineTuningJobListParams;
    /// <summary>
    /// Filters the fine-tuning jobs by Weights and Biases project name.
    /// </summary>
    /// <param name="Value">
    /// The WandB project name to filter on.
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobListParams"/> instance with the updated WandB project filter.
    /// </returns>
    function WandbProject(const Value: string): TFineTuningJobListParams;
    /// <summary>
    /// Filters the fine-tuning jobs by Weights and Biases run name.
    /// </summary>
    /// <param name="Value">
    /// The WandB run name to filter on.
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobListParams"/> instance with the updated WandB run name filter.
    /// </returns>
    function WandbName(const Value: string): TFineTuningJobListParams;
    /// <summary>
    /// Filters the fine-tuning jobs by model suffix.
    /// </summary>
    /// <param name="Value">
    /// The model suffix to filter on.
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobListParams"/> instance with the updated suffix filter.
    /// </returns>
    function Suffix(const Value: string): TFineTuningJobListParams;
  end;

  /// <summary>
  /// Represents the hyperparameters used in a fine-tuning job.
  /// </summary>
  /// <remarks>
  /// Includes settings such as the number of training steps and the learning rate.
  /// </remarks>
  THyperparametersParams = class(TJSONParam)
  public
    /// <summary>
    /// The number of training steps to perform. A training step refers to a single update of the model
    /// weights during the fine-tuning process. This update is typically calculated using a batch of
    /// samples from the training dataset.
    /// </summary>
    /// <remarks>
    /// Must be greater than or equal to 1. This property is required.
    /// </remarks>
    function TrainingSteps(const Value: Integer): THyperparametersParams;
    /// <summary>
    /// The learning rate for the fine-tuning process. It describes how much to adjust the pre-trained model's weights in response to
    /// the estimated error each time the weights are updated during the fine-tuning process.
    /// </summary>
    /// <remarks>
    /// Must be in the range [1e-8..1]. Default value: 0.0001.
    /// </remarks>
    function LearningRate(const Value: Double): THyperparametersParams;
    /// <summary>
    /// (Advanced Usage) Weight decay adds a term to the loss function that is proportional to the sum
    /// of the squared weights. This term reduces the magnitude of the weights and prevents them from
    /// growing too large.
    /// </summary>
    function WeightDecay(const Value: Double): THyperparametersParams;
    /// <summary>
    /// (Advanced Usage) A parameter that specifies the percentage of the total training steps at which
    /// the learning rate warm-up phase ends. During this phase, the learning rate gradually increases
    /// from a small value to the initial learning rate, helping to stabilize the training process and
    /// improve convergence. Similar to pct_start in mistral-finetune.
    /// </summary>
    function WarmupFraction(const Value: Double): THyperparametersParams;
    /// <summary>
    /// Set epochs value
    /// </summary>
    function Epochs(const Value: Double): THyperparametersParams;
    /// <summary>
    /// Set fim_ration value
    /// </summary>
    function FimRatio(const Value: Double): THyperparametersParams;
    /// <summary>
    /// Set seq_len value
    /// </summary>
    function SeqLen(const Value: Integer): THyperparametersParams;
    class function New(const ParamProc: TProcRef<THyperparametersParams>): THyperparametersParams;
  end;

  /// <summary>
  /// Represents the integration parameters for a fine-tuning job.
  /// </summary>
  /// <remarks>
  /// Specifies details for integrating with external platforms for monitoring fine-tuning jobs, such as Weights and Biases.
  /// </remarks>
  TJobIntegrationsParams = class(TJSONParam)
  public
    /// <summary>
    /// The type of integration.
    /// </summary>
    /// <remarks>
    /// Default: "wandb". Currently, only "wandb" (Weights and Biases) is supported. This property is required.
    /// </remarks>
    function &Type(const Value: TFineTuningIntegrationType): TJobIntegrationsParams;
    /// <summary>
    /// The name of the project under which the new run will be created.
    /// </summary>
    /// <remarks> This property is required. </remarks>
    function Project(const Value: string): TJobIntegrationsParams;
    /// <summary>
    /// A display name to set for the run. If not set, will use the job ID as the name.
    /// </summary>
    function Name(const Value: string): TJobIntegrationsParams;
    /// <summary>
    /// The WandB API key to use for authentication.
    /// </summary>
    /// <remarks> This property is required. </remarks>
    function ApiKey(const Value: string): TJobIntegrationsParams;
    /// <summary>
    /// A display run name to set for this run.
    /// </summary>
    function RunName(const Value: string): TJobIntegrationsParams;
    class function New(const ParamProc: TProcRef<TJobIntegrationsParams>): TJobIntegrationsParams;
  end;

  /// <summary>
  /// Represents the parameters required for configuring a repository in fine-tuning jobs.
  /// </summary>
  /// <remarks>
  /// This class is used to specify details about a repository, including its type, name, owner, reference,
  /// weight, and token. These parameters are typically used when setting up repositories for fine-tuning jobs.
  /// </remarks>
  TRepositoryParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the type of the repository.
    /// </summary>
    /// <param name="Value">
    /// The type of the repository as an enum value of <see cref="TRepositoryType"/>.
    /// </param>
    /// <returns>
    /// The <see cref="TRepositoryParams"/> instance with the updated repository type.
    /// </returns>
    function &Type(const Value: TRepositoryType): TRepositoryParams;
    /// <summary>
    /// Sets the name of the repository.
    /// </summary>
    /// <param name="Value">
    /// The name of the repository as a string.
    /// </param>
    /// <returns>
    /// The <see cref="TRepositoryParams"/> instance with the updated repository name.
    /// </returns>
    function Name(const Value: string): TRepositoryParams;
    /// <summary>
    /// Sets the owner of the repository.
    /// </summary>
    /// <param name="Value">
    /// The owner of the repository as a string.
    /// </param>
    /// <returns>
    /// The <see cref="TRepositoryParams"/> instance with the updated owner.
    /// </returns>
    function Owner(const Value: string): TRepositoryParams;
    /// <summary>
    /// Sets the reference for the repository.
    /// </summary>
    /// <param name="Value">
    /// The reference for the repository, such as a branch or commit hash, as a string.
    /// </param>
    /// <returns>
    /// The <see cref="TRepositoryParams"/> instance with the updated reference.
    /// </returns>
    function Ref(const Value: string): TRepositoryParams;
    /// <summary>
    /// Sets the weight for the repository.
    /// </summary>
    /// <param name="Value">
    /// The weight assigned to the repository as a double.
    /// </param>
    /// <returns>
    /// The <see cref="TRepositoryParams"/> instance with the updated weight.
    /// </returns>
    function Weight(const Value: Double): TRepositoryParams;
    /// <summary>
    /// Sets the token for accessing the repository.
    /// </summary>
    /// <param name="Value">
    /// The token for authentication as a string.
    /// </param>
    /// <returns>
    /// The <see cref="TRepositoryParams"/> instance with the updated token.
    /// </returns>
    function Token(const Value: string): TRepositoryParams;
    /// <summary>
    /// Creates a new instance of <see cref="TRepositoryParams"/> with configured parameters.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the parameters for the repository.
    /// </param>
    /// <returns>
    /// A new instance of <see cref="TRepositoryParams"/> with the specified parameters.
    /// </returns>
    class function New(const ParamProc: TProcRef<TRepositoryParams>): TRepositoryParams;
  end;

  /// <summary>
  /// Represents the parameters for creating a fine-tuning job.
  /// </summary>
  /// <remarks>
  /// Includes settings such as the model to fine-tune, training files, hyperparameters, and integrations.
  /// </remarks>
  TFineTuningJobParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the name of the model to fine-tune.
    /// </summary>
    /// <param name="Value">
    /// The name of the fine-tunable model.
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobParams"/> instance with the updated model name.
    /// </returns>
    /// <remarks> This property is required. </remarks>
    function Model(const Value: string): TFineTuningJobParams;
    /// <summary>
    /// Sets the IDs of uploaded files that contain training data.
    /// </summary>
    /// <param name="Value">
    /// An array of file IDs for training data.
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobParams"/> instance with the updated training files.
    /// </returns>
    /// <remarks> This property is required. </remarks>
    function TrainingFiles(const Value: TArray<string>): TFineTuningJobParams;
    /// <summary>
    /// Sets the IDs of uploaded files that contain validation data.
    /// </summary>
    /// <param name="Value">
    /// An array of file IDs for validation data.
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobParams"/> instance with the updated validation files.
    /// </returns>
    /// <remarks>
    /// If provided, the data is used to generate validation metrics periodically during fine-tuning.
    /// </remarks>
    function ValidationFiles(const Value: TArray<string>): TFineTuningJobParams;
    /// <summary>
    /// Sets the fine-tuning hyperparameter settings used in a fine-tune job.
    /// </summary>
    /// <param name="Value">
    /// The hyperparameters to use for fine-tuning.
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobParams"/> instance with the updated hyperparameters.
    /// </returns>
    /// <remarks> This property is required. </remarks>
    function Hyperparameters(Value: THyperparametersParams): TFineTuningJobParams; overload;
    /// <summary>
    /// Sets the fine-tuning hyperparameter settings used in a fine-tune job.
    /// </summary>
    /// <param name="Value">
    /// The hyperparameters to use for fine-tuning.
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobParams"/> instance with the updated hyperparameters.
    /// </returns>
    /// <remarks> This property is required. </remarks>
    function Hyperparameters(ParamProc: TProcRef<THyperparametersParams>): TFineTuningJobParams; overload;
    /// <summary>
    /// Sets a suffix to be added to the fine-tuned model name.
    /// <para>
    /// A string that will be added to your fine-tuning model name. For example, a suffix of
    /// "my-great-model" would produce a model name like ft:open-mistral-7b:my-great-model:xxx...
    /// </para>
    /// </summary>
    /// <param name="Value">
    /// A string less than 18 characters to be used as a suffix.
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobParams"/> instance with the updated suffix.
    /// </returns>
    function Suffix(const Value: string): TFineTuningJobParams;
    /// <summary>
    /// Sets the integrations to enable for the fine-tuning job.
    /// </summary>
    /// <param name="Value">
    /// An array of integration parameters.
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobParams"/> instance with the updated integrations.
    /// </returns>
    function Integrations(const Value: TArray<TJobIntegrationsParams>): TFineTuningJobParams; overload;
    /// <summary>
    /// Set the repositories reference .
    /// </summary>
    /// <param name="Value">
    /// An array of repository.
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobParams"/> instance with the updated integrations.
    /// </returns>
    function Repositories(const Value: TArray<TRepositoryParams>): TFineTuningJobParams;
    /// <summary>
    /// This field will be required in a future release.
    /// </summary>
    /// <param name="Value">
    /// Boolean value to manage the auto start
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobParams"/> instance with the updated integrations.
    /// </returns>
    function AutoStart(const Value: Boolean): TFineTuningJobParams;
  end;

  /// <summary>
  /// Represents the hyperparameters output in a fine-tuning job response.
  /// </summary>
  /// <remarks>
  /// Contains the hyperparameter settings used during fine-tuning.
  /// </remarks>
  TJobOutHyperparameters = class
  private
    [JsonNameAttribute('training_steps')]
    FTrainingSteps: Int64;
    [JsonNameAttribute('learning_rate')]
    FLearningRate: Extended;
  public
    /// <summary>
    /// The number of training steps performed.
    /// </summary>
    /// <remarks>
    /// An integer value greater than or equal to 1. This value is required.
    /// </remarks>
    property TrainingSteps: Int64 read FTrainingSteps write FTrainingSteps;
    /// <summary>
    /// The learning rate used during fine-tuning.
    /// </summary>
    /// <remarks>
    /// A value in the range [1e-8 .. 1]. This value is required.
    /// </remarks>
    property LearningRate: Extended read FLearningRate write FLearningRate;
  end;

  /// <summary>
  /// Represents the integrations output in a fine-tuning job response.
  /// </summary>
  /// <remarks>
  /// Contains information about integrations enabled for the fine-tuning job.
  /// </remarks>
  TJobOutIntegrations = class
  private
    [JsonReflectAttribute(ctString, rtString, TFineTuningIntegrationTypeInterceptor)]
    FType: TFineTuningIntegrationType;
    FProject: string;
    FName: string;
  public
    /// <summary>
    /// The type of integration.
    /// </summary>
    /// <remarks>
    /// Default: "wandb". Currently, only "wandb" is defined.
    /// </remarks>
    property &Type: TFineTuningIntegrationType read FType write FType;
    /// <summary>
    /// The name of the project that the run was created under.
    /// </summary>
    /// <remarks> This value is required. </remarks>
    property Project: string read FProject write FProject;
    /// <summary>
    /// The display name set for the run.
    /// </summary>
    property Name: string read FName write FName;
  end;

  /// <summary>
  /// Represents a repository used in the context of fine-tuning jobs.
  /// </summary>
  /// <remarks>
  /// This class encapsulates information about a repository, including its type, name, owner, reference, weight, and commit ID.
  /// It is used to provide detailed metadata about the repository in fine-tuning operations.
  /// </remarks>
  TRepository = class
  private
    [JsonReflectAttribute(ctString, rtString, TRepositoryTypeInterceptor)]
    FType: TRepositoryType;
    FName: string;
    FOwner: string;
    FRef: string;
    FWeight: Double;
    [JsonNameAttribute('commit_id')]
    FCommitId: string;
  public
    /// <summary>
    /// Gets or sets the type of the repository.
    /// </summary>
    /// <remarks>
    /// This property is required and determines the type of repository being used, such as "git" or "svn."
    /// </remarks>
    property &Type: TRepositoryType read FType write FType;
    /// <summary>
    /// Gets or sets the name of the repository.
    /// </summary>
    /// <remarks>
    /// This property represents the name of the repository as a string.
    /// </remarks>
    property Name: string read FName write FName;
    /// <summary>
    /// Gets or sets the owner of the repository.
    /// </summary>
    /// <remarks>
    /// This property specifies the owner of the repository, such as the username or organization name.
    /// </remarks>
    property Owner: string read FOwner write FOwner;
    /// <summary>
    /// Gets or sets the reference of the repository.
    /// </summary>
    /// <remarks>
    /// The reference can be a branch name, a tag, or a specific commit hash.
    /// </remarks>
    property Ref: string read FRef write FRef;
    /// <summary>
    /// Gets or sets the weight of the repository.
    /// </summary>
    /// <remarks>
    /// The weight is used to indicate the repository's relative importance or contribution in fine-tuning operations.
    /// </remarks>
    property Weight: Double read FWeight write FWeight;
    /// <summary>
    /// Gets or sets the commit ID of the repository.
    /// </summary>
    /// <remarks>
    /// This property specifies the exact commit used in the operation, ensuring reproducibility.
    /// </remarks>
    property CommitId: string read FCommitId write FCommitId;
  end;

  /// <summary>
  /// Represents metadata associated with data used in fine-tuning jobs.
  /// </summary>
  /// <remarks>
  /// This class provides detailed information about the cost, duration, and token usage
  /// for fine-tuning operations, offering insights into resource consumption.
  /// </remarks>
  TDataMetadata = class
  private
    [JsonNameAttribute('expected_duration_seconds')]
    FExpectedDurationSeconds: Int64;
    FCost: Double;
    [JsonNameAttribute('cost_currency')]
    FCostCurrency: string;
    [JsonNameAttribute('train_tokens_per_step')]
    FTrainTokensPerStep: Int64;
    [JsonNameAttribute('train_tokens')]
    FTrainTokens: Int64;
    [JsonNameAttribute('data_tokens')]
    FDataTokens: Int64;
    [JsonNameAttribute('estimated_start_time')]
    FEstimatedStartTime: Int64;
  public
    /// <summary>
    /// Gets or sets the expected duration of the fine-tuning job, in seconds.
    /// </summary>
    /// <remarks>
    /// This property provides an estimate of how long the job will take to complete.
    /// </remarks>
    property ExpectedDurationSeconds: Int64 read FExpectedDurationSeconds write FExpectedDurationSeconds;
    /// <summary>
    /// Gets or sets the total cost of the fine-tuning job.
    /// </summary>
    /// <remarks>
    /// This property reflects the overall monetary cost of the job.
    /// </remarks>
    property Cost: Double read FCost write FCost;
    /// <summary>
    /// Gets or sets the currency in which the cost is measured.
    /// </summary>
    /// <remarks>
    /// Examples include "USD" or "EUR."
    /// </remarks>
    property CostCurrency: string read FCostCurrency write FCostCurrency;
    /// <summary>
    /// Gets or sets the number of training tokens processed per step during fine-tuning.
    /// </summary>
    /// <remarks>
    /// This value helps analyze the efficiency of token processing in each training step.
    /// </remarks>
    property TrainTokensPerStep: Int64 read FTrainTokensPerStep write FTrainTokensPerStep;
    /// <summary>
    /// Gets or sets the total number of training tokens used in the fine-tuning process.
    /// </summary>
    /// <remarks>
    /// This property provides the cumulative count of tokens used for training the model.
    /// </remarks>
    property TrainTokens: Int64 read FTrainTokens write FTrainTokens;
    /// <summary>
    /// Gets or sets the total number of data tokens processed in the fine-tuning job.
    /// </summary>
    /// <remarks>
    /// This includes all tokens used in the training and validation datasets.
    /// </remarks>
    property DataTokens: Int64 read FDataTokens write FDataTokens;
    /// <summary>
    /// Gets or sets the estimated start time of the fine-tuning job, as a UNIX timestamp.
    /// </summary>
    /// <remarks>
    /// This property provides the predicted start time of the job for scheduling purposes.
    /// </remarks>
    property EstimatedStartTime: Int64 read FEstimatedStartTime write FEstimatedStartTime;
  end;

  /// <summary>
  /// Represents the output of a fine-tuning job.
  /// </summary>
  /// <remarks>
  /// Contains details about the fine-tuning job, including its status, parameters, and results.
  /// </remarks>
  TJobOut = class
  private
    FId: string;
    [JsonNameAttribute('auto_start')]
    FAutoStart: Boolean;
    FHyperparameters: TJobOutHyperparameters;
    FModel: string;
    [JsonReflectAttribute(ctString, rtString, TFineTuningJobStatusInterceptor)]
    FStatus: TFineTuningJobStatus;
    [JsonNameAttribute('job_type')]
    FJobType: string;
    [JsonNameAttribute('created_at')]
    FCreatedAt: Int64;
    [JsonNameAttribute('modified_at')]
    FModifiedAt: Int64;
    [JsonNameAttribute('training_files')]
    FTrainingFiles: TArray<string>;
    [JsonNameAttribute('validation_files')]
    FValidationFiles: TArray<string>;
    [JsonReflectAttribute(ctString, rtString, TFineTuningDataObjectKindInterceptor)]
    FObject: TFineTuningDataObjectKind;
    [JsonNameAttribute('fine_Tuning_model')]
    FFineTuningModel: string;
    FSuffix: string;
    FIntegrations: TArray<TJobOutIntegrations>;
    [JsonNameAttribute('trained_tokens')]
    FTrainedTokens: Int64;
    FRepositories: TArray<TRepository>;
    FMetadata: TDataMetadata;
  public
    /// <summary>
    /// The ID of the job.
    /// </summary>
    /// <remarks> This value is required. </remarks>
    property Id: string read FId write FId;
    /// <summary>
    /// The auto_start of the job.
    /// </summary>
    /// <remarks> This value is required. </remarks>
    property AutoStart: Boolean read FAutoStart write FAutoStart;
    /// <summary>
    /// The hyperparameters used in the fine-tuning job.
    /// </summary>
    /// <remarks> This value is required. </remarks>
    property Hyperparameters: TJobOutHyperparameters read FHyperparameters write FHyperparameters;
    /// <summary>
    /// The name of the model that was fine-tuned.
    /// </summary>
    /// <remarks> This value is required. </remarks>
    property Model: string read FModel write FModel;
    /// <summary>
    /// The current status of the fine-tuning job.
    /// </summary>
    /// <remarks> This value is required. </remarks>
    property Status: TFineTuningJobStatus read FStatus write FStatus;
    /// <summary>
    /// The type of job (e.g., "FT" for fine-tuning).
    /// </summary>
    /// <remarks> This value is required. </remarks>
    property JobType: string read FJobType write FJobType;
    /// <summary>
    /// The UNIX timestamp (in seconds) when the fine-tuning job was created.
    /// </summary>
    /// <remarks> This value is required. </remarks>
    property CreatedAt: Int64 read FCreatedAt write FCreatedAt;
    /// <summary>
    /// The UNIX timestamp (in seconds) when the fine-tuning job was last modified.
    /// </summary>
    /// <remarks> This value is required. </remarks>
    property ModifiedAt: Int64 read FModifiedAt write FModifiedAt;
    /// <summary>
    /// A list of IDs of uploaded files that contain training data.
    /// </summary>
    /// <remarks> This value is required. </remarks>
    property TrainingFiles: TArray<string> read FTrainingFiles write FTrainingFiles;
    //// <summary>
    /// A list of IDs of uploaded files that contain validation data.
    /// </summary>
    property ValidationFiles: TArray<string> read FValidationFiles write FValidationFiles;
    /// <summary>
    /// The kind of data object. Default is "job".
    /// </summary>
    /// <remarks>
    /// Currently only "job" is defined.
    /// </remarks>
    property &Object: TFineTuningDataObjectKind read FObject write FObject;
    /// <summary>
    /// The name of the fine-tuned model that was created. The value will be null if the fine-tuning job is still running.
    /// </summary>
    property FineTuningModel: string read FFineTuningModel write FFineTuningModel;
    /// <summary>
    /// Optional text/code that adds more context for the model. When given a prompt and a suffix
    /// the model will fill what is between them. When suffix is not provided, the model will simply
    /// execute completion starting with prompt.
    /// </summary>
    property Suffix: string read FSuffix write FSuffix;
    /// <summary>
    /// A list of integrations enabled for the fine-tuning job.
    /// </summary>
    property Integrations: TArray<TJobOutIntegrations> read FIntegrations write FIntegrations;
    /// <summary>
    /// Total number of tokens trained.
    /// </summary>
    property TrainedTokens: Int64 read FTrainedTokens write FTrainedTokens;
    /// <summary>
    /// Array of repositories (e.g. repository on GitHub) max <= 20 items
    /// </summary>
    property Repositories: TArray<TRepository> read FRepositories write FRepositories;
    /// <summary>
    /// JobMetadataOut
    /// </summary>
    property Metadata: TDataMetadata read FMetadata write FMetadata;
    /// <summary>
    /// Destructor for TJobOut.
    /// </summary>
    /// <remarks>
    /// Frees associated objects.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a list of fine-tuning jobs.
  /// </summary>
  /// <remarks>
  /// Contains an array of fine-tuning job outputs.
  /// </remarks>
  TListFineTuningJobs = class
  private
    FData: TArray<TJobOut>;
    [JsonReflectAttribute(ctString, rtString, TFineTuningObjectKindInterceptor)]
    FObject: TFineTuningObjectKind;
    FTotal: Int64;
  public
    /// <summary>
    /// An array of fine-tuning job outputs.
    /// </summary>
    property Data: TArray<TJobOut> read FData write FData;
    /// <summary>
    /// The kind of object. Default is "list".
    /// </summary>
    /// <remarks>
    /// Currently only "list" is defined.
    /// </remarks>
    property &Object: TFineTuningObjectKind read FObject write FObject;
    /// <summary>
    /// Count of Data
    /// </summary>
    property Total: Int64 read FTotal write FTotal;
    /// <summary>
    /// Destructor for TListFineTuningJobs.
    /// </summary>
    /// <remarks>
    /// Frees associated objects.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Status and error dot a fine-tune job.
  /// </summary>
  TJobOutEventData = class
  private
    [JsonReflectAttribute(ctString, rtString, TFineTuningJobStatusInterceptor)]
    FStatus: TFineTuningJobStatus;
    FError: string;
  public
    /// <summary>
    /// Status for a fine-tuning job
    /// </summary>
    property Status: TFineTuningJobStatus read FStatus write FStatus;
    /// <summary>
    /// Error message
    /// </summary>
    property Error: string read FError write FError;
  end;

  /// <summary>
  /// Represents an event in the fine-tuning job lifecycle.
  /// </summary>
  /// <remarks>
  /// Contains information about status changes during the job.
  /// </remarks>
  TJobOutEvent = class
  private
    FName: string;
    FData: TJobOutEventData;
    [JsonNameAttribute('created_at')]
    FCreatedAt: int64;
  public
    //// <summary>
    /// The name of the event.
    /// </summary>
    /// <remarks>
    /// This value is required.
    /// </remarks>
    property Name: string read FName write FName;
    /// <summary>
    /// The status of the fine-tuning job at the time of the event.
    /// </summary>
    /// <remarks>
    /// Enum values: "QUEUED", "STARTED", "RUNNING", "FAILED", "SUCCESS", "CANCELLED", "CANCELLATION_REQUESTED".
    /// </remarks>
    property Data: TJobOutEventData read FData write FData;
    /// <summary>
    /// The UNIX timestamp (in seconds) of the event.
    /// </summary>
    /// <remarks>
    /// This value is required.
    /// </remarks>
    property CreatedAt: int64 read FCreatedAt write FCreatedAt;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents metrics associated with a checkpoint during fine-tuning.
  /// </summary>
  /// <remarks>
  /// Contains loss and accuracy metrics.
  /// </remarks>
  TJobOutMetrics = class
  private
    [JsonNameAttribute('train_loss')]
    FTrainLoss: Extended;
    [JsonNameAttribute('valid_loss')]
    FValidLoss: Extended;
    [JsonNameAttribute('valid_mean_token_accuracy')]
    FValidMeanTokenAccuracy: Extended;
  public
    /// <summary>
    /// Training data loss rate.
    /// </summary>
    property TrainLoss: Extended read FTrainLoss write FTrainLoss;
    /// <summary>
    /// Validation data loss rate.
    /// </summary>
    property ValidLoss: Extended read FValidLoss write FValidLoss;
    /// <summary>
    /// Mean token accuracy on the validation set.
    /// </summary>
    property ValidMeanTokenAccuracy: Extended read FValidMeanTokenAccuracy write FValidMeanTokenAccuracy;
  end;

  /// <summary>
  /// Represents a checkpoint during the fine-tuning job.
  /// </summary>
  /// <remarks>
  /// Contains metrics and timing information at a specific step.
  /// </remarks>
  TJobOutCheckpoints = class
  private
    FMetrics: TJobOutMetrics;
    [JsonNameAttribute('step_number')]
    FStepNumber: Int64;
    [JsonNameAttribute('created_at')]
    FCreatedAt: Int64;
  public
    /// <summary>
    /// Metrics at the step number during the fine-tuning job.
    /// </summary>
    /// <remarks>
    /// Use these metrics to assess if the training is progressing as expected (e.g., loss should decrease).
    /// </remarks>
    property Metrics: TJobOutMetrics read FMetrics write FMetrics;
    /// <summary>
    /// The step number at which the checkpoint was created.
    /// </summary>
    property StepNumber: Int64 read FStepNumber write FStepNumber;
    /// <summary>
    /// The UNIX timestamp (in seconds) when the checkpoint was created.
    /// </summary>
    property CreatedAt: Int64 read FCreatedAt write FCreatedAt;
    /// <summary>
    /// Destructor for TJobOutCheckpoints.
    /// </summary>
    /// <remarks>
    /// Frees associated objects.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents detailed progress information for a fine-tuning job.
  /// </summary>
  /// <remarks>
  /// Extends <see cref="TJobOut"/> with events and checkpoints.
  /// </remarks>
  TJobOutProgress = class(TJobOut)
  private
    FEvents: TArray<TJobOutEvent>;
    FCheckpoints: TArray<TJobOutCheckpoints>;
  public
    /// <summary>
    /// Event items created every time the status of a fine-tuning job changes.
    /// </summary>
    /// <remarks>
    /// The timestamped list of all events is accessible here. Default value is an empty array.
    /// </remarks>
    property Events: TArray<TJobOutEvent> read FEvents write FEvents;
    /// <summary>
    /// An array with details of all intermediate checkpoints, including monitoring metrics.
    /// </summary>
    property Checkpoints: TArray<TJobOutCheckpoints> read FCheckpoints write FCheckpoints;
    /// <summary>
    /// Destructor for TJobOutProgress.
    /// </summary>
    /// <remarks>
    /// Frees associated objects.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Asynchronous callback parameters for listing fine-tuning jobs.
  /// </summary>
  TAsynListFineTuningJobs = TAsyncCallBack<TListFineTuningJobs>;

  /// <summary>
  /// Asynchronous callback parameters for fine-tuning job output.
  /// </summary>
  TAsynJobOut = TAsyncCallBack<TJobOut>;

  /// <summary>
  /// Asynchronous callback parameters for fine-tuning job progress.
  /// </summary>
  TAsynJobOutProgress = TAsyncCallBack<TJobOutProgress>;

  /// <summary>
  /// Provides methods to interact with fine-tuning jobs in the MistralAI API.
  /// </summary>
  /// <remarks>
  /// Includes synchronous and asynchronous methods for listing, creating, retrieving, and cancelling fine-tuning jobs.
  /// </remarks>
  TFineTuningRoute = class(TMistralAIAPIRoute)
    /// <summary>
    /// Asynchronously retrieves a list of fine-tuning jobs based on the specified parameters.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure that configures the parameters for the fine-tuning job list.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns the asynchronous callback parameters.
    /// </param>
    procedure AsyncList(ParamProc: TProc<TFineTuningJobListParams>;
      const CallBacks: TFunc<TAsynListFineTuningJobs>);
    /// <summary>
    /// Asynchronously creates and runs a new fine-tuning job.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure that configures the parameters for the fine-tuning job.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns the asynchronous callback parameters.
    /// </param>
    procedure AsyncCreateJob(ParamProc: TProc<TFineTuningJobParams>;
      const CallBacks: TFunc<TAsynJobOut>);
    /// <summary>
    /// Asynchronously retrieves detailed information about a specific fine-tuning job.
    /// </summary>
    /// <param name="Value">
    /// The ID of the job to retrieve.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns the asynchronous callback parameters.
    /// </param>
    procedure ASyncRetrieve(const JobId: string;
      const CallBacks: TFunc<TAsynJobOutProgress>);
    /// <summary>
    /// Asynchronously requests the cancellation of a fine-tuning job.
    /// </summary>
    /// <param name="Value">
    /// The ID of the job to cancel.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns the asynchronous callback parameters.
    /// </param>
    procedure AsyncCancel(const JobId: string;
      const CallBacks: TFunc<TAsynJobOutProgress>);
    /// <summary>
    /// Asynchronously start a fine-tuning job.
    /// </summary>
    /// <param name="Value">
    /// The ID of the job to cancel.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns the asynchronous callback parameters.
    /// </param>
    procedure AsyncStart(const JobId: string;
      const CallBacks: TFunc<TAsynJobOutProgress>);
    /// <summary>
    /// Retrieves a list of fine-tuning jobs based on the specified parameters.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure that configures the parameters for the fine-tuning job list.
    /// </param>
    /// <returns>
    /// A <see cref="TListFineTuningJobs"/> instance containing the list of jobs.
    /// </returns>
    function List(ParamProc: TProc<TFineTuningJobListParams>): TListFineTuningJobs;
    /// <summary>
    /// Creates and runs a new fine-tuning job.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure that configures the parameters for the fine-tuning job.
    /// </param>
    /// <returns>
    /// A <see cref="TJobOut"/> instance containing details about the created job.
    /// </returns>
    /// <remarks>
    /// The job is started immediately after creation.
    /// </remarks>
    function CreateJob(ParamProc: TProc<TFineTuningJobParams>): TJobOut;
    /// <summary>
    /// Retrieves detailed information about a specific fine-tuning job.
    /// </summary>
    /// <param name="Value">
    /// The ID of the job to retrieve.
    /// </param>
    /// <returns>
    /// A <see cref="TJobOutProgress"/> instance containing detailed progress information about the job.
    /// </returns>
    function Retrieve(const JobId: string): TJobOutProgress;
    /// <summary>
    /// Requests the cancellation of a fine-tuning job.
    /// </summary>
    /// <param name="Value">
    /// The ID of the job to cancel.
    /// </param>
    /// <returns>
    /// A <see cref="TJobOutProgress"/> instance reflecting the updated status of the job.
    /// </returns>
    function Cancel(const JobId: string): TJobOutProgress;
    /// <summary>
    /// Start a fine-tuning job.
    /// </summary>
    /// <param name="Value">
    /// The ID of the job to cancel.
    /// </param>
    /// <returns>
    /// A <see cref="TJobOutProgress"/> instance reflecting the updated status of the job.
    /// </returns>
    function Start(const JobId: string): TJobOutProgress;
  end;

implementation

uses
  System.StrUtils, Rest.Json, System.Rtti;

{ TFineTuningJobListParams }

function TFineTuningJobListParams.CreatedAfter(
  const Value: string): TFineTuningJobListParams;
begin
  Result := TFineTuningJobListParams(Add('created_after', Value));
end;

function TFineTuningJobListParams.CreatedByMe(
  const Value: Boolean): TFineTuningJobListParams;
begin
  Result := TFineTuningJobListParams(Add('created_by_me', Value));
end;

function TFineTuningJobListParams.Model(
  const Value: string): TFineTuningJobListParams;
begin
  Result := TFineTuningJobListParams(Add('model', Value));
end;

function TFineTuningJobListParams.Page(const Value: Int64): TFineTuningJobListParams;
begin
  Result := TFineTuningJobListParams(Add('page', Value));
end;

function TFineTuningJobListParams.PageSize(
  const Value: Int64): TFineTuningJobListParams;
begin
  Result := TFineTuningJobListParams(Add('page_size', Value));
end;

function TFineTuningJobListParams.Status(
  const Value: TFineTuningJobStatus): TFineTuningJobListParams;
begin
  Result := TFineTuningJobListParams(Add('status', Value.ToString));
end;

function TFineTuningJobListParams.Suffix(
  const Value: string): TFineTuningJobListParams;
begin
  Result := TFineTuningJobListParams(Add('suffix', Value));
end;

function TFineTuningJobListParams.WandbName(
  const Value: string): TFineTuningJobListParams;
begin
  Result := TFineTuningJobListParams(Add('wandb_name', Value));
end;

function TFineTuningJobListParams.WandbProject(
  const Value: string): TFineTuningJobListParams;
begin
  Result := TFineTuningJobListParams(Add('wandb_project', Value));
end;

{ TJobOut }

destructor TJobOut.Destroy;
begin
  if Assigned(FHyperparameters) then
    FHyperparameters.Free;
  for var Item in FIntegrations do
    Item.Free;
  for var Item in FRepositories do
    Item.Free;
  if Assigned(FMetadata) then
    FMetadata.Free;
  inherited;
end;

{ TFineTuningRoute }

procedure TFineTuningRoute.AsyncCancel(const JobId: string;
  const CallBacks: TFunc<TAsynJobOutProgress>);
begin
  with TAsyncCallBackExec<TAsynJobOutProgress, TJobOutProgress>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TJobOutProgress
      begin
        Result := Cancel(JobId);
      end);
  finally
    Free;
  end;
end;

procedure TFineTuningRoute.AsyncCreateJob(
  ParamProc: TProc<TFineTuningJobParams>;
  const CallBacks: TFunc<TAsynJobOut>);
begin
  with TAsyncCallBackExec<TAsynJobOut, TJobOut>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TJobOut
      begin
        Result := Self.CreateJob(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TFineTuningRoute.AsyncList(ParamProc: TProc<TFineTuningJobListParams>;
  const CallBacks: TFunc<TAsynListFineTuningJobs>);
begin
  with TAsyncCallBackExec<TAsynListFineTuningJobs, TListFineTuningJobs>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TListFineTuningJobs
      begin
        Result := Self.List(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TFineTuningRoute.ASyncRetrieve(const JobId: string;
  const CallBacks: TFunc<TAsynJobOutProgress>);
begin
  with TAsyncCallBackExec<TAsynJobOutProgress, TJobOutProgress>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TJobOutProgress
      begin
        Result := Self.Retrieve(JobId);
      end);
  finally
    Free;
  end;
end;

procedure TFineTuningRoute.AsyncStart(const JobId: string;
  const CallBacks: TFunc<TAsynJobOutProgress>);
begin
  with TAsyncCallBackExec<TAsynJobOutProgress, TJobOutProgress>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TJobOutProgress
      begin
        Result := Self.Start(JobId);
      end);
  finally
    Free;
  end;
end;

function TFineTuningRoute.Cancel(const JobId: string): TJobOutProgress;
begin
  Result := API.Post<TJobOutProgress>(Format('fine_tuning/jobs/%s/cancel', [JobId]), True);
end;

function TFineTuningRoute.CreateJob(
  ParamProc: TProc<TFineTuningJobParams>): TJobOut;
begin
  Result := API.Post<TJobOut, TFineTuningJobParams>('fine_tuning/jobs', ParamProc, True);
end;

function TFineTuningRoute.List(
  ParamProc: TProc<TFineTuningJobListParams>): TListFineTuningJobs;
begin
  Result := API.Get<TListFineTuningJobs, TFineTuningJobListParams>('fine_tuning/jobs', ParamProc, True);
end;

function TFineTuningRoute.Retrieve(const JobId: string): TJobOutProgress;
begin
  Result := API.Get<TJobOutProgress>(Format('fine_tuning/jobs/%s', [JobId]), True);
end;

function TFineTuningRoute.Start(const JobId: string): TJobOutProgress;
begin
  Result := API.Post<TJobOutProgress>(Format('fine_tuning/jobs/%s/start', [JobId]), True);
end;

{ TListFineTuningJobs }

destructor TListFineTuningJobs.Destroy;
begin
  for var Item in Data do
    Item.Free;
  inherited;
end;

{ TFineTuningJobParams }

function TFineTuningJobParams.AutoStart(
  const Value: Boolean): TFineTuningJobParams;
begin
  Result := TFineTuningJobParams(Add('auto_start', Value));
end;

function TFineTuningJobParams.Hyperparameters(
  Value: THyperparametersParams): TFineTuningJobParams;
begin
  Result := TFineTuningJobParams(Add('hyperparameters', Value.Detach));
end;

function TFineTuningJobParams.Hyperparameters(
  ParamProc: TProcRef<THyperparametersParams>): TFineTuningJobParams;
begin
  if Assigned(ParamProc) then
    begin
      var Value := THyperparametersParams.Create;
      ParamProc(Value);
      Result := Hyperparameters(Value);
    end
  else Result := Self;
end;

function TFineTuningJobParams.Integrations(
  const Value: TArray<TJobIntegrationsParams>): TFineTuningJobParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TFineTuningJobParams(Add('integrations', JSONArray));
end;

function TFineTuningJobParams.Model(const Value: string): TFineTuningJobParams;
begin
  Result := TFineTuningJobParams(Add('model', Value));
end;

function TFineTuningJobParams.Repositories(
  const Value: TArray<TRepositoryParams>): TFineTuningJobParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TFineTuningJobParams(Add('repositories', JSONArray));
end;

function TFineTuningJobParams.Suffix(const Value: string): TFineTuningJobParams;
begin
  var S := Trim(Value);
  if Length(S) > 18 then
    raise Exception.CreateFmt('%s : The length of the "suffix" string cannot exceed 18 characters', [S]);
  Result := TFineTuningJobParams(Add('suffix', S));
end;

function TFineTuningJobParams.TrainingFiles(
  const Value: TArray<string>): TFineTuningJobParams;
begin
  Result := TFineTuningJobParams(Add('training_files', Value));
end;

function TFineTuningJobParams.ValidationFiles(
  const Value: TArray<string>): TFineTuningJobParams;
begin
  Result := TFineTuningJobParams(Add('validation_files', Value));
end;

{ TJobOutCheckpoints }

destructor TJobOutCheckpoints.Destroy;
begin
  if Assigned(FMetrics) then
   FMetrics.Free;
  inherited;
end;

{ TJobOutProgress }

destructor TJobOutProgress.Destroy;
begin
  for var Item in FEvents do
    Item.Free;
  for var Item in FCheckpoints do
    Item.Free;
  inherited;
end;

{ TRepositoryParams }

function TRepositoryParams.Name(const Value: string): TRepositoryParams;
begin
  Result := TRepositoryParams(Add('name', Value));
end;

class function TRepositoryParams.New(
  const ParamProc: TProcRef<TRepositoryParams>): TRepositoryParams;
begin
  Result := TRepositoryParams.Create;
  if Assigned(ParamProc) then
    begin
      ParamProc(Result);
    end;
end;

function TRepositoryParams.Owner(const Value: string): TRepositoryParams;
begin
  Result := TRepositoryParams(Add('owner', Value));
end;

function TRepositoryParams.Ref(const Value: string): TRepositoryParams;
begin
  Result := TRepositoryParams(Add('ref', Value));
end;

function TRepositoryParams.Token(const Value: string): TRepositoryParams;
begin
  Result := TRepositoryParams(Add('token', Value));
end;

function TRepositoryParams.&Type(
  const Value: TRepositoryType): TRepositoryParams;
begin
  Result := TRepositoryParams(Add('type', Value.ToString));
end;

function TRepositoryParams.Weight(const Value: Double): TRepositoryParams;
begin
  Result := TRepositoryParams(Add('weight', Value));
end;

{ THyperparametersParams }

function THyperparametersParams.Epochs(
  const Value: Double): THyperparametersParams;
begin
  Result := THyperparametersParams(Add('epochs', Value));
end;

function THyperparametersParams.FimRatio(
  const Value: Double): THyperparametersParams;
begin
  Result := THyperparametersParams(Add('fim_ratio', Value));
end;

function THyperparametersParams.LearningRate(
  const Value: Double): THyperparametersParams;
begin
  Result := THyperparametersParams(Add('learning_rate', Value));
end;

class function THyperparametersParams.New(
  const ParamProc: TProcRef<THyperparametersParams>): THyperparametersParams;
begin
  Result := THyperparametersParams.Create;
  if Assigned(ParamProc) then
    begin
      ParamProc(Result);
    end;
end;

function THyperparametersParams.SeqLen(
  const Value: Integer): THyperparametersParams;
begin
  Result := THyperparametersParams(Add('seq_len', Value));
end;

function THyperparametersParams.TrainingSteps(
  const Value: Integer): THyperparametersParams;
begin
  Result := THyperparametersParams(Add('training_steps', Value));
end;

function THyperparametersParams.WarmupFraction(
  const Value: Double): THyperparametersParams;
begin
  Result := THyperparametersParams(Add('warmup_fraction', Value));
end;

function THyperparametersParams.WeightDecay(
  const Value: Double): THyperparametersParams;
begin
  Result := THyperparametersParams(Add('weight_decay', Value));
end;

{ TJobIntegrationsParams }

function TJobIntegrationsParams.ApiKey(
  const Value: string): TJobIntegrationsParams;
begin
  Result := TJobIntegrationsParams(Add('api_key', Value));
end;

function TJobIntegrationsParams.Name(
  const Value: string): TJobIntegrationsParams;
begin
  Result := TJobIntegrationsParams(Add('name', Value));
end;

class function TJobIntegrationsParams.New(
  const ParamProc: TProcRef<TJobIntegrationsParams>): TJobIntegrationsParams;
begin
  Result := TJobIntegrationsParams.Create;
  if Assigned(ParamProc) then
    begin
      ParamProc(Result);
    end;
end;

function TJobIntegrationsParams.Project(
  const Value: string): TJobIntegrationsParams;
begin
  Result := TJobIntegrationsParams(Add('project', Value));
end;

function TJobIntegrationsParams.RunName(
  const Value: string): TJobIntegrationsParams;
begin
  Result := TJobIntegrationsParams(Add('run_name', Value));
end;

function TJobIntegrationsParams.&Type(
  const Value: TFineTuningIntegrationType): TJobIntegrationsParams;
begin
  Result := TJobIntegrationsParams(Add('type', Value.ToString));
end;

{ TJobOutEvent }

destructor TJobOutEvent.Destroy;
begin
  if Assigned(FData) then
    FData.Free;
  inherited;
end;

end.


unit MistralAI.Functions.Core;

{-------------------------------------------------------------------------------

      Github repository : https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.JSON;

type
  /// <summary>
  /// Interface defining the core structure and functionality of a function in the system.
  /// </summary>
  /// <remarks>
  /// This interface outlines the basic properties and methods that any function implementation must include.
  /// </remarks>
  IFunctionCore = interface
    ['{2D8EA8C5-1E60-481D-B95F-2EFFE2CF6A7D}']
    /// <summary>
    /// Retrieves the description of the function.
    /// </summary>
    function GetDescription: string;
    /// <summary>
    /// Retrieves the name of the function.
    /// </summary>
    function GetName: string;
    /// <summary>
    /// Retrieves the parameters required by the function, represented as a JSON schema.
    /// </summary>
    function GetParameters: string;
    /// <summary>
    /// Retrieves the type of the function, typically "function".
    /// </summary>
    function GetType: string;
    /// <summary>
    /// Executes the function with the provided arguments and returns the result as a string.
    /// </summary>
    /// <param name="Arguments">The arguments passed to the function in JSON format.</param>
    /// <returns>The result of the function execution as a string.</returns>
    function Execute(const Arguments: string): string;
     /// <summary>
    /// Converts the TFunctionCore instance to a JSON object that contains its type and representation.
    /// </summary>
    /// <returns>A JSON object representing the function instance.</returns>
    function ToJson: TJSONObject;
    /// <summary>
    /// Creates a string representation of the TFunctionCore instance in JSON format, including its description, name, and parameters.
    /// </summary>
    /// <returns>A string representation of the function in JSON format.</returns>
    function ToString: string;
    /// <summary>
    /// A brief description of the function's purpose, used by the model to determine when and how to call the function.
    /// </summary>
    property Description: string read GetDescription;
    /// <summary>
    /// The unique identifier of the function that will be called. It must only contain characters from a-z, A-Z, 0-9, underscores, or dashes, and should not exceed 64 characters in length.
    /// </summary>
    property Name: string read GetName;
    //// <summary>
    /// The parameters required by the function, specified as a JSON schema. If no parameters are required, use the schema: {"type": "object", "properties": {}}.
    /// </summary>
    property Parameters: string read GetParameters;
    /// <summary>
    /// The type of the tool. Currently, only "function" is supported.
    /// </summary>
    property &Type: string read GetType;
  end;

  /// <summary>
  /// Abstract base class for implementing core function behavior.
  /// </summary>
  /// <remarks>
  /// This class provides basic implementations for some methods and defines the structure that derived classes must follow.
  /// </remarks>
  TFunctionCore = class abstract(TinterfacedObject, IFunctionCore)
  protected
    /// <summary>
    /// Retrieves the description of the function. Derived classes must implement this method.
    /// </summary>
    function GetDescription: string; virtual; abstract;
     /// <summary>
    /// Retrieves the name of the function. Derived classes must implement this method.
    /// </summary>
    function GetName: string; virtual; abstract;
    /// <summary>
    /// Retrieves the parameters required by the function, represented as a JSON schema. Derived classes must implement this method.
    /// </summary>
    function GetParameters: string; virtual; abstract;
    /// <summary>
    /// Retrieves the type of the function, which is "function" by default.
    /// </summary>
    function GetType: string; virtual;
  public
    /// <summary>
    /// Executes the function with the provided arguments and returns the result as a string. Derived classes must implement this method.
    /// </summary>
    /// <param name="Arguments">The arguments passed to the function in JSON format.</param>
    /// <returns>The result of the function execution as a string.</returns>
    function Execute(const Arguments: string): string; virtual; abstract;
    /// <summary>
    /// Converts the TFunctionCore instance to a JSON object that contains its type and representation.
    /// </summary>
    /// <returns>A JSON object representing the function instance.</returns>
    function ToJson: TJSONObject;
    /// <summary>
    /// Creates a string representation of the TFunctionCore instance in JSON format, including its description, name, and parameters.
    /// </summary>
    /// <returns>A string representation of the function in JSON format.</returns>
    function ToString: string; override;
    /// <summary>
    /// A brief description of the function's purpose, used by the model to determine when and how to call the function.
    /// </summary>
    property Description: string read GetDescription;
    /// <summary>
    /// The unique identifier of the function that will be called. It must only contain characters from a-z, A-Z, 0-9, underscores, or dashes, and should not exceed 64 characters in length.
    /// </summary>
    property Name: string read GetName;
    /// <summary>
    /// The parameters required by the function, specified as a JSON schema. If no parameters are required, use the schema: {"type": "object", "properties": {}}.
    /// </summary>
    property Parameters: string read GetParameters;
    /// <summary>
    /// The type of the tool. Currently, only "function" is supported.
    /// </summary>
    property &Type: string read GetType;
  end;

implementation

{ TFunctionCore }

function TFunctionCore.GetType: string;
begin
  Result := 'function';
end;

function TFunctionCore.ToJson: TJSONObject;
begin
  Result := TJSONObject.Create;
  try
    Result.AddPair('type', &Type);
    Result.AddPair('function', TJSONObject.ParseJSONValue(ToString));
  except
    on E: Exception do
      begin
        Result.Free;
        raise;
      end;
  end;
end;

function TFunctionCore.ToString: string;
begin
  with TStringWriter.Create do
    try
      Write('"description": "%s",', [Description]);
      Write('"name": "%s",', [Name]);
      Write('"parameters": %s', [Parameters]);
      Result := Format('{%s}', [ToString]);
    finally
      Free;
    end;
end;

end.

unit MistralAI.Functions.Example;

{-------------------------------------------------------------------------------

      Github repository : https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, MistralAI.Functions.Core, MistralAI.Schema;

type
  TWeatherReportFunction = class(TFunctionCore)
  protected
    function GetDescription: string; override;
    function GetName: string; override;
    function GetParameters: string; override;
  public
    function Execute(const Arguments: string): string; override;
    class function CreateInstance: IFunctionCore;
  end;

implementation

uses
  System.StrUtils, System.JSON;

{ TWeatherReportFunction }

class function TWeatherReportFunction.CreateInstance: IFunctionCore;
begin
  Result := TWeatherReportFunction.create;
end;

function TWeatherReportFunction.Execute(const Arguments: string): string;

  procedure AddToReport(const Value: TJSONObject;
    Temperature: Integer; Forecast: TArray<string>);
  begin
    Value.AddPair('temperature', TJSONNumber.Create(Temperature));
    Value.AddPair('forecast', TJSONArray.Create(Forecast[0], Forecast[1]));
  end;

begin
  Result := EmptyStr;
  var Location := EmptyStr;
  var UnitType := EmptyStr;

  {--- Parse arguments to retrieve parameters }
  var JSON := TJSONObject.ParseJSONValue(Arguments) as TJSONObject;
  try
    if Assigned(JSON) then
    try
      Location := JSON.GetValue('location', '');
      UnitType := JSON.GetValue('unit', '');
    finally
      JSON.Free;
    end;
  except
    Location := EmptyStr;
  end;

  {--- Stop the treatment if location is empty }
  if Location.IsEmpty then
    Exit;

  {--- Build the response }
  JSON := TJSONObject.Create;
  try
    JSON.AddPair('location', Location);
    JSON.AddPair('unit', UnitType);
    case IndexStr(AnsiLowerCase(Location), [
      'paris', 'paris, 75',
      'marseille', 'marseille, 13']) of
      0,1 :
        AddToReport(JSON, 14, ['rainy', 'low visibility']);

      2,3 :
        AddToReport(JSON, 29, ['sunny', 'windy']);
    end;
    Result := JSON.ToJSON;
  finally
    JSON.Free;
  end;
end; {Execute}

function TWeatherReportFunction.GetDescription: string;
begin
  Result := 'Get the current weather in a given location.';
end;

function TWeatherReportFunction.GetName: string;
begin
  Result := 'get_weather';
end;

function TWeatherReportFunction.GetParameters: string;
begin
//  Result :=
//    '{'+
//    '"type": "object",'+
//    '"properties": {'+
//         '"location": {'+
//             '"type": "string",'+
//             '"description": "The city and department, e.g. Marseille, 13"'+
//         '},'+
//         '"unit": {'+
//             '"type": "string",'+
//             '"enum": ["celsius", "fahrenheit"]'+
//         '}'+
//     '},'+
//     '"required": ["location"]'+
//  '}';

  {--- If we use the TSchemaParams class defined in the MistralAI.Schema.pas unit }
  var Schema := TSchemaParams.New(
    procedure (var Params: TSchemaParams)
    begin
      Params.&Type(stOBJECT);
      Params.Properties('properties',
        procedure (var Params: TSchemaParams)
        begin
          Params.Properties('location',
            procedure (var Params: TSchemaParams)
            begin
              Params.&Type(stSTRING);
              Params.Description('The city and state, e.g. San Francisco, CA');
            end);
          Params.Properties('unit',
            procedure (var Params: TSchemaParams)
            begin
              Params.&Type(stSTRING);
              Params.Enum(['celsius', 'fahrenheit']);
            end);
        end);
      Params.Required(['location', 'unit']);
    end);
  Result := Schema.ToJsonString(True);
end;

end.

unit MistralAI.Functions.Tools;

{-------------------------------------------------------------------------------

      Github repository : https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, REST.Json.Types,
  MistralAI.Functions.Core, MistralAI.Types;

type
  /// <summary>
  /// Represents a tool used for interacting with chat messages, including the ability to convert
  /// functions to JSON format.
  /// </summary>
  TChatMessageTool = record
  private
    FFunction: IFunctionCore;
  public
    /// <summary>
    /// This method converts the TFunctionCore instance to a JSON object containing the type and
    /// representation of the function, and handles exceptions by deleting the JSON object and
    /// propagating the exception if an error occurs
    /// </summary>
    /// <returns>
    /// A <c>TJSONObject</c> representing the function in JSON format.
    /// </returns>
    function ToJson: TJSONObject;
    /// <summary>
    /// The function properties
    /// </summary>
    property &Function: IFunctionCore read FFunction write FFunction;
    /// <summary>
    /// Adds a function to the chat message tool.
    /// </summary>
    /// <param name="AFunction">
    /// The function to be added.
    /// </param>
    /// <returns>
    /// An instance of <c>TChatMessageTool</c> containing the specified function.
    /// </returns>
    class function Add(const AFunction: IFunctionCore): TChatMessageTool; static;
  end;

  /// <summary>
  /// Represents the specifics of a called function, including its name and calculated arguments.
  /// </summary>
  TCalledFunctionSpecifics = class
  private
    FName: string;
    FArguments: string;
  public
    /// <summary>
    /// Gets or sets the name of the called function
    /// </summary>
    property Name: string read FName write FName;
    /// <summary>
    /// Gets or sets the calculed Arguments for the called function
    /// </summary>
    property Arguments: string read FArguments write FArguments;
  end;

  /// <summary>
  /// Represents a called function, containing its specifics such as name and arguments.
  /// </summary>
  TCalledFunction = class
  private
    FId: string;
    FType: string;
    FFunction: TCalledFunctionSpecifics;
  public
    /// <summary>
    /// Gets or sets the id of the called function
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Gets or sets the type of the called function
    /// </summary>
    property &Type: string read FType write FType;
    /// <summary>
    /// Gets or sets the specifics of the called function
    /// </summary>
    property &Function: TCalledFunctionSpecifics read FFunction write FFunction;
    /// <summary>
    /// Destructor that ensures proper memory management by freeing the <c>FFunction</c> property
    /// when the <c>TCalledFunction</c> instance is destroyed.
    /// </summary>
    destructor Destroy; override;
  end;

implementation

{ TChatMessageTool }

class function TChatMessageTool.Add(
  const AFunction: IFunctionCore): TChatMessageTool;
begin
  Result.&Function := AFunction;
end;

function TChatMessageTool.ToJson: TJSONObject;
begin
  Result := FFunction.ToJson;
end;

{ TCalledFunction }

destructor TCalledFunction.Destroy;
begin
  if Assigned(FFunction) then
    FFunction.Free;
  inherited;
end;

end.

unit MistralAI.Models;

{-------------------------------------------------------------------------------

      Github repository : https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Threading, REST.Json.Types,
  MistralAI.API.Params, MistralAI.API, MistralAI.Async.Support;

type
  /// <summary>
  /// The TModelParams class is used to specify parameters for updating the properties
  /// of a fine-tuned model in the MistralAI environment. It allows you to set new values
  /// for the model's name and  description.
  /// </summary>
  /// <remarks>
  /// This class provides a fluent interface for configuring model parameters before
  /// submitting an update request. The Name and Description methods allow you to set
  /// these attributes individually and return the updated TModelParams object, enabling
  /// method chaining for concise configuration.
  /// </remarks>
  TModelParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets a new name for the fine-tuned model.
    /// </summary>
    /// <param name="Value">The new name to assign to the model.</param>
    /// <returns>Returns the updated TModelParams object.</returns>
    /// <remarks>
    /// The name specified here should be a human-readable identifier for the model.
    /// It is not to be confused with the model's unique ID, which remains constant
    /// and is used for API operations. Changing the name only affects the metadata
    /// of the model.
    /// </remarks>
    function Name(const Value: string): TModelParams;
    /// <summary>
    /// Sets a new description for the fine-tuned model.
    /// </summary>
    /// <param name="Value">The new description to assign to the model.</param>
    /// <returns>Returns the updated TModelParams object.</returns>
    /// <remarks>
    /// Use this method to provide a detailed explanation of the model's purpose,
    /// capabilities, or any other relevant information. This description is useful
    /// for documentation purposes and for understanding the context in which the
    /// model is intended to be used.
    /// </remarks>
    function Description(const Value: string): TModelParams;
  end;

  /// <summary>
  /// The TCapabilities class represents the various features and functionalities
  /// that a MistralAI model can support. It indicates whether the model is capable of
  /// performing specific tasks such as chat completion, function calling, or fine-tuning.
  /// </summary>
  /// <remarks>
  /// This class is used to describe the capabilities of a model, helping users
  /// to understand what operations can be performed with the model. Each property
  /// corresponds to a specific capability, which can be checked to see if the model
  /// supports that feature. This information is typically used when selecting or
  /// configuring models for specific use cases.
  /// </remarks>
  TCapabilities = class
  private
    [JsonNameAttribute('completion_chat')]
    FCompletionChat: Boolean;
    [JsonNameAttribute('completion_fim')]
    FCompletionFim: Boolean;
    [JsonNameAttribute('function_calling')]
    FFunctionCalling: Boolean;
    [JsonNameAttribute('fine_tuning')]
    FFineTuning: Boolean;
    FVision: Boolean;
  public
    /// <summary>
    /// Indicates whether the model supports chat-based completions.
    /// </summary>
    /// <remarks>
    /// If True, the model can be used in applications that involve conversational
    /// agents or chatbots. This capability is crucial for creating interactive
    /// dialogue systems and enhancing user engagement through natural language
    /// interactions.
    /// </remarks>
    property CompletionChat: Boolean read FCompletionChat write FCompletionChat;
    /// <summary>
    /// Indicates whether the model supports "Fill-in-the-Middle" (FIM) completions.
    /// </summary>
    /// <remarks>
    /// FIM capabilities enable the model to generate text by filling in the blanks
    /// within a given context, which is useful for advanced text editing, code
    /// completion, and other scenarios where context-aware suggestions are needed.
    /// </remarks>
    property CompletionFim: Boolean read FCompletionFim write FCompletionFim;
    /// <summary>
    /// Indicates whether the model supports function calling.
    /// </summary>
    /// <remarks>
    /// If True, the model can trigger and call predefined functions based on
    /// the input it receives. This feature is particularly useful for building
    /// applications that require integration with external services or dynamic
    /// behaviors triggered by user input.
    /// </remarks>
    property FunctionCalling: Boolean read FFunctionCalling write FFunctionCalling;
    /// <summary>
    /// Indicates whether the model supports fine-tuning.
    /// </summary>
    /// <remarks>
    /// Fine-tuning allows the model to be further trained on specific datasets to
    /// improve its performance in specialized tasks. This capability is essential
    /// for customizing the model to better suit particular applications or domains.
    /// </remarks>
    property FineTuning: Boolean read FFineTuning write FFineTuning;
    /// <summary>
    /// Indicates whether the model supports vision.
    /// </summary>
    property Vision: Boolean read FVision write FVision;
  end;

  /// <summary>
  /// The TCoreModel class represents a generic model object that can be used with the MistralAI API.
  /// It contains all the essential properties and metadata required to describe a model, including
  /// its identifier, creation date, capabilities, and other attributes.
  /// </summary>
  /// <remarks>
  /// This class serves as the base class for more specific model types and provides a comprehensive
  /// view of a model's characteristics. The properties in this class are primarily used for
  /// interacting with the MistralAI API and retrieving model metadata. It is designed to be
  /// extended by other classes that represent more specialized model types.
  /// </remarks>
  TCoreModel = class
  private
    FId: string;
    FObject: string;
    FCreated: Int64;
    [JsonNameAttribute('owned_by')]
    FOwnedBy: string;
    FCapabilities: TCapabilities;
    FName: string;
    FDescription: string;
    [JsonNameAttribute('max_context_length')]
    FMaxContextLength: Int64;
    FAliases: TArray<string>;
  public
    /// <summary>
    /// The unique identifier of the model, used to reference the model in API operations.
    /// </summary>
    /// <remarks>
    /// This ID is a unique string that remains constant throughout the model's lifecycle.
    /// It is used to identify the model in API calls such as retrieving details or performing
    /// actions like updating or deleting the model.
    /// </remarks>
    property Id: string read FId write FId;
    /// <summary>
    /// The type of the object, which is always set to "model" for model instances.
    /// </summary>
    /// <remarks>
    /// This property indicates the type of object being represented. It is used internally
    /// by the API to differentiate between different types of entities.
    /// </remarks>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// The Unix timestamp (in seconds) representing when the model was created.
    /// </summary>
    /// <remarks>
    /// This timestamp is useful for tracking the model's age and for auditing purposes.
    /// It can be used to determine when the model was first made available in the MistralAI
    /// environment.
    /// </remarks>
    property Created: Int64 read FCreated write FCreated;
    /// <summary>
    /// The owner of the model, typically represented as a user or organization.
    /// </summary>
    /// <remarks>
    /// This property shows who has ownership of the model. Ownership can affect
    /// permissions and accessibility, especially in shared environments.
    /// </remarks>
    property OwnedBy: string read FOwnedBy write FOwnedBy;
    /// <summary>
    /// Represents the capabilities of the model, such as whether it supports fine-tuning or chat-based completion.
    /// </summary>
    /// <remarks>
    /// The capabilities provide a quick overview of what the model can do. Each capability is
    /// represented as a boolean value, indicating whether the model supports that feature. This
    /// information is essential for determining the suitability of the model for specific tasks.
    /// </remarks>
    property Capabilities: TCapabilities read FCapabilities write FCapabilities;
    /// <summary>
    /// The name of the model, which is used for display and identification purposes.
    /// </summary>
    /// <remarks>
    /// The name is a human-readable string that helps to identify the model. It is not
    /// unique and can be modified as needed without affecting the model's functionality.
    /// </remarks>
    property Name: string read FName write FName;
    /// <summary>
    /// A detailed description of the model, providing information about its purpose, capabilities, and other relevant details.
    /// </summary>
    /// <remarks>
    /// The description helps users understand what the model is designed to do, its intended
    /// use cases, and any special characteristics. It is especially useful for documentation
    /// and communication within teams.
    /// </remarks>
    property Description: string read FDescription write FDescription;
    /// <summary>
    /// The maximum context length that the model can handle.
    /// </summary>
    /// <remarks>
    /// This value represents the maximum number of tokens or characters that the model can process
    /// in a single request. It is an important parameter to consider when working with large inputs,
    /// as exceeding this limit may result in truncated responses or errors.
    /// </remarks>
    property MaxContextLength: Int64 read FMaxContextLength write FMaxContextLength;
    /// <summary>
    /// An array of alternative names or aliases for the model.
    /// </summary>
    /// <remarks>
    /// Aliases provide additional identifiers for the model, which can be useful in scenarios
    /// where multiple names are used to reference the same model. This property helps in
    /// maintaining consistency and flexibility in model references.
    /// </remarks>
    property Aliases: TArray<string> read FAliases write FAliases;
    /// <summary>
    /// Destructor to clean up allocated resources.
    /// </summary>
    /// <remarks>
    /// This destructor ensures that all dynamically allocated objects and resources associated
    /// with the TCoreModel instance are properly released, preventing memory leaks.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// The TModel class extends TCoreModel to include additional information about
  /// the model's deprecation status. It inherits all the properties of TCoreModel
  /// and adds a field to track when the model is considered deprecated.
  /// </summary>
  /// <remarks>
  /// This class is used to represent models that are still available in the MistralAI environment
  /// but are marked as deprecated. Deprecation indicates that the model may no longer be supported
  /// in future versions, and users are encouraged to migrate to newer models if possible.
  /// This class is particularly useful for managing model lifecycles and ensuring that applications
  /// do not rely on outdated or unsupported models.
  /// </remarks>
  TModel = class(TCoreModel)
  private
    [JsonNameAttribute('deprecation')]
    FDeprecation: string;
    [JsonNameAttribute('default_model_temperature')]
    FDefaultModelTemperature: Double;
    FType: string;
  public
    /// <summary>
    /// Indicates the deprecation date of the model as a string.
    /// </summary>
    /// <remarks>
    /// This property provides the date or version at which the model was deprecated.
    /// Deprecation means that the model is no longer recommended for use and may be
    /// removed or become unsupported in the future. Applications using deprecated
    /// models should plan to transition to updated models to maintain compatibility
    /// and support.
    /// </remarks>
    property Deprecation: string read FDeprecation write FDeprecation;
    /// <summary>
    /// Value of the default temperature for the model.
    /// </summary>
    property DefaultModelTemperature: Double read FDefaultModelTemperature write FDefaultModelTemperature;
    /// <summary>
    /// Type of model, Enum: base, fine-tuned
    /// </summary>
    /// <remarks>
    /// base is the default value
    /// </remarks>
    property &Type: string read FType write FType;
  end;

  /// <summary>
  /// The TFineTunedModel class extends the TCoreModel class to represent a fine-tuned model
  /// within the MistralAI environment. It includes additional information specific to the
  /// fine-tuning process, such as the job identifier associated with the fine-tuning operation.
  /// </summary>
  /// <remarks>
  /// This class is used to manage and interact with fine-tuned models, which are variants of
  /// base models that have been further trained on specific datasets to improve performance
  /// in specialized tasks. It inherits all properties from TCoreModel and adds specific
  /// attributes related to the fine-tuning process.
  /// </remarks>
  TFineTunedModel = class(TCoreModel)
  private
    FRoot: string;
    [JsonNameAttribute('job')]
    FJob: string;
    FArchived: Boolean;
  public
    /// <summary>
    /// Model uses for fine-tuning
    /// </summary>
    property Root: string read FRoot write FRoot;
    /// <summary>
    /// The identifier of the job associated with the fine-tuning process.
    /// </summary>
    /// <remarks>
    /// The Job property represents the ID of the fine-tuning task that created or modified
    /// the model. This ID can be used to track the details of the fine-tuning operation,
    /// such as the dataset used, training parameters, and performance metrics. It is
    /// particularly useful for auditing purposes and for understanding the history of the model.
    /// </remarks>
    property Job: string read FJob write FJob;
    /// <summary>
    /// Return True when the model is archived.
    /// </summary>
    property Archived: Boolean read FArchived write FArchived;
  end;

  /// <summary>
  /// The TModels class represents a collection of available models in the MistralAI environment.
  /// It provides basic information about each model, including the owner and availability,
  /// allowing users to list and inspect the models they have access to.
  /// </summary>
  /// <remarks>
  /// This class serves as a container for multiple `TModel` instances, each representing
  /// a different model. It is primarily used to retrieve a comprehensive list of models
  /// from the MistralAI API, and it can be helpful for applications that need to display
  /// or manage multiple models at once.
  /// </remarks>
  TModels = class
  private
    [JsonNameAttribute('object')]
    FObject: string;
    [JsonNameAttribute('data')]
    FData: TArray<TModel>;
  public
    /// <summary>
    /// The type of the object, typically "list" for collections.
    /// </summary>
    /// <remarks>
    /// This property indicates the type of the object represented by the class instance.
    /// For collections like `TModels`, it is usually set to "list", signifying that the
    /// object contains a list of other objects, in this case, models.
    /// </remarks>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// An array of `TModel` objects, each representing an individual model.
    /// </summary>
    /// <remarks>
    /// This property contains the data returned by the API, which is a list of models
    /// that are currently available. Each model in the array provides detailed information
    /// about its properties, capabilities, and ownership. This property is essential for
    /// accessing the complete set of models in a structured format.
    /// </remarks>
    property Data: TArray<TModel> read FData write FData;
    /// <summary>
    /// Destructor to clean up allocated resources.
    /// </summary>
    /// <remarks>
    /// This destructor ensures that all dynamically allocated objects and resources associated
    /// with the `TModels` instance are properly released, preventing memory leaks.
    /// It also frees each `TModel` object contained in the `Data` array.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// The TModelDeletion class manages the data returned after the successful deletion
  /// of a fine-tuned model in the MistralAI environment. It contains information
  /// about the model that was deleted, such as its ID and deletion status.
  /// </summary>
  /// <remarks>
  /// This class is used to capture the result of a model deletion request.
  /// It provides confirmation that the specified model has been successfully deleted
  /// from the system. This information is important for auditing and tracking purposes,
  /// especially in environments where model management and lifecycle tracking are critical.
  /// </remarks>
  TModelDeletion = class
  private
    FId: string;
    FObject: string;
    FDeleted: Boolean;
  public
    /// <summary>
    /// The ID of the fine-tuned model that was deleted.
    /// </summary>
    /// <remarks>
    /// This ID uniquely identifies the model that was removed from the system.
    /// It can be used to verify which model was deleted, particularly when managing
    /// multiple models or when logging deletion activities for compliance purposes.
    /// </remarks>
    property Id: string read FId write FId;
    /// <summary>
    /// The type of the object that was deleted, which is always "model" for model deletions.
    /// </summary>
    /// <remarks>
    /// This property confirms that the deleted object was a model. It is used internally
    /// by the API to verify the type of entity that was removed, ensuring that the correct
    /// object type was deleted.
    /// </remarks>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// Indicates whether the model was successfully deleted.
    /// </summary>
    /// <remarks>
    /// If True, the model has been successfully deleted from the MistralAI environment.
    /// This flag serves as confirmation that the deletion operation completed without
    /// errors, and the model is no longer available in the system.
    /// </remarks>
    property Deleted: Boolean read FDeleted write FDeleted;
  end;

  /// <summary>
  /// The TArchivingModel class represents the state of a fine-tuned model in terms of its
  /// archiving status. It is used to track whether a model has been archived or unarchived
  /// within the MistralAI environment.
  /// </summary>
  /// <remarks>
  /// This class is primarily used for operations that involve archiving or unarchiving models.
  /// Archiving a model makes it inactive, while unarchiving restores it to an active state.
  /// The class provides properties to check the current state and to identify the model being
  /// affected.
  /// </remarks>
  TArchivingModel = class
  private
    FId: string;
    FObject: string;
    FArchived: Boolean;
  public
    /// <summary>
    /// The unique identifier of the fine-tuned model to be archived or unarchived.
    /// </summary>
    /// <remarks>
    /// This ID is used to reference the model in archiving operations. It is essential
    /// for identifying the specific model whose state is being changed. Ensure that the
    /// correct ID is provided when performing archiving or unarchiving actions to avoid
    /// unintentional changes to other models.
    /// </remarks>
    property Id: string read FId write FId;
    /// <summary>
    /// The type of the object, which is always set to "model" for models being archived or unarchived.
    /// </summary>
    /// <remarks>
    /// This property indicates the type of the entity involved in the operation. For all models,
    /// this value will be "model", confirming that the object being archived or unarchived is indeed
    /// a model and not another type of entity.
    /// </remarks>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// Indicates whether the model is currently archived.
    /// </summary>
    /// <remarks>
    /// If True, the model is archived and not available for use. If False, the model is active and
    /// can be used normally. This property helps in tracking the current state of the model and is
    /// particularly useful for managing large sets of models where some may be inactive.
    /// </remarks>
    property Archived: Boolean read FArchived write FArchived;
  end;

  /// <summary>
  /// Represents an asynchronous callback parameter for retrieving a list of models.
  /// </summary>
  /// <remarks>
  /// This type is used when performing asynchronous operations to list models in the
  /// MistralAI environment. It enables the handling of the response containing a collection
  /// of models through a callback mechanism, facilitating non-blocking data retrieval.
  /// </remarks>
  TAsynModels = TAsyncCallBack<TModels>;

  /// <summary>
  /// Represents an asynchronous callback parameter for model deletion operations.
  /// </summary>
  /// <remarks>
  /// This type is used when performing asynchronous delete operations on a model. It
  /// allows the handling of the response which indicates the status of the deletion request.
  /// This type is essential for managing deletion results in a non-blocking manner, enabling
  /// efficient UI updates or further processing based on the deletion status.
  /// </remarks>
  TAsynModelDeletion = TAsyncCallBack<TModelDeletion>;

  /// <summary>
  /// Represents an asynchronous callback parameter for retrieving details of a specific model.
  /// </summary>
  /// <remarks>
  /// This type is used when performing asynchronous operations to fetch detailed information
  /// about a specific model. It allows for handling the response containing the model's metadata
  /// and capabilities in a non-blocking fashion. This is particularly useful for updating UI elements
  /// or triggering additional actions based on the model's properties.
  /// </remarks>
  TAsynModel = TAsyncCallBack<TModel>;

  /// <summary>
  /// Represents an asynchronous callback parameter for updating a fine-tuned model.
  /// </summary>
  /// <remarks>
  /// This type is used during asynchronous update operations on fine-tuned models. It enables
  /// handling the response, which contains the updated model details, through a callback mechanism.
  /// This is useful for reflecting changes in the user interface or performing further processing
  /// based on the updated model information.
  /// </remarks>
  TAsynFineTuneModel = TAsyncCallBack<TFineTunedModel>;

  /// <summary>
  /// Represents an asynchronous callback parameter for archiving or unarchiving a model.
  /// </summary>
  /// <remarks>
  /// This type is used when performing asynchronous archiving or unarchiving operations on a model.
  /// It allows handling the response, which indicates the status of the operation, in a non-blocking manner.
  /// This type is essential for updating the state of the model in the application without blocking the main thread.
  /// </remarks>
  TAsynArchivingModel = TAsyncCallBack<TArchivingModel>;

  /// <summary>
  /// The TModelsRoute class provides various methods for managing Large Language Models (LLMs)
  /// through MistralAI's API. It offers both synchronous and asynchronous methods to list, retrieve,
  /// delete, update, archive, and un-archive models.
  /// </summary>
  /// <remarks>
  /// This class is designed to interact with the MistralAI API to facilitate management operations
  /// on models. It supports fine-tuning models as well as handling models' metadata and status.
  /// Each method provides detailed interaction with the API, ensuring efficient model management.
  /// </remarks>
  TModelsRoute = class(TMistralAIAPIRoute)
  public
    /// <summary>
    /// Asynchronously lists the currently available models.
    /// </summary>
    /// <param name="CallBacks">A callback function that receives the list of models asynchronously.</param>
    /// <remarks>
    /// Use this method to get a list of all models available in the MistralAI environment.
    /// This is useful for obtaining an overview of the models you have access to.
    ///
    /// <code>
    ///  MistralAI.Models.AsyncList(
    ///     function : TAsynModels
    ///     begin
    ///       Result.OnSuccess :=
    ///         procedure (Sender: TObject; List: TModels)
    ///         begin
    ///           // Handle List
    ///         end
    ///     end);
    /// </code>
    /// </remarks>
    procedure AsyncList(const CallBacks: TFunc<TAsynModels>);
    /// <summary>
    /// Asynchronously deletes a fine-tuned model.
    /// </summary>
    /// <param name="ModelId">The ID of the fine-tuned model to be deleted.</param>
    /// <param name="CallBacks">A callback function that receives the deletion status asynchronously.</param>
    /// <remarks>
    /// Deleting a model is a permanent action. Use this method with caution, as it will remove
    /// the model and its metadata from the MistralAI environment.
    ///
    /// <code>
    ///  MistralAI.Models.AsyncDelete( ModelId,
    ///     function : TAsynModelDeletion
    ///     begin
    ///       Result.OnSuccess :=
    ///         procedure (Sender: TObject; Model: TModels)
    ///         begin
    ///           //Handle success
    ///         end
    ///     end);
    /// </code>
    /// </remarks>
    procedure AsyncDelete(const ModelId: string; const CallBacks: TFunc<TAsynModelDeletion>);
    /// <summary>
    /// Asynchronously retrieves the details of a model.
    /// </summary>
    /// <param name="ModelId">The ID of the model to be retrieved.</param>
    /// <param name="CallBacks">A callback function that receives the model details asynchronously.</param>
    /// <remarks>
    /// This method is useful for fetching detailed information about a specific model,
    /// including its metadata, capabilities, and current status.
    ///
    /// <code>
    ///  MistralAI.Models.AsyncRetrieve( ModelId,
    ///     function : TAsynModel
    ///     begin
    ///       Result.OnSuccess :=
    ///         procedure (Sender: TObject; Model: TModel)
    ///         begin
    ///           //Handle success
    ///         end
    ///     end);
    /// </code>
    /// </remarks>
    procedure AsyncRetrieve(const ModelId: string; const CallBacks: TFunc<TAsynModel>);
    /// <summary>
    /// Asynchronously updates the details of a fine-tuned model.
    /// </summary>
    /// <param name="ModelId">The ID of the fine-tuned model to be updated.</param>
    /// <param name="ParamProc">A procedure that specifies the parameters to be updated.</param>
    /// <param name="CallBacks">A callback function that receives the updated model details asynchronously.</param>
    /// <remarks>
    /// Use this method to change the name or description of a fine-tuned model. Ensure that the
    /// provided parameters are valid, as incorrect data might result in unexpected behavior.
    ///
    /// <code>
    ///  MistralAI.Models.AsyncUpdate( ModelId,
    ///     procedure (Params: TModelParams)
    ///     begin
    ///       // Define updating params
    ///     end,
    ///     function : TAsynFineTuneModel
    ///     begin
    ///       Result.OnSuccess :=
    ///         procedure (Sender: TObject; Model: TFineTunedModel)
    ///         begin
    ///           //Handle success
    ///         end
    ///     end);
    /// </code>
    /// </remarks>
    procedure AsyncUpdate(const ModelId: string; ParamProc: TProc<TModelParams>;
      const CallBacks: TFunc<TAsynFineTuneModel>);
    /// <summary>
    /// Asynchronously archives a fine-tuned model.
    /// </summary>
    /// <param name="ModelId">The ID of the fine-tuned model to be archived.</param>
    /// <param name="CallBacks">A callback function that receives the archiving status asynchronously.</param>
    /// <remarks>
    /// Archiving a model will make it unavailable for use. This is typically used to manage
    /// storage or to keep the model's state intact while it is not actively in use.
    ///
    /// <code>
    ///  MistralAI.Models.AsyncArchive( ModelId,
    ///     function : TAsynArchivingModel
    ///     begin
    ///       Result.OnSuccess :=
    ///         procedure (Sender: TObject; Model: TArchivingModel)
    ///         begin
    ///           //Handle success
    ///         end
    ///     end);
    /// </code>
    /// </remarks>
    procedure AsyncArchive(const ModelId: string; const CallBacks: TFunc<TAsynArchivingModel>);
    /// <summary>
    /// Asynchronously un-archives a fine-tuned model.
    /// </summary>
    /// <param name="ModelId">The ID of the fine-tuned model to be un-archived.</param>
    /// <param name="CallBacks">A callback function that receives the un-archiving status asynchronously.</param>
    /// <remarks>
    /// Un-archiving a model will restore it to an active state, making it available for use again.
    /// This is typically used for bringing back models that were previously archived.
    ///
    ///  <code>
    ///  MistralAI.Models.AsyncUnarchive( ModelId,
    ///     function : TAsynArchivingModel
    ///     begin
    ///       Result.OnSuccess :=
    ///         procedure (Sender: TObject; Model: TArchivingModel)
    ///         begin
    ///           //Handle success
    ///         end
    ///     end);
    /// </code>
    /// </remarks>
    procedure AsyncUnarchive(const ModelId: string; const CallBacks: TFunc<TAsynArchivingModel>);
    /// <summary>
    /// Lists the currently available models.
    /// </summary>
    /// <returns>Returns a list of currently available models.</returns>
    /// <remarks>
    /// This method provides a synchronous way to fetch all models in the MistralAI environment.
    /// It is useful for applications where synchronous data access is required.
    /// <code>
    ///   var Models := MistralAI.Models.List;
    ///   try
    ///     // List processing
    ///   finally
    ///     Models.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function List: TModels;
    /// <summary>
    /// Deletes a fine-tuned model.
    /// </summary>
    /// <param name="ModelId">The ID of the fine-tuned model to be deleted.</param>
    /// <returns>Returns the deletion status of the model.</returns>
    /// <remarks>
    /// Deleting a fine-tuned model removes it permanently from the MistralAI environment.
    /// This action cannot be undone, so use it with caution.
    /// <code>
    ///   with MistralAI.Models.Delete('ModelId');
    ///   try
    ///     if Deleted then
    ///       WriteLn('Modèle deleted');
    ///   finally
    ///     Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Delete(const ModelId: string): TModelDeletion;
    /// <summary>
    /// Retrieves the details of a model.
    /// </summary>
    /// <param name="ModelId">The ID of the model to be retrieved.</param>
    /// <returns>Returns the details of the specified model.</returns>
    /// <remarks>
    /// This method is used to access detailed information about a specific model, including its
    /// creation date, owner, and capabilities. This is useful for managing and reviewing model
    /// details.
    /// <code>
    ///   with MistralAI.Models.Retrieve('ModelId');
    ///   try
    ///     // Model found processing
    ///   finally
    ///     Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Retrieve(const ModelId: string): TModel;
    /// <summary>
    /// Updates the details of a fine-tuned model.
    /// </summary>
    /// <param name="ModelId">The ID of the fine-tuned model to be updated.</param>
    /// <param name="ParamProc">A procedure that specifies the parameters to be updated.</param>
    /// <returns>Returns the updated model details.</returns>
    /// <remarks>
    /// Use this method to change specific details of a fine-tuned model, such as its name or
    /// description. This is useful for managing model metadata.
    /// <code>
    ///   var FineTuned := MistralAI.Models.Retrieve(
    ///          'ModelId',
    ///          procedure (Params: TModelParams)
    ///          begin
    ///            // Define params to retrieve the model
    ///          end);
    ///   if Assigned(FineTuned) then
    ///     try
    ///       // Handle FineTuned.job
    ///     finally
    ///       FineTuned.Free;
    ///     end;
    /// </code>
    /// </remarks>
    function Update(const ModelId: string; ParamProc: TProc<TModelParams>): TFineTunedModel;
    /// <summary>
    /// Archives a fine-tuned model.
    /// </summary>
    /// <param name="ModelId">The ID of the fine-tuned model to be archived.</param>
    /// <returns>Returns the archiving status of the model.</returns>
    /// <remarks>
    /// Archiving a model makes it unavailable for use but preserves its state and metadata.
    /// This is useful for managing storage and ensuring that models are not used when they are
    /// not needed.
    /// <code>
    ///   with MistralAI.Models.Archive('ModelId');
    ///   try
    ///     // Model is archived
    ///   finally
    ///     Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Archive(const ModelId: string): TArchivingModel;
    /// <summary>
    /// Un-archives a fine-tuned model.
    /// </summary>
    /// <param name="ModelId">The ID of the fine-tuned model to be un-archived.</param>
    /// <returns>Returns the un-archiving status of the model.</returns>
    /// <remarks>
    /// Un-archiving a model restores it to an active state, making it available for use again.
    /// This is useful for reactivating models that were previously archived.
    /// <code>
    ///   with MistralAI.Models.Unarchive('ModelId');
    ///   try
    ///     // Model is unarchived
    ///   finally
    ///     Free;
    ///   end;
    /// </remarks>
    function Unarchive(const ModelId: string): TArchivingModel;
  end;

implementation

{ TModels }

destructor TModels.Destroy;
begin
  for var Item in FData do
    Item.Free;
  inherited;
end;

{ TModelsRoute }

function TModelsRoute.Archive(const ModelId: string): TArchivingModel;
begin
  Result := API.Post<TArchivingModel>(Format('fine_tuning/models/%s/archive', [ModelId]));
end;

procedure TModelsRoute.AsyncArchive(const ModelId: string;
  const CallBacks: TFunc<TAsynArchivingModel>);
begin
  with TAsyncCallBackExec<TAsynArchivingModel, TArchivingModel>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TArchivingModel
      begin
        Result := Archive(ModelId);
      end);
  finally
    Free;
  end;
end;

procedure TModelsRoute.AsyncDelete(const ModelId: string;
  const CallBacks: TFunc<TAsynModelDeletion>);
begin
  with TAsyncCallBackExec<TAsynModelDeletion, TModelDeletion>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TModelDeletion
      begin
        Result := Delete(ModelId);
      end);
  finally
    Free;
  end;
end;

procedure TModelsRoute.AsyncList(const CallBacks: TFunc<TAsynModels>);
begin
  with TAsyncCallBackExec<TAsynModels, TModels>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TModels
      begin
        Result := List;
      end);
  finally
    Free;
  end;
end;

procedure TModelsRoute.AsyncRetrieve(const ModelId: string;
  const CallBacks: TFunc<TAsynModel>);
begin
  with TAsyncCallBackExec<TAsynModel, TModel>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TModel
      begin
        Result := Retrieve(ModelId);
      end);
  finally
    Free;
  end;
end;

procedure TModelsRoute.AsyncUnarchive(const ModelId: string;
  const CallBacks: TFunc<TAsynArchivingModel>);
begin
  with TAsyncCallBackExec<TAsynArchivingModel, TArchivingModel>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TArchivingModel
      begin
        Result := Unarchive(ModelId);
      end);
  finally
    Free;
  end;
end;

procedure TModelsRoute.AsyncUpdate(const ModelId: string;
  ParamProc: TProc<TModelParams>;
  const CallBacks: TFunc<TAsynFineTuneModel>);
begin
  with TAsyncCallBackExec<TAsynFineTuneModel, TFineTunedModel>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TFineTunedModel
      begin
        Result := Update(ModelId, ParamProc);
      end);
  finally
    Free;
  end;
end;

function TModelsRoute.Delete(const ModelId: string): TModelDeletion;
begin
  Result := API.Delete<TModelDeletion>(Format('models/%s', [ModelId]));
end;

function TModelsRoute.List: TModels;
begin
  Result := API.Get<TModels>('models');
end;

function TModelsRoute.Retrieve(const ModelId: string): TModel;
begin
  Result := API.Get<TModel>(Format('models/%s', [ModelId]));
end;

function TModelsRoute.Unarchive(const ModelId: string): TArchivingModel;
begin
  Result := API.Delete<TArchivingModel>(Format('fine_tuning/models/%s/archive', [ModelId]));
end;

function TModelsRoute.Update(const ModelId: string;
  ParamProc: TProc<TModelParams>): TFineTunedModel;
begin
  Result := API.Patch<TFineTunedModel, TModelParams>(Format('fine_tuning/models/%s', [ModelId]), ParamProc);
end;

{ TCoreModel }

destructor TCoreModel.Destroy;
begin
  if Assigned(FCapabilities) then
    FCapabilities.Free;
  inherited;
end;

{ TModelParams }

function TModelParams.Description(const Value: string): TModelParams;
begin
  Result := TModelParams(Add('description', Value));
end;

function TModelParams.Name(const Value: string): TModelParams;
begin
  Result := TModelParams(Add('name', Value));
end;

end.

unit MistralAI.NetEncoding.Base64;

interface

uses
  System.SysUtils, System.Classes, System.NetEncoding, System.Net.Mime;

  /// <summary>
  /// Retrieves the MIME type of the specified file based on its location.
  /// </summary>
  /// <param name="FileLocation">The full path to the file whose MIME type is to be resolved.</param>
  /// <returns>
  /// A string representing the MIME type of the file.
  /// If the file does not exist, an exception will be raised.
  /// </returns>
  /// <exception cref="Exception">
  /// Thrown if the specified file cannot be found at the provided location.
  /// </exception>
  /// <remarks>
  /// This method checks if the specified file exists and retrieves its MIME type
  /// using the <c>TMimeTypes.Default.GetFileInfo</c> method.
  /// Ensure the provided path is valid before calling this function.
  /// </remarks>
  function ResolveMimeType(const FileLocation: string): string;

  /// <summary>
  /// Validates a URL or file location and converts it into a Base64 data URI if appropriate.
  /// </summary>
  /// <param name="Value">
  /// The input string, which can either be a URL or a file path.
  /// </param>
  /// <returns>
  /// A string representing the validated URL or a Base64-encoded data URI for supported image files.
  /// </returns>
  /// <exception cref="Exception">
  /// Thrown in the following cases:
  /// <para>If the URL starts with "http:" (insecure connection).</para>
  /// <para>If the file MIME type is not among the supported image formats: "image/png", "image/jpeg", "image/gif", "image/webp".</para>
  /// <para>If the file does not exist at the specified location.</para>
  /// </exception>
  /// <remarks>
  /// This function performs the following actions:
  /// <para>Checks if the input starts with "https:" and returns it directly if valid.</para>
  /// <para>Throws an exception if the input starts with "http:" to enforce secure connections.</para>
  /// <para>If the input is a file path, resolves its MIME type and verifies if it is a supported image format.</para>
  /// <para>Encodes the file content as a Base64 data URI if it is a supported image.</para>
  /// </remarks>
  function UrlCheck(const Value: string): string;

  /// <summary>
  /// Converts a byte array into a Base64-encoded string.
  /// </summary>
  /// <param name="Value">
  /// A <c>TBytes</c> array containing the binary data to be encoded.
  /// </param>
  /// <returns>
  /// A <c>string</c> representing the Base64-encoded content of the byte array.
  /// </returns>
  /// <exception cref="Exception">
  /// Raised if the provided byte array is empty.
  /// </exception>
  /// <remarks>
  /// This function processes the provided byte array, converts it into a memory stream, and encodes the content as a Base64 string.
  /// Ensure the byte array contains data before calling this function.
  /// </remarks>
  function BytesToBase64(const Value: TBytes): string;

  /// <summary>
  /// Converts a byte array into a UTF-8 encoded string.
  /// </summary>
  /// <param name="Value">
  /// A <c>TBytes</c> array containing the binary data to be converted.
  /// </param>
  /// <returns>
  /// A <c>string</c> representing the UTF-8 encoded content of the byte array.
  /// </returns>
  /// <exception cref="Exception">
  /// Raised if the provided byte array is empty.
  /// </exception>
  /// <remarks>
  /// This function processes the provided byte array by writing it to a memory stream,
  /// then reads and converts the data into a string using UTF-8 encoding.
  /// Ensure the byte array contains data before calling this function.
  /// </remarks>
  function BytesToString(const Value: TBytes): string;

  /// <summary>
  /// Encodes the content of a file into a Base64-encoded string.
  /// </summary>
  /// <param name="FileLocation">The full path to the file that will be encoded.</param>
  /// <returns>A Base64-encoded string representing the content of the file.</returns>
  /// <exception cref="Exception">Thrown if the specified file does not exist at the provided location.</exception>
  /// <remarks>
  /// This method reads the file from the specified location and converts it to a Base64 string.
  /// It uses different encoding methods depending on the version of  the RTL.
  /// For RTL version 35.0 and later, it uses <c>TNetEncoding.Base64String.Encode</c>,
  /// and for earlier versions, it uses <c>TNetEncoding.Base64.Encode</c>.
  /// </remarks>
  function EncodeBase64(FileLocation : string) : WideString; overload;

  /// <summary>
  /// Encodes the content of a stream into a Base64-encoded string.
  /// </summary>
  /// <param name="Value">
  /// A <c>TStream</c> containing the data to be encoded.
  /// </param>
  /// <returns>
  /// A <c>WideString</c> representing the Base64-encoded content of the stream.
  /// </returns>
  /// <exception cref="Exception">
  /// Raised if an error occurs while reading from the stream or during encoding.
  /// </exception>
  /// <remarks>
  /// This function reads the content of the provided stream and converts it into a Base64-encoded string.
  /// Ensure that the stream is properly positioned and contains readable data before calling this function.
  /// For RTL version 35.0 and later, it uses <c>TNetEncoding.Base64String.Encode</c>.
  /// For earlier versions, it uses <c>TNetEncoding.Base64.Encode</c>.
  /// </remarks>
  function EncodeBase64(const Value: TStream): WideString; overload;

  /// <summary>
  /// Decodes a Base64-encoded string and writes the resulting binary data to a specified file.
  /// </summary>
  /// <param name="Base64Str">The Base64-encoded string to decode.</param>
  /// <param name="FileName">The full path and name of the file where the decoded data will be written.</param>
  /// <exception cref="Exception">
  /// Thrown if the Base64 string cannot be decoded or if there is an error writing to the specified file.
  /// </exception>
  procedure DecodeBase64ToFile(const Base64Str: string; const FileName: string);

  /// <summary>
  /// Decodes a Base64-encoded string and writes the resulting binary data to the provided stream.
  /// </summary>
  /// <param name="Base64Str">The Base64-encoded string to decode.</param>
  /// <param name="Stream">The stream where the decoded binary data will be written. The stream should be writable.</param>
  /// <exception cref="Exception">
  /// Thrown if the Base64 string cannot be decoded or if there is an error writing to the provided stream.
  /// </exception>
  /// <remarks>
  /// After decoding, the stream's position is reset to the beginning.
  /// Ensure that the stream is properly managed and freed after use to avoid memory leaks.
  /// </remarks>
  procedure DecodeBase64ToStream(const Base64Str: string; const Stream: TStream);

implementation

uses
  System.StrUtils;

function EncodeBase64(FileLocation : string): WideString;
begin
  if not FileExists(FileLocation) then
    raise Exception.CreateFmt('File not found : %s', [FileLocation]);

  var Stream := TMemoryStream.Create;
  var StreamOutput := TStringStream.Create('', TEncoding.UTF8);
  try
    Stream.LoadFromFile(FileLocation);
    Stream.Position := 0;
    {$IF RTLVersion >= 35.0}
    TNetEncoding.Base64String.Encode(Stream, StreamOutput);
    {$ELSE}
    TNetEncoding.Base64.Encode(Stream, StreamOutput);
    {$ENDIF}
    Result := StreamOutput.DataString;
  finally
    Stream.Free;
    StreamOutput.Free;
  end;
end;

function ResolveMimeType(const FileLocation: string): string;
begin
  if not FileExists(FileLocation) then
    raise Exception.CreateFmt('File not found: %s', [FileLocation]);

  var LKind: TMimeTypes.TKind;
  TMimeTypes.Default.GetFileInfo(FileLocation, Result, LKind);
end;

function UrlCheck(const Value: string): string;
begin
  if Value.StartsWith('https:') then
    Exit(Value);
  if Value.StartsWith('http:') then
    raise Exception.Create('Invalid URL: Secure HTTPS connection required');

  var MimeType := ResolveMimeType(Value);
  if IndexStr(MimeType, ['image/png', 'image/jpeg', 'image/gif', 'image/webp']) = -1 then
    raise Exception.Create('Unsupported image format');
  Result :=  Format('data:%s;base64,%s', [MimeType, EncodeBase64(Value)]);
end;

function BytesToBase64(const Value: TBytes): String;
begin
  if Length(Value) = 0 then
    raise Exception.Create('No data recieved.');
  var MemStream := TMemoryStream.Create;
  try
    MemStream.WriteBuffer(Value[0], Length(Value));
    MemStream.Position := 0;
    Result := EncodeBase64(MemStream);
  finally
    MemStream.Free;
  end;
end;

function BytesToString(const Value: TBytes): string;
begin
  if Length(Value) = 0 then
    raise Exception.Create('No data recieved.');
  var MemStream := TMemoryStream.Create;
  try
    MemStream.WriteBuffer(Value[0], Length(Value));
    MemStream.Position := 0;
    var Reader := TStreamReader.Create(MemStream, TEncoding.UTF8);
    try
      Result := Reader.ReadToEnd;
    finally
      Reader.Free;
    end;
  finally
    MemStream.Free;
  end;
end;

function EncodeBase64(const Value: TStream): WideString; overload;
begin
  var Stream := TMemoryStream.Create;
  var StreamOutput := TStringStream.Create('', TEncoding.UTF8);
  try
    Stream.LoadFromStream(Value);
    Stream.Position := 0;
    {$IF RTLVersion >= 35.0}
    TNetEncoding.Base64String.Encode(Stream, StreamOutput);
    {$ELSE}
    TNetEncoding.Base64.Encode(Stream, StreamOutput);
    {$ENDIF}
    Result := StreamOutput.DataString;
  finally
    Stream.Free;
    StreamOutput.Free;
  end;
end;

procedure DecodeBase64ToFile(const Base64Str: string; const FileName: string);
begin
  {--- Convert Base64 string to byte array for input stream }
  var Bytes := TEncoding.UTF8.GetBytes(Base64Str);

  {--- Create the flows }
  var InputStream := TBytesStream.Create(Bytes);
  var OutputStream := TFileStream.Create(FileName, fmCreate);
  try
    {--- Decode using TNetEncoding.Base64.Decode (stream) }
    TNetEncoding.Base64.Decode(InputStream, OutputStream);
  finally
    InputStream.Free;
    OutputStream.Free;
  end;
end;

procedure DecodeBase64ToStream(const Base64Str: string; const Stream: TStream);
begin
  {--- Converts the base64 string directly into the memory stream }
  var InputStream := TBytesStream.Create(TEncoding.UTF8.GetBytes(Base64Str));
    try
      TNetEncoding.Base64.Decode(InputStream, Stream);
      Stream.Position := 0;
    finally
      InputStream.Free;
    end;
end;

end.

unit MistralAI.Params.Core;

{-------------------------------------------------------------------------------

      Unit containing generic interfaces and classes for managing parameters
      across  various  asynchronous  operations.

      The MistralAI.Params.Core  unit  provides  a set of tools for creating
      and managing  parameter  instances  using  generic  types. The primary
      components include:

      - IUseParams<T>: A generic interface for managing parameters of type T.
      - TUseParams<T>: A class  implementing  the IUseParams<T>  interface to
        encapsulate  parameter  handling.
      - TUseParamsFactory<T>: A  factory  class  for  creating  instances  of
        IUseParams<T>.

      These abstractions allow for  a flexible and  reusable  way  to  handle
      parameters  across  different  modules  and  contexts,  particularly in
      asynchronous  scenarios  such  as  chat operations.

      Note  that  This  unit  is  designed   to  work   seamlessly  with  the
      MistralAI.Chat.AsyncEvents  unit,  which  relies  on  IUseParams<T> and
      TUseParamsFactory<T>  to  manage   parameters   for  asynchronous  chat
      requests.

        Github  repository : https://github.com/MaxiDonkey/DelphiMistralAI
        Visit the Github repository for the documentation and use examples

-------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes;

type
  /// <summary>
  /// Generic interface for managing parameters of type <c>T</c>.
  /// </summary>
  /// <typeparam name="T">
  /// The type of the parameters.
  /// </typeparam>
  IUseParams<T> = interface
    ['{18566F2C-F2D9-4257-A460-D9AE8F053357}']
    /// <summary>
    /// Sets the parameters.
    /// </summary>
    /// <param name="Value">
    /// The value of the parameters to be set.
    /// </param>
    procedure SetParams(const Value: T);
    /// <summary>
    /// Gets the current parameters.
    /// </summary>
    /// <returns>
    /// The current parameters of type <c>T</c>.
    /// </returns>
    function GetParams: T;
    /// <summary>
    /// Assigns the parameters using a function.
    /// </summary>
    /// <param name="Value">
    /// A function that returns parameters of type <c>T</c>.
    /// </param>
    procedure Assign(Value: TFunc<T>);
    /// <summary>
    /// Returns the current instance as an object of type <c>TObject</c>.
    /// </summary>
    /// <returns>
    /// The instance cast to <c>TObject</c>.
    /// </returns>
    function AsSender: TObject;
    /// <summary>
    /// Provides access to the parameters as a property.
    /// </summary>
    property Param: T read GetParams write SetParams;
  end;

  /// <summary>
  /// A factory class for creating instances of <c>IUseParams</c>.
  /// </summary>
  /// <param name="T">
  /// The type of the parameters for which the instance is created.
  /// </param>
  TUseParamsFactory<T> = class
    /// <summary>
    /// Creates and returns a new instance of <c>IUseParams</c> for the specified type <c>T</c>.
    /// </summary>
    /// <returns>
    /// A new instance of <c>IUseParams&lt;T&gt;</c>.
    /// </returns>
    class function CreateInstance: IUseParams<T>; overload;
    /// <summary>
    /// Creates and returns a new instance of <c>IUseParams</c> for the specified type <c>T</c>, using the provided function.
    /// </summary>
    /// <param name="Value">
    /// A function that provides the parameter values for the instance.
    /// </param>
    /// <returns>
    /// A new instance of <c>IUseParams&lt;T&gt;</c>.
    /// </returns>
    class function CreateInstance(Value: TFunc<T>): IUseParams<T>; overload;
  end;

  /// <summary>
  /// A generic class implementing the <c>IUseParams</c> interface to manage parameters of type <c>T</c>.
  /// </summary>
  /// <param name="T">
  /// The type of the parameters.
  /// </param>
  TUseParams<T> = class(TInterfacedObject, IUseParams<T>)
  private
    FParams: T;
    /// <summary>
    /// Sets the parameters to the provided value.
    /// </summary>
    /// <param name="Value">
    /// The new parameters value.
    /// </param>
    procedure SetParams(const Value: T);
    /// <summary>
    /// Retrieves the current parameters value.
    /// </summary>
    /// <returns>
    /// The current parameters.
    /// </returns>
    function GetParams: T;
  protected
    /// <summary>
    /// Casts the instance as a <c>TObject</c> for use as the sender of events.
    /// </summary>
    /// <returns>
    /// The current instance cast to <c>TObject</c>.
    /// </returns>
    function AsSender: TObject;
    /// <summary>
    /// Assigns the parameters using a function that returns type <c>T</c>.
    /// </summary>
    /// <param name="Value">
    /// A function that sets the parameters.
    /// </param>
    procedure Assign(Value: TFunc<T>);
  public
    /// <summary>
    /// Property to get or set the parameters.
    /// </summary>
    property Params: T read GetParams write SetParams;
  end;

implementation

{ TUseParams<T> }

function TUseParams<T>.AsSender: TObject;
begin
  Result := Self;
end;

procedure TUseParams<T>.Assign(Value: TFunc<T>);
begin
  if Assigned(Value) then
    begin
      Params := Value();
    end;
end;

function TUseParams<T>.GetParams: T;
begin
  Result := FParams;
end;

procedure TUseParams<T>.SetParams(const Value: T);
begin
  FParams := Value;
end;

{ TUseParamsFactory<T> }

class function TUseParamsFactory<T>.CreateInstance: IUseParams<T>;
begin
  Result := TUseParams<T>.Create;
end;

class function TUseParamsFactory<T>.CreateInstance(
  Value: TFunc<T>): IUseParams<T>;
begin
  Result := CreateInstance;
  Result.Assign(Value);
end;

end.

unit MistralAI;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, MistralAI.API, System.Net.URLClient,
  MistralAI.Chat, MistralAI.Embeddings, MistralAI.Models, MistralAI.Codestral,
  MistralAI.Files, MistralAI.FineTunings, MistralAI.Agents, MistralAI.Classifiers,
  MistralAI.Functions.Tools, MistralAI.Functions.Core, MistralAI.Batch;

type
  /// <summary>
  /// The IMistralAI interface provides access to the various features and routes of the Mistral AI API.
  /// This interface allows interaction with different services such as agents, chat, code completion,
  /// embeddings, file management, fine-tuning, and model information.
  /// </summary>
  /// <remarks>
  /// This interface should be implemented by any class that wants to provide a structured way of accessing
  /// the Mistral AI services. It includes methods and properties for authenticating with an API key,
  /// configuring the base URL, and accessing different API routes.
  ///
  /// To use this interface, instantiate a class that implements it, set the required properties such as
  /// <see cref="Token"/> and <see cref="BaseURL"/>, and call the relevant methods for the desired operations.
  /// <code>
  ///   var MistralAI: IMistralAI := TMistralAI.Create(API_TOKEN);
  ///   or
  ///   var CodestralAI: IMistralAI := TMistralAI.Create(API_TOKEN, [CodestralSpec]);
  /// </code>
  /// <seealso cref="TMistralAI"/>
  /// </remarks>
  IMistralAI = interface
    ['{CB506753-77B2-4BD6-A2F8-216433D444A8}']
    function GetAPI: TMistralAIAPI;
    procedure SetToken(const Value: string);
    function GetToken: string;
    function GetBaseUrl: string;
    procedure SetBaseUrl(const Value: string);
    function GetAgentRoute: TAgentRoute;
    function GetChatRoute: TChatRoute;
    function GetCodestralRoute: TCodestralRoute;
    function GetEmbeddingsRoute: TEmbeddingsRoute;
    function GetFilesRoute: TFilesRoute;
    function GetFineTuningRoute: TFineTuningRoute;
    function GetModelsRoute: TModelsRoute;
    function GetClassifiersRoute: TClassifiersRoute;
    function GetBatchRoute: TBatchRoute;

    property Agent: TAgentRoute read GetAgentRoute;
    /// <summary>
    /// A batch is composed of a list of API requests. The structure of an individual request includes:
    /// <para>
    /// - A unique custom_id for identifying each request and referencing results after completion
    /// </para>
    /// <para>
    /// - A body object with message information
    /// </para>
    /// </summary>
    /// <returns>
    /// An instance of GetBatchRoute for batch-related operations.
    /// </returns>
    property Batch: TBatchRoute read GetBatchRoute;
    /// <summary>
    /// Provides access to the chat completion API.
    /// Allows for interaction with models fine-tuned for instruction-based dialogue.
    /// </summary>
    /// <returns>
    /// An instance of TChatRoute for chat-related operations.
    /// </returns>
    property Chat: TChatRoute read GetChatRoute;
    /// <summary>
    /// Provides access to the Codestral Completion API.
    /// Allows for code design or completion using a template configured to follow specific instructions.
    /// </summary>
    /// <returns>
    /// An instance of TCodestralRoute for code completion operations.
    /// </returns>
    property Codestral: TCodestralRoute read GetCodestralRoute;
    /// <summary>
    /// Provides access to the embeddings API.
    /// Enables the embedding of sentences or documents.
    /// </summary>
    /// <returns>
    /// An instance of TEmbeddingsRoute for embedding operations.
    /// </returns>
    property Embeddings: TEmbeddingsRoute read GetEmbeddingsRoute;
    /// <summary>
    /// Provides access to the file management API.
    /// Files can be uploaded and used with features such as fine-tuning.
    /// </summary>
    /// <returns>
    /// An instance of TFilesRoute for file-related operations.
    /// </returns>
    property &File: TFilesRoute read GetFilesRoute;
    /// <summary>
    /// Provides access to fine-tuning API for user and organization.
    /// Allows managing fine-tuning jobs.
    /// </summary>
    /// <returns>
    /// An instance of TFineTuningRoute for fine-tuning operations.
    /// </returns>
    property FineTuning: TFineTuningRoute read GetFineTuningRoute;
    /// <summary>
    /// Lists and describes the various models available in the API.
    /// You can refer to the Models documentation to understand what models are available and the differences between them.
    /// </summary>
    /// <returns>
    /// An instance of TModelsRoute for model-related operations.
    /// </returns>
    property Models: TModelsRoute read GetModelsRoute;
    /// <summary>
    /// Moderation service, which is powered by the Mistral Moderation model, Ministral 8B 24.10
    /// </summary>
    /// <returns>
    /// An instance of TModelsRoute for model-related operations.
    /// </returns>
    property Classifiers: TClassifiersRoute read GetClassifiersRoute;
    /// <summary>
    /// the main API object used for making requests.
    /// </summary>
    /// <returns>
    /// An instance of TMistralAIAPI for making API calls.
    /// </returns>
    property API: TMistralAIAPI read GetAPI;
    /// Sets or retrieves the API token for authentication.
    /// </summary>
    /// <param name="Value">
    /// The API token as a string.
    /// </param>
    /// <returns>
    /// The current API token.
    /// </returns>
    property Token: string read GetToken write SetToken;
    /// <summary>
    /// Sets or retrieves the base URL for API requests.
    /// Default is https://api.mistral.ai/v1.
    /// </summary>
    /// <param name="Value">
    /// The base URL as a string.
    /// </param>
    /// <returns>
    /// The current base URL.
    /// </returns>
    property BaseURL: string read GetBaseUrl write SetBaseUrl;
    /// <summary>
    /// Provides access to agent completion API.
    /// An AI agent is an autonomous system using large language models (LLM) to perform tasks based on high-level instructions.
    /// </summary>
    /// <returns>
    /// An instance of TAgentRoute for agent-related operations.
    /// </returns>
  end;

  /// <summary>
  /// Specification taken into account
  /// </summary>
  TSpec = (
    /// <summary>
    /// The "codestral" specification is taken into account in the instantiation of the class
    /// </summary>
    CodestralSpec);

  /// <summary>
  /// List of specifications taken into account
  /// </summary>
  TSpecs = set of TSpec;

  TMistralAIFactory = class
    class function CreateInstance(const AToken: string; Specs: TSpecs = []): IMistralAI;
  end;

  /// <summary>
  /// The TMistralAI class provides access to the various features and routes of the Mistral AI API.
  /// This class allows interaction with different services such as agents, chat, code completion,
  /// embeddings, file management, fine-tuning, and model information.
  /// </summary>
  /// <remarks>
  /// This class should be implemented by any class that wants to provide a structured way of accessing
  /// the Mistral AI services. It includes methods and properties for authenticating with an API key,
  /// configuring the base URL, and accessing different API routes.
  /// <seealso cref="TMistralAI"/>
  /// </remarks>
  TMistralAI = class(TInterfacedObject, IMistralAI)
  strict private
    FSpecs: TSpecs;
    procedure CodestralCheck;

  private
    FAPI: TMistralAIAPI;
    FAgentRoute: TAgentRoute;
    FChatRoute: TChatRoute;
    FCodestralRoute: TCodestralRoute;
    FEmbeddingsRoute: TEmbeddingsRoute;
    FFileRoute: TFilesRoute;
    FFineTuningRoute: TFineTuningRoute;
    FModelsRoute: TModelsRoute;
    FClassifiersRoute: TClassifiersRoute;
    FBatchRoute: TBatchRoute;
    function GetAPI: TMistralAIAPI;
    function GetToken: string;
    procedure SetToken(const Value: string);
    function GetBaseUrl: string;
    procedure SetBaseUrl(const Value: string);
    function GetAgentRoute: TAgentRoute;
    function GetChatRoute: TChatRoute;
    function GetCodestralRoute: TCodestralRoute;
    function GetEmbeddingsRoute: TEmbeddingsRoute;
    function GetFilesRoute: TFilesRoute;
    function GetFineTuningRoute: TFineTuningRoute;
    function GetModelsRoute: TModelsRoute;
    function GetClassifiersRoute: TClassifiersRoute;
    function GetBatchRoute: TBatchRoute;
  public
    /// <summary>
    /// the main API object used for making requests.
    /// </summary>
    /// <returns>
    /// An instance of TMistralAIAPI for making API calls.
    /// </returns>
    property API: TMistralAIAPI read GetAPI;
    /// <summary>
    /// Sets or retrieves the API token for authentication.
    /// </summary>
    /// <param name="Value">
    /// The API token as a string.
    /// </param>
    /// <returns>
    /// The current API token.
    /// </returns>
    property Token: string read GetToken write SetToken;
    /// <summary>
    /// Sets or retrieves the base URL for API requests.
    /// Default is https://api.mistral.ai/v1.
    /// </summary>
    /// <param name="Value">
    /// The base URL as a string.
    /// </param>
    /// <returns>
    /// The current base URL.
    /// </returns>
    property BaseURL: string read GetBaseUrl write SetBaseUrl;

  public
    /// <summary>
    /// Provides access to agent completion API.
    /// An AI agent is an autonomous system using large language models (LLM) to perform tasks based on high-level instructions.
    /// </summary>
    /// <returns>
    /// An instance of TAgentRoute for agent-related operations.
    /// </returns>
    property Agent: TAgentRoute read GetAgentRoute;
    /// <summary>
    /// A batch is composed of a list of API requests. The structure of an individual request includes:
    /// <para>
    /// - A unique custom_id for identifying each request and referencing results after completion
    /// </para>
    /// <para>
    /// - A body object with message information
    /// </para>
    /// </summary>
    /// <returns>
    /// An instance of GetBatchRoute for batch-related operations.
    /// </returns>
    property Batch: TBatchRoute read GetBatchRoute;
    /// <summary>
    /// Provides access to the chat completion API.
    /// Allows for interaction with models fine-tuned for instruction-based dialogue.
    /// </summary>
    /// <returns>
    /// An instance of TChatRoute for chat-related operations.
    /// </returns>
    property Chat: TChatRoute read GetChatRoute;
    /// <summary>
    /// Provides access to the Codestral Completion API.
    /// Allows for code design or completion using a template configured to follow specific instructions.
    /// </summary>
    /// <returns>
    /// An instance of TCodestralRoute for code completion operations.
    /// </returns>
    property Codestral: TCodestralRoute read GetCodestralRoute;
    /// <summary>
    /// Provides access to the embeddings API.
    /// Enables the embedding of sentences or documents.
    /// </summary>
    /// <returns>
    /// An instance of TEmbeddingsRoute for embedding operations.
    /// </returns>
    property Embeddings: TEmbeddingsRoute read GetEmbeddingsRoute;
    /// <summary>
    /// Provides access to the file management API.
    /// Files can be uploaded and used with features such as fine-tuning.
    /// </summary>
    /// <returns>
    /// An instance of TFilesRoute for file-related operations.
    /// </returns>
    property &File: TFilesRoute read GetFilesRoute;
    /// <summary>
    /// Provides access to fine-tuning API for user and organization.
    /// Allows managing fine-tuning jobs.
    /// </summary>
    /// <returns>
    /// An instance of TFineTuningRoute for fine-tuning operations.
    /// </returns>
    property FineTuning: TFineTuningRoute read GetFineTuningRoute;
    /// <summary>
    /// Lists and describes the various models available in the API.
    /// You can refer to the Models documentation to understand what models are available and the differences between them.
    /// </summary>
    /// <returns>
    /// An instance of TModelsRoute for model-related operations.
    /// </returns>
    property Models: TModelsRoute read GetModelsRoute;
    /// <summary>
    /// Moderation service, which is powered by the Mistral Moderation model, Ministral 8B 24.10
    /// </summary>
    /// <returns>
    /// An instance of TModelsRoute for model-related operations.
    /// </returns>
    property Classifiers: TClassifiersRoute read GetClassifiersRoute;
  public
    constructor Create; overload;
    constructor Create(const AToken: string; Specs: TSpecs = []); overload;
    destructor Destroy; override;
  end;

  {$REGION 'MistralAI.Chat'}

  /// <summary>
  /// Represents a message payload that includes an image, identified by a URL or a base-64 encoded string.
  /// </summary>
  /// <remarks>
  /// This class is used to encapsulate details of an image message, including its source (URL or base-64 string)
  /// and additional descriptive information. It extends <c>TJSONParam</c> for JSON serialization and integration with APIs.
  /// </remarks>
  /// <example>
  /// This class can be utilized to construct structured image messages for communication in chat systems.
  /// </example>
  TMessageImageURL = MistralAI.Chat.TMessageImageURL;

  /// <summary>
  /// Represents the content of a message, which can be either text or an image URL.
  /// </summary>
  /// <remarks>
  /// This class is used to define the structure and type of content within a message,
  /// such as textual data or image references. It extends <c>TJSONParam</c> for
  /// seamless JSON serialization and integration with APIs.
  /// </remarks>
  TMessageContent = MistralAI.Chat.TMessageContent;

  /// <summary>
  /// Represents the metadata and arguments of a function invoked during a chat interaction.
  /// </summary>
  /// <remarks>
  /// This class is used to define the structure of function calls, including the function's name and its associated arguments.
  /// It is designed to be serialized into JSON format for integration with APIs or other systems requiring structured function data.
  /// </remarks>
  TFunctionCalled = MistralAI.Chat.TFunctionCalled;

  /// <summary>
  /// Represents a tool call configuration used in chat-based operations.
  /// </summary>
  /// <remarks>
  /// This class is designed to define and manage tool calls within chat contexts, including
  /// their type, identifier, and associated functions. It integrates with <c>TJSONParam</c>
  /// for seamless serialization and API interactions.
  /// </remarks>
  TToolCalls = MistralAI.Chat.TToolCalls;

  /// <summary>
  /// Represents the payload structure for a chat message in the context of a conversation.
  /// </summary>
  /// <remarks>
  /// This class encapsulates the essential elements of a chat message, including its role, content,
  /// and associated metadata. It extends <c>TJSONParam</c>, enabling seamless integration with JSON-based
  /// APIs for chat functionalities. This class is a foundational building block for managing the flow of
  /// conversations between users, systems, and assistants.
  /// </remarks>
  TChatMessagePayload = MistralAI.Chat.TChatMessagePayload;

  /// <summary>
  /// Represents the payload structure for a chat message in the context of a conversation.
  /// </summary>
  /// <remarks>
  /// This class encapsulates the essential elements of a chat message, including its role, content,
  /// and associated metadata. It extends <c>TJSONParam</c>, enabling seamless integration with JSON-based
  /// APIs for chat functionalities. This class is a foundational building block for managing the flow of
  /// conversations between users, systems, and assistants.
  /// </remarks>
  PayLoad = MistralAI.Chat.PayLoad;

  /// <summary>
  /// The <c>TChatParams</c> class represents the set of parameters used to configure a chat interaction with an AI model.
  /// </summary>
  /// <remarks>
  /// This class allows you to define various settings that control how the model behaves, including which model to use, how many tokens to generate,
  /// what kind of messages to send, and how the model should handle its output. By using this class, you can fine-tune the AI's behavior and response format
  /// based on your application's specific needs.
  /// <para>
  /// It inherits from <c>TJSONParam</c>, which provides methods for handling and serializing the parameters as JSON, allowing seamless integration
  /// with JSON-based APIs.
  /// </para>
  /// <code>
  /// var
  ///   Params: TChatParams;
  /// begin
  ///   Params := TChatParams.Create
  ///     .Model('my_model')
  ///     .MaxTokens(100)
  ///     .Messages([TChatMessagePayload.User('Hello!')])
  ///     .ResponseFormat('json_object')
  ///     .Temperature(0.7)
  ///     .TopP(1)
  ///     .SafePrompt(True);
  /// end;
  /// </code>
  /// This example shows how to instantiate and configure a <c>TChatParams</c> object for interacting with an AI model.
  /// </remarks>
  TChatParams = MistralAI.Chat.TChatParams;

  /// <summary>
  /// Represents the token usage statistics for a chat interaction, including the number of tokens
  /// used in the prompt, the completion, and the total number of tokens consumed.
  /// </summary>
  /// <remarks>
  /// The <c>TChatUsage</c> class provides insight into the number of tokens used during a chat interaction.
  /// This information is critical for understanding the cost of a request when using token-based billing systems
  /// or for monitoring the model's behavior in terms of input (prompt) and output (completion) size.
  /// </remarks>
  TChatUsage = MistralAI.Chat.TChatUsage;

  /// <summary>
  /// Represents a chat message exchanged between participants (user, assistant, or system) in a conversation.
  /// </summary>
  /// <remarks>
  /// The <c>TChatMessage</c> class encapsulates the essential information of a message within a chat application, including:
  /// - The role of the sender (user, assistant, or system).
  /// - The content of the message itself.
  /// - Optionally, a list of tool calls that may be required to complete the message response.
  /// This class is fundamental for managing the flow of a conversation, allowing the system to track who said what and what actions need to be taken.
  /// </remarks>
  TChatMessage = MistralAI.Chat.TChatMessage;

  /// <summary>
  /// Represents a single completion option generated by the AI model during a chat interaction.
  /// </summary>
  /// <remarks>
  /// The <c>TChatChoices</c> class stores the results of the AI model's response to a user prompt. Each instance of this class represents one of potentially
  /// many choices that the model could return. This includes:
  /// - An index identifying the choice.
  /// - A message generated by the model.
  /// - Optional deltas for streamed responses.
  /// - The reason the model stopped generating tokens.
  /// This class is useful when multiple potential responses are generated and evaluated, or when streaming responses incrementally.
  /// </remarks>
  TChatChoices = MistralAI.Chat.TChatChoices;

  /// <summary>
  /// Represents a chat completion response generated by an AI model, containing the necessary metadata,
  /// the generated choices, and usage statistics.
  /// </summary>
  /// <remarks>
  /// The <c>TChat</c> class encapsulates the results of a chat request made to an AI model.
  /// It contains details such as a unique identifier, the model used, when the completion was created,
  /// the choices generated by the model, and token usage statistics.
  /// This class is crucial for managing the results of AI-driven conversations and understanding the
  /// underlying usage and response characteristics of the AI.
  /// </remarks>
  TChat = MistralAI.Chat.TChat;

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TChat</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynChat</c> type extends the <c>TAsynParams&lt;TChat&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynChat = MistralAI.Chat.TAsynChat;

  /// <summary>
  /// Manages asynchronous streaming chat callBacks for a chat request using <c>TChat</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynChatStream</c> type extends the <c>TAsynStreamParams&lt;TChat&gt;</c> record to support the lifecycle of an asynchronous streaming chat operation.
  /// It provides callbacks for different stages, including when the operation starts, progresses with new data chunks, completes successfully, or encounters an error.
  /// This structure is ideal for handling scenarios where the chat response is streamed incrementally, providing real-time updates to the user interface.
  /// </remarks>
  TAsynChatStream = MistralAI.Chat.TAsynChatStream;

  /// <summary>
  /// Represents a callback procedure used during the reception of responses from a chat request in streaming mode.
  /// </summary>
  /// <param name="Chat">
  /// The <c>TChat</c> object containing the current information about the response generated by the model.
  /// If this value is <c>nil</c>, it indicates that the data stream is complete.
  /// </param>
  /// <param name="IsDone">
  /// A boolean flag indicating whether the streaming process is complete.
  /// If <c>True</c>, it means the model has finished sending all response data.
  /// </param>
  /// <param name="Cancel">
  /// A boolean flag that can be set to <c>True</c> within the callback to cancel the streaming process.
  /// If set to <c>True</c>, the streaming will be terminated immediately.
  /// </param>
  /// <remarks>
  /// This callback is invoked multiple times during the reception of the response data from the model.
  /// It allows for real-time processing of received messages and interaction with the user interface or other systems
  /// based on the state of the data stream.
  /// When the <c>IsDone</c> parameter is <c>True</c>, it indicates that the model has finished responding,
  /// and the <c>Chat</c> parameter will be <c>nil</c>.
  /// </remarks>
  TChatEvent = MistralAI.Chat.TChatEvent;

  {$ENDREGION}

  {$REGION 'MistralAI.Embeddings'}

  /// <summary>
  /// Represents the parameters for an embedding request.
  /// </summary>
  /// <remarks>
  /// Use this class to specify the input text and other parameters for generating embeddings.
  /// </remarks>
  TEmbeddingParams = MistralAI.Embeddings.TEmbeddingParams;

  /// <summary>
  /// Represents token usage statistics for an embedding request.
  /// </summary>
  /// <remarks>
  /// Contains information about the number of tokens used in the request.
  /// </remarks>
  TEmbeddingUsage = MistralAI.Embeddings.TEmbeddingUsage;

  /// <summary>
  /// Represents an embedding result for a single input.
  /// </summary>
  /// <remarks>
  /// Contains the embedding vector and associated metadata for a single input text.
  /// </remarks>
  TEmbeddingData = MistralAI.Embeddings.TEmbeddingData;

  /// <summary>
  /// Represents the response from an embedding request.
  /// </summary>
  /// <remarks>
  /// Contains the embeddings, model information, and usage statistics returned by the API.
  /// </remarks>
  TEmbeddings = MistralAI.Embeddings.TEmbeddings;

  /// <summary>
  /// Represents the asynchronous callback parameters for embedding requests.
  /// </summary>
  /// <remarks>
  /// Used to handle asynchronous responses for embedding operations.
  /// </remarks>
  TAsyncEmbeddings = MistralAI.Embeddings.TAsyncEmbeddings;

  {$ENDREGION}

  {$REGION 'MistralAI.Models'}

  /// <summary>
  /// The TModelParams class is used to specify parameters for updating the properties
  /// of a fine-tuned model in the MistralAI environment. It allows you to set new values
  /// for the model's name and description.
  /// </summary>
  /// <remarks>
  /// This class provides a fluent interface for configuring model parameters before
  /// submitting an update request. The Name and Description methods allow you to set
  /// these attributes individually and return the updated TModelParams object, enabling
  /// method chaining for concise configuration.
  /// </remarks>
  TModelParams = MistralAI.Models.TModelParams;

  /// <summary>
  /// The TCapabilities class represents the various features and functionalities
  /// that a MistralAI model can support. It indicates whether the model is capable of
  /// performing specific tasks such as chat completion, function calling, or fine-tuning.
  /// </summary>
  /// <remarks>
  /// This class is used to describe the capabilities of a model, helping users
  /// to understand what operations can be performed with the model. Each property
  /// corresponds to a specific capability, which can be checked to see if the model
  /// supports that feature. This information is typically used when selecting or
  /// configuring models for specific use cases.
  /// </remarks>
  TCapabilities = MistralAI.Models.TCapabilities;

  /// <summary>
  /// The TCoreModel class represents a generic model object that can be used with the MistralAI API.
  /// It contains all the essential properties and metadata required to describe a model, including
  /// its identifier, creation date, capabilities, and other attributes.
  /// </summary>
  /// <remarks>
  /// This class serves as the base class for more specific model types and provides a comprehensive
  /// view of a model's characteristics. The properties in this class are primarily used for
  /// interacting with the MistralAI API and retrieving model metadata. It is designed to be
  /// extended by other classes that represent more specialized model types.
  /// </remarks>
  TCoreModel = MistralAI.Models.TCoreModel;

  /// <summary>
  /// The TModel class extends TCoreModel to include additional information about
  /// the model's deprecation status. It inherits all the properties of TCoreModel
  /// and adds a field to track when the model is considered deprecated.
  /// </summary>
  /// <remarks>
  /// This class is used to represent models that are still available in the MistralAI environment
  /// but are marked as deprecated. Deprecation indicates that the model may no longer be supported
  /// in future versions, and users are encouraged to migrate to newer models if possible.
  /// This class is particularly useful for managing model lifecycles and ensuring that applications
  /// do not rely on outdated or unsupported models.
  /// </remarks>
  TModel = MistralAI.Models.TModel;

  /// <summary>
  /// The TFineTunedModel class extends the TCoreModel class to represent a fine-tuned model
  /// within the MistralAI environment. It includes additional information specific to the
  /// fine-tuning process, such as the job identifier associated with the fine-tuning operation.
  /// </summary>
  /// <remarks>
  /// This class is used to manage and interact with fine-tuned models, which are variants of
  /// base models that have been further trained on specific datasets to improve performance
  /// in specialized tasks. It inherits all properties from TCoreModel and adds specific
  /// attributes related to the fine-tuning process.
  /// </remarks>
  TFineTunedModel = MistralAI.Models.TFineTunedModel;

  /// <summary>
  /// The TModels class represents a collection of available models in the MistralAI environment.
  /// It provides basic information about each model, including the owner and availability,
  /// allowing users to list and inspect the models they have access to.
  /// </summary>
  /// <remarks>
  /// This class serves as a container for multiple `TModel` instances, each representing
  /// a different model. It is primarily used to retrieve a comprehensive list of models
  /// from the MistralAI API, and it can be helpful for applications that need to display
  /// or manage multiple models at once.
  /// </remarks>
  TModels = MistralAI.Models.TModels;

  /// <summary>
  /// The TModelDeletion class manages the data returned after the successful deletion
  /// of a fine-tuned model in the MistralAI environment. It contains information
  /// about the model that was deleted, such as its ID and deletion status.
  /// </summary>
  /// <remarks>
  /// This class is used to capture the result of a model deletion request.
  /// It provides confirmation that the specified model has been successfully deleted
  /// from the system. This information is important for auditing and tracking purposes,
  /// especially in environments where model management and lifecycle tracking are critical.
  /// </remarks>
  TModelDeletion = MistralAI.Models.TModelDeletion;

  /// <summary>
  /// The TArchivingModel class represents the state of a fine-tuned model in terms of its
  /// archiving status. It is used to track whether a model has been archived or unarchived
  /// within the MistralAI environment.
  /// </summary>
  /// <remarks>
  /// This class is primarily used for operations that involve archiving or unarchiving models.
  /// Archiving a model makes it inactive, while unarchiving restores it to an active state.
  /// The class provides properties to check the current state and to identify the model being
  /// affected.
  /// </remarks>
  TArchivingModel = MistralAI.Models.TArchivingModel;

  /// <summary>
  /// Represents an asynchronous callback parameter for retrieving a list of models.
  /// </summary>
  /// <remarks>
  /// This type is used when performing asynchronous operations to list models in the
  /// MistralAI environment. It enables the handling of the response containing a collection
  /// of models through a callback mechanism, facilitating non-blocking data retrieval.
  /// </remarks>
  TAsynModels = MistralAI.Models.TAsynModels;

  /// <summary>
  /// Represents an asynchronous callback parameter for model deletion operations.
  /// </summary>
  /// <remarks>
  /// This type is used when performing asynchronous delete operations on a model. It
  /// allows the handling of the response which indicates the status of the deletion request.
  /// This type is essential for managing deletion results in a non-blocking manner, enabling
  /// efficient UI updates or further processing based on the deletion status.
  /// </remarks>
  TAsynModelDeletion = MistralAI.Models.TAsynModelDeletion;

  /// <summary>
  /// Represents an asynchronous callback parameter for retrieving details of a specific model.
  /// </summary>
  /// <remarks>
  /// This type is used when performing asynchronous operations to fetch detailed information
  /// about a specific model. It allows for handling the response containing the model's metadata
  /// and capabilities in a non-blocking fashion. This is particularly useful for updating UI elements
  /// or triggering additional actions based on the model's properties.
  /// </remarks>
  TAsynModel = MistralAI.Models.TAsynModel;

  /// <summary>
  /// Represents an asynchronous callback parameter for updating a fine-tuned model.
  /// </summary>
  /// <remarks>
  /// This type is used during asynchronous update operations on fine-tuned models. It enables
  /// handling the response, which contains the updated model details, through a callback mechanism.
  /// This is useful for reflecting changes in the user interface or performing further processing
  /// based on the updated model information.
  /// </remarks>
  TAsynFineTuneModel = MistralAI.Models.TAsynFineTuneModel;

  /// <summary>
  /// Represents an asynchronous callback parameter for archiving or unarchiving a model.
  /// </summary>
  /// <remarks>
  /// This type is used when performing asynchronous archiving or unarchiving operations on a model.
  /// It allows handling the response, which indicates the status of the operation, in a non-blocking manner.
  /// This type is essential for updating the state of the model in the application without blocking the main thread.
  /// </remarks>
  TAsynArchivingModel = MistralAI.Models.TAsynArchivingModel;

  {$ENDREGION}

  {$REGION 'MistralAI.FineTunings'}

  /// <summary>
  /// Represents the parameters for listing fine-tuning jobs.
  /// </summary>
  /// <remarks>
  /// Allows filtering and pagination of fine-tuning jobs when retrieving them via the API.
  /// </remarks>
  TFineTuningJobListParams = MistralAI.FineTunings.TFineTuningJobListParams;

  /// <summary>
  /// Represents the hyperparameters used in a fine-tuning job.
  /// </summary>
  /// <remarks>
  /// Includes settings such as the number of training steps and the learning rate.
  /// </remarks>
  THyperparametersParams = MistralAI.FineTunings.THyperparametersParams;

  /// <summary>
  /// Represents the integration parameters for a fine-tuning job.
  /// </summary>
  /// <remarks>
  /// Specifies details for integrating with external platforms for monitoring fine-tuning jobs, such as Weights and Biases.
  /// </remarks>
  TJobIntegrationsParams = MistralAI.FineTunings.TJobIntegrationsParams;

  /// <summary>
  /// Represents the parameters required for configuring a repository in fine-tuning jobs.
  /// </summary>
  /// <remarks>
  /// This class is used to specify details about a repository, including its type, name, owner, reference,
  /// weight, and token. These parameters are typically used when setting up repositories for fine-tuning jobs.
  /// </remarks>
  TRepositoryParams = MistralAI.FineTunings.TRepositoryParams;

  /// <summary>
  /// Represents the parameters for creating a fine-tuning job.
  /// </summary>
  /// <remarks>
  /// Includes settings such as the model to fine-tune, training files, hyperparameters, and integrations.
  /// </remarks>
  TFineTuningJobParams = MistralAI.FineTunings.TFineTuningJobParams;

  /// <summary>
  /// Represents the hyperparameters output in a fine-tuning job response.
  /// </summary>
  /// <remarks>
  /// Contains the hyperparameter settings used during fine-tuning.
  /// </remarks>
  TJobOutHyperparameters = MistralAI.FineTunings.TJobOutHyperparameters;

  /// <summary>
  /// Represents the integrations output in a fine-tuning job response.
  /// </summary>
  /// <remarks>
  /// Contains information about integrations enabled for the fine-tuning job.
  /// </remarks>
  TJobOutIntegrations = MistralAI.FineTunings.TJobOutIntegrations;

  /// <summary>
  /// Represents a repository used in the context of fine-tuning jobs.
  /// </summary>
  /// <remarks>
  /// This class encapsulates information about a repository, including its type, name, owner, reference, weight, and commit ID.
  /// It is used to provide detailed metadata about the repository in fine-tuning operations.
  /// </remarks>
  TRepository = MistralAI.FineTunings.TRepository;

  /// <summary>
  /// Represents metadata associated with data used in fine-tuning jobs.
  /// </summary>
  /// <remarks>
  /// This class provides detailed information about the cost, duration, and token usage
  /// for fine-tuning operations, offering insights into resource consumption.
  /// </remarks>
  TDataMetadata = MistralAI.FineTunings.TDataMetadata;

  /// <summary>
  /// Represents the output of a fine-tuning job.
  /// </summary>
  /// <remarks>
  /// Contains details about the fine-tuning job, including its status, parameters, and results.
  /// </remarks>
  TJobOut = MistralAI.FineTunings.TJobOut;

  /// <summary>
  /// Represents a list of fine-tuning jobs.
  /// </summary>
  /// <remarks>
  /// Contains an array of fine-tuning job outputs.
  /// </remarks>
  TListFineTuningJobs = MistralAI.FineTunings.TListFineTuningJobs;

  /// <summary>
  /// Status and error dot a fine-tune job.
  /// </summary>
  TJobOutEventData = MistralAI.FineTunings.TJobOutEventData;

  /// <summary>
  /// Represents an event in the fine-tuning job lifecycle.
  /// </summary>
  /// <remarks>
  /// Contains information about status changes during the job.
  /// </remarks>
  TJobOutEvent = MistralAI.FineTunings.TJobOutEvent;

  /// <summary>
  /// Represents metrics associated with a checkpoint during fine-tuning.
  /// </summary>
  /// <remarks>
  /// Contains loss and accuracy metrics.
  /// </remarks>
  TJobOutMetrics = MistralAI.FineTunings.TJobOutMetrics;

  /// <summary>
  /// Represents a checkpoint during the fine-tuning job.
  /// </summary>
  /// <remarks>
  /// Contains metrics and timing information at a specific step.
  /// </remarks>
  TJobOutCheckpoints = MistralAI.FineTunings.TJobOutCheckpoints;

  /// <summary>
  /// Represents detailed progress information for a fine-tuning job.
  /// </summary>
  /// <remarks>
  /// Extends <see cref="TJobOut"/> with events and checkpoints.
  /// </remarks>
  TJobOutProgress = MistralAI.FineTunings.TJobOutProgress;

  /// <summary>
  /// Asynchronous callback parameters for listing fine-tuning jobs.
  /// </summary>
  TAsynListFineTuningJobs = MistralAI.FineTunings.TAsynListFineTuningJobs;

  /// <summary>
  /// Asynchronous callback parameters for fine-tuning job output.
  /// </summary>
  TAsynJobOut = MistralAI.FineTunings.TAsynJobOut;

  /// <summary>
  /// Asynchronous callback parameters for fine-tuning job progress.
  /// </summary>
  TAsynJobOutProgress = MistralAI.FineTunings.TAsynJobOutProgress;

  {$ENDREGION}

  {$REGION 'MistralAI.Codestral'}

  /// <summary>
  /// The <c>TCodestralParams</c> class represents the set of parameters used to configure the behavior and output generation of the Codestral model.
  /// </summary>
  /// <remarks>
  /// This class allows you to define various settings that control how the model generates completions, including which model to use, the temperature of the output,
  /// and how many tokens to generate. By using this class, you can customize the model's response and fine-tune its behavior to suit the specific requirements of your application.
  /// <para>
  /// It inherits from <c>TJSONParam</c>, which provides methods for handling and serializing the parameters as JSON, enabling easy integration
  /// with JSON-based APIs. The parameters include options for setting prompts, suffixes, streaming preferences, and random seeds, among others.
  /// </para>
  /// <code>
  /// var
  ///   Params: TCodestralParams;
  /// begin
  ///   Params := TCodestralParams.Create
  ///     .Model('codestral-latest')
  ///     .Prompt('Generate a code snippet')
  ///     .MaxTokens(100)
  ///     .Temperature(0.7)
  ///     .TopP(0.9)
  ///     .Stop(['\n\n'])
  ///     .Stream(True);          // or Stream();
  /// end;
  /// </code>
  /// This example demonstrates how to instantiate and configure a <c>TCodestralParams</c> object to generate a code snippet using the Codestral model.
  /// </remarks>
  TCodestralParams = MistralAI.Codestral.TCodestralParams;

  /// <summary>
  /// Represents the token usage statistics for a request, including the number of tokens used in the prompt,
  /// the completion, and the total number of tokens consumed.
  /// </summary>
  /// <remarks>
  /// The <c>TCodestralUsage</c> class provides information on the number of tokens utilized during a request.
  /// This data is essential for understanding the token cost associated with a request, particularly in contexts
  /// where token-based billing is employed, or for monitoring the model's behavior in terms of input and output sizes.
  /// </remarks>
  TCodestralUsage = MistralAI.Codestral.TCodestralUsage;

  /// <summary>
  /// Represents a message exchanged in a conversation, containing the role of the sender and the message content.
  /// </summary>
  /// <remarks>
  /// The <c>TCodestralMessage</c> class captures the essential details of a message in a chat interaction,
  /// including the role of the sender (e.g., user or assistant) and the content of the message.
  /// This class is fundamental for managing and interpreting the flow of a conversation, providing context on who sent
  /// the message and what was communicated.
  /// </remarks>
  TCodestralMessage = MistralAI.Codestral.TCodestralMessage;

  /// <summary>
  /// Represents a single completion option generated by the AI model during a chat or completion interaction.
  /// </summary>
  /// <remarks>
  /// The <c>TCodestralChoices</c> class encapsulates the details of a single choice made by the AI model.
  /// Each instance of this class represents one possible response that the model could generate.
  /// This includes:
  /// - An index indicating the position of this choice among multiple options.
  /// - A complete message response generated by the model.
  /// - Optional deltas representing partial responses in the case of streamed outputs.
  /// - The reason why the model stopped generating tokens.
  /// This class is useful when evaluating multiple response options or handling streaming outputs that build over time.
  /// </remarks>
  TCodestralChoices = MistralAI.Codestral.TCodestralChoices;

  /// <summary>
  /// Represents a codestral completion response generated by an AI model, containing metadata,
  /// generated choices, and usage statistics.
  /// </summary>
  /// <remarks>
  /// The <c>TCodestral</c> class encapsulates the results of a completion request made to an AI model.
  /// It includes details such as a unique identifier, the model used, when the completion was created,
  /// the choices generated by the model, and usage statistics.
  /// This class is essential for managing and understanding the results of AI-driven completions,
  /// as well as tracking the underlying usage and response characteristics.
  /// </remarks>
  TCodestral = MistralAI.Codestral.TCodestral;

  /// <summary>
  /// Manages asynchronous chat events for a chat request using <c>TCodestral</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynCode</c> type extends the <c>TAsynParams&lt;TCodestral&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynCode = MistralAI.Codestral.TAsynCode;

  /// <summary>
  /// Manages asynchronous streaming chat events for a chat request using <c>TCodestral</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynCodeStream</c> type extends the <c>TAsynStreamParams&lt;TCodestral&gt;</c> record to support the lifecycle of an asynchronous streaming chat operation.
  /// It provides callbacks for different stages, including when the operation starts, progresses with new data chunks, completes successfully, or encounters an error.
  /// This structure is ideal for handling scenarios where the chat response is streamed incrementally, providing real-time updates to the user interface.
  /// </remarks>
  TAsynCodeStream = MistralAI.Codestral.TAsynCodeStream;

  /// <summary>
  /// Represents a callback procedure used during the reception of responses from a codestral request in streaming mode.
  /// </summary>
  /// <param name="Codestral">
  /// The <c>TCodestral</c> object containing the current information about the response generated by the model.
  /// If this value is <c>nil</c>, it indicates that the data stream is complete.
  /// </param>
  /// <param name="IsDone">
  /// A boolean flag indicating whether the streaming process is complete.
  /// If <c>True</c>, it means the model has finished sending all response data.
  /// </param>
  /// <param name="Cancel">
  /// A boolean flag that can be set to <c>True</c> within the callback to cancel the streaming process.
  /// If set to <c>True</c>, the streaming will be terminated immediately.
  /// </param>
  /// <remarks>
  /// This callback is invoked multiple times during the reception of the response data from the model.
  /// It allows for real-time processing of received messages and interaction with the user interface or other systems
  /// based on the state of the data stream.
  /// When the <c>IsDone</c> parameter is <c>True</c>, it indicates that the model has finished responding,
  /// and the <c>Codestral</c> parameter will be <c>nil</c>.
  /// </remarks>
  TCodestralEvent = MistralAI.Codestral.TCodestralEvent;

  {$ENDREGION}

  {$REGION 'MistralAI.Files'}

  /// <summary>
  /// Parameters for uploading a file.
  /// </summary>
  /// <remarks>
  /// This class is used to construct the multipart form data for file uploads.
  /// Example usage:
  /// <code>
  /// var
  ///   UploadParams: TUploadParams;
  /// begin
  ///   UploadParams := TUploadParams.Create;
  ///   try
  ///     UploadParams.File('path/to/file.jsonl');
  ///     UploadParams.Purpose(TFilePurpose.finetune);
  ///     // Use UploadParams with the API upload method
  ///   finally
  ///     UploadParams.Free;
  ///   end;
  /// end;
  /// </code>
  /// </remarks>
  TUploadParams = MistralAI.Files.TUploadParams;

  /// <summary>
  /// Represents the parameters for listing files with specific criteria.
  /// </summary>
  /// <remarks>
  /// This class is used to configure and pass parameters when listing files from the API.
  /// It provides methods to set pagination, filtering, and searching options.
  /// </remarks>
  TListParams = MistralAI.Files.TListParams;

  /// <summary>
  /// Represents a file in the Mistral AI system.
  /// </summary>
  /// <remarks>
  /// This class contains properties that represent the attributes of a file as returned by the API.
  /// </remarks>
  TFile = MistralAI.Files.TFile;

  /// <summary>
  /// Represents a collection of files.
  /// </summary>
  /// <remarks>
  /// This class is used to hold a list of files as returned by the API.
  /// Example usage:
  /// <code>
  /// var
  ///   Files: TFiles;
  ///   FileItem: TFile;
  /// begin
  ///   Files := FilesRoute.List;
  ///   try
  ///     for FileItem in Files.Data do
  ///     begin
  ///       // Process each file
  ///     end;
  ///   finally
  ///     Files.Free;
  ///   end;
  /// end;
  /// </code>
  /// </remarks>
  TFiles = MistralAI.Files.TFiles;

  /// <summary>
  /// Represents the result of a file deletion operation.
  /// </summary>
  /// <remarks>
  /// Contains information about the deletion status and the ID of the deleted file.
  /// </remarks>
  TDeletedResult = MistralAI.Files.TDeletedResult;

  /// <summary>
  /// Represents a downloaded file, providing functionality to access and save its data.
  /// </summary>
  /// <remarks>
  /// This class encapsulates a downloaded file and provides methods to retrieve its data as a stream
  /// or save it to a file. The file data is expected to be in a base64-encoded format.
  /// </remarks>
  TDownLoadFile = MistralAI.Files.TDownLoadFile;

  /// <summary>
  /// Asynchronous callback parameters for operations returning a single <c>TFile</c>.
  /// </summary>
  /// <remarks>
  /// Used when performing asynchronous operations that return a <c>TFile</c> instance.
  /// </remarks>
  TAsynFile = MistralAI.Files.TAsynFile;

  /// <summary>
  /// Asynchronous callback parameters for operations returning <c>TFiles</c>.
  /// </summary>
  /// <remarks>
  /// Used when performing asynchronous operations that return a <c>TFiles</c> instance.
  /// </remarks>
  TAsynFiles = MistralAI.Files.TAsynFiles;

  /// <summary>
  /// Asynchronous callback parameters for file deletion operations.
  /// </summary>
  /// <remarks>
  /// Used when performing asynchronous operations that return a <c>TDeletedResult</c> instance.
  /// </remarks>
  TAsynFilesDelete = MistralAI.Files.TAsynFilesDelete;

  /// <summary>
  /// Asynchronous callback parameters for file download operations.
  /// </summary>
  /// <remarks>
  /// Used when performing asynchronous operations that return a <c>TDownLoadFile</c> instance.
  /// </remarks>
  TAsynDownLoadFile = MistralAI.Files.TAsynDownLoadFile;

  {$ENDREGION}

  {$REGION 'MistralAI.Functions.Tools'}

  /// <summary>
  /// Represents a tool used for interacting with chat messages, including the ability to convert
  /// functions to JSON format.
  /// </summary>
  TChatMessageTool = MistralAI.Functions.Tools.TChatMessageTool;

  /// <summary>
  /// Represents the specifics of a called function, including its name and calculated arguments.
  /// </summary>
  TCalledFunctionSpecifics = MistralAI.Functions.Tools.TCalledFunctionSpecifics;

  /// <summary>
  /// Represents a called function, containing its specifics such as name and arguments.
  /// </summary>
  TCalledFunction = MistralAI.Functions.Tools.TCalledFunction;

  {$ENDREGION}

  {$REGION 'MistralAI.Agents'}

  /// <summary>
  /// Alias for <c>TChatMessagePayload</c>, representing an agent message payload.
  /// </summary>
  TAgentMessagePayload = MistralAI.Agents.TAgentMessagePayload;

  /// <summary>
  /// Provides methods to interact with agents, including creating completions and handling asynchronous operations.
  /// </summary>
  /// <remarks>
  /// Use this class to manage agent interactions, including synchronous and asynchronous requests.
  /// </remarks>
  TAgentParams = MistralAI.Agents.TAgentParams;

  {$ENDREGION}

  {$REGION 'MistralAI.Functions.Core'}

  /// <summary>
  /// Interface defining the core structure and functionality of a function in the system.
  /// </summary>
  /// <remarks>
  /// This interface outlines the basic properties and methods that any function implementation must include.
  /// </remarks>
  IFunctionCore = MistralAI.Functions.Core.IFunctionCore;

  /// <summary>
  /// Abstract base class for implementing core function behavior.
  /// </summary>
  /// <remarks>
  /// This class provides basic implementations for some methods and defines the structure that derived classes must follow.
  /// </remarks>
  TFunctionCore = MistralAI.Functions.Core.TFunctionCore;

  {$ENDREGION}

  {$REGION 'MistralAI.Classifiers'}

  /// <summary>
  /// <c>TModerationParams</c> class to manage params for guardrails in a text.
  /// </summary>
  /// <remarks>
  /// The policy threshold is determined based on the optimal performance of oan internal test set.
  /// You can use the raw score or adjust the threshold according to your specific use cases.
  /// </remarks>
  TModerationParams = MistralAI.Classifiers.TModerationParams;

  /// <summary>
  /// <c>TModerationChatParams</c> class to manage params for guardrails in a chat generation.
  /// </summary>
  /// <remarks>
  /// The policy threshold is determined based on the optimal performance of oan internal test set.
  /// You can use the raw score or adjust the threshold according to your specific use cases.
  /// </remarks>
  TModerationChatParams = MistralAI.Classifiers.TModerationChatParams;

  /// <summary>
  /// <c>TModerationCategories</c> class defines the categories for moderation checks.
  /// </summary>
  /// <remarks>
  /// This class provides a structured representation of the moderation categories
  /// used to evaluate the content against predefined guardrails. Each property corresponds
  /// to a specific moderation category and indicates whether the content violates that category.
  /// </remarks>
  TModerationCategories = MistralAI.Classifiers.TModerationCategories;

  /// <summary>
  /// <c>TModerationScores</c> class defines the scoring system for moderation categories.
  /// </summary>
  /// <remarks>
  /// This class provides a structured representation of the scores associated with each moderation category.
  /// Each property contains a numerical value indicating the likelihood that the content violates the corresponding category.
  /// </remarks>
  TModerationScores = MistralAI.Classifiers.TModerationScores;

  /// <summary>
  /// Represents a warning item in the moderation results, containing the category and its associated score.
  /// </summary>
  /// <remarks>
  /// This record is used to store information about a specific moderation category violation,
  /// including the category name and the numerical score indicating the likelihood of the violation.
  /// </remarks>
  TWarningItem = MistralAI.Classifiers.TWarningItem;

  /// <summary>
  /// <c>TModerationResult</c> class represents the results of a moderation check.
  /// </summary>
  /// <remarks>
  /// This class contains information about the moderation categories and their associated scores.
  /// It provides a detailed breakdown of whether content violates predefined moderation categories
  /// and the likelihood of such violations.
  /// </remarks>
  TModerationResult = MistralAI.Classifiers.TModerationResult;

  /// <summary>
  /// <c>TModeration</c> class represents the overall result of a moderation request.
  /// </summary>
  /// <remarks>
  /// This class provides a high-level summary of the moderation operation,
  /// including the request ID, the model used for moderation, and the detailed results
  /// for each category and score. It is the main structure returned by the moderation API.
  /// </remarks>
  TModeration = MistralAI.Classifiers.TModeration;

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TModeration</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynModeration</c> type extends the <c>TAsynParams&lt;TModeration&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynModeration = MistralAI.Classifiers.TAsynModeration;

  {$ENDREGION}

  {$REGION 'MistralAI.Batch'}

  /// <summary>
  /// Represents a class for constructing and managing query parameters to list batch jobs in the MistralAI API.
  /// </summary>
  /// <remarks>
  /// This class provides methods to define filters such as page size, model name, creation date, and batch status,
  /// allowing precise control over the listing of batch jobs.
  /// </remarks>
  TBatchJobListParams = MistralAI.Batch.TBatchJobListParams;

  /// <summary>
  /// Represents a class for managing parameters required to create a batch job for the MistralAI API.
  /// This class, <c>TBatchJobParams</c>, extends <c>TJSONParam</c> to construct and handle JSON payloads for batch job creation.
  ///</summary>
  ///<remarks>
  /// A batch job consists of multiple API requests, each identified by a unique <c>custom_id</c>.
  /// This class simplifies the process of defining the parameters and generating the required JSON payloads for a batch job.
  ///</remarks>
  TBatchJobParams = MistralAI.Batch.TBatchJobParams;

  /// <summary>
  /// Represents a class for capturing error information related to batch job processing in the MistralAI API.
  /// </summary>
  /// <remarks>
  /// This class provides details about errors encountered during batch job processing, including error messages and counts.
  /// </remarks>
  TBatchJobListDataError = MistralAI.Batch.TBatchJobListDataError;

  /// <summary>
  /// Represents a batch job in the MistralAI API.
  /// </summary>
  /// <remarks>
  /// A batch job contains details about the processing status, input files, model used, metadata, and
  /// the results of the batch operation.
  /// </remarks>
  TBatchJob = MistralAI.Batch.TBatchJob;

  /// <summary>
  /// Represents a collection of batch jobs in the MistralAI API.
  /// </summary>
  /// <remarks>
  /// This class contains a list of batch jobs along with metadata about the collection,
  /// such as the total number of jobs and the object type.
  /// </remarks>
  TBatchJobList = MistralAI.Batch.TBatchJobList;

  /// <summary>
  /// Asynchronous callback parameters for operations returning a single <c>TBatchJob</c>.
  /// </summary>
  /// <remarks>
  /// Used when performing asynchronous operations that return a <c>TBatchJob</c> instance.
  /// </remarks>
  TAsynBatchJob = MistralAI.Batch.TAsynBatchJob;

  /// <summary>
  /// Asynchronous callback parameters for operations returning a single <c>TBatchJobList</c>.
  /// </summary>
  /// <remarks>
  /// Used when performing asynchronous operations that return a <c>TBatchJobList</c> instance.
  /// </remarks>
  TAsynBatchJobList = MistralAI.Batch.TAsynBatchJobList;

  {$ENDREGION}

implementation

{ TMistralAI }

constructor TMistralAI.Create;
begin
  inherited;
  FAPI := TMistralAIAPI.Create;
end;

procedure TMistralAI.CodestralCheck;
begin
  if not (CodestralSpec in FSpecs) then
    raise Exception.Create(
       'The MistralAI instance cannot manage "Codestral", for this you must indicate '+
       '[CodestralSpec] as a specification when instantiating the TMistralAI type interface:'#13#13+
       '   TMistralAI.Create(''Your key'', [CodestralSpec])');
end;

constructor TMistralAI.Create(const AToken: string; Specs: TSpecs);
begin
  Create;
  Token := AToken;

  {--- Managing specifications for an instance of the class }
  if CodestralSpec in Specs then
    begin
      FSpecs := FSpecs + [CodestralSpec];
      FAPI.BaseUrl := TMistralAIAPI.URL_BASE_CODESTRAL;
    end;
end;

destructor TMistralAI.Destroy;
begin
  FModelsRoute.Free;
  FEmbeddingsRoute.Free;
  FAgentRoute.Free;
  FChatRoute.Free;
  if CodestralSpec in FSpecs then
    FCodestralRoute.Free;
  FFileRoute.Free;
  FFineTuningRoute.Free;
  FClassifiersRoute.Free;
  FBatchRoute.Free;
  FAPI.Free;
  inherited;
end;

function TMistralAI.GetAgentRoute: TAgentRoute;
begin
  if not Assigned(FAgentRoute) then
    FAgentRoute := TAgentRoute.CreateRoute(API);
  Result := FAgentRoute;
end;

function TMistralAI.GetAPI: TMistralAIAPI;
begin
  Result := FAPI;
end;

function TMistralAI.GetBaseUrl: string;
begin
  Result := FAPI.BaseURL;
end;

function TMistralAI.GetBatchRoute: TBatchRoute;
begin
  if not Assigned(FBatchRoute) then
    FBatchRoute := TBatchRoute.CreateRoute(API);
  Result := FBatchRoute;
end;

function TMistralAI.GetChatRoute: TChatRoute;
begin
  if not Assigned(FChatRoute) then
    FChatRoute := TChatRoute.CreateRoute(API);
  Result := FChatRoute;
end;

function TMistralAI.GetClassifiersRoute: TClassifiersRoute;
begin
  if not Assigned(FClassifiersRoute) then
    FClassifiersRoute := TClassifiersRoute.CreateRoute(API);
  Result := FClassifiersRoute;
end;

function TMistralAI.GetCodestralRoute: TCodestralRoute;
begin
  CodestralCheck;
  if not Assigned(FCodestralRoute) then
    FCodestralRoute := TCodestralRoute.CreateRoute(API);
  Result := FCodestralRoute;
end;

function TMistralAI.GetEmbeddingsRoute: TEmbeddingsRoute;
begin
  if not Assigned(FEmbeddingsRoute) then
    FEmbeddingsRoute := TEmbeddingsRoute.CreateRoute(API);
  Result := FEmbeddingsRoute;
end;

function TMistralAI.GetFilesRoute: TFilesRoute;
begin
  if not Assigned(FFileRoute) then
    FFileRoute := TFilesRoute.CreateRoute(API);
  Result := FFileRoute;
end;

function TMistralAI.GetFineTuningRoute: TFineTuningRoute;
begin
  if not Assigned(FFineTuningRoute) then
    FFineTuningRoute := TFineTuningRoute.CreateRoute(API);
  Result := FFineTuningRoute;
end;

function TMistralAI.GetModelsRoute: TModelsRoute;
begin
  if not Assigned(FModelsRoute) then
    FModelsRoute := TModelsRoute.CreateRoute(API);
  Result := FModelsRoute;
end;

function TMistralAI.GetToken: string;
begin
  Result := FAPI.Token;
end;

procedure TMistralAI.SetBaseUrl(const Value: string);
begin
  FAPI.BaseURL := Value;
end;

procedure TMistralAI.SetToken(const Value: string);
begin
  FAPI.Token := Value;
end;

{ TMistralAIFactory }

class function TMistralAIFactory.CreateInstance(const AToken: string;
  Specs: TSpecs): IMistralAI;
begin
  Result := TMistralAI.Create(AToken, Specs);
end;

end.

unit MistralAI.Schema;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, REST.Json.Types,
  MistralAI.API.Params;

type
  /// <summary>
  /// Type contains the list of OpenAPI data types as defined by https://spec.openapis.org/oas/v3.0.3#data-types
  /// </summary>
  TSchemaType = (
    /// <summary>
    /// Not specified, should not be used.
    /// </summary>
    TYPE_UNSPECIFIED,
    /// <summary>
    /// String type.
    /// </summary>
    stSTRING,
    /// <summary>
    /// Number type.
    /// </summary>
    stNUMBER,
    /// <summary>
    /// Integer type.
    /// </summary>
    stINTEGER,
    /// <summary>
    /// Boolean type.
    /// </summary>
    stBOOLEAN,
    /// <summary>
    /// Array type.
    /// </summary>
    stARRAY,
    /// <summary>
    /// Object type.
    /// </summary>
    stOBJECT
  );

  /// <summary>
  /// Helper record for the <c>TSchemaType</c> enumeration, providing utility methods for converting
  /// between <c>TSchemaType</c> values and their string representations.
  /// </summary>
  TSchemaTypeHelper = record helper for TSchemaType
    /// <summary>
    /// Converts the current <c>TSchemaType</c> value to its corresponding string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>TSchemaType</c> value.
    /// </returns>
    function ToString: string;
  end;

  TSchemaParams = class;

  /// <summary>
  /// Provides helper methods for creating property items in OpenAPI schema definitions.
  /// </summary>
  /// <remarks>
  /// This record simplifies the creation of property entries when building schema objects,
  /// particularly for object properties in OpenAPI specifications.
  /// </remarks>
  TPropertyItem = record
  public
    /// <summary>
    /// Creates a JSON pair representing a property in a schema object.
    /// </summary>
    /// <param name="Key">The name of the property.</param>
    /// <param name="Value">The data type of the property as a <c>TSchemaType</c>.</param>
    /// <returns>A <c>TJSONPair</c> representing the property key-value pair.</returns>
    /// <remarks>
    /// This method facilitates the addition of properties to schema objects by creating
    /// a JSON pair with the specified key and data type.
    /// </remarks>
    class function Add(Key: string; Value: TSchemaType): TJSONPair; static;
  end;

  /// <summary>
  /// Represents the Schema Object in OpenAPI, enabling the definition of input and output data types.
  /// These types can be objects, primitives, or arrays. This class provides methods to build and
  /// configure schema definitions as per the OpenAPI 3.0 Specification.
  /// </summary>
  /// <remarks>
  /// The Schema Object allows the definition of input and output data types in the OpenAPI Specification.
  /// This class provides a fluent interface to construct schema definitions programmatically.
  /// </remarks>
  TSchemaParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the data type of the schema.
    /// </summary>
    /// <param name="Value">The data type to assign to the schema, specified as a <c>TSchemaType</c> value.</param>
    /// <returns>The current <c>TSchemaParams</c> instance to allow for method chaining.</returns>
    /// <remarks>
    /// The <c>type</c> keyword is required in the Schema Object to define the data type.
    /// Valid types include <c>string</c>, <c>number</c>, <c>integer</c>, <c>boolean</c>, <c>array</c>, and <c>object</c>.
    /// </remarks>
    function &Type(const Value: TSchemaType): TSchemaParams;
    /// <summary>
    /// Specifies the format of the data type.
    /// </summary>
    /// <param name="Value">The format of the data type, as a string.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>format</c> keyword is an optional modifier to provide more fine-grained data type information.
    /// Common formats include <c>int32</c>, <c>int64</c> for <c>integer</c> types; <c>float</c>, <c>double</c>
    /// for <c>number</c> types; and <c>byte</c>, <c>binary</c>, <c>date</c>, <c>date-time</c>, <c>password</c> for <c>string</c> types.
    /// </remarks>
    function Format(const Value: string): TSchemaParams;
    /// <summary>
    /// Adds a description to the schema.
    /// </summary>
    /// <param name="Value">A brief description of the schema. Supports Markdown for formatting.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>description</c> keyword provides a description of the schema and can include examples of use.
    /// This field supports Markdown syntax for rich text representation.
    /// </remarks>
    function Description(const Value: string): TSchemaParams;
    /// <summary>
    /// Specifies whether the schema's value can be null.
    /// </summary>
    /// <param name="Value">A boolean indicating if the schema allows null values.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>nullable</c> keyword is a boolean property that indicates if the value of the schema can be null.
    /// By default, this is false.
    /// </remarks>
    function Nullable(const Value: Boolean): TSchemaParams;
    /// <summary>
    /// Specifies an enumeration of possible values.
    /// </summary>
    /// <param name="Value">An array of string values that the schema can take.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>enum</c> keyword restricts the value of the schema to a fixed set of values.
    /// The schema's type must be <c>string</c> when using enum.
    /// </remarks>
    function Enum(const Value: TArray<string>): TSchemaParams;
    /// <summary>
    /// Specifies the maximum number of items allowed in an array schema.
    /// </summary>
    /// <param name="Value">The maximum number of items as a string.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>maxItems</c> keyword applies to schemas of type <c>array</c> and restricts the maximum number
    /// of items the array can contain.
    /// </remarks>
    function MaxItems(const Value: string): TSchemaParams;
    /// <summary>
    /// Specifies the minimum number of items required in an array schema.
    /// </summary>
    /// <param name="Value">The minimum number of items as a string.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>minItems</c> keyword applies to schemas of type <c>array</c> and defines the minimum number
    /// of items the array must contain.
    /// </remarks>
    function MinItems(const Value: string): TSchemaParams;
    /// <summary>
    /// Adds a property to an object schema.
    /// </summary>
    /// <param name="Key">The name of the property.</param>
    /// <param name="Value">A <c>TSchemaParams</c> instance defining the property's schema.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>properties</c> keyword is used to define the properties of an object schema.
    /// Each property is a key-value pair where the key is the property name and the value is a schema defining the property.
    /// </remarks>
    function Properties(const Key: string; const Value: TSchemaParams): TSchemaParams; overload;
    /// <summary>
    /// Adds a property to an object schema using a parameterized procedure to configure the property's schema.
    /// </summary>
    /// <param name="Key">The name of the property.</param>
    /// <param name="ParamProc">A procedure that takes a <c>TSchemaParams</c> instance to configure the property's schema.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// This overload allows you to define the property's schema inline using a procedural configuration.
    /// </remarks>
    function Properties(const Key: string; const ParamProc: TProcRef<TSchemaParams>): TSchemaParams; overload;
    /// <summary>
    /// Adds multiple properties to an object schema.
    /// </summary>
    /// <param name="Value">An array of <c>TJSONPair</c> instances representing the properties.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// This overload allows adding multiple properties at once to the object schema.
    /// </remarks>
    function Properties(const Value: TArray<TJSONPair>): TSchemaParams; overload;
    /// <summary>
    /// Specifies which properties are required in an object schema.
    /// </summary>
    /// <param name="Value">An array of property names that are required.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>required</c> keyword lists the property names that must be included when an object instance
    /// is validated against the schema.
    /// </remarks>
    function Required(const Value: TArray<string>): TSchemaParams;
    /// <summary>
    /// Specifies the schema of the items in an array schema.
    /// </summary>
    /// <param name="Value">A <c>TSchemaParams</c> instance defining the schema of the array items.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>items</c> keyword is used in array schemas to define the schema of each item in the array.
    /// </remarks>
    function Items(const Value: TSchemaParams): TSchemaParams; overload;
    /// <summary>
    /// Specifies the schema of the items in an array schema using a parameterized procedure.
    /// </summary>
    /// <param name="ParamProc">A procedure that configures a <c>TSchemaParams</c> instance to define the array items' schema.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// This overload allows you to define the items' schema inline using a procedural configuration.
    /// </remarks>
    function Items(const ParamProc: TProcRef<TSchemaParams>): TSchemaParams; overload;
    /// <summary>
    /// Creates a new instance of <c>TSchemaParams</c>.
    /// </summary>
    /// <returns>A new <c>TSchemaParams</c> instance.</returns>
    class function New: TSchemaParams; overload;
    /// <summary>
    /// Creates and configures a new instance of <c>TSchemaParams</c> using a parameterized procedure.
    /// </summary>
    /// <param name="ParamProc">A procedure that configures the new <c>TSchemaParams</c> instance.</param>
    /// <returns>A new <c>TSchemaParams</c> instance.</returns>
    /// <remarks>
    /// This overload allows you to create and configure the instance inline.
    /// </remarks>
    class function New(const ParamProc: TProcRef<TSchemaParams>): TSchemaParams; overload;
  end;

implementation

uses
  System.StrUtils, System.Rtti, Rest.Json;

{ TSchemaTypeHelper }

function TSchemaTypeHelper.ToString: string;
begin
  case Self of
    TYPE_UNSPECIFIED:
      Exit('type_unspecified');
    stSTRING:
      Exit('string');
    stNUMBER:
      Exit('number');
    stINTEGER:
      Exit('integer');
    stBOOLEAN:
      Exit('boolean');
    stARRAY:
      Exit('array');
    stOBJECT:
      Exit('object');
  end;
end;

{ TSchemaParams }

function TSchemaParams.Description(const Value: string): TSchemaParams;
begin
  Result := TSchemaParams(Add('description', Value));
end;

function TSchemaParams.Enum(const Value: TArray<string>): TSchemaParams;
begin
  Result := TSchemaParams(Add('enum', Value));
end;

function TSchemaParams.Format(const Value: string): TSchemaParams;
begin
  Result := TSchemaParams(Add('format', Value));
end;

function TSchemaParams.Items(
  const ParamProc: TProcRef<TSchemaParams>): TSchemaParams;
begin
  if Assigned(ParamProc) then
    begin
      var Value := TSchemaParams.Create;
      ParamProc(Value);
      Result := Items(Value);
    end
  else Result := Self;
end;

function TSchemaParams.Items(const Value: TSchemaParams): TSchemaParams;
begin
  Result := TSchemaParams(Add('items', Value.Detach));
end;

function TSchemaParams.MaxItems(const Value: string): TSchemaParams;
begin
  Result := TSchemaParams(Add('maxItems', Value));
end;

function TSchemaParams.MinItems(const Value: string): TSchemaParams;
begin
  Result := TSchemaParams(Add('minItems', Value));
end;

class function TSchemaParams.New: TSchemaParams;
begin
  Result := TSchemaParams.Create;
end;

class function TSchemaParams.New(
  const ParamProc: TProcRef<TSchemaParams>): TSchemaParams;
begin
  Result := TSchemaParams.Create;
  if Assigned(ParamProc) then
    begin
      ParamProc(Result);
    end;
end;

function TSchemaParams.Nullable(const Value: Boolean): TSchemaParams;
begin
  Result := TSchemaParams(Add('nullable', Value.ToString));
end;

function TSchemaParams.Properties(
  const Value: TArray<TJSONPair>): TSchemaParams;
begin
  var JSONValue := TJSONObject.Create;
  for var Item in Value do
    begin
      JSONValue.AddPair(Item);
    end;
  Result := TSchemaParams(Add('properties', JSONValue));
end;

function TSchemaParams.Properties(const Key: string;
  const ParamProc: TProcRef<TSchemaParams>): TSchemaParams;
begin
  if Assigned(ParamProc) then
    begin
      var Value := TSchemaParams.Create;
      ParamProc(Value);
      Result := Properties(Key, Value);
    end
  else Result := Self;
end;

function TSchemaParams.Properties(const Key: string;
  const Value: TSchemaParams): TSchemaParams;
begin
  Result := TSchemaParams(Add(Key, Value.Detach));
end;

function TSchemaParams.Required(const Value: TArray<string>): TSchemaParams;
begin
  Result := TSchemaParams(Add('required', Value));
end;

function TSchemaParams.&Type(const Value: TSchemaType): TSchemaParams;
begin
  Result := TSchemaParams(Add('type', Value.ToString));
end;

{ TPropertyItem }

class function TPropertyItem.Add(Key: string; Value: TSchemaType): TJSONPair;
begin
  Result := TJSONPair.Create(Key, Value.ToString);
end;

end.

unit MistralAI.Tutorial.FMX;

{ Tutorial Support Unit

   WARNING:
     This module is intended solely to illustrate the examples provided in the
     README.md file of the repository :
          https://github.com/MaxiDonkey/DelphiMistralAI
     Under no circumstances should the methods described below be used outside
     of the examples presented on the repository's page.
}

interface

uses
  System.SysUtils, System.Classes, Winapi.Messages, FMX.Types, FMX.StdCtrls, FMX.ExtCtrls,
  FMX.Controls, FMX.Forms, Winapi.Windows, FMX.Graphics, FMX.Dialogs, FMX.Memo.Types,
  FMX.Media, FMX.Objects, FMX.Controls.Presentation, FMX.ScrollBox, FMX.Memo, System.UITypes,
  System.Types,
  MistralAI, MistralAI.Types, MistralAI.Functions.Core;

type
  TToolProc = procedure (const Value: TCalledFunction; Func: IFunctionCore) of object;

  /// <summary>
  /// Represents a tutorial hub for handling visual components in a Delphi application,
  /// including text display, button interactions, and navigation through pages.
  /// </summary>
  TFMXTutorialHub = class
  private
    FMemo1: TMemo;
    FMemo2: TMemo;
    FButton: TButton;
    FFileId: string;
    FJobId: string;
    FBatchId: string;
    FFileName: string;
    FTool: IFunctionCore;
    FToolCall: TToolProc;
    FPage: Integer;
    FFileOverride: Boolean;
    FCancel: Boolean;
    procedure OnButtonClick(Sender: TObject);
    procedure SetButton(const Value: TButton);
    procedure SetMemo1(const Value: TMemo);
    procedure SetMemo2(const Value: TMemo);
  public
    /// <summary>
    /// Advances the tutorial to the next page.
    /// </summary>
    procedure NextPage;
    /// <summary>
    /// Gets or sets the first memo component for displaying messages or data.
    /// </summary>
    property Memo1: TMemo read FMemo1 write SetMemo1;
    /// <summary>
    /// Gets or sets the second memo component for displaying additional messages or data.
    /// </summary>
    property Memo2: TMemo read FMemo2 write SetMemo2;
    /// <summary>
    /// Gets or sets the button component used to trigger actions or handle cancellation.
    /// </summary>
    property Button: TButton read FButton write SetButton;
    /// <summary>
    /// Gets or sets a value indicating whether the operation has been canceled.
    /// </summary>
    property Cancel: Boolean read FCancel write FCancel;
    /// <summary>
    /// Gets or sets the file identifier associated with the tutorial hub.
    /// </summary>
    property FileId: string read FFileId write FFileId;
    /// <summary>
    /// Gets or sets the job identifier associated with the tutorial hub.
    /// </summary>
    property JobId: string read FJobId write FJobId;
    /// <summary>
    /// Gets or sets the batch identifier associated with the tutorial hub.
    /// </summary>
    property BatchId: string read FBatchId write FBatchId;
    /// <summary>
    /// Gets or sets the name of the file associated with the tutorial hub.
    /// </summary>
    property FileName: string read FFileName write FFileName;
    /// <summary>
    /// Gets or sets the core function tool used for processing.
    /// </summary>
    property Tool: IFunctionCore read FTool write FTool;
    /// <summary>
    /// Gets or sets the procedure for handling tool-specific calls.
    /// </summary>
    property ToolCall: TToolProc read FToolCall write FToolCall;
    /// <summary>
    /// Gets or sets the current page number within the tutorial.
    /// </summary>
    property Page: Integer read FPage write FPage;
    /// <summary>
    /// Gets or sets a value indicating whether file overrides are allowed.
    /// </summary>
    property FileOverride: Boolean read FFileOverride write FFileOverride;
    constructor Create(const AMemo1, AMemo2: TMemo; const AButton: TButton);
  end;

  procedure Cancellation(Sender: TObject);
  function DoCancellation: Boolean;
  procedure Start(Sender: TObject);

  procedure Display(Sender: TObject); overload;
  procedure Display(Sender: TObject; Value: string); overload;
  procedure Display(Sender: TObject; Value: TArray<string>); overload;
  procedure Display(Sender: TObject; Value: TChat); overload;
  procedure Display(Sender: TObject; Value: TCodestral); overload;
  procedure Display(Sender: TObject; Value: TEmbeddings); overload;
  procedure Display(Sender: TObject; Value: TModel); overload;
  procedure Display(Sender: TObject; Value: TModels); overload;
  procedure Display(Sender: TObject; Value: TModerationResult); overload;
  procedure DisplayEx(Sender: TObject; Value: TModerationResult); overload;
  procedure Display(Sender: TObject; Value: TModeration); overload;
  procedure DisplayEx(Sender: TObject; Value: TModeration); overload;
  procedure Display(Sender: TObject; Value: TFile); overload;
  procedure Display(Sender: TObject; Value: TFiles); overload;
  procedure Display(Sender: TObject; Value: TDeletedResult); overload;
  procedure Display(Sender: TObject; Value: TDownLoadFile); overload;
  procedure Display(Sender: TObject; Value: TJobOut); overload;
  procedure Display(Sender: TObject; Value: TJobOutProgress); overload;
  procedure Display(Sender: TObject; Value: TListFineTuningJobs); overload;
  procedure Display(Sender: TObject; Value: TBatchJob); overload;
  procedure Display(Sender: TObject; Value: TBatchJobList); overload;

  procedure DisplayStream(Sender: TObject; Value: string); overload;
  procedure DisplayStream(Sender: TObject; Value: TChat); overload;
  procedure DisplayStream(Sender: TObject; Value: TCodestral); overload;

  function F(const Name, Value: string): string; overload;
  function F(const Name: string; const Value: TArray<string>): string; overload;
  function F(const Name: string; const Value: boolean): string; overload;
  function F(const Name: string; const State: Boolean; const Value: Double): string; overload;

  function CodeBefore: string;
  function CodeAfter: string;

var
  /// <summary>
  /// A global instance of the <see cref="TVCLTutorialHub"/> class used as the main tutorial hub.
  /// </summary>
  /// <remarks>
  /// This variable serves as the central hub for managing tutorial components, such as memos, buttons, and pages.
  /// It is initialized dynamically during the application's runtime, and its memory is automatically released during
  /// the application's finalization phase.
  /// </remarks>
  TutorialHub: TFMXTutorialHub = nil;

implementation

uses
  System.DateUtils;

function UnixIntToDateTime(const Value: Int64): TDateTime;
begin
  Result := TTimeZone.Local.ToLocalTime(UnixToDateTime(Value));
end;

function UnixDateTimeToString(const Value: Int64): string;
begin
  Result := DateTimeToStr(UnixIntToDateTime(Value))
end;

procedure Cancellation(Sender: TObject);
begin
  Display(Sender, 'The operation was cancelled' + sLineBreak);
  TutorialHub.Cancel := False;
end;

function DoCancellation: Boolean;
begin
  Result := TutorialHub.Cancel;
end;

procedure Start(Sender: TObject);
begin
  Display(Sender, 'Please wait...');
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: string);
var
  M: TMemo;
begin
  if Sender is TMemo then
    M := Sender as TMemo else
    M := (Sender as TFMXTutorialHub).Memo1;
  M.Lines.Add(Value);
  M.ViewportPosition := PointF(M.ViewportPosition.X, M.Content.Height - M.Height);
end;

procedure Display(Sender: TObject; Value: TArray<string>);
begin
  var index := 0;
  for var Item in Value do
    begin
      if not Item.IsEmpty then
        begin
          if index = 0 then
            Display(Sender, Item) else
            Display(Sender, '    ' + Item);
        end;
      Inc(index);
    end;
end;

procedure Display(Sender: TObject);
begin
  Display(Sender, sLineBreak);
end;

procedure Display(Sender: TObject; Value: TChat);
begin
  for var Item in Value.Choices do
    if Item.FinishReason = TFinishReason.tool_calls then
      begin
        if Assigned(TutorialHub.ToolCall) then
          TutorialHub.ToolCall(Item.Message.ToolsCalls[0], TutorialHub.Tool);
      end
    else
      begin
        Display(Sender, Item.Message.Content);
      end;
end;

procedure Display(Sender: TObject; Value: TCodestral); overload;
begin
  for var Item in Value.Choices do
    if Item.FinishReason = TCodestralFinishReason.cstool_calls then
      begin
        if Assigned(TutorialHub.ToolCall) then
          TutorialHub.ToolCall(Item.Message.ToolsCalls[0], TutorialHub.Tool);
      end
    else
      begin
        Display(Sender, Item.Message.Content);
      end;
end;

procedure Display(Sender: TObject; Value: TEmbeddings); overload;
begin
  var i := 0;
  for var Item in Value.Data do
    begin
      var j := 0;
      for var SubItem in Item.Embedding do
          begin
            Display(Sender, Format('Vector[%d, %d] = %s', [i, j, SubItem.ToString(ffNumber, 8, 8)]));
            Inc(j);
            Application.ProcessMessages;
          end;
      Display(Sender);
      Inc(i);
    end;
end;

procedure Display(Sender: TObject; Value: TModel);
begin
  Display(Sender, [
    Value.Id,
    F('Name', Value.Name),
    F('Description', Value.Description),
    F('Deprecation', Value.Deprecation),
    F('Default temperature', Value.DefaultModelTemperature.ToString(ffNumber, 3, 2)),
    F('Completion chat', BoolToStr(Value.Capabilities.CompletionChat, True)),
    F('Completion fim', BoolToStr(Value.Capabilities.CompletionFim, True)),
    F('Function calling', BoolToStr(Value.Capabilities.FunctionCalling, True)),
    F('Fine-tuning', BoolToStr(Value.Capabilities.FineTuning, True)),
    F('Vision', BoolToStr(Value.Capabilities.Vision, True))
  ]);
  Display(Sender, EmptyStr);
end;

procedure Display(Sender: TObject; Value: TModels);
begin
  if Length(Value.Data) = 0 then
    begin
      Display(Sender, 'No model found');
      Exit;
    end;
  for var Item in Value.Data do
    begin
      Display(Sender, Item);
      Application.ProcessMessages;
    end;
  Display(Sender);
end;

procedure DisplayEx(Sender: TObject; Value: TModerationResult);
var
  Temp: TArray<string>;
begin
  if Value.Warning then
    begin
      Temp := [''];
      for var Item in Value.Warnings do
        Temp := Temp + [F(Item.Category, (Item.Score * 100).ToString(ffNumber, 3, 2)) + '%'];
      Display(Sender, Temp);
      Display(Sender);
    end
  else
    begin
      Display(Sender, 'No moderation is necessary');
    end;
end;

procedure Display(Sender: TObject; Value: TModerationResult);
begin
  if Value.Warning then
    begin
      Display(Sender, [EmptyStr,
        F(Classifiers[0], Value.Categories.Sexual, Value.Scores.Sexual),
        F(Classifiers[1], Value.Categories.Hate_and_discrimination, Value.Scores.Hate_and_discrimination),
        F(Classifiers[2], Value.Categories.Violence_and_threats, Value.Scores.Violence_and_threats),
        F(Classifiers[3], Value.Categories.Dangerous_and_criminal_content, Value.Scores.Dangerous_and_criminal_content),
        F(Classifiers[4], Value.Categories.Selfharm, Value.Scores.Selfharm),
        F(Classifiers[5], Value.Categories.Health, Value.Scores.Health),
        F(Classifiers[6], Value.Categories.Financial, Value.Scores.Financial),
        F(Classifiers[7], Value.Categories.Law, Value.Scores.Law),
        F(Classifiers[8], Value.Categories.Pii, Value.Scores.Pii)
      ]);
      Display(Sender);
    end
  else
    begin
      Display(Sender, 'No moderation is necessary');
    end;
end;

procedure Display(Sender: TObject; Value: TModeration);
begin
  for var Item in Value.Results do
    Display(Sender, Item);
end;

procedure DisplayEx(Sender: TObject; Value: TModeration);
begin
  for var Item in Value.Results do
    DisplayEx(Sender, Item);
end;

procedure Display(Sender: TObject; Value: TFile);
begin
  Display(Sender, [
    F(Value.FileName, Value.Id),
    F('Source', [
      Value.Source.ToString,
      F('Purpose', Value.Purpose.ToString),
      F('Object', Value.&Object),
      F('Bytes', Value.Bytes.ToString),
      F('NumLines', Value.NumLines.ToString)
    ])
  ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TFiles);
begin
  if Length(Value.Data) = 0 then
    begin
      Display(Sender, 'No file found');
      Exit;
    end;
  for var Item in Value.Data do
    Display(Sender, Item);
end;

procedure Display(Sender: TObject; Value: TDeletedResult);
begin
  Display(Sender, [
    F('Id', Value.Id),
    F('Deleted', [
      BoolToStr(Value.Deleted, True),
      F('Object', Value.&Object)
    ])
  ]);
end;

procedure Display(Sender: TObject; Value: TDownLoadFile);
begin
  if TutorialHub.FileName.IsEmpty then
    raise Exception.Create('No filename defined for download.');
  Value.SaveToFile(TutorialHub.FileName, not TutorialHub.FileOverride);
  Display(Sender, Format('File downloaded and saved as "%s"', [TutorialHub.FileName]));
end;

procedure Display(Sender: TObject; Value: TJobOut);
begin
  Display(Sender, [
    Value.Id,
    F('AutoStart', [
      BoolToStr(Value.AutoStart, True),
      F('Model', Value.Model),
      F('Status', Value.Status.ToString),
      F('FineTuningModel', Value.FineTuningModel)
    ])
  ]);
end;

procedure Display(Sender: TObject; Value: TJobOutProgress);
begin
  Display(Sender, [
    Value.Id,
    F('AutoStart', [
      BoolToStr(Value.AutoStart, True),
      F('Model', Value.Model),
      F('Status', Value.Status.ToString),
      F('FineTuningModel', Value.FineTuningModel)
    ])
  ]);
  for var Item in Value.Events do
    Display(Sender, [
      Item.Name,
      Item.Data.Status.ToString,
      Item.Data.Error,
      UnixDateTimeToString(Item.CreatedAt)
    ]);
end;

procedure Display(Sender: TObject; Value: TListFineTuningJobs);
begin
  Display(Sender, F('Total', [Value.Total.ToString, F('Object', Value.&Object.ToString)]));
  for var Item in Value.Data do
    Display(Sender, F('Id', [
      Item.Id,
      F('Model', Item.Model),
      F('Status', Item.Status.ToString)
    ]));
end;

procedure Display(Sender: TObject; Value: TBatchJob);
begin
  Display(Sender, F('Id', [
    Value.Id,
    F('Model', Value.Model),
    F('Endpoint', Value.Endpoint.ToString),
    F('Status', Value.Status.ToString),
    F('CreatedAt', UnixDateTimeToString(Value.CreatedAt))
  ]));
  if not Value.OutputFile.IsEmpty then
    Display(Sender, F('OutputFile', Value.OutputFile));
  Display(Sender, Value.Metadata);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TBatchJobList);
begin
  Display(Sender, F('Total', [
    Value.Total.ToString,
    F('Object', Value.&Object)]));
  for var Item in Value.Data do
    Display(Sender, Item);
end;

procedure DisplayStream(Sender: TObject; Value: string);
var
  M: TMemo;
  CurrentLine: string;
begin
  if Sender is TMemo then
    M := Sender as TMemo
  else
    M := (Sender as TFMXTutorialHub).Memo1;
  var ShouldScroll := M.ViewportPosition.Y >= (M.Content.Height - M.Height - 16);
  M.Lines.BeginUpdate;
  try
    var Lines := Value.Replace(#13, '').Split([#10]);
    if System.Length(Lines) > 0 then
    begin
      if M.Lines.Count > 0 then
        CurrentLine := M.Lines[M.Lines.Count - 1]
      else
        CurrentLine := EmptyStr;
      CurrentLine := CurrentLine + Lines[0];
      if M.Lines.Count > 0 then
        M.Lines[M.Lines.Count - 1] := CurrentLine
      else
        M.Lines.Add(CurrentLine);
      for var i := 1 to High(Lines) do
        M.Lines.Add(Lines[i]);
    end;
  finally
    M.Lines.EndUpdate;
  end;
  if ShouldScroll then
    M.ViewportPosition := PointF(M.ViewportPosition.X, M.Content.Height - M.Height + 1);
end;

procedure DisplayStream(Sender: TObject; Value: TChat);
begin
  if Assigned(Value) then
    DisplayStream(Sender, Value.Choices[0].Delta.Content);
end;

procedure DisplayStream(Sender: TObject; Value: TCodestral);
begin
  if Assigned(Value) then
    DisplayStream(Sender, Value.Choices[0].Delta.Content);
end;

function F(const Name, Value: string): string;
begin
  if not Value.IsEmpty then
    Result := Format('%s: %s', [Name, Value])
end;

function F(const Name: string; const Value: TArray<string>): string;
begin
  var index := 0;
  for var Item in Value do
    begin
      if index = 0 then
        Result := Format('%s: %s', [Name, Item]) else
        Result := Result + '    ' + Item;
      Inc(index);
    end;
end;

function F(const Name: string; const Value: boolean): string;
begin
  Result := Format('%s: %s', [Name, BoolToStr(Value, True)])
end;

function F(const Name: string; const State: Boolean; const Value: Double): string;
begin
  Result := Format('%s (%s): %s%%', [Name, BoolToStr(State, True), (Value * 100).ToString(ffNumber, 3, 3)])
end;

function CodeBefore: string;
begin
  with TStringWriter.Create do
  try
    WriteLine('def is_odd(n):');
    WriteLine('  return n % 2 == 1');
    WriteLine('def test_is_odd():');
    Result := ToString;
  finally
    Free;
  end;
end;

function CodeAfter: string;
begin
  with TStringWriter.Create do
  try
    WriteLine('n = int(input(''Enter a number: ''))');
    WriteLine('print(fibonacci(n))');
    Result := ToString;
  finally
    Free;
  end;
end;

{ TFMXTutorialHub }

constructor TFMXTutorialHub.Create(const AMemo1, AMemo2: TMemo; const AButton: TButton);
begin
  inherited Create;
  Memo1 := AMemo1;
  Memo2 := AMemo2;
  Button := AButton;
  FFileOverride := False;
end;

procedure TFMXTutorialHub.NextPage;
begin
  Inc(FPage);
end;

procedure TFMXTutorialHub.OnButtonClick(Sender: TObject);
begin
  Cancel := True;
end;

procedure TFMXTutorialHub.SetButton(const Value: TButton);
begin
  FButton := Value;
  FButton.OnClick := OnButtonClick;
  FButton.Text := 'Cancel';
end;

procedure TFMXTutorialHub.SetMemo1(const Value: TMemo);
begin
  FMemo1 := Value;
  FMemo1.TextSettings.WordWrap := True;
end;

procedure TFMXTutorialHub.SetMemo2(const Value: TMemo);
begin
  FMemo2 := Value;
  FMemo2.TextSettings.WordWrap := True;
end;

initialization
finalization
  if Assigned(TutorialHub) then
    TutorialHub.Free;
end.

unit MistralAI.Tutorial.VCL;

{ Tutorial Support Unit

   WARNING:
     This module is intended solely to illustrate the examples provided in the
     README.md file of the repository :
          https://github.com/MaxiDonkey/DelphiMistralAI
     Under no circumstances should the methods described below be used outside
     of the examples presented on the repository's page.
}

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes,
  Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.ExtCtrls,
  System.UITypes,
  MistralAI, MistralAI.Types, MistralAI.Functions.Core;

type
  TToolProc = procedure (const Value: TCalledFunction; Func: IFunctionCore) of object;

  /// <summary>
  /// Represents a tutorial hub for handling visual components in a Delphi application,
  /// including text display, button interactions, and navigation through pages.
  /// </summary>
  TVCLTutorialHub = class
  private
    FMemo1: TMemo;
    FMemo2: TMemo;
    FButton: TButton;
    FFileId: string;
    FJobId: string;
    FBatchId: string;
    FFileName: string;
    FTool: IFunctionCore;
    FToolCall: TToolProc;
    FPage: Integer;
    FFileOverride: Boolean;
    FCancel: Boolean;
    procedure OnButtonClick(Sender: TObject);
    procedure SetButton(const Value: TButton);
    procedure SetMemo1(const Value: TMemo);
    procedure SetMemo2(const Value: TMemo);
  public
    /// <summary>
    /// Advances the tutorial to the next page.
    /// </summary>
    procedure NextPage;
    /// <summary>
    /// Gets or sets the first memo component for displaying messages or data.
    /// </summary>
    property Memo1: TMemo read FMemo1 write SetMemo1;
    /// <summary>
    /// Gets or sets the second memo component for displaying additional messages or data.
    /// </summary>
    property Memo2: TMemo read FMemo2 write SetMemo2;
    /// <summary>
    /// Gets or sets the button component used to trigger actions or handle cancellation.
    /// </summary>
    property Button: TButton read FButton write SetButton;
    /// <summary>
    /// Gets or sets a value indicating whether the operation has been canceled.
    /// </summary>
    property Cancel: Boolean read FCancel write FCancel;
    /// <summary>
    /// Gets or sets the file identifier associated with the tutorial hub.
    /// </summary>
    property FileId: string read FFileId write FFileId;
    /// <summary>
    /// Gets or sets the job identifier associated with the tutorial hub.
    /// </summary>
    property JobId: string read FJobId write FJobId;
    /// <summary>
    /// Gets or sets the batch identifier associated with the tutorial hub.
    /// </summary>
    property BatchId: string read FBatchId write FBatchId;
    /// <summary>
    /// Gets or sets the name of the file associated with the tutorial hub.
    /// </summary>
    property FileName: string read FFileName write FFileName;
    /// <summary>
    /// Gets or sets the core function tool used for processing.
    /// </summary>
    property Tool: IFunctionCore read FTool write FTool;
    /// <summary>
    /// Gets or sets the procedure for handling tool-specific calls.
    /// </summary>
    property ToolCall: TToolProc read FToolCall write FToolCall;
    /// <summary>
    /// Gets or sets the current page number within the tutorial.
    /// </summary>
    property Page: Integer read FPage write FPage;
    /// <summary>
    /// Gets or sets a value indicating whether file overrides are allowed.
    /// </summary>
    property FileOverride: Boolean read FFileOverride write FFileOverride;
    constructor Create(const AMemo1, AMemo2: TMemo; const AButton: TButton);
  end;

  procedure Cancellation(Sender: TObject);
  function DoCancellation: Boolean;
  procedure Start(Sender: TObject);

  procedure Display(Sender: TObject); overload;
  procedure Display(Sender: TObject; Value: string); overload;
  procedure Display(Sender: TObject; Value: TArray<string>); overload;
  procedure Display(Sender: TObject; Value: TChat); overload;
  procedure Display(Sender: TObject; Value: TCodestral); overload;
  procedure Display(Sender: TObject; Value: TEmbeddings); overload;
  procedure Display(Sender: TObject; Value: TModel); overload;
  procedure Display(Sender: TObject; Value: TModels); overload;
  procedure DisplayEx(Sender: TObject; Value: TModerationResult); overload;
  procedure Display(Sender: TObject; Value: TModerationResult); overload;
  procedure DisplayEx(Sender: TObject; Value: TModeration); overload;
  procedure Display(Sender: TObject; Value: TModeration); overload;
  procedure Display(Sender: TObject; Value: TFile); overload;
  procedure Display(Sender: TObject; Value: TFiles); overload;
  procedure Display(Sender: TObject; Value: TDeletedResult); overload;
  procedure Display(Sender: TObject; Value: TDownLoadFile); overload;
  procedure Display(Sender: TObject; Value: TJobOut); overload;
  procedure Display(Sender: TObject; Value: TJobOutProgress); overload;
  procedure Display(Sender: TObject; Value: TListFineTuningJobs); overload;
  procedure Display(Sender: TObject; Value: TBatchJob); overload;
  procedure Display(Sender: TObject; Value: TBatchJobList); overload;

  procedure DisplayStream(Sender: TObject; Value: string); overload;
  procedure DisplayStream(Sender: TObject; Value: TChat); overload;
  procedure DisplayStream(Sender: TObject; Value: TCodestral); overload;

  function F(const Name, Value: string): string; overload;
  function F(const Name: string; const Value: TArray<string>): string; overload;
  function F(const Name: string; const Value: boolean): string; overload;
  function F(const Name: string; const State: Boolean; const Value: Double): string; overload;

  function CodeBefore: string;
  function CodeAfter: string;

var
  /// <summary>
  /// A global instance of the <see cref="TVCLTutorialHub"/> class used as the main tutorial hub.
  /// </summary>
  /// <remarks>
  /// This variable serves as the central hub for managing tutorial components, such as memos, buttons, and pages.
  /// It is initialized dynamically during the application's runtime, and its memory is automatically released during
  /// the application's finalization phase.
  /// </remarks>
  TutorialHub: TVCLTutorialHub = nil;

implementation

uses
  System.DateUtils;

function UnixIntToDateTime(const Value: Int64): TDateTime;
begin
  Result := TTimeZone.Local.ToLocalTime(UnixToDateTime(Value));
end;

function UnixDateTimeToString(const Value: Int64): string;
begin
  Result := DateTimeToStr(UnixIntToDateTime(Value))
end;

procedure Cancellation(Sender: TObject);
begin
  Display(Sender, 'The operation was cancelled');
  Display(Sender);
  TutorialHub.Cancel := False;
end;

function DoCancellation: Boolean;
begin
  Result := TutorialHub.Cancel;
end;

procedure Start(Sender: TObject);
begin
  Display(Sender, 'Please wait...');
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: string);
var
  M: TMemo;
begin
  if Sender is TMemo then
    M := TMemo(Sender) else
    M := (Sender as TVCLTutorialHub).Memo1;

  var S := Value.Split([#10]);
  if Length(S) = 0 then
    begin
      M.Lines.Add(Value)
    end
  else
    begin
      for var Item in S do
        M.Lines.Add(Item);
    end;

  M.Perform(WM_VSCROLL, SB_BOTTOM, 0);
end;

procedure Display(Sender: TObject; Value: TArray<string>);
begin
  var index := 0;
  for var Item in Value do
    begin
      if not Item.IsEmpty then
        begin
          if index = 0 then
            Display(Sender, Item) else
            Display(Sender, '    ' + Item);
        end;
      Inc(index);
    end;
end;

procedure Display(Sender: TObject);
begin
  Display(Sender, sLineBreak);
end;

procedure Display(Sender: TObject; Value: TChat);
begin
  for var Item in Value.Choices do
    if Item.FinishReason = TFinishReason.tool_calls then
      begin
        if Assigned(TutorialHub.ToolCall) then
          TutorialHub.ToolCall(Item.Message.ToolsCalls[0], TutorialHub.Tool);
      end
    else
      begin
        Display(Sender, Item.Message.Content);
      end;
end;

procedure Display(Sender: TObject; Value: TCodestral); overload;
begin
  for var Item in Value.Choices do
    if Item.FinishReason = TCodestralFinishReason.cstool_calls then
      begin
        if Assigned(TutorialHub.ToolCall) then
          TutorialHub.ToolCall(Item.Message.ToolsCalls[0], TutorialHub.Tool);
      end
    else
      begin
        Display(Sender, Item.Message.Content);
      end;
end;

procedure Display(Sender: TObject; Value: TEmbeddings); overload;
begin
  var i := 0;
  for var Item in Value.Data do
    begin
      var j := 0;
      for var SubItem in Item.Embedding do
          begin
            Display(Sender, Format('Vector[%d, %d] = %s', [i, j, SubItem.ToString(ffNumber, 8, 8)]));
            Inc(j);
            Application.ProcessMessages;
          end;
      Display(Sender);
      Inc(i);
    end;
end;

procedure Display(Sender: TObject; Value: TModel);
begin
  Display(Sender, [
    Value.Id,
    F('Name', Value.Name),
    F('Description', Value.Description),
    F('Deprecation', Value.Deprecation),
    F('Default temperature', Value.DefaultModelTemperature.ToString(ffNumber, 3, 2)),
    F('Completion chat', BoolToStr(Value.Capabilities.CompletionChat, True)),
    F('Completion fim', BoolToStr(Value.Capabilities.CompletionFim, True)),
    F('Function calling', BoolToStr(Value.Capabilities.FunctionCalling, True)),
    F('Fine-tuning', BoolToStr(Value.Capabilities.FineTuning, True)),
    F('Vision', BoolToStr(Value.Capabilities.Vision, True))
  ]);
  Display(Sender, EmptyStr);
end;

procedure Display(Sender: TObject; Value: TModels);
begin
  if Length(Value.Data) = 0 then
    begin
      Display(Sender, 'No model found');
      Exit;
    end;
  for var Item in Value.Data do
    begin
      Display(Sender, Item);
      Application.ProcessMessages;
    end;
  Display(Sender);
end;

procedure DisplayEx(Sender: TObject; Value: TModerationResult);
var
  Temp: TArray<string>;
begin
  if Value.Warning then
    begin
      Temp := [''];
      for var Item in Value.Warnings do
        Temp := Temp + [F(Item.Category, (Item.Score * 100).ToString(ffNumber, 3, 2)) + '%'];
      Display(Sender, Temp);
      Display(Sender);
    end
  else
    begin
      Display(Sender, 'No moderation is necessary');
    end;
end;

procedure Display(Sender: TObject; Value: TModerationResult);
begin
  if Value.Warning then
    begin
      Display(Sender, [EmptyStr,
        F(Classifiers[0], Value.Categories.Sexual, Value.Scores.Sexual),
        F(Classifiers[1], Value.Categories.Hate_and_discrimination, Value.Scores.Hate_and_discrimination),
        F(Classifiers[2], Value.Categories.Violence_and_threats, Value.Scores.Violence_and_threats),
        F(Classifiers[3], Value.Categories.Dangerous_and_criminal_content, Value.Scores.Dangerous_and_criminal_content),
        F(Classifiers[4], Value.Categories.Selfharm, Value.Scores.Selfharm),
        F(Classifiers[5], Value.Categories.Health, Value.Scores.Health),
        F(Classifiers[6], Value.Categories.Financial, Value.Scores.Financial),
        F(Classifiers[7], Value.Categories.Law, Value.Scores.Law),
        F(Classifiers[8], Value.Categories.Pii, Value.Scores.Pii)
      ]);
    end
  else
    begin
      Display(Sender, 'No moderation is necessary');
    end;
end;

procedure Display(Sender: TObject; Value: TModeration);
begin
  for var Item in Value.Results do
    Display(Sender, Item);
end;

procedure DisplayEx(Sender: TObject; Value: TModeration);
begin
  for var Item in Value.Results do
    DisplayEx(Sender, Item);
end;

procedure Display(Sender: TObject; Value: TFile);
begin
  Display(Sender, [
    F(Value.FileName, Value.Id),
    F('Source', [
      Value.Source.ToString,
      F('Purpose', Value.Purpose.ToString),
      F('Object', Value.&Object),
      F('Bytes', Value.Bytes.ToString),
      F('NumLines', Value.NumLines.ToString)
    ])
  ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TFiles);
begin
  if Length(Value.Data) = 0 then
    begin
      Display(Sender, 'No file found');
      Exit;
    end;
  for var Item in Value.Data do
    Display(Sender, Item);
end;

procedure Display(Sender: TObject; Value: TDeletedResult);
begin
  Display(Sender, [
    F('Id', Value.Id),
    F('Deleted', [
      BoolToStr(Value.Deleted, True),
      F('Object', Value.&Object)
    ])
  ]);
end;

procedure Display(Sender: TObject; Value: TDownLoadFile);
begin
  if TutorialHub.FileName.IsEmpty then
    raise Exception.Create('No filename defined for download.');
  Value.SaveToFile(TutorialHub.FileName, not TutorialHub.FileOverride);
  Display(Sender, Format('File downloaded and saved as "%s"', [TutorialHub.FileName]));
end;

procedure Display(Sender: TObject; Value: TJobOut);
begin
  Display(Sender, [
    Value.Id,
    F('AutoStart', [
      BoolToStr(Value.AutoStart, True),
      F('Model', Value.Model),
      F('Status', Value.Status.ToString),
      F('FineTuningModel', Value.FineTuningModel)
    ])
  ]);
end;

procedure Display(Sender: TObject; Value: TJobOutProgress);
begin
  Display(Sender, [
    Value.Id,
    F('AutoStart', [
      BoolToStr(Value.AutoStart, True),
      F('Model', Value.Model),
      F('Status', Value.Status.ToString),
      F('FineTuningModel', Value.FineTuningModel)
    ])
  ]);
  for var Item in Value.Events do
    Display(Sender, [
      Item.Name,
      Item.Data.Status.ToString,
      Item.Data.Error,
      UnixDateTimeToString(Item.CreatedAt)
    ]);
end;

procedure Display(Sender: TObject; Value: TListFineTuningJobs);
begin
  Display(Sender, F('Total', [Value.Total.ToString, F('Object', Value.&Object.ToString)]));
  for var Item in Value.Data do
    Display(Sender, F('Id', [
      Item.Id,
      F('Model', Item.Model),
      F('Status', Item.Status.ToString)
    ]));
end;

procedure Display(Sender: TObject; Value: TBatchJob);
begin
  Display(Sender, F('Id', [
    Value.Id,
    F('Model', Value.Model),
    F('Endpoint', Value.Endpoint.ToString),
    F('Status', Value.Status.ToString),
    F('CreatedAt', UnixDateTimeToString(Value.CreatedAt))
  ]));
  if not Value.OutputFile.IsEmpty then
    Display(Sender, F('OutputFile', Value.OutputFile));
  Display(Sender, Value.Metadata);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TBatchJobList);
begin
  Display(Sender, F('Total', [
    Value.Total.ToString,
    F('Object', Value.&Object)]));
  for var Item in Value.Data do
    Display(Sender, Item);
end;

procedure DisplayStream(Sender: TObject; Value: string);
var
  M: TMemo;
  CurrentLine: string;
  Lines: TArray<string>;
begin
  if Sender is TMemo then
    M := TMemo(Sender) else
    M := (Sender as TVCLTutorialHub).Memo1;
  var OldSelStart := M.SelStart;
  var ShouldScroll := (OldSelStart = M.GetTextLen);
  M.Lines.BeginUpdate;
  try
    Lines := Value.Split([#10]);
    if Length(Lines) > 0 then
    begin
      if M.Lines.Count > 0 then
        CurrentLine := M.Lines[M.Lines.Count - 1]
      else
        CurrentLine := '';
      CurrentLine := CurrentLine + Lines[0];
      if M.Lines.Count > 0 then
        M.Lines[M.Lines.Count - 1] := CurrentLine
      else
        M.Lines.Add(CurrentLine);
      for var i := 1 to High(Lines) do
        M.Lines.Add(Lines[i]);
    end;
  finally
    M.Lines.EndUpdate;
  end;
  if ShouldScroll then
  begin
    M.SelStart := M.GetTextLen;
    M.SelLength := 0;
    M.Perform(EM_SCROLLCARET, 0, 0);
  end;
end;

procedure DisplayStream(Sender: TObject; Value: TChat);
begin
  if Assigned(Value) then
    DisplayStream(Sender, Value.Choices[0].Delta.Content);
end;

procedure DisplayStream(Sender: TObject; Value: TCodestral); overload;
begin
  if Assigned(Value) then
    DisplayStream(Sender, Value.Choices[0].Delta.Content);
end;

function F(const Name, Value: string): string;
begin
  if not Value.IsEmpty then
    Result := Format('%s: %s', [Name, Value])
end;

function F(const Name: string; const Value: TArray<string>): string;
begin
  var index := 0;
  for var Item in Value do
    begin
      if index = 0 then
        Result := Format('%s: %s', [Name, Item]) else
        Result := Result + '    ' + Item;
      Inc(index);
    end;
end;

function F(const Name: string; const Value: boolean): string;
begin
  Result := Format('%s: %s', [Name, BoolToStr(Value, True)])
end;

function F(const Name: string; const State: Boolean; const Value: Double): string;
begin
  Result := Format('%s (%s): %s%%', [Name, BoolToStr(State, True), (Value * 100).ToString(ffNumber, 3, 2)])
end;

function CodeBefore: string;
begin
  with TStringWriter.Create do
  try
    WriteLine('def is_odd(n):');
    WriteLine('  return n % 2 == 1');
    WriteLine('def test_is_odd():');
    Result := ToString;
  finally
    Free;
  end;
end;

function CodeAfter: string;
begin
  with TStringWriter.Create do
  try
    WriteLine('n = int(input(''Enter a number: ''))');
    WriteLine('print(fibonacci(n))');
    Result := ToString;
  finally
    Free;
  end;
end;

{ TVCLTutorialHub }

constructor TVCLTutorialHub.Create(const AMemo1, AMemo2: TMemo; const AButton: TButton);
begin
  inherited Create;
  Memo1 := AMemo1;
  Memo2 := AMemo2;
  Button := AButton;
  FFileOverride := False;
end;

procedure TVCLTutorialHub.NextPage;
begin
  Inc(FPage);
end;

procedure TVCLTutorialHub.OnButtonClick(Sender: TObject);
begin
  Cancel := True;
end;

procedure TVCLTutorialHub.SetButton(const Value: TButton);
begin
  FButton := Value;
  FButton.OnClick := OnButtonClick;
  FButton.Caption := 'Cancel';
end;

procedure TVCLTutorialHub.SetMemo1(const Value: TMemo);
begin
  FMemo1 := Value;
  FMemo1.ScrollBars := TScrollStyle.ssVertical;
end;

procedure TVCLTutorialHub.SetMemo2(const Value: TMemo);
begin
  FMemo2 := Value;
  FMemo2.ScrollBars := TScrollStyle.ssVertical;
end;

initialization
finalization
  if Assigned(TutorialHub) then
    TutorialHub.Free;
end.

unit MistralAI.Types;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, MistralAI.API.Params;

type
  {$REGION 'MistralAI.Chat'}

  /// <summary>
  /// Type of message role
  /// </summary>
  TMessageRole = (
    /// <summary>
    /// System message
    /// </summary>
    system,
    /// <summary>
    /// User message
    /// </summary>
    user,
    /// <summary>
    /// Assistant message
    /// </summary>
    assistant,
    /// <summary>
    /// Function message
    /// </summary>
    tool);

  /// <summary>
  /// Helper record for the <c>TMessageRole</c> enumeration, providing utility methods for converting
  /// between <c>TMessageRole</c> values and their string representations.
  /// </summary>
  TMessageRoleHelper = record helper for TMessageRole
    /// <summary>
    /// Converts the current <c>TMessageRole</c> value to its corresponding string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>TMessageRole</c> value.
    /// </returns>
    /// <remarks>
    /// <code>
    /// var Role: TMessageRole;
    /// begin
    ///   Role := TMessageRole.system;
    ///   ShowMessage(Role.ToString);  // Outputs "system"
    /// end;
    /// </code>
    /// </remarks>
    function ToString: string;
    /// <summary>
    /// Converts a string representation of a <c>TMessageRole</c> into its corresponding enumeration value.
    /// </summary>
    /// <param name="Value">
    /// The string representing a <c>TMessageRole</c>.
    /// </param>
    /// <returns>
    /// The <c>TMessageRole</c> enumeration value that corresponds to the provided string.
    /// </returns>
    /// <remarks>
    /// If the input string does not match any valid <c>TMessageRole</c> value, an exception will be raised.
    /// <code>
    /// var Role: TMessageRole;
    /// begin
    ///   Role := TMessageRoleHelper.FromString('user');  // Returns TMessageRole.user
    /// end;
    /// </code>
    /// </remarks>
    class function FromString(const Value: string): TMessageRole; static;
  end;

  /// <summary>
  /// Represents the different reasons why the processing of a request can terminate.
  /// </summary>
  TFinishReason = (
    /// <summary>
    /// API returned complete model output
    /// </summary>
    stop,
    /// <summary>
    /// Incomplete model output due to max_tokens parameter or token limit
    /// </summary>
    length_limit,
    /// <summary>
    /// model_length
    /// </summary>
    model_length,
    /// <summary>
    /// An error was encountered while processing the request
    /// </summary>
    error,
    /// <summary>
    /// A function must be invoked before further processing of the request
    /// </summary>
    tool_calls);

     /// <summary>
  /// Helper record for the <c>TFinishReason</c> enumeration, providing utility methods for conversion between string representations and <c>TFinishReason</c> values.
  /// </summary>
  TFinishReasonHelper = record helper for TFinishReason
    /// <summary>
    /// Converts the current <c>TFinishReason</c> value to its string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>TFinishReason</c> value.
    /// </returns>
    function ToString: string;
    /// <summary>
    /// Creates a <c>TFinishReason</c> value from its corresponding string representation.
    /// </summary>
    /// <param name="Value">
    /// The string value representing a <c>TFinishReason</c>.
    /// </param>
    /// <returns>
    /// The corresponding <c>TFinishReason</c> enumeration value for the provided string.
    /// </returns>
    /// <remarks>
    /// This method throws an exception if the input string does not match any valid <c>TFinishReason</c> values.
    /// </remarks>
    class function Create(const Value: string): TFinishReason; static;
  end;

  /// <summary>
  /// Interceptor class for converting <c>TFinishReason</c> values to and from their string representations in JSON serialization and deserialization.
  /// </summary>
  /// <remarks>
  /// This class is used to facilitate the conversion between the <c>TFinishReason</c> enum and its string equivalents during JSON processing.
  /// It extends the <c>TJSONInterceptorStringToString</c> class to override the necessary methods for custom conversion logic.
  /// </remarks>
  TFinishReasonInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// Converts the <c>TFinishReason</c> value of the specified field to a string during JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be converted.
    /// </param>
    /// <param name="Field">
    /// The field name representing the <c>TFinishReason</c> value.
    /// </param>
    /// <returns>
    /// The string representation of the <c>TFinishReason</c> value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string back to a <c>TFinishReason</c> value for the specified field during JSON deserialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be set.
    /// </param>
    /// <param name="Field">
    /// The field name where the <c>TFinishReason</c> value will be set.
    /// </param>
    /// <param name="Arg">
    /// The string representation of the <c>TFinishReason</c> to be converted back.
    /// </param>
    /// <remarks>
    /// This method converts the string argument back to the corresponding <c>TFinishReason</c> value and assigns it to the specified field in the object.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Represents the type of the content: text or image_url
  /// </summary>
  TContentType = (
    /// <summary>
    /// The content is a text
    /// </summary>
    text,
    /// <summary>
    /// The content is an url or a base-64 text
    /// </summary>
    image_url
  );

  /// <summary>
  /// Helper record for the <c>TContentType</c> enumeration, providing utility methods for conversion between string representations and <c>TContentType</c> values.
  /// </summary>
  TContentTypeHelper = record Helper for TContentType
    /// <summary>
    /// Converts the current <c>TFinishReason</c> value to its string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>TFinishReason</c> value.
    /// </returns>
    function ToString: string;
  end;

  /// <summary>
  /// Represents the type of tool type: only "function" available
  /// </summary>
  TToolType = (
    /// <summary>
    /// The tool calls use a function
    /// </summary>
    ttfunction
  );

  /// <summary>
  /// Helper record for the <c>TToolType</c> enumeration, providing utility methods for conversion between string representations and <c>TToolType</c> values.
  /// </summary>
  TToolTypeHelper = record Helper for TToolType
    /// <summary>
    /// Converts the current <c>TFinishReason</c> value to its string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>TFinishReason</c> value.
    /// </returns>
    function ToString: string;
  end;

  {$ENDREGION}

  {$REGION 'MistralAI.FineTunings'}

  /// <summary>
  /// Enum of the different statuses for a fine-tuning job.
  /// </summary>
  /// <remarks>
  /// Represents the various statuses that a fine-tuning job can have during its lifecycle.
  /// </remarks>
  TFineTuningJobStatus = (
    /// <summary>
    /// The job is queued and waiting to start.
    /// </summary>
    Queued,
    /// <summary>
    /// The job has started
    /// </summary>
    Started,
    /// <summary>
    /// Yhe job is currently being validated
    /// </summary>
    Validating,
    /// <summary>
    /// The job has been validated
    /// </summary>
    Validated,
    /// <summary>
    /// The job is currently running.
    /// </summary>
    Running,
    /// <summary>
    /// The validation failed.
    /// </summary>
    Failed_validation,
    /// <summary>
    /// The job has failed.
    /// </summary>
    Failed,
    /// <summary>
    /// The job ended successfully.
    /// </summary>
    Success,
    /// <summary>
    /// The job has been cancelled.
    /// </summary>
    Cancelled,
    /// <summary>
    /// A cancellation request has been made; the job is awaiting cancellation.
    /// </summary>
    CancellationRequested);

  /// <summary>
  /// Provides helper methods for the TFineTuningJobStatus enum.
  /// </summary>
  /// <remarks>
  /// Includes methods to convert enum values to strings and create enum values from strings.
  /// </remarks>
  TFineTuningJobStatusHelper = record helper for TFineTuningJobStatus
    /// <summary>
    /// Converts the TFineTuningJobStatus value to its string representation.
    /// </summary>
    /// <returns>
    /// The string representation of the TFineTuningJobStatus value.
    /// </returns>
    function ToString: string;
    /// <summary>
    /// Creates a TFineTuningJobStatus enum value from a string.
    /// </summary>
    /// <param name="Value">
    /// The string representation of the TFineTuningJobStatus.
    /// </param>
    /// <returns>
    /// The corresponding TFineTuningJobStatus enum value.
    /// </returns>
    class function Create(const Value: string): TFineTuningJobStatus; static;
  end;

  /// <summary>
  /// JSON interceptor for converting TFineTuningJobStatus enum values to strings and vice versa during JSON serialization and deserialization.
  /// </summary>
  TFineTuningJobStatusInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// Converts a TFineTuningJobStatus enum value to its string representation for JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to convert.
    /// </param>
    /// <param name="Field">
    /// The name of the field to convert.
    /// </param>
    /// <returns>
    /// The string representation of the TFineTuningJobStatus enum value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string from JSON deserialization back to a TFineTuningJobStatus enum value.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to revert.
    /// </param>
    /// <param name="Field">
    /// The name of the field to revert.
    /// </param>
    /// <param name="Arg">
    /// The string value to convert back to the enum.
    /// </param>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Represents the kind of data object in fine-tuning operations.
  /// </summary>
  /// <remarks>
  /// Currently only 'Job' is defined.
  /// </remarks>
  TFineTuningDataObjectKind = (
    /// <summary>
    /// Indicates a fine-tuning job object.
    /// </summary>
    Job
  );

  /// <summary>
  /// Provides helper methods for the TFineTuningDataObjectKind enum.
  /// </summary>
  /// <remarks>
  /// Includes methods to convert enum values to strings and create enum values from strings.
  /// </remarks>
  TFineTuningDataObjectKindHelper = record helper for TFineTuningDataObjectKind
    /// <summary>
    /// Converts the TFineTuningDataObjectKind value to its string representation.
    /// </summary>
    /// <returns>
    /// The string representation of the TFineTuningDataObjectKind value.
    /// </returns>
    function ToString: string;
    /// <summary>
    /// Creates a TFineTuningDataObjectKind enum value from a string.
    /// </summary>
    /// <param name="Value">
    /// The string representation of the TFineTuningDataObjectKind.
    /// </param>
    /// <returns>
    /// The corresponding TFineTuningDataObjectKind enum value.
    /// </returns>
    class function Create(const Value: string): TFineTuningDataObjectKind; static;
  end;

  /// <summary>
  /// JSON interceptor for converting TFineTuningDataObjectKind enum values to strings and vice versa during JSON serialization and deserialization.
  /// </summary>
  TFineTuningDataObjectKindInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// Converts a TFineTuningDataObjectKind enum value to its string representation for JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to convert.
    /// </param>
    /// <param name="Field">
    /// The name of the field to convert.
    /// </param>
    /// <returns>
    /// The string representation of the TFineTuningDataObjectKind enum value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string from JSON deserialization back to a TFineTuningDataObjectKind enum value.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to revert.
    /// </param>
    /// <param name="Field">
    /// The name of the field to revert.
    /// </param>
    /// <param name="Arg">
    /// The string value to convert back to the enum.
    /// </param>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Type of platform with which to integrate monitoring information for fine-tuning operations.
  /// </summary>
  TFineTuningIntegrationType = (
    /// <summary>
    /// See "Weights and Biases" solutions at the website "https://wandb.ai/site".
    /// </summary>
    Wandb
  );

  /// <summary>
  /// Provides helper methods for the TFineTuningIntegrationType enum.
  /// </summary>
  /// <remarks>
  /// Includes methods to convert enum values to strings and create enum values from strings.
  /// </remarks>
  TFineTuningIntegrationTypeHelper = record helper for TFineTuningIntegrationType
    /// <summary>
    /// Converts the TFineTuningIntegrationType value to its string representation.
    /// </summary>
    /// <returns>
    /// The string representation of the TFineTuningIntegrationType value.
    /// </returns>
    function ToString: string;
    /// <summary>
    /// Creates a TFineTuningIntegrationType enum value from a string.
    /// </summary>
    /// <param name="Value">
    /// The string representation of the TFineTuningIntegrationType.
    /// </param>
    /// <returns>
    /// The corresponding TFineTuningIntegrationType enum value.
    /// </returns>
    class function Create(const Value: string): TFineTuningIntegrationType; static;
  end;

  /// <summary>
  /// JSON interceptor for converting TFineTuningIntegrationType enum values to strings and vice versa during JSON serialization and deserialization.
  /// </summary>
  TFineTuningIntegrationTypeInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// Converts a TFineTuningIntegrationType enum value to its string representation for JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to convert.
    /// </param>
    /// <param name="Field">
    /// The name of the field to convert.
    /// </param>
    /// <returns>
    /// The string representation of the TFineTuningIntegrationType enum value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string from JSON deserialization back to a TFineTuningIntegrationType enum value.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to revert.
    /// </param>
    /// <param name="Field">
    /// The name of the field to revert.
    /// </param>
    /// <param name="Arg">
    /// The string value to convert back to the enum.
    /// </param>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Represents the kind of object returned by fine-tuning operations.
  /// </summary>
  /// <remarks>
  /// Currently only 'List' is defined.
  /// </remarks>
  TFineTuningObjectKind = (
    /// <summary>
    /// Indicates a list of fine-tuning jobs.
    /// </summary>
    List
  );

  /// <summary>
  /// Provides helper methods for the TFineTuningObjectKind enum.
  /// </summary>
  /// <remarks>
  /// Includes methods to convert enum values to strings and create enum values from strings.
  /// </remarks>
  TFineTuningObjectKindHelper = record helper for TFineTuningObjectKind
    /// <summary>
    /// Converts the TFineTuningObjectKind value to its string representation.
    /// </summary>
    /// <returns>
    /// The string representation of the TFineTuningObjectKind value.
    /// </returns>
    function ToString: string;
    /// <summary>
    /// Creates a TFineTuningObjectKind enum value from a string.
    /// </summary>
    /// <param name="Value">
    /// The string representation of the TFineTuningObjectKind.
    /// </param>
    /// <returns>
    /// The corresponding TFineTuningObjectKind enum value.
    /// </returns>
    class function Create(const Value: string): TFineTuningObjectKind; static;
  end;

  /// <summary>
  /// JSON interceptor for converting TFineTuningObjectKind enum values to strings and vice versa during JSON serialization and deserialization.
  /// </summary>
  TFineTuningObjectKindInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// Converts a TFineTuningObjectKind enum value to its string representation for JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to convert.
    /// </param>
    /// <param name="Field">
    /// The name of the field to convert.
    /// </param>
    /// <returns>
    /// The string representation of the TFineTuningObjectKind enum value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string from JSON deserialization back to a TFineTuningObjectKind enum value.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to revert.
    /// </param>
    /// <param name="Field">
    /// The name of the field to revert.
    /// </param>
    /// <param name="Arg">
    /// The string value to convert back to the enum.
    /// </param>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  TRepositoryType = (
    github
  );

  /// <summary>
  /// Provides helper methods for the TRepositoryType enum.
  /// </summary>
  /// <remarks>
  /// Includes methods to convert enum values to strings and create enum values from strings.
  /// </remarks>
  TRepositoryTypeHelper = record Helper for TRepositoryType
    /// <summary>
    /// Converts the TRepositoryType value to its string representation.
    /// </summary>
    /// <returns>
    /// The string representation of the TRepositoryType value.
    /// </returns>
    function ToString: string;
    /// <summary>
    /// Creates a TRepositoryType enum value from a string.
    /// </summary>
    /// <param name="Value">
    /// The string representation of the TRepositoryType.
    /// </param>
    /// <returns>
    /// The corresponding TRepositoryType enum value.
    /// </returns>
    class function Create(const Value: string): TRepositoryType; static;
  end;

  /// <summary>
  /// JSON interceptor for converting TRepositoryType enum values to strings and vice versa during JSON serialization and deserialization.
  /// </summary>
  TRepositoryTypeInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// Converts a TRepositoryType enum value to its string representation for JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to convert.
    /// </param>
    /// <param name="Field">
    /// The name of the field to convert.
    /// </param>
    /// <returns>
    /// The string representation of the TRepositoryType enum value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string from JSON deserialization back to a TRepositoryType enum value.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to revert.
    /// </param>
    /// <param name="Field">
    /// The name of the field to revert.
    /// </param>
    /// <param name="Arg">
    /// The string value to convert back to the enum.
    /// </param>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Interceptor class for converting <c>args</c> and <c>response</c> values into JSON string format in JSON deserialization.
  /// </summary>
  /// <remarks>
  /// This class is used to facilitate the conversion between the <c>args</c>, <c>response</c> and theirs string equivalent during JSON processing.
  /// It extends the <c>TJSONInterceptorStringToString</c> class to override the necessary methods for custom conversion logic.
  /// </remarks>
  TMetadataInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// When JSON deserialization, converts <c>args</c>, <c>response<c/> values into JSON string to retrieve arguments made by the tool.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be set.
    /// </param>
    /// <param name="Field">
    /// The field name where the <c>input</c> value will be set.
    /// </param>
    /// <param name="Arg">
    /// The string representation of the <c>args</c> or <c>response</c> to be converted back.
    /// </param>
    /// <remarks>
    /// This method converts the string argument back to the corresponding <c>args</c> or <c>response</c> value and assigns it to the specified field in the object.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  {$ENDREGION}

  {$REGION 'MistralAI.Codestral'}

  /// <summary>
  /// Represents the different reasons why the processing of a request can terminate.
  /// </summary>
  TCodestralFinishReason = (
    /// <summary>
    /// API returned complete model output
    /// </summary>
    csstop,
    /// <summary>
    /// Incomplete model output due to max_tokens parameter or token limit
    /// </summary>
    cslength_limite,
    /// <summary>
    /// model_length
    /// </summary>
    csmodel_length,
    /// <summary>
    /// An error was encountered while processing the request
    /// </summary>
    cserror,
    /// <summary>
    /// A function must be invoked before further processing of the request
    /// </summary>
    cstool_calls);

  /// <summary>
  /// Provides helper methods for the TCodestralFinishReason enumeration.
  /// </summary>
  TCodestralFinishReasonHelper = record helper for TCodestralFinishReason
    /// <summary>
    /// Returns the string representation of the TCodestralFinishReason value.
    /// </summary>
    function ToString: string;
    /// <summary>
    /// Creates a TCodestralFinishReason value from a given string.
    /// </summary>
    /// <param name="Value">The string representation of the TCodestralFinishReason.</param>
    /// <returns>A TCodestralFinishReason corresponding to the provided string.</returns>
    class function Create(const Value: string): TCodestralFinishReason; static;
  end;

  /// <summary>
  /// Interceptor class for converting and reverting TCodestralFinishReason values to and from strings in JSON.
  /// </summary>
  TCodestralFinishReasonInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// Converts a TCodestralFinishReason value to its string representation for JSON serialization.
    /// </summary>
    /// <param name="Data">The object containing the field to be converted.</param>
    /// <param name="Field">The name of the field to be converted.</param>
    /// <returns>The string representation of the TCodestralFinishReason value.</returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Reverts a string representation back to a TCodestralFinishReason value during JSON deserialization.
    /// </summary>
    /// <param name="Data">The object containing the field to be reverted.</param>
    /// <param name="Field">The name of the field to be reverted.</param>
    /// <param name="Arg">
    /// The string representation of the TCodestralFinishReason value.
    ///</param>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  {$ENDREGION}

  {$REGION 'MistralAI.Files'}

  /// <summary>
  /// Specifies the intended purpose of the uploaded file.
  /// </summary>
  /// <remarks>
  /// Enum :
  /// <para>
  /// finetune, batch
  /// </para>
  /// </remarks>
  TFilePurpose = (
    /// <summary>
    /// The file will be used for fine-tuning.
    /// </summary>
    finetune,
    /// <summary>
    /// The file will be used for batch operation
    /// </summary>
    batch
  );

  /// <summary>
  /// Helper methods for <c>TFilePurpose</c> enumeration.
  /// </summary>
  TFilePurposeHelper = record helper for TFilePurpose
    /// <summary>
    /// Converts the <c>TFilePurpose</c> value to its string representation.
    /// </summary>
    /// <returns>
    /// A string representing the <c>TFilePurpose</c> value.
    /// </returns>
    /// <remarks>
    /// For example:
    /// <code>
    /// var
    ///   Purpose: TFilePurpose;
    /// begin
    ///   Purpose := TFilePurpose.finetune;
    ///   ShowMessage(Purpose.ToString); // Outputs 'fine-tune'
    /// end;
    /// </code>
    /// </remarks>
    function ToString: string;
    /// <summary>
    /// Creates a <c>TFilePurpose</c> from its string representation.
    /// </summary>
    /// <param name="Value">
    /// The string representation of the <c>TFilePurpose</c>.
    /// </param>
    /// <returns>
    /// The <c>TFilePurpose</c> corresponding to the specified string.
    /// </returns>
    /// <exception cref="Exception">
    /// Raised if the string does not correspond to any <c>TFilePurpose</c> value.
    /// </exception>
    /// <remarks>
    /// For example:
    /// <code>
    /// var
    ///   Purpose: TFilePurpose;
    /// begin
    ///   Purpose := TFilePurposeHelper.Create('fine-tune');
    ///   // Purpose now equals TFilePurpose.finetune
    /// end;
    /// </code>
    /// </remarks>
    class function Create(const Value: string): TFilePurpose; static;
  end;

  /// <summary>
  /// JSON interceptor to convert <c>TFilePurpose</c> to and from its string representation during JSON serialization.
  /// </summary>
  TFilePurposeInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// Converts the <c>TFilePurpose</c> field value to its string representation.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field.
    /// </param>
    /// <param name="Field">
    /// The name of the field to convert.
    /// </param>
    /// <returns>
    /// The string representation of the <c>TFilePurpose</c> value.
    /// </returns>
    /// <remarks>
    /// This method is used internally during JSON serialization.
    /// </remarks>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string to the <c>TFilePurpose</c> field value during JSON deserialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field.
    /// </param>
    /// <param name="Field">
    /// The name of the field to convert.
    /// </param>
    /// <param name="Arg">
    /// The string value to convert to <c>TFilePurpose</c>.
    /// </param>
    /// <remarks>
    /// This method is used internally during JSON deserialization.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Specifies the sample_type of the file.
  /// </summary>
  /// <remarks>
  /// Enum :
  /// <para>
  /// pretrain, instruct, batch_request, batch_result, batch_error
  /// </para>
  /// </remarks>
  TSampleType = (
    pretrain,
    instruct,
    batch_request,
    batch_result,
    batch_error
  );

  /// <summary>
  /// Helper methods for <c>TSampleType</c> enumeration.
  /// </summary>
  TSampleTypeHelper = record Helper for TSampleType
    /// <summary>
    /// Converts the <c>TSampleType</c> value to its string representation.
    /// </summary>
    /// <returns>
    /// A string representing the <c>TSampleType</c> value.
    /// </returns>
    function ToString: string;
    /// <summary>
    /// Creates a <c>TSampleType</c> from its string representation.
    /// </summary>
    /// <param name="Value">
    /// The string representation of the <c>TSampleType</c>.
    /// </param>
    /// <returns>
    /// The <c>TSampleType</c> corresponding to the specified string.
    /// </returns>
    /// <exception cref="Exception">
    /// Raised if the string does not correspond to any <c>TSampleType</c> value.
    /// </exception>
    class function Create(const Value: string): TSampleType; static;
  end;

  /// <summary>
  /// JSON interceptor to convert <c>TSampleType</c> to and from its string representation during JSON serialization.
  /// </summary>
  TSampleTypeInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// Converts the <c>TSampleType</c> field value to its string representation.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field.
    /// </param>
    /// <param name="Field">
    /// The name of the field to convert.
    /// </param>
    /// <returns>
    /// The string representation of the <c>TSampleType</c> value.
    /// </returns>
    /// <remarks>
    /// This method is used internally during JSON serialization.
    /// </remarks>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string to the <c>TSampleType</c> field value during JSON deserialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field.
    /// </param>
    /// <param name="Field">
    /// The name of the field to convert.
    /// </param>
    /// <param name="Arg">
    /// The string value to convert to <c>TSampleType</c>.
    /// </param>
    /// <remarks>
    /// This method is used internally during JSON deserialization.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Specifies the source of the file.
  /// </summary>
  /// <remarks>
  /// Enum :
  /// <para>
  /// upload, repository, mistral
  /// </para>
  /// </remarks>
  TSourceType = (
    upload,
    repository,
    mistral
  );

  TSourceTypeHelper = record Helper for TSourceType
    /// <summary>
    /// Converts the <c>TSourceType</c> value to its string representation.
    /// </summary>
    /// <returns>
    /// A string representing the <c>TSourceType</c> value.
    /// </returns>
    function ToString: string;
    /// <summary>
    /// Creates a <c>TSourceType</c> from its string representation.
    /// </summary>
    /// <param name="Value">
    /// The string representation of the <c>TSourceType</c>.
    /// </param>
    /// <returns>
    /// The <c>TSourceType</c> corresponding to the specified string.
    /// </returns>
    /// <exception cref="Exception">
    /// Raised if the string does not correspond to any <c>TSourceType</c> value.
    /// </exception>
    class function Create(const Value: string): TSourceType; static;
  end;

  /// <summary>
  /// JSON interceptor to convert <c>TSourceType</c> to and from its string representation during JSON serialization.
  /// </summary>
  TSourceTypeInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// Converts the <c>TSourceType</c> field value to its string representation.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field.
    /// </param>
    /// <param name="Field">
    /// The name of the field to convert.
    /// </param>
    /// <returns>
    /// The string representation of the <c>TSourceType</c> value.
    /// </returns>
    /// <remarks>
    /// This method is used internally during JSON serialization.
    /// </remarks>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string to the <c>TSourceType</c> field value during JSON deserialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field.
    /// </param>
    /// <param name="Field">
    /// The name of the field to convert.
    /// </param>
    /// <param name="Arg">
    /// The string value to convert to <c>TSourceType</c>.
    /// </param>
    /// <remarks>
    /// This method is used internally during JSON deserialization.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  {$ENDREGION}

  {$REGION 'MistralAI.Functions.Tools'}

  /// <summary>
  /// Defines the model's function call behavior. This type determines whether the model generates
  /// a response, calls a function, or decides between the two.
  /// </summary>
  TToolChoice = (
    /// <summary>
    /// The model won't call a function and will generate a message instead
    /// </summary>
    none,
    /// <summary>
    /// The model can choose to either generate a message or call a function
    /// </summary>
    auto,
    /// <summary>
    /// The model is forced to call a function
    /// </summary>
    any,
    /// <summary>
    /// The model is required to call a function
    /// </summary>
    required);

  /// <summary>
  /// A helper record for the <c>TToolChoice</c> type, providing additional functionality.
  /// </summary>
  TToolChoiceHelper = record helper for TToolChoice
    /// <summary>
    /// Converts the <c>TToolChoice</c> value to its string representation.
    /// </summary>
    /// <returns>A string representing the current <c>TToolChoice</c> value.</returns>
    function ToString: string;
  end;

  {$ENDREGION}

  {$REGION 'MistralAI.Batch'}

  /// <summary>
  /// Represents the different status of a batch.
  /// </summary>
  TBatchStatus = (
    /// <summary>
    /// The batch is waiting to be processed. It is placed on the queue.
    /// </summary>
    BSQueued,
    /// <summary>
    /// The batch is being processed.
    /// </summary>
    BSRunning,
    /// <summary>
    /// Batch processing completed successfully.
    /// </summary>
    BSSuccess,
    /// <summary>
    /// Batch processing failed.
    /// </summary>
    BSFailed,
    /// <summary>
    /// The execution deadline has been reached.
    /// </summary>
    BSTimeout_exceeded,
    /// <summary>
    /// A request to abandon batch processing has been submitted.
    /// </summary>
    BSCancellation_requested,
    /// <summary>
    /// Batch processing has been aborted.
    /// </summary>
    BSCancelled
  );

  /// <summary>
  /// Provides helper methods for the TBatchStatus enumeration.
  /// </summary>
  TBatchStatusHelper = record Helper for TBatchStatus
    /// <summary>
    /// Returns the string representation of the TBatchStatus value.
    /// </summary>
    function ToString: string;
    /// <summary>
    /// Creates a TBatchStatus value from a given string.
    /// </summary>
    /// <param name="Value">The string representation of the TBatchStatus.</param>
    /// <returns>A TBatchStatus corresponding to the provided string.</returns>
    class function Create(const Value: string): TBatchStatus; static;
  end;

  /// <summary>
  /// Interceptor class for converting and reverting TBatchStatus values to and from strings in JSON.
  /// </summary>
  TBatchStatusInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// Converts a TBatchStatus value to its string representation for JSON serialization.
    /// </summary>
    /// <param name="Data">The object containing the field to be converted.</param>
    /// <param name="Field">The name of the field to be converted.</param>
    /// <returns>The string representation of the TBatchStatus value.</returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Reverts a string representation back to a TBatchStatus value during JSON deserialization.
    /// </summary>
    /// <param name="Data">The object containing the field to be reverted.</param>
    /// <param name="Field">The name of the field to be reverted.</param>
    /// <param name="Arg">
    /// The string representation of the TBatchStatus value.
    ///</param>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Endpoint for batch job.
  /// </summary>
  /// <remarks>
  /// Enum : epChatCompletion, epEmbeddings, epFimCompletions, epModeration
  /// <para>
  /// respectively for :
  /// </para>
  /// <para>
  /// - epChatCompletion : /v1/chat/completions
  /// </para>
  /// <para>
  /// - epEmbeddings : /v1/embeddings
  /// </para>
  /// <para>
  /// - epFimCompletions : /v1/fim/completions
  /// </para>
  /// <para>
  /// - epModeration : /v1/moderations
  /// </para>
  /// </remarks>
  TEndPointType = (
    /// <summary>
    /// /v1/chat/completions
    /// </summary>
    epChatCompletion,
    /// <summary>
    /// /v1/embeddings
    /// </summary>
    epEmbeddings,
    /// <summary>
    /// /v1/fim/completions
    /// </summary>
    epFimCompletions,
    /// <summary>
    /// /v1/moderations
    /// </summary>
    epModeration
  );

  /// <summary>
  /// Provides helper methods for the TEndPointType enumeration.
  /// </summary>
  TEndPointTypeHelper = record Helper for TEndPointType
    /// <summary>
    /// Returns the string representation of the TEndPointType value.
    /// </summary>
    /// <remarks>
    /// Enum : epChatCompletion, epEmbeddings, epFimCompletions, epModeration
    /// <para>
    /// respectively for :
    /// </para>
    /// <para>
    /// - epChatCompletion : /v1/chat/completions
    /// </para>
    /// <para>
    /// - epEmbeddings : /v1/embeddings
    /// </para>
    /// <para>
    /// - epFimCompletions : /v1/fim/completions
    /// </para>
    /// <para>
    /// - epModeration : /v1/moderations
    /// </para>
    /// </remarks>
    function ToString: string;
    /// <summary>
    /// Creates a TEndPointType value from a given string.
    /// </summary>
    /// <param name="Value">The string representation of the TEndPointType.</param>
    /// <returns>A TEndPointType corresponding to the provided string.</returns>
    class function Create(const Value: string): TEndPointType; static;
  end;

  /// <summary>
  /// Interceptor class for converting and reverting TEndPointType values to and from strings in JSON.
  /// </summary>
  TEndPointTypeInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// Converts a TEndPointType value to its string representation for JSON serialization.
    /// </summary>
    /// <param name="Data">The object containing the field to be converted.</param>
    /// <param name="Field">The name of the field to be converted.</param>
    /// <returns>The string representation of the TEndPointType value.</returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Reverts a string representation back to a TEndPointType value during JSON deserialization.
    /// </summary>
    /// <param name="Data">The object containing the field to be reverted.</param>
    /// <param name="Field">The name of the field to be reverted.</param>
    /// <param name="Arg">
    /// The string representation of the TEndPointType value.
    ///</param>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  {$ENDREGION}

  {$REGION 'MistralAI.Classifiers'}

  resourcestring
    SexualCategory = 'Sexual';
    HateAndDiscriminationCategory = 'Hate and discrimination';
    ViolenceAndThreatsCategory = 'Violence and threats';
    DangerousAndCriminalContentCategory = 'Dangerous and criminal content';
    SelfharmCategory = 'Selfharm';
    HealthCategory = 'Health';
    FinancialCategory = 'Financial';
    LawCategory = 'Law';
    PiiCategory = 'Pii';

  var
    Classifiers: TArray<string> =
      [SexualCategory, HateAndDiscriminationCategory, ViolenceAndThreatsCategory,
       DangerousAndCriminalContentCategory, SelfharmCategory, HealthCategory,
       FinancialCategory, LawCategory, PiiCategory];

  {$ENDREGION}

implementation

uses
  System.StrUtils, Rest.Json, System.Rtti;

{ TMessageRoleHelper }

class function TMessageRoleHelper.FromString(const Value: string): TMessageRole;
begin
  var index := IndexStr(Value.ToLower, ['system', 'user', 'assistant', 'tool']);
  if index = -1 then
    raise Exception.Create('Invalid message role value.');
  Result := TMessageRole(index);
end;

function TMessageRoleHelper.ToString: string;
begin
  case Self of
    system:
      Exit('system');
    user:
      Exit('user');
    assistant:
      Exit('assistant');
    tool:
      Exit('tool');
  end;
end;

{ TFinishReasonHelper }

class function TFinishReasonHelper.Create(const Value: string): TFinishReason;
begin
  var index := IndexStr(Value.ToLower, ['stop', 'length', 'model_length', 'error', 'tool_calls']);
  if index = -1 then
    raise Exception.Create('Invalid finish reason value.');
  Result := TFinishReason(index);
end;

function TFinishReasonHelper.ToString: string;
begin
  case Self of
    stop:
      Exit('stop');
    length_limit:
      Exit('length');
    model_length:
      Exit('model_length');
    error:
      Exit('error');
    tool_calls:
      Exit('tool_calls');
  end;
end;

{ TFinishReasonInterceptor }

function TFinishReasonInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TFinishReason>.ToString;
end;

procedure TFinishReasonInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TFinishReason.Create(Arg)));
end;

{ TContentTypeHelper }

function TContentTypeHelper.ToString: string;
begin
  case Self of
    text:
      Exit('text');
    image_url:
      Exit('image_url');
  end;
end;

{ TToolTypeHelper }

function TToolTypeHelper.ToString: string;
begin
  case Self of
    ttfunction:
      Exit('function');
  end;
end;

{ TFineTuningJobStatusHelper }

class function TFineTuningJobStatusHelper.Create(
  const Value: string): TFineTuningJobStatus;
begin
  var index := IndexStr(Value.ToUpper, [
    'QUEUED', 'STARTED', 'VALIDATING', 'VALIDATED', 'RUNNING', 'FAILED_VALIDATION', 'FAILED',
    'SUCCESS', 'CANCELLED', 'CANCELLATION_REQUESTED']);
  if index = -1 then
    raise Exception.Create('Invalid fine-tuning job status value.');
  Result := TFineTuningJobStatus(index);
end;

function TFineTuningJobStatusHelper.ToString: string;
begin
  case Self of
    Queued:
      Exit('QUEUED');
    Started:
      Exit('STARTED');
    Validating:
      Exit('VALIDATING');
    Validated:
      Exit('VALIDATED');
    Running:
      Exit('RUNNING');
    Failed_validation:
      Exit('FAILED_VALIDATION');
    Failed:
      Exit('FAILED');
    Success:
      Exit('SUCCESS');
    Cancelled:
      Exit('CANCELLED');
    CancellationRequested:
      Exit('CANCELLATION_REQUESTED');
  end;
end;

{ TFineTuningJobStatusInterceptor }

function TFineTuningJobStatusInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TFineTuningJobStatus>.ToString;
end;

procedure TFineTuningJobStatusInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TFineTuningJobStatus.Create(Arg)));
end;

{ TFineTuningDataObjectKindHelper }

class function TFineTuningDataObjectKindHelper.Create(
  const Value: string): TFineTuningDataObjectKind;
begin
  var index := IndexStr(Value.ToLower, ['job']);
  if index = -1 then
    raise Exception.Create('Invalid fine-tuning data object value.');
  Result := TFineTuningDataObjectKind(index);
end;

function TFineTuningDataObjectKindHelper.ToString: string;
begin
  case Self of
    Job:
      Exit('job');
  end;
end;

{ TFineTuningDataObjectKindInterceptor }

function TFineTuningDataObjectKindInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TFineTuningDataObjectKind>.ToString;
end;

procedure TFineTuningDataObjectKindInterceptor.StringReverter(Data: TObject;
  Field, Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TFineTuningDataObjectKind.Create(Arg)));
end;

{ TFineTuningIntegrationTypeHelper }

class function TFineTuningIntegrationTypeHelper.Create(
  const Value: string): TFineTuningIntegrationType;
begin
  case IndexStr(Value.ToLower, ['wandb']) of
    0 :
      Exit(Wandb);
    else
      raise Exception.Create('Invalid fine-tuning integration value.');
  end;
end;

function TFineTuningIntegrationTypeHelper.ToString: string;
begin
  case self of
    Wandb:
      Exit('wandb');
  end;
end;

{ TFineTuningIntegrationTypeInterceptor }

function TFineTuningIntegrationTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TFineTuningIntegrationType>.ToString;
end;

procedure TFineTuningIntegrationTypeInterceptor.StringReverter(Data: TObject;
  Field, Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TFineTuningIntegrationType.Create(Arg)));
end;

{ TFineTuningObjectKindHelper }

class function TFineTuningObjectKindHelper.Create(
  const Value: string): TFineTuningObjectKind;
begin
  var index := IndexStr(Value.ToLower, ['list']);
  if index = -1 then
    raise Exception.Create('Invalid Fine tuning object value.');
  Result := TFineTuningObjectKind(index);
end;

function TFineTuningObjectKindHelper.ToString: string;
begin
  case self of
    List:
      Exit('list');
  end;
end;

{ TFineTuningObjectKindInterceptor }

function TFineTuningObjectKindInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TFineTuningObjectKind>.ToString;
end;

procedure TFineTuningObjectKindInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TFineTuningObjectKind.Create(Arg)));
end;

{ TCodestralFinishReasonHelper }

class function TCodestralFinishReasonHelper.Create(
  const Value: string): TCodestralFinishReason;
begin
  var index := IndexStr(Value.ToLower, ['stop', 'length', 'model_length', 'error', 'tool_calls']);
  if index = -1 then
    raise Exception.Create('Invalid codestral finish reason value.');
  Result := TCodestralFinishReason(index);
end;

function TCodestralFinishReasonHelper.ToString: string;
begin
  case Self of
    csstop:
      Exit('stop');
    cslength_limite:
      Exit('length');
    csmodel_length:
      Exit('model_length');
    cserror:
      Exit('error');
    cstool_calls:
      Exit('tool_calls');
  end;
end;

{ TCodestralFinishReasonInterceptor }

function TCodestralFinishReasonInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TCodestralFinishReason>.ToString;
end;

procedure TCodestralFinishReasonInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TCodestralFinishReason.Create(Arg)));
end;

{ TFilePurposeHelper }

class function TFilePurposeHelper.Create(const Value: string): TFilePurpose;
begin
  var index := IndexStr(Value.ToLower, ['fine-tune', 'batch']);
  if index = - 1 then
    raise Exception.Create('Invalid files purpose value.');
  Result := TFilePurpose(index);
end;

function TFilePurposeHelper.ToString: string;
begin
  case self of
    FineTune:
      Exit('fine-tune');
    batch:
      Exit('batch');
  end;
end;

{ TFilePurposeInterceptor }

function TFilePurposeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TFilePurpose>.ToString;
end;

procedure TFilePurposeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TFilePurpose.Create(Arg)));
end;

{ TToolChoiceHelper }

function TToolChoiceHelper.ToString: string;
begin
  case Self of
    auto:
      Exit('auto');
    any:
      Exit('any');
    required:
      Exit('required');
    else
      Exit('none');
  end;
end;

{ TSampleTypeHelper }

class function TSampleTypeHelper.Create(const Value: string): TSampleType;
begin
  var index := IndexStr(Value.ToLower, [
    'pretrain', 'instruct', 'batch_request', 'batch_result', 'batch_error']);
  if index = -1 then
    raise Exception.Create('Invalid file sample value.');
  Result := TSampleType(index);
end;

function TSampleTypeHelper.ToString: string;
begin
  case Self of
    pretrain:
      Exit('pretrain');
    instruct:
      Exit('instruct');
    batch_request:
      Exit('batch_request');
    batch_result:
      Exit('batch_result');
    batch_error:
      Exit('batch_error');
  end;
end;

{ TSourceTypeHelper }

class function TSourceTypeHelper.Create(const Value: string): TSourceType;
begin
  var index := IndexStr(Value.ToLower, ['upload', 'repository', 'mistral']);
  if index = -1 then
    raise Exception.Create('Invalid file source value.');
  Result := TSourceType(index);
end;

function TSourceTypeHelper.ToString: string;
begin
  case Self of
    upload:
      Exit('upload');
    repository:
      Exit('repository');
    mistral:
      Exit('mistral');
  end;
end;

{ TSampleTypeInterceptor }

function TSampleTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TSampleType>.ToString;
end;

procedure TSampleTypeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TSampleType.Create(Arg)));
end;

{ TSourceTypeInterceptor }

function TSourceTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TSourceType>.ToString;
end;

procedure TSourceTypeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TSourceType.Create(Arg)));
end;

{ TRepositoryTypeHelper }

class function TRepositoryTypeHelper.Create(
  const Value: string): TRepositoryType;
begin
  var index := IndexStr(Value.ToLower, ['github']);
  if index = -1 then
    raise Exception.Create('Invalid repository value.');
  Result := TRepositoryType(index);
end;

function TRepositoryTypeHelper.ToString: string;
begin
  case Self of
    github:
      Exit('github');
  end;
end;

{ TRepositoryTypeInterceptor }

function TRepositoryTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TRepositoryType>.ToString;
end;

procedure TRepositoryTypeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TRepositoryType.Create(Arg)));
end;

{ TBatchStatusHelper }

class function TBatchStatusHelper.Create(const Value: string): TBatchStatus;
begin
  var index := IndexStr(Value.ToUpper, [
    'QUEUED', 'RUNNING', 'SUCCESS', 'FAILED', 'TIMEOUT_EXCEEDED', 'CANCELLATION_REQUESTED', 'CANCELLED']);
  if index = -1 then
    raise Exception.Create('Invalid batch status value.');
  Result := TBatchStatus(index);
end;

function TBatchStatusHelper.ToString: string;
begin
  case Self of
    BSQueued:
      Exit('QUEUED');
    BSRunning:
      Exit('RUNNING');
    BSSuccess:
      Exit('SUCCESS');
    BSFailed:
      Exit('FAILED');
    BSTimeout_exceeded:
      Exit('TIMEOUT_EXCEEDED');
    BSCancellation_requested:
      Exit('CANCELLATION_REQUESTED');
    BSCancelled:
      Exit('CANCELLED');
  end;
end;

{ TBatchStatusInterceptor }

function TBatchStatusInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TBatchStatus>.ToString;
end;

procedure TBatchStatusInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TBatchStatus.Create(Arg)));
end;

{ TEndPointTypeHelper }

class function TEndPointTypeHelper.Create(const Value: string): TEndPointType;
begin
  var index := IndexStr(Value.ToLower, [
    '/v1/chat/completions', '/v1/embeddings', '/v1/fim/completions', '/v1/moderations']);
  if index = -1 then
    raise Exception.Create('Invalid endpoint value.');
  Result := TEndPointType(index);
end;

function TEndPointTypeHelper.ToString: string;
begin
  case Self of
    epChatCompletion:
      Exit('/v1/chat/completions');
    epEmbeddings:
      Exit('/v1/embeddings');
    epFimCompletions:
      Exit('/v1/fim/completions');
    epModeration:
      Exit('/v1/moderations');
  end;
end;

{ TEndPointTypeInterceptor }

function TEndPointTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TEndPointType>.ToString;
end;

procedure TEndPointTypeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TEndPointType.Create(Arg)));
end;

{ TMetadataInterceptor }

procedure TMetadataInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  Arg := Format('{%s}', [Trim(Arg.Replace('`', '"').Replace(#10, ''))]);
  while Arg.Contains(', ') do Arg := Arg.Replace(', ', ',');
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, Arg.Replace(',', ', '));
end;

end.

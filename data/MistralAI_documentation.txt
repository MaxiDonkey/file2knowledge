DelphiMistralAI wrapper brings Mistral’s text-vision-audio models and agentic Conversations to Delphi, with chat, embeddings, Codestral codegen, fine-tuning, batching, moderation, async/await helpers and live request monitoring.

# Partie 1: The source code of MistralAI (unit by unit)

unit MistralAI.Agents;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, System.Threading,
  REST.Json.Types, MistralAI.API.Params, MistralAI.API, MistralAI.Functions.Core,
  MistralAI.Functions.Tools, MistralAI.Chat, MistralAI.Async.Params,
  MistralAI.Async.Support, MistralAI.Async.Promise, MistralAI.Types,
  MistralAI.API.Normalizer;

type
  /// <summary>
  /// Alias for <c>TChatMessagePayload</c>, representing an agent message payload.
  /// </summary>
  TAgentMessagePayload = TChatMessagePayload;

  /// <summary>
  /// Represents the parameters used to configure an agent request.
  /// </summary>
  /// <remarks>
  /// Use this class to set various options for the agent, such as model configuration, messages, and other settings.
  /// </remarks>
  TAgentParams = class(TJSONParam)
    /// <summary>
    /// Sets the maximum number of tokens to generate in the completion.
    /// The token count of your prompt plus <c>max_tokens</c> cannot exceed the model's context length.
    /// </summary>
    /// <param name="Value">
    /// The maximum number of tokens to generate in the completion.
    /// </param>
    /// <returns>
    /// An instance of <c>TAgentParams</c> with the <c>MaxTokens</c> parameter set.
    /// </returns>
    function MaxTokens(const Value: Integer): TAgentParams;

    /// <summary>
    /// Enables or disables streaming of partial progress.
    /// </summary>
    /// <param name="Value">
    /// Set to <c>True</c> to enable streaming mode; otherwise, set to <c>False</c>.
    /// </param>
    /// <returns>
    /// An instance of <c>TAgentParams</c> with the <c>Stream</c> parameter set.
    /// </returns>
    /// <remarks>
    /// Default is <c>False</c>. When streaming is enabled, partial progress is sent as data-only server-side events.
    /// </remarks>
    function Stream(const Value: Boolean = True): TAgentParams;

    /// <summary>
    /// Sets a string token at which to stop text generation.
    /// </summary>
    /// <param name="Value">
    /// A string token at which to stop the text generation.
    /// </param>
    /// <returns>
    /// An instance of <c>TAgentParams</c> with the <c>Stop</c> parameter set.
    /// </returns>
    function Stop(const Value: string): TAgentParams; overload;

    /// <summary>
    /// Sets an array of string tokens at which to stop text generation.
    /// </summary>
    /// <param name="Value">
    /// An array of string tokens at which to stop the text generation.
    /// </param>
    /// <returns>
    /// An instance of <c>TAgentParams</c> with the <c>Stop</c> parameter set.
    /// </returns>
    function Stop(const Value: TArray<string>): TAgentParams; overload;

    /// <summary>
    /// Sets the seed for random sampling to produce deterministic results.
    /// </summary>
    /// <param name="Value">
    /// The seed value for random sampling.
    /// </param>
    /// <returns>
    /// An instance of <c>TAgentParams</c> with the <c>RandomSeed</c> parameter set.
    /// </returns>
    function RandomSeed(const Value: Integer): TAgentParams;

    /// <summary>
    /// Sets the messages to generate completions for, encoded as a list of dictionaries with role and content.
    /// </summary>
    /// <param name="Value">
    /// An array of <c>TAgentMessagePayload</c> representing the messages in the conversation.
    /// </param>
    /// <returns>
    /// An instance of <c>TAgentParams</c> with the <c>Messages</c> parameter set.
    /// </returns>
    function Messages(const Value: TArray<TChatMessagePayload>): TAgentParams;

    /// <summary>
    /// Specifies the format that the model must output.
    /// </summary>
    /// <param name="Value">
    /// Specifies the desired response format type. For example, 'json_object' to enforce JSON output.
    /// </param>
    /// <returns>
    /// An instance of <c>TAgentParams</c> with the <c>ResponseFormat</c> parameter set.
    /// </returns>
    /// <remarks>
    /// Default value is { "type": "text" } if <c>ResponseFormat</c> is not called.
    /// </remarks>
    function ResponseFormat(const Value: string = 'json_object'): TAgentParams;

    /// <summary>
    /// Sets the list of available tools for the model.
    /// </summary>
    /// <param name="Value">
    /// An array of <c>TChatMessageTool</c> representing the available tools for the model.
    /// </param>
    /// <returns>
    /// An instance of <c>TAgentParams</c> with the <c>Tools</c> parameter set.
    /// </returns>
    function Tools(const Value: TArray<TChatMessageTool>): TAgentParams;

    /// <summary>
    /// Specifies if and how functions are called during the conversation.
    /// </summary>
    /// <param name="Value">
    /// Specifies how tools are used during the conversation. Options are <c>none</c>, <c>auto</c>, or <c>any</c>.
    /// </param>
    /// <returns>
    /// An instance of <c>TAgentParams</c> with the <c>ToolChoice</c> parameter set.
    /// </returns>
    /// <remarks>
    /// Default is <c>auto</c>. If set to <c>none</c>, the model will not call a function. If set to <c>auto</c>, the model can choose to generate a message or call a function. If set to <c>any</c>, the model is forced to call a function.
    /// </remarks>
    function ToolChoice(const Value: TToolChoice): TAgentParams;  overload;

    /// <summary>
    /// Configures how the model interacts when required is on.
    /// </summary>
    /// <param name="Value">
    /// The <c>TToolChoice</c> setting for function interaction, with a default of "auto".
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function ToolChoice(const FunctionName: string): TChatParams; overload;

    /// <summary>
    /// Presence_penalty determines how much the model penalizes the repetition of words or phrases
    /// </summary>
    /// <param name="Value">
    /// number (Presence Penalty) [ -2 .. 2 ]; Default: 0
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// A higher presence penalty encourages the model to use a wider variety of words and phrases,
    /// making the output more diverse and creative.
    /// </remarks>
    function PresencePenalty(const Value: Double): TAgentParams;

    /// <summary>
    /// Frequency_penalty penalizes the repetition of words based on their frequency in the generated text.
    /// </summary>
    /// <param name="Value">
    /// number (Presence Penalty) [ -2 .. 2 ]; Default: 0
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// A higher frequency penalty discourages the model from repeating words that have already appeared
    /// frequently in the output, promoting diversity and reducing repetition.
    /// </remarks>
    function FrequencyPenalty(const Value: Double): TAgentParams;

    /// <summary>
    /// Enable users to specify expected results, optimizing response times by leveraging known or
    /// predictable content.
    /// </summary>
    /// <param name="Value">The string prediction content.</param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// This approach is especially effective for updating text documents or code files with minimal
    /// changes, reducing latency while maintaining high-quality results.
    /// </remarks>
    function Prediction(const Value: string): TAgentParams;

    /// <summary>
    /// Whether to allow the model to run tool calls in parallel.
    /// </summary>
    /// <param name="Value">If true then enable parallel mode.</param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// Default: true
    /// </remarks>
    function ParallelToolCalls(const Value: Boolean): TAgentParams;

    /// <summary>
    /// Allows toggling between the reasoning mode and no system prompt.
    /// When set to reasoning the system prompt for reasoning models will be used.
    /// </summary>
    function PromptMode(const Value: string = 'reasoning'): TAgentParams;

    /// <summary>
    /// Number of completions to return for each request, input tokens are only billed once.
    /// </summary>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function N(const Value: Integer): TAgentParams;

    /// <summary>
    /// Sets the ID of the agent to use for this completion.
    /// </summary>
    /// <param name="Value">
    /// The identifier of the agent to be used for the completion.
    /// </param>
    /// <returns>
    /// An instance of <c>TAgentParams</c> with the <c>AgentId</c> parameter set.
    /// </returns>
    function AgentId(const Value: string): TAgentParams;
  end;

  /// <summary>
  /// Provides methods to interact with agents, including creating completions and handling asynchronous operations.
  /// </summary>
  /// <remarks>
  /// Use this class to manage agent interactions, including synchronous and asynchronous requests.
  /// </remarks>
  TAgentRoute = class(TMistralAIAPIRoute)
  public
    /// <summary>
    /// Initiates an asynchronous agent completion request using an awaitable promise.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the agent request, including model, prompt, tokens, and tool usage.
    /// </param>
    /// <param name="Callbacks">
    /// (Optional) A function returning a <c>TPromiseChat</c> structure containing callback handlers such as <c>OnSuccess</c>, <c>OnError</c>, and <c>OnStart</c>.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TChat&gt;</c> object that can be awaited to retrieve the resulting chat completion.
    /// </returns>
    /// <remarks>
    /// This method wraps the asynchronous execution of an agent call in a promise, allowing a fluent await-style programming model.
    /// It is particularly useful in scenarios where chaining or async/await-like behavior is preferred.
    /// </remarks>
    function AsyncAwaitCreate(const ParamProc: TProc<TAgentParams>;
      const Callbacks: TFunc<TPromiseChat> = nil): TPromise<TChat>;

    /// <summary>
    /// Initiates an asynchronous agent request in streaming mode using an awaitable promise.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the agent request, including model settings, messages, and tool configurations.
    /// </param>
    /// <param name="Callbacks">
    /// A function returning a <c>TPromiseChatStream</c> record that defines handlers for progress, success, error, cancellation, and optional sender context.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;string&gt;</c> that resolves with the concatenated streamed content when the operation completes successfully.
    /// </returns>
    /// <remarks>
    /// This method wraps an asynchronous streaming request in a promise interface, allowing developers to consume token-by-token progress and still benefit from a final resolved result.
    /// The collected streamed output is automatically buffered and returned as a single string.
    /// </remarks>
    function AsyncAwaitCreateStream(const ParamProc: TProc<TAgentParams>;
      const Callbacks: TFunc<TPromiseChatStream>): TPromise<string>;

    /// <summary>
    /// Creates a completion for an agent synchronously.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the parameters for the agent request.
    /// </param>
    /// <returns>
    /// An instance of <c>TAgent</c> containing the completion result.
    /// </returns>
    /// <exception cref="MistralAIExceptionAPI"> MistralAIExceptionAPI </exception>
    /// <exception cref="MistralAIExceptionInvalidRequestError"> MistralAIExceptionInvalidRequestError </exception>
    /// <remarks>
    /// This function sends a synchronous request to create an agent completion based on the provided parameters.
    ///
    /// <code>
    ///   var Agent := MistralAI.Agent.Create(
    ///     procedure (Params: TAgentParams)
    ///     begin
    ///       // Define agent parameters
    ///     end);
    ///   try
    ///     for var Choice in Agent.Choices do
    ///       WriteLn(Choice.Message.Content);
    ///   finally
    ///     Agent.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Create(ParamProc: TProc<TAgentParams>): TChat;

    /// <summary>
    /// Creates a completion for an agent with a streamed response.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the parameters for the agent request.
    /// </param>
    /// <param name="Event">
    /// An event handler to process each streamed response.
    /// </param>
    /// <returns>
    /// <c>True</c> if the streaming was successful; otherwise, <c>False</c>.
    /// </returns>
    /// <remarks>
    /// The <c>Agent</c> object will be <c>nil</c> when all data is received.
    ///
    /// <code>
    ///    MistralAI.Agent.Create(
    ///     procedure (Params: TAgentParams)
    ///     begin
    ///       // Define agent parameters
    ///     end,
    ///
    ///     procedure(var Agent: TAgent; IsDone: Boolean; var Cancel: Boolean)
    ///     begin
    ///       // handle displaying
    ///     end);
    /// </code>
    /// </remarks>
    function CreateStream(ParamProc: TProc<TAgentParams>; Event: TChatEvent): Boolean;

    /// <summary>
    /// Initiates an asynchronous request to create an agent completion based on the provided parameters.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the parameters for the agent request, such as model selection, messages, and other parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for the asynchronous agent operation, such as on success and on error.
    /// </param>
    /// <remarks>
    /// This procedure initiates an asynchronous request to generate a chat completion based on the provided parameters. The response or error is handled by the provided callbacks.
    /// <code>
    /// // Example usage:
    /// MistralAI.Agent.AsyncCreate(
    ///   procedure(Params: TAgentParams)
    ///   begin
    ///     // Define agent parameters
    ///   end,
    ///   function: TAsynAgent
    ///   begin
    ///     Result.OnSuccess :=
    ///        procedure(Sender: TObject; Agent: TAgent)
    ///        begin
    ///         // Handle success
    ///        end;
    ///     Result.OnError :=
    ///        procedure(Sender: TObject; const ErrorMsg: string)
    ///        begin
    ///          // Handle error
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncCreate(ParamProc: TProc<TAgentParams>; CallBacks: TFunc<TAsynChat>);

    /// <summary>
    /// Creates an asynchronous streaming agent completion request.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the agent request, including the model, messages, and additional options such as max tokens and streaming mode.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a <c>TAsynAgentStream</c> record which contains event handlers for managing different stages of the streaming process: progress updates, success, errors, and cancellation.
    /// </param>
    /// <remarks>
    /// This procedure initiates an asynchronous chat operation in streaming mode, where tokens are progressively received and processed.
    /// The provided event handlers allow for handling progress (i.e., receiving tokens in real time), detecting success, managing errors, and enabling cancellation logic.
    /// <code>
    /// // Example usage:
    /// MistralAI.Agent.AsyncStreamCreate(
    ///   procedure(Params: TAgentParams)
    ///   begin
    ///     // Define agent parameters
    ///   end,
    ///   function: TAsynAgentStream
    ///   begin
    ///     Result.OnProgress :=
    ///        procedure (Sender: TObject; Chat : TChat)
    ///        begin
    ///          // Handle progress
    ///        end;
    ///     Result.OnSuccess :=
    ///        procedure(Sender: TObject)
    ///        begin
    ///         // Handle success
    ///        end;
    ///     Result.OnError :=
    ///        procedure(Sender: TObject; const ErrorMsg: string)
    ///        begin
    ///          // Handle error
    ///        end;
    ///     Result.OnDoCancel :=
    ///        function : Boolean
    ///        begin
    ///          Result := CheckBox1.Checked; // Click the CheckBox to cancel
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncCreateStream(ParamProc: TProc<TAgentParams>; CallBacks: TFunc<TAsynChatStream>);
  end;

implementation

uses
  system.StrUtils, Rest.Json;

{ TAgentParams }

function TAgentParams.AgentId(const Value: string): TAgentParams;
begin
  Result := TAgentParams(Add('agent_id', Value));
end;

function TAgentParams.FrequencyPenalty(const Value: Double): TAgentParams;
begin
  Result := TAgentParams(Add('frequency_penalty', Value));
end;

function TAgentParams.MaxTokens(const Value: Integer): TAgentParams;
begin
  Result := TAgentParams(Add('max_tokens', Value));
end;

function TAgentParams.Messages(
  const Value: TArray<TChatMessagePayload>): TAgentParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TAgentParams(Add('messages', JSONArray));
end;

function TAgentParams.N(const Value: Integer): TAgentParams;
begin
  Result := TAgentParams(Add('n', Value));
end;

function TAgentParams.ParallelToolCalls(const Value: Boolean): TAgentParams;
begin
  Result := TAgentParams(Add('parallel_tool_calls', Value));
end;

function TAgentParams.Prediction(const Value: string): TAgentParams;
begin
  Result := TAgentParams(Add('prediction',
    TJSONObject.Create
      .AddPair('type', 'content')
      .AddPair('content', Value)
  ));
end;

function TAgentParams.PresencePenalty(const Value: Double): TAgentParams;
begin
  Result := TAgentParams(Add('presence_penalty', Value));
end;

function TAgentParams.PromptMode(const Value: string): TAgentParams;
begin
  Result := TAgentParams(Add('prompt_mode', Value));
end;

function TAgentParams.RandomSeed(const Value: Integer): TAgentParams;
begin
  Result := TAgentParams(Add('random_seed', Value));
end;

function TAgentParams.ResponseFormat(const Value: string): TAgentParams;
begin
  var JSON := TJSONObject.Create;
  JSON.AddPair('type', Value);
  Result := TAgentParams(Add('response_format', JSON));
end;

function TAgentParams.Stop(const Value: TArray<string>): TAgentParams;
begin
  Result := TAgentParams(Add('stop', Value));
end;

function TAgentParams.Stop(const Value: string): TAgentParams;
begin
  Result := TAgentParams(Add('stop', Value));
end;

function TAgentParams.Stream(const Value: Boolean): TAgentParams;
begin
  Result := TAgentParams(Add('stream', Value));
end;

function TAgentParams.ToolChoice(const Value: TToolChoice): TAgentParams;
begin
  Result := TAgentParams(Add('tool_choice', Value.ToString));
end;

function TAgentParams.ToolChoice(const FunctionName: string): TChatParams;
begin
  var Tool := TJSONParam.Create
        .Add('type', 'function')
        .Add('function', TJSONObject.Create
          .AddPair('Name', FunctionName));
  Result := TChatParams(Add('tool_choice', Tool.Detach));
end;

function TAgentParams.Tools(
  const Value: TArray<TChatMessageTool>): TAgentParams;
var
  Item: TChatMessageTool;
  Items: TJSONArray;
begin
  Items := TJSONArray.Create;
  try
    for Item in Value do
      begin
        Items.Add(Item.ToJson);
      end;
    Result := TAgentParams(Add('tools', Items));
  except
    on E: Exception do
      begin
        Items.Free;
        raise;
      end;
  end;
end;

{ TAgentRoute }

function TAgentRoute.AsyncAwaitCreate(const ParamProc: TProc<TAgentParams>;
  const Callbacks: TFunc<TPromiseChat>): TPromise<TChat>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TChat>(
    procedure(const CallbackParams: TFunc<TAsynChat>)
    begin
      AsyncCreate(ParamProc, CallbackParams);
    end,
    Callbacks);
end;

function TAgentRoute.AsyncAwaitCreateStream(
  const ParamProc: TProc<TAgentParams>;
  const Callbacks: TFunc<TPromiseChatStream>): TPromise<string>;
begin
  Result := TPromise<string>.Create(
    procedure(Resolve: TProc<string>; Reject: TProc<Exception>)
    var
      Buffer: string;
    begin
      AsyncCreateStream(ParamProc,
        function : TAsynChatStream
        begin
          Result.Sender := Callbacks.Sender;

          Result.OnStart := Callbacks.OnStart;

          Result.OnProgress :=
            procedure (Sender: TObject; Event: TChat)
            begin
              if Assigned(Callbacks.OnProgress) then
                Callbacks.OnProgress(Sender, Event);
              Buffer := Buffer + Event.Choices[0].Delta.Content[0].Text;
            end;

          Result.OnSuccess :=
            procedure (Sender: TObject)
            begin
              Resolve(Buffer);
            end;

          Result.OnError :=
            procedure (Sender: TObject; Error: string)
            begin
              if Assigned(Callbacks.OnError) then
                Error := Callbacks.OnError(Sender, Error);
              Reject(Exception.Create(Error));
            end;

          Result.OnDoCancel :=
            function : Boolean
            begin
              if Assigned(Callbacks.OnDoCancel) then
                Result := Callbacks.OnDoCancel()
              else
                Result := False;
            end;

          Result.OnCancellation :=
            procedure (Sender: TObject)
            begin
              var Error := 'aborted';
              if Assigned(Callbacks.OnCancellation) then
                Error := Callbacks.OnCancellation(Sender);
              Reject(Exception.Create(Error));
            end;
        end);
    end);
end;

procedure TAgentRoute.AsyncCreate(ParamProc: TProc<TAgentParams>;
  CallBacks: TFunc<TAsynChat>);
begin
  with TAsyncCallBackExec<TAsynChat, TChat>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TChat
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TAgentRoute.AsyncCreateStream(ParamProc: TProc<TAgentParams>;
  CallBacks: TFunc<TAsynChatStream>);
begin
  var CallBackParams := TUseParamsFactory<TAsynChatStream>.CreateInstance(CallBacks);

  var Sender := CallBackParams.Param.Sender;
  var OnStart := CallBackParams.Param.OnStart;
  var OnSuccess := CallBackParams.Param.OnSuccess;
  var OnProgress := CallBackParams.Param.OnProgress;
  var OnError := CallBackParams.Param.OnError;
  var OnCancellation := CallBackParams.Param.OnCancellation;
  var OnDoCancel := CallBackParams.Param.OnDoCancel;

  var Task: ITask := TTask.Create(
          procedure()
          begin
            {--- Pass the instance of the current class in case no value was specified. }
            if not Assigned(Sender) then
              Sender := Self;

            {--- Trigger OnStart callback }
            if Assigned(OnStart) then
              TThread.Queue(nil,
                procedure
                begin
                  OnStart(Sender);
                end);
            try
              var Stop := False;

              {--- Processing }
              CreateStream(ParamProc,
                procedure (var Agent: TChat; IsDone: Boolean; var Cancel: Boolean)
                begin
                  {--- Check that the process has not been canceled }
                  if Assigned(OnDoCancel) then
                    TThread.Queue(nil,
                        procedure
                        begin
                          Stop := OnDoCancel();
                        end);
                  if Stop then
                    begin
                      {--- Trigger when processus was stopped }
                      if Assigned(OnCancellation) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnCancellation(Sender)
                        end);
                      Cancel := True;
                      Exit;
                    end;
                  if not IsDone and Assigned(Agent) then
                    begin
                      var LocalAgent := Agent;
                      Agent := nil;

                      {--- Triggered when processus is progressing }
                      if Assigned(OnProgress) then
                        TThread.Synchronize(TThread.Current,
                        procedure
                        begin
                          try
                            OnProgress(Sender, LocalAgent);
                          finally
                            {--- Makes sure to release the instance containing the data obtained
                                 following processing}
                            LocalAgent.Free;
                          end;
                        end);
                    end
                  else
                  if IsDone then
                    begin
                      {--- Trigger OnEnd callback when the process is done }
                      if Assigned(OnSuccess) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnSuccess(Sender);
                        end);
                    end;
                end);
            except
              on E: Exception do
                begin
                  var Error := AcquireExceptionObject;
                  try
                    var ErrorMsg := (Error as Exception).Message;

                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(OnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        OnError(Sender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
          end);
  Task.Start;
end;

function TAgentRoute.Create(ParamProc: TProc<TAgentParams>): TChat;
begin
  Result := API.Post<TChat, TAgentParams>('agents/completions', ParamProc);
end;

function TAgentRoute.CreateStream(ParamProc: TProc<TAgentParams>;
  Event: TChatEvent): Boolean;
var
  Response: TStringStream;
  RetPos: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    RetPos := 0;
    Result := API.Post<TAgentParams>('agents/completions', ParamProc, Response,
      procedure(const Sender: TObject; AContentLength: Int64; AReadCount: Int64; var AAbort: Boolean)
      var
        IsDone: Boolean;
        Data: string;
        Agent: TChat;
        TextBuffer: string;
        Line: string;
        Ret: Integer;
      begin
        try
          TextBuffer := Response.DataString;
        except
          on E: EEncodingError do
            Exit;
        end;

        repeat
          Ret := TextBuffer.IndexOf(#10, RetPos);
          if Ret < 0 then
            Continue;
          Line := TextBuffer.Substring(RetPos, Ret - RetPos);
          RetPos := Ret + 1;

          if Line.IsEmpty or Line.StartsWith(#10) then
            Continue;
          Agent := nil;
          Data := Line.Replace('data: ', '').Trim([' ', #13, #10]);
          IsDone := Data = '[DONE]';

          if not IsDone then
          try
            Agent := TApiDeserializer.Parse<TChat>(
                  TJSONNormalizer.Normalize(Data, ['choices', '*', 'delta', 'content']));
          except
            Agent := nil;
          end;

          try
            Event(Agent, IsDone, AAbort);
          finally
            Agent.Free;
          end;
        until Ret < 0;

      end);
  finally
    Response.Free;
  end;
end;

end.

DelphiMistralAI wrapper brings Mistral’s text-vision-audio models and agentic Conversations to Delphi, with chat, embeddings, Codestral codegen, fine-tuning, batching, moderation, async/await helpers and live request monitoring.

# Partie 1: The source code of MistralAI (unit by unit)

unit MistralAI.Agents;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, System.Threading,
  REST.Json.Types, MistralAI.API.Params, MistralAI.API, MistralAI.Functions.Core,
  MistralAI.Functions.Tools, MistralAI.Chat, MistralAI.Async.Params,
  MistralAI.Async.Support, MistralAI.Async.Promise, MistralAI.Types,
  MistralAI.API.Normalizer;

type
  /// <summary>
  /// Alias for <c>TChatMessagePayload</c>, representing an agent message payload.
  /// </summary>
  TAgentMessagePayload = TChatMessagePayload;

  /// <summary>
  /// Represents the parameters used to configure an agent request.
  /// </summary>
  /// <remarks>
  /// Use this class to set various options for the agent, such as model configuration, messages, and other settings.
  /// </remarks>
  TAgentParams = class(TJSONParam)
    /// <summary>
    /// Sets the maximum number of tokens to generate in the completion.
    /// The token count of your prompt plus <c>max_tokens</c> cannot exceed the model's context length.
    /// </summary>
    /// <param name="Value">
    /// The maximum number of tokens to generate in the completion.
    /// </param>
    /// <returns>
    /// An instance of <c>TAgentParams</c> with the <c>MaxTokens</c> parameter set.
    /// </returns>
    function MaxTokens(const Value: Integer): TAgentParams;

    /// <summary>
    /// Enables or disables streaming of partial progress.
    /// </summary>
    /// <param name="Value">
    /// Set to <c>True</c> to enable streaming mode; otherwise, set to <c>False</c>.
    /// </param>
    /// <returns>
    /// An instance of <c>TAgentParams</c> with the <c>Stream</c> parameter set.
    /// </returns>
    /// <remarks>
    /// Default is <c>False</c>. When streaming is enabled, partial progress is sent as data-only server-side events.
    /// </remarks>
    function Stream(const Value: Boolean = True): TAgentParams;

    /// <summary>
    /// Sets a string token at which to stop text generation.
    /// </summary>
    /// <param name="Value">
    /// A string token at which to stop the text generation.
    /// </param>
    /// <returns>
    /// An instance of <c>TAgentParams</c> with the <c>Stop</c> parameter set.
    /// </returns>
    function Stop(const Value: string): TAgentParams; overload;

    /// <summary>
    /// Sets an array of string tokens at which to stop text generation.
    /// </summary>
    /// <param name="Value">
    /// An array of string tokens at which to stop the text generation.
    /// </param>
    /// <returns>
    /// An instance of <c>TAgentParams</c> with the <c>Stop</c> parameter set.
    /// </returns>
    function Stop(const Value: TArray<string>): TAgentParams; overload;

    /// <summary>
    /// Sets the seed for random sampling to produce deterministic results.
    /// </summary>
    /// <param name="Value">
    /// The seed value for random sampling.
    /// </param>
    /// <returns>
    /// An instance of <c>TAgentParams</c> with the <c>RandomSeed</c> parameter set.
    /// </returns>
    function RandomSeed(const Value: Integer): TAgentParams;

    /// <summary>
    /// Sets the messages to generate completions for, encoded as a list of dictionaries with role and content.
    /// </summary>
    /// <param name="Value">
    /// An array of <c>TAgentMessagePayload</c> representing the messages in the conversation.
    /// </param>
    /// <returns>
    /// An instance of <c>TAgentParams</c> with the <c>Messages</c> parameter set.
    /// </returns>
    function Messages(const Value: TArray<TChatMessagePayload>): TAgentParams;

    /// <summary>
    /// Specifies the format that the model must output.
    /// </summary>
    /// <param name="Value">
    /// Specifies the desired response format type. For example, 'json_object' to enforce JSON output.
    /// </param>
    /// <returns>
    /// An instance of <c>TAgentParams</c> with the <c>ResponseFormat</c> parameter set.
    /// </returns>
    /// <remarks>
    /// Default value is { "type": "text" } if <c>ResponseFormat</c> is not called.
    /// </remarks>
    function ResponseFormat(const Value: string = 'json_object'): TAgentParams;

    /// <summary>
    /// Sets the list of available tools for the model.
    /// </summary>
    /// <param name="Value">
    /// An array of <c>TChatMessageTool</c> representing the available tools for the model.
    /// </param>
    /// <returns>
    /// An instance of <c>TAgentParams</c> with the <c>Tools</c> parameter set.
    /// </returns>
    function Tools(const Value: TArray<TChatMessageTool>): TAgentParams;

    /// <summary>
    /// Specifies if and how functions are called during the conversation.
    /// </summary>
    /// <param name="Value">
    /// Specifies how tools are used during the conversation. Options are <c>none</c>, <c>auto</c>, or <c>any</c>.
    /// </param>
    /// <returns>
    /// An instance of <c>TAgentParams</c> with the <c>ToolChoice</c> parameter set.
    /// </returns>
    /// <remarks>
    /// Default is <c>auto</c>. If set to <c>none</c>, the model will not call a function. If set to <c>auto</c>, the model can choose to generate a message or call a function. If set to <c>any</c>, the model is forced to call a function.
    /// </remarks>
    function ToolChoice(const Value: TToolChoice): TAgentParams;  overload;

    /// <summary>
    /// Configures how the model interacts when required is on.
    /// </summary>
    /// <param name="Value">
    /// The <c>TToolChoice</c> setting for function interaction, with a default of "auto".
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function ToolChoice(const FunctionName: string): TChatParams; overload;

    /// <summary>
    /// Presence_penalty determines how much the model penalizes the repetition of words or phrases
    /// </summary>
    /// <param name="Value">
    /// number (Presence Penalty) [ -2 .. 2 ]; Default: 0
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// A higher presence penalty encourages the model to use a wider variety of words and phrases,
    /// making the output more diverse and creative.
    /// </remarks>
    function PresencePenalty(const Value: Double): TAgentParams;

    /// <summary>
    /// Frequency_penalty penalizes the repetition of words based on their frequency in the generated text.
    /// </summary>
    /// <param name="Value">
    /// number (Presence Penalty) [ -2 .. 2 ]; Default: 0
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// A higher frequency penalty discourages the model from repeating words that have already appeared
    /// frequently in the output, promoting diversity and reducing repetition.
    /// </remarks>
    function FrequencyPenalty(const Value: Double): TAgentParams;

    /// <summary>
    /// Enable users to specify expected results, optimizing response times by leveraging known or
    /// predictable content.
    /// </summary>
    /// <param name="Value">The string prediction content.</param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// This approach is especially effective for updating text documents or code files with minimal
    /// changes, reducing latency while maintaining high-quality results.
    /// </remarks>
    function Prediction(const Value: string): TAgentParams;

    /// <summary>
    /// Whether to allow the model to run tool calls in parallel.
    /// </summary>
    /// <param name="Value">If true then enable parallel mode.</param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// Default: true
    /// </remarks>
    function ParallelToolCalls(const Value: Boolean): TAgentParams;

    /// <summary>
    /// Allows toggling between the reasoning mode and no system prompt.
    /// When set to reasoning the system prompt for reasoning models will be used.
    /// </summary>
    function PromptMode(const Value: string = 'reasoning'): TAgentParams;

    /// <summary>
    /// Number of completions to return for each request, input tokens are only billed once.
    /// </summary>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function N(const Value: Integer): TAgentParams;

    /// <summary>
    /// Sets the ID of the agent to use for this completion.
    /// </summary>
    /// <param name="Value">
    /// The identifier of the agent to be used for the completion.
    /// </param>
    /// <returns>
    /// An instance of <c>TAgentParams</c> with the <c>AgentId</c> parameter set.
    /// </returns>
    function AgentId(const Value: string): TAgentParams;
  end;

  /// <summary>
  /// Provides methods to interact with agents, including creating completions and handling asynchronous operations.
  /// </summary>
  /// <remarks>
  /// Use this class to manage agent interactions, including synchronous and asynchronous requests.
  /// </remarks>
  TAgentRoute = class(TMistralAIAPIRoute)
  public
    /// <summary>
    /// Initiates an asynchronous agent completion request using an awaitable promise.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the agent request, including model, prompt, tokens, and tool usage.
    /// </param>
    /// <param name="Callbacks">
    /// (Optional) A function returning a <c>TPromiseChat</c> structure containing callback handlers such as <c>OnSuccess</c>, <c>OnError</c>, and <c>OnStart</c>.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TChat&gt;</c> object that can be awaited to retrieve the resulting chat completion.
    /// </returns>
    /// <remarks>
    /// This method wraps the asynchronous execution of an agent call in a promise, allowing a fluent await-style programming model.
    /// It is particularly useful in scenarios where chaining or async/await-like behavior is preferred.
    /// </remarks>
    function AsyncAwaitCreate(const ParamProc: TProc<TAgentParams>;
      const Callbacks: TFunc<TPromiseChat> = nil): TPromise<TChat>;

    /// <summary>
    /// Initiates an asynchronous agent request in streaming mode using an awaitable promise.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the agent request, including model settings, messages, and tool configurations.
    /// </param>
    /// <param name="Callbacks">
    /// A function returning a <c>TPromiseChatStream</c> record that defines handlers for progress, success, error, cancellation, and optional sender context.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;string&gt;</c> that resolves with the concatenated streamed content when the operation completes successfully.
    /// </returns>
    /// <remarks>
    /// This method wraps an asynchronous streaming request in a promise interface, allowing developers to consume token-by-token progress and still benefit from a final resolved result.
    /// The collected streamed output is automatically buffered and returned as a single string.
    /// </remarks>
    function AsyncAwaitCreateStream(const ParamProc: TProc<TAgentParams>;
      const Callbacks: TFunc<TPromiseChatStream>): TPromise<string>;

    /// <summary>
    /// Creates a completion for an agent synchronously.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the parameters for the agent request.
    /// </param>
    /// <returns>
    /// An instance of <c>TAgent</c> containing the completion result.
    /// </returns>
    /// <exception cref="MistralAIExceptionAPI"> MistralAIExceptionAPI </exception>
    /// <exception cref="MistralAIExceptionInvalidRequestError"> MistralAIExceptionInvalidRequestError </exception>
    /// <remarks>
    /// This function sends a synchronous request to create an agent completion based on the provided parameters.
    ///
    /// <code>
    ///   var Agent := MistralAI.Agent.Create(
    ///     procedure (Params: TAgentParams)
    ///     begin
    ///       // Define agent parameters
    ///     end);
    ///   try
    ///     for var Choice in Agent.Choices do
    ///       WriteLn(Choice.Message.Content);
    ///   finally
    ///     Agent.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Create(ParamProc: TProc<TAgentParams>): TChat;

    /// <summary>
    /// Creates a completion for an agent with a streamed response.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the parameters for the agent request.
    /// </param>
    /// <param name="Event">
    /// An event handler to process each streamed response.
    /// </param>
    /// <returns>
    /// <c>True</c> if the streaming was successful; otherwise, <c>False</c>.
    /// </returns>
    /// <remarks>
    /// The <c>Agent</c> object will be <c>nil</c> when all data is received.
    ///
    /// <code>
    ///    MistralAI.Agent.Create(
    ///     procedure (Params: TAgentParams)
    ///     begin
    ///       // Define agent parameters
    ///     end,
    ///
    ///     procedure(var Agent: TAgent; IsDone: Boolean; var Cancel: Boolean)
    ///     begin
    ///       // handle displaying
    ///     end);
    /// </code>
    /// </remarks>
    function CreateStream(ParamProc: TProc<TAgentParams>; Event: TChatEvent): Boolean;

    /// <summary>
    /// Initiates an asynchronous request to create an agent completion based on the provided parameters.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the parameters for the agent request, such as model selection, messages, and other parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for the asynchronous agent operation, such as on success and on error.
    /// </param>
    /// <remarks>
    /// This procedure initiates an asynchronous request to generate a chat completion based on the provided parameters. The response or error is handled by the provided callbacks.
    /// <code>
    /// // Example usage:
    /// MistralAI.Agent.AsyncCreate(
    ///   procedure(Params: TAgentParams)
    ///   begin
    ///     // Define agent parameters
    ///   end,
    ///   function: TAsynAgent
    ///   begin
    ///     Result.OnSuccess :=
    ///        procedure(Sender: TObject; Agent: TAgent)
    ///        begin
    ///         // Handle success
    ///        end;
    ///     Result.OnError :=
    ///        procedure(Sender: TObject; const ErrorMsg: string)
    ///        begin
    ///          // Handle error
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncCreate(ParamProc: TProc<TAgentParams>; CallBacks: TFunc<TAsynChat>);

    /// <summary>
    /// Creates an asynchronous streaming agent completion request.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the agent request, including the model, messages, and additional options such as max tokens and streaming mode.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a <c>TAsynAgentStream</c> record which contains event handlers for managing different stages of the streaming process: progress updates, success, errors, and cancellation.
    /// </param>
    /// <remarks>
    /// This procedure initiates an asynchronous chat operation in streaming mode, where tokens are progressively received and processed.
    /// The provided event handlers allow for handling progress (i.e., receiving tokens in real time), detecting success, managing errors, and enabling cancellation logic.
    /// <code>
    /// // Example usage:
    /// MistralAI.Agent.AsyncStreamCreate(
    ///   procedure(Params: TAgentParams)
    ///   begin
    ///     // Define agent parameters
    ///   end,
    ///   function: TAsynAgentStream
    ///   begin
    ///     Result.OnProgress :=
    ///        procedure (Sender: TObject; Chat : TChat)
    ///        begin
    ///          // Handle progress
    ///        end;
    ///     Result.OnSuccess :=
    ///        procedure(Sender: TObject)
    ///        begin
    ///         // Handle success
    ///        end;
    ///     Result.OnError :=
    ///        procedure(Sender: TObject; const ErrorMsg: string)
    ///        begin
    ///          // Handle error
    ///        end;
    ///     Result.OnDoCancel :=
    ///        function : Boolean
    ///        begin
    ///          Result := CheckBox1.Checked; // Click the CheckBox to cancel
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncCreateStream(ParamProc: TProc<TAgentParams>; CallBacks: TFunc<TAsynChatStream>);
  end;

implementation

uses
  system.StrUtils, Rest.Json;

{ TAgentParams }

function TAgentParams.AgentId(const Value: string): TAgentParams;
begin
  Result := TAgentParams(Add('agent_id', Value));
end;

function TAgentParams.FrequencyPenalty(const Value: Double): TAgentParams;
begin
  Result := TAgentParams(Add('frequency_penalty', Value));
end;

function TAgentParams.MaxTokens(const Value: Integer): TAgentParams;
begin
  Result := TAgentParams(Add('max_tokens', Value));
end;

function TAgentParams.Messages(
  const Value: TArray<TChatMessagePayload>): TAgentParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TAgentParams(Add('messages', JSONArray));
end;

function TAgentParams.N(const Value: Integer): TAgentParams;
begin
  Result := TAgentParams(Add('n', Value));
end;

function TAgentParams.ParallelToolCalls(const Value: Boolean): TAgentParams;
begin
  Result := TAgentParams(Add('parallel_tool_calls', Value));
end;

function TAgentParams.Prediction(const Value: string): TAgentParams;
begin
  Result := TAgentParams(Add('prediction',
    TJSONObject.Create
      .AddPair('type', 'content')
      .AddPair('content', Value)
  ));
end;

function TAgentParams.PresencePenalty(const Value: Double): TAgentParams;
begin
  Result := TAgentParams(Add('presence_penalty', Value));
end;

function TAgentParams.PromptMode(const Value: string): TAgentParams;
begin
  Result := TAgentParams(Add('prompt_mode', Value));
end;

function TAgentParams.RandomSeed(const Value: Integer): TAgentParams;
begin
  Result := TAgentParams(Add('random_seed', Value));
end;

function TAgentParams.ResponseFormat(const Value: string): TAgentParams;
begin
  var JSON := TJSONObject.Create;
  JSON.AddPair('type', Value);
  Result := TAgentParams(Add('response_format', JSON));
end;

function TAgentParams.Stop(const Value: TArray<string>): TAgentParams;
begin
  Result := TAgentParams(Add('stop', Value));
end;

function TAgentParams.Stop(const Value: string): TAgentParams;
begin
  Result := TAgentParams(Add('stop', Value));
end;

function TAgentParams.Stream(const Value: Boolean): TAgentParams;
begin
  Result := TAgentParams(Add('stream', Value));
end;

function TAgentParams.ToolChoice(const Value: TToolChoice): TAgentParams;
begin
  Result := TAgentParams(Add('tool_choice', Value.ToString));
end;

function TAgentParams.ToolChoice(const FunctionName: string): TChatParams;
begin
  var Tool := TJSONParam.Create
        .Add('type', 'function')
        .Add('function', TJSONObject.Create
          .AddPair('Name', FunctionName));
  Result := TChatParams(Add('tool_choice', Tool.Detach));
end;

function TAgentParams.Tools(
  const Value: TArray<TChatMessageTool>): TAgentParams;
var
  Item: TChatMessageTool;
  Items: TJSONArray;
begin
  Items := TJSONArray.Create;
  try
    for Item in Value do
      begin
        Items.Add(Item.ToJson);
      end;
    Result := TAgentParams(Add('tools', Items));
  except
    on E: Exception do
      begin
        Items.Free;
        raise;
      end;
  end;
end;

{ TAgentRoute }

function TAgentRoute.AsyncAwaitCreate(const ParamProc: TProc<TAgentParams>;
  const Callbacks: TFunc<TPromiseChat>): TPromise<TChat>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TChat>(
    procedure(const CallbackParams: TFunc<TAsynChat>)
    begin
      AsyncCreate(ParamProc, CallbackParams);
    end,
    Callbacks);
end;

function TAgentRoute.AsyncAwaitCreateStream(
  const ParamProc: TProc<TAgentParams>;
  const Callbacks: TFunc<TPromiseChatStream>): TPromise<string>;
begin
  Result := TPromise<string>.Create(
    procedure(Resolve: TProc<string>; Reject: TProc<Exception>)
    var
      Buffer: string;
    begin
      AsyncCreateStream(ParamProc,
        function : TAsynChatStream
        begin
          Result.Sender := Callbacks.Sender;

          Result.OnStart := Callbacks.OnStart;

          Result.OnProgress :=
            procedure (Sender: TObject; Event: TChat)
            begin
              if Assigned(Callbacks.OnProgress) then
                Callbacks.OnProgress(Sender, Event);
              Buffer := Buffer + Event.Choices[0].Delta.Content[0].Text;
            end;

          Result.OnSuccess :=
            procedure (Sender: TObject)
            begin
              Resolve(Buffer);
            end;

          Result.OnError :=
            procedure (Sender: TObject; Error: string)
            begin
              if Assigned(Callbacks.OnError) then
                Error := Callbacks.OnError(Sender, Error);
              Reject(Exception.Create(Error));
            end;

          Result.OnDoCancel :=
            function : Boolean
            begin
              if Assigned(Callbacks.OnDoCancel) then
                Result := Callbacks.OnDoCancel()
              else
                Result := False;
            end;

          Result.OnCancellation :=
            procedure (Sender: TObject)
            begin
              var Error := 'aborted';
              if Assigned(Callbacks.OnCancellation) then
                Error := Callbacks.OnCancellation(Sender);
              Reject(Exception.Create(Error));
            end;
        end);
    end);
end;

procedure TAgentRoute.AsyncCreate(ParamProc: TProc<TAgentParams>;
  CallBacks: TFunc<TAsynChat>);
begin
  with TAsyncCallBackExec<TAsynChat, TChat>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TChat
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TAgentRoute.AsyncCreateStream(ParamProc: TProc<TAgentParams>;
  CallBacks: TFunc<TAsynChatStream>);
begin
  var CallBackParams := TUseParamsFactory<TAsynChatStream>.CreateInstance(CallBacks);

  var Sender := CallBackParams.Param.Sender;
  var OnStart := CallBackParams.Param.OnStart;
  var OnSuccess := CallBackParams.Param.OnSuccess;
  var OnProgress := CallBackParams.Param.OnProgress;
  var OnError := CallBackParams.Param.OnError;
  var OnCancellation := CallBackParams.Param.OnCancellation;
  var OnDoCancel := CallBackParams.Param.OnDoCancel;

  var Task: ITask := TTask.Create(
          procedure()
          begin
            {--- Pass the instance of the current class in case no value was specified. }
            if not Assigned(Sender) then
              Sender := Self;

            {--- Trigger OnStart callback }
            if Assigned(OnStart) then
              TThread.Queue(nil,
                procedure
                begin
                  OnStart(Sender);
                end);
            try
              var Stop := False;

              {--- Processing }
              CreateStream(ParamProc,
                procedure (var Agent: TChat; IsDone: Boolean; var Cancel: Boolean)
                begin
                  {--- Check that the process has not been canceled }
                  if Assigned(OnDoCancel) then
                    TThread.Queue(nil,
                        procedure
                        begin
                          Stop := OnDoCancel();
                        end);
                  if Stop then
                    begin
                      {--- Trigger when processus was stopped }
                      if Assigned(OnCancellation) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnCancellation(Sender)
                        end);
                      Cancel := True;
                      Exit;
                    end;
                  if not IsDone and Assigned(Agent) then
                    begin
                      var LocalAgent := Agent;
                      Agent := nil;

                      {--- Triggered when processus is progressing }
                      if Assigned(OnProgress) then
                        TThread.Synchronize(TThread.Current,
                        procedure
                        begin
                          try
                            OnProgress(Sender, LocalAgent);
                          finally
                            {--- Makes sure to release the instance containing the data obtained
                                 following processing}
                            LocalAgent.Free;
                          end;
                        end);
                    end
                  else
                  if IsDone then
                    begin
                      {--- Trigger OnEnd callback when the process is done }
                      if Assigned(OnSuccess) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnSuccess(Sender);
                        end);
                    end;
                end);
            except
              on E: Exception do
                begin
                  var Error := AcquireExceptionObject;
                  try
                    var ErrorMsg := (Error as Exception).Message;

                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(OnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        OnError(Sender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
          end);
  Task.Start;
end;

function TAgentRoute.Create(ParamProc: TProc<TAgentParams>): TChat;
begin
  Result := API.Post<TChat, TAgentParams>('agents/completions', ParamProc);
end;

function TAgentRoute.CreateStream(ParamProc: TProc<TAgentParams>;
  Event: TChatEvent): Boolean;
var
  Response: TStringStream;
  RetPos: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    RetPos := 0;
    Result := API.Post<TAgentParams>('agents/completions', ParamProc, Response,
      procedure(const Sender: TObject; AContentLength: Int64; AReadCount: Int64; var AAbort: Boolean)
      var
        IsDone: Boolean;
        Data: string;
        Agent: TChat;
        TextBuffer: string;
        Line: string;
        Ret: Integer;
      begin
        try
          TextBuffer := Response.DataString;
        except
          on E: EEncodingError do
            Exit;
        end;

        repeat
          Ret := TextBuffer.IndexOf(#10, RetPos);
          if Ret < 0 then
            Continue;
          Line := TextBuffer.Substring(RetPos, Ret - RetPos);
          RetPos := Ret + 1;

          if Line.IsEmpty or Line.StartsWith(#10) then
            Continue;
          Agent := nil;
          Data := Line.Replace('data: ', '').Trim([' ', #13, #10]);
          IsDone := Data = '[DONE]';

          if not IsDone then
          try
            Agent := TApiDeserializer.Parse<TChat>(
                  TJSONNormalizer.Normalize(Data, ['choices', '*', 'delta', 'content']));
          except
            Agent := nil;
          end;

          try
            Event(Agent, IsDone, AAbort);
          finally
            Agent.Free;
          end;
        until Ret < 0;

      end);
  finally
    Response.Free;
  end;
end;

end.

unit MistralAI.API.Normalizer;

interface

uses
  System.SysUtils, System.JSON;

type
  /// <summary>
  /// Provides functionality to normalize specified JSON string fields into a standardized array-of-objects format.
  /// </summary>
  TJSONNormalizer = record
  private
    class function DoNormalize(const Raw: string;
      const Path: TArray<string>): string; static;

    class function NormalizeNode(Node: TJSONValue;
      const Path: TArray<string>; Depth: Integer): Boolean; static;
  public
    /// <summary>
    /// Entry point to normalize a JSON string. If the path is empty or parsing fails, returns the original string.
    /// </summary>
    /// <param name="Raw">The raw JSON text to normalize.</param>
    /// <param name="Path">Sequence of keys and/or "*" wildcards indicating which fields to convert.</param>
    /// <returns>
    /// The normalized JSON string with target fields wrapped in the format:
    /// <c>[ { "type": "text", "text": "&lt;original&gt;" } ]</c>.
    /// Returns the original <paramref name="Raw"/> if no modifications were made or on parse error.
    /// </returns>
    class function Normalize(const Raw: string;
      const Path: TArray<string>): string; static;
  end;

implementation

{ TJSONNormalizer }

class function TJSONNormalizer.Normalize(const Raw: string;
  const Path: TArray<string>): string;
begin
  Result := DoNormalize(Raw, TArray<string>(Path));
end;

class function TJSONNormalizer.DoNormalize(const Raw: string;
  const Path: TArray<string>): string;
var
  Root: TJSONValue;
begin
  if Length(Path) = 0 then
    Exit(Raw);

  Root := TJSONObject.ParseJSONValue(Raw);
  if not Assigned(Root) then
    Exit(Raw);

  try
    if not NormalizeNode(Root, Path, 0) then
      Exit(Raw);

    if Root is TJSONObject then
      Result := TJSONObject(Root).ToJSON
    else
      Result := Root.ToJSON;
  finally
    Root.Free;
  end;
end;

class function TJSONNormalizer.NormalizeNode(Node: TJSONValue;
  const Path: TArray<string>; Depth: Integer): Boolean;
var
  Key     : string;
  NextVal : TJSONValue;
  JObj    : TJSONObject;
  JArr    : TJSONArray;
  S       : string;
  NewArr  : TJSONArray;
  OldPair : TJSONPair;
begin
  Result := False;

  if Depth >= Length(Path) then
    Exit;

  Key := Path[Depth];

  {--- wildcard "*" -> we browse the current table }
  if Key = '*' then
    begin
      if not (Node is TJSONArray) then
        Exit;

      JArr := TJSONArray(Node);
      for var Item in JArr do
        if NormalizeNode(Item, Path, Depth + 1) then
          Result := True;
      Exit;
    end;

  {--- explicit key -> we go down into the object }
  if not (Node is TJSONObject) then
    Exit;

  JObj := TJSONObject(Node);
  NextVal := JObj.GetValue(Key);
  if not Assigned(NextVal) then
    Exit;

  {--- Last link in the path: we are in the "happy" field }
  if Depth = High(Path) then
    begin
      if NextVal is TJSONArray then
        Exit;

      if not (NextVal is TJSONString) then
        raise Exception.CreateFmt(
          'TJSONNormalizer: "%s" is neither JSONString nor JSONArray (got %s)',
          [Key, NextVal.ClassName]);

      S := TJSONString(NextVal).Value;

      NewArr := TJSONArray.Create;
      NewArr.Add(
        TJSONObject.Create
          .AddPair('type', 'text')
          .AddPair('text', S)
      );

      OldPair := JObj.RemovePair(Key);
      OldPair.Free;
      JObj.AddPair(Key, NewArr);
      Result := True;
      Exit;
    end;

  {--- Otherwise we continue to descend }
  Result := NormalizeNode(NextVal, Path, Depth + 1);
end;

end.

unit MistralAI.API.Params;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.Classes, System.JSON, System.SysUtils, System.Types, System.RTTI,
  System.Generics.Collections, System.Threading, System.NetEncoding,
  REST.JsonReflect, REST.Json.Interceptors;

type
  /// <summary>
  /// Represents a base class for all classes obtained after deserialization.
  /// </summary>
  /// <remarks>
  /// This class is designed to store the raw JSON string returned by the API,
  /// allowing applications to access the original JSON response if needed.
  /// </remarks>
  TJSONFingerprint = class
  private
    FJSONResponse: string;
  public
    /// <summary>
    /// Gets or sets the raw JSON string returned by the API.
    /// </summary>
    /// <remarks>
    /// Typically, the API returns a single JSON string, which is stored in this property.
    /// </remarks>
    property JSONResponse: string read FJSONResponse write FJSONResponse;
  end;

  TJSONInterceptorStringToString = class(TJSONInterceptor)
    constructor Create; reintroduce;
  protected
    RTTI: TRttiContext;
  end;

type
  /// <summary>
  /// Represents a reference to a procedure that takes a single argument of type T and returns no value.
  /// </summary>
  /// <param name="T">
  /// The type of the argument that the referenced procedure will accept.
  /// </param>
  /// <remarks>
  /// This type is useful for defining callbacks or procedures that operate on a variable of type T, allowing for more flexible and reusable code.
  /// </remarks>
  TProcRef<T> = reference to procedure(var Arg: T);

  TJSONParam = class
  private
    FJSON: TJSONObject;
    procedure SetJSON(const Value: TJSONObject);
    function GetCount: Integer;

  public
    constructor Create; virtual;
    destructor Destroy; override;
    function Add(const Key: string; const Value: string): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: Integer): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: Int64): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: Extended): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: Boolean): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: TDateTime; Format: string): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: TJSONValue): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: TJSONParam): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<string>): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<Integer>): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<Int64>): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<Extended>): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<TJSONValue>): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<TJSONParam>): TJSONParam; overload; virtual;
    function GetOrCreateObject(const Name: string): TJSONObject;
    function GetOrCreate<T: TJSONValue, constructor>(const Name: string): T;
    procedure Delete(const Key: string); virtual;
    procedure Clear; virtual;
    property Count: Integer read GetCount;
    function Detach: TJSONObject;
    property JSON: TJSONObject read FJSON write SetJSON;
    function ToJsonString(FreeObject: Boolean = False): string; virtual;
    function ToFormat(FreeObject: Boolean = False): string;
    function ToStringPairs: TArray<TPair<string, string>>;
    function ToStream: TStringStream;
  end;

  TUrlParam = class
  private
    FValue: string;
    procedure Check(const Name: string);
    function GetValue: string;
  public
    /// <summary>
    /// Adds a string parameter to the query string.
    /// </summary>
    /// <param name="Name">
    /// The name of the parameter.
    /// </param>
    /// <param name="Value">
    /// The value of the parameter.
    /// </param>
    /// <returns>
    /// The current instance of <c>TUrlParam</c>, allowing for method chaining.
    /// </returns>
    function Add(const Name, Value: string): TUrlParam; overload; virtual;

    /// <summary>
    /// Adds an integer parameter to the query string.
    /// </summary>
    /// <param name="Name">
    /// The name of the parameter.
    /// </param>
    /// <param name="Value">
    /// The integer value of the parameter.
    /// </param>
    /// <returns>
    /// The current instance of <c>TUrlParam</c>, allowing for method chaining.
    /// </returns>
    function Add(const Name: string; Value: Integer): TUrlParam; overload; virtual;

    /// <summary>
    /// Adds an integer 64 parameter to the query string.
    /// </summary>
    /// <param name="Name">
    /// The name of the parameter.
    /// </param>
    /// <param name="Value">
    /// The integer 64 value of the parameter.
    /// </param>
    /// <returns>
    /// The current instance of <c>TUrlParam</c>, allowing for method chaining.
    /// </returns>
    function Add(const Name: string; Value: Int64): TUrlParam; overload; virtual;

    /// <summary>
    /// Adds a boolean parameter to the query string.
    /// </summary>
    /// <param name="Name">
    /// The name of the parameter.
    /// </param>
    /// <param name="Value">
    /// The boolean value of the parameter. It will be converted to "true" or "false".
    /// </param>
    /// <returns>
    /// The current instance of <c>TUrlParam</c>, allowing for method chaining.
    /// </returns>
    function Add(const Name: string; Value: Boolean): TUrlParam; overload; virtual;

    /// <summary>
    /// Adds a double parameter to the query string.
    /// </summary>
    /// <param name="Name">
    /// The name of the parameter.
    /// </param>
    /// <param name="Value">
    /// The double value of the parameter.
    /// </param>
    /// <returns>
    /// The current instance of <c>TUrlParam</c>, allowing for method chaining.
    /// </returns>
    function Add(const Name: string; Value: Double): TUrlParam; overload; virtual;

    /// <summary>
    /// Adds an array of string values to the query string as a single parameter.
    /// </summary>
    /// <param name="Name">
    /// The name of the parameter.
    /// </param>
    /// <param name="Value">
    /// The array of string values to be added, joined by commas.
    /// </param>
    /// <returns>
    /// The current instance of <c>TUrlParam</c>, allowing for method chaining.
    /// </returns>
    function Add(const Name: string; Value: TArray<string>): TUrlParam; overload; virtual;

    /// <summary>
    /// Gets the constructed query string with all parameters.
    /// </summary>
    /// <returns>
    /// The query string, prefixed with a question mark ("?") if parameters are present.
    /// </returns>
    property Value: string read GetValue;

    constructor Create; virtual;
  end;

  /// <summary>
  /// Represents a generic key-value parameter manager.
  /// </summary>
  /// <remarks>
  /// This class allows storing and retrieving various types of parameters as key-value pairs.
  /// It supports basic types (integers, strings, booleans, floating-point numbers), objects,
  /// as well as arrays of these types.
  /// </remarks>
  /// <example>
  ///   <code>
  ///     var Params: TParameters;
  ///     begin
  ///       Params := TParameters.Create;
  ///       Params.Add('Limit', 100)
  ///             .Add('Order', 'Asc')
  ///             .Add('IsEnabled', True);
  ///       if Params.Exists('Limit') then
  ///         ShowMessage(IntToStr(Params.GetInteger('Limit')));
  ///       Params.Free;
  ///     end;
  ///   </code>
  /// </example>
  TParameters = class
  private
    FParams: TDictionary<string, TValue>;
  public
    constructor Create;
    destructor Destroy; override;
    function Add(const AKey: string; const AValue: Integer): TParameters; overload;
    function Add(const AKey: string; const AValue: Int64): TParameters; overload;
    function Add(const AKey: string; const AValue: string): TParameters; overload;
    function Add(const AKey: string; const AValue: Single): TParameters; overload;
    function Add(const AKey: string; const AValue: Double): TParameters; overload;
    function Add(const AKey: string; const AValue: Boolean): TParameters; overload;
    function Add(const AKey: string; const AValue: TObject): TParameters; overload;
    function Add(const AKey: string; const AValue: TJSONObject): TParameters; overload;
    function Add(const AKey: string; const AValue: TArray<string>): TParameters; overload;
    function Add(const AKey: string; const AValue: TArray<Integer>): TParameters; overload;
    function Add(const AKey: string; const AValue: TArray<Int64>): TParameters; overload;
    function Add(const AKey: string; const AValue: TArray<Single>): TParameters; overload;
    function Add(const AKey: string; const AValue: TArray<Double>): TParameters; overload;
    function Add(const AKey: string; const AValue: TArray<Boolean>): TParameters; overload;
    function Add(const AKey: string; const AValue: TArray<TObject>): TParameters; overload;
    function Add(const AKey: string; const AValue: TArray<TJSONObject>): TParameters; overload;

    function GetInteger(const AKey: string; const ADefault: Integer = 0): Integer;
    function GetInt64(const AKey: string; const ADefault: Integer = 0): Integer;
    function GetString(const AKey: string; const ADefault: string = ''): string;
    function GetSingle(const AKey: string; const ADefault: Single = 0.0): Double;
    function GetDouble(const AKey: string; const ADefault: Double = 0.0): Double;
    function GetBoolean(const AKey: string; const ADefault: Boolean = False): Boolean;
    function GetObject(const AKey: string; const ADefault: TObject = nil): TObject;
    function GetJSONObject(const AKey: string): TJSONObject;

    function GetArrayString(const AKey: string): TArray<string>;
    function GetArrayInteger(const AKey: string): TArray<Integer>;
    function GetArrayInt64(const AKey: string): TArray<Int64>;
    function GetArraySingle(const AKey: string): TArray<Single>;
    function GetArrayDouble(const AKey: string): TArray<Double>;
    function GetArrayBoolean(const AKey: string): TArray<Boolean>;
    function GetArrayObject(const AKey: string): TArray<TObject>;
    function GetArrayJSONObject(const AKey: string): TArray<TJSONObject>;
    function GetJSONArray(const AKey: string): TJSONArray;

    function Exists(const AKey: string): Boolean;
    procedure ProcessParam(const AKey: string; ACallback: TProc<TValue>);
  end;

const
  DATE_FORMAT = 'YYYY-MM-DD';
  TIME_FORMAT = 'HH:NN:SS';
  DATE_TIME_FORMAT = DATE_FORMAT + ' ' + TIME_FORMAT;

implementation

uses
  System.DateUtils;

{ TJSONInterceptorStringToString }

constructor TJSONInterceptorStringToString.Create;
begin
  ConverterType := ctString;
  ReverterType := rtString;
end;

{ Fetch }

type
  Fetch<T> = class
    type
      TFetchProc = reference to procedure(const Element: T);
  public
    class procedure All(const Items: TArray<T>; Proc: TFetchProc);
  end;

{ Fetch<T> }

class procedure Fetch<T>.All(const Items: TArray<T>; Proc: TFetchProc);
var
  Item: T;
begin
  for Item in Items do
    Proc(Item);
end;

{ TJSONParam }

function TJSONParam.Add(const Key, Value: string): TJSONParam;
begin
  Delete(Key);
  FJSON.AddPair(Key, Value);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: TJSONValue): TJSONParam;
begin
  Delete(Key);
  FJSON.AddPair(Key, Value);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: TJSONParam): TJSONParam;
begin
  Add(Key, TJSONValue(Value.JSON.Clone));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: TDateTime; Format: string): TJSONParam;
begin
  if Format.IsEmpty then
    Format := DATE_TIME_FORMAT;
  Add(Key, FormatDateTime(Format, System.DateUtils.TTimeZone.local.ToUniversalTime(Value)));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: Boolean): TJSONParam;
begin
  Add(Key, TJSONBool.Create(Value));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: Integer): TJSONParam;
begin
  Add(Key, TJSONNumber.Create(Value));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: Extended): TJSONParam;
begin
  Add(Key, TJSONNumber.Create(Value));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<TJSONValue>): TJSONParam;
var
  JArr: TJSONArray;
begin
  JArr := TJSONArray.Create;
  Fetch<TJSONValue>.All(Value, JArr.AddElement);
  Add(Key, JArr);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<TJSONParam>): TJSONParam;
var
  JArr: TJSONArray;
  Item: TJSONParam;
begin
  JArr := TJSONArray.Create;
  for Item in Value do
  try
    JArr.AddElement(Item.JSON);
    Item.JSON := nil;
  finally
    Item.Free;
  end;
  Add(Key, JArr);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<Int64>): TJSONParam;
var
  JArr: TJSONArray;
  Item: Integer;
begin
  JArr := TJSONArray.Create;
  for Item in Value do
    JArr.Add(Item);
  Add(Key, JArr);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: Int64): TJSONParam;
begin
  Add(Key, TJSONNumber.Create(Value));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<Extended>): TJSONParam;
var
  JArr: TJSONArray;
  Item: Extended;
begin
  JArr := TJSONArray.Create;
  for Item in Value do
    JArr.Add(Item);
  Add(Key, JArr);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<Integer>): TJSONParam;
var
  JArr: TJSONArray;
  Item: Integer;
begin
  JArr := TJSONArray.Create;
  for Item in Value do
    JArr.Add(Item);
  Add(Key, JArr);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<string>): TJSONParam;
var
  JArr: TJSONArray;
  Item: string;
begin
  JArr := TJSONArray.Create;
  for Item in Value do
    JArr.Add(Item);
  Add(Key, JArr);
  Result := Self;
end;

procedure TJSONParam.Clear;
begin
  FJSON.Free;
  FJSON := TJSONObject.Create;
end;

constructor TJSONParam.Create;
begin
  FJSON := TJSONObject.Create;
end;

procedure TJSONParam.Delete(const Key: string);
var
  Item: TJSONPair;
begin
  Item := FJSON.RemovePair(Key);
  if Assigned(Item) then
    Item.Free;
end;

destructor TJSONParam.Destroy;
begin
  if Assigned(FJSON) then
    FJSON.Free;
  inherited;
end;

function TJSONParam.Detach: TJSONObject;
begin
  Result := JSON;
  JSON := nil;
  var Task: ITask := TTask.Create(
    procedure()
    begin
      Sleep(30);
      TThread.Queue(nil,
      procedure
      begin
        Self.Free;
      end);
    end
  );
  Task.Start;
end;

function TJSONParam.GetCount: Integer;
begin
  Result := FJSON.Count;
end;

function TJSONParam.GetOrCreate<T>(const Name: string): T;
begin
  if not FJSON.TryGetValue<T>(Name, Result) then
  begin
    Result := T.Create;
    FJSON.AddPair(Name, Result);
  end;
end;

function TJSONParam.GetOrCreateObject(const Name: string): TJSONObject;
begin
  Result := GetOrCreate<TJSONObject>(Name);
end;

procedure TJSONParam.SetJSON(const Value: TJSONObject);
begin
  FJSON := Value;
end;

function TJSONParam.ToFormat(FreeObject: Boolean): string;
begin
  Result := FJSON.Format(4);
  if FreeObject then
    Free;
end;

function TJSONParam.ToJsonString(FreeObject: Boolean): string;
begin
  Result := FJSON.ToJSON;
  if FreeObject then
    Free;
end;

function TJSONParam.ToStream: TStringStream;
begin
  Result := TStringStream.Create;
  try
    Result.WriteString(ToJsonString);
    Result.Position := 0;
  except
    Result.Free;
    raise;
  end;
end;

function TJSONParam.ToStringPairs: TArray<TPair<string, string>>;
begin
  for var Pair in FJSON do
    Result := Result + [TPair<string, string>.Create(Pair.JsonString.Value, Pair.JsonValue.AsType<string>)];
end;

{ TUrlParam }

function TUrlParam.Add(const Name, Value: string): TUrlParam;
begin
  Check(Name);
  var S := Format('%s=%s', [Name, TNetEncoding.URL.Encode(Value).Replace('+', '%20')]);
  if FValue.IsEmpty then
    FValue := S else
    FValue := FValue + '&' + S;
  Result := Self;
end;

function TUrlParam.Add(const Name: string; Value: Integer): TUrlParam;
begin
  Result := Add(Name, Value.ToString);
end;

function TUrlParam.Add(const Name: string; Value: Boolean): TUrlParam;
begin
  Result := Add(Name, BoolToStr(Value, true));
end;

function TUrlParam.Add(const Name: string; Value: Double): TUrlParam;
begin
  Result := Add(Name, Value.ToString);
end;

procedure TUrlParam.Check(const Name: string);
var
  Params: TArray<string>;
begin
  var Items := FValue.Split(['&']);
  FValue := EmptyStr;
  for var Item in Items do
    begin
      if not Item.StartsWith(Name + '=') then
        Params := Params + [Item];
    end;
  FValue := string.Join('&', Params);
end;

constructor TUrlParam.Create;
begin
  FValue := EmptyStr;
end;

function TUrlParam.GetValue: string;
var
  Params: TArray<string>;
begin
  var Items := FValue.Split(['&']);
  for var Item in Items do
    begin
      var SubStr := Item.Split(['=']);
      if Length(SubStr) <> 2 then
        raise Exception.CreateFmt('%s: Ivalid URL parameter.', [SubStr]);
      Params := Params + [
        TNetEncoding.URL.Encode(SubStr[0]).Replace('+', '%20') + '=' + SubStr[1] ];
    end;
  Result := string.Join('&', Params);
  if not Result.IsEmpty then
    Result := '?' + Result;
end;

function TUrlParam.Add(const Name: string; Value: TArray<string>): TUrlParam;
begin
  Result := Add(Name, string.Join(',', Value).Replace(#32, #0));
end;

function TUrlParam.Add(const Name: string; Value: Int64): TUrlParam;
begin
  Result := Add(Name, Value.ToString);
end;

{ TParameters }

function TParameters.Add(const AKey: string;
  const AValue: Boolean): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, AValue);
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: Double): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, AValue);
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: Integer): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, AValue);
  Result := Self;
end;

function TParameters.Add(const AKey, AValue: string): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, AValue);
  Result := Self;
end;

constructor TParameters.Create;
begin
  inherited Create;
  FParams := TDictionary<string, TValue>.Create;
end;

destructor TParameters.Destroy;
begin
  FParams.Free;
  inherited;
end;

function TParameters.Exists(const AKey: string): Boolean;
begin
  Result := FParams.ContainsKey(AKey.ToLower)
end;

function TParameters.GetArrayBoolean(const AKey: string): TArray<Boolean>;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<TArray<Boolean>> then
    Result := LValue.AsType<TArray<Boolean>>
  else
    Result := [];
end;

function TParameters.GetArrayDouble(const AKey: string): TArray<Double>;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<TArray<Double>> then
    Result := LValue.AsType<TArray<Double>>
  else
    Result := [];
end;

function TParameters.GetArrayInt64(const AKey: string): TArray<Int64>;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<TArray<Int64>> then
    Result := LValue.AsType<TArray<Int64>>
  else
    Result := [];
end;

function TParameters.GetArrayInteger(const AKey: string): TArray<Integer>;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<TArray<Integer>> then
    Result := LValue.AsType<TArray<Integer>>
  else
    Result := [];
end;

function TParameters.GetArrayJSONObject(
  const AKey: string): TArray<TJSONObject>;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<TArray<TJSONObject>> then
    Result := LValue.AsType<TArray<TJSONObject>>
  else
    Result := nil;
end;

function TParameters.GetArrayObject(const AKey: string): TArray<TObject>;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<TArray<TObject>> then
    Result := LValue.AsType<TArray<TObject>>
  else
    Result := [];
end;

function TParameters.GetArraySingle(const AKey: string): TArray<Single>;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<TArray<Single>> then
    Result := LValue.AsType<TArray<Single>>
  else
    Result := [];
end;

function TParameters.GetArrayString(const AKey: string): TArray<string>;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<TArray<string>> then
    Result := LValue.AsType<TArray<string>>
  else
    Result := [];
end;

function TParameters.GetBoolean(const AKey: string;
  const ADefault: Boolean): Boolean;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<Boolean> then
    Result := LValue.AsBoolean
  else
    Result := ADefault;
end;

function TParameters.GetDouble(const AKey: string;
  const ADefault: Double): Double;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<Double> then
    Result := LValue.AsType<Double>
  else
    Result := ADefault;
end;

function TParameters.GetInt64(const AKey: string;
  const ADefault: Integer): Integer;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<Int64> then
    Result := LValue.AsInt64
  else
    Result := ADefault;
end;

function TParameters.GetInteger(const AKey: string;
  const ADefault: Integer): Integer;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<Integer> then
    Result := LValue.AsInteger
  else
    Result := ADefault;
end;

function TParameters.GetJSONArray(const AKey: string): TJSONArray;
begin
  Result := TJSONArray.Create;
  for var Item in GetArrayJSONObject(AKey) do
    Result.Add(Item);
end;

function TParameters.GetJSONObject(const AKey: string): TJSONObject;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<TJSONObject> then
    Result := LValue.AsType<TJSONObject>
  else
    Result := nil;
end;

function TParameters.GetObject(const AKey: string;
  const ADefault: TObject): TObject;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsObject then
    Result := LValue.AsObject
  else
    Result := ADefault;
end;

function TParameters.GetSingle(const AKey: string;
  const ADefault: Single): Double;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<Single> then
    Result := LValue.AsType<Single>
  else
    Result := ADefault;
end;

function TParameters.GetString(const AKey, ADefault: string): string;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<string> then
    Result := LValue.AsString
  else
    Result := ADefault;
end;

procedure TParameters.ProcessParam(const AKey: string;
  ACallback: TProc<TValue>);
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) then
    ACallback(LValue);
end;

function TParameters.Add(const AKey: string;
  const AValue: TArray<string>): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, TValue.From<TArray<string>>(AValue));
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: TArray<Integer>): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, TValue.From<TArray<Integer>>(AValue));
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: TArray<Double>): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, TValue.From<TArray<Double>>(AValue));
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: TArray<Boolean>): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, TValue.From<TArray<Boolean>>(AValue));
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: TObject): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, AValue);
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: TArray<Single>): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, TValue.From<TArray<Single>>(AValue));
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: Single): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, AValue);
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: TArray<Int64>): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, TValue.From<TArray<Int64>>(AValue));
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: Int64): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, AValue);
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: TArray<TObject>): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, TValue.From<TArray<TObject>>(AValue));
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: TJSONObject): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, AValue);
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: TArray<TJSONObject>): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, TValue.From<TArray<TJSONObject>>(AValue));
  Result := Self;
end;

end.

unit MistralAI.API;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

{$REGION 'Dev note'}
  (*
    --- NOTE ---
    The MistralAI.HttpClientInterface unit defines  an IHttpClientAPI  interface, which
    allows  for decoupling  the specific implementation  of  the HTTP  client used  for
    web requests. This introduces  an abstraction  that  enhances flexibility, improves
    testability, and simplifies code maintenance.

    The IHttpClientAPI interface  ensures that  client code can interact  with  the web
    without  being  dependent  on a specific class, thus  facilitating  the replacement
    or modification  of the  underlying  HTTP implementation  details without impacting
    the rest  of  the application. It also  enables  easy mocking  during unit testing,
    offering the ability to test  HTTP request behaviors in an isolated  and controlled
    manner.

    This approach adheres to the SOLID principles of dependency inversion, contributing
    to a robust, modular, and adaptable software architecture.
  *)
{$ENDREGION}

uses
  System.SysUtils, System.Classes, System.Net.HttpClient, System.Net.URLClient,
  System.Net.Mime, System.JSON, System.Generics.Collections,
  MistralAI.API.Params, MistralAI.Errors, MistralAI.Exception, MistralAI.Monitoring,
  MistralAI.HttpClientInterface, MistralAI.HttpClientAPI, MistralAI.API.Helper,
  MistralAI.API.Normalizer;

type
  /// <summary>
  /// Represents the configuration settings for the MistralAI API.
  /// </summary>
  /// <remarks>
  /// This class provides properties and methods to manage the API key, base URL,
  /// organization identifier, and custom headers for communicating with the MistralAI API.
  /// It also includes utility methods for building headers and endpoint URLs.
  /// </remarks>
  TMistralAISettings = class
  const
    URL_BASE = 'https://api.mistral.ai/v1';
    URL_BASE_CODESTRAL = 'https://codestral.mistral.ai/v1';
  private
    FAPIKey: string;
    FBaseUrl: string;
    FOrganization: string;
    FCustomHeaders: TNetHeaders;
    procedure SetAPIKey(const Value: string);
    procedure SetBaseUrl(const Value: string);
    procedure SetOrganization(const Value: string);
    procedure SetCustomHeaders(const Value: TNetHeaders);
    procedure VerifyApiSettings;
    procedure ResetCustomHeader;
  protected
    /// <summary>
    /// Retrieves the headers required for API requests.
    /// </summary>
    /// <returns>
    /// A list of headers including authorization and optional organization information.
    /// </returns>
    function BuildHeaders: TNetHeaders; virtual;

    /// <summary>
    /// Builds headers specific to JSON-based API requests.
    /// </summary>
    /// <returns>
    /// A list of headers including JSON content-type and authorization details.
    /// </returns>
    function BuildJsonHeaders: TNetHeaders; virtual;

    /// <summary>
    /// Constructs the full URL for a specific API endpoint.
    /// </summary>
    /// <param name="Endpoint">
    /// The relative endpoint path (e.g. "models").
    /// </param>
    /// <returns>
    /// The full URL including the base URL and endpoint.
    /// </returns>
    function BuildUrl(const Endpoint: string): string; overload; virtual;

    /// <summary>
    /// Constructs the full URL for a specific API endpoint.
    /// </summary>
    /// <param name="Endpoint">
    /// The relative endpoint path (e.g. "models").
    /// </param>
    /// <param name="Parameters">
    /// e.g. "?param1=val1&param2=val2...."
    /// </param>
    /// <returns>
    /// The full URL including the base URL and endpoint.
    /// </returns>
    function BuildUrl(const Endpoint, Parameters: string): string; overload; virtual;
  public
    constructor Create; overload;

    /// <summary>
    /// The API key used for authentication.
    /// </summary>
    property APIKey: string read FAPIKey write SetAPIKey;

    /// <summary>
    /// The base URL for API requests.
    /// </summary>
    property BaseUrl: string read FBaseUrl write SetBaseUrl;

    /// <summary>
    /// The organization identifier used for the API.
    /// </summary>
    property Organization: string read FOrganization write SetOrganization;

    /// <summary>
    /// Custom headers to include in API requests.
    /// </summary>
    property CustomHeaders: TNetHeaders read FCustomHeaders write SetCustomHeaders;
  end;

  /// <summary>
  /// Handles HTTP requests and responses for the MistralAI API.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TMistralAISettings</c> and provides a mechanism to
  /// manage HTTP client interactions for the API, including configuration and request execution.
  /// </remarks>
  TApiHttpClient = class(TMistralAISettings)
  private
    /// <summary>
    /// The HTTP client interface used for making API calls.
    /// </summary>
    FHTTPClient: IHttpClientAPI;
  public
    constructor Create;

    /// <summary>
    /// The HTTP client used to send requests to the API.
    /// </summary>
    /// <value>
    /// An instance of a class implementing <c>IHttpClientAPI</c>.
    /// </value>
    property HttpClient: IHttpClientAPI read FHTTPClient;
  end;

  /// <summary>
  /// Manages and processes errors from the MistralAI API responses.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TApiHttpClient</c> and provides error-handling capabilities
  /// by parsing error data and raising appropriate exceptions.
  /// </remarks>
  TApiDeserializer = class(TApiHttpClient)
  class var Metadata: ICustomFieldsPrepare;
  protected
    /// <summary>
    /// Parses the error data from the API response.
    /// </summary>
    /// <param name="Code">
    /// The HTTP status code returned by the API.
    /// </param>
    /// <param name="ResponseText">
    /// The response body containing error details.
    /// </param>
    /// <exception cref="MistralAIException">
    /// Raised if the error response cannot be parsed or contains invalid data.
    /// </exception>
    procedure DeserializeErrorData(const Code: Int64; const ResponseText: string); virtual;

    /// <summary>
    /// Raises an exception corresponding to the API error code.
    /// </summary>
    /// <param name="Code">
    /// The HTTP status code returned by the API.
    /// </param>
    /// <param name="Error">
    /// The deserialized error object containing error details.
    /// </param>
    procedure RaiseError(Code: Int64; Error: TErrorCore); virtual;

    /// <summary>
    /// Deserializes the API response into a strongly typed object.
    /// </summary>
    /// <param name="T">
    /// The type of the object to deserialize into. It must be a class with a parameterless constructor.
    /// </param>
    /// <param name="Code">
    /// The HTTP status code of the API response.
    /// </param>
    /// <param name="ResponseText">
    /// The response body as a JSON string.
    /// </param>
    /// <returns>
    /// A deserialized object of type <c>T</c>.
    /// </returns>
    /// <exception cref="MistralAIExceptionInvalidResponse">
    /// Raised if the response is non-compliant or deserialization fails.
    /// </exception>
    function Deserialize<T: class, constructor>(const Code: Int64; const ResponseText: string): T;
  public
    class constructor Create;

    /// <summary>
    /// Deserializes the API response into a strongly typed object.
    /// </summary>
    /// <param name="T">
    /// The type of the object to deserialize into. It must be a class with a parameterless constructor.
    /// </param>
    /// <param name="ResponseText">
    /// The response body as a JSON string.
    /// </param>
    /// <returns>
    /// A deserialized object of type <c>T</c>.
    /// </returns>
    /// <exception cref="MistralAIExceptionInvalidResponse">
    /// Raised if the response is non-compliant or deserialization fails.
    /// </exception>
    class function Parse<T: class, constructor>(const Value: string): T;
  end;

  /// <summary>
  /// Provides a high-level interface for interacting with the MistralAI API.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TApiDeserializer</c> and includes methods for making HTTP requests to
  /// the MistralAI API. It supports various HTTP methods, including GET, POST, PATCH, and DELETE,
  /// as well as handling file uploads and downloads. The API key and other configuration settings
  /// are inherited from the <c>TMistralAISettings</c> class.
  /// </remarks>
  TMistralAIAPI = class(TApiDeserializer)
  public
    function Get<TResult: class, constructor>(const Endpoint: string; const Path: TArray<string> = []): TResult; overload;
    function Get<TResult: class, constructor>(const Endpoint: string; const ListFieldName: string): TResult; overload;
    function Get<TResult: class, constructor; TParams: TUrlParam>(const Endpoint: string; ParamProc: TProc<TParams>; const ListFieldName: string = ''): TResult; overload;
    function GetEx<TResult: class, constructor>(const Endpoint: string): TResult; overload;
    function GetFile(const Endpoint: string; Response: TStream): Integer; overload;
    function GetFile<TResult: class, constructor>(const Endpoint: string; const JSONFieldName: string = 'data'): TResult; overload;
    function Delete<TResult: class, constructor>(const Endpoint: string): TResult; overload;
    function Delete<TResult: class, constructor; TParams: TJSONParam>(const Endpoint: string; ParamProc: TProc<TParams>): TResult; overload;
    function DeleteEx<TResult: class, constructor>(const Endpoint: string): TResult; overload;
    function Post(const Endpoint: string; Body: TJSONObject; Response: TStringStream; OnReceiveData: TReceiveDataCallback = nil): Integer; overload;
    function Post<TParams: TJSONParam>(const Endpoint: string; ParamProc: TProc<TParams>; Response: TStringStream; Event: TReceiveDataCallback): Boolean; overload;
    function Post<TResult: class, constructor; TParams: TJSONParam>(const Endpoint: string; ParamProc: TProc<TParams>; const Path: TArray<string> = []): TResult; overload;
    function Post<TResult: class, constructor>(const Endpoint: string): TResult; overload;
    function PostEx<TResult: class, constructor>(const Endpoint: string): TResult; overload;
    function Patch<TResult: class, constructor; TParams: TJSONParam>(const Endpoint: string; ParamProc: TProc<TParams>): TResult;
    function PatchFromUrl<TResult: class, constructor; TParams: TUrlParam>(const Endpoint: string; ParamProc: TProc<TParams>): TResult;
    function PostForm<TResult: class, constructor; TParams: TMultipartFormData, constructor>(const Endpoint: string; ParamProc: TProc<TParams>): TResult;
    function Put<TResult: class, constructor; TParams: TJSONParam>(const Endpoint: string; ParamProc: TProc<TParams>): TResult;

    /// <summary>
    /// Initializes a new instance of the <c>TMistralAIAPI</c> class with an API key.
    /// </summary>
    /// <param name="AAPIKey">
    /// The API key used for authenticating requests to the MistralAI API.
    /// </param>
    constructor Create(const AAPIKey: string); overload;
  end;

  /// <summary>
  /// Represents a specific route or logical grouping for the MistralAI API.
  /// </summary>
  /// <remarks>
  /// This class allows associating a <c>TMistralAIAPI</c> instance with specific routes or
  /// endpoints, providing an organized way to manage API functionality.
  /// </remarks>
  TMistralAIAPIRoute = class
  private
    /// <summary>
    /// The MistralAI API instance associated with this route.
    /// </summary>
    FAPI: TMistralAIAPI;
    procedure SetAPI(const Value: TMistralAIAPI);
  protected
    procedure HeaderCustomize; virtual;
  public
    /// <summary>
    /// The MistralAI API instance associated with this route.
    /// </summary>
    property API: TMistralAIAPI read FAPI write SetAPI;

    /// <summary>
    /// Initializes a new instance of the <c>TMistralAIRoute</c> class with the given API instance.
    /// </summary>
    /// <param name="AAPI">
    /// The <c>TMistralAIAPI</c> instance to associate with the route.
    /// </param>
    constructor CreateRoute(AAPI: TMistralAIAPI); reintroduce;
  end;

var
  MetadataAsObject: Boolean = False;

implementation

uses
  System.StrUtils, REST.Json, MistralAI.NetEncoding.Base64;

constructor TMistralAIAPI.Create(const AAPIKey: string);
begin
  Create;
  APIKey := AAPIKey;
end;

function TMistralAIAPI.Delete<TResult, TParams>(const Endpoint: string;
  ParamProc: TProc<TParams>): TResult;
begin
  Monitoring.Inc;
  var Response := TStringStream.Create('', TEncoding.UTF8);
  var Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    var Code := HTTPClient.Delete(BuildUrl(Endpoint), Params.JSON, Response, BuildJsonHeaders);
    Result := Deserialize<TResult>(Code, Response.DataString);
  finally
    Params.Free;
    Response.Free;
    Monitoring.Dec;
  end;
end;

function TMistralAIAPI.Delete<TResult>(const Endpoint: string): TResult;
begin
  Monitoring.Inc;
  var Response := TStringStream.Create('', TEncoding.UTF8);
  try
    var Code := HTTPClient.Delete(BuildUrl(Endpoint), Response, BuildHeaders);
    Result := Deserialize<TResult>(Code, Response.DataString);
  finally
    Response.Free;
    Monitoring.Dec;
  end;
end;

function TMistralAIAPI.DeleteEx<TResult>(const Endpoint: string): TResult;
begin
  Monitoring.Inc;
  var Response := TStringStream.Create('', TEncoding.UTF8);
  try
    var Code := HTTPClient.Delete(BuildUrl(Endpoint), Response, BuildHeaders);
    var S := Response.DataString;
    if S.IsEmpty then
      S := '{"processed":true}';
    Result := Deserialize<TResult>(Code, S);
  finally
    Response.Free;
    Monitoring.Dec;
  end;
end;

function TMistralAIAPI.Get<TResult, TParams>(const Endpoint: string;
  ParamProc: TProc<TParams>; const ListFieldName: string): TResult;
begin
  Monitoring.Inc;
  Result := nil;
  var Response := TStringStream.Create('', TEncoding.UTF8);
  var Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    var Code := HTTPClient.Get(BuildUrl(Endpoint, Params.Value), Response, BuildHeaders);
    case Code of
      200..299:
        if ListFieldName.IsEmpty then
          Result := Deserialize<TResult>(Code, Response.DataString)
        else
          Result := Deserialize<TResult>(Code, format('{"%s":%s}', [ListFieldName, Response.DataString]));
      else
        RaiseError(Code, nil);
    end;
  finally
    Response.Free;
    Params.Free;
    ResetCustomHeader;
    Monitoring.Dec;
  end;
end;

function TMistralAIAPI.Get<TResult>(const Endpoint,
  ListFieldName: string): TResult;
begin
  Monitoring.Inc;
  var Response := TStringStream.Create('', TEncoding.UTF8);
  try
    var Code := HTTPClient.Get(BuildUrl(Endpoint), Response, BuildHeaders);
    if ListFieldName.IsEmpty then
      Result := Deserialize<TResult>(Code, Response.DataString)
    else
      Result := Deserialize<TResult>(Code, format('{"%s":%s}', [ListFieldName, Response.DataString]));
  finally
    Response.Free;
    ResetCustomHeader;
    Monitoring.Dec;
  end;
end;

function TMistralAIAPI.Get<TResult>(const Endpoint: string;
  const Path: TArray<string>): TResult;
begin
  Monitoring.Inc;
  var Response := TStringStream.Create('', TEncoding.UTF8);
  try
    var Code := HTTPClient.Get(BuildUrl(Endpoint), Response, BuildHeaders);
    if Length(Path) = 0 then
      Result := Deserialize<TResult>(Code, Response.DataString)
    else
      Result := Deserialize<TResult>(Code, TJSONNormalizer.Normalize(Response.DataString, Path));
  finally
    Response.Free;
    ResetCustomHeader;
    Monitoring.Dec;
  end;
end;

function TMistralAIAPI.GetEx<TResult>(const Endpoint: string): TResult;
begin
  Monitoring.Inc;
  Result := nil;
  var Response := TStringStream.Create('', TEncoding.UTF8);
  try
    var Code := HTTPClient.Get(BuildUrl(Endpoint), Response, BuildHeaders);
    case Code of
      200..299:
        try
          begin
            Result := TJson.JsonToObject<TResult>(Response.DataString);
            if Assigned(Result) and TResult.InheritsFrom(TJSONFingerprint) then
              begin
                var JSONValue := TJSONObject.ParseJSONValue(Response.DataString);
                try
                  (Result as TJSONFingerprint).JSONResponse := JSONValue.Format();
                finally
                  JSONValue.Free;
                end;
              end;
          end;
        except
          Result := nil;
        end;
      else
        DeserializeErrorData(Code, Response.DataString);
    end;
  finally
    Response.Free;
    ResetCustomHeader;
    Monitoring.Dec;
  end;
end;

function TMistralAIAPI.GetFile<TResult>(const Endpoint: string; const JSONFieldName: string):TResult;
begin
  var Stream := TStringStream.Create;
  try
    var Code := GetFile(Endpoint, Stream);
    Stream.Position := 0;
    var Temp := TStringStream.Create(BytesToString(Stream.Bytes).TrimRight([#0]));
    try
      Result := Deserialize<TResult>(Code, Format('{"%s":"%s"}', [JSONFieldName, EncodeBase64(Temp)]));
    finally
      Temp.Free;
    end;
  finally
    Stream.Free;
  end;
end;

function TMistralAIAPI.GetFile(const Endpoint: string; Response: TStream): Integer;
begin
  Monitoring.Inc;
  try
    Result := FHTTPClient.Get(BuildUrl(Endpoint), Response, BuildHeaders);
    case Result of
      200..299:
        {success};
      else
        begin
          var Recieved := TStringStream.Create;
          try
            Response.Position := 0;
            Recieved.LoadFromStream(Response);
            DeserializeErrorData(Result, Recieved.DataString);
          finally
            Recieved.Free;
          end;
        end;
    end;
  finally
    Monitoring.Dec;
  end;
end;

function TMistralAIAPI.Patch<TResult, TParams>(const Endpoint: string;
  ParamProc: TProc<TParams>): TResult;
begin
  Monitoring.Inc;
  var Response := TStringStream.Create('', TEncoding.UTF8);
  var Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    var Code := HTTPClient.Patch(BuildUrl(Endpoint), Params.JSON, Response, BuildJsonHeaders);
    Result := Deserialize<TResult>(Code, Response.DataString);
  finally
    Params.Free;
    Response.Free;
    Monitoring.Dec;
  end;
end;

function TMistralAIAPI.PatchFromUrl<TResult, TParams>(
  const Endpoint: string; ParamProc: TProc<TParams>): TResult;
begin
  Monitoring.Inc;
  var Response := TStringStream.Create('', TEncoding.UTF8);
  var Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    var Code := HTTPClient.Patch(BuildUrl(Endpoint, Params.Value), nil, Response, BuildJsonHeaders);
    Result := Deserialize<TResult>(Code, Response.DataString);
  finally
    Params.Free;
    Response.Free;
    Monitoring.Dec;
  end;
end;

function TMistralAIAPI.Post(const Endpoint: string; Body: TJSONObject; Response: TStringStream; OnReceiveData: TReceiveDataCallback): Integer;
begin
  Monitoring.Inc;
  try
    Result := HTTPClient.Post(BuildUrl(Endpoint), Body, Response, BuildJsonHeaders, OnReceiveData);
  finally
    Monitoring.Dec;
  end;
end;

function TMistralAIAPI.Post<TResult, TParams>(const Endpoint: string;
  ParamProc: TProc<TParams>;
  const Path: TArray<string>): TResult;
begin
  var Response := TStringStream.Create('', TEncoding.UTF8);
  var Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    var Code := Post(Endpoint, Params.JSON, Response);
    if Length(Path) = 0 then
      Result := Deserialize<TResult>(Code, Response.DataString)
    else
      Result := Deserialize<TResult>(Code, TJSONNormalizer.Normalize(Response.DataString, Path));
  finally
    Params.Free;
    Response.Free;
  end;
end;

function TMistralAIAPI.Post<TParams>(const Endpoint: string; ParamProc: TProc<TParams>; Response: TStringStream; Event: TReceiveDataCallback): Boolean;
begin
  var Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    var Code := Post(Endpoint, Params.JSON, Response, Event);
    case Code of
      200..299:
        Result := True;
    else
      begin
        Result := False;
        var Recieved := TStringStream.Create;
        try
          Response.Position := 0;
          Recieved.LoadFromStream(Response);
          DeserializeErrorData(Code, Recieved.DataString);
        finally
          Recieved.Free;
        end;
      end;
    end;
  finally
    Params.Free;
  end;
end;

function TMistralAIAPI.Post<TResult>(const Endpoint: string): TResult;
begin
  Monitoring.Inc;
  var Response := TStringStream.Create('', TEncoding.UTF8);
  try
    var Code := HTTPClient.Post(BuildUrl(Endpoint), Response, BuildHeaders);
    Result := Deserialize<TResult>(Code, Response.DataString);
  finally
    Response.Free;
    Monitoring.Dec;
  end;
end;

function TMistralAIAPI.PostEx<TResult>(const Endpoint: string): TResult;
begin
  Monitoring.Inc;
  Result := nil;
  var Response := TStringStream.Create('', TEncoding.UTF8);
  try
    var Code := HTTPClient.Post(BuildUrl(Endpoint), Response, BuildHeaders);
    case Code of
      200..299:
        try
          begin
            var S := Response.DataString;
            if S.IsEmpty then
              S := '{"processed":true}';
            Result := Deserialize<TResult>(Code, S);
          end;
        except
          Result := nil;
        end;
      else
        DeserializeErrorData(Code, Response.DataString);
    end;
  finally
    Response.Free;
    Monitoring.Dec;
  end;
end;

function TMistralAIAPI.PostForm<TResult, TParams>(const Endpoint: string;
  ParamProc: TProc<TParams>): TResult;
begin
  Monitoring.Inc;
  var Response := TStringStream.Create('', TEncoding.UTF8);
  var Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    var Code := HTTPClient.Post(BuildUrl(Endpoint), Params, Response, BuildHeaders);
    Result := Deserialize<TResult>(Code, Response.DataString);
  finally
    Params.Free;
    Response.Free;
    Monitoring.Dec;
  end;
end;

function TMistralAIAPI.Put<TResult, TParams>(const Endpoint: string;
  ParamProc: TProc<TParams>): TResult;
begin
  Monitoring.Inc;
  var Response := TStringStream.Create('', TEncoding.UTF8);
  var Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    var Code := HttpClient.Put(BuildUrl(Endpoint), Params.JSON, Response, BuildJsonHeaders);
    Result := Deserialize<TResult>(Code, Response.DataString)
  finally
    Params.Free;
    Response.Free;
    Monitoring.Dec;
  end;
end;

{ TMistralAIAPIRoute }

constructor TMistralAIAPIRoute.CreateRoute(AAPI: TMistralAIAPI);
begin
  inherited Create;
  FAPI := AAPI;
end;

procedure TMistralAIAPIRoute.HeaderCustomize;
begin

end;

procedure TMistralAIAPIRoute.SetAPI(const Value: TMistralAIAPI);
begin
  FAPI := Value;
end;

{ TMistralAISettings }

function TMistralAISettings.BuildHeaders: TNetHeaders;
begin
  Result := [TNetHeader.Create('Authorization', 'Bearer ' + FAPIKey)] + FCustomHeaders;
end;

function TMistralAISettings.BuildUrl(const Endpoint: string): string;
begin
  Result := FBaseUrl.TrimRight(['/']) + '/' + Endpoint.TrimLeft(['/']);
end;

function TMistralAISettings.BuildJsonHeaders: TNetHeaders;
begin
  Result := BuildHeaders +
    [TNetHeader.Create('Content-Type', 'application/json')] +
    [TNetHeader.Create('Accept', 'application/json')];
end;

function TMistralAISettings.BuildUrl(const Endpoint,
  Parameters: string): string;
begin
  Result := BuildUrl(EndPoint) + Parameters;
end;

constructor TMistralAISettings.Create;
begin
  inherited;
  FAPIKey := EmptyStr;
  FBaseUrl := URL_BASE;
end;

procedure TMistralAISettings.ResetCustomHeader;
begin
  CustomHeaders := [];
end;

procedure TMistralAISettings.SetAPIKey(const Value: string);
begin
  FAPIKey := Value;
end;

procedure TMistralAISettings.SetBaseUrl(const Value: string);
begin
  FBaseUrl := Value;
end;

procedure TMistralAISettings.SetCustomHeaders(const Value: TNetHeaders);
begin
  FCustomHeaders := Value;
end;

procedure TMistralAISettings.SetOrganization(const Value: string);
begin
  FOrganization := Value;
end;

procedure TMistralAISettings.VerifyApiSettings;
begin
  if FAPIKey.IsEmpty then
    raise MistralAIExceptionAPI.Create('Token is empty!');
  if FBaseUrl.IsEmpty then
    raise MistralAIExceptionAPI.Create('Base url is empty!');
end;

{ TApiHttpClient }

constructor TApiHttpClient.Create;
begin
  inherited Create;
  FHttpClient := THttpClientAPI.CreateInstance(VerifyApiSettings);
end;

{ TApiDeserializer }

class constructor TApiDeserializer.Create;
begin
  Metadata := TDeserializationPrepare.CreateInstance;
end;

function TApiDeserializer.Deserialize<T>(const Code: Int64;
  const ResponseText: string): T;
begin
  Result := nil;
  case Code of
    200..299:
      try
        Result := Parse<T>(ResponseText);
      except
        Result := nil;
      end;
    else
      DeserializeErrorData(Code, ResponseText);
  end;
  if not Assigned(Result) then
    raise EInvalidResponse.Create(Code, 'Non-compliant response');
end;

procedure TApiDeserializer.DeserializeErrorData(const Code: Int64;
  const ResponseText: string);
var
  Error: TErrorCore;
begin
  Error := nil;
  try
    try
      case Code of
        422 : Error := TJson.JsonToObject<TError422>(ResponseText);
        else
          Error := TJson.JsonToObject<TError>(ResponseText);
      end;
    except
      Error := nil;
    end;
    if Assigned(Error) then
      RaiseError(Code, Error);
  finally
    if Assigned(Error) then
      Error.Free;
  end;
end;

class function TApiDeserializer.Parse<T>(const Value: string): T;
begin
  {$REGION 'Dev note'}
     (*
      - If Metadata are to be treated  as objects, a dedicated  TMetadata class is required, containing
      all the properties corresponding to the specified JSON fields.

      - However, if Metadata are  not treated  as objects, they will be temporarily handled as a string
      and subsequently converted back into a valid JSON string during the deserialization process using
      the revert method of the interceptor.

      By default, Metadata are  treated as strings rather  than objects to handle  cases where multiple
      classes to be deserialized may contain variable data structures.
      Refer to the global variable MetadataAsObject.
     *)
  {$ENDREGION}
  case MetadataAsObject of
    True:
      Result := TJson.JsonToObject<T>(Value);
    else
      Result := TJson.JsonToObject<T>(Metadata.Convert(Value));
  end;

  {--- Add JSON response if class inherits from TJSONFingerprint class. }
  if Assigned(Result) and T.InheritsFrom(TJSONFingerprint) then
    begin
      var JSONValue := TJSONObject.ParseJSONValue(Value);
      try
        (Result as TJSONFingerprint).JSONResponse := JSONValue.Format();
      finally
        JSONValue.Free;
      end;
    end;
end;

procedure TApiDeserializer.RaiseError(Code: Int64; Error: TErrorCore);
begin
  case Code of
    429:
      raise ERateLimitError.Create(Code, Error);
    400, 404, 415:
      raise EInvalidRequestError.Create(Code, Error);
    401:
      raise EAuthenticationError.Create(Code, Error);
    403:
      raise EPermissionError.Create(Code, Error);
    409:
      raise ETryAgain.Create(Code, Error);
    422:
      raise EUnprocessableEntityError.Create(Code, Error);
    500:
      raise EEngineException.Create(Code, Error);
  else
    raise MistralAIException.Create(Code, Error);
  end;
end;

end.

unit MistralAI.Async.Parallel;

interface

uses
  System.SysUtils, System.Classes, System.Generics.Collections, System.SyncObjs, System.Threading,
  MistralAI.Types, MistralAI.Async.Params, MistralAI.Async.Support, MistralAI.API.Params,
  MistralAI.Async.Promise;

type
  /// <summary>
  /// Represents an item in a bundle of chat prompts and responses.
  /// </summary>
  /// <remarks>
  /// This class stores information about a single chat request, including its index,
  /// associated prompt, generated response, and related chat object.
  /// It is used within a <c>TBundleList</c> to manage multiple asynchronous chat requests.
  /// </remarks>
  TBundleItem = class
  private
    FIndex: Integer;
    FFinishIndex: Integer;
    FPrompt: string;
    FResponse: string;
    FChat: TObject;
  public
    /// <summary>
    /// Gets or sets the index of the item in the bundle.
    /// </summary>
    property Index: Integer read FIndex write FIndex;
    /// <summary>
    /// Gets or sets the finishing index of the item after processing.
    /// </summary>
    property FinishIndex: Integer read FFinishIndex write FFinishIndex;
    /// <summary>
    /// Gets or sets the prompt associated with this bundle item.
    /// </summary>
    property Prompt: string read FPrompt write FPrompt;
    /// <summary>
    /// Gets or sets the response generated for the given prompt.
    /// </summary>
    property Response: string read FResponse write FResponse;
    /// <summary>
    /// Gets or sets the chat object associated with this item.
    /// </summary>
    /// <remarks>
    /// This object contains additional information about the chat session,
    /// including metadata related to the AI-generated response.
    /// </remarks>
    property Chat: TObject read FChat write FChat;
    /// <summary>
    /// Destroys the <c>TBundleItem</c> instance and releases associated resources.
    /// </summary>
    /// <remarks>
    /// If a chat object (<c>FChat</c>) is assigned, it is freed upon destruction.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages a collection of <c>TBundleItem</c> objects.
  /// </summary>
  /// <remarks>
  /// This class provides methods to add, retrieve, and count items in a bundle.
  /// It is designed to store multiple chat request items processed in parallel.
  /// The internal storage uses a <c>TObjectList&lt;TBundleItem&gt;</c> with automatic memory management.
  /// </remarks>
  TBundleList = class
  private
    FItems: TObjectList<TBundleItem>;
  public
    /// <summary>
    /// Initializes a new instance of <c>TBundleList</c>.
    /// </summary>
    /// <remarks>
    /// This constructor creates an internal list of <c>TBundleItem</c> objects,
    /// ensuring that items are automatically freed when the list is destroyed.
    /// </remarks>
    constructor Create;
    /// <summary>
    /// Destroys the <c>TBundleList</c> instance and releases all associated resources.
    /// </summary>
    /// <remarks>
    /// This destructor frees all <c>TBundleItem</c> objects stored in the list.
    /// </remarks>
    destructor Destroy; override;
    /// <summary>
    /// Adds a new item to the bundle.
    /// </summary>
    /// <param name="AIndex">
    /// The index of the new item in the bundle.
    /// </param>
    /// <returns>
    /// The newly created <c>TBundleItem</c> instance.
    /// </returns>
    /// <remarks>
    /// This method creates a new <c>TBundleItem</c>, assigns it the specified index,
    /// and adds it to the internal list.
    /// </remarks>
    function Add(const AIndex: Integer): TBundleItem;
    /// <summary>
    /// Retrieves an item from the bundle by its index.
    /// </summary>
    /// <param name="AIndex">
    /// The zero-based index of the item to retrieve.
    /// </param>
    /// <returns>
    /// The <c>TBundleItem</c> instance at the specified index.
    /// </returns>
    /// <exception cref="Exception">
    /// Raised if the specified index is out of bounds.
    /// </exception>
    function Item(const AIndex: Integer): TBundleItem;
    /// <summary>
    /// Gets the total number of items in the bundle.
    /// </summary>
    /// <returns>
    /// The number of items stored in the bundle.
    /// </returns>
    function Count: Integer;
    /// <summary>
    /// Provides direct access to the internal list of <c>TBundleItem</c> objects.
    /// </summary>
    property Items: TObjectList<TBundleItem> read FItems write FItems;
  end;

  /// <summary>
  /// Represents an asynchronous callback buffer for handling chat responses.
  /// </summary>
  /// <remarks>
  /// This class is a specialized type used to manage asynchronous operations
  /// related to chat request processing. It inherits from <c>TAsynCallBack&lt;TBundleList&gt;</c>,
  /// enabling structured handling of callback events.
  /// </remarks>
  TAsynBundleList = TAsyncCallBack<TBundleList>;

  /// <summary>
  /// Represents a promise-based callback for handling a bundle of chat responses.
  /// </summary>
  /// <remarks>
  /// The <c>TPromiseBundleList</c> alias extends <see cref="TPromiseCallBack&lt;TBundleList&gt;"/>
  /// to provide a promise-style API for parallel chat prompt execution, resolving with a
  /// <see cref="TBundleList"/> when all responses are complete or rejecting on error.
  /// </remarks>
  TPromiseBundleList = TPromiseCallBack<TBundleList>;

  /// <summary>
  /// Provides helper methods for managing asynchronous tasks.
  /// </summary>
  /// <remarks>
  /// This class contains utility methods for handling task execution flow,
  /// including a method to execute a follow-up action once a task completes.
  /// <para>
  /// - In order to replace TTask.WaitForAll due to a memory leak in TLightweightEvent/TCompleteEventsWrapper.
  /// See report RSP-12462 and RSP-25999.
  /// </para>
  /// </remarks>
  TTaskHelper = class
  public
    /// <summary>
    /// Executes a specified action after a given task is completed.
    /// </summary>
    /// <param name="Task">
    /// The task to wait for before executing the next action.
    /// </param>
    /// <param name="NextAction">
    /// The procedure to execute once the task is completed.
    /// </param>
    /// <param name="TimeOut">
    /// The maximum time (in milliseconds) to wait for the task to complete.
    /// The default value is 120,000 ms (2 minutes).
    /// </param>
    /// <remarks>
    /// This method waits for the specified task to finish within the provided timeout period.
    /// Once completed, the follow-up action is executed in the main thread using <c>TThread.Queue</c>,
    /// ensuring thread safety.
    /// <para>
    /// - In order to replace TTask.WaitForAll due to a memory leak in TLightweightEvent/TCompleteEventsWrapper.
    /// See report RSP-12462 and RSP-25999.
    /// </para>
    /// </remarks>
    class procedure ContinueWith(const Task: ITask; const NextAction: TProc; const TimeOut: Cardinal = 120000);
  end;

  /// <summary>
  /// Represents the parameters used for configuring a chat request bundle.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TParameters</c> and provides specific methods for setting chat-related
  /// parameters, such as prompts, model selection, and reasoning effort.
  /// It is used to structure and pass multiple requests efficiently in parallel processing.
  /// </remarks>
  TBundleParams = class(TParameters)
  const
    S_PROMPT = 'prompts';
    S_SYSTEM = 'system';
    S_MODEL = 'model';
  public
    /// <summary>
    /// Sets the prompts for the chat request bundle.
    /// </summary>
    /// <param name="Value">
    /// An array of strings containing the prompts to be processed.
    /// </param>
    /// <returns>
    /// The current instance of <c>TBundleParams</c> for method chaining.
    /// </returns>
    function Prompts(const Value: TArray<string>): TBundleParams;
    /// <summary>
    /// Sets the AI model to be used for processing the chat requests.
    /// </summary>
    /// <param name="Value">
    /// A string representing the model name.
    /// </param>
    /// <returns>
    /// The current instance of <c>TBundleParams</c> for method chaining.
    /// </returns>
    function Model(const Value: string): TBundleParams;
    /// <summary>
    /// Sets the system message for the chat request bundle.
    /// </summary>
    /// <param name="Value">
    /// A string containing the system message, which provides context or behavioral instructions
    /// to guide the AI model's responses across all prompts in the bundle.
    /// </param>
    /// <returns>
    /// The current instance of <c>TBundleParams</c> to allow method chaining.
    /// </returns>
    /// <remarks>
    /// The system message is typically used to influence the tone, format, or perspective
    /// of the AI responses, acting as a global directive for the conversation context.
    /// </remarks>
    function System(const Value: string): TBundleParams;
    /// <summary>
    /// Returns prompt array
    /// </summary>
    function GetPrompt: TArray<string>;
    /// <summary>
    /// Returns system or developer instructions
    /// </summary>
    function GetSystem: string;
    /// <summary>
    /// Returns the model name
    /// </summary>
    function GetModel: string;
  end;

implementation

{ TBundleList }

function TBundleList.Add(const AIndex: Integer): TBundleItem;
begin
  Result := TBundleItem.Create;
  Result.Index := AIndex;
  FItems.Add(Result);
end;

function TBundleList.Count: Integer;
begin
  Result := FItems.Count;
end;

constructor TBundleList.Create;
begin
  inherited Create;
  FItems := TObjectList<TBundleItem>.Create(True);
end;

destructor TBundleList.Destroy;
begin
  FItems.Free;
  inherited;
end;

function TBundleList.Item(const AIndex: Integer): TBundleItem;
begin
  if (AIndex < 0) or (AIndex > Pred(Count)) then
    raise Exception.Create('Index out of bounds');
  Result := FItems.Items[AIndex];
end;

{ TTaskHelper }

class procedure TTaskHelper.ContinueWith(const Task: ITask;
  const NextAction: TProc; const TimeOut: Cardinal);
begin
  TTask.Run(
    procedure
    begin
      {--- Wait for the task to complete within TimeOut ms }
      Task.Wait(TimeOut);

      {--- Execute the sequence in the main thread }
      TThread.Queue(nil,
        procedure
        begin
          NextAction();
        end);
    end);
end;

{ TBundleParams }

function TBundleParams.GetModel: string;
begin
  Result := GetString(S_MODEL);
end;

function TBundleParams.GetPrompt: TArray<string>;
begin
  Result := GetArrayString(S_PROMPT);
end;

function TBundleParams.GetSystem: string;
begin
  Result := GetString(S_SYSTEM);
end;

function TBundleParams.Model(const Value: string): TBundleParams;
begin
  Result := TBundleParams(Add(S_MODEL, Value));
end;

function TBundleParams.Prompts(const Value: TArray<string>): TBundleParams;
begin
  Result := TBundleParams(Add(S_PROMPT, Value));
end;

function TBundleParams.System(const Value: string): TBundleParams;
begin
  Result := TBundleParams(Add(S_SYSTEM, Value));
end;

{ TBundleItem }

destructor TBundleItem.Destroy;
begin
  if Assigned(FChat) then
    FChat.Free;
  inherited;
end;

end.

unit MistralAI.Async.Params;

{-------------------------------------------------------------------------------

      Unit containing generic interfaces and classes for managing parameters
      across  various  asynchronous  operations.

      The MistralAI.Async.Params  unit provides  a set of tools for creating
      and managing  parameter  instances  using  generic  types. The primary
      components include:

      - IUseParams<T>: A generic interface for managing parameters of type T.
      - TUseParams<T>: A class  implementing  the IUseParams<T>  interface to
        encapsulate  parameter  handling.
      - TUseParamsFactory<T>: A  factory  class  for  creating  instances  of
        IUseParams<T>.

      These abstractions allow for  a flexible and  reusable  way  to  handle
      parameters  across  different  modules  and  contexts,  particularly in
      asynchronous  scenarios  such  as  chat operations.

      Note  that  This  unit  is  designed   to  work   seamlessly  with  the
      MistralAI.Chat.AsyncEvents  unit,  which  relies  on  IUseParams<T> and
      TUseParamsFactory<T>  to  manage   parameters   for  asynchronous  chat
      requests.

        Github  repository : https://github.com/MaxiDonkey/DelphiMistralAI
        Visit the Github repository for the documentation and use examples

-------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes;

type
  /// <summary>
  /// Generic interface for managing parameters of type <c>T</c>.
  /// </summary>
  /// <typeparam name="T">
  /// The type of the parameters.
  /// </typeparam>
  IUseParams<T> = interface
    ['{18566F2C-F2D9-4257-A460-D9AE8F053357}']
    /// <summary>
    /// Sets the parameters.
    /// </summary>
    /// <param name="Value">
    /// The value of the parameters to be set.
    /// </param>
    procedure SetParams(const Value: T);

    /// <summary>
    /// Gets the current parameters.
    /// </summary>
    /// <returns>
    /// The current parameters of type <c>T</c>.
    /// </returns>
    function GetParams: T;

    /// <summary>
    /// Assigns the parameters using a function.
    /// </summary>
    /// <param name="Value">
    /// A function that returns parameters of type <c>T</c>.
    /// </param>
    procedure Assign(Value: TFunc<T>);

    /// <summary>
    /// Returns the current instance as an object of type <c>TObject</c>.
    /// </summary>
    /// <returns>
    /// The instance cast to <c>TObject</c>.
    /// </returns>
    function AsSender: TObject;

    /// <summary>
    /// Provides access to the parameters as a property.
    /// </summary>
    property Param: T read GetParams write SetParams;
  end;

  /// <summary>
  /// A factory class for creating instances of <c>IUseParams</c>.
  /// </summary>
  /// <param name="T">
  /// The type of the parameters for which the instance is created.
  /// </param>
  TUseParamsFactory<T> = class
    /// <summary>
    /// Creates and returns a new instance of <c>IUseParams</c> for the specified type <c>T</c>.
    /// </summary>
    /// <returns>
    /// A new instance of <c>IUseParams&lt;T&gt;</c>.
    /// </returns>
    class function CreateInstance: IUseParams<T>; overload;

    /// <summary>
    /// Creates and returns a new instance of <c>IUseParams</c> for the specified type <c>T</c>, using the provided function.
    /// </summary>
    /// <param name="Value">
    /// A function that provides the parameter values for the instance.
    /// </param>
    /// <returns>
    /// A new instance of <c>IUseParams&lt;T&gt;</c>.
    /// </returns>
    class function CreateInstance(Value: TFunc<T>): IUseParams<T>; overload;
  end;

  /// <summary>
  /// A generic class implementing the <c>IUseParams</c> interface to manage parameters of type <c>T</c>.
  /// </summary>
  /// <param name="T">
  /// The type of the parameters.
  /// </param>
  TUseParams<T> = class(TInterfacedObject, IUseParams<T>)
  private
    FParams: T;
    /// <summary>
    /// Sets the parameters to the provided value.
    /// </summary>
    /// <param name="Value">
    /// The new parameters value.
    /// </param>
    procedure SetParams(const Value: T);

    /// <summary>
    /// Retrieves the current parameters value.
    /// </summary>
    /// <returns>
    /// The current parameters.
    /// </returns>
    function GetParams: T;
  protected
    /// <summary>
    /// Casts the instance as a <c>TObject</c> for use as the sender of events.
    /// </summary>
    /// <returns>
    /// The current instance cast to <c>TObject</c>.
    /// </returns>
    function AsSender: TObject;

    /// <summary>
    /// Assigns the parameters using a function that returns type <c>T</c>.
    /// </summary>
    /// <param name="Value">
    /// A function that sets the parameters.
    /// </param>
    procedure Assign(Value: TFunc<T>);
  public
    /// <summary>
    /// Property to get or set the parameters.
    /// </summary>
    property Params: T read GetParams write SetParams;
  end;

implementation

{ TUseParams<T> }

function TUseParams<T>.AsSender: TObject;
begin
  Result := Self;
end;

procedure TUseParams<T>.Assign(Value: TFunc<T>);
begin
  if Assigned(Value) then
    begin
      Params := Value();
    end;
end;

function TUseParams<T>.GetParams: T;
begin
  Result := FParams;
end;

procedure TUseParams<T>.SetParams(const Value: T);
begin
  FParams := Value;
end;

{ TUseParamsFactory<T> }

class function TUseParamsFactory<T>.CreateInstance: IUseParams<T>;
begin
  Result := TUseParams<T>.Create;
end;

class function TUseParamsFactory<T>.CreateInstance(
  Value: TFunc<T>): IUseParams<T>;
begin
  Result := CreateInstance;
  Result.Assign(Value);
end;

end.

unit MistralAI.Async.Promise;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

{$REGION  'Dev notes : GenAI.Async.Promise'}

(*
      Unit providing a generic implementation of Promises for handling
      asynchronous operations in Delphi.

      The ASync.Promise unit enables structured handling of asynchronous
      tasks using Promises, allowing for a clean and readable
      asynchronous programming model similar to JavaScript Promises.

      Primary components include:

        - TPromise<T>: A generic class representing a promise that can be
          resolved or rejected asynchronously.
        - TPromiseState: An enumeration indicating the state of a promise
          (Pending, Fulfilled, or Rejected).
        - TPromiseRegistry: An internal registry that tracks all pending
          promises to prevent premature destruction.
        - Chained methods for structured handling:
          - &Then<T>: Chains operations to execute after a promise resolves.
          - &Catch: Handles errors occurring within a promise chain.

      These abstractions allow a structured and reusable way to manage
      asynchronous execution without deeply nested callbacks, facilitating
      a cleaner approach to asynchronous programming in Delphi.

  Example Usage:

  ```delphi
  procedure ExampleAsyncProcess;
  begin
    var Promise := TPromise<string>.Create(
      procedure(Resolve: TProc<string>; Reject: TProc<Exception>)
      begin
        TTask.Run(
        procedure()
        begin
          TThread.Queue(nil,
            procedure
            begin
              Sleep(2000); // Simulating asynchronous work
              if Random(2) = 0 then
                Resolve('Operation Successful')
              else
                Reject(Exception.Create('Operation Failed'));
            end)
        end)
      end);

    Promise
      .&Then(
        procedure(Value: string)
        begin
          ShowMessage('Success: ' + Value);
        end)
      .&Catch(
        procedure(E: Exception)
        begin
          ShowMessage('Error: ' + E.Message);
        end);
  end;
  ```

      The unit is designed to work seamlessly with other asynchronous
      programming modules, making it a powerful addition to any Delphi
      application requiring structured async execution.
*)

{$ENDREGION}

uses
  System.SysUtils, System.Generics.Collections, System.Classes, System.Threading;

type
  /// <summary>
  /// Represents the state of a Promise.
  /// </summary>
  TPromiseState = (
    /// <summary>
    /// The promise is pending and has not yet been resolved or rejected.
    /// </summary>
    psPending,

    /// <summary>
    /// The promise has been fulfilled with a value.
    /// </summary>
    psFulfilled,

    /// <summary>
    /// The promise has been rejected due to an error.
    /// </summary>
    psRejected
  );

  /// <summary>
  /// Abstract base class for promise implementations.
  /// </summary>
  /// <remarks>
  /// Provides a common interface for retrieving the current state
  /// of a promise. All concrete promise types must implement
  /// <see cref="GetState"/> to indicate whether they are pending,
  /// fulfilled, or rejected.
  /// </remarks>
  TPromiseBase = class abstract
  strict protected
    /// <summary>
    /// Returns the current state of the promise.
    /// </summary>
    /// <returns>
    /// A <see cref="TPromiseState"/> value indicating whether the
    /// promise is pending, fulfilled, or rejected.
    /// </returns>
    function GetState: TPromiseState; virtual; abstract;
  public
    /// <summary>
    /// Read-only property exposing the promise’s current state.
    /// </summary>
    /// <value>
    /// The <see cref="TPromiseState"/> of the promise.
    /// </value>
    property State: TPromiseState read GetState;
  end;

  /// <summary>
  /// A generic class that represents an asynchronous operation that may complete in the future.
  /// </summary>
  /// <typeparam name="T">The type of the value that the promise resolves with.</typeparam>
  TPromise<T> = class(TPromiseBase)
  public
    type
      /// <summary>
      /// Defines the executor procedure for a promise, providing callbacks
      /// to signal fulfillment or rejection of the asynchronous operation.
      /// </summary>
      /// <param name="Resolve">
      /// A callback that accepts a value of type T and transitions the promise
      /// into the fulfilled state with that value.
      /// </param>
      /// <param name="Reject">
      /// A callback that accepts an Exception and transitions the promise
      /// into the rejected state with that error.
      /// </param>
      TExecutor = reference to procedure(Resolve: TProc<T>; Reject: TProc<Exception>);
  private
    FState: TPromiseState;
    FValue: T;
    FError: Exception;
    FThenHandlers: TList<TProc<T>>;
    FCatchHandlers: TList<TProc<Exception>>;
    FHandlerLock: TObject;

    class function CloneException(E: Exception): Exception; static;

    /// <summary>
    /// Resolves the promise with a given value.
    /// </summary>
    /// <param name="AValue">The value to resolve the promise with.</param>
    procedure Resolve(const AValue: T);

    /// <summary>
    /// Rejects the promise with a given error.
    /// </summary>
    /// <param name="AError">The exception that caused the rejection.</param>
    procedure Reject(AError: Exception);

  strict protected
    /// <summary>
    /// Returns the current state of the promise.
    /// </summary>
    /// <returns>
    /// A <see cref="TPromiseState"/> value indicating whether the
    /// promise is pending, fulfilled, or rejected.
    /// </returns>
    function GetState: TPromiseState; override;

  public
    /// <summary>
    /// Initializes a new instance of the <see cref="TPromise{T}"/> class and starts the asynchronous operation.
    /// </summary>
    /// <param name="AExecutor">The executor function that starts the asynchronous task.</param>
    constructor Create(AExecutor: TExecutor);

    /// <summary>
    /// Destroys the promise instance and releases any associated resources.
    /// </summary>
    destructor Destroy; override;

    /// <summary>
    /// Attaches a fulfillment callback that is executed when the promise is resolved.
    /// </summary>
    /// <param name="AOnFulfill">A callback function executed upon fulfillment.</param>
    /// <returns>A new promise to allow method chaining.</returns>
    function &Then(AOnFulfill: TProc): TPromise<T>; overload;

    /// <summary>
    /// Attaches a fulfillment callback that receives the resolved value.
    /// </summary>
    /// <param name="AOnFulfill">A callback function that receives the resolved value.</param>
    /// <returns>A new promise to allow method chaining.</returns>
    function &Then(AOnFulfill: TProc<T>): TPromise<T>; overload;

    /// <summary>
    /// Attaches a fulfillment callback that returns a transformed value of a different type.
    /// </summary>
    /// <typeparam name="TResult">The type of the transformed result.</typeparam>
    /// <param name="AOnFulfill">A function that produces the transformed result.</param>
    /// <returns>A new promise that resolves with the transformed value.</returns>
    function &Then<TResult>(AOnFulfill: TFunc<TResult>): TPromise<TResult>; overload;

    /// <summary>
    /// Attaches a fulfillment callback that returns another promise of a different type.
    /// </summary>
    /// <typeparam name="TResult">The type of the new promise’s result.</typeparam>
    /// <param name="AOnFulfill">A function that returns a new promise.</param>
    /// <returns>A new promise that resolves with the value of the returned promise.</returns>
    function &Then<TResult>(AOnFulfill: TFunc<T, TPromise<TResult>>): TPromise<TResult>; overload;

    /// <summary>
    /// Attaches a fulfillment callback that returns another promise of the same type.
    /// </summary>
    /// <param name="AOnFulfill">A function that returns a new promise of the same type.</param>
    /// <returns>A new promise that resolves with the value of the returned promise.</returns>
    function &Then(AOnFulfill: TFunc<T, TPromise<T>>): TPromise<T>; overload;

    /// <summary>
    /// Attaches a fulfillment callback that transforms the resolved value into another type.
    /// </summary>
    /// <typeparam name="TResult">The type of the transformed value.</typeparam>
    /// <param name="AOnFulfill">A function that transforms the resolved value.</param>
    /// <returns>A new promise that resolves with the transformed value.</returns>
    function &Then<TResult>(AOnFulfill: TFunc<T, TResult>): TPromise<TResult>; overload;

    /// <summary>
    /// Attaches a rejection callback to handle errors if the promise is rejected.
    /// </summary>
    /// <param name="AOnReject">A callback function that handles the error.</param>
    /// <returns>A new promise to allow method chaining.</returns>
    function &Catch(AOnReject: TProc<Exception>): TPromise<T>;

    /// <summary>
    /// Creates a promise that is immediately resolved with the specified value.
    /// </summary>
    /// <remarks>
    /// Use this method when you already have the result and want to wrap it in a promise.
    /// You can optionally provide a <paramref name="Proc"/> callback, which will be executed
    /// just before the promise is resolved, allowing you to perform any side effects.
    /// </remarks>
    /// <param name="AValue">
    /// The value with which the new promise will be fulfilled.
    /// </param>
    /// <param name="Proc">
    /// An optional procedure to run before resolving the promise. If not needed, pass <c>nil</c>.
    /// </param>
    /// <returns>
    /// A new <see cref="TPromise{T}"/> instance that is already in the fulfilled state with <paramref name="AValue"/>.
    /// </returns>
    class function Resolved(const AValue: T; Proc: TProc = nil): TPromise<T>;

    /// <summary>
    /// Creates a promise that is immediately rejected with the specified error.
    /// </summary>
    /// <remarks>
    /// Use this method when you need to represent an error state in a promise without performing
    /// any asynchronous work. You can optionally provide a <paramref name="Proc"/> callback,
    /// which will be executed just before the promise is rejected, allowing for any necessary
    /// side effects or cleanup.
    /// </remarks>
    /// <param name="AError">
    /// The exception with which the new promise will be rejected.
    /// </param>
    /// <param name="Proc">
    /// An optional procedure to run before rejecting the promise. If not needed, pass <c>nil</c>.
    /// </param>
    /// <returns>
    /// A new <see cref="TPromise{T}"/> instance that is already in the rejected state with <paramref name="AError"/>.
    /// </returns>
    class function Rejected(AError: Exception; Proc: TProc = nil): TPromise<T>;

  end;

  /// <summary>
  /// Maintains a global registry of all pending promises, ensuring they
  /// are kept alive until they are fulfilled or rejected.
  /// </summary>
  /// <remarks>
  /// This sealed class provides thread-safe methods to add and remove
  /// promises from the registry, as well as a manual cleanup routine
  /// to prune completed promises.  It is used internally by
  /// <see cref="TPromise{T}"/> to prevent premature destruction of
  /// promises that are still pending.
  /// </remarks>
  TPromiseRegistry = class sealed
  strict private
    class var FList : TObjectList<TObject>;
    class var FLock : TObject;
  public
    /// <summary>
    /// Initializes the promise registry and its internal lock.
    /// </summary>
    class constructor Create;

    /// <summary>
    /// Releases all resources held by the promise registry.
    /// </summary>
    class destructor  Destroy;

    /// <summary>
    /// Adds a promise instance to the registry, preventing it
    /// from being freed until it transitions out of the pending state.
    /// </summary>
    /// <param name="APromise">
    /// The promise instance to register.
    /// </param>
    class procedure Add(APromise: TObject);

    /// <summary>
    /// Removes a promise instance from the registry, allowing it
    /// to be freed if it is no longer referenced elsewhere.
    /// </summary>
    /// <param name="APromise">
    /// The promise instance to unregister.
    /// </param>
    class procedure Remove(APromise: TObject);

    /// <summary>
    /// Removes later a promise instance from the registry, allowing it
    /// to be freed if it is no longer referenced elsewhere.
    /// </summary>
    /// <param name="APromise">
    /// The promise instance to unregister.
    /// </param>
    class procedure RemoveLater(APromise: TObject);

    /// <summary>
    /// Scans the registry and deletes any promises that are no longer
    /// pending (i.e., fulfilled or rejected), releasing their memory.
    /// </summary>
    /// <remarks>
    /// This method can be called manually if you need to force
    /// cleanup of completed promises before their <see cref="TPromise{T}"/>
    /// callbacks are all delivered.
    /// </remarks>
    class procedure Cleanup;

    /// <summary>
    /// Removes and frees all promises in the registry, regardless of their state.
    /// </summary>
    /// <remarks>
    /// Acquires the internal lock to ensure thread safety, then iterates through
    /// the list of registered promises and deletes each one.  This will release
    /// both pending and completed promises from memory.  Use with caution, as
    /// any still-pending promises will be destroyed immediately.
    /// </remarks>
    class procedure Clear;
  end;

implementation

{ TPromise<T> }

class function TPromise<T>.CloneException(E: Exception): Exception;
var
  ExClass: ExceptClass ;
begin
  ExClass := ExceptClass(E.ClassType);
  Result := ExClass.Create(E.Message);
end;

constructor TPromise<T>.Create(AExecutor: TExecutor);
begin
  inherited Create;
  FHandlerLock := TObject.Create;
  FState := psPending;
  TPromiseRegistry.Add(Self);
  FThenHandlers := TList<TProc<T>>.Create;
  FCatchHandlers := TList<TProc<Exception>>.Create;
  try
    {--- The executor function that starts the asynchronous task. }
    AExecutor(
      procedure(AValue: T)
      begin
        Self.Resolve(AValue);
      end,

      {--- OnReject — clone then free the original }
      procedure(E: Exception)
      begin
        var Cloned := CloneException(E);
        {--- releases the original exception }
        E.Free;
        Self.Reject(Cloned);
      end
    );
  except
    on E: Exception do
    begin
      var Cloned := CloneException(E);
      {--- E.Free; Do not release E here because Delphi takes care of it }
      Reject(Cloned);
    end;
  end;
end;

destructor TPromise<T>.Destroy;
begin
  if Assigned(FError) then
    FError.Free;
  FThenHandlers.Free;
  FCatchHandlers.Free;
  FHandlerLock.Free;
  inherited;
end;

function TPromise<T>.GetState: TPromiseState;
begin
  Result := FState;
end;

class function TPromise<T>.Rejected(AError: Exception; Proc: TProc): TPromise<T>;
begin
  Result := TPromise<T>.Create(
    procedure(Resolve: TProc<T>; Reject: TProc<Exception>)
    begin
      TTask.Run(
        procedure()
        begin
          TThread.Queue(nil,
            procedure
            begin
              if Assigned(Proc) then
                Proc();
              Reject(CloneException(AError));
            end)
        end)
    end);
end;

procedure TPromise<T>.Resolve(const AValue: T);
var
  Handlers: TArray<TProc<T>>;
  Handler: TProc<T>;
  LValue: T;
begin
  if FState <> psPending then
    Exit;

  FState := psFulfilled;
  FValue := AValue;
  LValue := AValue;

  {--- Copy the locked callback list }
  TMonitor.Enter(FHandlerLock);
  try
    Handlers := FThenHandlers.ToArray;
  finally
    TMonitor.Exit(FHandlerLock);
  end;

  {--- Asynchronously call all “then” callbacks }
  for Handler in Handlers do
    TThread.Queue(nil,
      procedure
      begin
        Handler(LValue);
      end);

  {--- Empty locked lists }
  TMonitor.Enter(FHandlerLock);
  try
    FThenHandlers.Clear;
    FCatchHandlers.Clear;
  finally
    TMonitor.Exit(FHandlerLock);
  end;

  {--- Safe destruction because we are out of the register }
  TPromiseRegistry.RemoveLater(Self);
end;

class function TPromise<T>.Resolved(const AValue: T; Proc: TProc): TPromise<T>;
begin
  Result := TPromise<T>.Create(
    procedure(Resolve: TProc<T>; Reject: TProc<Exception>)
    begin
      TTask.Run(
        procedure()
        begin
          TThread.Queue(nil,
            procedure
            begin
              if Assigned(Proc) then
                Proc();
              Resolve(AValue);
            end)
        end)
    end);
end;

procedure TPromise<T>.Reject(AError: Exception);
var
  Handlers: TArray<TProc<Exception>>;
  Handler: TProc<Exception>;
  LError: Exception;
begin
  if FState <> psPending then
    begin
      AError.Free;
      Exit;
    end;

  FState := psRejected;
  FError := AError;
  LError := AError;

  {--- Copy the locked callback list }
  TMonitor.Enter(FHandlerLock);
  try
    Handlers := FCatchHandlers.ToArray;
  finally
    TMonitor.Exit(FHandlerLock);
  end;

  {--- Call all “catch” callbacks }
  for Handler in Handlers do
    TThread.Queue(nil,
      procedure
      begin
        Handler(LError);
      end);

  {--- Empty locked lists }
  TMonitor.Enter(FHandlerLock);
  try
    FThenHandlers.Clear;
    FCatchHandlers.Clear;
  finally
    TMonitor.Exit(FHandlerLock);
  end;

  {--- Safe destruction because we are out of the register }
  TPromiseRegistry.RemoveLater(Self);
end;

function TPromise<T>.&Then(AOnFulfill: TProc<T>): TPromise<T>;
begin
  {--- Version without transformation: we wrap the procedure in a function which returns the unchanged value }
  Result := &Then<T>(
    function(Value: T): T
    begin
      AOnFulfill(Value);
      Result := Value;
    end);
end;

function TPromise<T>.&Then<TResult>(AOnFulfill: TFunc<T, TResult>): TPromise<TResult>;
begin
  {--- Creation of a new promise that will be resolved when this one is resolved }
  Result := TPromise<TResult>.Create(
    procedure(Resolve: TProc<TResult>; Reject: TProc<Exception>)
    begin
      if FState = psFulfilled then
        begin
          try
            Resolve(AOnFulfill(FValue));
          except
            on E: Exception do
              Reject(CloneException(E));
          end;
        end
      else
      if FState = psRejected then
        begin
          Reject(CloneException(FError))
        end
      else
        begin
          {--- If the operation is not yet complete, we add callbacks for chaining }
          TMonitor.Enter(FHandlerLock);
          try
            FThenHandlers.Add(
              procedure(Value: T)
              begin
                try
                  Resolve(AOnFulfill(Value));
                except
                  on E: Exception do
                    Reject(CloneException(E));
                end;
              end);
            FCatchHandlers.Add(
              procedure(E: Exception)
              begin
                Reject(CloneException(E));
              end);
          finally
            TMonitor.Exit(FHandlerLock);
          end;
        end;
    end);
end;

function TPromise<T>.&Then(AOnFulfill: TFunc<T, TPromise<T>>): TPromise<T>;
begin
  Result := TPromise<T>.Create(
    procedure(Resolve: TProc<T>; Reject: TProc<Exception>)
    begin
      if FState = psFulfilled then
        begin
          try
            AOnFulfill(FValue)
              .&Then(
                procedure(NewValue: T)
                begin
                  Resolve(NewValue);
                end)
              .&Catch(
                procedure(E: Exception)
                begin
                  Reject(CloneException(E));
                end);
          except
            on E: Exception do
              Reject(CloneException(E));
          end;
        end
      else
      if FState = psRejected then
        begin
          Reject(CloneException(FError))
        end
      else
        begin
          TMonitor.Enter(FHandlerLock);
          try
            FThenHandlers.Add(
              procedure(Value: T)
              begin
                try
                  AOnFulfill(Value)
                    .&Then(
                      procedure(NewValue: T)
                      begin
                        Resolve(NewValue);
                      end)
                    .&Catch(
                    procedure(E: Exception)
                    begin
                      Reject(CloneException(E));
                    end);
                except
                  on E: Exception do
                    Reject(CloneException(E));
                end;
              end);
            FCatchHandlers.Add(
              procedure(E: Exception)
              begin
                Reject(CloneException(E));
              end);
          finally
            TMonitor.Exit(FHandlerLock);
          end;
        end;
    end);
end;

function TPromise<T>.&Then<TResult>(
  AOnFulfill: TFunc<TResult>): TPromise<TResult>;
begin
  Result := TPromise<TResult>.Create(
    procedure(Resolve: TProc<TResult>; Reject: TProc<Exception>)
    begin
      if FState = psFulfilled then
        begin
          try
            {--- Call the action without parameters and resolve with the result }
            Resolve(AOnFulfill());
          except
            on E: Exception do
              Reject(CloneException(E));
          end;
        end
    else
    if FState = psRejected then
      begin
        Reject(CloneException(FError));
      end
    else
      begin
        {--- If the promise is pending, we add callbacks }
        TMonitor.Enter(FHandlerLock);
        try
          FThenHandlers.Add(
            procedure(Value: T)
            begin
              try
                Resolve(AOnFulfill());
              except
                on E: Exception do
                  Reject(CloneException(E));
              end;
            end);
          FCatchHandlers.Add(
            procedure(E: Exception)
            begin
              Reject(CloneException(E));
            end);
        finally
          TMonitor.Exit(FHandlerLock);
        end;
      end;
    end);
end;

function TPromise<T>.&Then<TResult>(
  AOnFulfill: TFunc<T, TPromise<TResult>>): TPromise<TResult>;
begin
  Result := TPromise<TResult>.Create(
    procedure(Resolve: TProc<TResult>; Reject: TProc<Exception>)
    begin
      if FState = psFulfilled then
        begin
          try
            AOnFulfill(FValue)
              .&Then(
                procedure(NewValue: TResult)
                begin
                  Resolve(NewValue);
                end)
              .&Catch(
                procedure(E: Exception)
                begin
                  Reject(CloneException(E));
                end);
          except
            on E: Exception do
              Reject(CloneException(E));
          end;
        end
      else
      if FState = psRejected then
        begin
          Reject(CloneException(FError));
        end
      else
        begin
          TMonitor.Enter(FHandlerLock);
          try
            FThenHandlers.Add(
              procedure(Value: T)
              begin
                try
                  AOnFulfill(Value)
                    .&Then(
                      procedure(NewValue: TResult)
                      begin
                        Resolve(NewValue);
                      end)
                    .&Catch(
                      procedure(E: Exception)
                      begin
                        Reject(CloneException(E));
                      end);
                except
                  on E: Exception do
                    Reject(CloneException(E));
                end;
              end);
            FCatchHandlers.Add(
              procedure(E: Exception)
              begin
                Reject(CloneException(E));
              end);
          finally
            TMonitor.Exit(FHandlerLock);
          end;
        end;
    end);
end;

function TPromise<T>.&Then(AOnFulfill: TProc): TPromise<T>;
begin
  Result := TPromise<T>.Create(
    procedure(Resolve: TProc<T>; Reject: TProc<Exception>)
    begin
      if FState = psFulfilled then
        begin
          try
            {--- Calling the action without parameters }
            AOnFulfill();
            {--- Pass the initial value after the action is executed }
            Resolve(FValue);
          except
            on E: Exception do
              Reject(CloneException(E));
          end;
        end
      else
      if FState = psRejected then
        begin
          Reject(CloneException(FError))
        end
      else
        begin
          {--- If the operation is not yet completed, add callbacks for chaining }
          TMonitor.Enter(FHandlerLock);
          try
            FThenHandlers.Add(
              procedure(Value: T)
              begin
                try
                  AOnFulfill();
                  Resolve(Value);
                except
                  on E: Exception do
                    Reject(CloneException(E));
                end;
              end);
            FCatchHandlers.Add(
              procedure(E: Exception)
              begin
                Reject(CloneException(E));
              end);
          finally
            TMonitor.Exit(FHandlerLock);
          end;
        end;
    end);
end;

function TPromise<T>.&Catch(AOnReject: TProc<Exception>): TPromise<T>;
begin
  {--- Create a new promise that passes the value or handles the error with AOnReject }
  Result := TPromise<T>.Create(
    procedure(Resolve: TProc<T>; Reject: TProc<Exception>)
    begin
      if FState = psFulfilled then
        begin
          Resolve(FValue);
        end
      else
      if FState = psRejected then
        begin
          AOnReject(FError);
          Reject(CloneException(FError));
        end
      else
        begin
          TMonitor.Enter(FHandlerLock);
          try
            FThenHandlers.Add(
              procedure(Value: T)
              begin
                Resolve(Value);
              end);
            FCatchHandlers.Add(
              procedure(E: Exception)
              begin
                AOnReject(E);
                Reject(CloneException(E));
              end);
          finally
            TMonitor.Exit(FHandlerLock);
          end;
        end;
    end);
end;

{ TPromiseRegistry }

class procedure TPromiseRegistry.Add(APromise: TObject);
begin
  TMonitor.Enter(FLock);
  try
    FList.Add(APromise);
  finally
    TMonitor.Exit(FLock);
  end;
end;

class procedure TPromiseRegistry.Cleanup;
begin
  TMonitor.Enter(FLock);
  try
    for var I := FList.Count - 1 downto 0 do
      {--- Remove the promise from the list as soon as it moves to the final state. }
      if TObject(FList[I]) is TPromiseBase then
        with TPromiseBase(FList[I]) do
          if State <> psPending then
            {--- releases the object }
            FList.Delete(I);
  finally
    TMonitor.Exit(FLock);
  end;
end;

class procedure TPromiseRegistry.Clear;
begin
  TMonitor.Enter(FLock);
  try
    for var I := FList.Count - 1 downto 0 do
      {--- Remove the promise from the list as soon as it moves to the final state. }
      if TObject(FList[I]) is TPromiseBase then
        with TPromiseBase(FList[I]) do
            {--- releases the object }
            FList.Delete(I);
  finally
    TMonitor.Exit(FLock);
  end;
end;

class constructor TPromiseRegistry.Create;
begin
  {--- simple critical section }
  FLock := TObject.Create;

  {--- OwnsObjects = True }
  FList := TObjectList<TObject>.Create(True);
end;

class destructor TPromiseRegistry.Destroy;
begin
  FList.Free;
  FLock.Free;
end;

class procedure TPromiseRegistry.Remove(APromise: TObject);
begin
  TMonitor.Enter(FLock);
  try
    {--- releases the object }
    var Index := FList.IndexOf(APromise);
    if Index >= 0 then
      FList.Delete(Index);
  finally
    TMonitor.Exit(FLock);
  end;
end;

class procedure TPromiseRegistry.RemoveLater(APromise: TObject);
begin
  TThread.Queue(nil,
    procedure
    begin
      Remove(APromise);
    end);
end;

initialization
finalization
  {--- Delete pending promises }
  TPromiseRegistry.Clear;
end.

unit MistralAI.Async.Support;

{-------------------------------------------------------------------------------

      Unit containing  records for managing  asynchronous events related to
      chat requests.

      The  MistralAI.Chat.AsyncEvents  unit  provides  definitions for  the
      TAsyncParams<T>  and  TAsynStreamParams<T>  records, which  are  used
      to  handle  the lifecycle  of asynchronous chat operations, including
      starting, progressing, succeeding, and handling errors.
      These records enable non-blocking operations for chat functionalities
      and can be reused across multiple modules.

      This unit depends  on MistralAI.Params.Core  for parameter management.
      The IUseParams<T>  and  TUseParamsFactory<T>  interfaces  and  classes
      from  MistralAI.Params.Core  are  utilized  to  create  and manage the
      parameter  instances  for  asynchronous  operations.

        Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
        Visit the Github repository for the documentation and use examples

-------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, system.Classes, System.Threading, MistralAI.Async.Params,
  MistralAI.Async.Promise;

type
  /// <summary>
  /// Record used to handle asynchronous request events.
  /// </summary>
  /// <remarks>
  /// <c>TAsyncCallback</c> manages the lifecycle of an asynchronous request.
  /// It provides Callbacks for different stages of the request, such as start, successful completion, or error.
  /// </remarks>
  TAsyncCallback<T> = record
  private
    FSender: TObject;
    FOnStart: TProc<TObject>;
    FOnSuccess: TProc<TObject, T>;
    FOnError: TProc<TObject, string>;
  public
    /// <summary>
    /// Object representing the sender of the asynchronous operation.
    /// </summary>
    /// <remarks>
    /// The <c>Sender</c> property is used to identify or store a reference to the object that initiated the request.
    /// This can be useful for providing context in the callback procedures.
    /// </remarks>
    property Sender: TObject read FSender write FSender;

    /// <summary>
    /// Event triggered at the start of the asynchronous request.
    /// </summary>
    /// <remarks>
    /// The <c>OnStart</c> event is called when the request begins.
    /// It can be used to initialize any required state or display a loading indicator to the user.
    /// <code>
    /// OnStart :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // Code executed at the start of the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnStart: TProc<TObject> read FOnStart write FOnStart;

    /// <summary>
    /// Event triggered at the end of the asynchronous request.
    /// </summary>
    /// <param name="Sender">
    /// Object that initiated the request, generally used for context.
    /// </param>
    /// <param name="Result">
    /// The result of type <c>T</c> returned at the end of the request.
    /// This event is used to process the final result of the asynchronous operation.
    /// </param>
    /// <remarks>
    /// The <c>OnSuccess</c> event is invoked when the process completes successfully.
    /// It can be used to perform final actions based on the received result.
    /// <code>
    /// OnSuccess :=
    ///    procedure (Sender: TObject; Result: T)
    ///    begin
    ///      // Code executed at the end of the request with the obtained result
    ///    end;
    /// </code>
    /// </remarks>
    property OnSuccess: TProc<TObject, T> read FOnSuccess write FOnSuccess;

    /// <summary>
    /// Event triggered when an error occurs during the asynchronous request.
    /// </summary>
    /// <param name="Sender">
    /// Object that initiated the request, generally used for context.
    /// </param>
    /// <param name="ErrorMessage">
    /// The error message received, which can be logged or displayed to the user.
    /// </param>
    /// <remarks>
    /// The <c>OnError</c> event is called when an error occurs during the asynchronous operation.
    /// It can be used to handle failures, display error messages, or perform any necessary cleanup actions.
    /// <code>
    /// OnError :=
    ///    procedure (Sender: TObject; ErrorMessage: string)
    ///    begin
    ///      // Code executed when an error occurs during the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnError: TProc<TObject, string> read FOnError write FOnError;
  end;

  /// <summary>
  /// Record used to define promise-style Callbacks for asynchronous operations.
  /// </summary>
  /// <typeparam name="T">The type of result returned by the asynchronous operation.</typeparam>
  /// <remarks>
  /// <c>TPromiseCallback&lt;T&gt;</c> encapsulates the Callbacks to handle the start, successful completion, or error of an asynchronous request
  /// in a promise-based workflow. Callback events can be used for UI updates, chaining operations, logging, or error handling
  /// according to the outcome of the asynchronous task.
  /// </remarks>
  TPromiseCallback<T> = record
  private
    FSender: TObject;
    FOnStart: TProc<TObject>;
    FOnSuccess: TFunc<TObject, T, string>;
    FOnError: TFunc<TObject, string, string>;
  public
    /// <summary>
    /// Object representing the sender of the asynchronous operation.
    /// </summary>
    /// <remarks>
    /// The <c>Sender</c> property is used to identify or store a reference to the object that initiated the request.
    /// This can be useful for providing context in the callback procedures.
    /// </remarks>
    property Sender: TObject read FSender write FSender;

    /// <summary>
    /// Event triggered at the start of the asynchronous request.
    /// </summary>
    /// <remarks>
    /// The <c>OnStart</c> event is called when the request begins.
    /// It can be used to initialize any required state or display a loading indicator to the user.
    /// <code>
    /// OnStart :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // Code executed at the start of the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnStart: TProc<TObject> read FOnStart write FOnStart;

    /// <summary>
    /// Event triggered at the end of the asynchronous request.
    /// </summary>
    /// <param name="Sender">
    /// Object that initiated the request, generally used for context.
    /// </param>
    /// <param name="Result">
    /// The result of type <c>T</c> returned at the end of the request.
    /// This event is used to process the final result of the asynchronous operation.
    /// </param>
    /// <remarks>
    /// The <c>OnSuccess</c> event is invoked when the process completes successfully.
    /// It can be used to perform final actions based on the received result.
    /// <code>
    /// OnSuccess :=
    ///    function (Sender: TObject; Result: T): string
    ///    begin
    ///      // Code executed at the end of the request with the obtained result
    ///      Result := String_builded_from_Result;
    ///    end;
    /// </code>
    /// </remarks>
    property OnSuccess: TFunc<TObject, T, string> read FOnSuccess write FOnSuccess;

    /// <summary>
    /// Event triggered when an error occurs during the asynchronous request.
    /// </summary>
    /// <param name="Sender">
    /// Object that initiated the request, generally used for context.
    /// </param>
    /// <param name="ErrorMessage">
    /// The error message received, which can be logged or displayed to the user.
    /// </param>
    /// <remarks>
    /// The <c>OnError</c> event is called when an error occurs during the asynchronous operation.
    /// It can be used to handle failures, display error messages, or perform any necessary cleanup actions.
    /// <code>
    /// OnError :=
    ///    function (Sender: TObject; ErrorMessage: string) : string
    ///    begin
    ///      // Code executed when an error occurs during the request
    ///      Result := String_from_error;
    ///    end;
    /// </code>
    /// </remarks>
    property OnError: TFunc<TObject, string, string> read FOnError write FOnError;
  end;

  /// <summary>
  /// Class used to manage asynchronous execution with callback events.
  /// </summary>
  /// <remarks>
  /// The <c>TAsyncCallBackExec&lt;T, U&gt;</c> class allows you to execute asynchronous operations with specified Callbacks for start, completion, and error events.
  /// It encapsulates the asynchronous execution logic, handling thread management and exception handling, providing an easy way to manage the lifecycle of an asynchronous request.
  /// </remarks>
  TAsyncCallbackExec<T; U: class> = class
  private
    FUse: IUseParams<T>;
    FSender: TObject;
    FOnStart: TProc<TObject>;
    FOnSuccess: TProc<TObject, U>;
    FOnError: TProc<TObject, string>;
  public
    /// <summary>
    /// Gets the <c>IUseParams&lt;T&gt;</c> interface instance used by this class.
    /// </summary>
    /// <value>
    /// An instance of <c>IUseParams&lt;T&gt;</c> that provides parameter management functionality.
    /// </value>
    property Use: IUseParams<T> read FUse;

    /// <summary>
    /// The object representing the sender of the asynchronous operation.
    /// </summary>
    /// <value>
    /// An instance of <c>TObject</c> identifying the originator of the operation.
    /// </value>
    /// <remarks>
    /// This property can be set to identify the object that initiated the asynchronous operation, which is useful in callback methods.
    /// </remarks>
    property Sender: TObject read FSender write FSender;

    /// <summary>
    /// Event triggered when the asynchronous operation starts.
    /// </summary>
    /// <value>
    /// A procedure of type <c>TProc&lt;TObject&gt;</c> to handle any setup or UI updates when the operation begins.
    /// </value>
    /// <remarks>
    /// Assign a procedure to this event to perform actions at the start of the asynchronous operation.
    /// <code>
    /// OnStart :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // Code executed at the start of the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnStart: TProc<TObject> read FOnStart write FOnStart;

    /// <summary>
    /// Event triggered when the asynchronous operation completes successfully.
    /// </summary>
    /// <value>
    /// A procedure of type <c>TProc&lt;TObject, U&gt;</c> to handle the result of the operation.
    /// </value>
    /// <remarks>
    /// Assign a procedure to this event to process the result returned by the operation.
    /// <code>
    /// OnSuccess :=
    ///    procedure (Sender: TObject; Result: T)
    ///    begin
    ///      // Code executed at the end of the request with the obtained result
    ///    end;
    /// </code>
    /// </remarks>
    property OnSuccess: TProc<TObject, U> read FOnSuccess write FOnSuccess;

    /// <summary>
    /// Event triggered when an error occurs during the asynchronous operation.
    /// </summary>
    /// <value>
    /// A procedure of type <c>TProc&lt;TObject, string&gt;</c> to handle exceptions or errors.
    /// </value>
    /// <remarks>
    /// Assign a procedure to this event to handle any exceptions or errors that occur during execution.
    /// <code>
    /// OnError :=
    ///    procedure (Sender: TObject; ErrorMessage: string)
    ///    begin
    ///      // Code executed when an error occurs during the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnError: TProc<TObject, string> read FOnError write FOnError;

    /// <summary>
    /// Executes the specified function asynchronously.
    /// </summary>
    /// <param name="Value">
    /// A function of type <c>TFunc&lt;U&gt;</c> representing the operation to execute asynchronously.
    /// </param>
    /// <remarks>
    /// This method creates and starts an asynchronous task that executes the provided function.
    /// It invokes the <c>OnStart</c> event before execution, the <c>OnSuccess</c> event upon successful completion, and the <c>OnError</c> event if an exception occurs during execution.
    /// </remarks>
    procedure Run(Value: TFunc<U>);

    /// <summary>
    /// Initializes a new instance of the <c>TAsyncCallBackExec&lt;T, U&gt;</c> class with the specified parameter function.
    /// </summary>
    /// <param name="Value">
    /// A function of type <c>TFunc&lt;T&gt;</c> used to create an instance of <c>IUseParams&lt;T&gt;</c>.
    /// </param>
    /// <remarks>
    /// The constructor initializes the internal <c>IUseParams&lt;T&gt;</c> interface using the provided function.
    /// </remarks>
    constructor Create(const Value: TFunc<T>);
  end;

  /// <summary>
  /// Record used to manage asynchronous events for a streaming chat request.
  /// </summary>
  /// <remarks>
  /// <c>TAsynChatStreamParams</c> allows you to handle the lifecycle of a chat request in streaming mode.
  /// It provides Callbacks for different stages such as when the request starts, progresses, succeeds, encounters an error, or needs to be canceled.
  /// </remarks>
  TAsyncStreamCallback<T> = record
  private
    FSender: TObject;
    FOnStart: TProc<TObject>;
    FOnSuccess: TProc<TObject>;
    FOnProgress: TProc<TObject, T>;
    FOnError: TProc<TObject, string>;
    FOnCancellation: TProc<TObject>;
    FOnDoCancel: TFunc<Boolean>;
  public
    /// <summary>
    /// The object representing the sender of the asynchronous operation.
    /// </summary>
    /// <remarks>
    /// The <c>Sender</c> property is used to identify or store a reference to the object that initiated the chat request,
    /// which can be useful for context within the callback procedures.
    /// </remarks>
    property Sender: TObject read FSender write FSender;

    /// <summary>
    /// Event triggered when the asynchronous chat request starts.
    /// </summary>
    /// <remarks>
    /// The <c>OnStart</c> event is called when the chat request begins. It can be used to set up any initial state or display a loading indicator to the user.
    /// <code>
    /// OnStart :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // code when chat request begin
    ///    end;
    /// </code>
    /// </remarks>
    property OnStart: TProc<TObject> read FOnStart write FOnStart;

    /// <summary>
    /// Event triggered when the asynchronous chat request completes successfully.
    /// </summary>
    /// <remarks>
    /// The <c>OnSuccess</c> event is invoked when the streaming process finishes successfully.
    /// It does not provide additional data, as the result is expected to have been handled progressively via the <c>OnProgress</c> event.
    /// <code>
    /// OnSuccess :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // code when the streaming process finishes successfully
    ///    end;
    /// </code>
    /// </remarks>
    property OnSuccess: TProc<TObject> read FOnSuccess write FOnSuccess;

    /// <summary>
    /// Event triggered to handle progress during the streaming chat request.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="Chat">
    /// The <c>TChat</c> object representing the current response chunk received from the model.
    /// This event can be used to update the user interface as new tokens are streamed in.
    /// </param>
    /// <remarks>
    /// The <c>OnProgress</c> event is fired every time a new chunk of data is received during the streaming process.
    /// This allows the application to handle the response progressively as it is generated by the model.
    /// <code>
    /// OnProgress :=
    ///    procedure (Sender: TObject; Chat: TChat)
    ///    begin
    ///      // code to handle the response progressively
    ///    end;
    /// </code>
    /// </remarks>
    property OnProgress: TProc<TObject, T> read FOnProgress write FOnProgress;

    /// <summary>
    /// Event triggered when an error occurs during the asynchronous chat request.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="ErrorMessage">
    /// The error message received, which can be logged or displayed to the user.
    /// </param>
    /// <remarks>
    /// The <c>OnError</c> event is called when an error occurs during the streaming process.
    /// This can be used to handle failures, show error messages, or perform any necessary clean-up actions.
    /// <code>
    /// OnError :=
    ///    procedure (Sender: TObject; message: string)
    ///    begin
    ///      // code to handle an error occurs during the streaming process
    ///    end;
    /// </code>
    /// </remarks>
    property OnError: TProc<TObject, string> read FOnError write FOnError;

    /// <summary>
    /// Event triggered when the asynchronous chat request has been canceled.
    /// </summary>
    /// <remarks>
    /// The <c>OnCancellation</c> event is fired when the chat request is canceled by the user or the application.
    /// This can be used to perform clean-up operations or notify the user that the request has been terminated.
    /// <code>
    /// OnCancellation :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // code to handle chat request cancellation
    ///    end;
    /// </code>
    /// </remarks>
    property OnCancellation: TProc<TObject> read FOnCancellation write FOnCancellation;

    /// <summary>
    /// Function called to determine if the asynchronous chat request should be canceled.
    /// </summary>
    /// <returns>
    /// A <c>Boolean</c> value indicating whether the request should be canceled (<c>True</c>) or allowed to continue (<c>False</c>).
    /// </returns>
    /// <remarks>
    /// The <c>OnDoCancel</c> function is periodically invoked to check whether the user or application has requested to cancel the chat request.
    /// If the function returns <c>True</c>, the streaming process will be aborted.
    /// <code>
    /// OnDoCancel :=
    ///    function : Boolean
    ///    begin
    ///      Result := ... // True to stop the streaming process
    ///    end;
    /// </code>
    /// </remarks>
    property OnDoCancel: TFunc<Boolean> read FOnDoCancel write FOnDoCancel;
  end;

  /// <summary>
  /// Record used to handle asynchronous events for a streaming operation with promise-based Callbacks.
  /// </summary>
  /// <remarks>
  /// <c>TPromiseStreamCallback&lt;T&gt;</c> manages the lifecycle of a streaming asynchronous request.
  /// It provides promise-style function Callbacks for key events including start, progress, success, error, cancellation, and cancellation check.
  /// The event signatures allow you to compose and chain UI, logging, or application logic in response to streamed data, errors, or user cancellation.
  /// </remarks>
  TPromiseStreamCallback<T> = record
  private
    FSender: TObject;
    FOnStart: TProc<TObject>;
    FOnSuccess: TFunc<TObject, string>;
    FOnProgress: TProc<TObject, T>;
    FOnError: TFunc<TObject, string, string>;
    FOnCancellation: TFunc<TObject, string>;
    FOnDoCancel: TFunc<Boolean>;
  public
    /// <summary>
    /// The object representing the sender of the asynchronous operation.
    /// </summary>
    /// <remarks>
    /// The <c>Sender</c> property is used to identify or store a reference to the object that initiated the chat request,
    /// which can be useful for context within the callback procedures.
    /// </remarks>
    property Sender: TObject read FSender write FSender;

    /// <summary>
    /// Event triggered when the asynchronous chat request starts.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="Chat">
    /// The <c>TChat</c> object representing the current response chunk received from the model.
    /// This event can be used to update the user interface as new tokens are streamed in.
    /// </param>
    /// <remarks>
    /// The <c>OnStart</c> event is called when the chat request begins. It can be used to set up any initial state or display a loading indicator to the user.
    /// <code>
    /// OnStart :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // code when chat request begin
    ///    end;
    /// </code>
    /// </remarks>
    property OnStart: TProc<TObject> read FOnStart write FOnStart;

    /// <summary>
    /// Event triggered when the asynchronous Data request completes successfully.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <remarks>
    /// The <c>OnSuccess</c> event is invoked when the streaming process finishes successfully.
    /// It does not provide additional data, as the result is expected to have been handled progressively via the <c>OnProgress</c> event.
    /// <code>
    /// OnSuccess :=
    ///    function (Sender: TObject): string
    ///    begin
    ///      // code when the streaming process finishes successfully
    ///      Result := String_builded_from_Data;
    ///    end;
    /// </code>
    /// </remarks>
    property OnSuccess: TFunc<TObject, string> read FOnSuccess write FOnSuccess;

    /// <summary>
    /// Event triggered to handle progress during the streaming Data request.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="Data">
    /// The <c>T</c> object representing the current response chunk received from the model.
    /// This event can be used to update the user interface as new tokens are streamed in.
    /// </param>
    /// <remarks>
    /// The <c>OnProgress</c> event is fired every time a new chunk of data is received during the streaming process.
    /// This allows the application to handle the response progressively as it is generated by the model.
    /// <code>
    /// OnProgress :=
    ///    procedure (Sender: TObject; Data: T)
    ///    begin
    ///      // code to handle the response progressively
    ///    end;
    /// </code>
    /// </remarks>
    property OnProgress: TProc<TObject, T> read FOnProgress write FOnProgress;

    /// <summary>
    /// Event triggered when an error occurs during the asynchronous streamed request.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="ErrorMessage">
    /// The error message received, which can be logged or displayed to the user.
    /// </param>
    /// <remarks>
    /// The <c>OnError</c> event is called when an error occurs during the streaming process.
    /// This can be used to handle failures, show error messages, or perform any necessary clean-up actions.
    /// <code>
    /// OnError :=
    ///    function (Sender: TObject; message: string): string
    ///    begin
    ///      // code to handle an error occurs during the streaming process
    ///      Result := String_builded_from_message;
    ///    end;
    /// </code>
    /// </remarks>
    property OnError: TFunc<TObject, string, string> read FOnError write FOnError;

    /// <summary>
    /// Event triggered when the asynchronous request has been canceled.
    /// </summary>
    /// <remarks>
    /// The <c>OnCancellation</c> event is fired when the chat request is canceled by the user or the application.
    /// This can be used to perform clean-up operations or notify the user that the request has been terminated.
    /// <code>
    /// OnCancellation :=
    ///    function (Sender: TObject): string
    ///    begin
    ///      // code to handle chat request cancellation
    ///      Result := 'aborted'; or other string message
    ///    end;
    /// </code>
    /// </remarks>
    property OnCancellation: TFunc<TObject, string> read FOnCancellation write FOnCancellation;

    /// <summary>
    /// Function called to determine if the asynchronous chat request should be canceled.
    /// </summary>
    /// <returns>
    /// A <c>Boolean</c> value indicating whether the request should be canceled (<c>True</c>) or allowed to continue (<c>False</c>).
    /// </returns>
    /// <remarks>
    /// The <c>OnDoCancel</c> function is periodically invoked to check whether the user or application has requested to cancel the chat request.
    /// If the function returns <c>True</c>, the streaming process will be aborted.
    /// <code>
    /// OnDoCancel :=
    ///    function : Boolean
    ///    begin
    ///      Result := ... // True to stop the streaming process
    ///    end;
    /// </code>
    /// </remarks>
    property OnDoCancel: TFunc<Boolean> read FOnDoCancel write FOnDoCancel;
  end;

  /// <summary>
  /// Reference to a procedure type used to invoke an asynchronous operation with callback parameters.
  /// </summary>
  /// <typeparam name="T">The type of the result expected from the asynchronous operation.</typeparam>
  /// <param name="CallbackParams">
  /// A function returning a <c>TAsynCallBack&lt;T&gt;</c> record that defines the Callbacks to handle start, success, and error events of the asynchronous request.
  /// </param>
  /// <remarks>
  /// <c>TInvokeAsync&lt;T&gt;</c> abstracts the invocation of an asynchronous task.
  /// It accepts a function providing the set of Callbacks to be executed during the lifecycle of the async operation.
  /// This enables flexible and type-safe management of event handlers for non-blocking code.
  /// </remarks>
  TInvokeAsync<T> = reference to procedure(const CallbackParams: TFunc<TAsyncCallback<T>>);

  /// <summary>
  /// Helper record providing utilities for composing asynchronous operations using async/await-style patterns.
  /// </summary>
  /// <remarks>
  /// <c>TAsyncAwaitHelper</c> offers static helper methods to simplify the integration of asynchronous workflows in a promise-like style.
  /// Its main utility is to bridge traditional callback-based asynchronous invocation with a modern, promise-based API.
  /// </remarks>
  TAsyncAwaitHelper = record
    /// <summary>
    /// Wraps a callback-based asynchronous invocation into a promise-style asynchronous workflow.
    /// </summary>
    /// <typeparam name="T">The type of result returned by the asynchronous operation.</typeparam>
    /// <param name="Invoke">
    /// A procedure that starts the asynchronous operation, accepting a function returning a <c>TAsynCallBack&lt;T&gt;</c> to specify event handlers.
    /// </param>
    /// <param name="Callbacks">
    /// A function returning a <c>TPromiseCallback&lt;T&gt;</c> record defining the promise-style callback handlers.
    /// </param>
    /// <returns>
    /// Returns a <c>TPromise&lt;T&gt;</c> representing the asynchronous operation.
    /// </returns>
    /// <remarks>
    /// Use <c>WrapAsyncAwait</c> to convert legacy callback-driven async code to a more composable, promise-based approach.
    /// </remarks>
    class function WrapAsyncAwait<T>(const Invoke: TInvokeAsync<T>;
      const Callbacks: TFunc<TPromiseCallback<T>>): TPromise<T>; static;
  end;

implementation

{ TAsyncCallbackExec<T, U> }

constructor TAsyncCallbackExec<T, U>.Create(const Value: TFunc<T>);
begin
  inherited Create;
  FUse := TUseParamsFactory<T>.CreateInstance(Value);
end;

procedure TAsyncCallbackExec<T, U>.Run(Value: TFunc<U>);
begin
  {--- Assign callback values to internal variables for asynchrony to work properly }
  var InternalSender := Sender;
  var InternalOnStart := OnStart;
  var InternalOnSuccess := OnSuccess;
  var InternalOnError := OnError;

  var Task: ITask := TTask.Create(
          procedure()
          begin
            try
              {--- Pass the instance of the current class in case no value was specified. }
              if not Assigned(InternalSender) then
                InternalSender := Self;

              {--- Trigger OnStart callback }
              if Assigned(InternalOnStart) then
                TThread.Queue(nil,
                  procedure
                  begin
                    InternalOnStart(InternalSender);
                  end);

              {--- Processing }
              var Result := Value();

              {--- Trigger OnEnd callback when the process is done }
              TThread.Queue(nil,
                  procedure
                  begin
                    try
                      if Assigned(InternalOnSuccess) then
                        InternalOnSuccess(InternalSender, Result);
                    finally
                      {--- Makes sure to release the instance containing the data obtained
                           following processing}
                      if Assigned(Result) then
                        Result.Free;
                    end;
                  end);

            except
              on E: Exception do
                begin
                  var Error := AcquireExceptionObject;
                  try
                    var ErrorMsg := (Error as Exception).Message;

                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(InternalOnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        InternalOnError(InternalSender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
          end);
  Task.Start;
end;

{ TAsyncAwaitHelper }

class function TAsyncAwaitHelper.WrapAsyncAwait<T>(const Invoke: TInvokeAsync<T>;
  const Callbacks: TFunc<TPromiseCallback<T>>): TPromise<T>;
begin
  Result := TPromise<T>.Create(
    procedure(Resolve: TProc<T>; Reject: TProc<Exception>)
    begin
      Invoke(
        function: TAsyncCallback<T>
        begin
          if Assigned(Callbacks) then
            begin
              Result.Sender  := Callbacks.Sender;
              Result.OnStart := Callbacks.OnStart;

              Result.OnSuccess :=
                procedure(Sender: TObject; Value: T)
                begin
                  if Assigned(Callbacks.OnSuccess) then
                    Callbacks.OnSuccess(Sender, Value);
                  Resolve(Value);
                end;

              Result.OnError :=
                procedure(Sender: TObject; Error: string)
                begin
                  if Assigned(Callbacks.OnError) then
                    Error := Callbacks.OnError(Sender, Error);
                  Reject(Exception.Create(Error));
                end;
            end
          else
            begin
              Result.OnSuccess :=
                procedure(Sender: TObject; Value: T)
                begin
                  Resolve(Value);
                end;

              Result.OnError := procedure(Sender: TObject; Error: string)
                begin
                  Reject(Exception.Create(Error));
                end;
            end;
        end);
    end);
end;

end.

unit MistralAI.Audio;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.Classes, System.SysUtils, REST.JsonReflect, REST.Json.Types, System.Net.Mime,
  System.Threading, MistralAI.API.Params, MistralAI.API, MistralAI.Async.Support,
  MistralAI.Types, MistralAI.Async.Promise;

type
  /// <summary>
  /// Represents the parameter builder for configuring an audio transcription request.
  /// </summary>
  /// <remarks>
  /// Use <c>TAudioTranscriptionParams</c> to set various input fields such as file path or URL, model name,
  /// language, and timestamp options. The configured instance is submitted to the transcription endpoint to
  /// obtain speech-to-text results from an audio source.
  /// </remarks>
  TAudioTranscriptionParams = class(TMultipartFormData)

    /// <summary>
    /// Sets the audio input for transcription via a local file path or a URL.
    /// </summary>
    /// <param name="Value">
    /// A file path (e.g., 'C:\audio\clip.mp3') or a public URL (e.g., 'https://example.com/audio.wav').
    /// </param>
    /// <returns>
    /// The current <c>TAudioTranscriptionParams</c> instance for fluent configuration.
    /// </returns>
    /// <exception cref="Exception">
    /// Raised if the local file does not exist or cannot be opened.
    /// </exception>
    /// <remarks>
    /// The method will determine whether the value is a URL or a file path and upload the audio accordingly.
    /// </remarks>
    function FileUrl(const Value: string): TAudioTranscriptionParams;

    /// <summary>
    /// Specifies the model to be used for transcription.
    /// </summary>
    /// <param name="Value">
    /// The model identifier string (e.g., 'voxtral-mini-2507').
    /// </param>
    /// <returns>
    /// The current <c>TAudioTranscriptionParams</c> instance for fluent configuration.
    /// </returns>
    function Model(const Value: string): TAudioTranscriptionParams;

    /// <summary>
    /// Defines the spoken language of the audio input to improve recognition accuracy.
    /// </summary>
    /// <param name="Value">
    /// A language code following the BCP 47 format (e.g., 'en', 'fr', 'es').
    /// </param>
    /// <returns>
    /// The current <c>TAudioTranscriptionParams</c> instance for fluent configuration.
    /// </returns>
    /// <remarks>
    /// If not specified, the transcription service attempts automatic language detection.
    /// </remarks>
    function Language(const Value: string): TAudioTranscriptionParams;

    /// <summary>
    /// Enables timestamp annotations in the transcription output.
    /// </summary>
    /// <param name="Value">
    /// A string value indicating the level of timestamp granularity. Currently, only 'segment' is supported.
    /// </param>
    /// <returns>
    /// The current <c>TAudioTranscriptionParams</c> instance for fluent configuration.
    /// </returns>
    /// <remarks>
    /// Timestamp granularity allows you to track when each segment of speech starts and ends.
    /// </remarks>
    function TimestampGranularities(const Value: string): TAudioTranscriptionParams;

    /// <summary>
    /// Creates a new instance of <c>TAudioTranscriptionParams</c>.
    /// </summary>
    /// <remarks>
    /// Automatically initializes the underlying multipart form structure.
    /// </remarks>
    constructor Create; reintroduce;
  end;

  /// <summary>
  /// Represents a single transcribed segment from an audio file.
  /// </summary>
  /// <remarks>
  /// Each instance of <c>TAudioSegment</c> contains the textual content of a portion of audio along with
  /// its start and end timestamps, allowing you to reconstruct the timing of speech within the original audio.
  /// </remarks>
  TAudioSegment = class
  private
    FText: string;
    FStart: Double;
    FEnd: Double;
  public
    /// <summary>
    /// The transcribed text content for this audio segment.
    /// </summary>
    /// <value>
    /// A string representing the portion of speech that occurred between <c>Start</c> and <c>End</c>.
    /// </value>
    property Text: string read FText write FText;

    /// <summary>
    /// The starting time of the segment, in seconds.
    /// </summary>
    /// <value>
    /// A <c>Double</c> value indicating the offset from the beginning of the audio file where the speech in this segment starts.
    /// </value>
    property Start: Double read FStart write FStart;

    /// <summary>
    /// The ending time of the segment, in seconds.
    /// </summary>
    /// <value>
    /// A <c>Double</c> value indicating the offset from the beginning of the audio file where the speech in this segment ends.
    /// </value>
    property &End: Double read FEnd write FEnd;
  end;

  /// <summary>
  /// Represents usage statistics related to an audio transcription request.
  /// </summary>
  /// <remarks>
  /// <c>TAudioUsage</c> provides detailed metrics about the resources consumed during the transcription
  /// process, including token counts and the total duration of the audio input.
  /// </remarks>
  TAudioUsage = class
  private
    [JsonNameAttribute('prompt_audio_seconds')]
    FPromptAudioSeconds: Int64;
    [JsonNameAttribute('prompt_tokens')]
    FPromptTokens: Int64;
    [JsonNameAttribute('total_tokens')]
    FTotalTokens: Int64;
    [JsonNameAttribute('completion_tokens')]
    FCompletionTokens: Int64;
  public
    /// <summary>
    /// Total duration of the input audio in seconds.
    /// </summary>
    /// <value>
    /// An integer representing the number of seconds of audio processed during the transcription.
    /// </value>
    property PromptAudioSeconds: Int64 read FPromptAudioSeconds write FPromptAudioSeconds;

    /// <summary>
    /// Total duration of the input audio in seconds.
    /// </summary>
    /// <value>
    /// An integer representing the number of seconds of audio processed during the transcription.
    /// </value>
    property PromptTokens: Int64 read FPromptTokens write FPromptTokens;

    /// <summary>
    /// Total number of tokens involved in the transcription process.
    /// </summary>
    /// <value>
    /// The combined count of prompt and completion tokens.
    /// </value>
    property TotalTokens: Int64 read FTotalTokens write FTotalTokens;

    /// <summary>
    /// Number of tokens generated as part of the transcription output.
    /// </summary>
    /// <value>
    /// The token count corresponding to the textual content produced by the transcription model.
    /// </value>
    property CompletionTokens: Int64 read FCompletionTokens write FCompletionTokens;
  end;

  /// <summary>
  /// Represents the result of an audio transcription request.
  /// </summary>
  /// <remarks>
  /// <c>TAudioTranscription</c> encapsulates the output of a transcription task, including the full transcribed text,
  /// detected language, model used, timestamped segments, and usage statistics. It is returned as the response
  /// object from the audio transcription API endpoint.
  /// </remarks>
  TAudioTranscription = class(TJSONFingerprint)
  private
    FModel: string;
    FText: string;
    FLanguage: string;
    FSegments : TArray<TAudioSegment>;
    FUsage: TAudioUsage;
  public
    /// <summary>
    /// The identifier of the model used for the transcription.
    /// </summary>
    /// <value>
    /// A string representing the name or version of the transcription model (e.g., 'voxtral-mini-2507').
    /// </value>
    property Model: string read FModel write FModel;

    /// <summary>
    /// The full transcribed text of the audio input.
    /// </summary>
    /// <value>
    /// A string containing the entire speech-to-text output as a single plain text block.
    /// </value>
    property Text: string read FText write FText;

    /// <summary>
    /// The detected or specified language of the transcription.
    /// </summary>
    /// <value>
    /// A BCP 47 language code string (e.g., 'en', 'fr', 'de').
    /// </value>
    property Language: string read FLanguage write FLanguage;

    /// <summary>
    /// The list of timestamped segments corresponding to speech intervals.
    /// </summary>
    /// <value>
    /// An array of <c>TAudioSegment</c> objects, each representing a portion of speech with timing metadata.
    /// </value>
    /// <remarks>
    /// This property is populated when <c>timestamp_granularities = 'segment'</c> is used during the request.
    /// </remarks>
    property Segments : TArray<TAudioSegment> read FSegments write FSegments;

    /// <summary>
    /// Detailed usage statistics for the transcription operation.
    /// </summary>
    /// <value>
    /// A <c>TAudioUsage</c> object providing information such as token counts and audio duration.
    /// </value>
    property Usage: TAudioUsage read FUsage write FUsage;

    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents the asynchronous callback structure for audio transcription operations.
  /// </summary>
  /// <remarks>
  /// <c>TAsyncAudioTranscription</c> is a type alias for <c>TAsyncCallback&lt;TAudioTranscription&gt;</c>.
  /// It allows you to assign lifecycle event handlers such as <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c>
  /// when performing non-blocking transcription requests.
  /// This is useful for integrating event-driven logic into your application when working with
  /// <c>TAudioRoute.AsyncTranscription</c> to process audio asynchronously without blocking the main thread.
  /// </remarks>
  TAsyncAudioTranscription = TAsyncCallback<TAudioTranscription>;

  /// <summary>
  /// Represents the promise-based interface for audio transcription operations.
  /// </summary>
  /// <remarks>
  /// <c>TPromiseAudioTranscription</c> is a type alias for <c>TPromiseCallback&lt;TAudioTranscription&gt;</c>.
  /// It provides a structured way to handle asynchronous transcription results using a promise-like API,
  /// allowing chaining of <c>OnSuccess</c> and <c>OnError</c> handlers.
  /// This type is typically used with <c>TAudioRoute.AsyncAwaitTranscription</c> for workflows where you want
  /// to react to the transcription result once it's completed, without relying on event callbacks.
  /// </remarks>
  TPromiseAudioTranscription = TPromiseCallback<TAudioTranscription>;

  TAudioRoute = class(TMistralAIAPIRoute)
    /// <summary>
    /// Submits an asynchronous audio transcription request and returns a promise for its result.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure that configures the <c>TAudioTranscriptionParams</c> instance used to define the transcription request,
    /// such as the audio source, model selection, language, or timestamp settings.
    /// </param>
    /// <param name="Callbacks">
    /// An optional function returning a <c>TPromiseAudioTranscription</c> instance, allowing you to assign
    /// <c>OnSuccess</c> and <c>OnError</c> handlers for promise-style chaining.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TAudioTranscription&gt;</c> that resolves with the transcription result or
    /// rejects with an exception if the operation fails.
    /// </returns>
    /// <remarks>
    /// This method enables a modern, promise-based approach to asynchronous programming, allowing you to compose
    /// follow-up logic once the transcription completes. It is especially useful in functional or await-style workflows.
    /// The transcription executes on a background thread. No UI blocking occurs.
    /// </remarks>
    function AsyncAwaitTranscription(
      const ParamProc: TProc<TAudioTranscriptionParams>;
      const Callbacks: TFunc<TPromiseAudioTranscription> = nil): TPromise<TAudioTranscription>;

    /// <summary>
    /// Executes a synchronous audio transcription request using the provided parameter configuration.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure that receives a <c>TAudioTranscriptionParams</c> instance to configure the transcription request,
    /// including fields such as file path or URL, model, language, and timestamp options.
    /// </param>
    /// <returns>
    /// A <c>TAudioTranscription</c> object containing the result of the transcription,
    /// including full text, segments (if requested), detected language, and usage metadata.
    /// </returns>
    /// <remarks>
    /// This method performs a blocking call. It should be used when you require an immediate result and
    /// can afford to wait until the request is fully processed.
    /// If an error occurs (e.g., invalid parameters, network failure, API error), an exception is raised.
    /// </remarks>
    function Transcription(const ParamProc: TProc<TAudioTranscriptionParams>): TAudioTranscription;

    /// <summary>
    /// Performs an asynchronous audio transcription request using callback-style event handlers.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the <c>TAudioTranscriptionParams</c> object, such as specifying the audio file URL or path,
    /// the transcription model, language, or timestamp granularity.
    /// </param>
    /// <param name="Callbacks">
    /// A function that returns a <c>TAsyncAudioTranscription</c> instance, where you can assign handlers such as
    /// <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c> to respond to different stages of the transcription lifecycle.
    /// </param>
    /// <remarks>
    /// This method is non-blocking and executes the transcription request on a background thread.
    /// It is suitable for UI applications or services that require reactive, event-driven processing without blocking the main thread.
    /// Use this method when you want fine-grained control over the asynchronous execution flow through explicit callbacks.
    /// </remarks>
    procedure AsyncTranscription(const ParamProc: TProc<TAudioTranscriptionParams>;
      const Callbacks: TFunc<TAsyncAudioTranscription>);
  end;

implementation

{ TAudioTranscriptionParams }

constructor TAudioTranscriptionParams.Create;
begin
  inherited Create(True);
end;

function TAudioTranscriptionParams.FileUrl(
  const Value: string): TAudioTranscriptionParams;
begin
  if Value.StartsWith('http') then
    AddField('file_url', Value)
  else
    begin
      if not FileExists(Value) then
        raise Exception.CreateFmt('File not found: %s', [Value]);
      var AudioStream := TFileStream.Create(Value, fmOpenRead or fmShareDenyWrite);
      AudioStream.Position := 0;
      try
        {$IF RTLVersion > 35.0}
        AddStream('file', AudioStream, True, ExtractFileName(Value));
        {$ELSE}
        AddStream('file', Stream, FileName);
        {$ENDIF}
      finally
      end;
    end;
  Result := Self;
end;

function TAudioTranscriptionParams.Language(
  const Value: string): TAudioTranscriptionParams;
begin
  AddField('language', Value);
  Result := Self;
end;

function TAudioTranscriptionParams.Model(
  const Value: string): TAudioTranscriptionParams;
begin
  AddField('model', Value);
  Result := Self;
end;

function TAudioTranscriptionParams.TimestampGranularities(
  const Value: string): TAudioTranscriptionParams;
begin
  AddField('timestamp_granularities', Value);
  Result := Self;
end;

{ TAudioTranscription }

destructor TAudioTranscription.Destroy;
begin
  for var Item in FSegments do
    Item.Free;
  if Assigned(FUsage) then
    FUsage.Free;
  inherited;
end;

{ TAudioRoute }

function TAudioRoute.AsyncAwaitTranscription(
  const ParamProc: TProc<TAudioTranscriptionParams>;
  const Callbacks: TFunc<TPromiseAudioTranscription>): TPromise<TAudioTranscription>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TAudioTranscription>(
    procedure(const CallbackParams: TFunc<TAsyncAudioTranscription>)
    begin
      AsyncTranscription(ParamProc, CallbackParams);
    end,
    Callbacks);
end;

procedure TAudioRoute.AsyncTranscription(
  const ParamProc: TProc<TAudioTranscriptionParams>;
  const Callbacks: TFunc<TAsyncAudioTranscription>);
begin
  with TAsyncCallBackExec<TAsyncAudioTranscription, TAudioTranscription>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TAudioTranscription
      begin
        Result := Self.Transcription(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TAudioRoute.Transcription(
  const ParamProc: TProc<TAudioTranscriptionParams>): TAudioTranscription;
begin
  Result := API.PostForm<TAudioTranscription, TAudioTranscriptionParams>('audio/transcriptions', ParamProc);
end;

end.

unit MistralAI.Batch;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, REST.Json.Types,
  System.NetEncoding, System.Net.Mime, MistralAI.API.Params, MistralAI.API,
  MistralAI.Async.Support, MistralAI.Types, MistralAI.Async.Promise;

type
  /// <summary>
  /// Represents a class for constructing and managing query parameters to list batch jobs in the MistralAI API.
  /// </summary>
  /// <remarks>
  /// This class provides methods to define filters such as page size, model name, creation date, and batch status,
  /// allowing precise control over the listing of batch jobs.
  /// </remarks>
  TBatchJobListParams = class(TUrlParam)
  public
    /// <summary>
    /// Sets the page number for pagination in the batch job list query.
    /// </summary>
    /// <param name="Value">
    /// The page number to retrieve (e.g., 1 for the first page).
    /// </param>
    /// <returns>
    /// Returns the instance of <c>TBatchJobListParams</c> for method chaining.
    /// </returns>
    function Page(const Value: Integer): TBatchJobListParams;

    /// <summary>
    /// Sets the number of items per page for pagination in the batch job list query.
    /// </summary>
    /// <param name="Value">
    /// The number of items to retrieve per page.
    /// </param>
    /// <returns>
    /// Returns the instance of <c>TBatchJobListParams</c> for method chaining.
    /// </returns>
    function PageSize(const Value: Integer): TBatchJobListParams;

    /// <summary>
    /// Filters the batch job list by the name of the model used for processing.
    /// </summary>
    /// <param name="Value">
    /// The model name to filter batch jobs (e.g., "mistral-small-latest").
    /// </param>
    /// <returns>
    /// Returns the instance of <c>TBatchJobListParams</c> for method chaining.
    /// </returns>
    function Model(const Value: string): TBatchJobListParams;

    /// <summary>
    /// Filters the batch job list by custom metadata associated with the batch.
    /// </summary>
    /// <param name="Value">
    /// The metadata key or value to filter batch jobs.
    /// </param>
    /// <returns>
    /// Returns the instance of <c>TBatchJobListParams</c> for method chaining.
    /// </returns>
    function Metadata(const Value: string): TBatchJobListParams;

    /// <summary>
    /// Filters the batch job list to include only jobs created after the specified timestamp.
    /// </summary>
    /// <param name="Value">
    /// A string representing the timestamp (e.g., ISO 8601 format).
    /// </param>
    /// <returns>
    /// Returns the instance of <c>TBatchJobListParams</c> for method chaining.
    /// </returns>
    function CreatedAfter(const Value: string): TBatchJobListParams;

    /// <summary>
    /// Filters the batch job list to include only jobs created by the current user.
    /// </summary>
    /// <param name="Value">
    /// A boolean value indicating whether to filter jobs by the current user.
    /// </param>
    /// <returns>
    /// Returns the instance of <c>TBatchJobListParams</c> for method chaining.
    /// </returns>
    function CreatedByMe(const Value: Boolean): TBatchJobListParams;

    /// <summary>
    /// Filters the batch job list by the current status of the jobs.
    /// </summary>
    /// <param name="Value">
    /// The status of the batch jobs to filter (e.g., <c>QUEUED</c>, <c>RUNNING</c>, <c>SUCCESS</c>, etc.).
    /// </param>
    /// <returns>
    /// Returns the instance of <c>TBatchJobListParams</c> for method chaining.
    /// </returns>
    function Status(const Value: TBatchStatus): TBatchJobListParams;
  end;

  /// <summary>
  /// Represents a class for managing parameters required to create a batch job for the MistralAI API.
  /// This class, <c>TBatchJobParams</c>, extends <c>TJSONParam</c> to construct and handle JSON payloads for batch job creation.
  ///</summary>
  ///<remarks>
  /// A batch job consists of multiple API requests, each identified by a unique <c>custom_id</c>.
  /// This class simplifies the process of defining the parameters and generating the required JSON payloads for a batch job.
  ///</remarks>
  TBatchJobParams = class(TJSONParam)
  public
    /// <summary>
    /// A list of the batch input file IDs.
    /// </summary>
    function InputFiles(const Value: TArray<string>): TBatchJobParams;

    /// <summary>
    /// Currently support <c>/v1/embeddings</c>, <c>/v1/chat/completions</c>, <c>/v1/fim/completions</c>, <c>/v1/moderations</c>, <c>/v1/chat/moderations</c>.
    /// </summary>
    function Endpoint(const Value: TEndPointType): TBatchJobParams;

    /// <summary>
    /// Model used for batch job process.
    /// </summary>
    function Model(const Value: string): TBatchJobParams;

    /// <summary>
    /// Optional custom metadata for the batch.
    /// </summary>
    /// <remarks>
    /// property name*: string [ 1 ... 512 ] characters
    /// <para>
    /// additional property
    /// </para>
    /// </remarks>
    function Metadata(const Value: TJSONObject): TBatchJobParams; overload;

    /// <summary>
    /// Optional custom metadata for the batch.
    /// </summary>
    /// <remarks>
    /// property name*: string [ 1 ... 512 ] characters
    /// <para>
    /// additional property
    /// </para>
    /// </remarks>
    function Metadata(const Value: TJSONParam): TBatchJobParams; overload;

    /// <summary>
    /// Batch generation can take up to 24 hours, although it might finish earlier.
    /// </summary>
    /// <remarks>
    /// <para>
    /// - Please note that processing speeds may be adjusted based on current demand and the volume of
    /// your request. Your batch results will only be accessible once the entire batch processing is
    /// complete.
    /// </para>
    /// <para>
    /// - Users can set timeout_hours when creating a job, which specifies the number of hours after
    /// which the job should expire. It defaults to 24 hours and cannot exceed this limit at present.
    /// This means that batches will expire if processing does not complete within 24 hours. This is
    /// subject to change in the future.
    /// </para>
    /// </remarks>
    function TimeoutHours(const Value: Integer): TBatchJobParams;
  end;

  /// <summary>
  /// Represents a class for capturing error information related to batch job processing in the MistralAI API.
  /// </summary>
  /// <remarks>
  /// This class provides details about errors encountered during batch job processing, including error messages and counts.
  /// </remarks>
  TBatchJobListDataError = class
  private
    FMessage: string;
    FCount: Int64;
  public
    /// <summary>
    /// Gets or sets the error message describing the issue encountered during batch job processing.
    /// </summary>
    /// <value>
    /// A string representing the error message (e.g., "Invalid input file format").
    /// </value>
    property &Message: string read FMessage write FMessage;

    /// <summary>
    /// Gets or sets the count of occurrences for this specific error.
    /// </summary>
    /// <value>
    /// An integer representing the number of times this error was encountered.
    /// </value>
    property Count: Int64 read FCount write FCount;
  end;

  /// <summary>
  /// Represents a batch job in the MistralAI API.
  /// </summary>
  /// <remarks>
  /// A batch job contains details about the processing status, input files, model used, metadata, and
  /// the results of the batch operation.
  /// </remarks>
  TBatchJob = class(TJSONFingerprint)
  private
    FId: string;
    FObjet: string;
    [JsonNameAttribute('input_files')]
    FInputFiles: TArray<string>;
    [JsonReflectAttribute(ctString, rtString, TMetadataInterceptor)]
    FMetadata: string;
    [JsonReflectAttribute(ctString, rtString, TEndPointTypeInterceptor)]
    FEndpoint: TEndPointType;
    FModel: string;
    [JsonNameAttribute('output_file')]
    FOutputFile: string;
    [JsonNameAttribute('error_file')]
    FErrorFile: string;
    FErrors: TArray<TBatchJobListDataError>;
    [JsonReflectAttribute(ctString, rtString, TBatchStatusInterceptor)]
    FStatus: TBatchStatus;
    [JsonNameAttribute('created_at')]
    FCreatedAt: Int64;
    [JsonNameAttribute('total_requests')]
    FTotalRequests: Int64;
    [JsonNameAttribute('completed_requests')]
    FCompletedRequests: Int64;
    [JsonNameAttribute('succeeded_requests')]
    FSucceededRequests: Int64;
    [JsonNameAttribute('failed_requests')]
    FFailedRequests: Int64;
    [JsonNameAttribute('started_at')]
    FStartedAt: Int64;
    [JsonNameAttribute('completed_at')]
    FCompletedAt: Int64;
  public
    /// <summary>
    /// The unique identifier for the batch job.
    /// </summary>
    property Id: string read FId write FId;

    /// <summary>
    /// The name or description of the batch job.
    /// </summary>
    property &Objet: string read FObjet write FObjet;

    /// <summary>
    /// An array of file IDs used as input for the batch job.
    /// </summary>
    property InputFiles: TArray<string> read FInputFiles write FInputFiles;

    /// <summary>
    /// Custom metadata associated with the batch job.
    /// </summary>
    property Metadata: string read FMetadata write FMetadata;

    /// <summary>
    /// The endpoint used for the batch job (e.g., <c>/v1/chat/completions</c>).
    /// </summary>
    property Endpoint: TEndPointType read FEndpoint write FEndpoint;

    /// <summary>
    /// The model used for processing the batch job.
    /// </summary>
    property Model: string read FModel write FModel;

    /// <summary>
    /// The file ID of the output file containing the results of the batch job.
    /// </summary>
    property OutputFile: string read FOutputFile write FOutputFile;

    /// <summary>
    /// The file ID of the error file containing details of any errors during processing.
    /// </summary>
    property ErrorFile: string read FErrorFile write FErrorFile;

    /// <summary>
    /// An array of error details, including messages and counts, for the batch job.
    /// </summary>
    property Errors: TArray<TBatchJobListDataError> read FErrors write FErrors;

    /// <summary>
    /// The current status of the batch job (e.g., <c>QUEUED</c>, <c>RUNNING</c>, <c>SUCCESS</c>, <c>FAILED</c>).
    /// </summary>
    property Status: TBatchStatus read FStatus write FStatus;

    /// <summary>
    /// The timestamp (in Unix time) when the batch job was created.
    /// </summary>
    property CreatedAt: Int64 read FCreatedAt write FCreatedAt;

    /// <summary>
    /// The total number of requests in the batch job.
    /// </summary>
    property TotalRequests: Int64 read FTotalRequests write FTotalRequests;

     /// <summary>
    /// The number of requests that have been completed so far.
    /// </summary>
    property CompletedRequests: Int64 read FCompletedRequests write FCompletedRequests;

    /// <summary>
    /// The number of requests that succeeded during batch processing.
    /// </summary>
    property SucceededRequests: Int64 read FSucceededRequests write FSucceededRequests;

    /// <summary>
    /// The number of requests that failed during batch processing.
    /// </summary>
    property FailedRequests: Int64 read FFailedRequests write FFailedRequests;

    /// <summary>
    /// The timestamp (in Unix time) when the batch job started processing.
    /// </summary>
    property StartedAt: Int64 read FStartedAt write FStartedAt;

    /// <summary>
    /// The timestamp (in Unix time) when the batch job completed processing.
    /// </summary>
    property CompletedAt: Int64 read FCompletedAt write FCompletedAt;

    /// <summary>
    /// Frees the memory allocated for the batch job, including associated error details.
    /// </summary>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a collection of batch jobs in the MistralAI API.
  /// </summary>
  /// <remarks>
  /// This class contains a list of batch jobs along with metadata about the collection,
  /// such as the total number of jobs and the object type.
  /// </remarks>
  TBatchJobList = class(TJSONFingerprint)
  private
    FData: TArray<TBatchJob>;
    FObject: string;
    FTotal: Int64;
  public
    /// <summary>
    /// An array of batch jobs included in the list.
    /// </summary>
    property Data: TArray<TBatchJob> read FData write FData;

    /// <summary>
    /// The object type for the batch job list (e.g., <c>"batch_job_list"</c>).
    /// </summary>
    property &Object: string read FObject write FObject;

    /// <summary>
    /// The total number of batch jobs available in the list.
    /// </summary>
    property Total: Int64 read FTotal write FTotal;

    /// <summary>
    /// Frees the memory allocated for the batch job list, including associated batch jobs.
    /// </summary>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Asynchronous callback parameters for operations returning a single <c>TBatchJob</c>.
  /// </summary>
  /// <remarks>
  /// Used when performing asynchronous operations that return a <c>TBatchJob</c> instance.
  /// </remarks>
  TAsynBatchJob = TAsyncCallback<TBatchJob>;

  /// <summary>
  /// Defines a promise‐style callback record for asynchronous batch‐job operations.
  /// </summary>
  /// <remarks>
  /// An alias of <c>TPromiseCallBack&lt;TBatchJob&gt;</c> that provides fields
  /// for OnStart, OnSuccess, OnError, and OnCancellation handlers, and resolves
  /// with a <see cref="TBatchJob"/> instance when the operation completes.
  /// </remarks>
  TPromiseBatchJob = TPromiseCallback<TBatchJob>;

  /// <summary>
  /// Asynchronous callback parameters for operations returning a single <c>TBatchJobList</c>.
  /// </summary>
  /// <remarks>
  /// Used when performing asynchronous operations that return a <c>TBatchJobList</c> instance.
  /// </remarks>
  TAsynBatchJobList = TAsyncCallback<TBatchJobList>;

  /// <summary>
  /// Defines a promise‐style callback record for asynchronous batch‐job‐list operations.
  /// </summary>
  /// <remarks>
  /// An alias of <c>TPromiseCallBack&lt;TBatchJobList&gt;</c> that provides fields
  /// for OnStart, OnSuccess, OnError, and OnCancellation handlers, and resolves
  /// with a <see cref="TBatchJobList"/> instance when the operation completes.
  /// </remarks>
  TPromiseBatchJobList = TPromiseCallback<TBatchJobList>;

  /// <summary>
  /// Provides methods for interacting with the batch job routes in the MistralAI API.
  /// </summary>
  /// <remarks>
  /// This class enables the creation, retrieval, listing, and cancellation of batch jobs.
  /// It also supports both synchronous and asynchronous operations.
  /// </remarks>
  TBatchRoute = class(TMistralAIAPIRoute)
    /// <summary>
    /// Asynchronously creates a new batch job using the supplied parameter procedure
    /// and returns a promise that resolves to the resulting <see cref="TBatchJob"/>.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure that configures the <see cref="TBatchJobParams"/> instance with
    /// the desired input files, model, endpoint, metadata, and timeout settings.
    /// </param>
    /// <param name="Callbacks">
    /// An optional function that returns a <see cref="TPromiseBatchJob"/> callback record
    /// (containing OnStart, OnSuccess, OnError, etc.). Pass <c>nil</c> to omit custom Callbacks.
    /// </param>
    /// <returns>
    /// A <see cref="TPromise&lt;TBatchJob&gt;"/> that completes with the created batch job
    /// once the asynchronous operation finishes successfully.
    /// </returns>
    function AsyncAwaitCreateJob(const ParamProc: TProc<TBatchJobParams>;
      const Callbacks: TFunc<TPromiseBatchJob> = nil): TPromise<TBatchJob>;

    /// <summary>
    /// Asynchronously retrieves all batch jobs and returns a promise that resolves
    /// to a <see cref="TBatchJobList"/> containing the collection of jobs.
    /// </summary>
    /// <param name="Callbacks">
    /// An optional function that returns a <see cref="TPromiseBatchJobList"/> callback record
    /// (containing OnStart, OnSuccess, OnError, etc.). Pass <c>nil</c> to use default handling.
    /// </param>
    /// <returns>
    /// A <see cref="TPromise&lt;TBatchJobList&gt;"/> that completes with the batch job list
    /// once the asynchro
    function AsyncAwaitList(
      const Callbacks: TFunc<TPromiseBatchJobList> = nil): TPromise<TBatchJobList>; overload;

    /// <summary>
    /// Asynchronously retrieves a filtered list of batch jobs according to the specified parameters
    /// and returns a promise that resolves to the resulting <see cref="TBatchJobList"/>.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure that configures the <see cref="TBatchJobListParams"/> instance with filters
    /// such as page, page size, model, metadata, status, creation date, and ownership.
    /// </param>
    /// <param name="Callbacks">
    /// An optional function that returns a <see cref="TPromiseBatchJobList"/> callback record
    /// (including OnStart, OnSuccess, OnError, etc.). Pass <c>nil</c> to omit custom Callbacks.
    /// </param>
    /// <returns>
    /// A <see cref="TPromise&lt;TBatchJobList&gt;"/> that completes with the filtered batch job list
    /// once the asynchronous operation finishes successfully.
    /// </returns>
    function AsyncAwaitList(const ParamProc: TProc<TBatchJobListParams>;
      const Callbacks: TFunc<TPromiseBatchJobList> = nil): TPromise<TBatchJobList>; overload;

    /// <summary>
    /// Asynchronously retrieves the details of a specific batch job by its identifier
    /// and returns a promise that resolves to the corresponding <see cref="TBatchJob"/>.
    /// </summary>
    /// <param name="BatchId">
    /// The unique identifier of the batch job to retrieve.
    /// </param>
    /// <param name="Callbacks">
    /// An optional function that returns a <see cref="TPromiseBatchJob"/> callback record
    /// (including OnStart, OnSuccess, OnError, etc.). Pass <c>nil</c> to use default handling.
    /// </param>
    /// <returns>
    /// A <see cref="TPromise&lt;TBatchJob&gt;"/> that completes with the requested batch job
    /// once the asynchronous operation finishes successfully.
    /// </returns>
    function AsyncAwaitRetrieve(const BatchId: string;
      const Callbacks: TFunc<TPromiseBatchJob> = nil): TPromise<TBatchJob>;

    /// <summary>
    /// Asynchronously cancels a batch job identified by the given ID
    /// and returns a promise that resolves to the updated <see cref="TBatchJob"/>.
    /// </summary>
    /// <param name="BatchId">
    /// The unique identifier of the batch job to cancel.
    /// </param>
    /// <param name="Callbacks">
    /// An optional function that returns a <see cref="TPromiseBatchJob"/> callback record
    /// (including OnStart, OnSuccess, OnError, etc.). Pass <c>nil</c> to use default handling.
    /// </param>
    /// <returns>
    /// A <see cref="TPromise&lt;TBatchJob&gt;"/> that completes with the canceled batch job
    /// once the asynchronous cancel operation finishes successfully.
    /// </returns>
    function AsyncAwaitCancel(const BatchId: string;
      const Callbacks: TFunc<TPromiseBatchJob> = nil): TPromise<TBatchJob>;

    /// <summary>
    /// Asynchronously creates a new batch job.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the parameters for the batch job using a <c>TBatchJobParams</c> instance.
    /// </param>
    /// <param name="Callbacks">
    /// A function to handle the asynchronous callback, returning a <c>TAsynBatchJob</c>.
    /// </param>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// // var MistralAI := TMistralAIFactory.CreateInstance(BaererKey);
    ///
    /// MistralAI.AsyncCreateJob(
    ///   procedure (Params: TBatchJobParams)
    ///   begin
    ///     // Define parameters for the batch job
    ///   end,
    ///
    ///   function: TAsynBatchJob
    ///   begin
    ///     Result.Sender := my_display_component;
    ///
    ///     Result.OnStart :=
    ///       procedure (Sender: TObject)
    ///       begin
    ///         // Handle the start
    ///       end;
    ///
    ///     Result.OnSuccess :=
    ///       procedure (Sender: TObject; Value: TBatchJob)
    ///       begin
    ///         // Handle the success result
    ///       end;
    ///
    ///     Result.OnError :=
    ///       procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle errors
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncCreateJob(const ParamProc: TProc<TBatchJobParams>;
      const Callbacks: TFunc<TAsynBatchJob>);

    /// <summary>
    /// Asynchronously retrieves a list of batch jobs.
    /// </summary>
    /// <param name="Callbacks">
    /// A function to handle the asynchronous callback, returning a <c>TAsynBatchJobList</c>.
    /// </param>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// // var MistralAI := TMistralAIFactory.CreateInstance(BaererKey);
    ///
    /// MistralAI.AsyncList(
    ///   function: TAsynBatchJobList
    ///   begin
    ///     Result.Sender := my_display_component;
    ///
    ///     Result.OnStart :=
    ///       procedure (Sender: TObject)
    ///       begin
    ///         // Handle the start
    ///       end;
    ///
    ///     Result.OnSuccess :=
    ///       procedure (Sender: TObject; Value: TBatchJobList)
    ///       begin
    ///         // Handle the successful retrieval
    ///       end;
    ///
    ///     Result.OnError :=
    ///       procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle errors
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncList(const Callbacks: TFunc<TAsynBatchJobList>); overload;

    /// <summary>
    /// Asynchronously retrieves a filtered list of batch jobs.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the filter parameters using a <c>TBatchJobListParams</c> instance.
    /// </param>
    /// <param name="Callbacks">
    /// A function to handle the asynchronous callback, returning a <c>TAsynBatchJobList</c>.
    /// </param>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// // var MistralAI := TMistralAIFactory.CreateInstance(BaererKey);
    ///
    /// MistralAI.AsyncList(
    ///   procedure (Params: TBatchJobListParams)
    ///   begin
    ///     // Define parameters for filtering batch jobs
    ///   end,
    ///
    ///   function: TAsynBatchJobList
    ///   begin
    ///     Result.Sender := my_display_component;
    ///
    ///     Result.OnStart :=
    ///       procedure (Sender: TObject)
    ///       begin
    ///         // Handle the start
    ///       end;
    ///
    ///     Result.OnSuccess :=
    ///       procedure (Sender: TObject; Value: TBatchJobList)
    ///       begin
    ///         // Handle the successful retrieval
    ///       end;
    ///
    ///     Result.OnError :=
    ///       procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle errors
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncList(const ParamProc: TProc<TBatchJobListParams>;
      const Callbacks: TFunc<TAsynBatchJobList>); overload;

    /// <summary>
    /// Asynchronously retrieves the details of a specific batch job.
    /// </summary>
    /// <param name="BatchId">
    /// The unique identifier of the batch job to retrieve.
    /// </param>
    /// <param name="Callbacks">
    /// A function to handle the asynchronous callback, returning a <c>TAsynBatchJob</c>.
    /// </param>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// // var MistralAI := TMistralAIFactory.CreateInstance(BaererKey);
    ///
    /// MistralAI.AsyncRetrieve('batch-id-123',
    ///   function: TAsynBatchJob
    ///   begin
    ///     Result.Sender := my_display_component;
    ///
    ///     Result.OnStart :=
    ///       procedure (Sender: TObject)
    ///       begin
    ///         // Handle the start
    ///       end;
    ///
    ///     Result.OnSuccess :=
    ///       procedure (Sender: TObject; Value: TBatchJob)
    ///       begin
    ///         // Handle the successful retrieval of the batch job
    ///       end;
    ///
    ///     Result.OnError :=
    ///       procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle errors
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncRetrieve(const BatchId: string;
      const Callbacks: TFunc<TAsynBatchJob>);

    /// <summary>
    /// Asynchronously cancels a specific batch job.
    /// </summary>
    /// <param name="BatchId">
    /// The unique identifier of the batch job to cancel.
    /// </param>
    /// <param name="Callbacks">
    /// A function to handle the asynchronous callback, returning a <c>TAsynBatchJob</c>.
    /// </param>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// // var MistralAI := TMistralAIFactory.CreateInstance(BaererKey);
    ///
    /// MistralAI.AsyncCancel('batch-id-456',
    ///   function: TAsynBatchJob
    ///   begin
    ///     Result.Sender := my_display_component;
    ///
    ///     Result.OnStart :=
    ///       procedure (Sender: TObject)
    ///       begin
    ///         // Handle the start
    ///       end;
    ///
    ///     Result.OnSuccess :=
    ///       procedure (Sender: TObject; Value: TBatchJob)
    ///       begin
    ///         // Handle the successful cancellation of the batch job
    ///       end;
    ///
    ///     Result.OnError :=
    ///       procedure (Sender: TObject; Error: string)
    ///       begin
    ///         // Handle errors
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncCancel(const BatchId: string; const Callbacks: TFunc<TAsynBatchJob>);

    /// <summary>
    /// Creates a new batch job.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the parameters for the batch job using a <c>TBatchJobParams</c> instance.
    /// </param>
    /// <returns>
    /// Returns the created <c>TBatchJob</c> instance.
    /// </returns>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// // var MistralAI := TMistralAIFactory.CreateInstance(BaererKey);
    ///
    /// var Value := MistralAI.Batch.CreateJob(
    ///   procedure (Params: TBatchJobParams)
    ///   begin
    ///     // Define parameters for the batch job
    ///   end);
    /// try
    ///   // Do something with the created batch job
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function CreateJob(const ParamProc: TProc<TBatchJobParams>): TBatchJob;

    /// <summary>
    /// Retrieves a list of batch jobs.
    /// </summary>
    /// <returns>
    /// Returns a <c>TBatchJobList</c> containing all available batch jobs.
    /// </returns>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// // var MistralAI := TMistralAIFactory.CreateInstance(BaererKey);
    ///
    /// var Value := MistralAI.Batch.List;
    /// try
    ///   // Do something
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function List: TBatchJobList; overload;

    /// <summary>
    /// Retrieves a filtered list of batch jobs.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the filter parameters using a <c>TBatchJobListParams</c> instance.
    /// </param>
    /// <returns>
    /// Returns a <c>TBatchJobList</c> containing the filtered batch jobs.
    /// </returns>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// // var MistralAI := TMistralAIFactory.CreateInstance(BaererKey);
    ///
    /// var Value := MistralAI.Batch.List(
    ///   procedure (Params: TBatchJobListParams)
    ///   begin
    ///     // Define parameters for the batch job
    ///   end);
    /// try
    ///   // Do something with the created batch job
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function List(const ParamProc: TProc<TBatchJobListParams>): TBatchJobList; overload;

    /// <summary>
    /// Retrieves the details of a specific batch job.
    /// </summary>
    /// <param name="BatchId">
    /// The unique identifier of the batch job to retrieve.
    /// </param>
    /// <returns>
    /// Returns the <c>TBatchJob</c> instance corresponding to the given batch ID.
    /// </returns>
    /// <remarks>
     /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// // var MistralAI := TMistralAIFactory.CreateInstance(BaererKey);
    ///
    /// var Job := MistralAI.Batch.Retrieve('batch-id-456');
    /// try
    ///   // Work with the retrieved batch job
    /// finally
    ///   Job.Free;
    /// end;
    /// </code>
    /// </remarks>
    function Retrieve(const BatchId: string): TBatchJob;

    /// <summary>
    /// Cancels a specific batch job.
    /// </summary>
    /// <param name="BatchId">
    /// The unique identifier of the batch job to cancel.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TBatchJob</c> instance after cancellation.
    /// </returns>
    /// <remarks>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// // var MistralAI := TMistralAIFactory.CreateInstance(BaererKey);
    ///
    /// var CanceledJob := MistralAI.Batch.Cancel('batch-id-789');
    /// try
    ///   // Handle the cancellation result
    /// finally
    ///   CanceledJob.Free;
    /// end;
    /// </code>
    /// </remarks>
    function Cancel(const BatchId: string): TBatchJob;
  end;

implementation

{ TBatchJobListParams }

function TBatchJobListParams.CreatedAfter(
  const Value: string): TBatchJobListParams;
begin
  Result := TBatchJobListParams(Add('created_after', Value));
end;

function TBatchJobListParams.CreatedByMe(
  const Value: Boolean): TBatchJobListParams;
begin
  Result := TBatchJobListParams(Add('created_by_me', Value));
end;

function TBatchJobListParams.Metadata(const Value: string): TBatchJobListParams;
begin
  Result := TBatchJobListParams(Add('metadata', Value));
end;

function TBatchJobListParams.Model(const Value: string): TBatchJobListParams;
begin
  Result := TBatchJobListParams(Add('model', Value));
end;

function TBatchJobListParams.Page(const Value: Integer): TBatchJobListParams;
begin
  Result := TBatchJobListParams(Add('page', Value));
end;

function TBatchJobListParams.PageSize(
  const Value: Integer): TBatchJobListParams;
begin
  Result := TBatchJobListParams(Add('page_size', Value));
end;

function TBatchJobListParams.Status(
  const Value: TBatchStatus): TBatchJobListParams;
begin
  Result := TBatchJobListParams(Add('status', Value.ToString));
end;

{ TBatchJob }

destructor TBatchJob.Destroy;
begin
  for var Item in FErrors do
    Item.Free;
  inherited;
end;

{ TBatchJobList }

destructor TBatchJobList.Destroy;
begin
  for var Item in FData do
    Item.Free;
  inherited;
end;

{ TBatchRoute }

function TBatchRoute.AsyncAwaitCancel(const BatchId: string;
  const Callbacks: TFunc<TPromiseBatchJob>): TPromise<TBatchJob>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TBatchJob>(
    procedure(const CallbackParams: TFunc<TAsynBatchJob>)
    begin
      AsyncCancel(BatchId, CallbackParams);
    end,
    Callbacks);
end;

function TBatchRoute.AsyncAwaitCreateJob(
  const ParamProc: TProc<TBatchJobParams>;
  const Callbacks: TFunc<TPromiseBatchJob>): TPromise<TBatchJob>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TBatchJob>(
    procedure(const CallbackParams: TFunc<TAsynBatchJob>)
    begin
      AsyncCreateJob(ParamProc, CallbackParams);
    end,
    Callbacks);
end;

function TBatchRoute.AsyncAwaitList(
  const Callbacks: TFunc<TPromiseBatchJobList>): TPromise<TBatchJobList>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TBatchJobList>(
    procedure(const CallbackParams: TFunc<TAsynBatchJobList>)
    begin
      AsyncList(CallbackParams);
    end,
    Callbacks);
end;

function TBatchRoute.AsyncAwaitList(const ParamProc: TProc<TBatchJobListParams>;
  const Callbacks: TFunc<TPromiseBatchJobList>): TPromise<TBatchJobList>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TBatchJobList>(
    procedure(const CallbackParams: TFunc<TAsynBatchJobList>)
    begin
      AsyncList(ParamProc, CallbackParams);
    end,
    Callbacks);
end;

function TBatchRoute.AsyncAwaitRetrieve(const BatchId: string;
  const Callbacks: TFunc<TPromiseBatchJob>): TPromise<TBatchJob>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TBatchJob>(
    procedure(const CallbackParams: TFunc<TAsynBatchJob>)
    begin
      AsyncRetrieve(BatchId, CallbackParams);
    end,
    Callbacks);
end;

procedure TBatchRoute.AsyncCancel(const BatchId: string;
  const Callbacks: TFunc<TAsynBatchJob>);
begin
  with TAsyncCallBackExec<TAsynBatchJob, TBatchJob>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TBatchJob
      begin
        Result := Self.Cancel(BatchId);
      end);
  finally
    Free;
  end;
end;

procedure TBatchRoute.AsyncCreateJob(const ParamProc: TProc<TBatchJobParams>;
  const Callbacks: TFunc<TAsynBatchJob>);
begin
  with TAsyncCallBackExec<TAsynBatchJob, TBatchJob>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TBatchJob
      begin
        Result := Self.CreateJob(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TBatchRoute.AsyncList(const ParamProc: TProc<TBatchJobListParams>;
  const Callbacks: TFunc<TAsynBatchJobList>);
begin
  with TAsyncCallBackExec<TAsynBatchJobList, TBatchJobList>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TBatchJobList
      begin
        Result := Self.List(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TBatchRoute.AsyncList(const Callbacks: TFunc<TAsynBatchJobList>);
begin
  with TAsyncCallBackExec<TAsynBatchJobList, TBatchJobList>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TBatchJobList
      begin
        Result := Self.List;
      end);
  finally
    Free;
  end;
end;

procedure TBatchRoute.AsyncRetrieve(const BatchId: string;
  const Callbacks: TFunc<TAsynBatchJob>);
begin
  with TAsyncCallBackExec<TAsynBatchJob, TBatchJob>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TBatchJob
      begin
        Result := Self.Retrieve(BatchId);
      end);
  finally
    Free;
  end;
end;

function TBatchRoute.Cancel(const BatchId: string): TBatchJob;
begin
  Result := API.Post<TBatchJob>(Format('batch/jobs/%s/cancel', [BatchId]));
end;

function TBatchRoute.CreateJob(const ParamProc: TProc<TBatchJobParams>): TBatchJob;
begin
  Result := API.Post<TBatchJob, TBatchJobParams>('batch/jobs', ParamProc);
end;

function TBatchRoute.List: TBatchJobList;
begin
  Result := API.Get<TBatchJobList>('batch/jobs');
end;

function TBatchRoute.List(const ParamProc: TProc<TBatchJobListParams>): TBatchJobList;
begin
  Result := API.Get<TBatchJobList, TBatchJobListParams>('batch/jobs', ParamProc);
end;

function TBatchRoute.Retrieve(const BatchId: string): TBatchJob;
begin
  Result := API.Get<TBatchJob>(Format('batch/jobs/%s', [BatchId]));
end;

{ TBatchJobParams }

function TBatchJobParams.Endpoint(const Value: TEndPointType): TBatchJobParams;
begin
  Result := TBatchJobParams(Add('endpoint', Value.ToString));
end;

function TBatchJobParams.InputFiles(
  const Value: TArray<string>): TBatchJobParams;
begin
  Result := TBatchJobParams(Add('input_files', Value));
end;

function TBatchJobParams.Metadata(const Value: TJSONObject): TBatchJobParams;
begin
  Result := TBatchJobParams(Add('metadata', Value));
end;

function TBatchJobParams.Metadata(const Value: TJSONParam): TBatchJobParams;
begin
  Result := TBatchJobParams(Add('metadata', Value.Detach));
end;

function TBatchJobParams.Model(const Value: string): TBatchJobParams;
begin
  Result := TBatchJobParams(Add('model', Value));
end;

function TBatchJobParams.TimeoutHours(const Value: Integer): TBatchJobParams;
begin
  Result := TBatchJobParams(Add('timeout_hours', Value));
end;

end.

unit MistralAI.Chat;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, System.Threading,
  REST.Json.Types, System.NetEncoding, System.Net.Mime, MistralAI.API.Params,
  MistralAI.API, MistralAI.Functions.Core, MistralAI.Functions.Tools,
  MistralAI.Async.Support, MistralAI.Async.Params, MistralAI.Types, MistralAI.Schema,
  MistralAI.Async.Promise, MistralAI.API.Normalizer, MistralAI.Async.Parallel;

type
  /// <summary>
  /// Represents a message payload that includes an image, identified by a URL or a base-64 encoded string.
  /// </summary>
  /// <remarks>
  /// This class is used to encapsulate details of an image message, including its source (URL or base-64 string)
  /// and additional descriptive information. It extends <c>TJSONParam</c> for JSON serialization and integration with APIs.
  /// </remarks>
  /// <example>
  /// This class can be utilized to construct structured image messages for communication in chat systems.
  /// </example>
  TMessageImageURL = class(TJSONParam)
  public
    /// <summary>
    /// Url or base-64 string
    /// </summary>
    function Url(const Value: string): TMessageImageURL;

    /// <summary>
    /// Detail string
    /// </summary>
    function Detail(const Value: string): TMessageImageURL;
  end;

  TDocumentUrlParams = class(TJSONParam)
    function &Type(const Value: string = 'document_url'): TDocumentUrlParams;

    function DocumentUrl(const Value: string): TDocumentUrlParams;

    class function New: TDocumentUrlParams;
  end;

  /// <summary>
  /// Represents the content of a message, which can be either text or an image URL.
  /// </summary>
  /// <remarks>
  /// This class is used to define the structure and type of content within a message,
  /// such as textual data or image references. It extends <c>TJSONParam</c> for
  /// seamless JSON serialization and integration with APIs.
  /// </remarks>
  TMessageContent = class(TJSONParam)
  public
    /// <summary>
    /// Type of the content: text or image_url
    /// </summary>
    function &Type(const Value: TContentType): TMessageContent;

    /// <summary>
    /// Text when type is text
    /// </summary>
    function Text(const Value: string): TMessageContent;

    /// <summary>
    /// Url or base-64 string when type is image_url
    /// </summary>
    function ImageUrl(const Url: string): TMessageContent; overload;

    /// <summary>
    /// Url or base-64 string when type is image_url
    /// </summary>
    function ImageUrl(const Url: string; const Detail: string): TMessageContent; overload;

    function InputAudio(const Url: string): TMessageContent;
  end;

  /// <summary>
  /// Represents the metadata and arguments of a function invoked during a chat interaction.
  /// </summary>
  /// <remarks>
  /// This class is used to define the structure of function calls, including the function's name and its associated arguments.
  /// It is designed to be serialized into JSON format for integration with APIs or other systems requiring structured function data.
  /// </remarks>
  TFunctionCalled = class(TJSONParam)
  public
    /// <summary>
    /// The name of the function called
    /// </summary>
    function Name(const Value: string): TFunctionCalled;

    /// <summary>
    /// The arguments returned by the function called
    /// </summary>
    function Arguments(const Value: string): TFunctionCalled;
  end;

  /// <summary>
  /// Represents a tool call configuration used in chat-based operations.
  /// </summary>
  /// <remarks>
  /// This class is designed to define and manage tool calls within chat contexts, including
  /// their type, identifier, and associated functions. It integrates with <c>TJSONParam</c>
  /// for seamless serialization and API interactions.
  /// </remarks>
  TToolCalls = class(TJSONParam)
  public
    /// <summary>
    /// Tool calls id
    /// </summary>
    function Id(const Value: string): TToolCalls;

    /// <summary>
    /// Tool calls type: Default: "function"
    /// </summary>
    function &Type(const Value: TToolType = TToolType.function): TToolCalls;

    /// <summary>
    /// Represents the object function called
    /// </summary>
    function Func(const Name: string; Arguments: string): TToolCalls;

    /// <summary>
    /// index default 0
    /// </summary>
    function Index(const Value: Integer): TToolCalls;

    /// <summary>
    /// Create a new <c>TtoolCalls</c> instance
    /// </summary>
    class function New(Id, Name, Arguments: string): TToolCalls; overload;

    /// <summary>
    /// Create a new <c>TtoolCalls</c> instance
    /// </summary>
    class function New(Name, Arguments: string): TToolCalls; overload;

    /// <summary>
    /// Create a new <c>TtoolCalls</c> instance
    /// </summary>
    class function New: TToolCalls; overload;
  end;

  /// <summary>
  /// Represents the payload structure for a chat message in the context of a conversation.
  /// </summary>
  /// <remarks>
  /// This class encapsulates the essential elements of a chat message, including its role, content,
  /// and associated metadata. It extends <c>TJSONParam</c>, enabling seamless integration with JSON-based
  /// APIs for chat functionalities. This class is a foundational building block for managing the flow of
  /// conversations between users, systems, and assistants.
  /// </remarks>
  TChatMessagePayload = class(TJSONParam)
  public
    /// <summary>
    /// Gets or sets the role of the message.
    /// </summary>
    /// <remarks>
    /// The <c>Role</c> property determines who is sending the message. It can be a "user" (representing the end user), an "assistant" (representing an AI or bot),
    /// or "system" (representing system-level messages). This property is essential for contextualizing the content of the message within the chat.
    /// </remarks>
    function Role(const Value: TMessageRole): TChatMessagePayload;

    /// <summary>
    /// Gets or sets the content of the message.
    /// </summary>
    /// <remarks>
    /// The <c>Content</c> property contains the actual message text. This is a required field and cannot be empty, as it represents the core information being exchanged
    /// in the chat, whether it's from the user, the assistant, or the system.
    /// </remarks>
    function Content(const Value: string): TChatMessagePayload; overload;

    /// <summary>
    /// Gets or sets the content of the message.
    /// </summary>
    /// <remarks>
    /// The <c>Content</c> property contains the actual message text. This is a required field and cannot be empty, as it represents the core information being exchanged
    /// in the chat, whether it's from the user, the assistant, or the system.
    /// </remarks>
    function Content(const Value: TArray<string>): TChatMessagePayload; overload;

    /// <summary>
    /// Gets or sets the content of the message.
    /// </summary>
    /// <remarks>
    /// The <c>Content</c> property contains the actual message text. This is a required field and cannot be empty, as it represents the core information being exchanged
    /// in the chat, whether it's from the user, the assistant, or the system.
    /// </remarks>
    function Content(const Kind: TContentType; const Value: string; const Detail: string = ''): TChatMessagePayload; overload;

    /// <summary>
    /// Gets or sets the content of the message.
    /// </summary>
    /// <remarks>
    /// The <c>Content</c> property contains the actual message text. This is a required field and cannot be empty, as it represents the core information being exchanged
    /// in the chat, whether it's from the user, the assistant, or the system.
    /// </remarks>
    function Content(const Value: TJSONArray): TChatMessagePayload; overload;

    function Content(const Value: string; const Url: TDocumentUrlParams): TChatMessagePayload; overload;

    /// <summary>
    /// Set prefix value
    /// </summary>
    function Prefix(const Value: Boolean): TChatMessagePayload;

    /// <summary>
    /// Set a tool_calls with an array of functions
    /// </summary>
    function ToolCalls(const Value: TArray<TToolCalls>): TChatMessagePayload; overload;

    /// <summary>
    /// Creates a new chat message payload with the role of the assistant.
    /// </summary>
    /// <param name="Value">
    /// The content of the message that the assistant is sending.
    /// </param>
    /// <param name="Prefix">
    /// Use prefix or no.
    /// </param>
    /// <returns>
    /// A <c>TChatMessagePayload</c> instance with the role set to "assistant" and the provided content.
    /// </returns>
    /// <remarks>
    /// This method is a convenience for creating assistant messages. Use this method when the assistant needs to respond to the user or system.
    /// </remarks>
    class function Assistant(const Value: string; const Prefix: Boolean = False): TChatMessagePayload; overload;

    /// <summary>
    /// Creates a new chat message payload with the role of the assistant and includes associated vision sources.
    /// </summary>
    /// <param name="Value">
    /// The content of the message that the user is sending.
    /// </param>
    /// <param name="Url">
    /// An array of strings representing vision sources.
    /// </param>
    /// <returns>
    /// A <c>TChatMessagePayload</c> instance with the role set to "user", the provided content, and the specified vision sources.
    /// </returns>
    /// <remarks>
    /// This method is used to create messages from the user's perspective that include both text content and optional vision sources.
    /// The vision sources can be URLs or Base64-encoded images, and they are used to enhance the message with visual information.
    /// </remarks>
    class function Assistant(const Value: string; const Url: TArray<string>; const Prefix: Boolean = False): TChatMessagePayload; overload;

    /// <summary>
    /// Creates a new chat message payload with the role of the assistant and includes tool calls.
    /// </summary>
    /// <param name="Value">
    /// The content of the message that the user is sending.
    /// </param>
    /// <param name="Func">
    /// An array of strings representing tool calls sources.
    /// </param>
    /// <returns>
    /// A <c>TChatMessagePayload</c> instance with the role set to "user", the provided content, and the specified vision sources.
    /// </returns>
    /// <remarks>
    /// This method is used to create messages from the user's perspective that include both text content and optional vision sources.
    /// The vision sources can be URLs or Base64-encoded images, and they are used to enhance the message with visual information.
    /// </remarks>
    class function Assistant(const Value: string; const Func: TArray<TToolCalls>; const Prefix: Boolean = False): TChatMessagePayload; overload;

    /// <summary>
    /// Creates a new chat message payload with the role of the assistant and includes associated vision sources and tool calls.
    /// </summary>
    /// <param name="Value">
    /// The content of the message that the user is sending.
    /// </param>
    /// <param name="Url">
    /// An array of strings representing vision sources.
    /// </param>
    /// </param>
    /// <param name="Func">
    /// An array of strings representing tool calls sources.
    /// </param>
    /// <returns>
    /// A <c>TChatMessagePayload</c> instance with the role set to "user", the provided content, and the specified vision sources.
    /// </returns>
    /// <remarks>
    /// This method is used to create messages from the user's perspective that include both text content and optional vision sources.
    /// The vision sources can be URLs or Base64-encoded images, and they are used to enhance the message with visual information.
    /// </remarks>
    class function Assistant(const Value: string; const Url: TArray<string>;
      const Func: TArray<TToolCalls>; const Prefix: Boolean = False): TChatMessagePayload; overload;

    /// <summary>
    /// Creates a new chat message payload with the role of the system.
    /// </summary>
    /// <param name="Value">
    /// The content of the system message.
    /// </param>
    /// <returns>
    /// A <c>TChatMessagePayload</c> instance with the role set to "system" and the provided content.
    /// </returns>
    /// <remarks>
    /// This method is used to create system-level messages, which may be used for notifications, warnings, or other system-related interactions.
    /// </remarks>
    class function System(const Value: string): TChatMessagePayload; overload;

    /// <summary>
    /// Creates a new chat message payload with the role of the system.
    /// </summary>
    /// <param name="Value">
    /// The content of the system message.
    /// </param>
    /// <returns>
    /// A <c>TChatMessagePayload</c> instance with the role set to "system" and the provided content.
    /// </returns>
    /// <remarks>
    /// This method is used to create system-level messages, which may be used for notifications, warnings, or other system-related interactions.
    /// </remarks>
    class function System(const Value: TArray<string>): TChatMessagePayload; overload;

    /// <summary>
    /// Creates a new chat message payload with the role of the user.
    /// </summary>
    /// <param name="Value">
    /// The content of the message that the user is sending.
    /// </param>
    /// <returns>
    /// A <c>TChatMessagePayload</c> instance with the role set to "user" and the provided content.
    /// </returns>
    /// <remarks>
    /// This method is used to create messages from the user's perspective, typically representing inputs or queries in the conversation.
    /// </remarks>
    class function User(const Value: string): TChatMessagePayload; overload;

    /// <summary>
    /// Creates a new chat message payload with the role of the user and includes associated vision sources.
    /// </summary>
    /// <param name="Value">
    /// The content of the message that the user is sending.
    /// </param>
    /// <param name="Url">
    /// An array of strings representing vision sources.
    /// </param>
    /// <returns>
    /// A <c>TChatMessagePayload</c> instance with the role set to "user", the provided content, and the specified vision sources.
    /// </returns>
    /// <remarks>
    /// This method is used to create messages from the user's perspective that include both text content and optional vision sources.
    /// The vision sources can be URLs or Base64-encoded images, and they are used to enhance the message with visual information.
    /// </remarks>
    class function User(const Value: string; const Url: TArray<string>): TChatMessagePayload; overload;

    class function User(const Value: string; const Url: string): TChatMessagePayload; overload;

    class function User(const Value: string; const Url: TDocumentUrlParams): TChatMessagePayload; overload;
  end;

  /// <summary>
  /// Represents the payload structure for a chat message in the context of a conversation.
  /// </summary>
  /// <remarks>
  /// This class encapsulates the essential elements of a chat message, including its role, content,
  /// and associated metadata. It extends <c>TJSONParam</c>, enabling seamless integration with JSON-based
  /// APIs for chat functionalities. This class is a foundational building block for managing the flow of
  /// conversations between users, systems, and assistants.
  /// </remarks>
  PayLoad = TChatMessagePayload;

  /// <summary>
  /// The <c>TChatParams</c> class represents the set of parameters used to configure a chat interaction with an AI model.
  /// </summary>
  /// <remarks>
  /// This class allows you to define various settings that control how the model behaves, including which model to use, how many tokens to generate,
  /// what kind of messages to send, and how the model should handle its output. By using this class, you can fine-tune the AI's behavior and response format
  /// based on your application's specific needs.
  /// <para>
  /// It inherits from <c>TJSONParam</c>, which provides methods for handling and serializing the parameters as JSON, allowing seamless integration
  /// with JSON-based APIs.
  /// </para>
  /// <code>
  /// var
  ///   Params: TChatParams;
  /// begin
  ///   Params := TChatParams.Create
  ///     .Model('my_model')
  ///     .MaxTokens(100)
  ///     .Messages([TChatMessagePayload.User('Hello!')])
  ///     .ResponseFormat('json_object')
  ///     .Temperature(0.7)
  ///     .TopP(1)
  ///     .SafePrompt(True);
  /// end;
  /// </code>
  /// This example shows how to instantiate and configure a <c>TChatParams</c> object for interacting with an AI model.
  /// </remarks>
  TChatParams = class(TJSONParam)
    /// <summary>
    /// Specifies the identifier of the model to use.
    /// Currently compatible with "mistral-tiny" or "mistral-large-latest".
    /// </summary>
    /// <param name="Value">
    /// The model ID to be used for the completion.
    /// Ensure that the specified model is supported and correctly spelled.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// This parameter is required and determines which model will process the request.
    /// </remarks>
    function Model(const Value: string): TChatParams;

    /// <summary>
    /// Sets the maximum number of tokens to generate in the completion.
    /// The total token count of your prompt plus <c>max_tokens</c> cannot exceed the model's context length.
    /// </summary>
    /// <param name="Value">
    /// The maximum number of tokens to generate.
    /// Choose an appropriate value based on your prompt length to avoid exceeding the model's limit.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function MaxTokens(const Value: Integer): TChatParams;

    /// <summary>
    /// Provides the prompt(s) for the model to generate completions from, structured as a list of messages with roles (user, assistant, system) and content.
    /// </summary>
    /// <param name="Value">An array of <c>TChatMessagePayload</c> representing the messages in the conversation.</param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// The first message should have either a "user" or "system" role to initiate the conversation properly.
    /// </remarks>
    function Messages(const Value: TArray<TChatMessagePayload>): TChatParams;

    /// <summary>
    /// Specifies the format in which the model should return the response. This can include formats like JSON or plain text.
    /// </summary>
    /// <param name="Value">The <c>TResponseFormatParams</c> value.</param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// If not specified, the default value is <c>{ "type": "text" }</c>. When using JSON mode, it's necessary to instruct the model to produce JSON explicitly through the system or user messages.
    /// </remarks>
    function ResponseFormat(const Value: TResponseFormatParams): TChatParams; overload;

    /// <summary>
    /// Specifies the format in which the model should return the response. This can include formats like JSON or plain text.
    /// </summary>
    /// <param name="Value">The string value.</param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// If not specified, the default value is <c>{ "type": "text" }</c>. When using JSON mode, it's necessary to instruct the model to produce JSON explicitly through the system or user messages.
    /// </remarks>
    function ResponseFormat(const Value: string): TChatParams; overload;

    /// <summary>
    /// Specifies whether to stream back partial progress as server-sent events (SSE).
    /// If <c>true</c>, tokens are sent as they become available.
    /// If <c>false</c>, the server will hold the request open until timeout or completion.
    /// </summary>
    /// <param name="Value">
    /// A boolean value indicating whether to enable streaming. Default is <c>true</c>, meaning streaming is enabled by default.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function Stream(const Value: Boolean = True): TChatParams;

    /// <summary>
    /// Sets the sampling temperature to use for the model's output.
    /// Higher values like 0.8 make the output more random, while lower values like 0.2 make it more focused and deterministic.
    /// </summary>
    /// <param name="Value">
    /// The temperature value between 0.0 and 1.0. Default is 0.7.
    /// A temperature of 0 makes the model deterministic, while a temperature of 1 allows for maximum creativity.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function Temperature(const Value: Single): TChatParams;

    /// <summary>
    /// Sets the nucleus sampling probability mass for the model (Top-p).
    /// For example, 0.1 means only the tokens comprising the top 10% probability mass are considered.
    /// </summary>
    /// <param name="Value">
    /// The <c>top_p</c> value between 0.0 and 1.0. Default is 1.
    /// Lower values limit the model to consider only the most probable options.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function TopP(const Value: Single): TChatParams;

    /// <summary>
    /// Specifies a list of tools that the model can use to generate structured outputs such as JSON inputs for function calls.
    /// </summary>
    /// <param name="Value">
    /// An array of <c>TChatMessageTool</c> representing the tools available to the model.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// These tools can include functions that the model can utilize when generating output. For example, they can help the model produce structured data for specific tasks.
    /// </remarks>
    function Tools(const Value: TArray<TChatMessageTool>): TChatParams; overload;

    /// <summary>
    /// Specifies a list of tools that the model can use to generate structured outputs such as JSON inputs for function calls.
    /// </summary>
    /// <param name="Value">
    /// An array of <c>IFunctionCore</c> representing the tools available to the model.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// These tools can include functions that the model can utilize when generating output. For example, they can help the model produce structured data for specific tasks.
    /// </remarks>
    function Tools(const Value: TArray<IFunctionCore>): TChatParams; overload;

    /// <summary>
    /// Configures how the model interacts with functions. This can either prevent, allow, or require function calls depending on the setting.
    /// </summary>
    /// <param name="Value">
    /// The <c>TToolChoice</c> setting for function interaction, with a default of "auto".
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// If set to <c>none</c>, the model will not call any functions and will generate a message instead. If set to <c>auto</c>, the model can choose between generating a message or calling a function. If set to <c>any</c>, the model is required to call a function.
    /// </remarks>
    function ToolChoice(const Value: TToolChoice): TChatParams; overload;

    /// <summary>
    /// Configures how the model interacts when required is on.
    /// </summary>
    /// <param name="Value">
    /// The <c>TToolChoice</c> setting for function interaction, with a default of "auto".
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function ToolChoice(const FunctionName: string): TChatParams; overload;

    /// <summary>
    /// Sets the random seed for deterministic results during sampling.
    /// </summary>
    /// <param name="Value">An integer value to be used as the seed.</param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// Providing a random seed ensures that multiple calls with the same parameters produce the same results, useful for testing or reproducible outcomes.
    /// </remarks>
    function RandomSeed(const Value: Integer): TChatParams;

    /// <summary>
    /// Stop (string)
    /// Stop generation if this token is detected. Or if one of these tokens is detected when providing an array
    /// </summary>
    /// <param name="Value">
    /// The string that causes the stop
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function Stop(const Value: string): TChatParams; overload;

    /// <summary>
    /// Stop Array of Stop (strings) (Stop)
    /// Stop generation if this token is detected. Or if one of these tokens is detected when providing an array
    /// </summary>
    /// <param name="Value">
    /// The array of string that causes the stop
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function Stop(const Value: TArray<string>): TChatParams; overload;

    /// <summary>
    /// Presence_penalty determines how much the model penalizes the repetition of words or phrases
    /// </summary>
    /// <param name="Value">
    /// number (Presence Penalty) [ -2 .. 2 ]; Default: 0
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// A higher presence penalty encourages the model to use a wider variety of words and phrases,
    /// making the output more diverse and creative.
    /// </remarks>
    function PresencePenalty(const Value: Double): TChatParams;

    /// <summary>
    /// Frequency_penalty penalizes the repetition of words based on their frequency in the generated text.
    /// </summary>
    /// <param name="Value">
    /// number (Presence Penalty) [ -2 .. 2 ]; Default: 0
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// A higher frequency penalty discourages the model from repeating words that have already appeared
    /// frequently in the output, promoting diversity and reducing repetition.
    /// </remarks>
    function FrequencyPenalty(const Value: Double): TChatParams;

    /// <summary>
    /// Number of completions to return for each request, input tokens are only billed once.
    /// </summary>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function N(const Value: Integer): TChatParams;

    /// <summary>
    /// Enable users to specify expected results, optimizing response times by leveraging known or
    /// predictable content.
    /// </summary>
    /// <param name="Value">The string prediction content.</param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// This approach is especially effective for updating text documents or code files with minimal
    /// changes, reducing latency while maintaining high-quality results.
    /// </remarks>
    function Prediction(const Value: string): TChatParams;

    /// <summary>
    /// Whether to allow the model to run tool calls in parallel.
    /// </summary>
    /// <param name="Value">If true then enable parallel mode.</param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// Default: true
    /// </remarks>
    function ParallelToolCalls(const Value: Boolean): TChatParams;

    /// <summary>
    /// Allows toggling between the reasoning mode and no system prompt.
    /// When set to reasoning the system prompt for reasoning models will be used.
    /// </summary>
    function PromptMode(const Value: string = 'reasoning'): TChatParams;

    /// <summary>
    /// Determines whether a safety prompt should be injected automatically before the conversation starts.
    /// </summary>
    /// <param name="Value">
    /// A boolean indicating whether to enable the safety prompt. Default is <c>False</c>.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function SafePrompt(const Value: Boolean = False): TChatParams;

    function DocumentImageLimit(const Value: Integer): TChatParams;

    function DocumentPageLimit(const Value: Integer): TChatParams;
  end;

  /// <summary>
  /// Represents the token usage statistics for a chat interaction, including the number of tokens
  /// used in the prompt, the completion, and the total number of tokens consumed.
  /// </summary>
  /// <remarks>
  /// The <c>TChatUsage</c> class provides insight into the number of tokens used during a chat interaction.
  /// This information is critical for understanding the cost of a request when using token-based billing systems
  /// or for monitoring the model's behavior in terms of input (prompt) and output (completion) size.
  /// </remarks>
  TChatUsage = class
  private
    [JsonNameAttribute('prompt_tokens')]
    FPrompt_tokens: Int64;
    [JsonNameAttribute('completion_tokens')]
    FCompletion_tokens: Int64;
    [JsonNameAttribute('total_tokens')]
    FTotal_tokens: Int64;
  public
    /// <summary>
    /// The number of tokens consumed by the prompt in the chat request.
    /// </summary>
    /// <remarks>
    /// This property tracks how many tokens were used for the initial input prompt sent to the model.
    /// It's useful for understanding how much of the token limit is being consumed by the user's query or system instructions.
    /// </remarks>
    property PromptTokens: Int64 read FPrompt_tokens write FPrompt_tokens;

    /// <summary>
    /// The number of tokens consumed by the completion generated by the model.
    /// </summary>
    /// <remarks>
    /// The <c>CompletionTokens</c> property tracks how many tokens were used in the response generated by the model.
    /// This helps in determining the token cost of the AI's output relative to the prompt size.
    /// </remarks>
    property CompletionTokens: Int64 read FCompletion_tokens write FCompletion_tokens;

    /// <summary>
    /// The total number of tokens used for the entire chat request, including both the prompt and the completion.
    /// </summary>
    /// <remarks>
    /// The <c>TotalTokens</c> property provides the overall token usage for a single request, which is the sum of the tokens
    /// from the prompt and the completion. This value is critical for tracking token consumption and ensuring it stays within
    /// model limitations or pricing thresholds.
    /// </remarks>
    property TotalTokens: Int64 read FTotal_tokens write FTotal_tokens;
  end;

  TThinking = class
  private
    [JsonReflectAttribute(ctString, rtString, TContentTypeInterceptor)]
    FType: TContentType;
    FText: string;
  public
    property &Type: TContentType read FType write FType;
    property Text: string read FText write FText;
  end;

  TMessageContentCommon = class
  private
    [JsonReflectAttribute(ctString, rtString, TContentTypeInterceptor)]
    FType: TContentType;
  public
    property &Type: TContentType read FType write FType;
  end;

  TMessageContentText = class(TMessageContentCommon)
  private
    FText: string;
  public
    property Text: string read FText write FText;
  end;

  TMessageContentReference = class(TMessageContentText)
  private
    [JsonNameAttribute('reference_ids')]
    FReferenceIds: TArray<Int64>;
  public
    property ReferenceIds: TArray<Int64> read FReferenceIds write FReferenceIds;
  end;

  TMessageContentDocumentUrl = class(TMessageContentReference)
  private
    [JsonNameAttribute('document_url')]
    FDocumentUrl: string;
    [JsonNameAttribute('document_name')]
    FDocumentName: string;
  public
    property DocumentUrl: string read FDocumentUrl write FDocumentUrl;
    property DocumentName: string read FDocumentName write FDocumentName;
  end;

  TContentImageUrl = class
  private
    FUrl: string;
    FDetail: string;
  public
    property Url: string read FUrl write FUrl;
    property Detail: string read FDetail write FDetail;
  end;

  TMessageContentImageUrl = class(TMessageContentDocumentUrl)
  private
    [JsonNameAttribute('image_url')]
    FImageUrl: TContentImageUrl;
  public
    property ImageUrl: TContentImageUrl read FImageUrl write FImageUrl;
    destructor Destroy; override;
  end;

  TMessageContentThinking = class(TMessageContentImageUrl)
  private
    FThinking: TArray<TThinking>;
  public
    property Thinking: TArray<TThinking> read FThinking write FThinking;
    destructor Destroy; override;
  end;

  TChatContent = class(TMessageContentThinking);

  /// <summary>
  /// Represents a chat message exchanged between participants (user, assistant, or system) in a conversation.
  /// </summary>
  /// <remarks>
  /// The <c>TChatMessage</c> class encapsulates the essential information of a message within a chat application, including:
  /// - The role of the sender (user, assistant, or system).
  /// - The content of the message itself.
  /// - Optionally, a list of tool calls that may be required to complete the message response.
  /// This class is fundamental for managing the flow of a conversation, allowing the system to track who said what and what actions need to be taken.
  /// </remarks>
  TChatMessage = class
  private
    FRole: string;
    FContent: TArray<TChatContent>;
    [JsonNameAttribute('tool_calls')]
    FToolsCalls: TArray<TCalledFunction>;
    FPrefix: Boolean;
  public
    /// <summary>
    /// The role of the author of this message, indicating the sender (e.g., user, assistant, or system).
    /// </summary>
    /// <remarks>
    /// The <c>Role</c> property identifies the participant responsible for the message. Common values are "user" for messages sent by the user,
    /// "assistant" for responses generated by the AI, or "system" for control messages.
    /// </remarks>
    property Role: string read FRole write FRole;

    /// <summary>
    /// The contents of the message.
    /// </summary>
    /// <remarks>
    /// The <c>Content</c> property stores the actual message text. This can include user inputs, assistant-generated replies, or system instructions.
    /// </remarks>
    property Content: TArray<TChatContent> read FContent write FContent;

    /// <summary>
    /// A list of tool calls to be executed for query completion.
    /// </summary>
    /// <remarks>
    /// The <c>ToolsCalls</c> property contains a list of functions or tools that need to be invoked to process the current query further.
    /// This is typically used when the assistant needs to call external APIs or perform specific actions before delivering a final response.
    /// </remarks>
    property ToolsCalls: TArray<TCalledFunction> read FToolsCalls write FToolsCalls;

    /// <summary>
    /// Prefix of the content.
    /// </summary>
    /// <remarks>
    property Prefix: Boolean read FPrefix write FPrefix;

    /// <summary>
    /// Destructor to release any resources used by this instance.
    /// </summary>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a single completion option generated by the AI model during a chat interaction.
  /// </summary>
  /// <remarks>
  /// The <c>TChatChoices</c> class stores the results of the AI model's response to a user prompt. Each instance of this class represents one of potentially
  /// many choices that the model could return. This includes:
  /// - An index identifying the choice.
  /// - A message generated by the model.
  /// - Optional deltas for streamed responses.
  /// - The reason the model stopped generating tokens.
  /// This class is useful when multiple potential responses are generated and evaluated, or when streaming responses incrementally.
  /// </remarks>
  TChatChoices = class
  private
    FIndex: Int64;
    FMessage: TChatMessage;
    [JsonReflectAttribute(ctString, rtString, TFinishReasonInterceptor)]
    FFinish_reason: TFinishReason;
    FDelta: TChatMessage;
  public
    /// <summary>
    /// The index of the choice in the list of possible choices generated by the model.
    /// </summary>
    /// <remarks>
    /// The <c>Index</c> property helps identify the position of this particular choice in a set of choices provided by the AI model.
    /// This is useful when multiple options are generated for completion, and each one is referenced by its index.
    /// </remarks>
    property Index: Int64 read FIndex write FIndex;

    /// <summary>
    /// A chat completion message generated by the AI model.
    /// </summary>
    /// <remarks>
    /// The <c>Message</c> property contains the message that the model generated based on the provided prompt or conversation context.
    /// This is typically a complete message representing the AI's response to a user or system message.
    /// </remarks>
    property Message: TChatMessage read FMessage write FMessage;

    /// <summary>
    /// A chat completion delta representing partial responses generated during streaming.
    /// </summary>
    /// <remarks>
    /// The <c>Delta</c> property holds an incremental message (or delta) when the model sends streamed responses.
    /// This allows the model to progressively generate and deliver a response before it is fully completed.
    /// </remarks>
    property Delta: TChatMessage read FDelta write FDelta;

    /// <summary>
    /// The reason the model stopped generating tokens.
    /// </summary>
    /// <remarks>
    /// The <c>FinishReason</c> property indicates why the model ceased generating further tokens. This could be due to reaching a natural stop point
    /// in the conversation, hitting a token limit, or encountering a stop sequence provided by the user.
    /// </remarks>
    property FinishReason: TFinishReason read FFinish_reason write FFinish_reason;

    /// <summary>
    /// Destructor to clean up resources used by the <c>TChatChoices</c> instance.
    /// </summary>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a chat completion response generated by an AI model, containing the necessary metadata,
  /// the generated choices, and usage statistics.
  /// </summary>
  /// <remarks>
  /// The <c>TChat</c> class encapsulates the results of a chat request made to an AI model.
  /// It contains details such as a unique identifier, the model used, when the completion was created,
  /// the choices generated by the model, and token usage statistics.
  /// This class is crucial for managing the results of AI-driven conversations and understanding the
  /// underlying usage and response characteristics of the AI.
  /// </remarks>
  TChat = class(TJSONFingerprint)
  private
    FId: string;
    FObject: string;
    FCreated: Int64;
    FModel: string;
    FChoices: TArray<TChatChoices>;
    FUsage: TChatUsage;
  public
    /// <summary>
    /// A unique identifier for the chat completion.
    /// </summary>
    /// <remarks>
    /// The <c>Id</c> property stores a unique string that identifies the specific chat completion request.
    /// This is useful for tracking and managing chat sessions or retrieving the results of a particular interaction.
    /// </remarks>
    property Id: string read FId write FId;

    /// <summary>
    /// The object type, which is always "chat.completion".
    /// </summary>
    /// <remarks>
    /// The <c>Object</c> property describes the type of the response. For chat completions, this value is always "chat.completion",
    /// providing a clear indication of the response type when working with multiple object types in a system.
    /// </remarks>
    property &Object: string read FObject write FObject;

    /// <summary>
    /// The Unix timestamp (in seconds) of when the chat completion was created.
    /// </summary>
    /// <remarks>
    /// The <c>Created</c> property contains a Unix timestamp indicating when the AI generated the chat completion. This is
    /// useful for logging, auditing, or ordering chat completions chronologically.
    /// </remarks>
    property Created: Int64 read FCreated write FCreated;

    /// <summary>
    /// The model used for the chat completion.
    /// </summary>
    /// <remarks>
    /// The <c>Model</c> property specifies which AI model was used to generate the chat completion. This can be helpful
    /// when comparing results across different models or tracking which model versions are producing responses.
    /// </remarks>
    property Model: string read FModel write FModel;

    /// <summary>
    /// A list of chat completion choices generated by the model.
    /// </summary>
    /// <remarks>
    /// The <c>Choices</c> property holds an array of <c>TChatChoices</c> objects, which represent the different response options
    /// generated by the AI model. There may be multiple choices if the request asked for more than one completion.
    /// </remarks>
    property Choices: TArray<TChatChoices> read FChoices write FChoices;

    /// <summary>
    /// Usage statistics for the completion request, including token counts for the prompt and completion.
    /// </summary>
    /// <remarks>
    /// The <c>Usage</c> property contains information about the number of tokens consumed during the request, including the
    /// tokens used in the prompt and those generated in the completion. This data is important for monitoring API usage and costs.
    /// </remarks>
    property Usage: TChatUsage read FUsage write FUsage;

    /// <summary>
    /// Destructor to clean up resources used by this <c>TChat</c> instance.
    /// </summary>
    /// <remarks>
    /// The destructor ensures that any allocated resources, such as the memory for the array of choices or usage statistics, are
    /// properly released when the object is no longer needed.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous chat Callbacks for a chat request using <c>TChat</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynChat</c> type extends the <c>TAsynParams&lt;TChat&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynChat = TAsyncCallback<TChat>;

  /// <summary>
  /// Represents a promise-based asynchronous callback for chat completion operations.
  /// </summary>
  /// <remarks>
  /// Alias of <c>TPromiseCallBack&lt;TChat&gt;</c>, this type allows you to await the result
  /// of a chat completion request and handle it as a <see cref="TChat"/> instance.
  /// </remarks>
  TPromiseChat = TPromiseCallback<TChat>;

  /// <summary>
  /// Manages asynchronous streaming chat Callbacks for a chat request using <c>TChat</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynChatStream</c> type extends the <c>TAsynStreamParams&lt;TChat&gt;</c> record to support the lifecycle of an asynchronous streaming chat operation.
  /// It provides Callbacks for different stages, including when the operation starts, progresses with new data chunks, completes successfully, or encounters an error.
  /// This structure is ideal for handling scenarios where the chat response is streamed incrementally, providing real-time updates to the user interface.
  /// </remarks>
  TAsynChatStream = TAsyncStreamCallback<TChat>;

  /// <summary>
  /// Represents a promise-based asynchronous callback for streaming chat completion operations.
  /// </summary>
  /// <remarks>
  /// Alias of <c>TPromiseStreamCallBack&lt;TChat&gt;</c>, this type provides a <see cref="TChat"/> stream
  /// that can be awaited, delivering partial <see cref="TChat"/> updates as they arrive.
  /// </remarks>
  TPromiseChatStream = TPromiseStreamCallback<TChat>;

  /// <summary>
  /// Represents a callback procedure used during the reception of responses from a chat request in streaming mode.
  /// </summary>
  /// <param name="Chat">
  /// The <c>TChat</c> object containing the current information about the response generated by the model.
  /// If this value is <c>nil</c>, it indicates that the data stream is complete.
  /// </param>
  /// <param name="IsDone">
  /// A boolean flag indicating whether the streaming process is complete.
  /// If <c>True</c>, it means the model has finished sending all response data.
  /// </param>
  /// <param name="Cancel">
  /// A boolean flag that can be set to <c>True</c> within the callback to cancel the streaming process.
  /// If set to <c>True</c>, the streaming will be terminated immediately.
  /// </param>
  /// <remarks>
  /// This callback is invoked multiple times during the reception of the response data from the model.
  /// It allows for real-time processing of received messages and interaction with the user interface or other systems
  /// based on the state of the data stream.
  /// When the <c>IsDone</c> parameter is <c>True</c>, it indicates that the model has finished responding,
  /// and the <c>Chat</c> parameter will be <c>nil</c>.
  /// </remarks>
  TChatEvent = reference to procedure(var Chat: TChat; IsDone: Boolean; var Cancel: Boolean);

  /// <summary>
  /// The <c>TChatRoute</c> class inherits from <c>TMistralAIAPIRoute</c> and provides an interface for managing various interactions with the chat API.
  /// It supports creating chat completion requests in synchronous, asynchronous, and streaming modes, offering mechanisms to handle responses generated by the model.
  /// </summary>
  /// <remarks>
  /// This class facilitates sending messages to a chat model, receiving responses, and managing them, whether synchronously or asynchronously.
  /// The primary methods in the class are:
  /// <para>
  /// - <c>Create</c> : Sends a chat request and waits for a full response.
  /// </para>
  /// <para>
  /// - <c>AsyncCreate</c> : Performs an asynchronous chat completion request with event handling.
  /// </para>
  /// <para>
  /// - <c>CreateStream</c> : Initiates a chat completion request in streaming mode, receiving tokens progressively.
  /// </para>
  /// <para>
  /// - <c>ASyncCreateStream</c> : Performs an asynchronous request in streaming mode with event handling.
  /// </para>
  /// Each method allows configuring model parameters, setting input messages, managing token limits, and including Callbacks for processing responses or errors.
  /// </remarks>
  TChatRoute = class(TMistralAIAPIRoute)
  public
    /// <summary>
    /// Asynchronously sends a chat completion request and returns a promise that resolves with the resulting <see cref="TChat"/> object.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure in which you configure the <see cref="TChatParams"/> for the request, such as model selection, messages, and other options.
    /// </param>
    /// <param name="Callbacks">
    /// An optional function that provides asynchronous Callbacks wrapped in a <see cref="TPromiseChat"/>, allowing you to handle success, error, or cancellation events.
    /// If omitted, the promise will only resolve or reject based on the API response.
    /// </param>
    /// <returns>
    /// A <see cref="TPromise{TChat}"/> that resolves to the completed <see cref="TChat"/> result when the request succeeds, or rejects with an exception on error.
    /// </returns>
    /// <remarks>
    /// This method wraps the standard <see cref="AsyncCreate"/> callback pattern in a promise, simplifying integration with code that favors
    /// promise-based asynchronous flows. Use <c>await</c> on the returned promise to retrieve the <see cref="TChat"/> result directly.
    /// </remarks>
    function AsyncAwaitCreate(const ParamProc: TProc<TChatParams>;
      const Callbacks: TFunc<TPromiseChat> = nil): TPromise<TChat>;

    /// <summary>
    /// Asynchronously sends a streaming chat completion request and returns a promise that resolves with the complete response text once streaming finishes.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure in which you configure the <see cref="TChatParams"/> for the request, such as model selection, messages, and streaming options.
    /// </param>
    /// <param name="Callbacks">
    /// A function that provides asynchronous Callbacks wrapped in a <see cref="TPromiseChatStream"/>, allowing you to handle progress updates, success, errors, and cancellation events.
    /// </param>
    /// <returns>
    /// A <see cref="TPromise{string}"/> that resolves to the full concatenated response text when the stream completes, or rejects with an exception on error.
    /// </returns>
    /// <remarks>
    /// This method wraps the standard <see cref="AsyncCreateStream"/> callback pattern in a promise-based interface. Partial responses received via the provided Callbacks
    /// are accumulated internally, and the returned promise yields the entire response once streaming is done.
    /// </remarks>
    function AsyncAwaitCreateStream(const ParamProc: TProc<TChatParams>;
      const Callbacks: TFunc<TPromiseChatStream>): TPromise<string>;

    /// <summary>
    /// Initiates parallel processing of multiple chat prompts and returns a promise for the bundled results.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the bundle parameters (model, prompts, reasoning effort, etc.) before dispatch.
    /// </param>
    /// <param name="CallBacks">
    /// An optional function that provides a <see cref="TPromiseBundleList"/> record for hooking into lifecycle events.
    /// </param>
    /// <returns>
    /// A <see cref="TPromise&lt;TBundleList&gt;"/> that resolves with a <see cref="TBundleList"/> containing all responses
    /// once every parallel task completes, or rejects on the first error.
    /// </returns>
    /// <remarks>
    /// This method wraps the callback-based <see cref="CreateParallel"/> in a promise interface, enabling async/await usage
    /// for parallel prompt execution. If <paramref name="CallBacks"/> is omitted, only the promise resolution is available.
    /// </remarks>
    function AsyncAwaitCreateParallel(const ParamProc: TProc<TBundleParams>;
      const CallBacks: TFunc<TPromiseBundleList> = nil): TPromise<TBundleList>;

    /// <summary>
    /// Creates a completion for the chat message using the provided parameters.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the chat request, such as selecting the model, providing messages, setting token limits, etc.
    /// </param>
    /// <returns>
    /// Returns a <c>TChat</c> object that contains the chat response, including the choices generated by the model.
    /// </returns>
    /// <exception cref="MistralAIExceptionAPI">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="MistralAIExceptionInvalidRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// The <c>Create</c> method sends a chat completion request and waits for the full response. The returned <c>TChat</c> object contains the model's generated response, including multiple choices if available.
    ///
    /// Example usage:
    /// <code>
    ///   MistralAI := TMistralAIFactory.CreateInstance(BaererKey);
    ///   var Chat := MistralAI.Chat.Create(
    ///     procedure (Params: TChatParams)
    ///     begin
    ///       // Define chat parameters
    ///     end);
    ///   try
    ///     for var Choice in Chat.Choices do
    ///       WriteLn(Choice.Message.Content);
    ///   finally
    ///     Chat.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Create(const ParamProc: TProc<TChatParams>): TChat;

    /// <summary>
    /// Creates a chat message completion with a streamed response.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the chat request, such as selecting the model, providing messages, and adjusting other settings like token limits or temperature.
    /// </param>
    /// <param name="Event">
    /// A callback of type <c>TChatEvent</c> that is triggered with each chunk of data received during the streaming process. It includes the current state of the <c>TChat</c> object, a flag indicating if the stream is done, and a boolean to handle cancellation.
    /// </param>
    /// <returns>
    /// Returns <c>True</c> if the streaming process started successfully, <c>False</c> otherwise.
    /// </returns>
    /// <remarks>
    /// This method initiates a chat request in streaming mode, where the response is delivered incrementally in real-time.
    /// The <c>Event</c> callback will be invoked multiple times as tokens are received.
    /// When the response is complete, the <c>IsDone</c> flag will be set to <c>True</c>, and the <c>Chat</c> object will be <c>nil</c>.
    /// The streaming process can be interrupted by setting the <c>Cancel</c> flag to <c>True</c> within the event.
    ///
    /// Example usage:
    /// <code>
    ///   MistralAI.Chat.CreateStream(
    ///     procedure (Params: TChatParams)
    ///     begin
    ///       // Define chat parameters
    ///     end,
    ///
    ///     procedure(var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
    ///     begin
    ///       // Handle displaying
    ///     end
    ///   );
    /// </code>
    /// </remarks>
    function CreateStream(const ParamProc: TProc<TChatParams>; Event: TChatEvent): Boolean;

    /// <summary>
    /// Initiates parallel processing of chat prompts by creating multiple chat completions
    /// asynchronously, with results stored in a bundle and provided back to the callback function.
    /// This method allows for parallel processing of multiple prompts in an efficient manner,
    /// handling errors and successes for each chat completion.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure delegate that configures the parameters for the bundle. It is responsible
    /// for providing the necessary settings (such as model and reasoning effort) for the chat completions.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns an instance of TAsynBuffer, which manages the lifecycle of the
    /// asynchronous operation. The callbacks include handlers for start, error, and success events.
    /// </param>
    /// <remarks>
    /// The method allows for efficient parallel processing of multiple prompts by delegating
    /// individual tasks to separate threads. It each task's result is properly bundled and communicated back to the caller.
    /// If an error occurs, the error handling callback will be triggered, and the rest of the tasks
    /// will continue processing. The success callback is triggered once all tasks are completed.
    /// </remarks>
    procedure CreateParallel(const ParamProc: TProc<TBundleParams>;
      const CallBacks: TFunc<TAsynBundleList>);

    /// <summary>
    /// Create an asynchronous completion for chat message
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the parameters for the chat request, such as model selection, messages, and other parameters.
    /// </param>
    /// <param name="Callbacks">
    /// A function that returns a record containing event handlers for the asynchronous chat completion, such as on success and on error.
    /// </param>
    /// <remarks>
    /// This procedure initiates an asynchronous request to generate a chat completion based on the provided parameters. The response or error is handled by the provided Callbacks.
    /// <code>
    /// MistralAI.Chat.AsyncCreate(
    ///   procedure (Params: TChatParams)
    ///   begin
    ///     // Define chat parameters
    ///   end,
    ///   function: TAsynChat
    ///   begin
    ///     Result.Sender := Memo1;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Chat: TChat)
    ///     begin
    ///       var M := Sender as TMemo; // Because Result.Sender = Memo1
    ///       // Handle success operation
    ///     end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Value: string)
    ///     begin
    ///       // Handle error message
    ///     end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncCreate(const ParamProc: TProc<TChatParams>;
      const Callbacks: TFunc<TAsynChat>);

    /// <summary>
    /// Creates an asynchronous streaming chat completion request.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the chat request, including the model, messages, and additional options such as max tokens and streaming mode.
    /// </param>
    /// <param name="Callbacks">
    /// A function that returns a <c>TAsynChatStream</c> record which contains event handlers for managing different stages of the streaming process: progress updates, success, errors, and cancellation.
    /// </param>
    /// <remarks>
    /// This procedure initiates an asynchronous chat operation in streaming mode, where tokens are progressively received and processed.
    /// The provided event handlers allow for handling progress (i.e., receiving tokens in real time), detecting success, managing errors, and enabling cancellation logic.
    /// <code>
    /// MistralAI.Chat.AsyncCreateStream(
    ///   procedure(Params: TChatParams)
    ///   begin
    ///     // Define chat parameters
    ///     Params.Stream;
    ///   end,
    ///
    ///   function: TAsynChatStream
    ///   begin
    ///     Result.Sender := Memo1; // Instance passed to callback parameter
    ///     Result.OnProgress :=
    ///         procedure (Sender: TObject; Chat: TChat)
    ///         begin
    ///           // Handle progressive updates to the chat response
    ///         end;
    ///     Result.OnSuccess :=
    ///         procedure (Sender: TObject)
    ///         begin
    ///           // Handle success when the operation completes
    ///         end;
    ///     Result.OnError :=
    ///         procedure (Sender: TObject; Value: string)
    ///         begin
    ///           // Handle error message
    ///         end;
    ///     Result.OnDoCancel :=
    ///         function: Boolean
    ///         begin
    ///           Result := CheckBox1.Checked; // Click on checkbox to cancel
    ///         end;
    ///     Result.OnCancellation :=
    ///         procedure (Sender: TObject)
    ///         begin
    ///           // Processing when process has been canceled
    ///         end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncCreateStream(const ParamProc: TProc<TChatParams>;
      const Callbacks: TFunc<TAsynChatStream>);
  end;

implementation

uses
  system.StrUtils, Rest.Json, System.Rtti, MistralAI.NetEncoding.Base64;

{ TChatParams }

function TChatParams.DocumentImageLimit(const Value: Integer): TChatParams;
begin
  Result := TChatParams(Add('document_image_limit', Value));
end;

function TChatParams.DocumentPageLimit(const Value: Integer): TChatParams;
begin
  Result := TChatParams(Add('document_page_limit', Value));
end;

function TChatParams.FrequencyPenalty(const Value: Double): TChatParams;
begin
  Result := TChatParams(Add('frequency_penalty', Value));
end;

function TChatParams.MaxTokens(const Value: Integer): TChatParams;
begin
  Result := TChatParams(Add('max_tokens', Value));
end;

function TChatParams.Messages(const Value: TArray<TChatMessagePayload>): TChatParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TChatParams(Add('messages', JSONArray));
end;

function TChatParams.Model(const Value: string): TChatParams;
begin
  Result := TChatParams(Add('model', Value));
end;

function TChatParams.N(const Value: Integer): TChatParams;
begin
  Result := TChatParams(Add('n', Value));
end;

function TChatParams.ParallelToolCalls(const Value: Boolean): TChatParams;
begin
  Result := TChatParams(Add('parallel_tool_calls', Value));
end;

function TChatParams.Prediction(const Value: string): TChatParams;
begin
  Result := TChatParams(Add('prediction',
    TJSONObject.Create
      .AddPair('type', 'content')
      .AddPair('content', Value)
    ));
end;

function TChatParams.PresencePenalty(const Value: Double): TChatParams;
begin
  Result := TChatParams(Add('presence_penalty', Value));
end;

function TChatParams.PromptMode(const Value: string): TChatParams;
begin
  Result := TChatParams(Add('prompt_mode', Value));
end;

function TChatParams.RandomSeed(const Value: Integer): TChatParams;
begin
  Result := TChatParams(Add('random_seed', Value));
end;

function TChatParams.ResponseFormat(const Value: string): TChatParams;
begin
  Result := TChatParams(Add('response_format', TResponseFormatParams.Json_Schema(Value)));
end;

function TChatParams.ResponseFormat(
  const Value: TResponseFormatParams): TChatParams;
begin
  Result := TChatParams(Add('response_format', Value.Detach));
end;

function TChatParams.SafePrompt(const Value: Boolean): TChatParams;
begin
  Result := TChatParams(Add('safe_prompt', Value));
end;

function TChatParams.Stop(const Value: string): TChatParams;
begin
  Result := TChatParams(Add('stop', Value));
end;

function TChatParams.Stop(const Value: TArray<string>): TChatParams;
begin
  Result := TChatParams(Add('stop', Value));
end;

function TChatParams.Stream(const Value: Boolean): TChatParams;
begin
  Result := TChatParams(Add('stream', Value));
end;

function TChatParams.Temperature(const Value: Single): TChatParams;
begin
  Result := TChatParams(Add('temperature', Value));
end;

function TChatParams.ToolChoice(const Value: TToolChoice): TChatParams;
begin
  Result := TChatParams(Add('tool_choice', Value.ToString));
end;

function TChatParams.ToolChoice(const FunctionName: string): TChatParams;
begin
  var Tool := TJSONParam.Create
        .Add('type', 'function')
        .Add('function', TJSONObject.Create
          .AddPair('Name', FunctionName));
  Result := TChatParams(Add('tool_choice', Tool.Detach));
end;

function TChatParams.Tools(const Value: TArray<IFunctionCore>): TChatParams;
var
  Arr: TArray<TChatMessageTool>;
begin
  for var Item in Value do
    Arr := Arr + [TChatMessageTool.Add(Item)];
  Result := Tools(Arr);
end;

function TChatParams.Tools(const Value: TArray<TChatMessageTool>): TChatParams;
var
  Item: TChatMessageTool;
  Items: TJSONArray;
begin
  Items := TJSONArray.Create;
  try
    for Item in Value do
      begin
        Items.Add(Item.ToJson);
      end;
    Result := TChatParams(Add('tools', Items));
  except
    on E: Exception do
      begin
        Items.Free;
        raise;
      end;
  end;
end;

function TChatParams.TopP(const Value: Single): TChatParams;
begin
  Result := TChatParams(Add('top_p', Value));
end;

{ TChatChoices }

destructor TChatChoices.Destroy;
begin
  if Assigned(FMessage) then
    FMessage.Free;
  if Assigned(FDelta) then
    FDelta.Free;
  inherited;
end;

{ TChat }

destructor TChat.Destroy;
begin
  if Assigned(FUsage) then
    FUsage.Free;
  for var Item in FChoices do
    Item.Free;
  inherited;
end;

{ TChatRoute }

function TChatRoute.AsyncAwaitCreate(const ParamProc: TProc<TChatParams>;
  const Callbacks: TFunc<TPromiseChat>): TPromise<TChat>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TChat>(
    procedure(const CallbackParams: TFunc<TAsynChat>)
    begin
      AsyncCreate(ParamProc, CallbackParams);
    end,
    Callbacks);
end;

function TChatRoute.AsyncAwaitCreateStream(const ParamProc: TProc<TChatParams>;
  const Callbacks: TFunc<TPromiseChatStream>): TPromise<string>;
begin
  Result := TPromise<string>.Create(
    procedure(Resolve: TProc<string>; Reject: TProc<Exception>)
    var
      Buffer: string;
    begin
      AsyncCreateStream(ParamProc,
        function : TAsynChatStream
        begin
          Result.Sender := Callbacks.Sender;

          Result.OnStart := Callbacks.OnStart;

          Result.OnProgress :=
            procedure (Sender: TObject; Event: TChat)
            begin
              if Assigned(Callbacks.OnProgress) then
                Callbacks.OnProgress(Sender, Event);
              Buffer := Buffer + Event.Choices[0].Delta.Content[0].Text;
            end;

          Result.OnSuccess :=
            procedure (Sender: TObject)
            begin
              Resolve(Buffer);
            end;

          Result.OnError :=
            procedure (Sender: TObject; Error: string)
            begin
              if Assigned(Callbacks.OnError) then
                Error := Callbacks.OnError(Sender, Error);
              Reject(Exception.Create(Error));
            end;

          Result.OnDoCancel :=
            function : Boolean
            begin
              if Assigned(Callbacks.OnDoCancel) then
                Result := Callbacks.OnDoCancel()
              else
                Result := False;
            end;

          Result.OnCancellation :=
            procedure (Sender: TObject)
            begin
              var Error := 'aborted';
              if Assigned(Callbacks.OnCancellation) then
                Error := Callbacks.OnCancellation(Sender);
              Reject(Exception.Create(Error));
            end;
        end);
    end);
end;

function TChatRoute.AsyncAwaitCreateParallel(const ParamProc: TProc<TBundleParams>;
  const CallBacks: TFunc<TPromiseBundleList>): TPromise<TBundleList>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TBundleList>(
    procedure(const CallBackParams: TFunc<TAsynBundleList>)
    begin
      CreateParallel(ParamProc, CallBackParams);
    end,
    CallBacks);
end;

procedure TChatRoute.AsyncCreate(
  const ParamProc: TProc<TChatParams>;
  const Callbacks: TFunc<TAsynChat>);
begin
  with TAsyncCallBackExec<TAsynChat, TChat>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TChat
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TChatRoute.AsyncCreateStream(
  const ParamProc: TProc<TChatParams>;
  const Callbacks: TFunc<TAsynChatStream>);
begin
  var CallbackParams := TUseParamsFactory<TAsynChatStream>.CreateInstance(Callbacks);

  var Sender := CallbackParams.Param.Sender;
  var OnStart := CallbackParams.Param.OnStart;
  var OnSuccess := CallbackParams.Param.OnSuccess;
  var OnProgress := CallbackParams.Param.OnProgress;
  var OnError := CallbackParams.Param.OnError;
  var OnCancellation := CallbackParams.Param.OnCancellation;
  var OnDoCancel := CallbackParams.Param.OnDoCancel;

  var Task: ITask := TTask.Create(
          procedure()
          begin
            {--- Pass the instance of the current class in case no value was specified. }
            if not Assigned(Sender) then
              Sender := Self;

            {--- Trigger OnStart callback }
            if Assigned(OnStart) then
              TThread.Queue(nil,
                procedure
                begin
                  OnStart(Sender);
                end);
            try
              var Stop := False;

              {--- Processing }
              CreateStream(ParamProc,
                procedure (var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
                begin
                  {--- Check that the process has not been canceled }
                  if Assigned(OnDoCancel) then
                    TThread.Queue(nil,
                        procedure
                        begin
                          Stop := OnDoCancel();
                        end);
                  if Stop then
                    begin
                      {--- Trigger when processus was stopped }
                      if Assigned(OnCancellation) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnCancellation(Sender)
                        end);
                      Cancel := True;
                      Exit;
                    end;
                  if not IsDone and Assigned(Chat) then
                    begin
                      var LocalChat := Chat;
                      Chat := nil;

                      {--- Triggered when processus is progressing }
                      if Assigned(OnProgress) then
                        TThread.Synchronize(TThread.Current,
                        procedure
                        begin
                          try
                            OnProgress(Sender, LocalChat);
                          finally
                            {--- Makes sure to release the instance containing the data obtained
                                 following processing}
                            LocalChat.Free;
                          end;
                        end)
                     else
                       LocalChat.Free;
                    end
                  else
                  if IsDone then
                    begin
                      {--- Trigger OnEnd callback when the process is done }
                      if Assigned(OnSuccess) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnSuccess(Sender);
                        end);
                    end;
                end);
            except
              on E: Exception do
                begin
                  var Error := AcquireExceptionObject;
                  try
                    var ErrorMsg := (Error as Exception).Message;

                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(OnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        OnError(Sender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
          end);
  Task.Start;
end;

function TChatRoute.Create(const ParamProc: TProc<TChatParams>): TChat;
begin
  Result := API.Post<TChat, TChatParams>('chat/completions', ParamProc,
    ['choices', '*', 'message', 'content']);
end;

procedure TChatRoute.CreateParallel(const ParamProc: TProc<TBundleParams>;
  const CallBacks: TFunc<TAsynBundleList>);
var
  Tasks: TArray<ITask>;
  BundleParams: TBundleParams;
begin
  BundleParams := TBundleParams.Create;
  try
    if not Assigned(ParamProc) then
      raise Exception.Create('The lambda can''t be null');

    ParamProc(BundleParams);
    var Bundle := TBundleList.Create;
    var Ranking := 0;
    var ErrorExists := False;
    var Prompts := BundleParams.GetPrompt;
    var Counter := Length(Prompts);

    if Assigned(CallBacks.OnStart) then
      CallBacks.OnStart(CallBacks.Sender);

    SetLength(Tasks, Length(Prompts));
    for var index := 0 to Pred(Length(Prompts)) do
      begin
        Tasks[index] := TTask.Run(
          procedure
          begin
            var Buffer := Bundle.Add(index + 1);
            Buffer.Prompt := Prompts[index];
            try
              var Chat := Create(
                procedure (Params: TChatParams)
                begin
                  {--- Set the model for the process }
                  Params.Model(BundleParams.GetModel);

                  {--- Set the current prompt and developer message }
                  Params.Messages([
                    Payload.System(BundleParams.GetSystem),
                    Payload.User(Buffer.Prompt)
                  ]);
                end);
              Inc(Ranking);
              Buffer.FinishIndex := Ranking;
              Buffer.Response := Chat.Choices[0].Message.Content[0].Text;
              Buffer.Chat := Chat;
            except
              on E: Exception do
                begin
                  {--- Catch the exception }
                  var Error := AcquireExceptionObject;
                  ErrorExists := True;
                  try
                    var ErrorMsg := (Error as Exception).Message;
                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(CallBacks.OnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        CallBacks.OnError(CallBacks.Sender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
          end);

        if ErrorExists then
          Continue;

        {--- TTask.WaitForAll is not used due to a memory leak in TLightweightEvent/TCompleteEventsWrapper.
             See report RSP-12462 and RSP-25999. }
        TTaskHelper.ContinueWith(Tasks[Index],
          procedure
          begin
            Dec(Counter);
            if Counter = 0 then
              begin
                try
                  if not ErrorExists and Assigned(CallBacks.OnSuccess) then
                    CallBacks.OnSuccess(CallBacks.Sender, Bundle);
                finally
                  Bundle.Free;
                end;
              end;
          end);
        {--- Need a delay, otherwise the process runs only with the first task. }
        Sleep(30);
      end;
  finally
    BundleParams.Free;
  end;
end;

function TChatRoute.CreateStream(const ParamProc: TProc<TChatParams>;
  Event: TChatEvent): Boolean;
var
  Response: TStringStream;
  RetPos, LineFeed: Integer;
  ResponseBuffer, CurrentLine, Data, NewBuffer: string;
  Chunk: TChat;
  IsDone: Boolean;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    RetPos := 0;
    Result := API.Post<TChatParams>('chat/completions', ParamProc, Response,
      procedure(const Sender: TObject; AContentLength, AReadCount: Int64; var AAbort: Boolean)
      begin
        try
          ResponseBuffer := Response.DataString;
        except
          on E: EEncodingError do
            Exit;
        end;

        LineFeed := ResponseBuffer.IndexOf(#10, RetPos);
        while LineFeed >= 0 do
          begin
            CurrentLine := ResponseBuffer.Substring(RetPos, LineFeed - RetPos).Trim([' ', #13, #10]);
            Inc(RetPos, LineFeed - RetPos + 1);

            if CurrentLine.IsEmpty then
              begin
                LineFeed := ResponseBuffer.IndexOf(#10, RetPos);
                Continue;
              end;

            if CurrentLine.StartsWith('data: ') then
              Data := CurrentLine.Substring(6).Trim
            else
              Data := CurrentLine;

            IsDone := SameText(Data, '[DONE]');

            Chunk := nil;
            if not IsDone then
              try
                Chunk := TApiDeserializer.Parse<TChat>(
                  TJSONNormalizer.Normalize(Data, ['choices', '*', 'delta', 'content']));
              except
                Chunk := nil;
              end;

            if Assigned(Event) then
              try
                Event(Chunk, IsDone, AAbort);
              finally
                Chunk.Free;
              end;

            if IsDone then
              Break;

            LineFeed := ResponseBuffer.IndexOf(#10, RetPos);
          end;

        if RetPos > 0 then
          begin
            NewBuffer := ResponseBuffer.Substring(RetPos);
            Response.Size := 0;
            if NewBuffer <> '' then
              Response.WriteString(NewBuffer);
            RetPos := 0;
          end;
      end);
  finally
    Response.Free;
  end;
end;

{ TChatMessage }

destructor TChatMessage.Destroy;
begin
  for var Tool in FToolsCalls do
    Tool.Free;
  for var Item in FContent do
    Item.Free;
  inherited;
end;

{ TChatMessagePayload }

class function TChatMessagePayload.Assistant(const Value: string; const Prefix: Boolean): TChatMessagePayload;
begin
  Result := TChatMessagePayload.Create.Role(TMessageRole.assistant).Content(Value).Prefix(Prefix);
end;

class function TChatMessagePayload.Assistant(const Value: string;
  const Url: TArray<string>; const Prefix: Boolean): TChatMessagePayload;
begin
  var JSONArray := TJSONArray.Create;
  JSONArray.Add(TMessageContent.Create.&Type(TContentType.text).Text(Value).Detach);
  for var Item in Url do
    JSONArray.Add(TMessageContent.Create.&Type(TContentType.image_url).ImageUrl(ImageUrlCheck(Item)).Detach);
  Result := TChatMessagePayload.Create.Role(TMessageRole.assistant).Content(JSONArray).Prefix(Prefix);
end;

class function TChatMessagePayload.Assistant(const Value: string;
  const Func: TArray<TToolCalls>; const Prefix: Boolean): TChatMessagePayload;
begin
  Result := TChatMessagePayload.Create.Role(TMessageRole.assistant).Content(Value).ToolCalls(Func).Prefix(Prefix);
end;

function TChatMessagePayload.Content(const Value: string): TChatMessagePayload;
begin
  Result := TChatMessagePayload(Add('content', Value));
end;

function TChatMessagePayload.Content(const Kind: TContentType; const Value,
  Detail: string): TChatMessagePayload;
begin
  var MessageContent := TMessageContent.Create.&Type(Kind);
  case Kind of
    TContentType.text:
      MessageContent := MessageContent.Text(Value);
    TContentType.image_url:
      MessageContent := MessageContent.ImageUrl(Value, Detail);
    TContentType.input_audio:
      MessageContent := MessageContent.InputAudio(Value);
  end;
  Result := TChatMessagePayload(Add('content', MessageContent.Detach));
end;

function TChatMessagePayload.Content(const Value: TJSONArray): TChatMessagePayload;
begin
  Result := TChatMessagePayload(Add('content', Value));
end;

function TChatMessagePayload.Content(
  const Value: TArray<string>): TChatMessagePayload;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(TJSONObject.Create.AddPair('type', 'text').AddPair('text', Item));
  Result := TChatMessagePayload(Add('content', JSONArray));
end;

function TChatMessagePayload.Content(const Value: string;
  const Url: TDocumentUrlParams): TChatMessagePayload;
begin
  var JSONArray := TJSONArray.Create;
  JSONArray
    .Add(
      TJSONObject.Create
        .AddPair('type', 'text')
        .AddPair('text', Value))
    .Add(Url.Detach);

  Result := TChatMessagePayload(Add('content', JSONArray));
end;

function TChatMessagePayload.Prefix(const Value: Boolean): TChatMessagePayload;
begin
  Result := TChatMessagePayload(Add('prefix', Value));
end;

function TChatMessagePayload.Role(const Value: TMessageRole): TChatMessagePayload;
begin
  Result := TChatMessagePayload(Add('role', Value.ToString));
end;

class function TChatMessagePayload.System(
  const Value: TArray<string>): TChatMessagePayload;
begin
  Result := TChatMessagePayload.Create.Role(TMessageRole.system).Content(Value);
end;

class function TChatMessagePayload.System(const Value: string): TChatMessagePayload;
begin
  Result := TChatMessagePayload.Create.Role(TMessageRole.system).Content(Value);
end;

function TChatMessagePayload.ToolCalls(
  const Value: TArray<TToolCalls>): TChatMessagePayload;
begin
  if Length(Value) = 0 then
    Exit(Self);

  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TChatMessagePayload(Add('tool_calls', JSONArray));
end;

class function TChatMessagePayload.User(const Value: string;
  const Url: TDocumentUrlParams): TChatMessagePayload;
begin
  Result := TChatMessagePayload.Create.Role(TMessageRole.user).Content(Value, Url);
end;

class function TChatMessagePayload.User(const Value,
  Url: string): TChatMessagePayload;
begin
  var JSONArray := TJSONArray.Create;
  JSONArray.Add(TMessageContent.Create.&Type(TContentType.input_audio).InputAudio(AudioUrlCheck(Url)).Detach);
  JSONArray.Add(TMessageContent.Create.&Type(TContentType.text).Text(Value).Detach);
  Result := TChatMessagePayload.Create.Role(TMessageRole.user).Content(JSONArray);
end;

class function TChatMessagePayload.User(const Value: string;
  const Url: TArray<string>): TChatMessagePayload;
begin
  var JSONArray := TJSONArray.Create;
  JSONArray.Add(TMessageContent.Create.&Type(TContentType.text).Text(Value).Detach);
  for var Item in Url do
    JSONArray.Add(TMessageContent.Create.&Type(TContentType.image_url).ImageUrl(ImageUrlCheck(Item)).Detach);
  Result := TChatMessagePayload.Create.Role(TMessageRole.user).Content(JSONArray);
end;

class function TChatMessagePayload.User(const Value: string): TChatMessagePayload;
begin
  Result := TChatMessagePayload.Create.Role(TMessageRole.user).Content(Value);
end;

class function TChatMessagePayload.Assistant(const Value: string;
  const Url: TArray<string>;
  const Func: TArray<TToolCalls>;
  const Prefix: Boolean = False): TChatMessagePayload;
begin
  Result := User(Value, Url);
  Result := Result.ToolCalls(Func).Prefix(Prefix);
end;

{ TMessageContent }

function TMessageContent.ImageUrl(const Url: string): TMessageContent;
begin
  Result := TMessageContent(Add('image_url', Url));
end;

function TMessageContent.ImageUrl(const Url, Detail: string): TMessageContent;
begin
  var Value := TMessageImageURL.Create.Url(Url);
  if not Detail.IsEmpty then
    Value := Value.Detail(Detail);
  Result := TMessageContent(Add('image_url', Value.Detach));
end;

function TMessageContent.InputAudio(const Url: string): TMessageContent;
begin
  Result := TMessageContent(Add('input_audio', Url));
end;

function TMessageContent.Text(const Value: string): TMessageContent;
begin
  Result := TMessageContent(Add('text', Value));
end;

function TMessageContent.&Type(const Value: TContentType): TMessageContent;
begin
  Result := TMessageContent(Add('type', Value.ToString));
end;

{ TMessageImageURL }

function TMessageImageURL.Detail(const Value: string): TMessageImageURL;
begin
  Result := TMessageImageURL(Add('detail', Value));
end;

function TMessageImageURL.Url(const Value: string): TMessageImageURL;
begin
  Result := TMessageImageURL(Add('url', Value));
end;

{ TToolCalls }

function TToolCalls.&Type(const Value: TToolType): TToolCalls;
begin
  Result := TToolCalls(Add('type', Value.ToString));
end;

function TToolCalls.Func(const Name: string; Arguments: string): TToolCalls;
begin
  var Value := TFunctionCalled.Create.Name(Name).Arguments(Arguments);
  Result := TToolCalls(Add('function', Value.Detach));
end;

function TToolCalls.Id(const Value: string): TToolCalls;
begin
  Result := TToolCalls(Add('id', Value));
end;

function TToolCalls.Index(const Value: Integer): TToolCalls;
begin
  Result := TToolCalls(Add('index', Value));
end;

class function TToolCalls.New(Name, Arguments: string): TToolCalls;
begin
  Result := New.Func(Name, Arguments);
end;

class function TToolCalls.New(Id, Name, Arguments: string): TToolCalls;
begin
  Result := New.Id(Id).Func(Name, Arguments);
end;

class function TToolCalls.New: TToolCalls;
begin
  Result := TToolCalls.Create.&Type();
end;

{ TFunctionCalled }

function TFunctionCalled.Arguments(const Value: string): TFunctionCalled;
begin
  Result := TFunctionCalled(Add('arguments', Value));
end;

function TFunctionCalled.Name(const Value: string): TFunctionCalled;
begin
  Result := TFunctionCalled(Add('name', Value));
end;

{ TMessageContentImageUrl }

destructor TMessageContentImageUrl.Destroy;
begin
  if Assigned(FImageUrl) then
    FImageUrl.Free;
  inherited;
end;

{ TMessageContentThinking }

destructor TMessageContentThinking.Destroy;
begin
  for var Item in FThinking do
    Item.Free;
  inherited;
end;

{ TDocumentUrlParams }

function TDocumentUrlParams.DocumentUrl(
  const Value: string): TDocumentUrlParams;
begin
  Result := TDocumentUrlParams(Add('document_url', Value));
end;

class function TDocumentUrlParams.New: TDocumentUrlParams;
begin
  Result := TDocumentUrlParams.Create.&Type();
end;

function TDocumentUrlParams.&Type(const Value: string): TDocumentUrlParams;
begin
  Result := TDocumentUrlParams(Add('type', Value));
end;

end.

unit MistralAI.Classifiers;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, System.Threading,
  REST.Json.Types, System.NetEncoding, MistralAI.API.Params, MistralAI.API,
  MistralAI.Chat, MistralAI.Functions.Tools, MistralAI.Async.Params,
  MistralAI.Async.Support, MistralAI.Types, MistralAI.Async.Promise;

type
  /// <summary>
  /// <c>TModerationParams</c> class to manage params for guardrails in a text.
  /// </summary>
  /// <remarks>
  /// The policy threshold is determined based on the optimal performance of oan internal test set.
  /// You can use the raw score or adjust the threshold according to your specific use cases.
  /// </remarks>
  TModerationParams = class(TJSONParam)
  public
    /// <summary>
    /// Text submitted for moderation
    /// </summary>
    /// <returns>
    /// The updated <c>TModerationParams</c> instance.
    /// </returns>
    function Input(const Value: string): TModerationParams; overload;

    /// <summary>
    /// Array of text submitted for moderation
    /// </summary>
    /// <returns>
    /// The updated <c>TModerationParams</c> instance.
    /// </returns>
    function Input(const Value: TArray<string>): TModerationParams; overload;

    /// <summary>
    /// Model for guardraile (e.g. mistral-moderation-latest)
    /// </summary>
    /// <returns>
    /// The updated <c>TModerationParams</c> instance.
    /// </returns>
    function Model(const Value: string): TModerationParams;
  end;

  /// <summary>
  /// <c>TModerationChatParams</c> class to manage params for guardrails in a chat generation.
  /// </summary>
  /// <remarks>
  /// The policy threshold is determined based on the optimal performance of oan internal test set.
  /// You can use the raw score or adjust the threshold according to your specific use cases.
  /// </remarks>
  TModerationChatParams = class(TJSONParam)
  public
    /// <summary>
    /// Provides the prompt(s) for the model to generate completions from, structured as a list of messages with roles (user, assistant, system) and content.
    /// </summary>
    /// <param name="Value">An array of <c>TChatMessagePayload</c> representing the messages in the conversation.</param>
    /// <returns>
    /// The updated <c>TModerationChatParams</c> instance.
    /// </returns>
    function Input(const Value: TArray<TChatMessagePayload>): TModerationChatParams;

    /// <summary>
    /// Model for guardraile (e.g. mistral-moderation-latest)
    /// </summary>
    /// <returns>
    /// The updated <c>TModerationChatParams</c> instance.
    /// </returns>
    function Model(const Value: string): TModerationChatParams;
  end;

  /// <summary>
  /// <c>TModerationCategories</c> class defines the categories for moderation checks.
  /// </summary>
  /// <remarks>
  /// This class provides a structured representation of the moderation categories
  /// used to evaluate the content against predefined guardrails. Each property corresponds
  /// to a specific moderation category and indicates whether the content violates that category.
  /// </remarks>
  TModerationCategories = class
  private
    FSexual: Boolean;
    FHate_and_discrimination: Boolean;
    FViolence_and_threats: Boolean;
    FDangerous_and_criminal_content: Boolean;
    FSelfharm: Boolean;
    FHealth: Boolean;
    FFinancial: Boolean;
    FLaw: Boolean;
    FPii: Boolean;
  public
    /// <summary>
    /// Indicates whether the content depicts or promotes explicit sexual material.
    /// </summary>
    /// <remarks>
    /// This includes content explicitly describing sexual activities, nudity, or solicitation for
    /// sexual purposes. Educational or medical content about sexual health in a non-explicit,
    /// informational context is generally exempted.
    /// </remarks>
    property Sexual: Boolean read FSexual write FSexual;

    /// <summary>
    /// Indicates whether the content expresses prejudice or advocates discrimination.
    /// </summary>
    /// <remarks>
    /// This category covers content that targets individuals or groups based on protected
    /// characteristics such as race, ethnicity, religion, gender, sexual orientation, or disability.
    /// </remarks>
    property Hate_and_discrimination: Boolean read FHate_and_discrimination write FHate_and_discrimination;

    /// <summary>
    /// Indicates whether the content glorifies, incites, or threatens physical violence.
    /// </summary>
    /// <remarks>
    /// This includes content that graphically describes injury or death, issues explicit threats,
    /// or provides instructions for carrying out violent acts.
    /// </remarks>
    property Violence_and_threats: Boolean read FViolence_and_threats write FViolence_and_threats;

    /// <summary>
    /// Indicates whether the content promotes dangerous or illegal activities.
    /// </summary>
    /// <remarks>
    /// This category includes guidance on creating weapons, encouragement of extreme risk-taking behaviors,
    /// and promotion of illegal activities such as fraud or drug trafficking.
    /// </remarks>
    property Dangerous_and_criminal_content: Boolean read FDangerous_and_criminal_content write FDangerous_and_criminal_content;

    /// <summary>
    /// Indicates whether the content promotes self-harm or related behaviors.
    /// </summary>
    /// <remarks>
    /// This includes encouragement or glorification of deliberate self-injury, suicide, eating disorders,
    /// or other self-destructive behaviors.
    /// </remarks>
    property Selfharm: Boolean read FSelfharm write FSelfharm;

    /// <summary>
    /// Indicates whether the content contains or elicits medical advice.
    /// </summary>
    /// <remarks>
    /// This applies to detailed or tailored medical advice that is not appropriate for non-expert contexts.
    /// </remarks>
    property Health: Boolean read FHealth write FHealth;

    /// <summary>
    /// Indicates whether the content contains or elicits financial advice.
    /// </summary>
    /// <remarks>
    /// This applies to detailed or tailored financial advice that may not align with ethical or legal standards.
    /// </remarks>
    property Financial: Boolean read FFinancial write FFinancial;

    /// <summary>
    /// Indicates whether the content contains or elicits legal advice.
    /// </summary>
    /// <remarks>
    /// This applies to detailed or tailored legal advice that should not be provided in a general context.
    /// </remarks>
    property Law: Boolean read FLaw write FLaw;

    /// <summary>
    /// Indicates whether the content involves personal identifying information (PII).
    /// </summary>
    /// <remarks>
    /// This category applies to content requesting, sharing, or attempting to elicit PII such as names,
    /// addresses, phone numbers, or financial account details.
    /// </remarks>
    property Pii: Boolean read FPii write FPii;
  end;

  /// <summary>
  /// <c>TModerationScores</c> class defines the scoring system for moderation categories.
  /// </summary>
  /// <remarks>
  /// This class provides a structured representation of the scores associated with each moderation category.
  /// Each property contains a numerical value indicating the likelihood that the content violates the corresponding category.
  /// </remarks>
  TModerationScores = class
  private
    FSexual: Double;
    FHate_and_discrimination: Double;
    FViolence_and_threats: Double;
    FDangerous_and_criminal_content: Double;
    FSelfharm: Double;
    FHealth: Double;
    FFinancial: Double;
    FLaw: Double;
    FPii: Double;
  public
    /// <summary>
    /// Numerical score indicating the likelihood of explicit sexual content.
    /// </summary>
    /// <remarks>
    /// Higher scores suggest a higher probability that the content explicitly depicts or promotes
    /// sexual activities, nudity, or solicitation for sexual purposes.
    /// </remarks>
    property Sexual: Double read FSexual write FSexual;

    /// <summary>
    /// Numerical score indicating the likelihood of hateful or discriminatory content.
    /// </summary>
    /// <remarks>
    /// Higher scores suggest a higher probability that the content targets individuals or groups based
    /// on protected characteristics such as race, ethnicity, religion, gender, or sexual orientation.
    /// </remarks>
    property Hate_and_discrimination: Double read FHate_and_discrimination write FHate_and_discrimination;

    /// <summary>
    /// Numerical score indicating the likelihood of violent or threatening content.
    /// </summary>
    /// <remarks>
    /// Higher scores suggest a higher probability that the content glorifies, incites, or threatens
    /// physical violence or provides instructions for violent acts.
    /// </remarks>
    property Violence_and_threats: Double read FViolence_and_threats write FViolence_and_threats;

    /// <summary>
    /// Numerical score indicating the likelihood of dangerous or illegal content.
    /// </summary>
    /// <remarks>
    /// Higher scores suggest a higher probability that the content promotes or provides instructions
    /// for illegal or haza
    property Dangerous_and_criminal_content: Double read FDangerous_and_criminal_content write FDangerous_and_criminal_content;

    /// <summary>
    /// Numerical score indicating the likelihood of content promoting self-harm.
    /// </summary>
    /// <remarks>
    /// Higher scores suggest a higher probability that the content encourages or glorifies
    /// deliberate self-injury, suicide, or other self-destructive behaviors.
    /// </remarks>
    property Selfharm: Double read FSelfharm write FSelfharm;

    /// <summary>
    /// Numerical score indicating the likelihood of content containing medical advice.
    /// </summary>
    /// <remarks>
    /// Higher scores suggest a higher probability that the content contains or attempts to elicit
    /// detailed or tailored medical advice.
    /// </remarks>
    property Health: Double read FHealth write FHealth;

    /// <summary>
    /// Numerical score indicating the likelihood of content containing financial advice.
    /// </summary>
    /// <remarks>
    /// Higher scores suggest a higher probability that the content contains or attempts to elicit
    /// detailed or tailored financial advice.
    /// </remarks>
    property Financial: Double read FFinancial write FFinancial;

    /// <summary>
    /// Numerical score indicating the likelihood of content containing legal advice.
    /// </summary>
    /// <remarks>
    /// Higher scores suggest a higher probability that the content contains or attempts to elicit
    /// detailed or tailored legal advice.
    /// </remarks>
    property Law: Double read FLaw write FLaw;

    /// <summary>
    /// Numerical score indicating the likelihood of content involving personal identifying information (PII).
    /// </summary>
    /// <remarks>
    /// Higher scores suggest a higher probability that the content requests, shares, or attempts
    /// to elicit personal information such as names, addresses, phone numbers, or financial details.
    /// </remarks>
    property Pii: Double read FPii write FPii;
  end;

  /// <summary>
  /// Represents a warning item in the moderation results, containing the category and its associated score.
  /// </summary>
  /// <remarks>
  /// This record is used to store information about a specific moderation category violation,
  /// including the category name and the numerical score indicating the likelihood of the violation.
  /// </remarks>
  TWarningItem = record
  private
    FCategory: string;
    FScore: Double;
  public
    /// <summary>
    /// Gets or sets the name of the moderation category.
    /// </summary>
    /// <value>
    /// A <c>string</c> representing the name of the category, such as "Sexual" or "Hate_and_discrimination."
    /// </value>
    property Category: string read FCategory write FCategory;

    /// <summary>
    /// Gets or sets the numerical score indicating the likelihood of a violation in the category.
    /// </summary>
    /// <value>
    /// A <c>Double</c> representing the likelihood score, where higher values indicate a greater likelihood of a violation.
    /// </value>
    property Score: Double read FScore write FScore;

    /// <summary>
    /// Creates a new instance of <c>TWarningItem</c> with the specified category and score.
    /// </summary>
    /// <param name="Category">
    /// The name of the moderation category.
    /// </param>
    /// <param name="Score">
    /// The numerical score associated with the category.
    /// </param>
    /// <returns>
    /// A new <c>TWarningItem</c> instance containing the specified category and score.
    /// </returns>
    class function Create(const Category: string; const Score: Double): TWarningItem; static;
  end;

  /// <summary>
  /// <c>TModerationResult</c> class represents the results of a moderation check.
  /// </summary>
  /// <remarks>
  /// This class contains information about the moderation categories and their associated scores.
  /// It provides a detailed breakdown of whether content violates predefined moderation categories
  /// and the likelihood of such violations.
  /// </remarks>
  TModerationResult = class
  strict private
    function GetWarning: Boolean;
  private
    FCategories: TModerationCategories;
    FCategory_scores: TModerationScores;
  public
    /// <summary>
    /// Retrieves an array of warning items for categories that have been flagged as violations.
    /// </summary>
    /// <remarks>
    /// This method analyzes the moderation results and returns a list of warning items,
    /// where each item contains the category name and its associated score. Only categories
    /// with a flagged status (true) in the moderation result are included in the returned array.
    /// </remarks>
    /// <returns>
    /// An array of <c>TWarningItem</c> instances, each representing a flagged moderation category
    /// along with its likelihood score.
    /// </returns>
    function Warnings: TArray<TWarningItem>;

    /// <summary>
    /// Contains the categories indicating whether the content violates specific moderation guardrails.
    /// </summary>
    /// <remarks>
    /// Each property within <c>TModerationCategories</c> indicates whether a particular category is violated.
    /// These categories include areas such as sexual content, hate speech, violence, and others.
    /// </remarks>
    property Categories: TModerationCategories read FCategories write FCategories;

    /// <summary>
    /// Contains the scores for each moderation category, indicating the likelihood of violations.
    /// </summary>
    /// <remarks>
    /// Each property within <c>TModerationScores</c> represents a numerical score. Higher scores suggest
    /// a greater probability that the content violates the corresponding category.
    /// </remarks>
    property Scores: TModerationScores read FCategory_scores write FCategory_scores;

    /// <summary>
    /// Returns true if at least one of the moderation categories is active.
    /// </summary>
    property Warning: Boolean read GetWarning;

    /// <summary>
    /// Destructor for the <c>TModerationResult</c> class.
    /// </summary>
    /// <remarks>
    /// Ensures proper cleanup of dynamically allocated resources, including the
    /// <c>Categories</c> and <c>Scores</c> objects.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// <c>TModeration</c> class represents the overall result of a moderation request.
  /// </summary>
  /// <remarks>
  /// This class provides a high-level summary of the moderation operation,
  /// including the request ID, the model used for moderation, and the detailed results
  /// for each category and score. It is the main structure returned by the moderation API.
  /// </remarks>
  TModeration = class(TJSONFingerprint)
  private
    FId: string;
    FModel: string;
    FResults: TArray<TModerationResult>;
  public
    /// <summary>
    /// Unique identifier for the moderation request.
    /// </summary>
    /// <remarks>
    /// This property is useful for tracking or referencing specific moderation operations.
    /// </remarks>
    property Id: string read FId write FId;

    /// <summary>
    /// Name of the model used to process the moderation request.
    /// </summary>
    /// <remarks>
    /// Typically, this is the versioned name of the moderation model, such as
    /// "mistral-moderation-latest".
    /// </remarks>
    property Model: string read FModel write FModel;

    /// <summary>
    /// Array of detailed moderation results.
    /// </summary>
    /// <remarks>
    /// Each element in this array represents a separate result for a moderation check,
    /// containing both category flags and likelihood scores.
    /// </remarks>
    property Results: TArray<TModerationResult> read FResults write FResults;

    /// <summary>
    /// Destructor for the <c>TModeration</c> class.
    /// </summary>
    /// <remarks>
    /// Ensures proper cleanup of dynamically allocated resources, particularly the array
    /// of <c>TModerationResult</c> objects.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous chat Callbacks for a chat request using <c>TModeration</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynModeration</c> type extends the <c>TAsynParams&lt;TModeration&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynModeration = TAsyncCallback<TModeration>;

  /// <summary>
  /// Defines a promise-style callback wrapper for moderation results.
  /// </summary>
  /// <remarks>
  /// <c>TPromiseModeration</c> is an alias of <c>TPromiseCallBack&lt;TModeration&gt;</c>,
  /// providing a streamlined way to handle asynchronous moderation operations
  /// that yield a <c>TModeration</c> instance when completed.
  /// </remarks>
  TPromiseModeration = TPromiseCallback<TModeration>;

  /// <summary>
  /// <c>TClassifiersRoute</c> class provides an interface to interact with the MistralAI API for moderation tasks.
  /// </summary>
  /// <remarks>
  /// This class serves as a route handler for moderation-related operations, including both synchronous and asynchronous processing.
  /// It allows developers to send text or chat messages for moderation and receive structured feedback on their compliance with predefined guardrails.
  /// The available methods support various moderation scenarios, including text and conversational data.
  /// </remarks>
  TClassifiersRoute = class(TMistralAIAPIRoute)
    /// <summary>
    /// Initiates a moderation request and returns a promise that resolves with the result.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TModerationParams</c> for the moderation call.
    /// </param>
    /// <param name="Callbacks">
    /// An optional factory function that provides a <c>TPromiseModeration</c> to handle
    /// lifecycle events (OnStart, OnSuccess, OnError) during the asynchronous operation.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TModeration&gt;</c> which will complete with the <c>TModeration</c> result.
    /// </returns>
    function AsyncAwaitModeration(const ParamProc: TProc<TModerationParams>;
      const Callbacks: TFunc<TPromiseModeration> = nil): TPromise<TModeration>;

    /// <summary>
    /// Initiates a chat-based moderation request and returns a promise with the outcome.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TModerationChatParams</c>, including the chat messages to be evaluated.
    /// </param>
    /// <param name="Callbacks">
    /// An optional factory function that supplies a <c>TPromiseModeration</c> for handling
    /// lifecycle Callbacks (OnStart, OnSuccess, OnError) during the asynchronous operation.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TModeration&gt;</c> that resolves with the <c>TModeration</c> result of the chat evaluation.
    /// </returns>
    function AsyncAwaitModerationChat(const ParamProc: TProc<TModerationChatParams>;
      const Callbacks: TFunc<TPromiseModeration> = nil): TPromise<TModeration>;

    /// <summary>
    /// Submit a text for moderation
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TModerationParams</c> parameters.
    /// </param>
    /// <param name="Callbacks">
    /// A function that returns <c>TAsynModeration</c> to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// <para>
    /// The <c>Callbacks</c> function is invoked when the operation completes, either successfully or with an error.
    /// </para>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var MistralAI := TMistralAIFactory.CreateInstance(BaererKey);
    /// MistralAI.AsynModeration(
    ///   procedure (Params: TModerationParams)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynModeration
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TModeration)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncModeration(const ParamProc: TProc<TModerationParams>;
      const Callbacks: TFunc<TAsynModeration>);

    /// <summary>
    /// Submit a text in a chat generation system for moderation.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TModerationChatParams</c> parameters.
    /// </param>
    /// <param name="Callbacks">
    /// A function that returns <c>TAsynModeration</c> to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// <para>
    /// The <c>Callbacks</c> function is invoked when the operation completes, either successfully or with an error.
    /// </para>
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var MistralAI := TMistralAIFactory.CreateInstance(BaererKey);
    /// MistralAI.AsynModerationChat(
    ///   procedure (Params: TModerationChatParams)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynModeration
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TModeration)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncModerationChat(const ParamProc: TProc<TModerationChatParams>;
      const Callbacks: TFunc<TAsynModeration>);

    /// <summary>
    /// Submit a text for moderation
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TModerationParams</c> parameters.
    /// </param>
    /// <returns>
    /// A <c>TModeration</c> object containing the AudioToAudio result.
    /// </returns>
    /// <remarks>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var MistralAI := TMistralAIFactory.CreateInstance(BaererKey);
    /// var Value := MistralAI.Moderation(
    ///     procedure (Params: TModerationParams)
    ///     begin
    ///       // Define parameters
    ///     end;
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function Moderation(const ParamProc: TProc<TModerationParams>): TModeration;

    /// <summary>
    /// Submit a text in a chat generation system for moderation.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TModerationChatParams</c> parameters.
    /// </param>
    /// <returns>
    /// A <c>TModeration</c> object containing the AudioToAudio result.
    /// </returns>
    /// <remarks>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var MistralAI := TMistralAIFactory.CreateInstance(BaererKey);
    /// var Value := MistralAI.ModerationChat(
    ///     procedure (Params: TModerationChatParams)
    ///     begin
    ///       // Define parameters
    ///     end;
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function ModerationChat(const ParamProc: TProc<TModerationChatParams>): TModeration;
  end;

implementation

{ TModerationParams }

function TModerationParams.Input(const Value: string): TModerationParams;
begin
  Result := TModerationParams(Add('input', Value));
end;

function TModerationParams.Input(
  const Value: TArray<string>): TModerationParams;
begin
  Result := TModerationParams(Add('input', Value));
end;

function TModerationParams.Model(const Value: string): TModerationParams;
begin
  Result := TModerationParams(Add('model', Value));
end;

{ TModerationResult }

destructor TModerationResult.Destroy;
begin
  if Assigned(FCategories) then
    FCategories.Free;
  if Assigned(FCategory_scores) then
    FCategory_scores.Free;
  inherited;
end;

function TModerationResult.GetWarning: Boolean;
begin
  Result := Categories.Sexual or Categories.FHate_and_discrimination or
    Categories.Violence_and_threats or Categories.Dangerous_and_criminal_content or
    Categories.Selfharm or Categories.Health or Categories.FFinancial or
    Categories.Law or Categories.Pii;
end;

function TModerationResult.Warnings: TArray<TWarningItem>;
begin
  if Categories.Sexual then
    Result := Result + [TWarningItem.Create(Classifiers[0], Scores.Sexual)];
  if Categories.Hate_and_discrimination then
    Result := Result + [TWarningItem.Create(Classifiers[1], Scores.Hate_and_discrimination)];
  if Categories.Violence_and_threats then
    Result := Result + [TWarningItem.Create(Classifiers[2], Scores.Violence_and_threats)];
  if Categories.Dangerous_and_criminal_content then
    Result := Result + [TWarningItem.Create(Classifiers[3], Scores.Dangerous_and_criminal_content)];
  if Categories.Selfharm then
    Result := Result + [TWarningItem.Create(Classifiers[4], Scores.Selfharm)];
  if Categories.Health then
    Result := Result + [TWarningItem.Create(Classifiers[5], Scores.Health)];
  if Categories.Financial then
    Result := Result + [TWarningItem.Create(Classifiers[6], Scores.Financial)];
  if Categories.Law then
    Result := Result + [TWarningItem.Create(Classifiers[7], Scores.Law)];
  if Categories.Pii then
    Result := Result + [TWarningItem.Create(Classifiers[8], Scores.Pii)];
end;

{ TModeration }

destructor TModeration.Destroy;
begin
  for var Item in FResults do
    Item.Free;
  inherited;
end;

{ TClassifiersRoute }

function TClassifiersRoute.AsyncAwaitModeration(
  const ParamProc: TProc<TModerationParams>;
  const Callbacks: TFunc<TPromiseModeration>): TPromise<TModeration>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TModeration>(
    procedure(const CallbackParams: TFunc<TAsynModeration>)
    begin
      AsyncModeration(ParamProc, CallbackParams);
    end,
    Callbacks);
end;

function TClassifiersRoute.AsyncAwaitModerationChat(
  const ParamProc: TProc<TModerationChatParams>;
  const Callbacks: TFunc<TPromiseModeration>): TPromise<TModeration>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TModeration>(
    procedure(const CallbackParams: TFunc<TAsynModeration>)
    begin
      AsyncModerationChat(ParamProc, CallbackParams);
    end,
    Callbacks);
end;

procedure TClassifiersRoute.AsyncModeration(const ParamProc: TProc<TModerationParams>;
  const Callbacks: TFunc<TAsynModeration>);
begin
  with TAsyncCallBackExec<TAsynModeration, TModeration>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TModeration
      begin
        Result := Self.Moderation(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TClassifiersRoute.AsyncModerationChat(
  const ParamProc: TProc<TModerationChatParams>;
  const Callbacks: TFunc<TAsynModeration>);
begin
  with TAsyncCallBackExec<TAsynModeration, TModeration>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TModeration
      begin
        Result := Self.ModerationChat(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TClassifiersRoute.Moderation(
  const ParamProc: TProc<TModerationParams>): TModeration;
begin
  Result := API.Post<TModeration, TModerationParams>('moderations', ParamProc);
end;

function TClassifiersRoute.ModerationChat(
  const ParamProc: TProc<TModerationChatParams>): TModeration;
begin
  Result := API.Post<TModeration, TModerationChatParams>('chat/moderations', ParamProc);
end;

{ TModerationChatParams }

function TModerationChatParams.Input(
  const Value: TArray<TChatMessagePayload>): TModerationChatParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TModerationChatParams(Add('input', JSONArray));
end;

function TModerationChatParams.Model(
  const Value: string): TModerationChatParams;
begin
  Result := TModerationChatParams(Add('model', Value));
end;

{ TWarningItem }

class function TWarningItem.Create(const Category: string;
  const Score: Double): TWarningItem;
begin
  Result.Category := Category;
  Result.Score := Score;
end;

end.

unit MistralAI.Codestral;


{-------------------------------------------------------------------------------

   **Important Notice**

   To utilize the classes managing the Codestral function, you are required to
   create a new KEY on the Mistral.ai website. Please note that obtaining this
   key necessitates providing a valid phone number.

   https://console.mistral.ai/codestral

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

-------------------------------------------------------------------------------}


interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, REST.Json.Types,
  System.Threading, MistralAI.API.Params, MistralAI.API, MistralAI.Async.Support,
  MistralAI.Async.Params, MistralAI.Functions.Tools, MistralAI.Types,
  MistralAI.Async.Promise;

type
  /// <summary>
  /// The <c>TCodestralParams</c> class represents the set of parameters used to configure the behavior and output generation of the Codestral model.
  /// </summary>
  /// <remarks>
  /// This class allows you to define various settings that control how the model generates completions, including which model to use, the temperature of the output,
  /// and how many tokens to generate. By using this class, you can customize the model's response and fine-tune its behavior to suit the specific requirements of your application.
  /// <para>
  /// It inherits from <c>TJSONParam</c>, which provides methods for handling and serializing the parameters as JSON, enabling easy integration
  /// with JSON-based APIs. The parameters include options for setting prompts, suffixes, streaming preferences, and random seeds, among others.
  /// </para>
  /// <code>
  /// var
  ///   Params: TCodestralParams;
  /// begin
  ///   Params := TCodestralParams.Create
  ///     .Model('codestral-latest')
  ///     .Prompt('Generate a code snippet')
  ///     .MaxTokens(100)
  ///     .Temperature(0.7)
  ///     .TopP(0.9)
  ///     .Stop(['\n\n'])
  ///     .Stream(True);          // or Stream();
  /// end;
  /// </code>
  /// This example demonstrates how to instantiate and configure a <c>TCodestralParams</c> object to generate a code snippet using the Codestral model.
  /// </remarks>
  TCodestralParams = class(TJSONParam)
    /// <summary>
    /// Sets the text or code to be completed by the model.
    /// </summary>
    /// <param name="Value">
    /// The prompt text or code that the model should complete.
    /// This parameter is required and serves as the starting point for the model's generation.
    /// </param>
    /// <returns>
    /// The updated <c>TCodestralParams</c> instance.
    /// </returns>
    /// <remarks>
    /// The <c>Prompt</c> parameter is mandatory and provides the initial context that the model will use to generate a response.
    /// </remarks>
    function Prompt(const Value: string): TCodestralParams;

    /// <summary>
    /// Sets an optional suffix that provides additional context for the model.
    /// If both a prompt and a suffix are provided, the model will generate text to fill the space between them.
    /// </summary>
    /// <param name="Value">
    /// The suffix text that follows the content generated by the model.
    /// This helps guide the model on how to conclude the generation.
    /// </param>
    /// <returns>
    /// The updated <c>TCodestralParams</c> instance.
    /// </returns>
    function Suffix(const Value: string): TCodestralParams;

    /// <summary>
    /// Specifies the identifier of the model to use.
    /// Currently compatible with "codestral-2405" or "codestral-latest".
    /// </summary>
    /// <param name="Value">
    /// The model ID to be used for the completion.
    /// Ensure that the specified model is supported and correctly spelled.
    /// </param>
    /// <returns>
    /// The updated <c>TCodestralParams</c> instance.
    /// </returns>
    /// <remarks>
    /// This parameter is required and determines which model will process the request.
    /// </remarks>
    function Model(const Value: string): TCodestralParams;

    /// <summary>
    /// Sets the sampling temperature to use for the model's output.
    /// Higher values like 0.8 make the output more random, while lower values like 0.2 make it more focused and deterministic.
    /// </summary>
    /// <param name="Value">
    /// The temperature value between 0.0 and 1.0. Default is 0.7.
    /// A temperature of 0 makes the model deterministic, while a temperature of 1 allows for maximum creativity.
    /// </param>
    /// <returns>
    /// The updated <c>TCodestralParams</c> instance.
    /// </returns>
    function Temperature(const Value: Single): TCodestralParams;

    /// <summary>
    /// Sets the nucleus sampling probability mass for the model (Top-p).
    /// For example, 0.1 means only the tokens comprising the top 10% probability mass are considered.
    /// </summary>
    /// <param name="Value">
    /// The <c>top_p</c> value between 0.0 and 1.0. Default is 1.
    /// Lower values limit the model to consider only the most probable options.
    /// </param>
    /// <returns>
    /// The updated <c>TCodestralParams</c> instance.
    /// </returns>
    function TopP(const Value: Single): TCodestralParams;

    /// <summary>
    /// Sets the maximum number of tokens to generate in the completion.
    /// The total token count of your prompt plus <c>max_tokens</c> cannot exceed the model's context length.
    /// </summary>
    /// <param name="Value">
    /// The maximum number of tokens to generate.
    /// Choose an appropriate value based on your prompt length to avoid exceeding the model's limit.
    /// </param>
    /// <returns>
    /// The updated <c>TCodestralParams</c> instance.
    /// </returns>
    function MaxTokens(const Value: Integer): TCodestralParams;

    /// <summary>
    /// Sets the minimum number of tokens to generate in the completion.
    /// The model will continue generating tokens until this minimum is reached, unless a stop sequence is encountered.
    /// </summary>
    /// <param name="Value">
    /// The minimum number of tokens the model should generate.
    /// Use this parameter to ensure a response of a certain minimum length.
    /// </param>
    /// <returns>
    /// The updated <c>TCodestralParams</c> instance.
    /// </returns>
    function MinTokens(const Value: Integer): TCodestralParams;

    /// <summary>
    /// Specifies whether to stream back partial progress as server-sent events (SSE).
    /// If <c>true</c>, tokens are sent as they become available.
    /// If <c>false</c>, the server will hold the request open until timeout or completion.
    /// </summary>
    /// <param name="Value">
    /// A boolean value indicating whether to enable streaming. Default is <c>true</c>, meaning streaming is enabled by default.
    /// </param>
    /// <returns>
    /// The updated <c>TCodestralParams</c> instance.
    /// </returns>
    function Stream(const Value: Boolean = True): TCodestralParams;

    /// <summary>
    /// Sets the seed for random sampling. If specified, different calls with the same seed will produce deterministic results.
    /// </summary>
    /// <param name="Value">
    /// The seed value to use for random sampling.
    /// This can be useful for reproducing results during debugging or testing.
    /// </param>
    /// <returns>
    /// The updated <c>TCodestralParams</c> instance.
    /// </returns>
    function RandomSeed(const Value: Integer): TCodestralParams;

    /// <summary>
    /// Sets the tokens or sequences that will stop the generation process when detected.
    /// </summary>
    /// <param name="Value">
    /// A strings representing the stop tokens or sequences.
    /// Use this parameter to indicate when the model should stop generating, such as specifying a sequence like "\n\n".
    /// </param>
    /// <returns>
    /// The updated <c>TCodestralParams</c> instance.
    /// </returns>
    function Stop(const Value: string): TCodestralParams; overload;

    /// <summary>
    /// Sets the tokens or sequences that will stop the generation process when detected.
    /// </summary>
    /// <param name="Value">
    /// An array of strings representing the stop tokens or sequences.
    /// Use this parameter to indicate when the model should stop generating, such as specifying a sequence like "\n\n".
    /// </param>
    /// <returns>
    /// The updated <c>TCodestralParams</c> instance.
    /// </returns>
    function Stop(const Value: TArray<string>): TCodestralParams; overload;
  end;

  /// <summary>
  /// Represents the token usage statistics for a request, including the number of tokens used in the prompt,
  /// the completion, and the total number of tokens consumed.
  /// </summary>
  /// <remarks>
  /// The <c>TCodestralUsage</c> class provides information on the number of tokens utilized during a request.
  /// This data is essential for understanding the token cost associated with a request, particularly in contexts
  /// where token-based billing is employed, or for monitoring the model's behavior in terms of input and output sizes.
  /// </remarks>
  TCodestralUsage = class
  private
    [JsonNameAttribute('prompt_tokens')]
    FPrompt_tokens: Int64;
    [JsonNameAttribute('completion_tokens')]
    FCompletion_tokens: Int64;
    [JsonNameAttribute('total_tokens')]
    FTotal_tokens: Int64;
  public
    /// <summary>
    /// The number of tokens consumed by the prompt in the request.
    /// </summary>
    /// <remarks>
    /// This property indicates how many tokens were used for the initial input prompt sent to the model.
    /// It helps to assess the portion of the token budget consumed by the user's input or system instructions.
    /// </remarks>
    property PromptTokens: Int64 read FPrompt_tokens write FPrompt_tokens;

    /// <summary>
    /// The number of tokens consumed by the completion generated by the model.
    /// </summary>
    /// <remarks>
    /// The <c>CompletionTokens</c> property tracks the number of tokens used in the model's response.
    /// This is useful for analyzing the token cost of the model's output in relation to the input size.
    /// </remarks>
    property CompletionTokens: Int64 read FCompletion_tokens write FCompletion_tokens;

    /// <summary>
    /// The total number of tokens used for the entire request, including both the prompt and the completion.
    /// </summary>
    /// <remarks>
    /// The <c>TotalTokens</c> property provides the cumulative token usage for a single request,
    /// combining both prompt and completion tokens. This value is crucial for monitoring overall token consumption
    /// and ensuring compliance with token limits or pricing considerations.
    /// </remarks>
    property TotalTokens: Int64 read FTotal_tokens write FTotal_tokens;
  end;

  /// <summary>
  /// Represents a message exchanged in a conversation, containing the role of the sender and the message content.
  /// </summary>
  /// <remarks>
  /// The <c>TCodestralMessage</c> class captures the essential details of a message in a chat interaction,
  /// including the role of the sender (e.g., user or assistant) and the content of the message.
  /// This class is fundamental for managing and interpreting the flow of a conversation, providing context on who sent
  /// the message and what was communicated.
  /// </remarks>
  TCodestralMessage = class
  private
    FRole: string;
    FContent: string;
    [JsonNameAttribute('tool_calls')]
    FToolsCalls: TArray<TCalledFunction>;
    FPrefix: Boolean;
  public
    /// <summary>
    /// The role of the author of this message.
    /// </summary>
    /// <remarks>
    /// The <c>Role</c> property specifies the participant who authored the message. It typically has values like "user" for user input
    /// or "assistant" for responses generated by the AI. This property helps in distinguishing the source of the message within the conversation.
    /// </remarks>
    property Role: string read FRole write FRole;

    /// <summary>
    /// The content of the message.
    /// </summary>
    /// <remarks>
    /// The <c>Content</c> property holds the actual message text. This can be a user query, an AI-generated response, or other relevant information
    /// exchanged during the conversation.
    /// </remarks>
    property Content: string read FContent write FContent;

    /// <summary>
    /// A list of tool calls to be executed for query completion.
    /// </summary>
    /// <remarks>
    /// The <c>ToolsCalls</c> property contains a list of functions or tools that need to be invoked to process the current query further.
    /// This is typically used when the assistant needs to call external APIs or perform specific actions before delivering a final response.
    /// </remarks>
    property ToolsCalls: TArray<TCalledFunction> read FToolsCalls write FToolsCalls;

    /// <summary>
    /// The returned prefix: True or False
    /// </summary>
    property Prefix: Boolean read FPrefix write FPrefix;

    /// <summary>
    /// Destructor to release any resources used by this instance.
    /// </summary>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a single completion option generated by the AI model during a chat or completion interaction.
  /// </summary>
  /// <remarks>
  /// The <c>TCodestralChoices</c> class encapsulates the details of a single choice made by the AI model.
  /// Each instance of this class represents one possible response that the model could generate.
  /// This includes:
  /// - An index indicating the position of this choice among multiple options.
  /// - A complete message response generated by the model.
  /// - Optional deltas representing partial responses in the case of streamed outputs.
  /// - The reason why the model stopped generating tokens.
  /// This class is useful when evaluating multiple response options or handling streaming outputs that build over time.
  /// </remarks>
  TCodestralChoices = class
  private
    FIndex: Int64;
    FMessage: TCodestralMessage;
    [JsonReflectAttribute(ctString, rtString, TCodestralFinishReasonInterceptor)]
    FFinish_reason: TCodestralFinishReason;
    FDelta: TCodestralMessage;
  public
    /// <summary>
    /// Represents the position of this choice within the list of available choices generated by the model.
    /// </summary>
    /// <remarks>
    /// The <c>Index</c> property identifies the index of this particular choice in the set of choices provided by the model.
    /// This helps differentiate between multiple possible responses generated during a completion.
    /// </remarks>
    property Index: Int64 read FIndex write FIndex;

    /// <summary>
    /// The full completion message generated by the AI model based on the provided input or conversation context.
    /// </summary>
    /// <remarks>
    /// The <c>Message</c> property contains the complete message that represents the model's response.
    /// This is typically a detailed reply generated in response to a user prompt or system directive.
    /// </remarks>
    property Message: TCodestralMessage read FMessage write FMessage;

    /// <summary>
    /// A partial message (delta) generated by the model during streaming responses.
    /// </summary>
    /// <remarks>
    /// The <c>Delta</c> property holds incremental content provided when the model streams its response.
    /// This allows for progressively building the final response before it is fully completed.
    /// </remarks>
    property Delta: TCodestralMessage read FDelta write FDelta;

    /// <summary>
    /// Indicates the reason why the model stopped generating tokens.
    /// </summary>
    /// <remarks>
    /// The <c>FinishReason</c> property describes why the generation process ceased. This could be due to reaching a natural end of the response,
    /// hitting a specified stop sequence, or encountering a model constraint like a token limit.
    /// </remarks>
    property FinishReason: TCodestralFinishReason read FFinish_reason write FFinish_reason;

    /// <summary>
    /// Destructor to release resources held by the <c>TCodestralChoices</c> instance.
    /// </summary>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a codestral completion response generated by an AI model, containing metadata,
  /// generated choices, and usage statistics.
  /// </summary>
  /// <remarks>
  /// The <c>TCodestral</c> class encapsulates the results of a completion request made to an AI model.
  /// It includes details such as a unique identifier, the model used, when the completion was created,
  /// the choices generated by the model, and usage statistics.
  /// This class is essential for managing and understanding the results of AI-driven completions,
  /// as well as tracking the underlying usage and response characteristics.
  /// </remarks>
  TCodestral = class(TJSONFingerprint)
  private
    FId: string;
    FObject: string;
    FCreated: Int64;
    FModel: string;
    FChoices: TArray<TCodestralChoices>;
    FUsage: TCodestralUsage;
  public
    /// <summary>
    /// A unique identifier for the codestral completion.
    /// </summary>
    /// <remarks>
    /// The <c>Id</c> property stores a unique string that identifies the specific codestral completion request.
    /// This is useful for tracking and managing individual completions or retrieving the results of a particular request.
    /// </remarks>
    property Id: string read FId write FId;

    /// <summary>
    /// The object type, which is always "codestral.completion".
    /// </summary>
    /// <remarks>
    /// The <c>Object</c> property describes the type of the response. For codestral completions, this value is always "codestral.completion",
    /// providing a clear indication of the response type when working with multiple object types in a system.
    /// </remarks>
    property &Object: string read FObject write FObject;

    /// <summary>
    /// The Unix timestamp (in seconds) of when the codestral completion was created.
    /// </summary>
    /// <remarks>
    /// The <c>Created</c> property contains a Unix timestamp indicating when the AI generated the codestral completion.
    /// This is useful for logging, auditing, or ordering completions chronologically.
    /// </remarks>
    property Created: Int64 read FCreated write FCreated;

    /// <summary>
    /// The model used for the codestral completion.
    /// </summary>
    /// <remarks>
    /// The <c>Model</c> property specifies which AI model was used to generate the codestral completion. This can be helpful
    /// when comparing results across different models or tracking which model versions are producing responses.
    /// </remarks>
    property Model: string read FModel write FModel;

    /// <summary>
    /// A list of codestral completion choices generated by the model.
    /// </summary>
    /// <remarks>
    /// The <c>Choices</c> property holds an array of <c>TCodestralChoices</c> objects, representing different response options
    /// generated by the AI model. There may be multiple choices if the request specified more than one completion.
    /// </remarks>
    property Choices: TArray<TCodestralChoices> read FChoices write FChoices;

    /// <summary>
    /// Usage statistics for the completion request, including token counts for the prompt and completion.
    /// </summary>
    /// <remarks>
    /// The <c>Usage</c> property provides information about the number of tokens consumed during the request, including those
    /// used in the prompt and those generated in the completion. This data is important for monitoring API usage and costs.
    /// </remarks>
    property Usage: TCodestralUsage read FUsage write FUsage;

    /// <summary>
    /// Destructor to clean up resources used by this <c>TCodestral</c> instance.
    /// </summary>
    /// <remarks>
    /// The destructor ensures that any allocated resources, such as the memory for the array of choices or usage statistics, are
    /// properly released when the object is no longer needed.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous chat events for a chat request using <c>TCodestral</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynCode</c> type extends the <c>TAsynParams&lt;TCodestral&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynCode = TAsyncCallback<TCodestral>;

  /// <summary>
  /// Represents a promise-based asynchronous callback for code completion operations using the Codestral model.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TPromiseCallBack&lt;TCodestral&gt;</c> enables awaiting a <see cref="TCodestral"/> result
  /// in promise-style flows. Use it when you need to handle success, error, or cancellation events
  /// for a Codestral completion without blocking the calling thread.
  /// </remarks>
  TPromiseCode = TPromiseCallback<TCodestral>;

  /// <summary>
  /// Manages asynchronous streaming chat events for a chat request using <c>TCodestral</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynCodeStream</c> type extends the <c>TAsynStreamParams&lt;TCodestral&gt;</c> record to support the lifecycle of an asynchronous streaming chat operation.
  /// It provides Callbacks for different stages, including when the operation starts, progresses with new data chunks, completes successfully, or encounters an error.
  /// This structure is ideal for handling scenarios where the chat response is streamed incrementally, providing real-time updates to the user interface.
  /// </remarks>
  TAsynCodeStream = TAsyncStreamCallback<TCodestral>;

  /// <summary>
  /// Represents a promise-based asynchronous streaming callback for code completion operations using the Codestral model.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TPromiseStreamCallBack&lt;TCodestral&gt;</c> enables awaiting both partial results and the final
  /// <see cref="TCodestral"/> response in a promise-style flow. Use it to handle on-progress updates, successful completion,
  /// errors, or cancellation for a streaming Codestral completion without blocking the calling thread.
  /// </remarks>
  TPromiseCodeStream = TPromiseStreamCallback<TCodestral>;

  /// <summary>
  /// Represents a callback procedure used during the reception of responses from a codestral request in streaming mode.
  /// </summary>
  /// <param name="Codestral">
  /// The <c>TCodestral</c> object containing the current information about the response generated by the model.
  /// If this value is <c>nil</c>, it indicates that the data stream is complete.
  /// </param>
  /// <param name="IsDone">
  /// A boolean flag indicating whether the streaming process is complete.
  /// If <c>True</c>, it means the model has finished sending all response data.
  /// </param>
  /// <param name="Cancel">
  /// A boolean flag that can be set to <c>True</c> within the callback to cancel the streaming process.
  /// If set to <c>True</c>, the streaming will be terminated immediately.
  /// </param>
  /// <remarks>
  /// This callback is invoked multiple times during the reception of the response data from the model.
  /// It allows for real-time processing of received messages and interaction with the user interface or other systems
  /// based on the state of the data stream.
  /// When the <c>IsDone</c> parameter is <c>True</c>, it indicates that the model has finished responding,
  /// and the <c>Codestral</c> parameter will be <c>nil</c>.
  /// </remarks>
  TCodestralEvent = reference to procedure(var Codestral: TCodestral; IsDone: Boolean; var Cancel: Boolean);

  /// <summary>
  /// The <c>TCodestralRoute</c> class inherits from <c>TMistralAIAPIRoute</c> and provides an interface for managing various interactions with the codestral API.
  /// It supports creating codestral completion requests in synchronous, asynchronous, and streaming modes, offering mechanisms to handle responses generated by the model.
  /// </summary>
  /// <remarks>
  /// This class facilitates sending messages to a codestral model, receiving responses, and managing them, whether synchronously or asynchronously.
  /// The primary methods in the class are:
  /// <list type="bullet">
  /// <item>
  /// <term><c>Create</c></term>
  /// <description>Sends a codestral request and waits for a full response.</description>
  /// </item>
  /// <item>
  /// <term><c>AsyncCreate</c></term>
  /// <description>Performs an asynchronous codestral completion request with event handling.</description>
  /// </item>
  /// <item>
  /// <term><c>CreateStream</c></term>
  /// <description>Initiates a codestral completion request in streaming mode, receiving tokens progressively.</description>
  /// </item>
  /// <item>
  /// <term><c>ASyncCreateStream</c></term>
  /// <description>Performs an asynchronous request in streaming mode with event handling.</description>
  /// </item>
  /// </list>
  /// Each method allows configuring model parameters, setting input messages, managing token limits, and including Callbacks for processing responses or errors.
  /// </remarks>
  TCodestralRoute = class(TMistralAIAPIRoute)
  public
    /// <summary>
    /// Wraps an asynchronous Codestral completion request in a promise-based API.
    /// This method invokes <see cref="AsyncCreate"/> internally and returns a <see cref="TPromise&lt;TCodestral&gt;"/>.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <see cref="TCodestralParams"/> for the request,
    /// such as selecting the model, setting prompts, and adjusting generation options.
    /// </param>
    /// <param name="Callbacks">
    /// An optional function that returns a <see cref="TPromiseCode"/> record containing
    /// event handlers (OnStart, OnSuccess, OnError, etc.) for the asynchronous operation.
    /// </param>
    /// <returns>
    /// A <see cref="TPromise&lt;TCodestral&gt;"/> that resolves with the completed <see cref="TCodestral"/> result
    /// once the operation finishes, or rejects with an exception on error.
    /// </returns>
    /// <remarks>
    /// Use this method when you prefer promise-style flow control over callback handlers.
    /// If <paramref name="Callbacks"/> is nil, default handlers will be used.
    /// </remarks>
    function AsyncAwaitCreate(const ParamProc: TProc<TCodestralParams>;
      const Callbacks: TFunc<TPromiseCode> = nil): TPromise<TCodestral>;

    /// <summary>
    /// Wraps an asynchronous streaming Codestral completion in a promise-based API.
    /// Internally invokes <see cref="AsyncCreateStream"/> and returns a <see cref="TPromise&lt;string&gt;"/>
    /// that resolves with the full concatenated output once streaming is complete.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <see cref="TCodestralParams"/> for the request,
    /// such as selecting the model, setting prompts, enabling streaming, and tuning generation options.
    /// </param>
    /// <param name="Callbacks">
    /// A function that returns a <see cref="TPromiseCodeStream"/> record containing
    /// event handlers (OnStart, OnProgress, OnSuccess, OnError, OnDoCancel, OnCancellation)
    /// to manage the lifecycle of the streaming operation.
    /// </param>
    /// <returns>
    /// A <see cref="TPromise&lt;string&gt;"/> that
    /// <para>
    /// - resolves to the complete concatenated text produced by the stream, or
    /// </para>
    /// <para>
    /// - rejects with an exception if an error occurs or the stream is cancelled.
    /// </para>
    /// </returns>
    /// <remarks>
    /// Use this method when you need promise-style flow control for streaming completions.
    /// The promise buffers each partial <c>Delta.Content</c> and delivers the full result
    /// only after the <c>[DONE]</c> event is received.
    /// </remarks>
    function AsyncAwaitCreateStream(const ParamProc: TProc<TCodestralParams>;
      const Callbacks: TFunc<TPromiseCodeStream>): TPromise<string>;

    /// <summary>
    /// Creates an asynchronous completion for codestral message.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the parameters for the codestral request, such as model selection, messages, and other parameters.
    /// </param>
    /// <param name="Callbacks">
    /// A function that returns a record containing event handlers for the asynchronous codestral completion, such as on success and on error.
    /// </param>
    /// <remarks>
    /// This procedure initiates an asynchronous request to generate a codestral completion based on the provided parameters. The response or error is handled by the provided Callbacks.
    /// <code>
    /// MistralAI.Codestral.AsyncCreate(
    ///   procedure (Params: TChatParams)
    ///   begin
    ///     // Define codestral parameters
    ///   end,
    ///
    ///   function: TAsynCode
    ///   begin
    ///     Result.Sender := Memo1;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Chat: TChat)
    ///     begin
    ///       var M := Sender as TMemo; // Because Result.Sender = Memo1
    ///       // Handle success operation
    ///     end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Value: string)
    ///     begin
    ///       // Handle error message
    ///     end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncCreate(ParamProc: TProc<TCodestralParams>; Callbacks: TFunc<TAsynCode>);

    /// <summary>
    /// Creates an asynchronous streaming codestral completion request.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the codestral request, including the model, messages, and additional options such as max tokens and streaming mode.
    /// </param>
    /// <param name="Callbacks">
    /// A function that returns a <c>TAsynCodeStream</c> record which contains event handlers for managing different stages of the streaming process: progress updates, success, errors, and cancellation.
    /// </param>
    /// <remarks>
    /// This procedure initiates an asynchronous codestral operation in streaming mode, where tokens are progressively received and processed.
    /// The provided event handlers allow for handling progress (i.e., receiving tokens in real time), detecting success, managing errors, and enabling cancellation logic.
    /// <code>
    /// MistralAI.CodeStral.AsyncCreateStream(
    ///   procedure(Params: TChatParams)
    ///   begin
    ///     // Define codestral parameters
    ///     Params.Stream;
    ///   end,
    ///
    ///   function: TAsynCodeStream
    ///   begin
    ///     Result.Sender := Memo1; // Instance passed to callback parameter
    ///     Result.OnProgress :=
    ///         procedure (Sender: TObject; Chat: TChat)
    ///         begin
    ///           // Handle progressive updates to the chat response
    ///         end;
    ///     Result.OnSuccess :=
    ///         procedure (Sender: TObject)
    ///         begin
    ///           // Handle success when the operation completes
    ///         end;
    ///     Result.OnError :=
    ///         procedure (Sender: TObject; Value: string)
    ///         begin
    ///           // Handle error message
    ///         end;
    ///     Result.OnDoCancel :=
    ///         function: Boolean
    ///         begin
    ///           Result := CheckBox1.Checked; // Click on checkbox to cancel
    ///         end;
    ///     Result.OnCancellation :=
    ///         procedure (Sender: TObject)
    ///         begin
    ///           // Processing when process has been canceled
    ///         end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncCreateStream(ParamProc: TProc<TCodestralParams>; Callbacks: TFunc<TAsynCodeStream>);

    /// <summary>
    /// Creates a completion for the codestral message using the provided parameters.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the codestral request, such as selecting the model, providing messages, setting token limits, etc.
    /// </param>
    /// <returns>
    /// Returns a <c>TCodestral</c> object that contains the codestral response, including the choices generated by the model.
    /// </returns>
    /// <exception cref="MistralAIExceptionAPI">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="MistralAIExceptionInvalidRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// The <c>Create</c> method sends a codestral completion request and waits for the full response. The returned <c>TCodestral</c> object contains the model's generated response, including multiple choices if available.
    /// Example usage:
    /// <code>
    ///   var Codestral := MistralAI.Codestral.Create(
    ///     procedure (Params: TCodestralParams)
    ///     begin
    ///       // Define codestral parameters
    ///     end);
    ///   try
    ///     for var Choice in Codestral.Choices do
    ///       WriteLn(Choice.Message.Content);
    ///   finally
    ///     Codestral.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Create(ParamProc: TProc<TCodestralParams>): TCodestral;

    /// <summary>
    /// Creates a codestral message completion with a streamed response.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the codestral request, such as selecting the model, providing messages, and adjusting other settings like token limits or temperature.
    /// </param>
    /// <param name="Event">
    /// A callback of type <c>TCodestralEvent</c> that is triggered with each chunk of data received during the streaming process. It includes the current state of the <c>TCodestral</c> object, a flag indicating if the stream is done, and a boolean to handle cancellation.
    /// </param>
    /// <returns>
    /// Returns <c>True</c> if the streaming process started successfully, <c>False</c> otherwise.
    /// </returns>
    /// <remarks>
    /// This method initiates a codestral request in streaming mode, where the response is delivered incrementally in real-time.
    /// The <c>Event</c> callback will be invoked multiple times as tokens are received.
    /// When the response is complete, the <c>IsDone</c> flag will be set to <c>True</c>, and the <c>Codestral</c> object will be <c>nil</c>.
    /// The streaming process can be interrupted by setting the <c>Cancel</c> flag to <c>True</c> within the event.
    /// Example usage:
    /// <code>
    ///   MistralAI.Codestral.CreateStream(
    ///     procedure (Params: TCodestralParams)
    ///     begin
    ///       // Define codestral parameters
    ///     end,
    ///
    ///     procedure(var Codestral: TCodestral; IsDone: Boolean; var Cancel: Boolean)
    ///     begin
    ///       // Handle displaying
    ///     end
    ///   );
    /// </code>
    /// </remarks>
    function CreateStream(ParamProc: TProc<TCodestralParams>; Event: TCodestralEvent): Boolean;
  end;

implementation

uses
  System.StrUtils, Rest.Json, System.Rtti;

{ TCodestralParams }

function TCodestralParams.MaxTokens(const Value: Integer): TCodestralParams;
begin
  Result := TCodestralParams(Add('max_tokens', Value));
end;

function TCodestralParams.MinTokens(const Value: Integer): TCodestralParams;
begin
  Result := TCodestralParams(Add('min_tokens', Value));
end;

function TCodestralParams.Model(const Value: string): TCodestralParams;
begin
  Result := TCodestralParams(Add('model', Value));
end;

function TCodestralParams.Prompt(const Value: string): TCodestralParams;
begin
  Result := TCodestralParams(Add('prompt', Value));
end;

function TCodestralParams.RandomSeed(const Value: Integer): TCodestralParams;
begin
  Result := TCodestralParams(Add('random_seed', Value));
end;

function TCodestralParams.Stop(const Value: TArray<string>): TCodestralParams;
var
  Items: TJSONArray;
begin
  Items := TJSONArray.Create;
  try
    for var Item in Value do
      begin
        Items.Add(Item);
      end;
  except
    Items.Free;
    raise;
  end;
  Result := TCodestralParams(Add('stop', Items));
end;

function TCodestralParams.Stop(const Value: string): TCodestralParams;
begin
  Result := TCodestralParams(Add('stop', Value));
end;

function TCodestralParams.Stream(const Value: Boolean): TCodestralParams;
begin
  Result := TCodestralParams(Add('stream', Value));
end;

function TCodestralParams.Suffix(const Value: string): TCodestralParams;
begin
  Result := TCodestralParams(Add('suffix', Value));
end;

function TCodestralParams.Temperature(const Value: Single): TCodestralParams;
begin
  Result := TCodestralParams(Add('temperature', Value));
end;

function TCodestralParams.TopP(const Value: Single): TCodestralParams;
begin
  Result := TCodestralParams(Add('top_p', Value));
end;

{ TCodestralChoices }

destructor TCodestralChoices.Destroy;
begin
  if Assigned(FMessage) then
    FMessage.Free;
  if Assigned(FDelta) then
    FDelta.Free;
  inherited;
end;

{ TCodestral }

destructor TCodestral.Destroy;
begin
  if Assigned(FUsage) then
    FUsage.Free;
  for var Item in FChoices do
    Item.Free;
  inherited;
end;

{ TCodestralRoute }

function TCodestralRoute.AsyncAwaitCreate(
  const ParamProc: TProc<TCodestralParams>;
  const Callbacks: TFunc<TPromiseCode>): TPromise<TCodestral>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TCodestral>(
    procedure(const CallbackParams: TFunc<TAsynCode>)
    begin
      AsyncCreate(ParamProc, CallbackParams);
    end,
    Callbacks);
end;

function TCodestralRoute.AsyncAwaitCreateStream(
  const ParamProc: TProc<TCodestralParams>;
  const Callbacks: TFunc<TPromiseCodeStream>): TPromise<string>;
begin
  Result := TPromise<string>.Create(
    procedure(Resolve: TProc<string>; Reject: TProc<Exception>)
    var
      Buffer: string;
    begin
      AsyncCreateStream(ParamProc,
        function : TAsynCodeStream
        begin
          Result.Sender := Callbacks.Sender;

          Result.OnStart := Callbacks.OnStart;

          Result.OnProgress :=
            procedure (Sender: TObject; Event: TCodestral)
            begin
              if Assigned(Callbacks.OnProgress) then
                Callbacks.OnProgress(Sender, Event);
              Buffer := Buffer + Event.FChoices[0].Delta.Content;
            end;

          Result.OnSuccess :=
            procedure (Sender: TObject)
            begin
              Resolve(Buffer);
            end;

          Result.OnError :=
            procedure (Sender: TObject; Error: string)
            begin
              if Assigned(Callbacks.OnError) then
                Error := Callbacks.OnError(Sender, Error);
              Reject(Exception.Create(Error));
            end;

          Result.OnDoCancel :=
            function : Boolean
            begin
              if Assigned(Callbacks.OnDoCancel) then
                Result := Callbacks.OnDoCancel()
              else
                Result := False;
            end;

          Result.OnCancellation :=
            procedure (Sender: TObject)
            begin
              var Error := 'aborted';
              if Assigned(Callbacks.OnCancellation) then
                Error := Callbacks.OnCancellation(Sender);
              Reject(Exception.Create(Error));
            end;
        end);
    end);
end;

procedure TCodestralRoute.AsyncCreate(ParamProc: TProc<TCodestralParams>;
  Callbacks: TFunc<TAsynCode>);
begin
  with TAsyncCallBackExec<TAsynCode, TCodestral>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TCodestral
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TCodestralRoute.AsyncCreateStream(ParamProc: TProc<TCodestralParams>;
  Callbacks: TFunc<TAsynCodeStream>);
begin
  var CallbackParams := TUseParamsFactory<TAsynCodeStream>.CreateInstance(Callbacks);

  var Sender := CallbackParams.Param.Sender;
  var OnStart := CallbackParams.Param.OnStart;
  var OnSuccess := CallbackParams.Param.OnSuccess;
  var OnProgress := CallbackParams.Param.OnProgress;
  var OnError := CallbackParams.Param.OnError;
  var OnCancellation := CallbackParams.Param.OnCancellation;
  var OnDoCancel := CallbackParams.Param.OnDoCancel;

  var Task: ITask := TTask.Create(
          procedure()
          begin
            {--- Pass the instance of the current class in case no value was specified. }
            if not Assigned(Sender) then
              Sender := Self;

            {--- Trigger OnStart callback }
            if Assigned(OnStart) then
              TThread.Queue(nil,
                procedure
                begin
                  OnStart(Sender);
                end);
            try
              var Stop := False;

              {--- Processing }
              CreateStream(ParamProc,
                procedure (var Code: TCodestral; IsDone: Boolean; var Cancel: Boolean)
                begin
                  {--- Check that the process has not been canceled }
                  if Assigned(OnDoCancel) then
                    TThread.Queue(nil,
                        procedure
                        begin
                          Stop := OnDoCancel();
                        end);
                  if Stop then
                    begin
                      {--- Trigger when processus was stopped }
                      if Assigned(OnCancellation) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnCancellation(Sender)
                        end);
                      Cancel := True;
                      Exit;
                    end;
                  if not IsDone and Assigned(Code) then
                    begin
                      var LocalCode := Code;
                      Code := nil;

                      {--- Triggered when processus is progressing }
                      if Assigned(OnProgress) then
                        TThread.Synchronize(TThread.Current,
                        procedure
                        begin
                          try
                            OnProgress(Sender, LocalCode);
                          finally
                            {--- Makes sure to release the instance containing the data obtained
                                 following processing}
                            LocalCode.Free;
                          end;
                        end)
                      else
                        LocalCode.Free;
                    end
                  else
                  if IsDone then
                    begin
                      {--- Trigger OnEnd callback when the process is done }
                      if Assigned(OnSuccess) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnSuccess(Sender);
                        end);
                    end;
                end);
            except
              on E: Exception do
                begin
                  var Error := AcquireExceptionObject;
                  try
                    var ErrorMsg := (Error as Exception).Message;

                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(OnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        OnError(Sender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
          end);
  Task.Start;
end;

function TCodestralRoute.Create(
  ParamProc: TProc<TCodestralParams>): TCodestral;
begin
  Result := API.Post<TCodestral, TCodestralParams>('fim/completions', ParamProc);
end;

function TCodestralRoute.CreateStream(ParamProc: TProc<TCodestralParams>;
  Event: TCodestralEvent): Boolean;
var
  Response: TStringStream;
  RetPos, LineFeed: Integer;
  ResponseBuffer, CurrentLine, Data, NewBuffer: string;
  Chunk: TCodestral;
  IsDone: Boolean;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    RetPos := 0;
    Result := API.Post<TCodestralParams>('fim/completions', ParamProc, Response,
      procedure(const Sender: TObject; AContentLength, AReadCount: Int64; var AAbort: Boolean)
      begin
        try
          ResponseBuffer := Response.DataString;
        except
          on E: EEncodingError do
            Exit;
        end;

        LineFeed := ResponseBuffer.IndexOf(#10, RetPos);
        while LineFeed >= 0 do
          begin
            CurrentLine := ResponseBuffer.Substring(RetPos, LineFeed - RetPos).Trim([' ', #13, #10]);
            Inc(RetPos, LineFeed - RetPos + 1);

            if CurrentLine.IsEmpty then
              begin
                LineFeed := ResponseBuffer.IndexOf(#10, RetPos);
                Continue;
              end;

            if CurrentLine.StartsWith('data: ') then
              Data := CurrentLine.Substring(6).Trim
            else
              Data := CurrentLine;

            IsDone := SameText(Data, '[DONE]');

            Chunk := nil;
            if not IsDone then
              try
                Chunk := TApiDeserializer.Parse<TCodestral>(Data);
              except
                Chunk := nil;
              end;

            if Assigned(Event) then
              try
                Event(Chunk, IsDone, AAbort);
              finally
                Chunk.Free;
              end;

            if IsDone then
              Break;

            LineFeed := ResponseBuffer.IndexOf(#10, RetPos);
          end;

        if RetPos > 0 then
          begin
            NewBuffer := ResponseBuffer.Substring(RetPos);
            Response.Size := 0;
            if NewBuffer <> '' then
              Response.WriteString(NewBuffer);
            RetPos := 0;
          end;
      end);
  finally
    Response.Free;
  end;
end;

{ TCodestralMessage }

destructor TCodestralMessage.Destroy;
begin
  for var Item in FToolsCalls do
    Item.Free;
  inherited;
end;

end.

unit MistralAI.Conversations.Agents;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes,
  MistralAI.API.Params, MistralAI.API, MistralAI.Types, MistralAI.Conversations.Params,
  MistralAI.Async.Params, MistralAI.Async.Support, MistralAI.Async.Promise,
  MistralAI.Conversations.Chunks, MistralAI.Conversations.Manager;

type
  /// <summary>
  /// Defines an asynchronous callback type for operations returning a <see cref="TConversationsAgent"/> instance.
  /// </summary>
  /// <remarks>
  /// <para>
  /// <c>TAsyncConversationsAgent</c> is an alias for <c>TAsyncCallback&lt;TConversationsAgent&gt;</c>,
  /// providing a structured mechanism for handling the lifecycle of asynchronous agent creation or retrieval
  /// calls. Use this callback to register <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c> handlers
  /// when interacting with the <c>TConversationsAgentRoute</c>.
  /// </para>
  /// <para>
  /// The <c>TConversationsAgent</c> returned encapsulates metadata and state associated with a conversation
  /// agent, including its configuration, description, and available tools.
  /// </para>
  /// </remarks>
  TAsyncConversationsAgent = TAsyncCallback<TConversationsAgent>;

  /// <summary>
  /// Defines a promise-based asynchronous callback for operations that return a <see cref="TConversationsAgent"/>.
  /// </summary>
  /// <remarks>
  /// <para>
  /// <c>TPromiseConversationsAgent</c> is an alias for <c>TPromiseCallback&lt;TConversationsAgent&gt;</c>,
  /// providing a task-like interface for creating or retrieving conversation agents asynchronously.
  /// </para>
  /// <para>
  /// Use this promise to await the result of an agent operation—resolving with a <c>TConversationsAgent</c>
  /// instance on success or raising an exception on error.
  /// </para>
  /// </remarks>
  TPromiseConversationsAgent = TPromiseCallback<TConversationsAgent>;

  /// <summary>
  /// Defines an asynchronous callback type for operations returning a <see cref="TConversationsAgentList"/> instance.
  /// </summary>
  /// <remarks>
  /// <para>
  /// <c>TAsyncConversationsAgentList</c> is an alias for <c>TAsyncCallback&lt;TConversationsAgentList&gt;</c>,
  /// providing a structured mechanism for handling the lifecycle of asynchronous calls that list conversation agents.
  /// </para>
  /// <para>
  /// Use this callback to register <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c> handlers when invoking
  /// <c>TConversationsAgentRoute.List</c> or its asynchronous variants.
  /// </para>
  /// <para>
  /// The <c>TConversationsAgentList</c> returned contains metadata and a collection of <c>TConversationsAgent</c>
  /// entries, representing the available agents.
  /// </para>
  /// </remarks>
  TAsyncConversationsAgentList = TAsyncCallback<TConversationsAgentList>;

  /// <summary>
  /// Defines a promise-based asynchronous callback for operations returning a <see cref="TConversationsAgentList"/>.
  /// </summary>
  /// <remarks>
  /// <para>
  /// <c>TPromiseConversationsAgentList</c> is an alias for <c>TPromiseCallback&lt;TConversationsAgentList&gt;</c>,
  /// providing a task-like interface for retrieving a list of conversation agents asynchronously.
  /// </para>
  /// <para>
  /// Use this promise to await the result of a list operation—resolving with a <c>TConversationsAgentList</c>
  /// instance on success or raising an exception on failure.
  /// </para>
  /// </remarks>
  TPromiseConversationsAgentList = TPromiseCallback<TConversationsAgentList>;

  /// <summary>
  /// Provides access to the Conversations Agents API, enabling creation, retrieval, listing, updating, and version management of conversation agents.
  /// </summary>
  /// <remarks>
  /// <para>
  /// <c>TConversationsAgentRoute</c> extends <see cref="TMistralAIAPIRoute"/> to encapsulate HTTP interactions
  /// with the `/agents` endpoints. It offers both synchronous and asynchronous methods for agent lifecycle management.
  /// </para>
  /// <para>
  /// Synchronous operations include <see cref="Create"/>, <see cref="List"/>, <see cref="Retrieve"/>,
  /// <see cref="Update"/>, and <see cref="VersionSwitch"/>. For non-blocking workflows, use the
  /// asynchronous callbacks <see cref="AsyncCreate"/>, <see cref="AsyncList"/>, <see cref="AsyncRetrieve"/>,
  /// <see cref="AsyncUpdate"/>, and <see cref="AsyncVersionSwitch"/>, or their promise-based counterparts
  /// <see cref="AsyncAwaitCreate"/>, <see cref="AsyncAwaitList"/>, <see cref="AsyncAwaitRetrieve"/>,
  /// <see cref="AsyncAwaitUpdate"/>, and <see cref="AsyncAwaitVersionSwitch"/>.
  /// </para>
  /// </remarks>
  TConversationsAgentRoute = class(TMistralAIAPIRoute)

    /// <summary>
    /// Initiates an asynchronous creation of a conversation agent and returns a promise for the result.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <see cref="TConversationsAgentParams"/> for the request, such as model, name, description, tools, and completion arguments.
    /// </param>
    /// <param name="Callbacks">
    /// An optional promise-based callback (<see cref="TPromiseConversationsAgent"/>) to handle lifecycle events:
    /// resolution with a <see cref="TConversationsAgent"/> on success or exception on error.
    /// </param>
    /// <returns>
    /// A <see cref="TPromise{TConversationsAgent}"/> that resolves to the created <see cref="TConversationsAgent"/>.
    /// </returns>
    /// <remarks>
    /// This method wraps the standard <see cref="AsyncCreate"/> callback pattern into a promise-based interface.
    /// Use <c>await</c> on the returned promise to obtain the <see cref="TConversationsAgent"/> once the API call completes.
    /// If <paramref name="Callbacks"/> is provided, its handlers will be invoked during the request lifecycle.
    /// </remarks>
    function AsyncAwaitCreate(
      const ParamProc: TProc<TConversationsAgentParams>;
      const Callbacks: TFunc<TPromiseConversationsAgent> = nil): TPromise<TConversationsAgent>;

    /// <summary>
    /// Initiates an asynchronous request to retrieve the list of conversation agents and returns a promise for the result.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <see cref="TConversationsListParams"/>, such as filtering, pagination, or sorting options.
    /// </param>
    /// <param name="Callbacks">
    /// An optional promise-based callback (<see cref="TPromiseConversationsAgentList"/>) to handle lifecycle events:
    /// resolution with a <see cref="TConversationsAgentList"/> on success or exception on failure.
    /// </param>
    /// <returns>
    /// A <see cref="TPromise{TConversationsAgentList}"/> that resolves to the retrieved list of <see cref="TConversationsAgent"/> instances.
    /// </returns>
    /// <remarks>
    /// This method wraps the <see cref="AsyncList"/> callback pattern into a promise-based interface.
    /// Use <c>await</c> on the returned promise to obtain the <see cref="TConversationsAgentList"/> once the API call completes.
    /// If <paramref name="Callbacks"/> is provided, its handlers will be invoked during the request lifecycle.
    /// </remarks>
    function AsyncAwaitList(
      const ParamProc: TProc<TConversationsListParams>;
      const Callbacks: TFunc<TPromiseConversationsAgentList> = nil): TPromise<TConversationsAgentList>;

    /// <summary>
    /// Initiates an asynchronous request to retrieve a specific conversation agent by its identifier and returns a promise for the result.
    /// </summary>
    /// <param name="AgentId">
    /// The unique identifier of the conversation agent to retrieve.
    /// </param>
    /// <param name="Callbacks">
    /// An optional promise-based callback (<see cref="TPromiseConversationsAgent"/>) to handle lifecycle events:
    /// resolution with a <see cref="TConversationsAgent"/> instance on success or exception on error.
    /// </param>
    /// <returns>
    /// A <see cref="TPromise{TConversationsAgent}"/> that resolves to the requested <see cref="TConversationsAgent"/>.
    /// </returns>
    /// <remarks>
    /// This method wraps the <see cref="AsyncRetrieve"/> callback pattern into a promise-based interface.
    /// Use <c>await</c> on the returned promise to obtain the <see cref="TConversationsAgent"/> once the API call completes.
    /// If <paramref name="Callbacks"/> is provided, its handlers will be invoked during the request lifecycle.
    /// </remarks>
    function AsyncAwaitRetrieve(
      const AgentId: string;
      const Callbacks: TFunc<TPromiseConversationsAgent> = nil): TPromise<TConversationsAgent>;

    /// <summary>
    /// Initiates an asynchronous update of a conversation agent’s settings and returns a promise for the updated agent.
    /// </summary>
    /// <param name="AgentId">
    /// The unique identifier of the conversation agent to update.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure the <see cref="TConversationsAgentParams"/>, such as modifying tools, description, or completion arguments.
    /// </param>
    /// <param name="Callbacks">
    /// An optional promise-based callback (<see cref="TPromiseConversationsAgent"/>) to handle lifecycle events:
    /// resolution with the updated <see cref="TConversationsAgent"/> on success or exception on error.
    /// </param>
    /// <returns>
    /// A <see cref="TPromise{TConversationsAgent}"/> that resolves to the updated <see cref="TConversationsAgent"/>.
    /// </returns>
    /// <remarks>
    /// This method wraps the <see cref="AsyncUpdate"/> callback pattern into a promise-based interface.
    /// Use <c>await</c> on the returned promise to receive the updated agent once the API call completes.
    /// If <paramref name="Callbacks"/> is provided, its handlers will be invoked during the request lifecycle.
    /// </remarks>
    function AsyncAwaitUpdate(
      const AgentId: string;
      const ParamProc: TProc<TConversationsAgentParams>;
      const Callbacks: TFunc<TPromiseConversationsAgent> = nil): TPromise<TConversationsAgent>;

    /// <summary>
    /// Initiates an asynchronous version switch for a conversation agent and returns a promise for the resulting agent.
    /// </summary>
    /// <param name="AgentId">
    /// The unique identifier of the conversation agent whose version will be switched.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure the <see cref="TAgentVersionParams"/>, specifying the target version number.
    /// </param>
    /// <param name="Callbacks">
    /// An optional promise-based callback (<see cref="TPromiseConversationsAgent"/>) to handle lifecycle events:
    /// resolution with the <see cref="TConversationsAgent"/> of the new version on success or exception on error.
    /// </param>
    /// <returns>
    /// A <see cref="TPromise{TConversationsAgent}"/> that resolves to the <see cref="TConversationsAgent"/> switched to the specified version.
    /// </returns>
    /// <remarks>
    /// This method wraps the <see cref="VersionSwitch"/> callback into a promise-based interface.
    /// Use <c>await</c> on the returned promise to obtain the agent at its new version once the API call completes.
    /// If <paramref name="Callbacks"/> is provided, its handlers will be invoked during the request lifecycle.
    /// </remarks>
    function AsyncAwaitVersionSwitch(const AgentId: string;
      const ParamProc: TProc<TAgentVersionParams>;
      const Callbacks: TFunc<TPromiseConversationsAgent> = nil): TPromise<TConversationsAgent>;

    /// <summary>
    /// Creates a new conversation agent synchronously using the specified parameters.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <see cref="TConversationsAgentParams"/>, including model selection, name, description, tools, and completion arguments.
    /// </param>
    /// <returns>
    /// A <see cref="TConversationsAgent"/> instance representing the newly created agent.
    /// </returns>
    /// <remarks>
    /// This method performs a blocking HTTP POST to the /agents endpoint. Use it when you need to create
    /// an agent and immediately work with the returned object. For non-blocking workflows, consider using
    /// <see cref="AsyncCreate"/> or <see cref="AsyncAwaitCreate"/>.
    /// </remarks>
    function Create(const ParamProc: TProc<TConversationsAgentParams>): TConversationsAgent;

    /// <summary>
    /// Retrieves a list of conversation agents synchronously using the specified parameters.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <see cref="TConversationsListParams"/>, such as filtering, pagination, or sorting options.
    /// </param>
    /// <returns>
    /// A <see cref="TConversationsAgentList"/> instance containing the retrieved collection of agents.
    /// </returns>
    /// <remarks>
    /// This method performs a blocking HTTP GET to the /agents endpoint. Use it when you need to fetch
    /// agents immediately. For non-blocking workflows, consider using <see cref="AsyncList"/> or <see cref="AsyncAwaitList"/>.
    /// </remarks>
    function List(const ParamProc: TProc<TConversationsListParams>): TConversationsAgentList;

    /// <summary>
    /// Retrieves a specific conversation agent synchronously by its identifier.
    /// </summary>
    /// <param name="AgentId">
    /// The unique identifier of the conversation agent to retrieve.
    /// </param>
    /// <returns>
    /// A <see cref="TConversationsAgent"/> instance representing the requested agent.
    /// </returns>
    /// <remarks>
    /// This method performs a blocking HTTP GET to the /agents/{AgentId} endpoint.
    /// Use it when you need to fetch an agent’s details immediately.
    /// For non-blocking workflows, consider using <see cref="AsyncRetrieve"/> or <see cref="AsyncAwaitRetrieve"/>.
    /// </remarks>
    function Retrieve(const AgentId: string): TConversationsAgent;

    /// <summary>
    /// Updates an existing conversation agent synchronously with the specified parameters.
    /// </summary>
    /// <param name="AgentId">
    /// The unique identifier of the conversation agent to update.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure the <see cref="TConversationsAgentParams"/>, such as modifying the agent’s name, description, tools, or completion arguments.
    /// </param>
    /// <returns>
    /// A <see cref="TConversationsAgent"/> instance representing the updated agent.
    /// </returns>
    /// <remarks>
    /// This method performs a blocking HTTP PATCH to the /agents/{AgentId} endpoint. Use it when you
    /// need to apply configuration changes to an agent and work with the updated object immediately.
    /// For non-blocking workflows, consider using <see cref="AsyncUpdate"/> or <see cref="AsyncAwaitUpdate"/>.
    /// </remarks>
    function Update(const AgentId: string;
      const ParamProc: TProc<TConversationsAgentParams>): TConversationsAgent;

    /// <summary>
    /// Switches the active version of a conversation agent synchronously.
    /// </summary>
    /// <param name="AgentId">
    /// The unique identifier of the conversation agent whose version will be switched.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure the <see cref="TAgentVersionParams"/>, specifying the target version number.
    /// </param>
    /// <returns>
    /// A <see cref="TConversationsAgent"/> instance representing the agent at the newly selected version.
    /// </returns>
    /// <remarks>
    /// This method performs a blocking HTTP PATCH to the /agents/{AgentId}/version endpoint.
    /// Use it when you need to immediately switch an agent to a different version and work with the updated configuration.
    /// For non-blocking workflows, consider using <see cref="AsyncAwaitVersionSwitch"/> or <see cref="AsyncAwaitVersionSwitch"/>.
    /// </remarks>
    function VersionSwitch(const AgentId: string;
      const ParamProc: TProc<TAgentVersionParams>): TConversationsAgent;

    /// <summary>
    /// Initiates an asynchronous creation of a conversation agent using callbacks.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <see cref="TConversationsAgentParams"/>, including model selection, name, description, tools, and completion arguments.
    /// </param>
    /// <param name="Callbacks">
    /// A callback delegate (<see cref="TAsyncConversationsAgent"/>) to handle lifecycle events:
    /// <c>OnStart</c> when the request begins, <c>OnSuccess</c> with the created <see cref="TConversationsAgent"/>, and <c>OnError</c> on failure.
    /// </param>
    /// <remarks>
    /// This method performs a non-blocking HTTP POST to the /agents endpoint.
    /// Use it when you need to create an agent without blocking the calling thread.
    /// For promise-based flows, see <see cref="AsyncAwaitCreate"/>.
    /// </remarks>
    procedure AsyncCreate(
      const ParamProc: TProc<TConversationsAgentParams>;
      const Callbacks: TFunc<TAsyncConversationsAgent>);

    /// <summary>
    /// Initiates an asynchronous request to list conversation agents using callbacks.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <see cref="TConversationsListParams"/>, such as filtering, pagination, or sorting options.
    /// </param>
    /// <param name="Callbacks">
    /// A callback delegate (<see cref="TAsyncConversationsAgentList"/>) to handle lifecycle events:
    /// <c>OnStart</c> when the request begins, <c>OnSuccess</c> with the resulting <see cref="TConversationsAgentList"/>, and <c>OnError</c> on failure.
    /// </param>
    /// <remarks>
    /// This method performs a non-blocking HTTP GET to the /agents endpoint.
    /// Use it when you need to retrieve the list of agents without blocking the calling thread.
    /// For promise-based flows, see <see cref="AsyncAwaitList"/>.
    /// </remarks>
    procedure AsyncList(
      const ParamProc: TProc<TConversationsListParams>;
      const Callbacks: TFunc<TAsyncConversationsAgentList>);

    /// <summary>
    /// Initiates an asynchronous retrieval of a specific conversation agent using callbacks.
    /// </summary>
    /// <param name="AgentId">
    /// The unique identifier of the conversation agent to retrieve.
    /// </param>
    /// <param name="Callbacks">
    /// A callback delegate (<see cref="TAsyncConversationsAgent"/>) to handle lifecycle events:
    /// <c>OnStart</c> when the request begins, <c>OnSuccess</c> with the retrieved <see cref="TConversationsAgent"/>, and <c>OnError</c> on failure.
    /// </param>
    /// <remarks>
    /// This method performs a non-blocking HTTP GET to the /agents/{AgentId} endpoint.
    /// Use it when you need to fetch an agent’s details without blocking the calling thread.
    /// For promise-based workflows, see <see cref="AsyncAwaitRetrieve"/>.
    /// </remarks>
    procedure AsyncRetrieve(
      const AgentId: string;
      const Callbacks: TFunc<TAsyncConversationsAgent>);

    /// <summary>
    /// Initiates an asynchronous update of a conversation agent using callbacks.
    /// </summary>
    /// <param name="AgentId">
    /// The unique identifier of the conversation agent to update.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure the <see cref="TConversationsAgentParams"/>, such as modifying tools, description, or completion arguments.
    /// </param>
    /// <param name="Callbacks">
    /// A callback delegate (<see cref="TAsyncConversationsAgent"/>) to handle lifecycle events:
    /// <c>OnStart</c> when the request begins, <c>OnSuccess</c> with the updated <see cref="TConversationsAgent"/>, and <c>OnError</c> on failure.
    /// </param>
    /// <remarks>
    /// This method performs a non-blocking HTTP PATCH to the /agents/{AgentId} endpoint.
    /// Use it when you need to apply configuration changes without blocking the calling thread.
    /// For promise-based flows, see <see cref="AsyncAwaitUpdate"/>.
    /// </remarks>
    procedure AsyncUpdate(
      const AgentId: string;
      const ParamProc: TProc<TConversationsAgentParams>;
      const Callbacks: TFunc<TAsyncConversationsAgent>);

    /// <summary>
    /// Initiates an asynchronous version switch of a conversation agent using callbacks.
    /// </summary>
    /// <param name="AgentId">
    /// The unique identifier of the conversation agent whose version will be switched.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure the <see cref="TAgentVersionParams"/>, specifying the target version number.
    /// </param>
    /// <param name="Callbacks">
    /// A callback delegate (<see cref="TAsyncConversationsAgent"/>) to handle lifecycle events:
    /// <c>OnStart</c> when the request begins, <c>OnSuccess</c> with the <see cref="TConversationsAgent"/> of the new version, and <c>OnError</c> on failure.
    /// </param>
    /// <remarks>
    /// This method performs a non-blocking HTTP PATCH to the /agents/{AgentId}/version endpoint.
    /// Use it when you need to switch an agent’s version without blocking the calling thread.
    /// For promise-based workflows, see <see cref="AsyncAwaitVersionSwitch"/>.
    /// </remarks>
    procedure AsyncVersionSwitch(
      const AgentId: string;
      const ParamProc: TProc<TAgentVersionParams>;
      const Callbacks: TFunc<TAsyncConversationsAgent>);
  end;

implementation

{ TConversationsAgentRoute }

function TConversationsAgentRoute.AsyncAwaitCreate(
  const ParamProc: TProc<TConversationsAgentParams>;
  const Callbacks: TFunc<TPromiseConversationsAgent>): TPromise<TConversationsAgent>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TConversationsAgent>(
    procedure(const CallbackParams: TFunc<TAsyncConversationsAgent>)
    begin
      AsyncCreate(ParamProc, CallbackParams);
    end,
    Callbacks);
end;

function TConversationsAgentRoute.AsyncAwaitList(
  const ParamProc: TProc<TConversationsListParams>;
  const Callbacks: TFunc<TPromiseConversationsAgentList>): TPromise<TConversationsAgentList>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TConversationsAgentList>(
    procedure(const CallbackParams: TFunc<TAsyncConversationsAgentList>)
    begin
      AsyncList(ParamProc, CallbackParams);
    end,
    Callbacks);
end;

function TConversationsAgentRoute.AsyncAwaitRetrieve(const AgentId: string;
  const Callbacks: TFunc<TPromiseConversationsAgent>): TPromise<TConversationsAgent>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TConversationsAgent>(
    procedure(const CallbackParams: TFunc<TAsyncConversationsAgent>)
    begin
      AsyncRetrieve(AgentId, CallbackParams);
    end,
    Callbacks);
end;

function TConversationsAgentRoute.AsyncAwaitUpdate(const AgentId: string;
  const ParamProc: TProc<TConversationsAgentParams>;
  const Callbacks: TFunc<TPromiseConversationsAgent>): TPromise<TConversationsAgent>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TConversationsAgent>(
    procedure(const CallbackParams: TFunc<TAsyncConversationsAgent>)
    begin
      AsyncUpdate(AgentId, ParamProc, CallbackParams);
    end,
    Callbacks);
end;

function TConversationsAgentRoute.AsyncAwaitVersionSwitch(const AgentId: string;
  const ParamProc: TProc<TAgentVersionParams>;
  const Callbacks: TFunc<TPromiseConversationsAgent>): TPromise<TConversationsAgent>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TConversationsAgent>(
    procedure(const CallbackParams: TFunc<TAsyncConversationsAgent>)
    begin
      AsyncVersionSwitch(AgentId, ParamProc, CallbackParams);
    end,
    Callbacks);
end;

procedure TConversationsAgentRoute.AsyncCreate(
  const ParamProc: TProc<TConversationsAgentParams>;
  const Callbacks: TFunc<TAsyncConversationsAgent>);
begin
  with TAsyncCallbackExec<TAsyncConversationsAgent, TConversationsAgent>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TConversationsAgent
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TConversationsAgentRoute.AsyncList(
  const ParamProc: TProc<TConversationsListParams>;
  const Callbacks: TFunc<TAsyncConversationsAgentList>);
begin
  with TAsyncCallbackExec<TAsyncConversationsAgentList, TConversationsAgentList>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TConversationsAgentList
      begin
        Result := Self.List(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TConversationsAgentRoute.AsyncRetrieve(const AgentId: string;
  const Callbacks: TFunc<TAsyncConversationsAgent>);
begin
  with TAsyncCallbackExec<TAsyncConversationsAgent, TConversationsAgent>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TConversationsAgent
      begin
        Result := Self.Retrieve(AgentId);
      end);
  finally
    Free;
  end;
end;

procedure TConversationsAgentRoute.AsyncUpdate(const AgentId: string;
  const ParamProc: TProc<TConversationsAgentParams>;
  const Callbacks: TFunc<TAsyncConversationsAgent>);
begin
  with TAsyncCallbackExec<TAsyncConversationsAgent, TConversationsAgent>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TConversationsAgent
      begin
        Result := Self.Update(AgentId, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TConversationsAgentRoute.AsyncVersionSwitch(const AgentId: string;
  const ParamProc: TProc<TAgentVersionParams>;
  const Callbacks: TFunc<TAsyncConversationsAgent>);
begin
  with TAsyncCallbackExec<TAsyncConversationsAgent, TConversationsAgent>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TConversationsAgent
      begin
        Result := Self.VersionSwitch(AgentId, ParamProc);
      end);
  finally
    Free;
  end;
end;

function TConversationsAgentRoute.Create(
  const ParamProc: TProc<TConversationsAgentParams>): TConversationsAgent;
begin
  Result := API.Post<TConversationsAgent, TConversationsAgentParams>('agents', ParamProc);
end;

function TConversationsAgentRoute.List(
  const ParamProc: TProc<TConversationsListParams>): TConversationsAgentList;
begin
  Result := API.Get<TConversationsAgentList, TConversationsListParams>('agents', ParamProc, 'data');
end;

function TConversationsAgentRoute.Retrieve(
  const AgentId: string): TConversationsAgent;
begin
  Result := API.Get<TConversationsAgent>('agents/' + AgentId);
end;

function TConversationsAgentRoute.Update(const AgentId: string;
  const ParamProc: TProc<TConversationsAgentParams>): TConversationsAgent;
begin
  Result := API.Patch<TConversationsAgent, TConversationsAgentParams>('agents/' + AgentId, ParamProc);
end;

function TConversationsAgentRoute.VersionSwitch(const AgentId: string;
  const ParamProc: TProc<TAgentVersionParams>): TConversationsAgent;
begin
  Result := API.PatchFromUrl<TConversationsAgent, TAgentVersionParams>('agents/' + AgentId + '/version', ParamProc);
end;

end.


unit MistralAI.Conversations.Chunks;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.JSON, System.Rtti, System.Generics.Collections,
  REST.JsonReflect, REST.Json.Types, REST.Json,
  MistralAI.Types, MistralAI.API.Params;

type
  TImageUrl = class
  private
    FUrl: string;
    FDetail: string;
  public
    property Url: string read FUrl write FUrl;
    property Detail: string read FDetail write FDetail;
  end;

  {$REGION 'TContentChunk'}

  /// <summary>
  /// Serves as the base class for content chunk types, encapsulating common functionality shared by all chunk classes.
  /// </summary>
  /// <remarks>
  /// This class defines the <c>Type</c> property, which indicates how a chunk's content should be interpreted
  /// (e.g., as text, an image URL, a document link, etc.). Derived classes inherit this property and may
  /// extend it with additional fields and behavior specific to their chunk type.
  /// </remarks>
  TMessageOutputContentChunksCommon = class
  private
    [JsonReflectAttribute(ctString, rtString, TContentChunkTypeInterceptor)]
    FType: TContentChunkType;
  public
    /// <summary>
    /// Gets or sets the content chunk’s type, determining the format or category of the chunk.
    /// </summary>
    /// <value>
    /// A <see cref="TContentChunkType"/> enumeration value specifying the chunk’s kind (for example,
    /// <c>Text</c>, <c>ImageUrl</c>, <c>ToolFile</c>, etc.).
    /// </value>
    property &Type: TContentChunkType read FType write FType;
  end;

  /// <summary>
  /// Represents a chunk containing plain text within a conversation output.
  /// </summary>
  /// <remarks>
  /// Inherits the <see cref="TMessageOutputContentChunksCommon"/> base and adds
  /// the <c>Text</c> property to hold the actual textual content of the chunk.
  /// </remarks>
  TTextChunk = class(TMessageOutputContentChunksCommon)
  private
    FText: string;
  public
    /// <summary>
    /// Gets or sets the textual content of this chunk.
    /// </summary>
    /// <value>
    /// A <see cref="string"/> containing the text payload for this chunk.
    /// </value>
    property Text: string read FText write FText;
  end;

  /// <summary>
  /// Represents a chunk that includes an image URL, extending the plain-text chunk functionality.
  /// </summary>
  /// <remarks>
  /// Inherits from <see cref="TTextChunk"/> and introduces the <c>ImageUrl</c> property,
  /// which encapsulates a URL (and optional detail) pointing to an image associated with this chunk.
  /// </remarks>
  TImageURLChunk = class(TTextChunk)
  private
    [JsonNameAttribute('image_url')]
    FImageUrl: TImageUrl;
  public
    /// <summary>
    /// Gets or sets the image URL information for this chunk.
    /// </summary>
    /// <value>
    /// A <see cref="TImageUrl"/> instance containing the image’s URL and any descriptive detail.
    /// </value>
    property ImageUrl: TImageUrl read FImageUrl write FImageUrl;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a content chunk that includes metadata for a tool-generated file,
  /// extending image URL capabilities with file-specific information.
  /// </summary>
  /// <remarks>
  /// Inherits from <see cref="TImageURLChunk"/> to combine image URL support with
  /// tool execution context. Adds properties for identifying the tool, file ID,
  /// file name, and file type to facilitate handling of file attachments or outputs.
  /// </remarks>
  TToolFileChunk = class(TImageURLChunk)
  private
    [JsonReflectAttribute(ctString, rtString, TConversationToolInterceptor)]
    FTool: TConversationTool;
    [JsonNameAttribute('file_id')]
    FFileId: string;
    [JsonNameAttribute('file_name')]
    FFileName: string;
    [JsonNameAttribute('file_type')]
    FFileType: string;
  public
    /// <summary>
    /// Gets or sets the tool that produced or is associated with this file chunk.
    /// </summary>
    /// <value>
    /// A <see cref="TConversationTool"/> value identifying the originating tool.
    /// </value>
    property Tool: TConversationTool read FTool write FTool;

    /// <summary>
    /// Gets or sets the unique identifier assigned to the file.
    /// </summary>
    /// <value>
    /// A <see cref="string"/> representing the file’s ID within the tool context.
    /// </value>
    property FileId: string read FFileId write FFileId;

    /// <summary>
    /// Gets or sets the name of the file.
    /// </summary>
    /// <value>
    /// A <see cref="string"/> containing the human-readable file name.
    /// </value>
    property FileName: string read FFileName write FFileName;

    /// <summary>
    /// Gets or sets the type or MIME type of the file.
    /// </summary>
    /// <value>
    /// A <see cref="string"/> describing the file’s format or media type.
    /// </value>
    property FileType: string read FFileType write FFileType;
  end;

  /// <summary>
  /// Represents a content chunk that includes a document link,
  /// extending tool file chunk functionality with document-specific metadata.
  /// </summary>
  /// <remarks>
  /// Inherits from <see cref="TToolFileChunk"/> to combine file and image URL support
  /// with document handling. Adds properties for the document’s URL and its display name,
  /// facilitating the integration of linked documents within conversation outputs.
  /// </remarks>
  TDocumentURLChunk = class(TToolFileChunk)
  private
    [JsonNameAttribute('document_url')]
    FDocumentUrl: string;
    [JsonNameAttribute('document_name')]
    FDocumentName: string;
  public
    /// <summary>
    /// Gets or sets the URL pointing to the document resource.
    /// </summary>
    /// <value>
    /// A <see cref="string"/> containing the fully-qualified URL of the document.
    /// </value>
    property DocumentUrl: string read FDocumentUrl write FDocumentUrl;

    /// <summary>
    /// Gets or sets the display name of the document.
    /// </summary>
    /// <value>
    /// A <see cref="string"/> containing the human-readable name of the document.
    /// </value>
    property DocumentName: string read FDocumentName write FDocumentName;
  end;

  /// <summary>
  /// Represents a content chunk that includes a reference to an external tool resource or metadata link,
  /// extending document URL chunk functionality with additional reference details.
  /// </summary>
  /// <remarks>
  /// Inherits from <see cref="TDocumentURLChunk"/> to combine document linking with tool and file context.
  /// Adds properties for title, URL, source identifier, favicon link, and descriptive text to support rich
  /// reference integration within conversation outputs.
  /// </remarks>
  TToolReferenceChunk = class(TDocumentURLChunk)
  private
    FTitle: string;
    FUrl: string;
    FSource: string;
    FFavicon: string;
    FDescription: string;
  public
    /// <summary>
    /// Gets or sets the title of the referenced resource.
    /// </summary>
    /// <value>
    /// A <see cref="string"/> containing the human-readable title or headline of the reference.
    /// </value>
    property Title: string read FTitle write FTitle;

    /// <summary>
    /// Gets or sets the URL of the referenced resource.
    /// </summary>
    /// <value>
    /// A <see cref="string"/> containing the fully-qualified link to the external resource.
    /// </value>
    property Url: string read FUrl write FUrl;

    /// <summary>
    /// Gets or sets the source identifier for the reference, such as a domain or tool name.
    /// </summary>
    /// <value>
    /// A <see cref="string"/> indicating the origin or provider of the referenced content.
    /// </value>
    property Source: string read FSource write FSource;

    /// <summary>
    /// Gets or sets the favicon URL of the referenced source.
    /// </summary>
    /// <value>
    /// A <see cref="string"/> containing the link to the favicon image used to visually represent the source.
    /// </value>
    property Favicon: string read FFavicon write FFavicon;

    /// <summary>
    /// Gets or sets a brief description of the referenced resource.
    /// </summary>
    /// <value>
    /// A <see cref="string"/> providing contextual or descriptive information about the link.
    /// </value>
    property Description: string read FDescription write FDescription;
  end;

  {$ENDREGION}

  /// <summary>
  /// Represents a concrete, all‑purpose content chunk that aggregates every inherited chunk capability.
  /// </summary>
  /// <remarks>
  /// <para>Inherits from <see cref="TToolReferenceChunk"/>.</para>
  /// <para>Derives from <see cref="TDocumentURLChunk"/>.</para>
  /// <para>Derives from <see cref="TToolFileChunk"/>.</para>
  /// <para>Derives from <see cref="TImageURLChunk"/>.</para>
  /// <para>Derives from <see cref="TTextChunk"/>.</para>
  /// <para>Derives from <see cref="TMessageOutputContentChunksCommon"/>.</para>
  /// <para>Use <c>TContentChunk</c> when you need a single chunk type capable of representing any supported content form.</para>
  /// </remarks>
  TContentChunk = class(TToolReferenceChunk);

  {$REGION 'TConversationChunk'}

  TOutputCommon = class(TJSONFingerprint)
  private
    FObject: string;
    [JsonReflectAttribute(ctString, rtString, TConversatonEventInterceptor)]
    FType: TConversatonEvent;
    [JsonNameAttribute('created_at')]
    FCreatedAt: string;
    [JsonNameAttribute('completed_at')]
    FCompletedAt: string;
    FId: string;
  public
    /// <summary>
    /// Gets or sets the API object type.
    /// </summary>
    property &Object: string read FObject write FObject;

    /// <summary>
    /// Gets or sets the subtype of this entry.
    /// </summary>
    property &Type: TConversatonEvent read FType write FType;

    /// <summary>
    /// Gets or sets the timestamp when the entry was created.
    /// </summary>
    property CreatedAt: string read FCreatedAt write FCreatedAt;

    /// <summary>
    /// Gets or sets the timestamp when the entry was completed.
    /// </summary>
    property CompletedAt: string read FCompletedAt write FCompletedAt;

    /// <summary>
    /// Gets or sets the unique identifier of the entry.
    /// </summary>
    property Id: string read FId write FId;
  end;

  /// <summary>
  /// Represents an entry for a tool execution within a conversation, capturing the tool’s identifier and associated metadata.
  /// </summary>
  /// <remarks>
  /// <para>Inherits from <see cref="TOutputCommon"/>.</para>
  /// <para>Defines the <see cref="TToolExecutionEntry.Name"/> property, specifying the name of the tool being executed.</para>
  /// <para>Defines the <see cref="TToolExecutionEntry.Info"/> property, containing detailed information or metadata about the execution.</para>
  /// </remarks>
  TToolExecutionEntry = class(TOutputCommon)
  private
    FName: string;
    [JsonReflectAttribute(ctString, rtString, TMetadataInterceptor)]
    FInfo: string;
  public
    /// <summary>
    /// Gets or sets the name of the tool involved in this execution entry.
    /// </summary>
    property Name: string read FName write FName;

    /// <summary>
    /// Gets or sets detailed metadata or execution information for the tool.
    /// </summary>
    property Info: string read FInfo write FInfo;
  end;

  /// <summary>
  /// Represents a function call entry within a conversation log, linking a tool invocation to its supplied arguments.
  /// </summary>
  /// <remarks>
  /// <para>Inherits from <see cref="TToolExecutionEntry"/>.</para>
  /// <para>Defines the <see cref="TFunctionCallEntry.ToolCallId"/> property, which holds the identifier of the invoked tool call.</para>
  /// <para>Defines the <see cref="TFunctionCallEntry.Arguments"/> property, which contains the serialized arguments passed to the function.</para>
  /// </remarks>
  TFunctionCallEntry = class(TToolExecutionEntry)
  private
    [JsonNameAttribute('tool_call_id')]
    FToolCallId: string;
    FArguments: string;
  public
    /// <summary>
    /// Gets or sets the unique identifier of the tool call associated with this function entry.
    /// </summary>
    property ToolCallId: string read FToolCallId write FToolCallId;

    /// <summary>
    /// Gets or sets the arguments provided to the function, typically in serialized form.
    /// </summary>
    property Arguments: string read FArguments write FArguments;
  end;

  /// <summary>
  /// Represents an agent handoff within a conversation, capturing the transition between agents.
  /// </summary>
  /// <remarks>
  /// <para>Inherits from <see cref="TFunctionCallEntry"/>.</para>
  /// <para>Defines the <see cref="TAgentHandoffEntry.PreviousAgentId"/> property, specifying the identifier of the agent handing off.</para>
  /// <para>Defines the <see cref="TAgentHandoffEntry.PreviousAgentName"/> property, specifying the name of the agent handing off.</para>
  /// <para>Defines the <see cref="TAgentHandoffEntry.NextAgentId"/> property, specifying the identifier of the agent taking over.</para>
  /// <para>Defines the <see cref="TAgentHandoffEntry.NextAgentName"/> property, specifying the name of the agent taking over.</para>
  /// </remarks>
  TAgentHandoffEntry = class(TFunctionCallEntry)
  private
    [JsonNameAttribute('previous_agent_id')]
    FPreviousAgentId: string;
    [JsonNameAttribute('previous_agent_name')]
    FPreviousAgentName: string;
    [JsonNameAttribute('next_agent_id')]
    FNextAgentId: string;
    [JsonNameAttribute('next_agent_name')]
    FNextAagentName: string;
  public
    /// <summary>
    /// Gets or sets the identifier of the agent handing off responsibility.
    /// </summary>
    property PreviousAgentId: string read FPreviousAgentId write FPreviousAgentId;

    /// <summary>
    /// Gets or sets the name of the agent handing off responsibility.
    /// </summary>
    property PreviousAgentName: string read FPreviousAgentName write FPreviousAgentName;

    /// <summary>
    /// Gets or sets the identifier of the agent taking over responsibility.
    /// </summary>
    property NextAgentId: string read FNextAgentId write FNextAgentId;

    /// <summary>
    /// Gets or sets the name of the agent taking over responsibility.
    /// </summary>
    property NextAagentName: string read FNextAagentName write FNextAagentName;
  end;

  /// <summary>
  /// Represents a message output entry in a conversation, including agent metadata, the model used, the sender’s role, and the content chunks.
  /// </summary>
  /// <remarks>
  /// <para>Inherits from <see cref="TAgentHandoffEntry"/>.</para>
  /// <para>Derives from <see cref="TFunctionCallEntry"/>.</para>
  /// <para>Derives from <see cref="TToolExecutionEntry"/>.</para>
  /// <para>Derives from <see cref="TOutputCommon"/>.</para>
  /// <para>Derives from <see cref="TJSONFingerprint"/>.</para>
  /// </remarks>
  TMessageOutputEntry = class(TAgentHandoffEntry)
  private
    [JsonNameAttribute('agent_id')]
    FAgentId: string;
    FModel: string;
    [JsonReflectAttribute(ctString, rtString, TMessageRoleInterceptor)]
    FRole: TMessageRole;
    FContent: TArray<TContentChunk>;
  public
    /// <summary>
    /// Gets or sets the identifier of the agent that produced this message entry.
    /// </summary>
    property AgentId: string read FAgentId write FAgentId;

    /// <summary>
    /// Gets or sets the name of the model used to generate this entry.
    /// </summary>
    property Model: string read FModel write FModel;

    /// <summary>
    /// Gets or sets the role of the message author.
    /// </summary>
    property Role: TMessageRole read FRole write FRole;

    /// <summary>
    /// Gets or sets the content chunks associated with this message.
    /// </summary>
    /// <value>An array of <see cref="TContentChunk"/> instances containing the message’s content.</value>
    property Content: TArray<TContentChunk> read FContent write FContent;

    destructor Destroy; override;
  end;

  {$ENDREGION}

  /// <summary>
  /// Represents a single chunk of conversation output, including all associated metadata and content.
  /// </summary>
  /// <remarks>
  /// <para>Inherits from <see cref="TMessageOutputEntry"/>.</para>
  /// <para>Derives from <see cref="TAgentHandoffEntry"/>.</para>
  /// <para>Derives from <see cref="TFunctionCallEntry"/>.</para>
  /// <para>Derives from <see cref="TToolExecutionEntry"/>.</para>
  /// <para>Derives from <see cref="TOutputCommon"/>.</para>
  /// <para>Derives from <see cref="TJSONFingerprint"/>.</para>
  /// <para>Use <c>TConversationChunk</c> for handling individual output entries within a conversation,
  /// capturing agent transitions, tool execution details, and content chunks.</para>
  /// </remarks>
  TConversationChunk = class(TMessageOutputEntry);

  TConversationUsage = class
  private
    [JsonNameAttribute('prompt_tokens')]
    FPromptTokens: Integer;
    [JsonNameAttribute('completion_tokens')]
    FCompletionTokens: Integer;
    [JsonNameAttribute('total_tokens')]
    FTotalTokens: Integer;
    [JsonNameAttribute('connector_tokens')]
    [JsonReflectAttribute(ctString, rtString, TMetadataInterceptor)]
    FConnectorTokens: string;
    [JsonReflectAttribute(ctString, rtString, TMetadataInterceptor)]
    FConnectors: string;
  public
    /// <summary>
    /// Gets or sets the number of tokens consumed by the prompt.
    /// </summary>
    /// <value>An <see cref="Integer"/> representing the prompt token count.</value>
    property PromptTokens: Integer read FPromptTokens write FPromptTokens;

    /// <summary>
    /// Gets or sets the number of tokens consumed by the completion.
    /// </summary>
    /// <value>An <see cref="Integer"/> representing the completion token count.</value>
    property CompletionTokens: Integer read FCompletionTokens write FCompletionTokens;

    /// <summary>
    /// Gets or sets the total number of tokens used (prompt + completion + connectors).
    /// </summary>
    /// <value>An <see cref="Integer"/> representing the total token count.</value>
    property TotalTokens: Integer read FTotalTokens write FTotalTokens;

    /// <summary>
    /// Gets or sets the number of tokens consumed by connector operations.
    /// </summary>
    /// <value>A <see cref="string"/> representing the connector token count.</value>
    property ConnectorTokens: string read FConnectorTokens write FConnectorTokens;

    /// <summary>
    /// Gets or sets the list of connectors involved in the conversation.
    /// </summary>
    /// <value>A <see cref="string"/> containing serialized connector identifiers or details.</value>
    property Connectors: string read FConnectors write FConnectors;
  end;

  TConversation = class(TJSONFingerprint)
  private
    FObject: string;
    [JsonNameAttribute('conversation_id')]
    FConversationId: string;
    FOutputs: TArray<TConversationChunk>;
    FUsage: TConversationUsage;
  public
    /// <summary>
    /// Gets or sets the API object type, typically "conversation".
    /// </summary>
    property &Object: string read FObject write FObject;

    /// <summary>
    /// Gets or sets the unique identifier for this conversation.
    /// </summary>
    property ConversationId: string read FConversationId write FConversationId;

    /// <summary>
    /// Gets or sets the collection of output chunks generated during the conversation.
    /// </summary>
    property Outputs: TArray<TConversationChunk> read FOutputs write FOutputs;

    /// <summary>
    /// Gets or sets the usage statistics for the conversation, detailing token counts.
    /// </summary>
    property Usage: TConversationUsage read FUsage write FUsage;

    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents content retrieved from a conversation, including document URL and associated metadata.
  /// </summary>
  /// <remarks>
  /// <para>Inherits from <see cref="TDocumentURLChunk"/>.</para>
  /// <para>Derives from <see cref="TToolFileChunk"/>.</para>
  /// <para>Derives from <see cref="TImageURLChunk"/>.</para>
  /// <para>Derives from <see cref="TTextChunk"/>.</para>
  /// <para>Derives from <see cref="TMessageOutputContentChunksCommon"/>.</para>
  /// <para>Use <c>TRetrievedContent</c> when you need to represent a retrieved document link with full context of file, image, and text metadata.</para>
  /// </remarks>
  TRetrievedContent = class(TDocumentURLChunk);

  {$REGION 'TEntry'}

  /// <summary>
  /// Represents an input entry in a conversation, extending common output metadata
  /// to include the message role, prefix indicator, and associated retrieved content.
  /// </summary>
  /// <remarks>
  /// Use this class to model the structure and metadata of an incoming message
  /// within the conversation system.
  /// </remarks>
  TMessageInputEntryEx = class(TOutputCommon)
  private
    [JsonReflectAttribute(ctString, rtString, TMessageRoleInterceptor)]
    FRole: TMessageRole;
    FPrefix: Boolean;
    FContent: TArray<TRetrievedContent>;
  public
    /// <summary>
    /// Gets or sets the role of the message sender.
    /// </summary>
    /// <value>
    /// A <see cref="TMessageRole"/> value indicating who authored the message.
    /// </value>
    property Role: TMessageRole read FRole write FRole;

    /// <summary>
    /// Gets or sets a value indicating whether the message is a prefix.
    /// </summary>
    /// <value>
    /// True if the message should be treated as a prefix; otherwise, False.
    /// </value>
    property Prefix: Boolean read FPrefix write FPrefix;

    /// <summary>
    /// Gets or sets the collection of retrieved content items.
    /// </summary>
    /// <value>
    /// An array of <see cref="TRetrievedContent"/> instances.
    /// </value>
    property Content: TArray<TRetrievedContent> read FContent write FContent;

    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents an output entry in a conversation, extending the input entry
  /// metadata with agent and model information.
  /// </summary>
  /// <remarks>
  /// Use this class to model the structure and metadata of an outgoing message
  /// in the conversation system, capturing which agent produced the output
  /// and which AI model was used to generate it.
  /// </remarks>
  TMessageOutputEntryEx = class(TMessageInputEntryEx)
  private
    [JsonNameAttribute('agent_id')]
    FAgentId: string;
    FModel: string;
  public
    /// <summary>
    /// Gets or sets the identifier of the agent that produced this output.
    /// </summary>
    /// <value>
    /// A <see cref="string"/> containing the agent’s ID.
    /// </value>
    property AgentId: string read FAgentId write FAgentId;

    /// <summary>
    /// Gets or sets the model name used to generate the output.
    /// </summary>
    /// <value>
    /// A <see cref="string"/> representing the model identifier.
    /// </value>
    property Model: string read FModel write FModel;
  end;

  /// <summary>
  /// Represents the result of a function call within a conversation,
  /// extending the output entry with function-specific identifiers and output.
  /// </summary>
  /// <remarks>
  /// Use this class to capture the output from a function invocation,
  /// including the identifier of the tool call and the raw result payload.
  /// </remarks>
  TFunctionResultEntryEx = class(TMessageOutputEntryEx)
  private
    [JsonNameAttribute('tool_call_id')]
    FToolCallId: string;
    FResult: string;
  public
    /// <summary>
    /// Gets or sets the tool call identifier associated with this result.
    /// </summary>
    /// <value>
    /// A <see cref="string"/> holding the unique ID of the function invocation.
    /// </value>
    property ToolCallId: string read FToolCallId write FToolCallId;

    /// <summary>
    /// Gets or sets the result payload returned by the function.
    /// </summary>
    /// <value>
    /// A <see cref="string"/> containing the function’s output, typically serialized JSON or plain text.
    /// </value>
    property Result: string read FResult write FResult;
  end;

  /// <summary>
  /// Represents a function call entry in the conversation, extending the function result entry
  /// with the original call arguments.
  /// </summary>
  /// <remarks>
  /// Use this class to model the details of a function invocation, including the tool call identifier,
  /// the result payload, and the serialized arguments that were passed to the function.
  /// </remarks>
  TFunctionCallEntryEx = class(TFunctionResultEntryEx)
  private
    [JsonReflectAttribute(ctString, rtString, TMetadataInterceptor)]
    FArguments: string;
  public
    /// <summary>
    /// Gets or sets the serialized arguments for the function invocation.
    /// </summary>
    /// <value>
    /// A <see cref="string"/> representing the JSON-encoded arguments of the call.
    /// </value>
    property Arguments: string read FArguments write FArguments;
  end;

  /// <summary>
  /// Represents the execution of a tool within a conversation, extending the function call entry
  /// with tool-specific metadata such as the tool’s name, informational summary, and the function invoked.
  /// </summary>
  /// <remarks>
  /// Use this class to capture details about a tool execution event,
  /// including its unique name, descriptive info, and the specific function identifier that was called.
  /// </remarks>
  TToolExecutionEntryEx = class(TFunctionCallEntryEx)
  private
    FName: string;
    [JsonReflectAttribute(ctString, rtString, TMetadataInterceptor)]
    FInfo: string;
    FFunction: string;
  public
    /// <summary>
    /// Gets or sets the name of the executed tool.
    /// </summary>
    /// <value>
    /// A <see cref="string"/> containing the tool’s name.
    /// </value>
    property Name: string read FName write FName;

    /// <summary>
    /// Gets or sets the informational metadata about the tool execution.
    /// </summary>
    /// <value>
    /// A <see cref="string"/> with summary or details about the execution context.
    /// </value>
    property Info: string read FInfo write FInfo;

    /// <summary>
    /// Gets or sets the function identifier that was invoked on the tool.
    /// </summary>
    /// <value>
    /// A <see cref="string"/> representing the function name or handle.
    /// </value>
    property &Function: string read FFunction write FFunction;
  end;

  /// <summary>
  /// Represents an agent handoff entry in a conversation, extending the tool execution entry
  /// with identifiers for the previous and next agents involved.
  /// </summary>
  /// <remarks>
  /// Use this class to model transitions between agents during a conversation workflow,
  /// capturing both the outgoing agent and the incoming agent metadata.
  /// </remarks>
  TAgentHandoffEntryEx = class(TToolExecutionEntryEx)
  private
    [JsonNameAttribute('previous_agent_id')]
    FPreviousAgentId: string;
    [JsonNameAttribute('previous_agent_name')]
    FPreviousAgentName: string;
    [JsonNameAttribute('next_agent_id')]
    FNextAgentId: string;
    [JsonNameAttribute('next_agent_name')]
    FNextAgentName: string;
  public
    /// <summary>
    /// Gets or sets the ID of the agent that is handing off.
    /// </summary>
    /// <value>
    /// A <see cref="string"/> containing the previous agent’s unique identifier.
    /// </value>
    property PreviousAgentId: string read FPreviousAgentId write FPreviousAgentId;

    /// <summary>
    /// Gets or sets the name of the agent that is handing off.
    /// </summary>
    /// <value>
    /// A <see cref="string"/> containing the previous agent’s display name.
    /// </value>
    property PreviousAgentName: string read FPreviousAgentName write FPreviousAgentName;

    /// <summary>
    /// Gets or sets the ID of the agent that is taking over.
    /// </summary>
    /// <value>
    /// A <see cref="string"/> containing the next agent’s unique identifier.
    /// </value>
    property NextAgentId: string read FNextAgentId write FNextAgentId;

    /// <summary>
    /// Gets or sets the name of the agent that is taking over.
    /// </summary>
    /// <value>
    /// A <see cref="string"/> containing the next agent’s display name.
    /// </value>
    property NextAgentName: string read FNextAgentName write FNextAgentName;
  end;

  {$ENDREGION}

  /// <summary>
  /// Represents a single entry.
  /// combining all conversation metadata, function/tool call information, and agent handoff details.
  /// </summary>
  /// <remarks>
  /// <para>
  /// Use this class for each chunk returned by the streaming API when processing a chat completion in real time.
  /// </para>
  /// <para>
  /// Inherits from <see cref="TOutputCommon"/> for base metadata such as object type, creation and completion timestamps, and unique ID.
  /// </para>
  /// <para>
  /// Inherits from <see cref="TMessageInputEntryEx"/> to include the message role, prefix flag, and any retrieved content items.
  /// </para>
  /// <para>
  /// Inherits from <see cref="TMessageOutputEntryEx"/> to capture which agent produced the message and which model was used.
  /// </para>
  /// <para>
  /// Inherits from <see cref="TFunctionResultEntryEx"/> to include the identifier of a function call and its raw result payload.
  /// </para>
  /// <para>
  /// Inherits from <see cref="TFunctionCallEntryEx"/> to record the JSON‑encoded arguments passed to the function invocation.
  /// </para>
  /// <para>
  /// Inherits from <see cref="TToolExecutionEntryEx"/> to capture the executed tool’s name, informational metadata, and invoked function identifier.
  /// </para>
  /// <para>
  /// Inherits from <see cref="TAgentHandoffEntryEx"/> to track agent transitions, including the IDs and names of the previous and next agents.
  /// </para>
  /// </remarks>
  TEntry = class(TAgentHandoffEntryEx);

  /// <summary>
  /// Represents a set of conversation entries retrieved from the API,
  /// including metadata about the conversation and its entries.
  /// </summary>
  /// <remarks>
  /// Use this class to encapsulate the payload returned when fetching
  /// all entries for a given conversation, including the conversation ID
  /// and the list of entries.
  /// </remarks>
  TRetrievedEntries = class(TJSONFingerprint)
  private
    FObject: string;
    [JsonNameAttribute('conversation_id')]
    FConversationId: string;
    FEntries: TArray<TEntry>;
  public
    /// <summary>
    /// Gets or sets the JSON object type for this payload.
    /// </summary>
    /// <value>
    /// A <see cref="string"/> indicating the payload type.
    /// </value>
    property &Object: string read FObject write FObject;

    /// <summary>
    /// Gets or sets the conversation identifier.
    /// </summary>
    /// <value>
    /// A <see cref="string"/> representing the conversation ID.
    /// </value>
    property ConversationId: string read FConversationId write FConversationId;

    /// <summary>
    /// Gets or sets the array of entries associated with the conversation.
    /// </summary>
    /// <value>
    /// An array of <see cref="TEntry"/> instances.
    /// </value>
    property Entries: TArray<TEntry> read FEntries write FEntries;

    destructor Destroy; override;
  end;

  {$REGION 'TMessage'}

  /// <summary>
  /// Represents an input message entry in a conversation stream, extending
  /// common output metadata with sender role, prefix flag, and content chunks.
  /// </summary>
  /// <remarks>
  /// Use this class to model the structure and metadata of an incoming message
  /// when retrieving or replaying conversation streams. It captures who sent
  /// the message, whether it serves as a prefix, and the associated content chunks.
  /// </remarks>
  TMessageInputEntryEx1 = class(TOutputCommon)
  private
    [JsonReflectAttribute(ctString, rtString, TMessageRoleInterceptor)]
    FRole: TMessageRole;
    FPrefix: Boolean;
    FContent: TArray<TContentChunk>;
  public
    /// <summary>
    /// Gets or sets the sender role for this message entry.
    /// </summary>
    /// <value>
    /// A <see cref="TMessageRole"/> value indicating who authored the message.
    /// </value>
    property Role: TMessageRole read FRole write FRole;

    /// <summary>
    /// Gets or sets a value indicating whether the message is a prefix.
    /// </summary>
    /// <value>
    /// True if the message should be treated as a prefix; otherwise, False.
    /// </value>
    property Prefix: Boolean read FPrefix write FPrefix;

    /// <summary>
    /// Gets or sets the content chunks for this message entry.
    /// </summary>
    /// <value>
    /// An array of <see cref="TContentChunk"/> instances representing parts of the message.
    /// </value>
    property Content: TArray<TContentChunk> read FContent write FContent;

    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents an output message entry in a conversation stream, extending the input entry
  /// metadata with agent identifier and model details.
  /// </summary>
  /// <remarks>
  /// Use this class to capture information about an outgoing message when retrieving
  /// or replaying conversation streams, including which agent generated the message
  /// and which AI model produced it.
  /// </remarks>
  TMessageOutputEntryEx1 = class(TMessageInputEntryEx1)
  private
    [JsonNameAttribute('agent_id')]
    FAgentId: string;
    [JsonNameAttribute('model')]
    FModel: string;
  public
    /// <summary>
    /// Gets or sets the agent identifier for this message entry.
    /// </summary>
    /// <value>
    /// A <see cref="string"/> containing the agent’s unique ID.
    /// </value>
    property AgentId: string read FAgentId write FAgentId;

    /// <summary>
    /// Gets or sets the model name used to generate the message entry.
    /// </summary>
    /// <value>
    /// A <see cref="string"/> representing the model identifier.
    /// </value>
    property Model: string read FModel write FModel;
  end;

  {$ENDREGION}

  /// <summary>
  /// Represents a complete chat message entry, combining metadata, sender info, agent details,
  /// and the actual content chunks.
  /// Inherits from <see cref="TMessageOutputEntryEx1"/>, which in turn inherits from
  /// <see cref="TMessageInputEntryEx1"/> and <see cref="TOutputCommon"/>, bringing together:
  /// <para>
  /// - TOutputCommon: common fields like Object, Id, CreatedAt, CompletedAt
  /// </para>
  /// <para>
  /// - TMessageInputEntryEx1: Role, Prefix, Content chunks
  /// </para>
  /// <para>
  /// - TMessageOutputEntryEx1: AgentId, Model
  /// </para>
  /// </summary>
  /// <remarks>
  /// Use this class to deserialize or construct a full message when retrieving or streaming
  /// conversation data. It contains both the raw content pieces and all contextual metadata.
  /// <para>
  /// <see cref="TMessageRole"/> defines the role of the sender (e.g., user, assistant, system).
  /// </para>
  /// <para>
  /// <see cref="TContentChunkType"/> specifies the type of each content chunk (text, image_url, etc.).
  /// </para>
  /// </remarks>
  TMessage = class(TMessageOutputEntryEx1);

  /// <summary>
  /// Represents the set of messages retrieved from a conversation,
  /// including metadata and the message list.
  /// </summary>
  /// <remarks>
  /// Use this class to encapsulate the payload returned when fetching
  /// all messages for a given conversation, providing the JSON object type,
  /// the conversation identifier, and the array of message entries.
  /// </remarks>
  TRetrieveMessages = class(TJSONFingerprint)
  private
    FObject: string;
    [JsonNameAttribute('conversation_id')]
    FConversationId: string;
    FMessages: TArray<TMessage>;
  public
    /// <summary>
    /// Gets or sets the JSON object type for this payload.
    /// </summary>
    /// <value>
    /// A <see cref="string"/> indicating the type of the JSON object.
    /// </value>
    property &Object: string read FObject write FObject;

    /// <summary>
    /// Gets or sets the conversation identifier.
    /// </summary>
    /// <value>
    /// A <see cref="string"/> representing the unique conversation ID.
    /// </value>
    property ConversationId: string read FConversationId write FConversationId;

    /// <summary>
    /// Gets or sets the array of messages in the conversation.
    /// </summary>
    /// <value>
    /// An array of <see cref="TMessage"/> instances representing each message entry.
    /// </value>
    property Messages: TArray<TMessage> read FMessages write FMessages;

    destructor Destroy; override;
  end;

implementation

{ TImageURLChunk }

destructor TImageURLChunk.Destroy;
begin
  if Assigned(FImageUrl) then
    FImageUrl.Free;
  inherited;
end;

{ TConversation }

destructor TConversation.Destroy;
begin
  for var Item in Foutputs do
    Item.Free;
  if Assigned(FUsage) then
    FUsage.Free;
  inherited;
end;

{ TMessageOutputEntry }

destructor TMessageOutputEntry.Destroy;
begin
  for var Item in FContent do
    Item.Free;
  inherited;
end;

{ TMessageInputEntryEx }

destructor TMessageInputEntryEx.Destroy;
begin
  for var Item in FContent do
    Item.Free;
  inherited;
end;

{ TRetrievedEntries }

destructor TRetrievedEntries.Destroy;
begin
  for var Item  in FEntries do
    Item.Free;
  inherited;
end;

{ TMessageInputEntryEx1 }

destructor TMessageInputEntryEx1.Destroy;
begin
  for var Item in FContent do
    Item.Free;
  inherited;
end;

{ TRetrieveMessages }

destructor TRetrieveMessages.Destroy;
begin
  for var Item in FMessages do
    Item.Free;
  inherited;
end;

end.

unit MistralAI.Conversations.EventStreaming;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, System.Threading,
  REST.Json.Types,
  MistralAI.API.Params, MistralAI.API, MistralAI.Types, MistralAI.Schema,
  MistralAI.Conversations.Params, MistralAI.Conversations.Chunks;

type
  /// <summary>
  /// Base class for streamed conversation chunk events.
  /// Encapsulates the event’s type identifier and the timestamp when it was created.
  /// </summary>
  TChunkEventCommon = class(TJSONFingerprint)
  private
    [JsonReflectAttribute(ctString, rtString, TChunkEventInterceptor)]
    FType: TChunkEvent;
    [JsonNameAttribute('created_at')]
    FCreatedAt: string;
  public
    /// <summary>
    /// The kind of chunk event (for example, message.output.delta, tool.execution.started, etc.).
    /// </summary>
    property &Type: TChunkEvent read FType write FType;

    /// <summary>
    /// The creation timestamp of the event in ISO 8601 format.
    /// </summary>
    property CreatedAt: string read FCreatedAt write FCreatedAt;
  end;

  /// <summary>
  /// Represents an error event in a conversation stream.
  /// Extends TChunkEventCommon to include an error message and numeric code.
  /// </summary>
  TConversationResponseError = class(TChunkEventCommon)
  private
    FMessage: string;
    FCode: Integer;
  public
    /// <summary>
    /// A human‑readable description of the error that occurred.
    /// </summary>
    property Message: string read FMessage write FMessage;

    /// <summary>
    /// A numeric code identifying the specific error type.
    /// </summary>
    property Code: Integer read FCode write FCode;
  end;

  /// <summary>
  /// Fired when a tool begins execution during a conversation stream.
  /// Inherits from TConversationResponseError to include error context if applicable.
  /// </summary>
  TToolExecutionStarted = class(TConversationResponseError)
  private
    [JsonNameAttribute('output_index')]
    FOutputIndex: Integer;
    FId: string;
    FName: string;
  public
    /// <summary>
    /// The zero‑based index of this execution in cases where multiple outputs are produced.
    /// </summary>
    property OutputIndex: Integer read FOutputIndex write FOutputIndex;

    /// <summary>
    /// A unique identifier for this specific tool execution instance.
    /// </summary>
    property Id: string read FId write FId;

    /// <summary>
    /// The registered name of the tool being executed.
    /// </summary>
    property Name: string read FName write FName;
  end;

  /// <summary>
  /// Fired when a tool finishes execution during a conversation stream.
  /// Inherits from TToolExecutionStarted and adds execution metadata.
  /// </summary>
  TToolExecutionDone = class(TToolExecutionStarted)
  private
    [JsonReflectAttribute(ctString, rtString, TMetadataInterceptor)]
    FInfo: string;
  public
    /// <summary>
    /// Additional metadata returned by the tool upon completion,
    /// typically used to convey execution details or results summary.
    /// </summary>
    property Info: string read FInfo write FInfo;
  end;

  /// <summary>
  /// Represents a function call delta event in the conversation stream.
  /// Inherits from TToolExecutionDone to include completion metadata,
  /// and adds the function call identifier and its serialized arguments.
  /// </summary>
  TFunctionCallDelta = class(TToolExecutionDone)
  private
    [JsonNameAttribute('tool_call_id')]
    FToolCallId: string;
    [JsonReflectAttribute(ctString, rtString, TMetadataInterceptor)]
    FArguments: string;
  public
    /// <summary>
    /// The unique identifier of the tool call instance this delta refers to.
    /// </summary>
    property ToolCallId: string read FToolCallId write FToolCallId;

    /// <summary>
    /// The JSON‐serialized arguments passed to the function at call time.
    /// </summary>
    property Arguments: string read FArguments write FArguments;
  end;

  /// <summary>
  /// Indicates the start of an agent handoff within the conversation stream.
  /// Inherits from TFunctionCallDelta to include function call context and metadata.
  /// </summary>
  TAgentHandoffStarted = class(TFunctionCallDelta)
  private
    [JsonNameAttribute('previous_agent_id')]
    FPreviousAgentId: string;
    [JsonNameAttribute('previous_agent_name')]
    FPreviousAgentName: string;
  public
    /// <summary>
    /// The identifier of the agent handing off control.
    /// </summary>
    property PreviousAgentId: string read FPreviousAgentId write FPreviousAgentId;

    /// <summary>
    /// The name of the agent handing off control.
    /// </summary>
    property PreviousAgentName: string read FPreviousAgentName write FPreviousAgentName;
  end;

  /// <summary>
  /// Indicates the completion of an agent handoff within the conversation stream.
  /// Inherits from TAgentHandoffStarted to include both the previous and next agent context.
  /// </summary>
  TAgentHandoffDone = class(TAgentHandoffStarted)
  private
    [JsonNameAttribute('next_agent_id')]
    FNextAgentId: string;
    [JsonNameAttribute('next_agent_name')]
    FNextAgentName: string;
  public
    /// <summary>
    /// The identifier of the agent taking over control.
    /// </summary>
    property NextAgentId: string read FNextAgentId write FNextAgentId;

    /// <summary>
    /// The name of the agent taking over control.
    /// </summary>
    property NextAgentName: string read FNextAgentName write FNextAgentName;
  end;

  /// <summary>
  /// Signals the start of a conversation response in the event stream.
  /// Inherits from TAgentHandoffDone to include agent handoff context and function call metadata.
  /// </summary>
  TConversationResponseStarted = class(TAgentHandoffDone)
  private
    [JsonNameAttribute('conversation_id')]
    FConversationId: string;
  public
    /// <summary>
    /// The unique identifier for this conversation instance.
    /// </summary>
    property ConversationId: string read FConversationId write FConversationId;
  end;

  /// <summary>
  /// Marks the completion of a conversation response in the event stream.
  /// Inherits from TConversationResponseStarted and includes usage statistics.
  /// </summary>
  TConversationResponseDone = class(TConversationResponseStarted)
  private
    FUsage: TConversationUsage;
  public
    /// <summary>
    /// Token usage details for this conversation response, including prompt, completion, and total counts.
    /// </summary>
    property Usage: TConversationUsage read FUsage write FUsage;

    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a chunk of streamed message content in a conversation response.
  /// Inherits from TConversationResponseDone to include completion metadata and usage statistics.
  /// </summary>
  TMessageOutputDelta = class(TConversationResponseDone)
  private
    [JsonNameAttribute('content_index')]
    FContentIndex: Integer;
    FModel: string;
    [JsonNameAttribute('agent_id')]
    FAgentId: string;
    [JsonReflectAttribute(ctString, rtString, TMessageRoleInterceptor)]
    FRole: TMessageRole;
    FContent: TArray<TContentChunk>;
  public
    /// <summary>
    /// The zero‑based index indicating the order of this content chunk in the overall response.
    /// </summary>
    property ContentIndex: Integer read FContentIndex write FContentIndex;

    /// <summary>
    /// The identifier of the model that generated this chunk of content.
    /// </summary>
    property Model: string read FModel write FModel;

    /// <summary>
    /// The identifier of the agent (e.g., assistant) producing this content chunk.
    /// </summary>
    property AgentId: string read FAgentId write FAgentId;

    /// <summary>
    /// The role associated with this chunk (such as 'user', 'assistant', or 'system').
    /// </summary>
    property Role: TMessageRole read FRole write FRole;

    /// <summary>
    /// An array of content chunks, each representing a part of the streamed message.
    /// </summary>
    property Content: TArray<TContentChunk> read FContent write FContent;

    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a single event emitted during streaming reception of a conversation.
  /// Inherits from <see cref="TMessageOutputDelta"/>, which in turn inherits from:
  /// <para>
  /// - <see cref="TConversationResponseDone"/>: adds usage statistics (prompt, completion, total tokens)
  /// </para>
  /// <para>
  /// - <see cref="TConversationResponseStarted"/>: adds the conversation identifier
  /// </para>
  /// <para>
  /// - <see cref="TAgentHandoffDone"/>: adds next agent context
  /// </para>
  /// <para>
  /// - <see cref="TAgentHandoffStarted"/>: adds previous agent context
  /// </para>
  /// <para>
  /// - <see cref="TFunctionCallDelta"/>: adds tool call identifier and arguments
  /// </para>
  /// <para>
  /// - <see cref="TToolExecutionDone"/>: adds tool execution metadata
  /// </para>
  /// <para>
  /// - <see cref="TToolExecutionStarted"/>: adds tool execution id, name, and output index
  /// </para>
  /// <para>
  /// - <see cref="TConversationResponseError"/>: adds error message and code
  /// </para>
  /// <para>
  /// - <see cref="TChunkEventCommon"/>: adds event type and creation timestamp
  /// </para>
  /// </summary>
  /// <remarks>
  /// Use this class to receive and process incremental chunks of a conversation response.
  /// Each event contains the role of the sender, content chunks, agent and model identifiers,
  /// error context if applicable, and token usage metrics. These events are generated in real‑time
  /// as the response is streamed from the server.
  /// <para>
  /// <see cref="TMessageRole"/> defines the role of the sender (e.g., user, assistant, system).
  /// </para>
  /// <para>
  /// <see cref="TContentChunkType"/> specifies the type of each content chunk (text, image_url, etc.).
  /// </para>
  /// <para>
  /// The inheritance chain brings together all contextual metadata needed for full deserialization
  /// or reconstruction of the streaming conversation data.
  /// </para>
  /// </remarks>
  TConversationsEvent = class(TMessageOutputDelta);

implementation

{ TConversationResponseDone }

destructor TConversationResponseDone.Destroy;
begin
  if Assigned(FUsage) then
    FUsage.Free;
  inherited;
end;

{ TMessageOutputDelta }

destructor TMessageOutputDelta.Destroy;
begin
  for var Item in FContent do
    Item.Free;
  inherited;
end;

end.

unit MistralAI.Conversations.Internal;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, System.Threading,
  REST.Json.Types,
  MistralAI.API.Params, MistralAI.API, MistralAI.Types,
  MistralAI.Conversations.Params, MistralAI.Conversations.Chunks, MistralAI.Async.Support,
  MistralAI.Async.Params, MistralAI.Async.Promise, MistralAI.Conversations.Manager,
  MistralAI.Conversations.EventStreaming, MistralAI.API.Normalizer;

type
  /// <summary>
  /// Defines a reference callback type for handling streamed conversation event chunks.
  /// </summary>
  /// <remarks>
  /// <para>
  /// <c>TConversationsEventRef</c> is a procedure reference that is invoked for each chunk of a streaming
  /// conversation response. It provides the <see cref="TConversationsEvent"/> chunk, a flag indicating
  /// whether the stream is complete (<c>IsDone</c>), and a <c>Cancel</c> parameter that can be set to
  /// <c>True</c> to abort the stream.
  /// </para>
  /// <para>
  /// Implement this callback to process incoming event data incrementally and to control stream cancellation.
  /// </para>
  /// </remarks>
  TConversationsEventRef = reference to procedure(var Chunk: TConversationsEvent; IsDone: Boolean; var Cancel: Boolean);

  /// <summary>
  /// Defines an asynchronous callback type for operations returning a <see cref="TConversation"/> instance.
  /// </summary>
  /// <remarks>
  /// <para>
  /// <c>TAsyncConversation</c> is an alias for <c>TAsyncCallback&lt;TConversation&gt;</c>, providing a consistent pattern
  /// for handling the lifecycle of asynchronous conversation calls.
  /// </para>
  /// <para>
  /// Use this callback to register <c>OnStart</c>, <c>OnProgress</c>, <c>OnSuccess</c>, and <c>OnError</c> handlers
  /// when invoking methods that produce a <see cref="TConversation"/> asynchronously.
  /// </para>
  /// </remarks>
  TAsyncConversation = TAsyncCallback<TConversation>;

  /// <summary>
  /// Defines a promise-based asynchronous callback for operations returning a <see cref="TConversation"/> instance.
  /// </summary>
  /// <remarks>
  /// <para>
  /// <c>TPromiseConversation</c> is an alias for <c>TPromiseCallback&lt;TConversation&gt;</c>, offering a task-like interface
  /// for awaiting the result of an asynchronous conversation operation.
  /// </para>
  /// <para>
  /// Use this promise to <c>await</c> the completion of a conversation request—resolving with a <see cref="TConversation"/>
  /// on success or raising an exception on error.
  /// </para>
  /// </remarks>
  TPromiseConversation = TPromiseCallback<TConversation>;

  /// <summary>
  /// Defines an asynchronous streaming callback type for conversation events.
  /// </summary>
  /// <remarks>
  /// <para>
  /// <c>TAsyncConversationsEvent</c> is an alias for <c>TAsyncStreamCallBack&lt;TConversationsEvent&gt;</c>,
  /// providing a mechanism to handle streamed chunks of <see cref="TConversationsEvent"/> as they arrive.
  /// </para>
  /// <para>
  /// Use this callback to register <c>OnStart</c>, <c>OnProgress</c>, <c>OnSuccess</c>, and <c>OnError</c> handlers
  /// when invoking streaming conversation APIs.  Progress events deliver each <see cref="TConversationsEvent"/> chunk,
  /// and the final success event signals completion of the stream.
  /// </para>
  /// </remarks>
  TAsyncConversationsEvent = TAsyncStreamCallBack<TConversationsEvent>;

  /// <summary>
  /// Defines a promise-based asynchronous streaming callback for conversation events.
  /// </summary>
  /// <remarks>
  /// <para>
  /// <c>TPromiseConversationsEvent</c> is an alias for <c>TPromiseStreamCallBack&lt;TConversationsEvent&gt;</c>,
  /// providing a task-like interface for handling streamed conversation event chunks.
  /// </para>
  /// <para>
  /// Use this promise to <c>await</c> the full event stream—receiving each <see cref="TConversationsEvent"/> incrementally
  /// via progress callbacks and resolving when the stream completes, or raising an exception on error.
  /// </para>
  /// </remarks>
  TPromiseConversationsEvent = TPromiseStreamCallBack<TConversationsEvent>;

  /// <summary>
  /// Defines an asynchronous callback type for operations returning a <see cref="TConversationsList"/> instance.
  /// </summary>
  /// <remarks>
  /// <para>
  /// <c>TAsyncConversationsList</c> is an alias for <c>TAsyncCallback&lt;TConversationsList&gt;</c>, providing a structured mechanism
  /// for handling the lifecycle of asynchronous calls that produce a <see cref="TConversationsList"/>.
  /// </para>
  /// <para>
  /// Use this callback to register <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c> handlers when invoking methods
  /// that retrieve or process a list of conversations asynchronously.
  /// </para>
  /// </remarks>
  TAsyncConversationsList = TAsyncCallback<TConversationsList>;

  /// <summary>
  /// Defines a promise-based asynchronous callback for operations returning a <see cref="TConversationsList"/> instance.
  /// </summary>
  /// <remarks>
  /// <para>
  /// <c>TPromiseConversationsList</c> is an alias for <c>TPromiseCallback&lt;TConversationsList&gt;</c>, offering a task-like interface
  /// for awaiting the result of an asynchronous conversation-list operation.
  /// </para>
  /// <para>
  /// Use this promise to <c>await</c> the completion of a request that retrieves a <see cref="TConversationsList"/>;
  /// it resolves with the list on success or raises an exception on error.
  /// </para>
  /// </remarks>
  TPromiseConversationsList = TPromiseCallback<TConversationsList>;

  /// <summary>
  /// Defines an asynchronous callback type for operations returning a <see cref="TConversationsListItem"/> instance.
  /// </summary>
  /// <remarks>
  /// <para>
  /// <c>TAsyncConversationsListItem</c> is an alias for <c>TAsyncCallback&lt;TConversationsListItem&gt;</c>, providing a consistent pattern
  /// for handling the lifecycle of asynchronous calls that yield a single conversation list item.
  /// </para>
  /// <para>
  /// Use this callback to register <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c> handlers when invoking methods
  /// that fetch or process a <see cref="TConversationsListItem"/> asynchronously.
  /// </para>
  /// </remarks>
  TAsyncConversationsListItem = TAsyncCallback<TConversationsListItem>;

  /// <summary>
  /// Defines a promise-based asynchronous callback for operations returning a <see cref="TConversationsListItem"/> instance.
  /// </summary>
  /// <remarks>
  /// <para>
  /// <c>TPromiseConversationsListItem</c> is an alias for <c>TPromiseCallback&lt;TConversationsListItem&gt;</c>, providing
  /// a task-like interface for awaiting the outcome of an asynchronous operation that yields a single conversation list item.
  /// </para>
  /// <para>
  /// Use this promise to <c>await</c> the retrieval or processing of a <see cref="TConversationsListItem"/>, resolving
  /// with the item on success or raising an exception on error.
  /// </para>
  /// </remarks>
  TPromiseConversationsListItem = TPromiseCallback<TConversationsListItem>;

  /// <summary>
  /// Defines an asynchronous callback type for operations returning a <see cref="TRetrievedEntries"/> instance.
  /// </summary>
  /// <remarks>
  /// <para>
  /// <c>TAsyncRetrievedEntries</c> is an alias for <c>TAsyncCallback&lt;TRetrievedEntries&gt;</c>, providing
  /// a structured mechanism for handling the lifecycle of asynchronous calls that produce a <see cref="TRetrievedEntries"/>.
  /// </para>
  /// <para>
  /// Use this callback to register <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c> handlers when invoking methods
  /// that retrieve or process entries asynchronously.
  /// </para>
  /// </remarks>
  TAsyncRetrievedEntries = TAsyncCallback<TRetrievedEntries>;

  /// <summary>
  /// Defines a promise-based asynchronous callback for operations returning a <see cref="TRetrievedEntries"/> instance.
  /// </summary>
  /// <remarks>
  /// <para>
  /// <c>TPromiseRetrievedEntries</c> is an alias for <c>TPromiseCallback&lt;TRetrievedEntries&gt;</c>, offering a task-like interface
  /// for awaiting the result of an asynchronous entries retrieval operation.
  /// </para>
  /// <para>
  /// Use this promise to <c>await</c> the completion of a request that fetches <see cref="TRetrievedEntries"/>,
  /// resolving with the entries on success or raising an exception on error.
  /// </para>
  /// </remarks>
  TPromiseRetrievedEntries = TPromiseCallback<TRetrievedEntries>;

  /// <summary>
  /// Defines an asynchronous callback type for operations returning a <see cref="TRetrieveMessages"/> instance.
  /// </summary>
  /// <remarks>
  /// <para>
  /// <c>TAsyncRetrieveMessages</c> is an alias for <c>TAsyncCallback&lt;TRetrieveMessages&gt;</c>, providing
  /// a consistent pattern for handling the lifecycle of asynchronous calls that retrieve messages.
  /// </para>
  /// <para>
  /// Use this callback to register <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c> handlers when invoking
  /// methods that fetch message data asynchronously.
  /// </para>
  /// </remarks>
  TAsyncRetrieveMessages = TAsyncCallback<TRetrieveMessages>;

  /// <summary>
  /// Defines a promise-based asynchronous callback for operations returning a <see cref="TRetrieveMessages"/> instance.
  /// </summary>
  /// <remarks>
  /// <para>
  /// <c>TPromiseRetrieveMessages</c> is an alias for <c>TPromiseCallback&lt;TRetrieveMessages&gt;</c>, offering
  /// a task-like interface for awaiting the result of an asynchronous message retrieval operation.
  /// </para>
  /// <para>
  /// Use this promise to <c>await</c> the completion of a request that fetches <see cref="TRetrieveMessages"/>,
  /// resolving with the retrieved messages on success or raising an exception on error.
  /// </para>
  /// </remarks>
  TPromiseRetrieveMessages = TPromiseCallback<TRetrieveMessages>;

  TConversationsRouteInternal = class(TMistralAIAPIRoute)
  protected
    /// <summary>
    /// Performs a low‑level streaming request to the specified conversations endpoint.
    /// </summary>
    /// <param name="Endpoint">
    /// The relative API endpoint (for example, 'conversations' or 'conversations/{id}/stream')
    /// to which the streaming POST will be sent.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure that configures the <see cref="TConversationsParams"/>, including model,
    /// prompt, and any additional streaming options.
    /// </param>
    /// <param name="Event">
    /// A callback reference (<see cref="TConversationsEventRef"/>) invoked for each incoming
    /// <see cref="TConversationsEvent"/> chunk. The <c>IsDone</c> flag indicates end‑of‑stream,
    /// and setting <c>Cancel</c> to <c>True</c> aborts the stream.
    /// </param>
    /// <returns>
    /// <c>True</c> if the stream completed successfully or was cancelled via the callback;
    /// <c>False</c> if an unrecoverable error occurred during the HTTP transfer.
    /// </returns>
    /// <remarks>
    /// <para>
    /// This method issues a blocking HTTP POST to the given <paramref name="Endpoint"/>,
    /// writing raw response data into a buffer and parsing individual SSE‑style lines.
    /// For each non‑empty line, it normalizes and deserializes the JSON payload into
    /// a <see cref="TConversationsEvent"/> object, then invokes the <paramref name="Event"/>
    /// callback on the main thread to allow incremental UI updates or cancellation checks.
    /// </para>
    /// <para>
    /// When the special “[DONE]” sentinel is encountered, <c>IsDone</c> is passed as
    /// <c>True</c> and the loop breaks, triggering the final completion behavior.
    /// Any deserialization errors for individual chunks are swallowed, allowing
    /// the stream to continue until cancelled or finished.
    /// </para>
    /// </remarks>
    function CreateStreamInternal(const Endpoint: string;
      const ParamProc: TProc<TConversationsParams>;
      const Event: TConversationsEventRef): Boolean;

    /// <summary>
    /// Initiates an asynchronous streaming request to a conversations endpoint using callbacks.
    /// </summary>
    /// <param name="Endpoint">
    /// The relative API endpoint (e.g., 'conversations/stream') to which the streaming POST will be sent.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure the <see cref="TConversationsParams"/>, including model settings, prompt text,
    /// and streaming options such as max tokens or stop sequences.
    /// </param>
    /// <param name="Callbacks">
    /// A function that returns a <see cref="TAsyncConversationsEvent"/> instance, where you can assign
    /// <c>OnStart</c>, <c>OnProgress</c>, <c>OnSuccess</c>, <c>OnError</c>, and <c>OnDoCancel</c> handlers
    /// to manage the streaming lifecycle.
    /// </param>
    /// <remarks>
    /// <para>
    /// This method creates a background task that performs a non-blocking HTTP POST to the specified
    /// <paramref name="Endpoint"/>. It parses server-sent events (SSE) line by line, deserializes each
    /// JSON chunk into a <see cref="TConversationsEvent"/>, and invokes the <c>OnProgress</c> callback
    /// for each chunk. When the stream completes (or the callback signals cancellation), the
    /// <c>OnSuccess</c> or <c>OnCancellation</c> handler is called on the main thread.
    /// </para>
    /// <para>
    /// Errors during streaming trigger the <c>OnError</c> handler with the exception message.
    /// Cancellation is cooperative: if <c>OnDoCancel</c> returns <c>True</c>, the HTTP read loop aborts.
    /// </para>
    /// </remarks>
    procedure AsyncStreamInternal(
      const Endpoint  : string;
      const ParamProc : TProc<TConversationsParams>;
      const Callbacks : TFunc<TAsyncConversationsEvent>);

    /// <summary>
    /// Initiates an asynchronous streaming request to a conversations endpoint and returns a promise for the full response.
    /// </summary>
    /// <param name="Endpoint">
    /// The relative API endpoint (for example, 'conversations/{id}/stream') to which the streaming POST will be sent.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure the <see cref="TConversationsParams"/>, such as model selection, prompt text,
    /// and any streaming options (e.g., max tokens, stop sequences).
    /// </param>
    /// <param name="Callbacks">
    /// A function that returns a <see cref="TPromiseConversationsEvent"/> instance, where you can assign
    /// <c>OnStart</c>, <c>OnProgress</c>, <c>OnError</c>, and <c>OnDoCancel</c> handlers. Progress callbacks
    /// receive each <see cref="TConversationsEvent"/> chunk, and cancellation can be requested via <c>OnDoCancel</c>.
    /// </param>
    /// <returns>
    /// A <see cref="TPromise{String}"/> that resolves with the concatenated text of all chunks when the stream completes,
    /// or rejects with an exception if an error occurs or the stream is aborted.
    /// </returns>
    /// <remarks>
    /// <para>
    /// This method wraps the callback-based <see cref="AsyncStreamInternal"/> into a promise-based interface.
    /// It starts a background task that parses server-sent events (SSE) line by line, deserializes JSON
    /// into <see cref="TConversationsEvent"/> objects, and buffers text content. Each chunk triggers the
    /// <c>OnProgress</c> handler. When the special "[DONE]" sentinel is encountered, the accumulated buffer
    /// is resolved via the promise. Errors trigger promise rejection, and setting <c>Cancel</c> in <c>OnDoCancel</c>
    /// aborts the stream and rejects the promise with an "aborted" exception.
    /// </para>
    /// </remarks>
    function AsyncAwaitStreamInternal(
      const Endpoint  : string;
      const ParamProc : TProc<TConversationsParams>;
      const Callbacks : TFunc<TPromiseConversationsEvent>): TPromise<string>;
  end;

implementation

{ TConversationsRouteInternal }

function TConversationsRouteInternal.AsyncAwaitStreamInternal(
  const Endpoint: string; const ParamProc: TProc<TConversationsParams>;
  const Callbacks: TFunc<TPromiseConversationsEvent>): TPromise<string>;
begin
  Result := TPromise<string>.Create(
    procedure(Resolve: TProc<string>; Reject: TProc<Exception>)
    var
      Buffer: string;
    begin
      AsyncStreamInternal(Endpoint, ParamProc,
        function : TAsyncConversationsEvent
        begin
          Result.Sender := Callbacks.Sender;

          Result.OnStart := Callbacks.OnStart;

          Result.OnProgress :=
            procedure (Sender: TObject; Event: TConversationsEvent)
            begin
              if Assigned(Callbacks.OnProgress) then
                Callbacks.OnProgress(Sender, Event);

              case Event.&Type of
                TChunkEvent.conversation_response_done:
                  Resolve(Buffer);

                TChunkEvent.conversation_response_error:
                  Reject(Exception.Create(Event.Message));

                else
                  begin
                    for var Item in Event.Content do
                      if Item.&Type = TContentChunkType.text then
                        Buffer := Buffer + Item.Text;
                  end;
              end;
            end;

          Result.OnError :=
            procedure (Sender: TObject; Error: string)
            begin
              if Assigned(Callbacks.OnError) then
                Error := Callbacks.OnError(Sender, Error);
              Reject(Exception.Create(Error));
            end;

          Result.OnDoCancel :=
            function : Boolean
            begin
              if Assigned(Callbacks.OnDoCancel) then
                Result := Callbacks.OnDoCancel()
              else
                Result := False;
            end;

          Result.OnCancellation :=
            procedure (Sender: TObject)
            begin
              var Error := 'aborted';
              if Assigned(Callbacks.OnCancellation) then
                Error := Callbacks.OnCancellation(Sender);
              Reject(Exception.Create(Error));
            end;
        end);
    end);
end;

procedure TConversationsRouteInternal.AsyncStreamInternal(
  const Endpoint: string; const ParamProc: TProc<TConversationsParams>;
  const Callbacks: TFunc<TAsyncConversationsEvent>);
begin
  var CallbackParams := TUseParamsFactory<TAsyncConversationsEvent>.CreateInstance(Callbacks);

  var Sender := CallbackParams.Param.Sender;
  var OnStart := CallbackParams.Param.OnStart;
  var OnSuccess := CallbackParams.Param.OnSuccess;
  var OnProgress := CallbackParams.Param.OnProgress;
  var OnError := CallbackParams.Param.OnError;
  var OnCancellation := CallbackParams.Param.OnCancellation;
  var OnDoCancel := CallbackParams.Param.OnDoCancel;

  var Task: ITask := TTask.Create(
          procedure()
          begin
            {--- Pass the instance of the current class in case no value was specified. }
            if not Assigned(Sender) then
              Sender := Self;

            {--- Trigger OnStart callback }
            if Assigned(OnStart) then
              TThread.Queue(nil,
                procedure
                begin
                  OnStart(Sender);
                end);
            try
              var Stop := False;

              {--- Processing }
              CreateStreamInternal(Endpoint, ParamProc,
                procedure (var Chunk: TConversationsEvent; IsDone: Boolean; var Cancel: Boolean)
                begin
                  {--- Check that the process has not been canceled }
                  if Assigned(OnDoCancel) then
                    TThread.Queue(nil,
                        procedure
                        begin
                          Stop := OnDoCancel();
                        end);
                  if Stop then
                    begin
                      {--- Trigger when processus was stopped }
                      if Assigned(OnCancellation) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnCancellation(Sender)
                        end);
                      Cancel := True;
                      Exit;
                    end;
                  if not IsDone and Assigned(Chunk) then
                    begin
                      var LocalChunk := Chunk;
                      Chunk := nil;

                      {--- Triggered when processus is progressing }
                      if Assigned(OnProgress) then
                        TThread.Synchronize(TThread.Current,
                        procedure
                        begin
                          try
                            OnProgress(Sender, LocalChunk);
                          finally
                            {--- Makes sure to release the instance containing the data obtained
                                 following processing}
                            LocalChunk.Free;
                          end;
                        end)
                     else
                       LocalChunk.Free;
                    end
                  else
                  if IsDone then
                    begin
                      {--- Trigger OnEnd callback when the process is done }
                      if Assigned(OnSuccess) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnSuccess(Sender);
                        end);
                    end;
                end);
            except
              on E: Exception do
                begin
                  var Error := AcquireExceptionObject;
                  try
                    var ErrorMsg := (Error as Exception).Message;

                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(OnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        OnError(Sender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
          end);
  Task.Start;
end;

function TConversationsRouteInternal.CreateStreamInternal(
  const Endpoint: string; const ParamProc: TProc<TConversationsParams>;
  const Event: TConversationsEventRef): Boolean;
var
  Response: TStringStream;
  RetPos, LineFeed: Integer;
  ResponseBuffer, CurrentLine, Data, NewBuffer: string;
  Chunk: TConversationsEvent;
  IsDone: Boolean;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    RetPos := 0;
    Result := API.Post<TConversationsParams>(Endpoint, ParamProc, Response,
      procedure(const Sender: TObject; AContentLength, AReadCount: Int64; var AAbort: Boolean)
      begin
        try
          ResponseBuffer := Response.DataString;
        except
          on E: EEncodingError do
            Exit;
        end;

        LineFeed := ResponseBuffer.IndexOf(#10, RetPos);
        while LineFeed >= 0 do
          begin
            CurrentLine := ResponseBuffer.Substring(RetPos, LineFeed - RetPos).Trim([' ', #13, #10]);
            Inc(RetPos, LineFeed - RetPos + 1);

            if CurrentLine.IsEmpty then
              begin
                LineFeed := ResponseBuffer.IndexOf(#10, RetPos);
                Continue;
              end;

            if CurrentLine.StartsWith('data: ') then
              Data := CurrentLine.Substring(6).Trim
            else
              Data := CurrentLine;

            IsDone := SameText(Data, '[DONE]');

            Chunk := nil;
            if not IsDone then
              try
                Chunk := TApiDeserializer.Parse<TConversationsEvent>(
                  TJSONNormalizer.Normalize(Data, ['content']));
              except
                Chunk := nil;
              end;

            if Assigned(Event) then
              try
                Event(Chunk, IsDone, AAbort);
              finally
                Chunk.Free;
              end;

            if IsDone then
              Break;

            LineFeed := ResponseBuffer.IndexOf(#10, RetPos);
          end;

        if RetPos > 0 then
          begin
            NewBuffer := ResponseBuffer.Substring(RetPos);
            Response.Size := 0;
            if NewBuffer <> '' then
              Response.WriteString(NewBuffer);
            RetPos := 0;
          end;
      end);
  finally
    Response.Free;
  end;
end;

end.


unit MistralAI.Conversations.Manager;

interface

uses
  System.SysUtils, System.Classes, System.Json, REST.JsonReflect, REST.Json.Types,
  MistralAI.API.Params, MistralAI.API, MistralAI.Types;

type
  /// <summary>
  /// Defines URL parameters for specifying the version of an agent when querying or updating.
  /// </summary>
  TAgentVersionParams = class(TUrlParam)
    /// <summary>
    /// Sets the version number for the agent in the URL query.
    /// </summary>
    /// <param name="Value">
    /// The integer version identifier to include in the request.
    /// </param>
    /// <returns>
    /// The <see cref="TAgentVersionParams"/> instance for fluent chaining.
    /// </returns>
    function Version(const Value: Integer): TAgentVersionParams;
  end;

  /// <summary>
  /// Defines URL parameters for fetching a paginated list of conversations,
  /// allowing specification of the page number and the number of items per page.
  /// </summary>
  TConversationsListParams = class(TUrlParam)
    /// <summary>
    /// Sets the page number for the conversation list query.
    /// </summary>
    /// <param name="Value">
    /// The one-based index of the page to retrieve.
    /// </param>
    /// <returns>
    /// The <see cref="TConversationsListParams"/> instance, for fluent chaining.
    /// </returns>
    function Page(const Value: Integer): TConversationsListParams;

    /// <summary>
    /// Sets the number of conversation entries to return per page.
    /// </summary>
    /// <param name="Value">
    /// The maximum number of items to include on each page.
    /// </param>
    /// <returns>
    /// The <see cref="TConversationsListParams"/> instance, for fluent chaining.
    /// </returns>
    function PageSize(const Value: Integer): TConversationsListParams;
  end;

  TConversationsListCommon = class(TJSONFingerprint)
  private
    FName: string;
    FDescription: string;
    FObject: string;
    FId: string;
    [JsonNameAttribute('created_at')]
    FCreatedAt: string;
    [JsonNameAttribute('updated_at')]
    FUpdatedAt: string;
  public
    /// <summary>
    /// Gets or sets the display name of the conversation entry.
    /// </summary>
    property Name: string read FName write FName;

    /// <summary>
    /// Gets or sets a brief description of the conversation’s content or purpose.
    /// </summary>
    property Description: string read FDescription write FDescription;

    /// <summary>
    /// Gets or sets the resource object type for this entry.
    /// </summary>
    property &Object: string read FObject write FObject;

    /// <summary>
    /// Gets or sets the unique identifier for this conversation entry.
    /// </summary>
    property Id: string read FId write FId;

    /// <summary>
    /// Gets or sets the creation timestamp of the entry in ISO 8601 format.
    /// </summary>
    property CreatedAt: string read FCreatedAt write FCreatedAt;

    /// <summary>
    /// Gets or sets the last updated timestamp of the entry in ISO 8601 format.
    /// </summary>
    property UpdatedAt: string read FUpdatedAt write FUpdatedAt;
  end;

  TAgentConversation = class(TConversationsListCommon)
  private
    [JsonNameAttribute('agent_id')]
    FAgentId: string;
  public
    /// <summary>
    /// Gets or sets the agent’s unique identifier for this conversation.
    /// </summary>
    property AgentId: string read FAgentId write FAgentId;
  end;

  TPredictionObject = class
  private
    FType: string;
    FContent: string;
  public
    /// <summary>
    /// Gets or sets the prediction type (e.g., "content", "schema", etc.).
    /// </summary>
    property &Type: string read FType write FType;

    /// <summary>
    /// Gets or sets the prediction content.
    /// </summary>
    property Content: string read FContent write FContent;
  end;

  TJsonSchemaObject = class
  private
    FName: string;
    FDescription: string;
    FSchema: string;
    FStrict: Boolean;
  public
    /// <summary>
    /// Gets or sets the name of the JSON schema.
    /// </summary>
    property Name: string read FName write FName;

    /// <summary>
    /// Gets or sets the description of the JSON schema.
    /// </summary>
    property Description: string read FDescription write FDescription;

    /// <summary>
    /// Gets or sets the JSON schema content.
    /// </summary>
    property Schema: string read FSchema write FSchema;

    /// <summary>
    /// Gets or sets whether strict schema validation is applied.
    /// </summary>
    property Strict: Boolean read FStrict write FStrict;
  end;

  TCompletionArgs = class
  private
    [JsonReflectAttribute(ctString, rtString, TMetadataInterceptor)]
    FStop: string;
    [JsonNameAttribute('presence_penalty')]
    FPresencePenalty: Double;
    [JsonNameAttribute('frequency_penalty')]
    FFrequencyPenalty: Double;
    FTemperature: Double;
    [JsonNameAttribute('top_p')]
    FTopP: Double;
    [JsonNameAttribute('max_tokens')]
    FMaxTokens: Integer;
    [JsonNameAttribute('random_seed')]
    FRandomSeed: Integer;
    FPrediction: TPredictionObject;
    [JsonNameAttribute('json_schema')]
    [JsonReflectAttribute(ctString, rtString, TMetadataInterceptor)]
    FJsonSchema: TJsonSchemaObject;
    [JsonNameAttribute('tool_choice')]
    FToolChoice: string;
  public
    /// <summary>
    /// The values that causes the stop
    /// </summary>
    property Stop: string read FStop write FStop;

    /// <summary>
    /// Presence_penalty determines how much the model penalizes the repetition of words or phrases
    /// </summary>
    property PresencePenalty: Double read FPresencePenalty write FPresencePenalty;

    /// <summary>
    /// Frequency_penalty penalizes the repetition of words based on their frequency in the generated text.
    /// </summary>
    property FrequencyPenalty: Double read FFrequencyPenalty write FFrequencyPenalty;

    /// <summary>
    /// The sampling temperature to use for the model's output
    /// </summary>
    property Temperature: Double read FTemperature write FTemperature;

    /// <summary>
    /// The nucleus sampling probability mass for the model (Top-p)
    /// </summary>
    property TopP: Double read FTopP write FTopP;

    /// <summary>
    /// The maximum number of tokens to generate in the completion
    /// </summary>
    property MaxTokens: Integer read FMaxTokens write FMaxTokens;

    /// <summary>
    /// The random seed for deterministic results during sampling
    /// </summary>
    property RandomSeed: Integer read FRandomSeed write FRandomSeed;

    /// <summary>
    /// The users to specify expected results, optimizing response times by leveraging known or predictable content
    /// </summary>
    property Prediction: TPredictionObject read FPrediction write FPrediction;

    /// <summary>
    /// The json schema returned
    /// </summary>
    property JsonSchema: TJsonSchemaObject read FJsonSchema write FJsonSchema;

    /// <summary>
    /// How the model interacts with functions
    /// </summary>
    property ToolChoice: string read FToolChoice write FToolChoice;

    destructor Destroy; override;
  end;

  TToolFunctionObject = class
  private
    FName: string;
    FDescription: string;
    FStrict: Boolean;
    [JsonReflectAttribute(ctString, rtString, TMetadataInterceptor)]
    FParameters: string;
  public
    /// <summary>
    /// Gets or sets the function’s name.
    /// </summary>
    property Name: string read FName write FName;

    /// <summary>
    /// Gets or sets the function’s description.
    /// </summary>
    property Description: string read FDescription write FDescription;

    /// <summary>
    /// Gets or sets a value indicating whether the function requires strict parameter validation.
    /// </summary>
    property Strict: Boolean read FStrict write FStrict;

    /// <summary>
    /// Gets or sets the JSON schema that defines the function’s input parameters.
    /// </summary>
    property Parameters: string read FParameters write FParameters;
  end;

  TToolObject = class
  private
    FType: string;
    [JsonNameAttribute('open_results')]
    FOpenResults: Boolean;
    FFunction: TToolFunctionObject;
    [JsonNameAttribute('library_ids')]
    FLibraryIds: TArray<string>;
  public
    /// <summary>
    /// Gets or sets the tool’s type.
    /// </summary>
    property &Type: string read FType write FType;

    /// <summary>
    /// Gets or sets a flag indicating whether the tool should open its results by default.
    /// </summary>
    property OpenResults: Boolean read FOpenResults write FOpenResults;

    /// <summary>
    /// Gets or sets the function metadata associated with this tool.
    /// </summary>
    property &Function: TToolFunctionObject read FFunction write FFunction;

    /// <summary>
    /// Gets or sets the list of library IDs to which this tool has access.
    /// </summary>
    property LibraryIds: TArray<string> read FLibraryIds write FLibraryIds;

    destructor Destroy; override;
  end;

  TModelConversation = class(TAgentConversation)
  private
    FInstructions: string;
    FTools: TArray<TToolObject>;
    [JsonNameAttribute('completion_args')]
    FCompletionArgs: TCompletionArgs;
  public
    /// <summary>
    /// Instruction prompt the model will follow during the conversation.
    /// </summary>
    property Instructions: string read FInstructions write FInstructions;

    /// <summary>
    /// List of tools which are available to the model during the conversation.
    /// </summary>
    property Tools: TArray<TToolObject> read FTools write FTools;

    /// <summary>
    /// Completion arguments that will be used to generate assistant responses. Can be overridden at each message request.
    /// </summary>
    property CompletionArgs: TCompletionArgs read FCompletionArgs write FCompletionArgs;

    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a single conversation entry in a list of model-driven conversations.
  /// Inherits instructions, tools, completion arguments, and metadata from <see cref="TModelConversation"/>.
  /// </summary>
  TConversationsListItem = class(TModelConversation);

  /// <summary>
  /// Represents a collection of conversation entries, typically returned by the API
  /// when listing available conversations or conversation templates.
  /// </summary>
  TConversationsList = class(TJSONFingerprint)
  private
    FData: TArray<TConversationsListItem>;
  public
    /// <summary>
    /// Array of conversation list items, each containing metadata and settings
    /// for a specific conversation.
    /// </summary>
    property Data: TArray<TConversationsListItem> read FData write FData;

    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a conversation agent configuration, including its instruction prompt,
  /// available tools, completion parameters, and metadata such as model, ID, version,
  /// and timestamps for creation and updates.
  /// </summary>
  TConversationsAgent = class(TJSONFingerprint)
  private
    FInstructions: string;
    FTools: TArray<TToolObject>;
    [JsonNameAttribute('completion_args')]
    FCompletionArgs: TCompletionArgs;
    FModel: string;
    FName: string;
    FDescription: string;
    FHandoffs: TArray<string>;
    FObject: string;
    FId: string;
    FVersion: Int64;
    [JsonNameAttribute('created_at')]
    FCreatedAt: string;
    [JsonNameAttribute('updated_at')]
    FUpdatedAt: string;
  public
    /// <summary>
    /// Gets or sets the instruction prompt the agent will follow during the conversation.
    /// </summary>
    property Instructions: string read FInstructions write FInstructions;

    /// <summary>
    /// Gets or sets the list of tools available to this agent.
    /// </summary>
    property Tools: TArray<TToolObject> read FTools write FTools;

    /// <summary>
    /// Gets or sets the default completion arguments for this agent.
    /// </summary>
    property CompletionArgs: TCompletionArgs read FCompletionArgs write FCompletionArgs;

    /// <summary>
    /// Gets or sets the model identifier used by this agent.
    /// </summary>
    property Model: string read FModel write FModel;

    /// <summary>
    /// Gets or sets the human-readable name of the agent.
    /// </summary>
    property Name: string read FName write FName;

    /// <summary>
    /// Gets or sets the description of what this agent’s conversation is about.
    /// </summary>
    property Description: string read FDescription write FDescription;

    /// <summary>
    /// Gets or sets the list of handoff targets, defining how and when control transfers to other agents.
    /// </summary>
    property Handoffs: TArray<string> read FHandoffs write FHandoffs;

    /// <summary>
    /// Gets the object type, always "agent".
    /// </summary>
    property &Object: string read FObject write FObject;

    /// <summary>
    /// Gets or sets the unique identifier for this agent.
    /// </summary>
    property Id: string read FId write FId;

    /// <summary>
    /// Gets or sets the version number of this agent configuration.
    /// </summary>
    property Version: Int64 read FVersion write FVersion;

    /// <summary>
    /// Gets or sets the creation timestamp of this agent configuration.
    /// </summary>
    property CreatedAt: string read FCreatedAt write FCreatedAt;

    /// <summary>
    /// Gets or sets the last update timestamp of this agent configuration.
    /// </summary>
    property UpdatedAt: string read FUpdatedAt write FUpdatedAt;

    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a collection of agent conversation definitions,
  /// typically returned by the API when querying available agent configurations.
  /// </summary>
  TConversationsAgentList = class(TJSONFingerprint)
  private
    FData: TArray<TConversationsAgent>;
  public
    /// <summary>
    /// Gets or sets the array of agent conversation entries.
    /// </summary>
    property Data: TArray<TConversationsAgent> read FData write FData;
    destructor Destroy; override;
  end;

implementation

{ TConversationsListParams }

function TConversationsListParams.Page(
  const Value: Integer): TConversationsListParams;
begin
  Result := TConversationsListParams(Add('page', Value));
end;

function TConversationsListParams.PageSize(
  const Value: Integer): TConversationsListParams;
begin
  Result := TConversationsListParams(Add('page_size', Value));
end;

{ TModelConversation }

destructor TModelConversation.Destroy;
begin
  for var Item in FTools do
    Item.Free;
  if Assigned(FCompletionArgs) then
    FCompletionArgs.Free;
  inherited;
end;

{ TCompletionArgs }

destructor TCompletionArgs.Destroy;
begin
  if Assigned(FPrediction) then
    FPrediction.Free;
  if Assigned(FJsonSchema) then
    FJsonSchema.Free;
  inherited;
end;

{ TConversationsList }

destructor TConversationsList.Destroy;
begin
  for var Item in FData do
    Item.Free;
  inherited;
end;

{ TToolObject }

destructor TToolObject.Destroy;
begin
  if Assigned(FFunction) then
    FFunction.Free;
  inherited;
end;

{ TConversationsAgent }

destructor TConversationsAgent.Destroy;
begin
  for var Item in FTools do
    Item.Free;
  if Assigned(FCompletionArgs) then
    FCompletionArgs.Free;
  inherited;
end;

{ TConversationsAgentList }

destructor TConversationsAgentList.Destroy;
begin
  for var Item in FData do
    Item.Free;
  inherited;
end;

{ TAgentVersionParams }

function TAgentVersionParams.Version(const Value: Integer): TAgentVersionParams;
begin
  Result := TAgentVersionParams(Add('version', Value)); 
end;

end.

unit MistralAI.Conversations.Params;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Json, MistralAI.API.Params,
  MistralAI.API, MistralAI.Types, MistralAI.Schema, MistralAI.Functions.Core;

type
  TImageUrlParams = class(TJSONParam)
    /// <summary>
    /// Sets the URL for this image parameter.
    /// </summary>
    /// <param name="Value">
    /// A string containing the URL or base‑64-encoded image reference.
    /// </param>
    /// <returns>
    /// The same <see cref="TImageUrlParams"/> instance, with its <c>url</c> property updated.
    /// </returns>
    function Url(const Value: string): TImageUrlParams;

    /// <summary>
    /// Sets the detail description for this image parameter.
    /// </summary>
    /// <param name="Value">
    /// An optional string providing additional context or caption for the image.
    /// </param>
    /// <returns>
    /// The same <see cref="TImageUrlParams"/> instance, with its <c>detail</c> property updated.
    /// </returns>
    function Detail(const Value: string): TImageUrlParams;

    /// <summary>
    /// Creates a new <see cref="TImageUrlParams"/> instance.
    /// </summary>
    /// <returns>
    /// A fresh <see cref="TImageUrlParams"/> object with no properties set.
    /// </returns>
    class function New: TImageUrlParams;
  end;

  {$REGION 'TContentParams'}

  TContentParams = class(TJSONParam);

  TTextChunkParams = class(TContentParams)
    /// <summary>
    /// Sets the JSON <c>type</c> field for this text chunk.
    /// </summary>
    /// <param name="Value">
    /// The chunk type string (defaults to "text").
    /// </param>
    /// <returns>
    /// The same <see cref="TTextChunkParams"/> instance, with its <c>type</c> property updated.
    /// </returns>
    function &Type(const Value: string = 'text'): TTextChunkParams;

    /// <summary>
    /// Sets the text content for this chunk.
    /// </summary>
    /// <param name="Value">
    /// The string value to use as the text of the chunk.
    /// </param>
    /// <returns>
    /// The same <see cref="TTextChunkParams"/> instance, with its <c>text</c> property set.
    /// </returns>
    function Text(const Value: string): TTextChunkParams;

    /// <summary>
    /// Creates a new <see cref="TTextChunkParams"/> instance initialized as a text chunk.
    /// </summary>
    /// <returns>
    /// A fresh <see cref="TTextChunkParams"/> object with its <c>type</c> property set to "text".
    /// </returns>
    class function New: TTextChunkParams;
  end;

  TImageURLChunkParams = class(TContentParams)
    /// <summary>
    /// Sets the JSON <c>type</c> field for this image URL chunk.
    /// </summary>
    /// <param name="Value">
    /// The chunk type string (defaults to "image_url").
    /// </param>
    /// <returns>
    /// The same <see cref="TImageURLChunkParams"/> instance, with its <c>type</c> property updated.
    /// </returns>
    function &Type(const Value: string = 'image_url'): TImageURLChunkParams;

    /// <summary>
    /// Sets the image URL parameters for this chunk.
    /// </summary>
    /// <param name="Value">
    /// A <see cref="TImageUrlParams"/> instance specifying the URL and optional detail for the image.
    /// </param>
    /// <returns>
    /// The same <see cref="TImageURLChunkParams"/> instance, with its <c>image_url</c> property set.
    /// </returns>
    function ImageUrl(const Value: TImageUrlParams): TImageURLChunkParams;

    /// <summary>
    /// Creates a new <see cref="TImageURLChunkParams"/> instance initialized as an image URL chunk.
    /// </summary>
    /// <returns>
    /// A fresh <see cref="TImageURLChunkParams"/> object with its <c>type</c> property set to "image_url".
    /// </returns>
    class function New: TImageURLChunkParams;
  end;

  TToolFileChunkParams = class(TContentParams)
    /// <summary>
    /// Sets the JSON <c>type</c> field for this tool file chunk.
    /// </summary>
    /// <param name="Value">
    /// The chunk type string (defaults to "tool_file").
    /// </param>
    /// <returns>
    /// The same <see cref="TToolFileChunkParams"/> instance, with its <c>type</c> property updated.
    /// </returns>
    function &Type(const Value: string = 'tool_file'): TToolFileChunkParams;

    /// <summary>
    /// Specifies which tool processed this file chunk.
    /// </summary>
    /// <param name="Value">
    /// The identifier of the built‑in connector or tool name (e.g., "web_search", "code_interpreter").
    /// </param>
    /// <returns>
    /// The same <see cref="TToolFileChunkParams"/> instance, with its <c>tool</c> property set.
    /// </returns>
    function Tool(const Value: string): TToolFileChunkParams;

    /// <summary>
    /// Sets the unique file identifier for this chunk.
    /// </summary>
    /// <param name="Value">
    /// The file ID assigned by the tool for reference.
    /// </param>
    /// <returns>
    /// The same <see cref="TToolFileChunkParams"/> instance, with its <c>file_id</c> property updated.
    /// </returns>
    function FileId(const Value: string): TToolFileChunkParams;

    /// <summary>
    /// Sets the filename for this chunk.
    /// </summary>
    /// <param name="Value">
    /// The name of the file associated with this tool chunk.
    /// </param>
    /// <returns>
    /// The same <see cref="TToolFileChunkParams"/> instance, with its <c>file_name</c> property updated.
    /// </returns>
    function FileName(const Value: string): TToolFileChunkParams;

    /// <summary>
    /// Sets the file type for this chunk.
    /// </summary>
    /// <param name="Value">
    /// The MIME type or descriptor of the file (e.g., "application/pdf").
    /// </param>
    /// <returns>
    /// The same <see cref="TToolFileChunkParams"/> instance, with its <c>file_type</c> property updated.
    /// </returns>
    function FileType(const Value: string): TToolFileChunkParams;

    /// <summary>
    /// Creates a new <see cref="TToolFileChunkParams"/> instance initialized as a tool file chunk.
    /// </summary>
    /// <returns>
    /// A fresh <see cref="TToolFileChunkParams"/> object with its <c>type</c> property set to "tool_file".
    /// </returns>
    class function New: TToolFileChunkParams;
  end;

  TDocumentUrlChunkParams = class(TContentParams)
    /// <summary>
    /// Sets the JSON <c>type</c> field for this document URL chunk.
    /// </summary>
    /// <param name="Value">
    /// The chunk type string (defaults to "document_url").
    /// </param>
    /// <returns>
    /// The same <see cref="TDocumentUrlChunkParams"/> instance, with its <c>type</c> property updated.
    /// </returns>
    function &Type(const Value: string = 'document_url'): TDocumentUrlChunkParams;

    /// <summary>
    /// Specifies the document URL for this chunk.
    /// </summary>
    /// <param name="Value">
    /// A string containing the URL of the document resource.
    /// </param>
    /// <returns>
    /// The same <see cref="TDocumentUrlChunkParams"/> instance, with its <c>document_url</c> property set.
    /// </returns>
    function DocumentUrl(const Value: string): TDocumentUrlChunkParams;

    /// <summary>
    /// Specifies the document name for this chunk.
    /// </summary>
    /// <param name="Value">
    /// The filename or descriptive name of the document.
    /// </param>
    /// <returns>
    /// The same <see cref="TDocumentUrlChunkParams"/> instance, with its <c>document_name</c> property updated.
    /// </returns>
    function DocumentName(const Value: string): TDocumentUrlChunkParams;

    /// <summary>
    /// Creates a new <see cref="TDocumentUrlChunkParams"/> instance initialized as a document URL chunk.
    /// </summary>
    /// <returns>
    /// A fresh <see cref="TDocumentUrlChunkParams"/> object with its <c>type</c> property set to "document_url".
    /// </returns>
    class function New: TDocumentUrlChunkParams;
  end;

  {$ENDREGION}

  {$REGION 'TEntryParams'}

  TEntryParams = class(TJSONParam)
    /// <summary>
    /// Sets the JSON <object> field for this entry.
    /// </summary>
    /// <param name="Value">
    /// The object type identifier (for example, "entry").
    /// </param>
    /// <returns>
    /// The same <see cref="TEntryParams"/> instance, with its <c>object</c> property updated.
    /// </returns>
    function &Object(const Value: string): TEntryParams;

    /// <summary>
    /// Sets the JSON <type> field for this entry.
    /// </summary>
    /// <param name="Value">
    /// The entry type (for example, "message.input" or "function.result").
    /// </param>
    /// <returns>
    /// The same <see cref="TEntryParams"/> instance, with its <c>type</c> property updated.
    /// </returns>
    function &Type(const Value: string = 'message.input'): TEntryParams;

    /// <summary>
    /// Sets the creation timestamp for this entry.
    /// </summary>
    /// <param name="Value">
    /// An ISO 8601 date‑time string indicating when the entry was created.
    /// </param>
    /// <returns>
    /// The same <see cref="TEntryParams"/> instance, with its <c>created_at</c> property set.
    /// </returns>
    function CreatedAt(const Value: string): TEntryParams;

    /// <summary>
    /// Sets the completion timestamp for this entry.
    /// </summary>
    /// <param name="Value">
    /// An ISO 8601 date‑time string indicating when the entry was completed (or null if not completed).
    /// </param>
    /// <returns>
    /// The same <see cref="TEntryParams"/> instance, with its <c>completed_at</c> property set.
    /// </returns>
    function CompletedAt(const Value: string): TEntryParams;

    /// <summary>
    /// Sets the unique identifier for this entry.
    /// </summary>
    /// <param name="Value">
    /// A string representing the entry’s unique ID.
    /// </param>
    /// <returns>
    /// The same <see cref="TEntryParams"/> instance, with its <c>id</c> property set.
    /// </returns>
    function Id(const Value: string): TEntryParams;

    class function New: TEntryParams;
  end;

  TMessageInputEntryParams = class(TEntryParams)
    /// <summary>
    /// Sets the role for this message input entry.
    /// </summary>
    /// <param name="Value">
    /// A string indicating the sender role (for example, "user" or "assistant").
    /// </param>
    /// <returns>
    /// The same <see cref="TMessageInputEntryParams"/> instance, with its <c>role</c> property updated.
    /// </returns>
    function Role(const Value: string): TMessageInputEntryParams;

    /// <summary>
    /// Specifies the content of this message input entry as a single text string.
    /// </summary>
    /// <param name="Value">
    /// The full text content to include in the entry.
    /// </param>
    /// <returns>
    /// The same <see cref="TMessageInputEntryParams"/> instance, with its <c>content</c> property set to the given text.
    /// </returns>
    function Content(const Value: string): TMessageInputEntryParams; overload;

    /// <summary>
    /// Specifies the content of this message input entry using a sequence of content chunks.
    /// </summary>
    /// <param name="Value">
    /// An array of <see cref="TContentParams"/> instances representing one or more content chunks
    /// (e.g. text, image URL, document reference) to include in the entry.
    /// </param>
    /// <returns>
    /// The same <see cref="TMessageInputEntryParams"/> instance, with its <c>content</c> property populated
    /// by the provided chunk parameters.
    /// </returns>
    function Content(const Value: TArray<TContentParams>): TMessageInputEntryParams; overload;
  end;

  TFunctionResultEntryParams = class(TEntryParams)
    /// <summary>
    /// Sets the identifier of the tool call that produced this function result entry.
    /// </summary>
    /// <param name="Value">
    /// The unique ID of the tool call associated with this result entry.
    /// </param>
    /// <returns>
    /// The same <see cref="TFunctionResultEntryParams"/> instance, with its <c>tool_call_id</c> property updated.
    /// </returns>
    function ToolCallId(const Value: string): TFunctionResultEntryParams;

    /// <summary>
    /// Specifies the output produced by the tool call for this function result entry.
    /// </summary>
    /// <param name="Value">
    /// A string containing the result or return value from the tool execution.
    /// </param>
    /// <returns>
    /// The same <see cref="TFunctionResultEntryParams"/> instance, with its <c>result</c> property set to the provided value.
    /// </returns>
    function Result(const Value: string): TFunctionResultEntryParams;
  end;

  {$ENDREGION}

  TCompletionArgsParams = class(TJSONParam)
    /// <summary>
    /// Stop (string)
    /// Stop generation if this token is detected. Or if one of these tokens is detected when providing an array
    /// </summary>
    /// <param name="Value">
    /// The string that causes the stop
    /// </param>
    /// <returns>
    /// The updated <c>TCompletionArgsParams</c> instance.
    /// </returns>
    function Stop(const Value: string): TCompletionArgsParams; overload;

    /// <summary>
    /// Stop Array of Stop (strings) (Stop)
    /// Stop generation if this token is detected. Or if one of these tokens is detected when providing an array
    /// </summary>
    /// <param name="Value">
    /// The array of string that causes the stop
    /// </param>
    /// <returns>
    /// The updated <c>TCompletionArgsParams</c> instance.
    /// </returns>
    function Stop(const Value: TArray<string>): TCompletionArgsParams; overload;

    /// <summary>
    /// Presence_penalty determines how much the model penalizes the repetition of words or phrases
    /// </summary>
    /// <param name="Value">
    /// number (Presence Penalty) [ -2 .. 2 ]; Default: 0
    /// </param>
    /// <returns>
    /// The updated <c>TCompletionArgsParams</c> instance.
    /// </returns>
    /// <remarks>
    /// A higher presence penalty encourages the model to use a wider variety of words and phrases,
    /// making the output more diverse and creative.
    /// </remarks>
    function PresencePenalty(const Value: Double): TCompletionArgsParams;

    /// <summary>
    /// Frequency_penalty penalizes the repetition of words based on their frequency in the generated text.
    /// </summary>
    /// <param name="Value">
    /// number (Presence Penalty) [ -2 .. 2 ]; Default: 0
    /// </param>
    /// <returns>
    /// The updated <c>TCompletionArgsParams</c> instance.
    /// </returns>
    /// <remarks>
    /// A higher frequency penalty discourages the model from repeating words that have already appeared
    /// frequently in the output, promoting diversity and reducing repetition.
    /// </remarks>
    function FrequencyPenalty(const Value: Double): TCompletionArgsParams;

    /// <summary>
    /// Sets the sampling temperature to use for the model's output.
    /// Higher values like 0.8 make the output more random, while lower values like 0.2 make it more focused and deterministic.
    /// </summary>
    /// <param name="Value">
    /// The temperature value between 0.0 and 1.0. Default is 0.7.
    /// A temperature of 0 makes the model deterministic, while a temperature of 1 allows for maximum creativity.
    /// </param>
    /// <returns>
    /// The updated <c>TCompletionArgsParams</c> instance.
    /// </returns>
    function Temperature(const Value: Double): TCompletionArgsParams;

    /// <summary>
    /// Sets the nucleus sampling probability mass for the model (Top-p).
    /// For example, 0.1 means only the tokens comprising the top 10% probability mass are considered.
    /// </summary>
    /// <param name="Value">
    /// The <c>top_p</c> value between 0.0 and 1.0. Default is 1.
    /// Lower values limit the model to consider only the most probable options.
    /// </param>
    /// <returns>
    /// The updated <c>TCompletionArgsParams</c> instance.
    /// </returns>
    function TopP(const Value: Double): TCompletionArgsParams;

    /// <summary>
    /// Sets the maximum number of tokens to generate in the completion.
    /// The total token count of your prompt plus <c>max_tokens</c> cannot exceed the model's context length.
    /// </summary>
    /// <param name="Value">
    /// The maximum number of tokens to generate.
    /// Choose an appropriate value based on your prompt length to avoid exceeding the model's limit.
    /// </param>
    /// <returns>
    /// The updated <c>TCompletionArgsParams</c> instance.
    /// </returns>
    function MaxTokens(const Value: Integer): TCompletionArgsParams;

    /// <summary>
    /// Sets the random seed for deterministic results during sampling.
    /// </summary>
    /// <param name="Value">An integer value to be used as the seed.</param>
    /// <returns>
    /// The updated <c>TCompletionArgsParams</c> instance.
    /// </returns>
    /// <remarks>
    /// Providing a random seed ensures that multiple calls with the same parameters produce the same results, useful for testing or reproducible outcomes.
    /// </remarks>
    function RandomSeed(const Value: Integer): TCompletionArgsParams;

    /// <summary>
    /// Enable users to specify expected results, optimizing response times by leveraging known or
    /// predictable content.
    /// </summary>
    /// <param name="Value">The string prediction content.</param>
    /// <returns>
    /// The updated <c>TCompletionArgsParams</c> instance.
    /// </returns>
    /// <remarks>
    /// This approach is especially effective for updating text documents or code files with minimal
    /// changes, reducing latency while maintaining high-quality results.
    /// </remarks>
    function Prediction(const Value: string): TCompletionArgsParams;

    /// <summary>
    /// Specifies the format in which the model should return the response. This can include formats like JSON or plain text.
    /// </summary>
    /// <param name="Value">The <c>TResponseFormatParams</c> value.</param>
    /// <returns>
    /// The updated <c>TCompletionArgsParams</c> instance.
    /// </returns>
    /// <remarks>
    /// If not specified, the default value is <c>{ "type": "text" }</c>. When using JSON mode, it's necessary to instruct the model to produce JSON explicitly through the system or user messages.
    /// </remarks>
    function ResponseFormat(const Value: TResponseFormatParams): TCompletionArgsParams; overload;

    /// <summary>
    /// Specifies the format in which the model should return the response. This can include formats like JSON or plain text.
    /// </summary>
    /// <param name="Value">The string value.</param>
    /// <returns>
    /// The updated <c>TCompletionArgsParams</c> instance.
    /// </returns>
    function ResponseFormat(const Value: string): TCompletionArgsParams; overload;

    /// <summary>
    /// Configures how the model interacts with functions. This can either prevent, allow, or require function calls depending on the setting.
    /// </summary>
    /// <param name="Value">
    /// The <c>TToolChoice</c> setting for function interaction, with a default of "auto".
    /// </param>
    /// <returns>
    /// The updated <c>TCompletionArgsParams</c> instance.
    /// </returns>
    /// <remarks>
    /// If set to <c>none</c>, the model will not call any functions and will generate a message instead. If set to <c>auto</c>, the model can choose between generating a message or calling a function. If set to <c>any</c>, the model is required to call a function.
    /// </remarks>
    function ToolChoice(const Value: TToolChoice): TCompletionArgsParams; overload;

    /// <summary>
    /// Configures how the model interacts when required is on.
    /// </summary>
    /// <param name="Value">
    /// The <c>TToolChoice</c> setting for function interaction, with a default of "auto".
    /// </param>
    /// <returns>
    /// The updated <c>TCompletionArgsParams</c> instance.
    /// </returns>
    function ToolChoice(const Value: string): TCompletionArgsParams; overload;
  end;

  TToolFunctionParams = class(TJSONParam)
    /// <summary>
    /// The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
    /// </summary>
    function Name(const Value: string): TToolFunctionParams;

    /// <summary>
    /// A description of what the response format is for, used by the model to determine how to respond in the format.
    /// </summary>
    function Description(const Value: string): TToolFunctionParams;

    /// <summary>
    /// Whether to enable strict schema adherence when generating the output. If set to true, the model will always
    /// follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict
    /// is true.
    /// </summary>
    function Strict(const Value: Boolean): TToolFunctionParams;

    /// <summary>
    /// The parameters for the response format, described as a JSON Schema object. Learn how to build JSON schemas here.
    /// </summary>
    function Parameters(const Value: TJSONObject): TToolFunctionParams; overload;

    /// <summary>
    /// The parameters for the response format, described as a JSON Schema object. Learn how to build JSON schemas here.
    /// </summary>
    function Parameters(const Value: TSchemaParams): TToolFunctionParams; overload;
  end;

  TConnectorParams = class(TJSONParam)
    /// <summary>
    /// An object specifying the format that the model must output. Setting to { "type": "json_object" }
    /// enables JSON mode, which guarantees the message the model generates is in JSON. When using JSON
    /// mode you MUST also instruct the model to produce JSON yourself with a system or a user message.
    /// </summary>
    /// <param name="Value">
    /// Enum: "text" "json_object" "json_schema"
    /// </param>
    function &Type(const Value: TToolType): TConnectorParams; overload;

    /// <summary>
    /// An object specifying the format that the model must output. Setting to { "type": "json_object" }
    /// enables JSON mode, which guarantees the message the model generates is in JSON. When using JSON
    /// mode you MUST also instruct the model to produce JSON yourself with a system or a user message.
    /// </summary>
    /// <param name="Value">
    /// Enum: "text" "json_object" "json_schema"
    /// </param>
    function &Type(const Value: string): TConnectorParams; overload;

    /// <summary>
    /// Represents the object function called
    /// </summary>
    function &Function(const Value: TToolFunctionParams): TConnectorParams; overload;

    /// <summary>
    /// Represents the object function called
    /// </summary>
    function &Function(const Value: TJSONValue): TConnectorParams; overload;

    /// <summary>
    /// Ids of the library in which to search.
    /// </summary>
    function LibraryIds(const Value: TArray<string>): TConnectorParams; overload;

    class function New(const Value: TToolType): TConnectorParams; overload;
    class function New(const Value: string): TConnectorParams; overload;
    class function New(const Value: IFunctionCore): TConnectorParams; overload;
    class function New(const Value: TToolFunctionParams): TConnectorParams; overload;
    class function New(const Value: TArray<string>): TConnectorParams; overload;
  end;

  TConnector = record
  public
    class function web_search_premium: TConnectorParams; static;
    class function web_search: TConnectorParams; static;
    class function image_generation: TConnectorParams; static;
    class function code_interpreter: TConnectorParams; static;
    class function &function(const Value: IFunctionCore): TConnectorParams; overload; static;
    class function &function(const Value: TToolFunctionParams): TConnectorParams; overload; static;
    class function document_library(const Value: TArray<string>): TConnectorParams; static;
  end;

  TConversationsCommonParams = class(TJSONParam)
    /// <summary>
    /// Instruction prompt the model will follow during the conversation.
    /// </summary>
    function Instructions(const Value: string): TConversationsCommonParams; overload;

    /// <summary>
    /// Guidelines that the model will adhere to throughout the conversation when using a reasoning module.
    /// </summary>
    function Instructions(const Value: TReasoningInstruction = Default; Arg: string = ''): TConversationsCommonParams; overload;

    /// <summary>
    /// List of tools which are available to the model during the conversation.
    /// </summary>
    function Tools(const Value: TArray<TConnectorParams>): TConversationsCommonParams;

    /// <summary>
    /// Completion arguments that will be used to generate assistant responses.
    /// Can be overridden at each message request.
    /// </summary>
    function CompletionArgs(const Value: TCompletionArgsParams): TConversationsCommonParams;

    /// <summary>
    /// Model used with the agent
    /// </summary>
    function Model(const Value: string): TConversationsCommonParams;

    /// <summary>
    /// Agent name
    /// </summary>
    function Name(const Value: string): TConversationsCommonParams;

    /// <summary>
    /// Agent description
    /// </summary>
    function Description(const Value: string): TConversationsCommonParams;
  end;

  /// <summary>
  /// Defines the set of parameters used to configure and send a conversation request.
  /// </summary>
  /// <remarks>
  /// Use <see cref="Inputs"/> to specify the user input, either as plain text or as a sequence
  /// of <see cref="TEntryParams"/>. Control streaming behavior via <see cref="Stream"/>, and
  /// persist the response with <see cref="Store"/>. You can also configure automatic handoff
  /// execution, restart from a previous entry, or route through a specific agent.
  /// </remarks>
  TConversationsParams = class(TConversationsCommonParams)
    /// <summary>
    /// Specifies the conversation inputs using a plain text string.
    /// </summary>
    /// <param name="Value">
    /// A string containing the input to append to the conversation (for example, a user message or command).
    /// </param>
    /// <returns>
    /// The same <see cref="TConversationsParams"/> instance, with its <c>inputs</c> property set to the provided value.
    /// </returns>
    function Inputs(const Value: string): TConversationsParams; overload;

    /// <summary>
    /// Specifies the conversation inputs using a collection of entry parameters.
    /// </summary>
    /// <param name="Value">
    /// An array of <see cref="TEntryParams"/> instances representing individual input entries
    /// (such as user messages or function results) to append to the conversation.
    /// </param>
    /// <returns>
    /// The same <see cref="TConversationsParams"/> instance, with its <c>inputs</c> property
    /// populated by the provided entry parameters.
    /// </returns>
    function Inputs(const Value: TArray<TEntryParams>): TConversationsParams; overload;

    /// <summary>
    /// Specifies whether to stream back partial progress as server-sent events (SSE).
    /// If <c>true</c>, tokens are sent as they become available.
    /// If <c>false</c>, the server will hold the request open until timeout or completion.
    /// </summary>
    /// <param name="Value">
    /// A boolean value indicating whether to enable streaming. Default is <c>true</c>, meaning streaming is enabled by default.
    /// </param>
    /// <returns>
    /// The updated <c>TConversationsParams</c> instance.
    /// </returns>
    function Stream(const Value: Boolean = True): TConversationsParams;

    /// <summary>
    /// Whether to store the generated model response for later retrieval via API.
    /// </summary>
    /// <returns>
    /// The updated <c>TConversationsParams</c> instance.
    /// </returns>
    function Store(const Value: Boolean = True): TConversationsParams;

    /// <summary>
    /// Handoffs is the control-transfer mechanism for an action, configurable either to execute automatically
    /// on the server side or to hand execution back to the user in client mode.
    /// </summary>
    /// <returns>
    /// The updated <c>TConversationsParams</c> instance.
    /// </returns>
    function HandoffExecution(const Value: THandoffExecutionType): TConversationsParams; overload;

    /// <summary>
    /// Handoffs is the control-transfer mechanism for an action, configurable either to execute automatically
    /// on the server side or to hand execution back to the user in client mode.
    /// </summary>
    /// <returns>
    /// The updated <c>TConversationsParams</c> instance.
    /// </returns>
    function HandoffExecution(const Value: string): TConversationsParams; overload;

    /// <summary>
    /// Specify the agent ID to be used for the conversation.
    /// </summary>
    /// <returns>
    /// The updated <c>TConversationsParams</c> instance.
    /// </returns>
    function AgentId(const Value: string): TConversationsParams;

    /// <summary>
    /// Specify the identifier from which the conversation will be restarted.
    /// </summary>
    /// <returns>
    /// The updated <c>TConversationsParams</c> instance.
    /// </returns>
    function FromEntryId(const Value: string): TConversationsParams;
  end;

  /// <summary>
  /// Defines the parameters for configuring an agent within a conversation context.
  /// </summary>
  /// <remarks>
  /// Extend <see cref="TConversationsCommonParams"/> to include agent-specific settings.
  /// Use <see cref="Handoffs"/> to declare which handoff mechanisms this agent supports
  /// (for example, server‑side automation or client‑side control transfer).
  /// </remarks>
  TConversationsAgentParams = class(TConversationsCommonParams)
    /// <summary>
    /// Handoffs is the control-transfer mechanism for an action, configurable either to execute automatically
    /// on the server side or to hand execution back to the user in client mode.
    /// </summary>
    function Handoffs(const Value: TArray<string>): TConversationsAgentParams;
  end;

implementation

{ TConversationsParams }

function TConversationsParams.AgentId(const Value: string): TConversationsParams;
begin
  Result := TConversationsParams(Add('agent_id', Value));
end;

function TConversationsParams.FromEntryId(
  const Value: string): TConversationsParams;
begin
  Result := TConversationsParams(Add('from_entry_id', Value));
end;

function TConversationsParams.HandoffExecution(
  const Value: THandoffExecutionType): TConversationsParams;
begin
  Result := TConversationsParams(Add('handoff_execution', Value.ToString));
end;

function TConversationsParams.HandoffExecution(
  const Value: string): TConversationsParams;
begin
  Result := TConversationsParams(Add('handoff_execution', THandoffExecutionType.Create(Value).ToString));
end;

function TConversationsParams.Inputs(const Value: string): TConversationsParams;
begin
  Result := TConversationsParams(Add('inputs', Value));
end;

function TConversationsParams.Inputs(
  const Value: TArray<TEntryParams>): TConversationsParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TConversationsParams(Add('inputs', JSONArray));
end;

function TConversationsParams.Store(const Value: Boolean): TConversationsParams;
begin
  Result := TConversationsParams(Add('store', Value));
end;

function TConversationsParams.Stream(const Value: Boolean): TConversationsParams;
begin
  Result := TConversationsParams(Add('stream', Value));
end;

{ TEntryParams }

function TEntryParams.&Type(const Value: string): TEntryParams;
begin
  Result := TEntryParams(Add('type', Value));
end;

function TEntryParams.CompletedAt(const Value: string): TEntryParams;
begin
  Result := TEntryParams(Add('completed_at', Value));
end;

function TEntryParams.CreatedAt(const Value: string): TEntryParams;
begin
  Result := TEntryParams(Add('created_at', Value));
end;

function TEntryParams.Id(const Value: string): TEntryParams;
begin
  Result := TEntryParams(Add('id', Value));
end;

class function TEntryParams.New: TEntryParams;
begin
  Result := TEntryParams.Create.&Type();
end;

function TEntryParams.&Object(const Value: string): TEntryParams;
begin
  Result := TEntryParams(Add('object', Value));
end;

{ TMessageInputEntryParams }

function TMessageInputEntryParams.Content(
  const Value: string): TMessageInputEntryParams;
begin
  Result := TMessageInputEntryParams(Add('content', Value));
end;

function TMessageInputEntryParams.Content(
  const Value: TArray<TContentParams>): TMessageInputEntryParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TMessageInputEntryParams(Add('content', JSONArray));
end;

function TMessageInputEntryParams.Role(
  const Value: string): TMessageInputEntryParams;
begin
  Result := TMessageInputEntryParams(Add('role', TMessageRole.Create(Value).ToString));
end;

{ TTextChunkParams }

class function TTextChunkParams.New: TTextChunkParams;
begin
  Result := TTextChunkParams.Create.&Type();
end;

function TTextChunkParams.Text(
  const Value: string): TTextChunkParams;
begin
  Result := TTextChunkParams(Add('text', Value));
end;

function TTextChunkParams.&Type(
  const Value: string): TTextChunkParams;
begin
  Result := TTextChunkParams(Add('type', Value));
end;

{ TImageURLChunkParams }

function TImageURLChunkParams.ImageUrl(
  const Value: TImageUrlParams): TImageURLChunkParams;
begin
  Result := TImageURLChunkParams(Add('image_url', Value.Detach));
end;

class function TImageURLChunkParams.New: TImageURLChunkParams;
begin
  Result := TImageURLChunkParams.Create.&Type();
end;

function TImageURLChunkParams.&Type(const Value: string): TImageURLChunkParams;
begin
  Result := TImageURLChunkParams(Add('type', Value));
end;

{ TImageUrlParams }

function TImageUrlParams.Detail(const Value: string): TImageUrlParams;
begin
  Result := TImageUrlParams(Add('detail', Value));
end;

class function TImageUrlParams.New: TImageUrlParams;
begin
  Result := TImageUrlParams.Create;
end;

function TImageUrlParams.Url(const Value: string): TImageUrlParams;
begin
  Result := TImageUrlParams(Add('url', Value));
end;

{ TToolFileChunkParams }

function TToolFileChunkParams.FileId(const Value: string): TToolFileChunkParams;
begin
  Result := TToolFileChunkParams(Add('file_id', Value));
end;

function TToolFileChunkParams.FileName(
  const Value: string): TToolFileChunkParams;
begin
  Result := TToolFileChunkParams(Add('file_name', Value));
end;

function TToolFileChunkParams.FileType(
  const Value: string): TToolFileChunkParams;
begin
  Result := TToolFileChunkParams(Add('file_type', Value));
end;

class function TToolFileChunkParams.New: TToolFileChunkParams;
begin
  Result := TToolFileChunkParams.Create.&Type();
end;

function TToolFileChunkParams.Tool(const Value: string): TToolFileChunkParams;
begin
  Result := TToolFileChunkParams(Add('tool', Value));
end;

function TToolFileChunkParams.&Type(const Value: string): TToolFileChunkParams;
begin
  Result := TToolFileChunkParams(Add('type', Value));
end;

{ TDocumentUrlChunkParams }

function TDocumentUrlChunkParams.DocumentName(
  const Value: string): TDocumentUrlChunkParams;
begin
  Result := TDocumentUrlChunkParams(Add('document_name', Value));
end;

function TDocumentUrlChunkParams.DocumentUrl(
  const Value: string): TDocumentUrlChunkParams;
begin
  Result := TDocumentUrlChunkParams(Add('document_url', Value));
end;

class function TDocumentUrlChunkParams.New: TDocumentUrlChunkParams;
begin
  Result := TDocumentUrlChunkParams.Create.&Type();
end;

function TDocumentUrlChunkParams.&Type(
  const Value: string): TDocumentUrlChunkParams;
begin
  Result := TDocumentUrlChunkParams(Add('type', Value));
end;

{ TFunctionResultEntryParams }

function TFunctionResultEntryParams.Result(
  const Value: string): TFunctionResultEntryParams;
begin
  Result := TFunctionResultEntryParams(Add('result', Value));
end;

function TFunctionResultEntryParams.ToolCallId(
  const Value: string): TFunctionResultEntryParams;
begin
  Result := TFunctionResultEntryParams(Add('tool_call_id', Value));
end;

{ TCompletionArgsParams }

function TCompletionArgsParams.Stop(const Value: string): TCompletionArgsParams;
begin
  Result := TCompletionArgsParams(Add('stop', Value));
end;

function TCompletionArgsParams.FrequencyPenalty(
  const Value: Double): TCompletionArgsParams;
begin
  Result := TCompletionArgsParams(Add('frequency_penalty', Value));
end;

function TCompletionArgsParams.MaxTokens(
  const Value: Integer): TCompletionArgsParams;
begin
  Result := TCompletionArgsParams(Add('max_tokens', Value));
end;

function TCompletionArgsParams.Prediction(
  const Value: string): TCompletionArgsParams;
begin
  Result := TCompletionArgsParams(Add('prediction',
    TJSONObject.Create
      .AddPair('type', 'content')
      .AddPair('content', Value)
    ));
end;

function TCompletionArgsParams.PresencePenalty(
  const Value: Double): TCompletionArgsParams;
begin
  Result := TCompletionArgsParams(Add('presence_penalty', Value));
end;

function TCompletionArgsParams.RandomSeed(
  const Value: Integer): TCompletionArgsParams;
begin
  Result := TCompletionArgsParams(Add('random_seed', Value));
end;

function TCompletionArgsParams.ResponseFormat(
  const Value: string): TCompletionArgsParams;
begin
  Result := TCompletionArgsParams(Add('response_format', TResponseFormatParams.Json_Schema(Value)));
end;

function TCompletionArgsParams.ResponseFormat(
  const Value: TResponseFormatParams): TCompletionArgsParams;
begin
  Result := TCompletionArgsParams(Add('response_format', Value.Detach));
end;

function TCompletionArgsParams.Stop(
  const Value: TArray<string>): TCompletionArgsParams;
begin
  Result := TCompletionArgsParams(Add('stop', Value));
end;

function TCompletionArgsParams.Temperature(
  const Value: Double): TCompletionArgsParams;
begin
  Result := TCompletionArgsParams(Add('temperature', Value));
end;

function TCompletionArgsParams.ToolChoice(
  const Value: TToolChoice): TCompletionArgsParams;
begin
  Result := TCompletionArgsParams(Add('tool_choice', Value.ToString));
end;

function TCompletionArgsParams.ToolChoice(
  const Value: string): TCompletionArgsParams;
begin
  Result := TCompletionArgsParams(Add('tool_choice', TToolChoice.Create(Value).ToString));
end;

function TCompletionArgsParams.TopP(const Value: Double): TCompletionArgsParams;
begin
  Result := TCompletionArgsParams(Add('top_p', Value));
end;

{ TConnectorParams }

function TConnectorParams.&Function(const Value: TToolFunctionParams): TConnectorParams;
begin
  Result := TConnectorParams(Add('function', Value.Detach));
end;

class function TConnectorParams.New(const Value: string): TConnectorParams;
begin
  Result := TConnectorParams.Create.&Type(Value);
end;

function TConnectorParams.&Type(const Value: string): TConnectorParams;
begin
  Result := TConnectorParams(Add('type', TToolType.Create(Value).ToString));
end;

class function TConnectorParams.New(const Value: TToolType): TConnectorParams;
begin
  Result := TConnectorParams.Create.&Type(Value);
end;

function TConnectorParams.&Type(const Value: TToolType): TConnectorParams;
begin
  Result := TConnectorParams(Add('type', Value.ToString));
end;

class function TConnectorParams.New(const Value: IFunctionCore): TConnectorParams;
begin
  Result := TConnectorParams.Create
    .&Type('function')
    .&function(TJSONObject.ParseJSONValue(Value.ToString));
end;

function TConnectorParams.&Function(const Value: TJSONValue): TConnectorParams;
begin
  Result := TConnectorParams(Add('function', Value));
end;

function TConnectorParams.LibraryIds(const Value: TArray<string>): TConnectorParams;
begin
  Result := TConnectorParams(Add('library_ids', Value));
end;

class function TConnectorParams.New(const Value: TArray<string>): TConnectorParams;
begin
  Result := TConnectorParams.Create.&Type('document_library').LibraryIds(Value);
end;

class function TConnectorParams.New(
  const Value: TToolFunctionParams): TConnectorParams;
begin
  Result := TConnectorParams.Create
    .&Type('function')
    .&function(Value);
end;

{ TToolFunctionParams }

function TToolFunctionParams.Description(
  const Value: string): TToolFunctionParams;
begin
  Result := TToolFunctionParams(Add('description', Value));
end;

function TToolFunctionParams.Name(const Value: string): TToolFunctionParams;
begin
  Result := TToolFunctionParams(Add('name', Value));
end;

function TToolFunctionParams.Parameters(
  const Value: TSchemaParams): TToolFunctionParams;
begin
  Result := TToolFunctionParams(Add('parameters', Value.Detach));
end;

function TToolFunctionParams.Parameters(
  const Value: TJSONObject): TToolFunctionParams;
begin
  Result := TToolFunctionParams(Add('parameters', Value));
end;

function TToolFunctionParams.Strict(const Value: Boolean): TToolFunctionParams;
begin
  Result := TToolFunctionParams(Add('strict', Value));
end;

{ TConnector }

class function TConnector.document_library(
  const Value: TArray<string>): TConnectorParams;
begin
  Result := TConnectorParams.New(Value);
end;

class function TConnector.&function(const Value: IFunctionCore): TConnectorParams;
begin
  Result := TConnectorParams.New(Value);
end;

class function TConnector.&function(
  const Value: TToolFunctionParams): TConnectorParams;
begin
  Result := TConnectorParams.New(Value);
end;

class function TConnector.code_interpreter: TConnectorParams;
begin
  Result := TConnectorParams.New('code_interpreter');
end;

class function TConnector.image_generation: TConnectorParams;
begin
  Result := TConnectorParams.New('image_generation');
end;

class function TConnector.web_search: TConnectorParams;
begin
  Result := TConnectorParams.New('web_search');
end;

class function TConnector.web_search_premium: TConnectorParams;
begin
  Result := TConnectorParams.New('web_search_premium');
end;

{ TConversationsCommonParams }

function TConversationsCommonParams.CompletionArgs(
  const Value: TCompletionArgsParams): TConversationsCommonParams;
begin
  Result := TConversationsCommonParams(Add('completion_args', Value.Detach));
end;

function TConversationsCommonParams.Description(
  const Value: string): TConversationsCommonParams;
begin
  Result := TConversationsCommonParams(Add('description', Value));
end;

function TConversationsCommonParams.Instructions(
  const Value: TReasoningInstruction; Arg: string): TConversationsCommonParams;
begin
  case Value of
    Custom:
      Result := TConversationsCommonParams(Add('instructions', Arg));
    else
      Result := TConversationsCommonParams(Add('instructions', Value.ToString));
  end;
end;

function TConversationsCommonParams.Instructions(
  const Value: string): TConversationsCommonParams;
begin
  Result := TConversationsCommonParams(Add('instructions', Value));
end;

function TConversationsCommonParams.Model(
  const Value: string): TConversationsCommonParams;
begin
  Result := TConversationsCommonParams(Add('model', Value));
end;

function TConversationsCommonParams.Name(
  const Value: string): TConversationsCommonParams;
begin
  Result := TConversationsCommonParams(Add('name', Value));
end;

function TConversationsCommonParams.Tools(
  const Value: TArray<TConnectorParams>): TConversationsCommonParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TConversationsCommonParams(Add('tools', JSONArray));
end;

{ TConversationsAgentParams }

function TConversationsAgentParams.Handoffs(const Value: TArray<string>): TConversationsAgentParams;
begin
  Result := TConversationsAgentParams(Add('handoffs', Value));
end;

end.

unit MistralAI.Conversations;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Threading,
  MistralAI.API.Params, MistralAI.API, MistralAI.Types, MistralAI.Conversations.Params,
  MistralAI.Async.Params, MistralAI.Async.Support, MistralAI.Async.Promise,
  MistralAI.Conversations.Chunks, MistralAI.Conversations.Manager,
  MistralAI.Conversations.EventStreaming, MistralAI.Conversations.Internal,
  MistralAI.Async.Parallel;

type
  /// <summary>
  /// Provides a high‑level interface for managing conversation resources.
  /// </summary>
  /// <remarks>
  /// Inherits from <see cref="TConversationsRouteInternal"/> and exposes synchronous,
  /// asynchronous, and streaming methods to create, append, restart, list, retrieve,
  /// and stream conversation events. Designed for seamless integration with the
  /// MistralAI Conversations API, it centralizes operations on conversations and
  /// handles request/response normalization, streaming event parsing, and error handling.
  /// </remarks>
  TConversationsRoute =  class(TConversationsRouteInternal)
  public
    /// <summary>
    /// Initiates an asynchronous "create conversation" request and returns a promise for the resulting conversation.
    /// </summary>
    /// <remarks>
    /// This method wraps the callback‑based <c>AsyncCreate</c> invocation in a promise interface.
    /// It sends the configured parameters to the "conversations" endpoint and resolves when the full
    /// <see cref="TConversation"/> object is available, or rejects on error.
    /// </remarks>
    /// <param name="ParamProc">
    /// A procedure that configures the <see cref="TConversationsParams"/>, including model selection,
    /// prompt text, and any additional options such as stop sequences or maximum tokens.
    /// </param>
    /// <param name="Callbacks">
    /// Optional. A function returning a <see cref="TPromiseConversation"/> that allows hooking into
    /// <c>OnStart</c>, <c>OnProgress</c>, <c>OnSuccess</c>, and <c>OnError</c> events.
    /// </param>
    /// <returns>
    /// A <see cref="TPromise{TConversation}"/> that resolves with the created <see cref="TConversation"/>
    /// when the API call completes successfully, or rejects with an exception on failure.
    /// </returns>
    function AsyncAwaitCreate(
      const ParamProc: TProc<TConversationsParams>;
      const Callbacks: TFunc<TPromiseConversation> = nil): TPromise<TConversation>;

    /// <summary>
    /// Initiates parallel processing of multiple chat prompts and returns a promise for the bundled results.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the bundle parameters (model, prompts, reasoning effort, etc.) before dispatch.
    /// </param>
    /// <param name="CallBacks">
    /// An optional function that provides a <see cref="TPromiseBundleList"/> record for hooking into lifecycle events.
    /// </param>
    /// <returns>
    /// A <see cref="TPromise&lt;TBundleList&gt;"/> that resolves with a <see cref="TBundleList"/> containing all responses
    /// once every parallel task completes, or rejects on the first error.
    /// </returns>
    /// <remarks>
    /// This method wraps the callback-based <see cref="CreateParallel"/> in a promise interface, enabling async/await usage
    /// for parallel prompt execution. If <paramref name="CallBacks"/> is omitted, only the promise resolution is available.
    /// </remarks>
    function AsyncAwaitCreateParallel(const ParamProc: TProc<TBundleParams>;
      const CallBacks: TFunc<TPromiseBundleList> = nil): TPromise<TBundleList>;

    /// <summary>
    /// Initiates an asynchronous streaming "create conversation" request and returns a promise for the concatenated response text.
    /// </summary>
    /// <remarks>
    /// This method wraps the callback‑based <c>AsyncCreateStream</c> invocation into a promise interface.
    /// It sends the configured parameters to the "conversations#stream" endpoint and collects each
    /// chunk of the server‑sent events (SSE) stream into a single string. The promise resolves when
    /// the stream ends or rejects on error.
    /// </remarks>
    /// <param name="ParamProc">
    /// A procedure that configures the <see cref="TConversationsParams"/>, including model selection,
    /// prompt text, and any streaming options such as maximum tokens or stop sequences.
    /// </param>
    /// <param name="Callbacks">
    /// Optional. A function returning a <see cref="TPromiseConversationsEvent"/> that allows hooking into
    /// <c>OnStart</c>, <c>OnProgress</c>, <c>OnError</c>, and <c>OnDoCancel</c> events for each stream chunk.
    /// </param>
    /// <returns>
    /// A <see cref="TPromise{String}"/> that resolves with the full concatenated text of all chunks when
    /// the stream completes, or rejects with an exception if an error occurs or the stream is aborted.
    /// </returns>
    function AsyncAwaitCreateStream(
      const ParamProc: TProc<TConversationsParams>;
      const Callbacks: TFunc<TPromiseConversationsEvent> = nil): TPromise<string>;

    /// <summary>
    /// Initiates an asynchronous streaming "append to conversation" request and returns a promise for the concatenated response text.
    /// </summary>
    /// <remarks>
    /// This method wraps the callback‑based <c>AsyncAppendStream</c> invocation in a promise interface.
    /// It sends the configured parameters to the "conversations/{ConversationId}#stream" endpoint,
    /// processes each server‑sent event (SSE) chunk, and accumulates the text into a single string.
    /// The promise resolves when the stream ends or rejects on error.
    /// </remarks>
    /// <param name="ConversationId">
    /// The identifier of the conversation to which new input is appended.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure that configures the <see cref="TConversationsParams"/>, including the new message content,
    /// model settings, and any streaming options such as stop sequences or maximum tokens.
    /// </param>
    /// <param name="Callbacks">
    /// Optional. A function returning a <see cref="TPromiseConversationsEvent"/> that allows hooking into
    /// <c>OnStart</c>, <c>OnProgress</c>, <c>OnError</c>, and <c>OnDoCancel</c> events for each incoming chunk.
    /// </param>
    /// <returns>
    /// A <see cref="TPromise{String}"/> that resolves with the full concatenated text of all SSE chunks when
    /// the append stream completes, or rejects with an exception if an error occurs or the stream is aborted.
    /// </returns>
    function AsyncAwaitAppendStream(
      const ConversationId: string;
      const ParamProc: TProc<TConversationsParams>;
      const Callbacks: TFunc<TPromiseConversationsEvent> = nil): TPromise<string>;

    /// <summary>
    /// Initiates an asynchronous streaming "restart conversation" request and returns a promise for the concatenated response text.
    /// </summary>
    /// <remarks>
    /// This method wraps the callback‑based <c>AsyncRestartStream</c> invocation in a promise interface.
    /// It sends the configured parameters to the "conversations/{ConversationId}/restart#stream" endpoint,
    /// processes each server‑sent event (SSE) chunk, and accumulates the text into a single string.
    /// The promise resolves when the stream ends or rejects on error.
    /// </remarks>
    /// <param name="ConversationId">
    /// The identifier of the conversation to restart; the new stream will begin from the conversation’s start.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure that configures the <see cref="TConversationsParams"/>, including the initial prompt,
    /// model settings, and any streaming options such as stop sequences or maximum tokens.
    /// </param>
    /// <param name="Callbacks">
    /// Optional. A function returning a <see cref="TPromiseConversationsEvent"/> that allows hooking into
    /// <c>OnStart</c>, <c>OnProgress</c>, <c>OnError</c>, and <c>OnDoCancel</c> events for each stream chunk.
    /// </param>
    /// <returns>
    /// A <see cref="TPromise{String}"/> that resolves with the full concatenated text of all SSE chunks when
    /// the restart stream completes, or rejects with an exception if an error occurs or the stream is aborted.
    /// </returns>
    function AsyncAwaitRestartStream(
      const ConversationId: string;
      const ParamProc: TProc<TConversationsParams>;
      const Callbacks: TFunc<TPromiseConversationsEvent> = nil): TPromise<string>;

    /// <summary>
    /// Initiates an asynchronous "append to conversation" request and returns a promise for the updated conversation.
    /// </summary>
    /// <remarks>
    /// This method wraps the callback‑based <c>AsyncAppend</c> invocation into a promise interface.
    /// It sends the configured parameters to the "conversations/{ConversationId}" endpoint and resolves with the
    /// full <see cref="TConversation"/> object once the append operation completes, or rejects on error.
    /// </remarks>
    /// <param name="ConversationId">
    /// The identifier of the existing conversation to which the new input will be appended.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure that configures the <see cref="TConversationsParams"/>, including the message content,
    /// model selection, and any additional options such as stop sequences or maximum tokens.
    /// </param>
    /// <param name="Callbacks">
    /// Optional. A function returning a <see cref="TPromiseConversation"/> that allows hooking into
    /// <c>OnStart</c>, <c>OnProgress</c>, <c>OnSuccess</c>, and <c>OnError</c> events.
    /// </param>
    /// <returns>
    /// A <see cref="TPromise{TConversation}"/> that resolves with the updated <see cref="TConversation"/>
    /// when the API call completes successfully, or rejects with an exception on failure.
    /// </returns>
    function AsyncAwaitAppend(
      const ConversationId: string;
      const ParamProc: TProc<TConversationsParams>;
      const Callbacks: TFunc<TPromiseConversation> = nil): TPromise<TConversation>;

    /// <summary>
    /// Initiates an asynchronous "list conversations" request and returns a promise for the conversation list.
    /// </summary>
    /// <remarks>
    /// This method wraps the callback‑based <c>AsyncList</c> invocation into a promise interface.
    /// It sends the configured parameters to the "conversations" endpoint and resolves with a
    /// <see cref="TConversationsList"/> containing metadata and entries, or rejects on error.
    /// </remarks>
    /// <param name="ParamProc">
    /// A procedure that configures the <see cref="TConversationsListParams"/>, including pagination,
    /// filtering, or sorting options for the returned conversations.
    /// </param>
    /// <param name="Callbacks">
    /// Optional. A function returning a <see cref="TPromiseConversationsList"/> that allows hooking
    /// into <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c> events.
    /// </param>
    /// <returns>
    /// A <see cref="TPromise{TConversationsList}"/> that resolves with the retrieved
    /// <see cref="TConversationsList"/> when the API call completes successfully, or rejects with
    /// an exception on failure.
    /// </returns>
    function AsyncAwaitList(
      const ParamProc: TProc<TConversationsListParams>;
      const Callbacks: TFunc<TPromiseConversationsList> = nil): TPromise<TConversationsList>;

    /// <summary>
    /// Initiates an asynchronous request to retrieve a specific conversation and returns a promise for the conversation item.
    /// </summary>
    /// <remarks>
    /// This method wraps the callback‑based <c>AsyncRetrieve</c> invocation into a promise interface.
    /// It sends a GET request to the "conversations/{ConversationId}" endpoint and resolves with the
    /// <see cref="TConversationsListItem"/> containing the conversation metadata and messages, or rejects on error.
    /// </remarks>
    /// <param name="ConversationId">
    /// The identifier of the conversation to retrieve.
    /// </param>
    /// <param name="Callbacks">
    /// Optional. A function returning a <see cref="TPromiseConversationsListItem"/> that allows hooking into
    /// <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c> events for the retrieval operation.
    /// </param>
    /// <returns>
    /// A <see cref="TPromise{TConversationsListItem}"/> that resolves with the requested
    /// <see cref="TConversationsListItem"/> when the API call completes successfully, or rejects with an exception on failure.
    /// </returns>
    function AsyncAwaitRetrieve(
      const ConversationId: string;
      const Callbacks: TFunc<TPromiseConversationsListItem> = nil): TPromise<TConversationsListItem>;

    /// <summary>
    /// Initiates an asynchronous request to fetch the full history of a conversation and returns a promise for the entries.
    /// </summary>
    /// <remarks>
    /// This method wraps the callback‑based <c>AsyncGetHistory</c> into a promise interface.
    /// It issues a GET request to the "conversations/{ConversationId}/history" endpoint and resolves with
    /// a <see cref="TRetrievedEntries"/> containing all entries (messages, function calls, etc.), or rejects on error.
    /// </remarks>
    /// <param name="ConversationId">
    /// The identifier of the conversation whose history is being retrieved.
    /// </param>
    /// <param name="Callbacks">
    /// Optional. A function returning a <see cref="TPromiseRetrievedEntries"/> that allows hooking into
    /// <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c> events for the retrieval process.
    /// </param>
    /// <returns>
    /// A <see cref="TPromise{TRetrievedEntries}"/> that resolves with the complete conversation history
    /// when the API call completes successfully, or rejects with an exception on failure.
    /// </returns>
    function AsyncAwaitGetHistory(
      const ConversationId: string;
      const Callbacks: TFunc<TPromiseRetrievedEntries> = nil): TPromise<TRetrievedEntries>;

    /// <summary>
    /// Initiates an asynchronous request to fetch all messages of a conversation and returns a promise for the messages.
    /// </summary>
    /// <remarks>
    /// This method wraps the callback‑based <c>AsyncGetMessages</c> into a promise interface.
    /// It issues a GET request to the "conversations/{ConversationId}/messages" endpoint and resolves with
    /// a <see cref="TRetrieveMessages"/> containing only the message entries, or rejects on error.
    /// </remarks>
    /// <param name="ConversationId">
    /// The identifier of the conversation whose messages are being retrieved.
    /// </param>
    /// <param name="Callbacks">
    /// Optional. A function returning a <see cref="TPromiseRetrieveMessages"/> that allows hooking into
    /// <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c> events for the message retrieval operation.
    /// </param>
    /// <returns>
    /// A <see cref="TPromise{TRetrieveMessages}"/> that resolves with the conversation’s messages
    /// when the API call completes successfully, or rejects with an exception on failure.
    /// </returns>
    function AsyncAwaitGetMessages(
      const ConversationId: string;
      const Callbacks: TFunc<TPromiseRetrieveMessages> = nil): TPromise<TRetrieveMessages>;

    /// <summary>
    /// Initiates an asynchronous "restart conversation" request and returns a promise for the restarted conversation.
    /// </summary>
    /// <remarks>
    /// This method wraps the callback‑based <c>AsyncRestart</c> invocation into a promise interface.
    /// It sends the configured parameters to the "conversations/{ConversationId}/restart" endpoint and
    /// resolves with a fresh <see cref="TConversation"/> object that reflects the conversation restarted
    /// from its initial state, or rejects on error.
    /// </remarks>
    /// <param name="ConversationId">
    /// The identifier of the conversation to restart.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure that configures the <see cref="TConversationsParams"/>, including the initial prompt,
    /// model selection, and any options such as stop sequences or maximum tokens.
    /// </param>
    /// <param name="Callbacks">
    /// Optional. A function returning a <see cref="TPromiseConversation"/> that allows hooking into
    /// <c>OnStart</c>, <c>OnProgress</c>, <c>OnSuccess</c>, and <c>OnError</c> events.
    /// </param>
    /// <returns>
    /// A <see cref="TPromise{TConversation}"/> that resolves with the restarted <see cref="TConversation"/>
    /// when the API call completes successfully, or rejects with an exception on failure.
    /// </returns>
    function AsyncAwaitRestart(
      const ConversationId: string;
      const ParamProc: TProc<TConversationsParams>;
      const Callbacks: TFunc<TPromiseConversation> = nil): TPromise<TConversation>;

    /// <summary>
    /// Sends a synchronous "create conversation" request and returns the resulting conversation.
    /// </summary>
    /// <remarks>
    /// This method issues a POST to the "conversations" endpoint using the configured parameters.
    /// It blocks until the API returns a <see cref="TConversation"/> object or raises an exception on failure.
    /// </remarks>
    /// <param name="ParamProc">
    /// A procedure that configures the <see cref="TConversationsParams"/>, including model selection,
    /// prompt text, and any additional options such as stop sequences or maximum tokens.
    /// </param>
    /// <returns>
    /// The newly created <see cref="TConversation"/> containing the conversation ID and initial outputs.
    /// </returns>
    function Create(const ParamProc: TProc<TConversationsParams>): TConversation;

    /// <summary>
    /// Initiates parallel processing of chat prompts by creating multiple chat completions
    /// asynchronously, with results stored in a bundle and provided back to the callback function.
    /// This method allows for parallel processing of multiple prompts in an efficient manner,
    /// handling errors and successes for each chat completion.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure delegate that configures the parameters for the bundle. It is responsible
    /// for providing the necessary settings (such as model and reasoning effort) for the chat completions.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns an instance of TAsynBuffer, which manages the lifecycle of the
    /// asynchronous operation. The callbacks include handlers for start, error, and success events.
    /// </param>
    /// <remarks>
    /// The method allows for efficient parallel processing of multiple prompts by delegating
    /// individual tasks to separate threads. It each task's result is properly bundled and communicated back to the caller.
    /// If an error occurs, the error handling callback will be triggered, and the rest of the tasks
    /// will continue processing. The success callback is triggered once all tasks are completed.
    /// </remarks>
    procedure CreateParallel(const ParamProc: TProc<TBundleParams>;
      const CallBacks: TFunc<TAsynBundleList>);

    /// <summary>
    /// Sends a synchronous streaming "create conversation" request and returns a success flag.
    /// </summary>
    /// <remarks>
    /// This method issues a POST to the "conversations#stream" endpoint using the configured parameters
    /// and invokes the provided <see cref="TConversationsEventRef"/> callback for each server‑sent event chunk.
    /// It blocks until the stream completes or an unrecoverable error occurs.
    /// </remarks>
    /// <param name="ParamProc">
    /// A procedure that configures the <see cref="TConversationsParams"/>, including model selection,
    /// prompt text, and any streaming options such as maximum tokens or stop sequences.
    /// </param>
    /// <param name="Event">
    /// A reference callback (<see cref="TConversationsEventRef"/>) invoked for each <see cref="TConversationsEvent"/> chunk.
    /// Use the <c>IsDone</c> flag to detect end‑of‑stream and set <c>Cancel</c> to abort prematurely.
    /// </param>
    /// <returns>
    /// <c>True</c> if the stream completed successfully or was cancelled via the callback;
    /// <c>False</c> if an unrecoverable error occurred during HTTP transfer.
    /// </returns>
    function CreateStream(
      const ParamProc: TProc<TConversationsParams>;
      const Event: TConversationsEventRef): Boolean;

    /// <summary>
    /// Sends a synchronous streaming "append to conversation" request and returns a success flag.
    /// </summary>
    /// <remarks>
    /// This method issues a POST to the "conversations/{ConversationId}#stream" endpoint using the configured parameters
    /// and invokes the provided <see cref="TConversationsEventRef"/> callback for each server‑sent event (SSE) chunk.
    /// It blocks until the stream completes or an unrecoverable error occurs.
    /// </remarks>
    /// <param name="ConversationId">
    /// The identifier of the conversation to which new input is appended.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure that configures the <see cref="TConversationsParams"/>, including the appended message content,
    /// model settings, and any streaming options such as stop sequences or maximum tokens.
    /// </param>
    /// <param name="Event">
    /// A reference callback (<see cref="TConversationsEventRef"/>) invoked for each <see cref="TConversationsEvent"/> chunk.
    /// The <c>IsDone</c> flag indicates end‑of‑stream; setting <c>Cancel</c> to <c>True</c> aborts the stream.
    /// </param>
    /// <returns>
    /// <c>True</c> if the stream completed successfully or was cancelled via the callback;
    /// <c>False</c> if an unrecoverable error occurred during HTTP transfer.
    /// </returns>
    function AppendStream(
      const ConversationId: string;
      const ParamProc: TProc<TConversationsParams>;
      const Event: TConversationsEventRef): Boolean; overload;

    /// <summary>
    /// Sends a synchronous streaming "restart conversation" request and returns a success flag.
    /// </summary>
    /// <remarks>
    /// This method issues a POST to the "conversations/{ConversationId}/restart#stream" endpoint using the configured parameters
    /// and invokes the provided <see cref="TConversationsEventRef"/> callback for each server‑sent event (SSE) chunk.
    /// It blocks until the stream completes or an unrecoverable error occurs.
    /// </remarks>
    /// <param name="ConversationId">
    /// The identifier of the conversation to restart; the stream will begin from the conversation’s start.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure that configures the <see cref="TConversationsParams"/>, including the initial prompt,
    /// model settings, and any streaming options such as stop sequences or maximum tokens.
    /// </param>
    /// <param name="Event">
    /// A reference callback (<see cref="TConversationsEventRef"/>) invoked for each <see cref="TConversationsEvent"/> chunk.
    /// The <c>IsDone</c> flag indicates end‑of‑stream; setting <c>Cancel</c> to <c>True</c> aborts the stream.
    /// </param>
    /// <returns>
    /// <c>True</c> if the stream completed successfully or was cancelled via the callback;
    /// <c>False</c> if an unrecoverable error occurred during HTTP transfer.
    /// </returns>
    function RestartStream(
      const ConversationId: string;
      const ParamProc: TProc<TConversationsParams>;
      const Event: TConversationsEventRef): Boolean; overload;

    /// <summary>
    /// Sends a synchronous "append to conversation" request and returns the updated conversation.
    /// </summary>
    /// <remarks>
    /// This method issues a POST to the "conversations/{ConversationId}" endpoint using the configured parameters.
    /// It blocks until the API returns the full <see cref="TConversation"/> object reflecting the appended input,
    /// or raises an exception on failure.
    /// </remarks>
    /// <param name="ConversationId">
    /// The identifier of the conversation to which new input will be appended.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure that configures the <see cref="TConversationsParams"/>, including the message content,
    /// model selection, and any additional options such as stop sequences or maximum tokens.
    /// </param>
    /// <returns>
    /// The updated <see cref="TConversation"/> containing the full conversation state after the append operation.
    /// </returns>
    function Append(
      const ConversationId: string;
      const ParamProc: TProc<TConversationsParams>): TConversation;

    /// <summary>
    /// Sends a synchronous "list conversations" request and returns the conversation list.
    /// </summary>
    /// <remarks>
    /// This method issues a GET to the "conversations" endpoint using the configured parameters.
    /// It blocks until the API returns a <see cref="TConversationsList"/> containing conversation metadata
    /// and entries, or raises an exception on failure.
    /// </remarks>
    /// <param name="ParamProc">
    /// A procedure that configures the <see cref="TConversationsListParams"/>, including pagination,
    /// filtering, or sorting options for the returned conversations.
    /// </param>
    /// <returns>
    /// A <see cref="TConversationsList"/> containing the retrieved conversations and their metadata.
    /// </returns>
    function List(const ParamProc: TProc<TConversationsListParams>): TConversationsList;

    /// <summary>
    /// Sends a synchronous request to retrieve a specific conversation and returns the conversation item.
    /// </summary>
    /// <remarks>
    /// This method issues a GET to the "conversations/{ConversationId}" endpoint using the provided identifier.
    /// It blocks until the API returns a <see cref="TConversationsListItem"/> containing the conversation’s
    /// metadata and messages, or raises an exception on failure.
    /// </remarks>
    /// <param name="ConversationId">
    /// The identifier of the conversation to retrieve.
    /// </param>
    /// <returns>
    /// A <see cref="TConversationsListItem"/> representing the retrieved conversation,
    /// including its messages and associated metadata.
    /// </returns>
    function Retrieve(const ConversationId: string): TConversationsListItem;

    /// <summary>
    /// Sends a synchronous request to fetch the full history of a conversation and returns all entries.
    /// </summary>
    /// <remarks>
    /// This method issues a GET to the "conversations/{ConversationId}/history" endpoint using the provided identifier.
    /// It blocks until the API returns a <see cref="TRetrievedEntries"/> object containing every entry
    /// (messages, function calls, etc.) in the conversation, or raises an exception on failure.
    /// </remarks>
    /// <param name="ConversationId">
    /// The identifier of the conversation whose history is being retrieved.
    /// </param>
    /// <returns>
    /// A <see cref="TRetrievedEntries"/> containing the complete sequence of entries for the specified conversation.
    /// </returns>
    function GetHistory(const ConversationId: string): TRetrievedEntries;

    /// <summary>
    /// Sends a synchronous request to fetch all messages of a conversation and returns the message entries.
    /// </summary>
    /// <remarks>
    /// This method issues a GET to the "conversations/{ConversationId}/messages" endpoint using the provided identifier.
    /// It blocks until the API returns a <see cref="TRetrieveMessages"/> object containing all message entries,
    /// or raises an exception on failure.
    /// </remarks>
    /// <param name="ConversationId">
    /// The identifier of the conversation whose messages are being retrieved.
    /// </param>
    /// <returns>
    /// A <see cref="TRetrieveMessages"/> containing the list of message entries for the specified conversation.
    /// </returns>
    function GetMessages(const ConversationId: string): TRetrieveMessages;

    /// <summary>
    /// Sends a synchronous "restart conversation" request and returns the restarted conversation.
    /// </summary>
    /// <remarks>
    /// This method issues a POST to the "conversations/{ConversationId}/restart" endpoint using the configured parameters.
    /// It blocks until the API returns a <see cref="TConversation"/> object reflecting the conversation restarted
    /// from its initial state, or raises an exception on failure.
    /// </remarks>
    /// <param name="ConversationId">
    /// The identifier of the conversation to restart.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure that configures the <see cref="TConversationsParams"/>, including the initial prompt,
    /// model settings, and any options such as stop sequences or maximum tokens.
    /// </param>
    /// <returns>
    /// The newly created <see cref="TConversation"/> representing the restarted conversation.
    /// </returns>
    function Restart(
      const ConversationId: string;
      const ParamProc: TProc<TConversationsParams>): TConversation;

    /// <summary>
    /// Initiates an asynchronous "create conversation" request using callbacks.
    /// </summary>
    /// <remarks>
    /// This method sends the configured parameters to the "conversations" endpoint and invokes
    /// the provided callback handlers for lifecycle events. It uses <c>AsyncCreate</c> internally.
    /// </remarks>
    /// <param name="ParamProc">
    /// A procedure that configures the <see cref="TConversationsParams"/>, including model selection,
    /// prompt text, and any additional options such as stop sequences or maximum tokens.
    /// </param>
    /// <param name="Callbacks">
    /// A function returning a <see cref="TAsyncConversation"/>. Use the returned object’s
    /// <c>OnStart</c> event to respond when the request begins, <c>OnSuccess</c> to handle
    /// the resulting <see cref="TConversation"/> on success, and <c>OnError</c> to handle any
    /// error message if the request fails.
    /// </param>
    procedure AsyncCreate(
      const ParamProc: TProc<TConversationsParams>;
      const Callbacks: TFunc<TAsyncConversation>);

    /// <summary>
    /// Initiates an asynchronous streaming "create conversation" request using callbacks.
    /// </summary>
    /// <remarks>
    /// This method sends the configured parameters to the "conversations#stream" endpoint and invokes
    /// the provided callback handlers for each server‑sent event chunk. It uses <c>AsyncCreateStream</c> internally.
    /// </remarks>
    /// <param name="ParamProc">
    /// A procedure that configures the <see cref="TConversationsParams"/>, including model selection,
    /// prompt text, and any streaming options such as maximum tokens or stop sequences.
    /// </param>
    /// <param name="Callbacks">
    /// A function returning a <see cref="TAsyncConversationsEvent"/>. Use the returned object’s
    /// <c>OnStart</c> event to respond when the stream begins, <c>OnProgress</c> to handle each
    /// <see cref="TConversationsEvent"/> chunk, <c>OnError</c> to handle any errors during streaming,
    /// and <c>OnDoCancel</c> to cooperatively abort the stream if needed.
    /// </param>
    procedure AsyncCreateStream(
      const ParamProc: TProc<TConversationsParams>;
      const Callbacks: TFunc<TAsyncConversationsEvent>);

    /// <summary>
    /// Initiates an asynchronous streaming "append to conversation" request using callbacks.
    /// </summary>
    /// <remarks>
    /// This method sends the configured parameters to the "conversations/{ConversationId}#stream" endpoint and invokes
    /// the provided callback handlers for each server‑sent event chunk. It uses <c>AsyncAppendStream</c> internally.
    /// </remarks>
    /// <param name="ConversationId">
    /// The identifier of the existing conversation to which new input is appended.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure that configures the <see cref="TConversationsParams"/>, including the appended message content,
    /// model selection, and any streaming options such as stop sequences or maximum tokens.
    /// </param>
    /// <param name="Callbacks">
    /// A function returning a <see cref="TAsyncConversationsEvent"/>. Use the returned object’s <c>OnStart</c> event
    /// to respond when the stream begins, <c>OnProgress</c> to handle each <see cref="TConversationsEvent"/> chunk,
    /// <c>OnError</c> to handle any streaming errors, and <c>OnDoCancel</c> to cooperatively abort the stream if needed.
    /// </param>
    procedure AsyncAppendStream(
      const ConversationId: string;
      const ParamProc: TProc<TConversationsParams>;
      const Callbacks: TFunc<TAsyncConversationsEvent>);

    /// <summary>
    /// Initiates an asynchronous streaming "restart conversation" request using callbacks.
    /// </summary>
    /// <remarks>
    /// This method sends the configured parameters to the "conversations/{ConversationId}/restart#stream" endpoint
    /// and invokes the provided callback handlers for each server‑sent event chunk. It uses <c>AsyncRestartStream</c> internally.
    /// </remarks>
    /// <param name="ConversationId">
    /// The identifier of the conversation to restart; the stream will begin from the conversation’s initial state.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure that configures the <see cref="TConversationsParams"/>, including the initial prompt,
    /// model selection, and any streaming options such as stop sequences or maximum tokens.
    /// </param>
    /// <param name="Callbacks">
    /// A function returning a <see cref="TAsyncConversationsEvent"/>. Use the returned object’s
    /// <c>OnStart</c> event to respond when the stream begins, <c>OnProgress</c> to handle each
    /// <see cref="TConversationsEvent"/> chunk, <c>OnError</c> to handle any streaming errors,
    /// and <c>OnDoCancel</c> to cooperatively abort the stream if needed.
    /// </param>
    procedure AsyncRestartStream(
      const ConversationId: string;
      const ParamProc: TProc<TConversationsParams>;
      const Callbacks: TFunc<TAsyncConversationsEvent>);

    /// <summary>
    /// Initiates an asynchronous "append to conversation" request using callbacks.
    /// </summary>
    /// <remarks>
    /// This method sends the configured parameters to the "conversations/{ConversationId}" endpoint
    /// and invokes the provided callback handlers for lifecycle events. It uses <c>AsyncAppend</c> internally.
    /// </remarks>
    /// <param name="ConversationId">
    /// The identifier of the existing conversation to which new input will be appended.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure that configures the <see cref="TConversationsParams"/>, including the appended message content,
    /// model selection, and any additional options such as stop sequences or maximum tokens.
    /// </param>
    /// <param name="Callbacks">
    /// A function returning a <see cref="TAsyncConversation"/>. Use the returned object’s <c>OnStart</c> event
    /// to respond when the request begins, <c>OnSuccess</c> to handle the resulting <see cref="TConversation"/> on success,
    /// and <c>OnError</c> to handle any error message if the request fails.
    /// </param>
    procedure AsyncAppend(
      const ConversationId: string;
      const ParamProc: TProc<TConversationsParams>;
      const Callbacks: TFunc<TAsyncConversation>);

    /// <summary>
    /// Initiates an asynchronous "list conversations" request using callbacks.
    /// </summary>
    /// <remarks>
    /// This method sends the configured parameters to the "conversations" endpoint and invokes
    /// the provided callback handlers for lifecycle events. It uses <c>AsyncList</c> internally.
    /// </remarks>
    /// <param name="ParamProc">
    /// A procedure that configures the <see cref="TConversationsListParams"/>, including pagination,
    /// filtering, or sorting options for the returned conversations.
    /// </param>
    /// <param name="Callbacks">
    /// A function returning a <see cref="TAsyncConversationsList"/>. Use the returned object’s
    /// <c>OnStart</c> event to respond when the request begins, <c>OnSuccess</c> to handle the resulting
    /// <see cref="TConversationsList"/> on success, and <c>OnError</c> to handle any error if the request fails.
    /// </param>
    procedure AsyncList(
      const ParamProc: TProc<TConversationsListParams>;
      const Callbacks: TFunc<TAsyncConversationsList>);

    /// <summary>
    /// Initiates an asynchronous request to retrieve a specific conversation using callbacks.
    /// </summary>
    /// <remarks>
    /// This method sends a GET request to the "conversations/{ConversationId}" endpoint and invokes
    /// the provided callback handlers for lifecycle events. It uses <c>AsyncRetrieve</c> internally.
    /// </remarks>
    /// <param name="ConversationId">
    /// The identifier of the conversation to retrieve.
    /// </param>
    /// <param name="Callbacks">
    /// A function returning a <see cref="TAsyncConversationsListItem"/>. Use the returned object’s
    /// <c>OnStart</c> event to respond when the request begins, <c>OnSuccess</c> to handle the resulting
    /// <see cref="TConversationsListItem"/> on success, and <c>OnError</c> to handle any error if the request fails.
    /// </param>
    procedure AsyncRetrieve(
      const ConversationId: string;
      const Callbacks: TFunc<TAsyncConversationsListItem>);

    /// <summary>
    /// Initiates an asynchronous request to fetch the full history of a conversation using callbacks.
    /// </summary>
    /// <remarks>
    /// This method sends a GET request to the "conversations/{ConversationId}/history" endpoint and invokes
    /// the provided callback handlers for lifecycle events. It uses <c>AsyncGetHistory</c> internally.
    /// </remarks>
    /// <param name="ConversationId">
    /// The identifier of the conversation whose history is being retrieved.
    /// </param>
    /// <param name="Callbacks">
    /// A function returning a <see cref="TAsyncRetrievedEntries"/>. Use the returned object’s <c>OnStart</c> event
    /// to respond when the request begins, <c>OnSuccess</c> to handle the resulting <see cref="TRetrievedEntries"/>
    /// on success, and <c>OnError</c> to handle any error if the request fails.
    /// </param>
    procedure AsyncGetHistory(
      const ConversationId: string;
      const Callbacks: TFunc<TAsyncRetrievedEntries>);

    /// <summary>
    /// Initiates an asynchronous request to fetch all messages of a conversation using callbacks.
    /// </summary>
    /// <remarks>
    /// This method sends a GET request to the "conversations/{ConversationId}/messages" endpoint and invokes
    /// the provided callback handlers for lifecycle events. It uses <c>AsyncGetMessages</c> internally.
    /// </remarks>
    /// <param name="ConversationId">
    /// The identifier of the conversation whose messages are being retrieved.
    /// </param>
    /// <param name="Callbacks">
    /// A function returning a <see cref="TAsyncRetrieveMessages"/>. Use the returned object’s <c>OnStart</c> event
    /// to respond when the request begins, <c>OnSuccess</c> to handle the resulting <see cref="TRetrieveMessages"/>
    /// on success, and <c>OnError</c> to handle any error if the request fails.
    /// </param>
    procedure AsyncGetMessages(
      const ConversationId: string;
      const Callbacks: TFunc<TAsyncRetrieveMessages>);

    /// <summary>
    /// Initiates an asynchronous "restart conversation" request using callbacks.
    /// </summary>
    /// <remarks>
    /// This method sends the configured parameters to the "conversations/{ConversationId}/restart" endpoint
    /// and invokes the provided callback handlers for lifecycle events. It uses <c>AsyncRestart</c> internally.
    /// </remarks>
    /// <param name="ConversationId">
    /// The identifier of the conversation to restart.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure that configures the <see cref="TConversationsParams"/>, including the initial prompt,
    /// model selection, and any options such as stop sequences or maximum tokens.
    /// </param>
    /// <param name="Callbacks">
    /// A function returning a <see cref="TAsyncConversation"/>. Use the returned object’s <c>OnStart</c> event
    /// to respond when the request begins, <c>OnSuccess</c> to handle the resulting <see cref="TConversation"/> on success,
    /// and <c>OnError</c> to handle any error message if the request fails.
    /// </param>
    procedure AsyncRestart(
      const ConversationId: string;
      const ParamProc: TProc<TConversationsParams>;
      const Callbacks: TFunc<TAsyncConversation>);
  end;

implementation

{ TConversationsRoute }

function TConversationsRoute.Append(
  const ConversationId: string;
  const ParamProc: TProc<TConversationsParams>): TConversation;
begin
  Result := API.Post<TConversation, TConversationsParams>('conversations/' + ConversationId, ParamProc,
    ['outputs', '*', 'content']);
end;

function TConversationsRoute.AppendStream(
  const ConversationId: string;
  const ParamProc: TProc<TConversationsParams>;
  const Event: TConversationsEventRef): Boolean;
begin
  Result := CreateStreamInternal('conversations/' + ConversationId + '#stream', ParamProc, Event);
end;

procedure TConversationsRoute.AsyncAppend(
  const ConversationId: string;
  const ParamProc: TProc<TConversationsParams>;
  const Callbacks: TFunc<TAsyncConversation>);
begin
  with TAsyncCallbackExec<TAsyncConversation, TConversation>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TConversation
      begin
        Result := Self.Append(ConversationId, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TConversationsRoute.AsyncAppendStream(
  const ConversationId: string;
  const ParamProc: TProc<TConversationsParams>;
  const Callbacks: TFunc<TAsyncConversationsEvent>);
begin
  AsyncStreamInternal('conversations/' + ConversationId + '#stream', ParamProc, Callbacks);
end;

function TConversationsRoute.AsyncAwaitAppend(
  const ConversationId: string;
  const ParamProc: TProc<TConversationsParams>;
  const Callbacks: TFunc<TPromiseConversation>): TPromise<TConversation>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TConversation>(
    procedure(const CallbackParams: TFunc<TAsyncConversation>)
    begin
      AsyncAppend(ConversationId, ParamProc, CallbackParams);
    end,
    Callbacks);
end;

function TConversationsRoute.AsyncAwaitAppendStream(
  const ConversationId: string; const ParamProc: TProc<TConversationsParams>;
  const Callbacks: TFunc<TPromiseConversationsEvent>): TPromise<string>;
begin
  Result := AsyncAwaitStreamInternal('conversations/' + ConversationId + '#stream', ParamProc, Callbacks);
end;

function TConversationsRoute.AsyncAwaitCreate(
  const ParamProc: TProc<TConversationsParams>;
  const Callbacks: TFunc<TPromiseConversation>): TPromise<TConversation>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TConversation>(
    procedure(const CallbackParams: TFunc<TAsyncConversation>)
    begin
      AsyncCreate(ParamProc, CallbackParams);
    end,
    Callbacks);
end;

function TConversationsRoute.AsyncAwaitCreateStream(
  const ParamProc: TProc<TConversationsParams>;
  const Callbacks: TFunc<TPromiseConversationsEvent>): TPromise<string>;
begin
  Result := AsyncAwaitStreamInternal('conversations#stream', ParamProc, Callbacks);
end;

function TConversationsRoute.AsyncAwaitGetHistory(
  const ConversationId: string;
  const Callbacks: TFunc<TPromiseRetrievedEntries>): TPromise<TRetrievedEntries>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TRetrievedEntries>(
    procedure(const CallbackParams: TFunc<TAsyncRetrievedEntries>)
    begin
      AsyncGetHistory(ConversationId, CallbackParams);
    end,
    Callbacks);
end;

function TConversationsRoute.AsyncAwaitGetMessages(
  const ConversationId: string;
  const Callbacks: TFunc<TPromiseRetrieveMessages>): TPromise<TRetrieveMessages>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TRetrieveMessages>(
    procedure(const CallbackParams: TFunc<TAsyncRetrieveMessages>)
    begin
      AsyncGetMessages(ConversationId, CallbackParams);
    end,
    Callbacks);
end;

function TConversationsRoute.AsyncAwaitList(
  const ParamProc: TProc<TConversationsListParams>;
  const Callbacks: TFunc<TPromiseConversationsList>): TPromise<TConversationsList>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TConversationsList>(
    procedure(const CallbackParams: TFunc<TAsyncConversationsList>)
    begin
      AsyncList(ParamProc, CallbackParams);
    end,
    Callbacks);
end;

function TConversationsRoute.AsyncAwaitCreateParallel(
  const ParamProc: TProc<TBundleParams>;
  const CallBacks: TFunc<TPromiseBundleList>): TPromise<TBundleList>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TBundleList>(
    procedure(const CallBackParams: TFunc<TAsynBundleList>)
    begin
      CreateParallel(ParamProc, CallBackParams);
    end,
    CallBacks);
end;

function TConversationsRoute.AsyncAwaitRestart(
  const ConversationId: string;
  const ParamProc: TProc<TConversationsParams>;
  const Callbacks: TFunc<TPromiseConversation>): TPromise<TConversation>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TConversation>(
    procedure(const CallbackParams: TFunc<TAsyncConversation>)
    begin
      AsyncRestart(ConversationId, ParamProc, CallbackParams);
    end,
    Callbacks);
end;

function TConversationsRoute.AsyncAwaitRestartStream(
  const ConversationId: string;
  const ParamProc: TProc<TConversationsParams>;
  const Callbacks: TFunc<TPromiseConversationsEvent>): TPromise<string>;
begin
  Result := AsyncAwaitStreamInternal('conversations/' + ConversationId + '/restart#stream', ParamProc, Callbacks);
end;

function TConversationsRoute.AsyncAwaitRetrieve(
  const ConversationId: string;
  const Callbacks: TFunc<TPromiseConversationsListItem>): TPromise<TConversationsListItem>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TConversationsListItem>(
    procedure(const CallbackParams: TFunc<TAsyncConversationsListItem>)
    begin
      AsyncRetrieve(ConversationId, CallbackParams);
    end,
    Callbacks);
end;

procedure TConversationsRoute.AsyncCreate(
  const ParamProc: TProc<TConversationsParams>;
  const Callbacks: TFunc<TAsyncConversation>);
begin
  with TAsyncCallbackExec<TAsyncConversation, TConversation>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TConversation
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TConversationsRoute.AsyncCreateStream(
  const ParamProc: TProc<TConversationsParams>;
  const Callbacks: TFunc<TAsyncConversationsEvent>);
begin
  AsyncStreamInternal('conversations#stream', ParamProc, Callbacks);
end;

procedure TConversationsRoute.AsyncGetHistory(
  const ConversationId: string;
  const Callbacks: TFunc<TAsyncRetrievedEntries>);
begin
  with TAsyncCallbackExec<TAsyncRetrievedEntries, TRetrievedEntries>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TRetrievedEntries
      begin
        Result := Self.GetHistory(ConversationId);
      end);
  finally
    Free;
  end;
end;

procedure TConversationsRoute.AsyncGetMessages(
  const ConversationId: string;
  const Callbacks: TFunc<TAsyncRetrieveMessages>);
begin
  with TAsyncCallbackExec<TAsyncRetrieveMessages, TRetrieveMessages>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TRetrieveMessages
      begin
        Result := Self.GetMessages(ConversationId);
      end);
  finally
    Free;
  end;
end;

procedure TConversationsRoute.AsyncList(
  const ParamProc: TProc<TConversationsListParams>;
  const Callbacks: TFunc<TAsyncConversationsList>);
begin
  with TAsyncCallbackExec<TAsyncConversationsList, TConversationsList>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TConversationsList
      begin
        Result := Self.List(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TConversationsRoute.AsyncRestart(
  const ConversationId: string;
  const ParamProc: TProc<TConversationsParams>;
  const Callbacks: TFunc<TAsyncConversation>);
begin
  with TAsyncCallbackExec<TAsyncConversation, TConversation>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TConversation
      begin
        Result := Self.Restart(ConversationId, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TConversationsRoute.AsyncRestartStream(
  const ConversationId: string;
  const ParamProc: TProc<TConversationsParams>;
  const Callbacks: TFunc<TAsyncConversationsEvent>);
begin
  AsyncStreamInternal('conversations/' + ConversationId + '/restart#stream', ParamProc, Callbacks);
end;

procedure TConversationsRoute.AsyncRetrieve(
  const ConversationId: string;
  const Callbacks: TFunc<TAsyncConversationsListItem>);
begin
  with TAsyncCallbackExec<TAsyncConversationsListItem, TConversationsListItem>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TConversationsListItem
      begin
        Result := Self.Retrieve(ConversationId);
      end);
  finally
    Free;
  end;
end;

function TConversationsRoute.Create(
  const ParamProc: TProc<TConversationsParams>): TConversation;
begin
  Result := API.Post<TConversation, TConversationsParams>('conversations', ParamProc,
     ['outputs', '*', 'content']);
end;

procedure TConversationsRoute.CreateParallel(
  const ParamProc: TProc<TBundleParams>;
  const CallBacks: TFunc<TAsynBundleList>);
var
  Tasks: TArray<ITask>;
  BundleParams: TBundleParams;
begin
  BundleParams := TBundleParams.Create;
  try
    if not Assigned(ParamProc) then
      raise Exception.Create('The lambda can''t be null');

    ParamProc(BundleParams);
    var Bundle := TBundleList.Create;
    var Ranking := 0;
    var ErrorExists := False;
    var Prompts := BundleParams.GetPrompt;
    var Counter := Length(Prompts);

    if Assigned(CallBacks.OnStart) then
      CallBacks.OnStart(CallBacks.Sender);

    SetLength(Tasks, Length(Prompts));
    for var index := 0 to Pred(Length(Prompts)) do
      begin
        Tasks[index] := TTask.Run(
          procedure
          begin
            var Buffer := Bundle.Add(index + 1);
            Buffer.Prompt := Prompts[index];
            try
              var Chat := Create(
                procedure (Params: TConversationsParams)
                begin
                  {--- Set the model for the process }
                  Params.Model(BundleParams.GetModel);

                  {--- Set instructions }
                  Params.Instructions(BundleParams.GetSystem);

                  {--- Set the current prompt and developer message }
                  Params.Inputs(Buffer.Prompt);

                  {--- Don't store the result when parallel execution }
                  Params.Store(False);
                end);
              Inc(Ranking);
              Buffer.FinishIndex := Ranking;
              for var Item in Chat.Outputs do
                for var SubItem in Item.Content do
                  if SubItem.&Type = TContentChunkType.text then
                    Buffer.Response := SubItem.Text;
              Buffer.Chat := Chat;
            except
              on E: Exception do
                begin
                  {--- Catch the exception }
                  var Error := AcquireExceptionObject;
                  ErrorExists := True;
                  try
                    var ErrorMsg := (Error as Exception).Message;
                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(CallBacks.OnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        CallBacks.OnError(CallBacks.Sender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
          end);

        if ErrorExists then
          Continue;

        {--- TTask.WaitForAll is not used due to a memory leak in TLightweightEvent/TCompleteEventsWrapper.
             See report RSP-12462 and RSP-25999. }
        TTaskHelper.ContinueWith(Tasks[Index],
          procedure
          begin
            Dec(Counter);
            if Counter = 0 then
              begin
                try
                  if not ErrorExists and Assigned(CallBacks.OnSuccess) then
                    CallBacks.OnSuccess(CallBacks.Sender, Bundle);
                finally
                  Bundle.Free;
                end;
              end;
          end);
        {--- Need a delay, otherwise the process runs only with the first task. }
        Sleep(30);
      end;
  finally
    BundleParams.Free;
  end;
end;

function TConversationsRoute.CreateStream(
  const ParamProc: TProc<TConversationsParams>;
  const Event: TConversationsEventRef): Boolean;
begin
  Result := CreateStreamInternal('conversations#stream', ParamProc, Event);
end;

function TConversationsRoute.GetHistory(
  const ConversationId: string): TRetrievedEntries;
begin
  Result := API.Get<TRetrievedEntries>('conversations/' + ConversationId + '/history',
    ['entries', '*', 'content']);
end;

function TConversationsRoute.GetMessages(
  const ConversationId: string): TRetrieveMessages;
begin
  Result := API.Get<TRetrieveMessages>('conversations/' + ConversationId + '/messages',
    ['messages', '*', 'content']);
end;

function TConversationsRoute.List(
  const ParamProc: TProc<TConversationsListParams>): TConversationsList;
begin
  Result := API.Get<TConversationsList, TConversationsListParams>('conversations', ParamProc, 'data');
end;

function TConversationsRoute.Restart(
  const ConversationId: string;
  const ParamProc: TProc<TConversationsParams>): TConversation;
begin
  Result := API.Post<TConversation, TConversationsParams>('conversations/' + ConversationId + '/restart', ParamProc,
    ['outputs', '*', 'content']);
end;

function TConversationsRoute.RestartStream(
  const ConversationId: string;
  const ParamProc: TProc<TConversationsParams>;
  const Event: TConversationsEventRef): Boolean;
begin
  Result := CreateStreamInternal('conversations/' + ConversationId + '/restart#stream', ParamProc, Event);
end;

function TConversationsRoute.Retrieve(
  const ConversationId: string): TConversationsListItem;
begin
  Result := API.Get<TConversationsListItem>('conversations/' + ConversationId);
end;

end.

unit MistralAI.DUnit.Tests;

(*
  To execute unit tests proceed as follows :

  Declare
  -------
      uses
        DUnitX.TestFramework,
        DUnitX.Loggers.Console,
        DUnitX.TestRunner,
        GenAI.API.Tests, ... ;

  Process
  -------
      procedure TForm1.Button1Click(Sender: TObject);
      var
        Runner: ITestRunner;
        Results: IRunResults;
      begin
        TDUnitX.RegisterTestFixture(TGenAIAPITests);
        Runner := TDUnitX.CreateRunner;
        Results := Runner.Execute;
        if Results.AllPassed then
          Memo1.Lines.Add('All tests passed.')
        else
          Memo1.Lines.Add('Some tests failed.');
      end;
*)

interface

{$M+}

uses
  DUnitX.TestFramework, System.SysUtils, System.Classes, REST.JsonReflect,
  MistralAI.API, MistralAI.API.Params, MistralAI.Types, MistralAI.Exception;

type
  [TestFixture]
  TGenAIAPITests = class
  public
    [Test] procedure Test_TUrlParam_AddParameters;
    [Test] procedure Test_TJSONParam_Serialization;
    [Test] procedure Test_TApiDeserializer_Deserialize;
    [Test] procedure Test_TApiDeserializer_Deserialize_MetadataAsstring;
    [Test] procedure Test_TApiDeserializer_RaiseErrors;
    [Test] procedure Test_TApiDeserializer_EmptyResponse;
    [Test] procedure Test_TGenAIAPI_GetFileWithError;
    [Test] procedure Test_TGenAIConfiguration_BuildHeaders;
  end;

  TTestModel = class(TObject)
  private
    FId: string;
    FName: string;
    FKind: string;
  public
    property Id: string read FId write FId;
    property Name: string read FName write FName;
    property Kind: string read FKind write FKind;
  end;

  TTestMetadata = class(TObject)
  private
    FId: string;
    FName: string;
    [JsonReflectAttribute(ctString, rtString, TMetadataInterceptor)]
    FMetadata: string;
  public
    property Id: string read FId write FId;
    property Name: string read FName write FName;
    property Metadata: string read FMetadata write FMetadata;
  end;

implementation

uses
  System.Net.URLClient;

type
  TTestMistralConfiguration = class(TMistralAISettings);

  TTestTApiDeserializer = class(TApiDeserializer);

{ TGenAIAPITests }

procedure TGenAIAPITests.Test_TApiDeserializer_Deserialize;
{--- This ensures that data received from the API is correctly transformed into
     usable Delphi objects. }
begin
  var DeserializedObj: TTestModel := nil;
  var Deserializer := TTestTApiDeserializer.Create;
  var JsonInput := '{"name":"test_model","id":"123","kind":"object"}';
  try
    DeserializedObj := Deserializer.Deserialize<TTestModel>(200, JsonInput);
    Assert.IsNotNull(DeserializedObj, 'The deserialized object is null.');
    Assert.AreEqual('test_model', DeserializedObj.Name, 'The Name field is incorrect.');
    Assert.AreEqual('123', DeserializedObj.Id, 'The Id field is incorrect.');
    Assert.AreEqual('object', DeserializedObj.kind, 'The Kind field is incorrect.');
  finally
    DeserializedObj.Free;
    Deserializer.Free;
  end;
end;

procedure TGenAIAPITests.Test_TApiDeserializer_Deserialize_MetadataAsstring;
{--- This guarantees that the data retrieved from the API is properly transformed into objects,
     ensuring that metadata is correctly deserialized as strings and not in object form. }
begin
  var DeserializedObj: TTestMetadata := nil;
  var Deserializer := TTestTApiDeserializer.Create;
  var JsonInput := '{"name":"test_model","id":"123","metadata":{"key":"value"}}';
  try
    DeserializedObj := Deserializer.Deserialize<TTestMetadata>(200, JsonInput);
    Assert.IsNotNull(DeserializedObj, 'The deserialized object is null.');
    Assert.AreEqual('test_model', DeserializedObj.Name, 'The Name field is incorrect.');
    Assert.AreEqual('123', DeserializedObj.Id, 'The Id field is incorrect.');
    Assert.AreEqual('{"key":"value"}', DeserializedObj.Metadata, 'The Kind field is incorrect.');
  finally
    DeserializedObj.Free;
    Deserializer.Free;
  end;
end;

procedure TGenAIAPITests.Test_TApiDeserializer_EmptyResponse;
{--- Checking for an empty or non-JSON response throws the TGenAIInvalidResponseError exception. }
begin
  var Deserializer := TTestTApiDeserializer.Create;
  try
    Assert.WillRaise(
      procedure begin
        Deserializer.Deserialize<TTestModel>(200, '');
      end,
      EInvalidResponse,
      'No exception thrown for empty response.'
    );
  finally
    Deserializer.Free;
  end;
end;

procedure TGenAIAPITests.Test_TApiDeserializer_RaiseErrors;
{--- This ensures that every type of API error is handled correctly by the exception system. }
begin
  var Deserializer := TTestTApiDeserializer.Create;
  try
    Assert.WillRaise(
      procedure begin
        Deserializer.DeserializeErrorData(401, '{"error": {"message": "Invalid API key", "code": 401}}');
      end,
      EAuthenticationError,
      'TGenAIAuthError exception was not thrown for error 401.');
    Assert.WillRaise(
      procedure begin
        Deserializer.DeserializeErrorData(403, '{"error": {"message": "Invalid API key", "code": 403}}');
      end,
      EPermissionError,
      'TGenAICountryNotSupportedError exception was not thrown for error 403.');
    Assert.WillRaise(
      procedure begin
        Deserializer.DeserializeErrorData(429, '{"error": {"message": "Invalid API key", "code": 429}}');
      end,
      ERateLimitError,
      'TGenAIRateLimitError exception was not thrown for error 429.');
//    Assert.WillRaise(
//      procedure begin
//        Deserializer.DeserializeErrorData(500, '{"error": {"message": "Invalid API key", "code": 500}}');
//      end,
//      TGenAIServerError,
//      'TGenAIServerError exception was not thrown for error 500.');
//    Assert.WillRaise(
//      procedure begin
//        Deserializer.DeserializeErrorData(503, '{"error": {"message": "Invalid API key", "code": 503}}');
//      end,
//      TGenAIEngineOverloadedError,
//      'TGenAIEngineOverloadedError exception was not thrown for error 503.');
  finally
    Deserializer.Free;
  end;
end;

procedure TGenAIAPITests.Test_TGenAIAPI_GetFileWithError;
{--- Ensure that an appropriate exception is thrown when a file download fails. }
begin
  var API := TMistralAIAPI.Create('dummy_api_key');
  var Stream := TMemoryStream.Create;
  try
    Assert.WillRaise(
      procedure
      begin
        API.GetFile('invalid/endpoint', Stream);
      end,
      EInvalidRequestError,
      'No exception thrown when downloading an invalid file.'
    );
  finally
    Stream.Free;
    API.Free;
  end;
end;

procedure TGenAIAPITests.Test_TGenAIConfiguration_BuildHeaders;
{--- This ensures that every request sent to the API is properly authenticated. }
begin
  var Config := TTestMistralConfiguration.Create;
  try
    Config.APIKey := 'my_api_key';

    var Headers := Config.BuildHeaders;

    Assert.AreEqual('Bearer my_api_key', Headers[0].Value, 'The Authorization header is incorrect.');
  finally
    Config.Free;
  end;
end;

procedure TGenAIAPITests.Test_TJSONParam_Serialization;
{--- Verify that HTTP POST/GET requests correctly serialize JSON parameters. }
begin
  var JSONParam := TJSONParam.Create;
  try
    JSONParam.Add('param1', 'value1');
    JSONParam.Add('param2', 42);
    JSONParam.Add('param3', True);
    var JsonString := JSONParam.ToJsonString;
    Assert.IsTrue(JsonString.Contains('"param1":"value1"'), 'Parameter param1 missing or incorrect.');
    Assert.IsTrue(JsonString.Contains('"param2":42'), 'Incorrect parameter param2.');
    Assert.IsTrue(JsonString.Contains('"param3":true'), 'Incorrect parameter param3.');
  finally
    JSONParam.Free;
  end;
end;

procedure TGenAIAPITests.Test_TUrlParam_AddParameters;
{--- This ensures that all API requests use properly formatted URLs, avoiding HTTP
     errors due to mis-encoded parameters.}
begin
  var UrlParams := TUrlParam.Create;
  try
    UrlParams.Add('key1', 'value1');
    UrlParams.Add('key2', 'value 2');
    var ResultingUrl := UrlParams.Value;
    Assert.AreEqual('?key1=value1&key2=value%202', ResultingUrl,
      'URL parameters are not encoded correctly.');
  finally
    UrlParams.Free;
  end;

  {--- Verify that URL parameters containing special characters are correctly encoded. }
  UrlParams := TUrlParam.Create;
  try
    UrlParams.Add('param1', 'value with spaces');
    UrlParams.Add('param2', 'value&with=special%chars');
    var ResultingUrl := UrlParams.Value;
    Assert.AreEqual('?param1=value%20with%20spaces&param2=value%26with%3Dspecial%25chars', ResultingUrl,
      'URL parameters are not encoded correctly.');
  finally
    UrlParams.Free;
  end;
end;

end.

unit MistralAI.Embeddings;

{-------------------------------------------------------------------------------

      Github repository : https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, REST.Json.Types, MistralAI.API.Params, MistralAI.API,
  MistralAI.Async.Support, MistralAI.Async.Promise;

type
  /// <summary>
  /// Represents the parameters for an embedding request.
  /// </summary>
  /// <remarks>
  /// Use this class to specify the input text and other parameters for generating embeddings.
  /// </remarks>
  TEmbeddingParams = class(TJSONParam)
    /// <summary>
    /// Sets the ID of the model to use for this request.
    /// </summary>
    /// <param name="Value">
    /// The model ID to be used for embedding.
    /// </param>
    /// <returns>
    /// The current instance of <c>TEmbeddingParams</c> for method chaining.
    /// </returns>
    /// <remarks>
    /// Use this method to specify the model that will generate the embeddings.
    /// </remarks>
    function Model(const Value: string): TEmbeddingParams;

    /// <summary>
    /// Sets the input text for which to generate an embedding.
    /// </summary>
    /// <param name="Value">
    /// The input text as a string.
    /// </param>
    /// <returns>
    /// The current instance of <c>TEmbeddingParams</c> for method chaining.
    /// </returns>
    /// <remarks>
    /// Use this method to specify a single string input for embedding.
    /// </remarks>
    function Input(const Value: string): TEmbeddingParams; overload;

    /// <summary>
    /// Sets multiple input texts for which to generate embeddings.
    /// </summary>
    /// <param name="Value">
    /// An array of input texts.
    /// </param>
    /// <returns>
    /// The current instance of <c>TEmbeddingParams</c> for method chaining.
    /// </returns>
    /// <remarks>
    /// Use this method to specify multiple strings as inputs for embeddings.
    /// </remarks>
    function Input(const Value: TArray<string>): TEmbeddingParams; overload;

    /// <summary>
    /// Sets the format of the output data.
    /// </summary>
    /// <param name="Value">
    /// The desired output format (e.g., 'float').
    /// </param>
    /// <returns>
    /// The current instance of <c>TEmbeddingParams</c> for method chaining.
    /// </returns>
    /// <remarks>
    /// Use this method to specify the output format of the embeddings.
    /// </remarks>
    function output_dtype(const Value: string): TEmbeddingParams;

    /// <summary>
    /// The dimension of the output embeddings.
    /// </summary>
    /// <param name="Value">
    /// The vector dimension as an integer.
    /// </param>
    /// <remarks>
    /// only available with the codestral-embed model
    /// </remarks>
    function output_dimension(const Value: Integer): TEmbeddingParams;
  end;

  /// <summary>
  /// Represents token usage statistics for an embedding request.
  /// </summary>
  /// <remarks>
  /// Contains information about the number of tokens used in the request.
  /// </remarks>
  TEmbeddingUsage = class
  private
    [JsonNameAttribute('prompt_tokens')]
    FPrompt_tokens: Int64;
    [JsonNameAttribute('total_tokens')]
    FTotal_tokens: Int64;
  public
    /// <summary>
    /// The number of tokens used in the input text.
    /// </summary>
    property PromptTokens: Int64 read FPrompt_tokens write FPrompt_tokens;

    /// <summary>
    /// The total number of tokens consumed during the embedding request.
    /// </summary>
    property TotalTokens: Int64 read FTotal_tokens write FTotal_tokens;
  end;

  /// <summary>
  /// Represents an embedding result for a single input.
  /// </summary>
  /// <remarks>
  /// Contains the embedding vector and associated metadata for a single input text.
  /// </remarks>
  TEmbeddingData = class
  private
    FIndex: Int64;
    FObject: string;
    FEmbedding: TArray<Double>;
  public
    /// <summary>
    /// The index of the embedding in the list of embeddings.
    /// </summary>
    property Index: Int64 read FIndex write FIndex;

    /// <summary>
    /// The object type, which is always "embedding".
    /// </summary>
    property &Object: string read FObject write FObject;

    /// <summary>
    /// The embedding vector, which is a list of floats. The length of the vector depends on the model as listed in the embedding guide.
    /// </summary>
    property Embedding: TArray<Double> read FEmbedding write FEmbedding;
  end;

  /// <summary>
  /// Represents the response from an embedding request.
  /// </summary>
  /// <remarks>
  /// Contains the embeddings, model information, and usage statistics returned by the API.
  /// </remarks>
  TEmbeddings = class(TJSONFingerprint)
  private
    FId: string;
    FObject: string;
    FData: TArray<TEmbeddingData>;
    FModel: string;
    FUsage: TEmbeddingUsage;
  public
    /// <summary>
    /// The unique identifier for the embedding response.
    /// </summary>
    property Id: string read FId write FId;

    /// <summary>
    /// The object type of the response (e.g., 'list').
    /// </summary>
    property &Object: string read FObject write FObject;

    /// <summary>
    /// The list of embedding data for each input.
    /// </summary>
    property Data: TArray<TEmbeddingData> read FData write FData;

    /// <summary>
    /// The token usage statistics for the embedding request.
    /// </summary>
    property Usage: TEmbeddingUsage read FUsage write FUsage;

    /// <summary>
    /// The model used to generate the embeddings.
    /// </summary>
    property Model: string read FModel write FModel;

    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents the asynchronous callback parameters for embedding requests.
  /// </summary>
  /// <remarks>
  /// Used to handle asynchronous responses for embedding operations.
  /// </remarks>
  TAsyncEmbeddings = TAsyncCallback<TEmbeddings>;

  /// <summary>
  /// Defines a promise-style callback wrapper for embedding results.
  /// </summary>
  /// <remarks>
  /// <c>TPromiseEmbeddings</c> is an alias of <c>TPromiseCallBack&lt;TEmbeddings&gt;</c>,
  /// offering a concise way to handle asynchronous embedding operations that
  /// yield a <c>TEmbeddings</c> instance once completed.
  /// </remarks>
  TPromiseEmbeddings = TPromiseCallback<TEmbeddings>;

  /// <summary>
  /// Provides methods for creating embedding requests.
  /// </summary>
  /// <remarks>
  /// Contains synchronous and asynchronous methods to generate embeddings using the API.
  /// <code>
  /// // Example usage:
  /// var
  ///   EmbeddingsRoute: TEmbeddingsRoute;
  ///   EmbeddingsResult: TEmbeddings;
  /// begin
  ///   EmbeddingsRoute := TEmbeddingsRoute.Create;
  ///   EmbeddingsResult := EmbeddingsRoute.Create(
  ///     procedure(Params: TEmbeddingParams)
  ///     begin
  ///       Params.Input('Your input text here');
  ///     end);
  ///   // Use EmbeddingsResult as needed
  /// end;
  /// </code>
  /// </remarks>
  TEmbeddingsRoute = class(TMistralAIAPIRoute)
  public
    /// <summary>
    /// Initiates an embedding request and returns a promise that resolves with the embeddings.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TEmbeddingParams</c>, including input texts and model settings.
    /// </param>
    /// <param name="Callbacks">
    /// An optional factory function that provides a <c>TPromiseEmbeddings</c> to handle
    /// lifecycle Callbacks (OnStart, OnSuccess, OnError) during the asynchronous operation.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TEmbeddings&gt;</c> which will complete with the <c>TEmbeddings</c> result.
    /// </returns>
    /// <remarks>
    /// Use this method to perform non-blocking embedding requests in a promise-style workflow.
    /// </remarks>
    function AsyncAwaitCreate(const ParamProc: TProc<TEmbeddingParams>;
      const Callbacks: TFunc<TPromiseEmbeddings> = nil): TPromise<TEmbeddings>;

    /// <summary>
    /// Initiates an asynchronous embedding request.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to set up the embedding parameters.
    /// </param>
    /// <param name="Callbacks">
    /// A function that returns the asynchronous callback parameters.
    /// </param>
    /// <remarks>
    /// Use this method to perform an embedding request without blocking the main thread.
    /// <code>
    ///   // Example usage:
    ///   MistralAI.Embeddings.AsyncCreate(
    ///     procedure(Params: TEmbeddingParams)
    ///     begin
    ///       Params.Input('Your input text here');
    ///     end,
    ///
    ///     function: TAsyncEmbeddings
    ///     begin
    ///       Result.OnSuccess :=
    ///         procedure(Sender: TObject; Embeddings: TEmbeddings)
    ///         begin
    ///           // Handle successful embedding result
    ///         end;
    ///
    ///       Result.OnError :=
    ///         procedure(Sender: TObject; E: Exception)
    ///         begin
    ///           // Handle error
    ///         end;
    ///     end);
    /// </code>
    /// </remarks>
    procedure AsyncCreate(ParamProc: TProc<TEmbeddingParams>;
      const Callbacks: TFunc<TAsyncEmbeddings>);

    /// <summary>
    /// Performs a synchronous embedding request and returns the result.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to set up the embedding parameters.
    /// </param>
    /// <returns>
    /// An instance of <c>TEmbeddings</c> containing the embedding results.
    /// </returns>
    /// <remarks>
    /// Use this method to perform an embedding request that blocks until the response is received.
    /// <code>
    ///   // Example usage:
    ///   var Embeddings := MistralAI.Embeddings.Create(
    ///     procedure(Params: TEmbeddingParams)
    ///     begin
    ///       Params.Input(['Your input text here']);
    ///     end);
    ///    try
    ///      // Use Embeddings as needed
    ///    finally
    ///      Embeddings.Free;
    ///    end;
    /// </code>
    /// </remarks>
    function Create(ParamProc: TProc<TEmbeddingParams>): TEmbeddings;
  end;

implementation

{ TEmbeddingParams }

function TEmbeddingParams.output_dimension(
  const Value: Integer): TEmbeddingParams;
begin
  Result := TEmbeddingParams(Add('output_dimension', Value));
end;

function TEmbeddingParams.output_dtype(
  const Value: string): TEmbeddingParams;
begin
  Result := TEmbeddingParams(Add('output_dtype', Value));
end;

function TEmbeddingParams.Input(const Value: string): TEmbeddingParams;
begin
  Result := TEmbeddingParams(Add('input', Value));
end;

function TEmbeddingParams.Input(const Value: TArray<string>): TEmbeddingParams;
begin
  Result := TEmbeddingParams(Add('input', Value));
end;

function TEmbeddingParams.Model(const Value: string): TEmbeddingParams;
begin
  Result := TEmbeddingParams(Add('model', Value));
end;

{ TEmbeddings }

destructor TEmbeddings.Destroy;
begin
  FUsage.Free;
  for var Item in FData do
    Item.Free;
  inherited;
end;

{ TEmbeddingsRoute }

function TEmbeddingsRoute.AsyncAwaitCreate(
  const ParamProc: TProc<TEmbeddingParams>;
  const Callbacks: TFunc<TPromiseEmbeddings>): TPromise<TEmbeddings>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TEmbeddings>(
    procedure(const CallbackParams: TFunc<TAsyncEmbeddings>)
    begin
      AsyncCreate(ParamProc, CallbackParams);
    end,
    Callbacks);
end;

procedure TEmbeddingsRoute.AsyncCreate(ParamProc: TProc<TEmbeddingParams>;
  const Callbacks: TFunc<TAsyncEmbeddings>);
begin
  with TAsyncCallBackExec<TAsyncEmbeddings, TEmbeddings>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TEmbeddings
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TEmbeddingsRoute.Create(
  ParamProc: TProc<TEmbeddingParams>): TEmbeddings;
begin
  Result := API.Post<TEmbeddings, TEmbeddingParams>('embeddings', ParamProc);
end;

end.

unit MistralAI.Errors;

{-------------------------------------------------------------------------------

      Github repository : https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  REST.Json.Types;

type
  TErrorCore = class abstract
  end;

  TError = class(TErrorCore)
  private
    [JsonNameAttribute('message')]
    FMessage: string;
    [JsonNameAttribute('detail')]
    FDetail: string;
    [JsonNameAttribute('request_id')]
    FRequestID: string;
  public
    property Message: string read FMessage write FMessage;
    property Detail: string read FDetail write FDetail;
    property RequestID: string read FRequestID write FRequestID;
  end;

  TCTX = class
  private
    [JsonNameAttribute('le')]
    FLe: Double;
  public
    property Le: Double read FLe write FLe;
  end;

  TDetail = class
  private
    [JsonNameAttribute('loc')]
    FLoc: TArray<string>;
    [JsonNameAttribute('msg')]
    FMsg: string;
    [JsonNameAttribute('type')]
    FType: string;
    [JsonNameAttribute('input')]
    FInput: string;
    [JsonNameAttribute('ctx')]
    FCTX: TCTX;
  public
    property Loc: TArray<string> read FLoc write FLoc;
    property Msg: string read FMsg write FMsg;
    property &Type: string read FType write FType;
    property Input: string read FInput write FInput;
    property CTX: TCTX read FCTX write FCTX;
    destructor Destroy; override;
  end;

  TMessage422 = class
  private
    [JsonNameAttribute('detail')]
    FDetail: TArray<TDetail>;
  public
    property Detail: TArray<TDetail> read FDetail write FDetail;
    destructor Destroy; override;
  end;

  TError422 = class(TErrorCore)
  private
     [JsonNameAttribute('object')]
     FObject: string;
     [JsonNameAttribute('message')]    // NOTE : Should't exists
     FMessage: TMessage422;
     [JsonNameAttribute('type')]
     FType: string;
     [JsonNameAttribute('param')]
     FParam: string;
     [JsonNameAttribute('code')]
     FCode: string;
     [JsonNameAttribute('detail')]
     FDetail: TArray<TDetail>;
  public
    property &Object: string read FObject write FObject;
    {--- "Message" Property that should not exist according to API documentation.
         But some 422 errors use this property.}
    property Message: TMessage422 read FMessage write FMessage;
    property &Type: string read FType write FType;
    property Param: string read FParam write FParam;
    property Code: string read FCode write FCode;
    property Detail: TArray<TDetail> read FDetail write FDetail;
    destructor Destroy; override;
  end;

implementation

{ TError422 }

destructor TError422.Destroy;
begin
  if Assigned(FMessage) then
    FMessage.Free;
  if Assigned(FDetail) then
    for var Item in FDetail do
      Item.Free;
  inherited;
end;

{ TDetail }

destructor TDetail.Destroy;
begin
  if Assigned(FCTX) then
    FCTX.Free;
  inherited;
end;

{ TMessage422 }

destructor TMessage422.Destroy;
begin
  for var Item in Detail do
    Item.Free;
  inherited;
end;

end.

unit MistralAI.Exception;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, MistralAI.Errors;

type
  MistralAIException = class(Exception)
  private
    FCode: Int64;
    FMsg: string;
  public
    constructor Create(const ACode: Int64; const AError: TErrorCore); reintroduce; overload;
    constructor Create(const ACode: Int64; const Value: string); reintroduce; overload;
    property Code: Int64 read FCode write FCode;
    property Msg: string read FMsg write FMsg;
  end;

  MistralAIValidationException = class(Exception)
  private
    FCode: Int64;
  protected
    function DetailItemToStr(const Value: TDetail): string;
    function LocToStr(const Value: TArray<string>): string;
    function ToText(const AError: TError422): string;
    function TypeToStr(const Value: string): string;
  public
    constructor Create(const ACode: Int64; const AError: TErrorCore); reintroduce;
    property Code: Int64 read FCode write FCode;
  end;

  /// <summary>
  /// The MistralAIExceptionAPI class represents a generic API-related exception.
  /// It is thrown when there is an issue with the API configuration or request process,
  /// such as a missing API token, invalid base URL, or other configuration errors.
  /// This class serves as a base for more specific API exceptions.
  /// </summary>
  MistralAIExceptionAPI = class(Exception);

  /// <summary>
  /// An EInvalidRequestError indicates that your request was malformed or
  /// missing some required parameters, such as a token or an input.
  /// This could be due to a typo, a formatting error, or a logic error in your code.
  /// </summary>
  EInvalidRequestError = class(MistralAIException);

  /// <summary>
  /// A ERateLimitError indicates that you have hit your assigned rate limit.
  /// This means that you have sent too many tokens or requests in a given period of time,
  /// and our services have temporarily blocked you from sending more.
  /// </summary>
  ERateLimitError = class(MistralAIException);

  /// <summary>
  /// An EAuthenticationError indicates that your API key or token was invalid,
  /// expired, or revoked. This could be due to a typo, a formatting error, or a security breach.
  /// </summary>
  EAuthenticationError = class(MistralAIException);

  /// <summary>
  /// This error message indicates that your account is not part of an organization
  /// </summary>
  EPermissionError = class(MistralAIException);

  /// <summary>
  /// This error message indicates that our servers are experiencing high
  /// traffic and are unable to process your request at the moment
  /// </summary>
  ETryAgain = class(MistralAIException);

  EEngineException = class(MistralAIException);

  /// <summary>
  /// This error occurs when a request to the API can not be processed. This is a client-side error,
  /// meaning the problem is with the request itself, and not the API.
  /// </summary>
  EUnprocessableEntityError = class(MistralAIValidationException);

  /// <summary>
  /// An EInvalidResponse error occurs when the API response is either empty or not in the expected format.
  /// This error indicates that the API did not return a valid response that can be processed, possibly due to a server-side issue,
  /// a malformed request, or unexpected input data.
  /// </summary>
  EInvalidResponse = class(MistralAIException);

implementation

uses
  System.StrUtils;

{ MistralAIException }

constructor MistralAIException.Create(const ACode: Int64; const AError: TErrorCore);
begin
  if not Assigned(AError) then
    begin
      case ACode of
        404: Msg := 'The requested resource was not found on this server.';
        else
          Msg := 'Unknown error';
      end;
      inherited Create(Format('error %d: %s', [ACode, Msg]));
      Exit;
    end;

  var Error := AError as TError;

  Code := ACode;
  if Error.Detail <> EmptyStr then
    Msg := Error.Detail
  else
  if Error.Message <> EmptyStr then
    Msg := Error.Message;
  if Error.RequestID <> EmptyStr then
    Msg := Format('%s for request %s', [Msg, Error.RequestID]);

  inherited Create(Format('error %d: %s', [ACode, Msg]));
end;

constructor MistralAIException.Create(const ACode: Int64; const Value: string);
begin
  Code := ACode;
  Msg := Value;
  inherited Create(Format('error %d: %s', [ACode, Msg]));
end;

{ MistralAIValidationException }

constructor MistralAIValidationException.Create(const ACode: Int64;
  const AError: TErrorCore);
begin
  var Error := AError as TError422;
  Code := ACode;
  if Length(Error.Detail) > 0 then
    inherited Create(Format('error %d: %s ', [ACode, TypeToStr(Error.Detail[0].Msg)]))
  else
    {--- WARNING ---
         Problem with errors generated by Mistral.
         (Detail & Message: inconsistent. Pending correction)}
    if Length(Error.Message.Detail) > 0 then
       inherited Create(
          Format('error %d: %s '+ sLineBreak +' %s',
                 [ACode, TypeToStr(Error.&Type), ToText(Error)]) )
    else
      inherited Create(Format('error %d: %s ', [ACode, 'Detail not captured']));
end;

function MistralAIValidationException.DetailItemToStr(
  const Value: TDetail): string;
begin
  Result := Format('   %s (%s) --- %s '+sLineBreak, [LocToStr(Value.Loc), Value.Input, Value.Msg])
end;

function MistralAIValidationException.LocToStr(
  const Value: TArray<string>): string;
begin
  Result := EmptyStr;
  for var S in Value do
    if IndexStr(S, ['body']) = -1 then
      begin
        if Result <> EmptyStr then
          Result := Result + '.' + S else
          Result := S;
      end;
end;

function MistralAIValidationException.ToText(
  const AError: TError422): string;
begin
  Result := EmptyStr;
  for var Item in AError.Message.Detail do
    begin
      if Result <> EmptyStr then
        Result := Format('%s %s', [Result, DetailItemToStr(Item)]) else
        Result := DetailItemToStr(Item);
    end;
end;

function MistralAIValidationException.TypeToStr(const Value: string): string;
begin
  Result := StringReplace(Value, '_', ' ', [rfReplaceAll, rfIgnoreCase]);
end;

end.

unit MistralAI.Files;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.Classes, System.SysUtils, REST.JsonReflect, REST.Json.Types, System.Net.Mime,
  System.Threading, MistralAI.API.Params, MistralAI.API, MistralAI.Async.Support,
  MistralAI.Types, MistralAI.Async.Promise;

type
  /// <summary>
  /// Parameters for uploading a file.
  /// </summary>
  /// <remarks>
  /// This class is used to construct the multipart form data for file uploads.
  /// Example usage:
  /// <code>
  /// var
  ///   UploadParams: TUploadParams;
  /// begin
  ///   UploadParams := TUploadParams.Create;
  ///   try
  ///     UploadParams.File('path/to/file.jsonl');
  ///     UploadParams.Purpose(TFilePurpose.finetune);
  ///     // Use UploadParams with the API upload method
  ///   finally
  ///     UploadParams.Free;
  ///   end;
  /// end;
  /// </code>
  /// </remarks>
  TUploadParams = class(TMultipartFormData)
    /// <summary>
    /// Adds a file to be uploaded from a file name.
    /// </summary>
    /// <param name="FileName">
    /// The name of the file to upload.
    /// </param>
    /// <returns>
    /// The current <c>TUploadParams</c> instance.
    /// </returns>
    /// <remarks>
    /// Example:
    /// <code>
    /// UploadParams.File('path/to/file.jsonl');
    /// </code>
    /// </remarks>
    function &File(const FileName: string): TUploadParams; overload;

    /// <summary>
    /// Adds a file to be uploaded from a stream.
    /// </summary>
    /// <param name="Stream">
    /// The stream containing the file data.
    /// </param>
    /// <param name="FileName">
    /// The name of the file.
    /// </param>
    /// <returns>
    /// The current <c>TUploadParams</c> instance.
    /// </returns>
    /// <remarks>
    /// Example:
    /// <code>
    /// var
    ///   FileStream: TFileStream;
    /// begin
    ///   FileStream := TFileStream.Create('path/to/file.jsonl', fmOpenRead);
    ///   try
    ///     UploadParams.File(FileStream, 'file.jsonl');
    ///   finally
    ///     FileStream.Free;
    ///   end;
    /// end;
    /// </code>
    /// </remarks>
    function &File(const Stream: TStream; const FileName: string): TUploadParams; overload;

    /// <summary>
    /// Sets the intended purpose of the uploaded file.
    /// </summary>
    /// <param name="Value">
    /// The purpose as a string. Only 'fine-tune' is accepted for now.
    /// </param>
    /// <returns>
    /// The current <c>TUploadParams</c> instance.
    /// </returns>
    /// <remarks>
    /// Example:
    /// <code>
    /// UploadParams.Purpose('fine-tune');
    /// </code>
    /// </remarks>
    function Purpose(const Value: string): TUploadParams; overload;

    /// <summary>
    /// Sets the intended purpose of the uploaded file.
    /// </summary>
    /// <param name="Value">
    /// The purpose as a <c>TFilePurpose</c> value.
    /// </param>
    /// <returns>
    /// The current <c>TUploadParams</c> instance.
    /// </returns>
    /// <remarks>
    /// Example:
    /// <code>
    /// UploadParams.Purpose(TFilePurpose.finetune);
    /// </code>
    /// </remarks>
    function Purpose(const Value: TFilePurpose): TUploadParams; overload;

    /// <summary>
    /// Creates a new instance of <c>TUploadParams</c>.
    /// </summary>
    /// <remarks>
    /// Initializes the multipart form data with ownership set to True.
    /// </remarks>
    constructor Create; reintroduce;
  end;

  /// <summary>
  /// Represents the parameters for listing files with specific criteria.
  /// </summary>
  /// <remarks>
  /// This class is used to configure and pass parameters when listing files from the API.
  /// It provides methods to set pagination, filtering, and searching options.
  /// </remarks>
  TListParams = class(TUrlParam)
    /// <summary>
    /// Sets the intended page in the returned list.
    /// </summary>
    /// <param name="Value">
    /// Integer type size value. Default 0
    /// </param>
    /// <returns>
    /// The current <c>TListParams</c> instance.
    /// </returns>
    function Page(const Value: Integer): TListParams;

    /// <summary>
    /// Sets the intended page size of the returned list.
    /// </summary>
    /// <param name="Value">
    /// Integer type size value. Default 100
    /// </param>
    /// <returns>
    /// The current <c>TListParams</c> instance.
    /// </returns>
    function PageSize(const Value: Integer): TListParams;

    /// <summary>
    /// Sets the intended sample_type of the listed file.
    /// </summary>
    /// <param name="Value">
    /// The sample_type as a <c>TSampleType</c> value.
    /// </param>
    /// <returns>
    /// The current <c>TListParams</c> instance.
    /// </returns>
    function SampleType(const Value: TArray<TSampleType>): TListParams;

    /// <summary>
    /// Sets the intended source of the listed file.
    /// </summary>
    /// <param name="Value">
    /// The source as a <c>TSourceType</c> value.
    /// </param>
    /// <returns>
    /// The current <c>TListParams</c> instance.
    /// </returns>
    function Source(const Value: TArray<TSourceType>): TListParams;

    /// <summary>
    /// Sets the intended search of the listed file.
    /// </summary>
    /// <param name="Value">
    /// The search as a <c>string</c> type value.
    /// </param>
    /// <returns>
    /// The current <c>TListParams</c> instance.
    /// </returns>
    function Search(const Value: string): TListParams;

    /// <summary>
    /// Sets the intended purpose of the listed file.
    /// </summary>
    /// <param name="Value">
    /// The purpose as a <c>TFilePurpose</c> value.
    /// </param>
    /// <returns>
    /// The current <c>TListParams</c> instance.
    /// </returns>
    function Purpose(const Value: TFilePurpose): TListParams;
  end;

  /// <summary>
  /// Represents URL signing parameters for file access requests.
  /// </summary>
  /// <remarks>
  /// Use this class to specify how long a pre-signed URL remains valid.
  /// The default expiry is 24 hours.
  /// </remarks>
  TSignedUrlParams = class(TUrlParam)
    /// <summary>
    /// Sets the number of hours before the signed URL expires.
    /// </summary>
    /// <param name="Value">
    /// The lifetime of the URL in hours. If not specified, defaults to 24.
    /// </param>
    /// <returns>
    /// The current <c>TSignedUrlParams</c> instance.
    /// </returns>
    /// <remarks>
    /// After the expiry time elapses, the signed URL will no longer grant access.
    /// </remarks>
    function Expiry(const Value: Integer): TSignedUrlParams;
  end;

  /// <summary>
  /// Represents a file in the Mistral AI system.
  /// </summary>
  /// <remarks>
  /// This class contains properties that represent the attributes of a file as returned by the API.
  /// </remarks>
  TFile = class(TJSONFingerprint)
  private
    FBytes: Int64;
    [JsonNameAttribute('created_at')]
    FCreated_at: Int64;
    FFilename: string;
    FId: string;
    FObject: string;
    [JsonReflectAttribute(ctString, rtString, TFilePurposeInterceptor)]
    FPurpose: TFilePurpose;
    [JsonReflectAttribute(ctString, rtString, TSampleTypeInterceptor)]
    [JsonNameAttribute('sample_type')]
    FSampleType: TSampleType;
    [JsonNameAttribute('num_lines')]
    FNumLines: Int64;
    FMimetype: string;
    [JsonReflectAttribute(ctString, rtString, TSourceTypeInterceptor)]
    FSource: TSourceType;
    FDeleted: Boolean;
    FSignature: string;
  public
    /// <summary>
    /// The size (in bytes) of the file.
    /// </summary>
    property Bytes: Int64 read FBytes write FBytes;

    /// <summary>
    /// The UNIX timestamp (in seconds) when the file was created.
    /// </summary>
    /// <remarks>
    /// You can convert this to a TDateTime using standard Delphi functions.
    /// Example:
    /// <code>
    /// var
    ///   CreationDate: TDateTime;
    /// begin
    ///   CreationDate := UnixToDateTime(File.CreatedAt);
    /// end;
    /// </code>
    /// </remarks>
    property CreatedAt: Int64 read FCreated_at write FCreated_at;

    /// <summary>
    /// The name of the uploaded file.
    /// </summary>
    property FileName: string read FFilename write FFilename;

    /// <summary>
    /// The unique identifier of the file.
    /// </summary>
    property Id: string read FId write FId;

    /// <summary>
    /// The object type, which is always 'file'.
    /// </summary>
    property &Object: string read FObject write FObject;

    /// <summary>
    /// The intended purpose of the file.
    /// </summary>
    property Purpose: TFilePurpose read FPurpose write FPurpose;

    /// <summary>
    /// Enum: "pretrain" "instruct" "batch_request" "batch_result" "batch_error"
    /// </summary>
    property SampleType: TSampleType read FSampleType write FSampleType;

    /// <summary>
    /// Num lines returned
    /// </summary>
    property NumLines: Int64 read FNumLines write FNumLines;

    property Mimetype: string read FMimetype write FMimetype;

    /// <summary>
    /// Enum: "upload" "repository" "mistral"
    /// </summary>
    property Source: TSourceType read FSource write FSource;

    /// <summary>
    /// Indicator when file retrieving only
    /// </summary>
    property Deleted: Boolean read FDeleted write FDeleted;

    property Signature: string read FSignature write FSignature;
  end;

  /// <summary>
  /// Represents a collection of files.
  /// </summary>
  /// <remarks>
  /// This class is used to hold a list of files as returned by the API.
  /// Example usage:
  /// <code>
  /// var
  ///   Files: TFiles;
  ///   FileItem: TFile;
  /// begin
  ///   Files := FilesRoute.List;
  ///   try
  ///     for FileItem in Files.Data do
  ///     begin
  ///       // Process each file
  ///     end;
  ///   finally
  ///     Files.Free;
  ///   end;
  /// end;
  /// </code>
  /// </remarks>
  TFiles = class(TJSONFingerprint)
  private
    FData: TArray<TFile>;
    FObject: string;
    FTotal: Int64;
  public
    /// <summary>
    /// An array of <c>TFile</c> objects representing the files.
    /// </summary>
    property Data: TArray<TFile> read FData write FData;

    /// <summary>
    /// The object type, which is always 'list'.
    /// </summary>
    property &Object: string read FObject write FObject;

    /// <summary>
    /// The total returned
    /// </summary>
    property Total: Int64 read FTotal write FTotal;

    /// <summary>
    /// Destroys the <c>TFiles</c> instance and frees associated resources.
    /// </summary>
    /// <remarks>
    /// This destructor ensures that all <c>TFile</c> instances in the Data array are properly freed.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents the result of a file deletion operation.
  /// </summary>
  /// <remarks>
  /// Contains information about the deletion status and the ID of the deleted file.
  /// </remarks>
  TDeletedResult = class(TJSONFingerprint)
  private
    [JsonNameAttribute('deleted')]
    FDeleted: Boolean;
    [JsonNameAttribute('id')]
    FId: string;
    [JsonNameAttribute('object')]
    FObject: string;
  public
    /// <summary>
    /// Indicates whether the file was successfully deleted.
    /// </summary>
    property Deleted: Boolean read FDeleted write FDeleted;

    /// <summary>
    /// The unique identifier of the deleted file.
    /// </summary>
    property Id: string read FId write FId;

    /// <summary>
    /// The object type, which is always 'file'.
    /// </summary>
    property &Object: string read FObject write FObject;
  end;

  /// <summary>
  /// Represents a downloaded file, providing functionality to access and save its data.
  /// </summary>
  /// <remarks>
  /// This class encapsulates a downloaded file and provides methods to retrieve its data as a stream
  /// or save it to a file. The file data is expected to be in a base64-encoded format.
  /// </remarks>
  TDownLoadFile = class(TJSONFingerprint)
  private
    FData: string;
    FFileName: string;
  public
    /// <summary>
    /// Gets the file name where the data was saved.
    /// </summary>
    /// <value>
    /// The file path as a string.
    /// </value>
    /// <remarks>
    /// This property holds the file name specified in the last call to <c>SaveToFile</c>.
    /// </remarks>
    property FileName: string read FFileName write FFileName;

    /// <summary>
    /// Retrieves the downloaded file as a <c>TStream</c>.
    /// </summary>
    /// <returns>
    /// A <c>TStream</c> containing the decoded image data.
    /// </returns>
    /// <remarks>
    /// This method decodes the base64-encoded data and returns it as a stream.
    /// The caller is responsible for freeing the returned stream.
    /// </remarks>
    /// <exception cref="Exception">
    /// Raises an exception data field is empty.
    /// </exception>
    function GetStream: TStream;

    /// <summary>
    /// Saves the gdownloaded file to a file.
    /// </summary>
    /// <param name="FileName">
    /// The file path to save data.
    /// </param>
    /// <remarks>
    /// This method decodes the base64-encoded data and saves it to the specified file.
    /// </remarks>
    /// <exception cref="Exception">
    /// Raises an exception if the data cannot be decoded or saved.
    /// </exception>
    procedure SaveToFile(const FileName: string; const FailIfExists: Boolean = True);

    /// <summary>
    /// File downloaded as base64-encoded data
    /// </summary>
    property Data: string read FData write FData;
  end;

  /// <summary>
  /// Represents a pre-signed URL returned by the API for temporary file access.
  /// </summary>
  /// <remarks>
  /// This class holds the URL that grants time-limited access to a file resource.
  /// Use the <see cref="Url"/> property before it expires.
  /// </remarks>
  TSignedUrl = class(TJSONFingerprint)
  private
    FUrl: string;
  public
    /// <summary>
    /// Gets or sets the pre-signed URL.
    /// </summary>
    /// <value>
    /// A string containing the URL that allows temporary access to the file.
    /// </value>
    /// <remarks>
    /// The URL is valid for the duration specified when it was created.
    /// </remarks>
    property Url: string read FUrl write FUrl;
  end;

  /// <summary>
  /// Asynchronous callback parameters for operations returning a single <c>TFile</c>.
  /// </summary>
  /// <remarks>
  /// Used when performing asynchronous operations that return a <c>TFile</c> instance.
  /// </remarks>
  TAsyncFile = TAsyncCallback<TFile>;

  /// <summary>
  /// Promise-based callback parameters for operations returning a single <c>TFile</c>.
  /// </summary>
  /// <remarks>
  /// Use this type when you prefer a promise-style API over traditional Callbacks.
  /// </remarks>
  TPromiseFile = TPromiseCallback<TFile>;

  /// <summary>
  /// Asynchronous callback parameters for operations returning <c>TFiles</c>.
  /// </summary>
  /// <remarks>
  /// Used when performing asynchronous operations that return a <c>TFiles</c> instance.
  /// </remarks>
  TAsyncFiles = TAsyncCallback<TFiles>;

  /// <summary>
  /// Promise-based callback parameters for operations returning a collection of <c>TFile</c> objects.
  /// </summary>
  /// <remarks>
  /// Use this type when you prefer a promise-style API over traditional Callbacks for file list operations.
  /// </remarks>
  TPromiseFiles = TPromiseCallback<TFiles>;

  /// <summary>
  /// Asynchronous callback parameters for file deletion operations.
  /// </summary>
  /// <remarks>
  /// Used when performing asynchronous operations that return a <c>TDeletedResult</c> instance.
  /// </remarks>
  TAsyncFilesDelete = TAsyncCallback<TDeletedResult>;

  /// <summary>
  /// Promise-based callback parameters for operations that delete a file, returning a <c>TDeletedResult</c>.
  /// </summary>
  /// <remarks>
  /// Use this type when you prefer a promise-style API over traditional Callbacks for file deletion operations.
  /// </remarks>
  TPromiseFilesDelete = TPromiseCallback<TDeletedResult>;

  /// <summary>
  /// Asynchronous callback parameters for file download operations.
  /// </summary>
  /// <remarks>
  /// Used when performing asynchronous operations that return a <c>TDownLoadFile</c> instance.
  /// </remarks>
  TAsyncDownLoadFile = TAsyncCallback<TDownLoadFile>;

  /// <summary>
  /// Promise-based callback parameters for operations returning a downloaded <c>TDownLoadFile</c>.
  /// </summary>
  /// <remarks>
  /// Use this type when you prefer a promise-style API over traditional Callbacks for file download operations.
  /// </remarks>
  TPromiseDownLoadFile = TPromiseCallback<TDownLoadFile>;

  /// <summary>
  /// Asynchronous callback parameters for operations returning a <c>TSignedUrl</c>.
  /// </summary>
  /// <remarks>
  /// Use this type when performing an asynchronous request to obtain a pre-signed URL.
  /// Configure its <c>OnSuccess</c> and <c>OnError</c> handlers to handle the result or any errors.
  /// Example:
  /// <code>
  /// MistralAI.File.AsyncGetSignedUrl(
  ///   'file_id',
  ///   procedure(Params: TSignedUrlParams)
  ///   begin
  ///     Params.Expiry(24);
  ///   end,
  ///   function: TAsyncSignedUrl
  ///   begin
  ///     Result.OnSuccess :=
  ///       procedure(Sender: TObject; UrlResult: TSignedUrl)
  ///       begin
  ///         // Use UrlResult.Url
  ///       end;
  ///     Result.OnError :=
  ///       procedure(Sender: TObject; ErrorMsg: string)
  ///       begin
  ///         // Handle error
  ///       end;
  ///   end);
  /// </code>
  /// </remarks>
  TAsyncSignedUrl = TAsyncCallback<TSignedUrl>;

  /// <summary>
  /// Promise-style callback parameters for operations returning a <c>TSignedUrl</c>.
  /// </summary>
  /// <remarks>
  /// Use this type when you prefer a promise-based API to request a pre-signed URL.
  /// The returned promise exposes <c>Then</c> for success and <c>Catch</c> for error handling.
  /// Example:
  /// <code>
  /// FilesRoute.AsyncAwaitGetSignedUrl(
  ///   'file_id',
  ///   procedure(Params: TSignedUrlParams)
  ///   begin
  ///     Params.Expiry(24);
  ///   end
  /// ).&Then(
  ///   function(UrlResult: TSignedUrl): TSignedUrl
  ///   begin
  ///     // Use UrlResult.Url
  ///   end
  /// ).&Catch(
  ///   procedure(E: Exception)
  ///   begin
  ///     // Handle error
  ///   end
  /// );
  /// </code>
  /// </remarks>
  TPromiseSignedUrl = TPromiseCallback<TSignedUrl>;

  /// <summary>
  /// Provides methods to interact with the Mistral AI Files API.
  /// </summary>
  /// <remarks>
  /// This class includes both synchronous and asynchronous methods for file operations.
  /// Example usage:
  /// <code>
  /// var
  ///   FilesRoute: TFilesRoute;
  ///   FileInfo: TFile;
  /// begin
  ///   FilesRoute := TFilesRoute.Create(APIInstance);
  ///   try
  ///     FileInfo := FilesRoute.Retrieve('file_id');
  ///     // Process FileInfo
  ///   finally
  ///     FilesRoute.Free;
  ///     FileInfo.Free;
  ///   end;
  /// end;
  /// </code>
  /// </remarks>
  TFilesRoute = class(TMistralAIAPIRoute)
    /// <summary>
    /// Wraps the asynchronous delete operation in a promise-style API.
    /// </summary>
    /// <param name="FileId">
    /// The unique identifier of the file to delete.
    /// </param>
    /// <param name="Callbacks">
    /// Optional function to configure promise-based Callbacks (OnSuccess, OnError, etc.).
    /// </param>
    /// <returns>
    /// A <see cref="TPromise&lt;TDeletedResult&gt;"/> that resolves with the deletion result.
    /// </returns>
    /// <remarks>
    /// Internally calls <see cref="AsyncDelete"/> and wraps its Callbacks into a <see cref="TPromise&lt;TDeletedResult&gt;"/>.
    /// Use this method when you prefer awaiting a promise rather than handling Callbacks directly.
    /// </remarks>
    function AsyncAwaitDelete(const FileId: string;
      const Callbacks: TFunc<TPromiseFilesDelete> = nil): TPromise<TDeletedResult>;

    /// <summary>
    /// Wraps the asynchronous download operation in a promise-style API.
    /// </summary>
    /// <param name="FileId">
    /// The unique identifier of the file to download.
    /// </param>
    /// <param name="Callbacks">
    /// Optional function to configure promise-based Callbacks (OnSuccess, OnError, etc.).
    /// </param>
    /// <returns>
    /// A <see cref="TPromise&lt;TDownLoadFile&gt;"/> that resolves with the downloaded file.
    /// </returns>
    /// <remarks>
    /// Internally calls <see cref="AsyncDownload"/> and wraps its Callbacks into a <see cref="TPromise&lt;TDownLoadFile&gt;"/>.
    /// Use this method when you prefer awaiting a promise rather than handling Callbacks directly.
    /// </remarks>
    function AsyncAwaitDownload(const FileId: string;
      const Callbacks: TFunc<TPromiseDownLoadFile> = nil): TPromise<TDownLoadFile>;

    /// <summary>
    /// Wraps the asynchronous list operation in a promise-style API.
    /// </summary>
    /// <param name="Callbacks">
    /// Optional function to configure promise-based Callbacks (OnSuccess, OnError, etc.).
    /// </param>
    /// <returns>
    /// A <see cref="TPromise&lt;TFiles&gt;"/> that resolves with the collection of files.
    /// </returns>
    /// <remarks>
    /// Internally calls <see cref="AsyncList"/> and wraps its Callbacks into a <see cref="TPromise&lt;TFiles&gt;"/>.
    /// Use this method when you prefer awaiting a promise rather than handling Callbacks directly.
    /// </remarks>
    function AsyncAwaitList(
      const Callbacks: TFunc<TPromiseFiles> = nil): TPromise<TFiles>; overload;

    /// <summary>
    /// Wraps the asynchronous list operation—with custom parameters—in a promise-style API.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <see cref="TListParams"/> (e.g., paging, filtering).
    /// </param>
    /// <param name="Callbacks">
    /// Optional function to configure promise-based Callbacks (OnSuccess, OnError, etc.).
    /// </param>
    /// <returns>
    /// A <see cref="TPromise&lt;TFiles&gt;"/> that resolves with the collection of files matching the specified parameters.
    /// </returns>
    /// <remarks>
    /// Internally calls <see cref="AsyncList"/> with <paramref name="ParamProc"/> and wraps its Callbacks into a <see cref="TPromise&lt;TFiles&gt;"/>.
    /// Use this overload when you need to customize list parameters before awaiting the result.
    /// </remarks>
    function AsyncAwaitList(const ParamProc: TProc<TListParams>;
      const Callbacks: TFunc<TPromiseFiles> = nil): TPromise<TFiles>; overload;

    /// <summary>
    /// Wraps the asynchronous retrieve operation in a promise-style API.
    /// </summary>
    /// <param name="FileId">
    /// The unique identifier of the file to retrieve.
    /// </param>
    /// <param name="Callbacks">
    /// Optional function to configure promise-based Callbacks (OnSuccess, OnError, etc.).
    /// </param>
    /// <returns>
    /// A <see cref="TPromise&lt;TFile&gt;"/> that resolves with the retrieved file.
    /// </returns>
    /// <remarks>
    /// Internally calls <see cref="AsyncRetrieve"/> and wraps its Callbacks into a <see cref="TPromise&lt;TFile&gt;"/>.
    /// Use this method when you prefer awaiting a promise rather than handling Callbacks directly.
    /// </remarks>
    function AsyncAwaitRetrieve(const FileId: string;
      const Callbacks: TFunc<TPromiseFile> = nil): TPromise<TFile>;

    /// <summary>
    /// Wraps the asynchronous upload operation in a promise-style API.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <see cref="TUploadParams"/> (e.g., file stream, purpose).
    /// </param>
    /// <param name="Callbacks">
    /// Optional function to configure promise-based Callbacks (OnSuccess, OnError, etc.).
    /// </param>
    /// <returns>
    /// A <see cref="TPromise&lt;TFile&gt;"/> that resolves with the uploaded file metadata.
    /// </returns>
    /// <remarks>
    /// Internally calls <see cref="AsyncUpload"/> with <paramref name="ParamProc"/> and wraps its Callbacks into a <see cref="TPromise&lt;TFile&gt;"/>.
    /// Use this method when you prefer awaiting a promise rather than handling Callbacks directly.
    /// </remarks>
    function AsyncAwaitUpload(const ParamProc: TProc<TUploadParams>;
      const Callbacks: TFunc<TPromiseFile> = nil): TPromise<TFile>;

    /// <summary>
    /// Wraps the asynchronous get-signed-URL operation in a promise-style API.
    /// </summary>
    /// <param name="FileId">
    /// The unique identifier of the file for which to obtain a signed URL.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TSignedUrlParams</c> (e.g., expiry time).
    /// </param>
    /// <param name="Callbacks">
    /// Optional function to configure promise-based Callbacks (<c>OnSuccess</c>, <c>OnError</c>, etc.).
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TSignedUrl&gt;</c> that resolves with the pre-signed URL.
    /// </returns>
    /// <remarks>
    /// Internally calls <see cref="ASyncGetSignedUrl"/> and wraps its Callbacks into a promise.
    /// Use <c>Then</c> to handle success and <c>Catch</c> to handle errors.
    /// Example:
    /// <code>
    /// FilesRoute.AsyncAwaitGetSignedUrl(
    ///   'file_id',
    ///   procedure(Params: TSignedUrlParams)
    ///   begin
    ///     Params.Expiry(24);
    ///   end
    /// ).Then(
    ///   function(UrlResult: TSignedUrl): TSignedUrl
    ///   begin
    ///     // Use UrlResult.Url here
    ///   end
    /// ).Catch(
    ///   procedure(E: Exception)
    ///   begin
    ///     // Handle error
    ///   end
    /// );
    /// </code>
    /// </remarks>
    function AsyncAwaitGetSignedUrl(const FileId: string;
      const ParamProc: TProc<TSignedUrlParams>;
      const Callbacks: TFunc<TPromiseSignedUrl> = nil): TPromise<TSignedUrl>;

    /// <summary>
    /// Deletes a file.
    /// </summary>
    /// <param name="FileId">
    /// The unique identifier of the file to delete.
    /// </param>
    /// <returns>
    /// A <c>TDeletedResult</c> instance representing the result of the deletion.
    /// </returns>
    /// <remarks>
    /// Example:
    /// <code>
    ///   with MistralAI.File.Delete('file_id');
    ///   try
    ///     if Deleted then
    ///       ShowMessage('file deleted');
    ///   finally
    ///     Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Delete(const FileId: string): TDeletedResult;

    /// <summary>
    /// Download a file.
    /// </summary>
    /// <param name="FileId">
    /// The unique identifier of the file to delete.
    /// </param>
    /// <returns>
    /// A <c>TDownLoadFile</c> instance representing the result of the download.
    /// </returns>
    /// <remarks>
    /// Example:
    /// <code>
    ///   with MistralAI.File.Download('file_id');
    ///   try
    ///     //do something
    ///   finally
    ///     Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Download(const FileId: string): TDownLoadFile;

    /// <summary>
    /// Retrieves the list of files belonging to the user's organization.
    /// </summary>
    /// <returns>
    /// A <c>TFiles</c> instance containing the list of files.
    /// </returns>
    /// <remarks>
    /// Example:
    /// <code>
    ///   var Files := MistralAI.File.List;
    ///   try
    ///     // Process files
    ///   finally
    ///     Files.Free;
    /// end;
    /// </code>
    /// </remarks>
    function List: TFiles; overload;

    /// <summary>
    /// Retrieves the list of files belonging to the user's organization.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the <c>TListParams</c> for the upload.
    /// </param>
    /// <returns>
    /// A <c>TFiles</c> instance containing the list of files.
    /// </returns>
    /// <remarks>
    /// Example:
    /// <code>
    ///   var Files := MistralAI.File.List(
    ///     procedure (Params: TListParams)
    ///     begin
    ///       // Set parameters
    ///     end);
    ///   try
    ///     // Process files
    ///   finally
    ///     Files.Free;
    /// end;
    /// </code>
    /// </remarks>
    function List(const ParamProc: TProc<TListParams>): TFiles; overload;

    /// <summary>
    /// Retrieves information about a specific file.
    /// </summary>
    /// <param name="FileId">
    /// The unique identifier of the file to retrieve.
    /// </param>
    /// <returns>
    /// A <c>TFile</c> instance containing the file information.
    /// </returns>
    /// <remarks>
    /// Example:
    /// <code>
    ///   var FileInfo := MistralAI.File.Retrieve('file_id');
    ///   try
    ///     // Process FileInfo
    ///   finally
    ///     FileInfo.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Retrieve(const FileId: string): TFile;

    /// <summary>
    /// Uploads a file that can be used across various endpoints.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the <c>TUploadParams</c> for the upload.
    /// </param>
    /// <returns>
    /// A <c>TFile</c> instance representing the uploaded file.
    /// </returns>
    /// <remarks>
    /// The size of individual files can be a maximum of 512 MB. The Fine-tuning API only supports .jsonl files. Please contact support if you need to increase these storage limits.
    /// Example:
    /// <code>
    ///   var UploadedFile := MistralAI.File.Upload(
    ///     procedure(Params: TUploadParams)
    ///     begin
    ///       Params.File('path/to/file.jsonl');
    ///       Params.Purpose(TFilePurpose.finetune);
    ///     end);
    ///   try
    ///     // Process UploadedFile
    ///   finally
    ///     UploadedFile.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Upload(const ParamProc: TProc<TUploadParams>): TFile;

    /// <summary>
    /// Retrieves a pre-signed URL for temporary access to the specified file.
    /// </summary>
    /// <param name="FileId">
    /// The unique identifier of the file to generate a signed URL for.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TSignedUrlParams</c> (e.g., expiry time in hours).
    /// </param>
    /// <returns>
    /// A <c>TSignedUrl</c> instance containing the URL that grants time-limited access.
    /// </returns>
    /// <remarks>
    /// Internally invokes the API endpoint <c>files/{FileId}/url</c> with the given parameters.
    /// Example:
    /// <code>
    /// var
    ///   UrlResult: TSignedUrl;
    /// begin
    ///   UrlResult := FilesRoute.GetSignedUrl('file_id',
    ///     procedure(Params: TSignedUrlParams)
    ///     begin
    ///       Params.Expiry(24);
    ///     end);
    ///   try
    ///     // Use UrlResult.Url here
    ///   finally
    ///     UrlResult.Free;
    ///   end;
    /// end;
    /// </remarks>
    function GetSignedUrl(const FileId: string;
      const ParamProc: TProc<TSignedUrlParams>): TSignedUrl;

    /// <summary>
    /// Asynchronously deletes a file.
    /// </summary>
    /// <param name="FileId">
    /// The unique identifier of the file to delete.
    /// </param>
    /// <param name="Callbacks">
    /// A function that returns the asynchronous callback parameters.
    /// </param>
    /// <remarks>
    /// Example:
    /// <code>
    /// MistralAI.File.AsyncDelete(
    ///   'file_id',
    ///   function: TAsynFilesDelete
    ///   begin
    ///     Result.OnSuccess :=
    ///       procedure(Sender: TObject; DeletedResult: TDeletedResult)
    ///       begin
    ///         // Handle successful deletion
    ///       end;
    ///
    ///     Result.OnError :=
    ///       procedure(Sender: TObject; ErrorMsg: string)
    ///       begin
    ///         // Handle error
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncDelete(const FileId: string; const Callbacks: TFunc<TAsyncFilesDelete>);

    /// <summary>
    /// Asynchronously download a file.
    /// </summary>
    /// <param name="FileId">
    /// The unique identifier of the file to download.
    /// </param>
    /// <param name="Callbacks">
    /// A function that returns the asynchronous callback parameters.
    /// </param>
    /// <remarks>
    /// Example:
    /// <code>
    /// MistralAI.File.AsynDownload(
    ///   'file_id',
    ///   function: TAsynDownLoadFile
    ///   begin
    ///     Result.OnSuccess :=
    ///       procedure(Sender: TObject; Value: TDownLoadFile)
    ///       begin
    ///         // Handle successful deletion
    ///       end;
    ///
    ///     Result.OnError :=
    ///       procedure(Sender: TObject; ErrorMsg: string)
    ///       begin
    ///         // Handle error
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncDownload(const FileId: string; const Callbacks: TFunc<TAsyncDownLoadFile>);

    /// <summary>
    /// Asynchronously retrieves the list of files belonging to the user's organization.
    /// </summary>
    /// <param name="Callbacks">
    /// A function that returns the asynchronous callback parameters.
    /// </param>
    /// <remarks>
    /// Example:
    /// <code>
    /// MistralAI.File.AsyncList(
    ///   function: TAsynFiles
    ///   begin
    ///     Result.OnSuccess :=
    ///       procedure(Sender: TObject; Files: TFiles)
    ///       begin
    ///         // Process files
    ///       end;
    ///
    ///     Result.OnError :=
    ///       procedure(Sender: TObject; ErrorMsg: string)
    ///       begin
    ///         // Handle error
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncList(const Callbacks: TFunc<TAsyncFiles>); overload;

    /// <summary>
    /// Asynchronously retrieves the list of files belonging to the user's organization.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the <c>TListParams</c> for the upload.
    /// </param>
    /// <param name="Callbacks">
    /// A function that returns the asynchronous callback parameters.
    /// </param>
    /// <remarks>
    /// Example:
    /// <code>
    /// MistralAI.File.AsyncList(
    ///   function: TAsynFiles
    ///   begin
    ///     Result.OnSuccess :=
    ///       procedure(Sender: TObject; Files: TFiles)
    ///       begin
    ///         // Process files
    ///       end;
    ///
    ///     Result.OnError :=
    ///       procedure(Sender: TObject; ErrorMsg: string)
    ///       begin
    ///         // Handle error
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncList(const ParamProc: TProc<TListParams>; const Callbacks: TFunc<TAsyncFiles>); overload;

    /// <summary>
    /// Asynchronously retrieves information about a specific file.
    /// </summary>
    /// <param name="FileId">
    /// The unique identifier of the file to retrieve.
    /// </param>
    /// <param name="Callbacks">
    /// A function that returns the asynchronous callback parameters.
    /// </param>
    /// <remarks>
    /// Example:
    /// <code>
    /// MistralAI.File.AsyncRetrieve(
    ///   'file_id',
    ///   function: TAsynFile
    ///   begin
    ///     Result.OnSuccess :=
    ///       procedure(Sender: TObject; FileInfo: TFile)
    ///       begin
    ///         // Process FileInfo
    ///       end;
    ///
    ///     Result.OnError :=
    ///       procedure(Sender: TObject; ErrorMsg: string)
    ///       begin
    ///         // Handle error
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsyncRetrieve(const FileId: string; const Callbacks: TFunc<TAsyncFile>);

    /// <summary>
    /// Asynchronously uploads a file that can be used across various endpoints.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the <c>TUploadParams</c> for the upload.
    /// </param>
    /// <param name="Callbacks">
    /// A function that returns the asynchronous callback parameters.
    /// </param>
    /// <remarks>
    /// The size of individual files can be a maximum of 512 MB. The Fine-tuning API only supports .jsonl files. Please contact support if you need to increase these storage limits.
    /// Example:
    /// <code>
    /// MistralAI.File.AsyncUpload(
    ///   procedure(Params: TUploadParams)
    ///   begin
    ///     Params.File('path/to/file.jsonl');
    ///     Params.Purpose(TFilePurpose.finetune);
    ///   end,
    ///   function: TAsynFile
    ///   begin
    ///     Result.OnSuccess :=
    ///       procedure(Sender: TObject; UploadedFile: TFile)
    ///       begin
    ///         // Process UploadedFile
    ///       end;
    ///
    ///     Result.OnError :=
    ///       procedure(Sender: TObject; ErrorMsg: string)
    ///       begin
    ///         // Handle error
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure ASyncUpload(const ParamProc: TProc<TUploadParams>; const Callbacks: TFunc<TAsyncFile>);

    /// <summary>
    /// Asynchronously obtains a pre-signed URL for temporary file access.
    /// </summary>
    /// <param name="FileId">
    /// The unique identifier of the file for which to generate the signed URL.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TSignedUrlParams</c>, such as the URL expiry time.
    /// </param>
    /// <param name="Callbacks">
    /// A function that returns the asynchronous callback parameters (<c>OnStart</c>, <c>OnSuccess</c>, <c>OnError</c>).
    /// </param>
    /// <remarks>
    /// This method invokes <see cref="GetSignedUrl"/> under the hood and delivers the result via the provided Callbacks.
    /// Use <c>Result.OnSuccess</c> to receive the <c>TSignedUrl</c> instance, or <c>Result.OnError</c> to handle failures.
    /// Example:
    /// <code>
    /// FilesRoute.ASyncGetSignedUrl(
    ///   'file_id',
    ///   procedure(Params: TSignedUrlParams)
    ///   begin
    ///     Params.Expiry(24);
    ///   end,
    ///   function: TAsyncSignedUrl
    ///   begin
    ///     Result.OnSuccess :=
    ///       procedure(Sender: TObject; UrlResult: TSignedUrl)
    ///       begin
    ///         // Use UrlResult.Url
    ///       end;
    ///     Result.OnError :=
    ///       procedure(Sender: TObject; ErrorMsg: string)
    ///       begin
    ///         // Handle error
    ///       end;
    ///   end
    /// );
    /// </code>
    /// </remarks>
    procedure ASyncGetSignedUrl(const FileId: string;
      const ParamProc: TProc<TSignedUrlParams>;
      const Callbacks: TFunc<TAsyncSignedUrl>);
  end;

implementation

uses
  System.StrUtils, Rest.Json, System.Rtti, MistralAI.NetEncoding.Base64, Vcl.Dialogs;

{ TUploadParams }

function TUploadParams.&File(const FileName: string): TUploadParams;
begin
  AddFile('file', FileName);
  Result := Self;
end;

constructor TUploadParams.Create;
begin
  inherited Create(True);
end;

function TUploadParams.&File(const Stream: TStream;
  const FileName: string): TUploadParams;
begin
  {$IF RTLVersion > 35.0}
  AddStream('file', Stream, True, FileName);
  {$ELSE}
  AddStream('file', Stream, FileName);
  {$ENDIF}
  Result := Self;
end;

function TUploadParams.Purpose(const Value: string): TUploadParams;
begin
  AddField('purpose', Value);
  Result := Self;
end;

function TUploadParams.Purpose(const Value: TFilePurpose): TUploadParams;
begin
  Result := Purpose(Value.ToString);
end;

{ TFilesRoute }

function TFilesRoute.AsyncAwaitDelete(const FileId: string;
  const Callbacks: TFunc<TPromiseFilesDelete>): TPromise<TDeletedResult>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TDeletedResult>(
    procedure(const CallbackParams: TFunc<TAsyncFilesDelete>)
    begin
      AsyncDelete(FileId, CallbackParams);
    end,
    Callbacks);
end;

function TFilesRoute.AsyncAwaitDownload(const FileId: string;
  const Callbacks: TFunc<TPromiseDownLoadFile>): TPromise<TDownLoadFile>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TDownLoadFile>(
    procedure(const CallbackParams: TFunc<TAsyncDownLoadFile>)
    begin
      AsyncDownload(FileId, CallbackParams);
    end,
    Callbacks);
end;

function TFilesRoute.AsyncAwaitGetSignedUrl(const FileId: string;
  const ParamProc: TProc<TSignedUrlParams>;
  const Callbacks: TFunc<TPromiseSignedUrl>): TPromise<TSignedUrl>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TSignedUrl>(
    procedure(const CallbackParams: TFunc<TAsyncSignedUrl>)
    begin
      ASyncGetSignedUrl(FileId, ParamProc, CallbackParams);
    end,
    Callbacks);
end;

function TFilesRoute.AsyncAwaitList(const ParamProc: TProc<TListParams>;
  const Callbacks: TFunc<TPromiseFiles>): TPromise<TFiles>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TFiles>(
    procedure(const CallbackParams: TFunc<TAsyncFiles>)
    begin
      AsyncList(ParamProc, CallbackParams);
    end,
    Callbacks);
end;

function TFilesRoute.AsyncAwaitList(
  const Callbacks: TFunc<TPromiseFiles>): TPromise<TFiles>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TFiles>(
    procedure(const CallbackParams: TFunc<TAsyncFiles>)
    begin
      AsyncList(CallbackParams);
    end,
    Callbacks);
end;

function TFilesRoute.AsyncAwaitRetrieve(const FileId: string;
  const Callbacks: TFunc<TPromiseFile>): TPromise<TFile>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TFile>(
    procedure(const CallbackParams: TFunc<TAsyncFile>)
    begin
      AsyncRetrieve(FileId, CallbackParams);
    end,
    Callbacks);
end;

function TFilesRoute.AsyncAwaitUpload(const ParamProc: TProc<TUploadParams>;
  const Callbacks: TFunc<TPromiseFile>): TPromise<TFile>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TFile>(
    procedure(const CallbackParams: TFunc<TAsyncFile>)
    begin
      AsyncUpload(ParamProc, CallbackParams);
    end,
    Callbacks);
end;

procedure TFilesRoute.AsyncDelete(const FileId: string;
  const Callbacks: TFunc<TAsyncFilesDelete>);
begin
  with TAsyncCallBackExec<TAsyncFilesDelete, TDeletedResult>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TDeletedResult
      begin
        Result := Delete(FileId);
      end);
  finally
    Free;
  end;
end;

procedure TFilesRoute.AsyncList(const ParamProc: TProc<TListParams>;
  const Callbacks: TFunc<TAsyncFiles>);
begin
  with TAsyncCallBackExec<TAsyncFiles, TFiles>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TFiles
      begin
        Result := List(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TFilesRoute.AsyncList(const Callbacks: TFunc<TAsyncFiles>);
begin
  with TAsyncCallBackExec<TAsyncFiles, TFiles>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TFiles
      begin
        Result := List;
      end);
  finally
    Free;
  end;
end;

procedure TFilesRoute.AsyncRetrieve(const FileId: string;
  const Callbacks: TFunc<TAsyncFile>);
begin
  with TAsyncCallBackExec<TAsyncFile, TFile>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TFile
      begin
        Result := Retrieve(FileId);
      end);
  finally
    Free;
  end;
end;

procedure TFilesRoute.ASyncUpload(const ParamProc: TProc<TUploadParams>;
  const Callbacks: TFunc<TAsyncFile>);
begin
  with TAsyncCallBackExec<TAsyncFile, TFile>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TFile
      begin
        Result := Upload(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TFilesRoute.AsyncDownload(const FileId: string;
  const Callbacks: TFunc<TAsyncDownLoadFile>);
begin
  with TAsyncCallBackExec<TAsyncDownLoadFile, TDownLoadFile>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TDownLoadFile
      begin
        Result := Self.Download(FileId);
      end);
  finally
    Free;
  end;
end;

procedure TFilesRoute.ASyncGetSignedUrl(const FileId: string;
  const ParamProc: TProc<TSignedUrlParams>;
  const Callbacks: TFunc<TAsyncSignedUrl>);
begin
  with TAsyncCallBackExec<TAsyncSignedUrl, TSignedUrl>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TSignedUrl
      begin
        Result := GetSignedUrl(FileId, ParamProc);
      end);
  finally
    Free;
  end;
end;

function TFilesRoute.Delete(const FileId: string): TDeletedResult;
begin
  Result := API.Delete<TDeletedResult>('files/' + FileId);
end;

function TFilesRoute.Download(const FileId: string): TDownLoadFile;
begin
  Result := API.GetFile<TDownLoadFile>(Format('files/%s/content', [FileId]));
end;

function TFilesRoute.GetSignedUrl(const FileId: string;
  const ParamProc: TProc<TSignedUrlParams>): TSignedUrl;
begin
  Result := API.Get<TSignedUrl, TSignedUrlParams>('files/' + FileId + '/url', ParamProc);
end;

function TFilesRoute.List: TFiles;
begin
  Result := API.Get<TFiles>('files');
end;

function TFilesRoute.List(const ParamProc: TProc<TListParams>): TFiles;
begin
  Result := API.Get<TFiles, TListParams>('files', ParamProc);
end;

function TFilesRoute.Retrieve(const FileId: string): TFile;
begin
  Result := API.Get<TFile>('files/' + FileId);
end;

function TFilesRoute.Upload(const ParamProc: TProc<TUploadParams>): TFile;
begin
  Result := API.PostForm<TFile, TUploadParams>('files', ParamProc);
end;

{ TFiles }

destructor TFiles.Destroy;
begin
  for var Item in FData do
    Item.Free;
  inherited;
end;

{ TListParams }

function TListParams.Page(const Value: Integer): TListParams;
begin
  Result := TListParams(Add('page', Value));
end;

function TListParams.PageSize(const Value: Integer): TListParams;
begin
  Result := TListParams(Add('page_size', Value));
end;

function TListParams.Purpose(const Value: TFilePurpose): TListParams;
begin
  Result := TListParams(Add('purpose', Value.ToString));
end;

function TListParams.SampleType(const Value: TArray<TSampleType>): TListParams;
begin
  var Param: TArray<string> := [];
  for var Item in Value do
    Param := Param + [Item.ToString];
  Result := TListParams(Add('sample_type', Param));
end;

function TListParams.Search(const Value: string): TListParams;
begin
  Result := TListParams(Add('search', Value));
end;

function TListParams.Source(const Value: TArray<TSourceType>): TListParams;
begin
  var Param: TArray<string> := [];
  for var Item in Value do
    Param := Param + [Item.ToString];
  Result := TListParams(Add('source', Param));
end;

{ TDownLoadFile }

function TDownLoadFile.GetStream: TStream;
begin
  {--- Create a memory stream to write the decoded content. }
  Result := TMemoryStream.Create;
  try
    {--- Convert the base-64 string directly into the memory stream. }
    DecodeBase64ToStream(Data, Result)
  except
    Result.Free;
    raise;
  end;
end;

procedure TDownLoadFile.SaveToFile(const FileName: string; const FailIfExists: Boolean);
begin
  if FileExists(FileName) and FailIfExists then
    raise Exception.CreateFmt('The file "%s" already exists and has not been overwritten.', [FileName]);
  try
    Self.FFileName := FileName;
    {--- Perform the decoding operation and save it into the file specified by the FileName parameter. }
    DecodeBase64ToFile(Data, FileName)
  except
    raise;
  end;
end;

{ TSignedUrlParams }

function TSignedUrlParams.Expiry(const Value: Integer): TSignedUrlParams;
begin
  Result := TSignedUrlParams(Add('expiry', Value));
end;

end.

unit MistralAI.FineTunings;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

-------------------------------------------------------------------------------}

interface

{$REGION 'Dev note'}
  (*

  **Important Notice**
                                                                                                                                                            |
  To monitor and track the progress of fine-tuning using Wandb.ai tools,
  you are required to register on the Wandb website at   https://wandb.ai/site.

  Registration is necessary to obtain the API key needed for "job" integration
  (TJobIntegrationsParam).

  *)
{$ENDREGION}

uses
  System.Classes, System.SysUtils, REST.JsonReflect, System.JSON, REST.Json.Types,
  MistralAI.API.Params, MistralAI.API, MistralAI.Types, MistralAI.Async.Support,
  MistralAI.Async.Promise;

type
  /// <summary>
  /// Represents the parameters for listing fine-tuning jobs.
  /// </summary>
  /// <remarks>
  /// Allows filtering and pagination of fine-tuning jobs when retrieving them via the API.
  /// </remarks>
  TFineTuningJobListParams = class(TURLParam)
    /// <summary>
    /// Sets the page number of the results to be returned.
    /// </summary>
    /// <param name="Value">
    /// The page number (starting from 0).
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobListParams"/> instance with the updated page number.
    /// </returns>
    /// <remarks> Default: 0 </remarks>
    function Page(const Value: Int64): TFineTuningJobListParams;

    /// <summary>
    /// Sets the number of items to return per page.
    /// </summary>
    /// <param name="Value">
    /// The number of items per page.
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobListParams"/> instance with the updated page size.
    /// </returns>
    /// <remarks> Default: 100 </remarks>
    function PageSize(const Value: Int64): TFineTuningJobListParams;

    /// <summary>
    /// Filters the fine-tuning jobs by model name.
    /// </summary>
    /// <param name="Value">
    /// The model name used for fine-tuning to filter on.
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobListParams"/> instance with the updated model filter.
    /// </returns>
    function Model(const Value: string): TFineTuningJobListParams;

    /// <summary>
    /// Filters the fine-tuning jobs by their current status.
    /// </summary>
    /// <param name="Value">
    /// The current job state to filter on.
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobListParams"/> instance with the updated status filter.
    /// </returns>
    function Status(const Value: TFineTuningJobStatus): TFineTuningJobListParams;

    /// <summary>
    /// Filters the fine-tuning jobs created after a specific date/time.
    /// </summary>
    /// <param name="Value">
    /// The date/time (ISO 8601 format) to filter on.
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobListParams"/> instance with the updated creation date filter.
    /// </returns>
    function CreatedAfter(const Value: string): TFineTuningJobListParams;

    /// <summary>
    /// Filters to only include jobs created by the API caller.
    /// </summary>
    /// <param name="Value">
    /// Set to <c>true</c> to include only jobs created by the API caller.
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobListParams"/> instance with the updated creator filter.
    /// </returns>
    /// <remarks> Default: false </remarks>
    function CreatedByMe(const Value: Boolean = True): TFineTuningJobListParams;

    /// <summary>
    /// Filters the fine-tuning jobs by Weights and Biases project name.
    /// </summary>
    /// <param name="Value">
    /// The WandB project name to filter on.
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobListParams"/> instance with the updated WandB project filter.
    /// </returns>
    function WandbProject(const Value: string): TFineTuningJobListParams;

    /// <summary>
    /// Filters the fine-tuning jobs by Weights and Biases run name.
    /// </summary>
    /// <param name="Value">
    /// The WandB run name to filter on.
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobListParams"/> instance with the updated WandB run name filter.
    /// </returns>
    function WandbName(const Value: string): TFineTuningJobListParams;

    /// <summary>
    /// Filters the fine-tuning jobs by model suffix.
    /// </summary>
    /// <param name="Value">
    /// The model suffix to filter on.
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobListParams"/> instance with the updated suffix filter.
    /// </returns>
    function Suffix(const Value: string): TFineTuningJobListParams;
  end;

  /// <summary>
  /// Represents the hyperparameters used in a fine-tuning job.
  /// </summary>
  /// <remarks>
  /// Includes settings such as the number of training steps and the learning rate.
  /// </remarks>
  THyperparametersParams = class(TJSONParam)
  public
    /// <summary>
    /// The number of training steps to perform. A training step refers to a single update of the model
    /// weights during the fine-tuning process. This update is typically calculated using a batch of
    /// samples from the training dataset.
    /// </summary>
    /// <remarks>
    /// Must be greater than or equal to 1. This property is required.
    /// </remarks>
    function TrainingSteps(const Value: Integer): THyperparametersParams;

    /// <summary>
    /// The learning rate for the fine-tuning process. It describes how much to adjust the pre-trained model's weights in response to
    /// the estimated error each time the weights are updated during the fine-tuning process.
    /// </summary>
    /// <remarks>
    /// Must be in the range [1e-8..1]. Default value: 0.0001.
    /// </remarks>
    function LearningRate(const Value: Double): THyperparametersParams;

    /// <summary>
    /// (Advanced Usage) Weight decay adds a term to the loss function that is proportional to the sum
    /// of the squared weights. This term reduces the magnitude of the weights and prevents them from
    /// growing too large.
    /// </summary>
    function WeightDecay(const Value: Double): THyperparametersParams;

    /// <summary>
    /// (Advanced Usage) A parameter that specifies the percentage of the total training steps at which
    /// the learning rate warm-up phase ends. During this phase, the learning rate gradually increases
    /// from a small value to the initial learning rate, helping to stabilize the training process and
    /// improve convergence. Similar to pct_start in mistral-finetune.
    /// </summary>
    function WarmupFraction(const Value: Double): THyperparametersParams;

    /// <summary>
    /// Set epochs value
    /// </summary>
    function Epochs(const Value: Double): THyperparametersParams;

    /// <summary>
    /// Set fim_ration value
    /// </summary>
    function FimRatio(const Value: Double): THyperparametersParams;

    /// <summary>
    /// Set seq_len value
    /// </summary>
    function SeqLen(const Value: Integer): THyperparametersParams;

    class function New(const ParamProc: TProcRef<THyperparametersParams>): THyperparametersParams;
  end;

  /// <summary>
  /// Represents the integration parameters for a fine-tuning job.
  /// </summary>
  /// <remarks>
  /// Specifies details for integrating with external platforms for monitoring fine-tuning jobs, such as Weights and Biases.
  /// </remarks>
  TJobIntegrationsParams = class(TJSONParam)
  public
    /// <summary>
    /// The type of integration.
    /// </summary>
    /// <remarks>
    /// Default: "wandb". Currently, only "wandb" (Weights and Biases) is supported. This property is required.
    /// </remarks>
    function &Type(const Value: TFineTuningIntegrationType): TJobIntegrationsParams;

    /// <summary>
    /// The name of the project under which the new run will be created.
    /// </summary>
    /// <remarks> This property is required. </remarks>
    function Project(const Value: string): TJobIntegrationsParams;

    /// <summary>
    /// A display name to set for the run. If not set, will use the job ID as the name.
    /// </summary>
    function Name(const Value: string): TJobIntegrationsParams;

    /// <summary>
    /// The WandB API key to use for authentication.
    /// </summary>
    /// <remarks> This property is required. </remarks>
    function ApiKey(const Value: string): TJobIntegrationsParams;

    /// <summary>
    /// A display run name to set for this run.
    /// </summary>
    function RunName(const Value: string): TJobIntegrationsParams;

    class function New(const ParamProc: TProcRef<TJobIntegrationsParams>): TJobIntegrationsParams;
  end;

  /// <summary>
  /// Represents the parameters required for configuring a repository in fine-tuning jobs.
  /// </summary>
  /// <remarks>
  /// This class is used to specify details about a repository, including its type, name, owner, reference,
  /// weight, and token. These parameters are typically used when setting up repositories for fine-tuning jobs.
  /// </remarks>
  TRepositoryParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the type of the repository.
    /// </summary>
    /// <param name="Value">
    /// The type of the repository as an enum value of <see cref="TRepositoryType"/>.
    /// </param>
    /// <returns>
    /// The <see cref="TRepositoryParams"/> instance with the updated repository type.
    /// </returns>
    function &Type(const Value: TRepositoryType): TRepositoryParams;

    /// <summary>
    /// Sets the name of the repository.
    /// </summary>
    /// <param name="Value">
    /// The name of the repository as a string.
    /// </param>
    /// <returns>
    /// The <see cref="TRepositoryParams"/> instance with the updated repository name.
    /// </returns>
    function Name(const Value: string): TRepositoryParams;

    /// <summary>
    /// Sets the owner of the repository.
    /// </summary>
    /// <param name="Value">
    /// The owner of the repository as a string.
    /// </param>
    /// <returns>
    /// The <see cref="TRepositoryParams"/> instance with the updated owner.
    /// </returns>
    function Owner(const Value: string): TRepositoryParams;

    /// <summary>
    /// Sets the reference for the repository.
    /// </summary>
    /// <param name="Value">
    /// The reference for the repository, such as a branch or commit hash, as a string.
    /// </param>
    /// <returns>
    /// The <see cref="TRepositoryParams"/> instance with the updated reference.
    /// </returns>
    function Ref(const Value: string): TRepositoryParams;

    /// <summary>
    /// Sets the weight for the repository.
    /// </summary>
    /// <param name="Value">
    /// The weight assigned to the repository as a double.
    /// </param>
    /// <returns>
    /// The <see cref="TRepositoryParams"/> instance with the updated weight.
    /// </returns>
    function Weight(const Value: Double): TRepositoryParams;

    /// <summary>
    /// Sets the token for accessing the repository.
    /// </summary>
    /// <param name="Value">
    /// The token for authentication as a string.
    /// </param>
    /// <returns>
    /// The <see cref="TRepositoryParams"/> instance with the updated token.
    /// </returns>
    function Token(const Value: string): TRepositoryParams;

    /// <summary>
    /// Creates a new instance of <see cref="TRepositoryParams"/> with configured parameters.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the parameters for the repository.
    /// </param>
    /// <returns>
    /// A new instance of <see cref="TRepositoryParams"/> with the specified parameters.
    /// </returns>
    class function New(const ParamProc: TProcRef<TRepositoryParams>): TRepositoryParams;
  end;

  /// <summary>
  /// Represents the parameters for creating a fine-tuning job.
  /// </summary>
  /// <remarks>
  /// Includes settings such as the model to fine-tune, training files, hyperparameters, and integrations.
  /// </remarks>
  TFineTuningJobParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the name of the model to fine-tune.
    /// </summary>
    /// <param name="Value">
    /// The name of the fine-tunable model.
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobParams"/> instance with the updated model name.
    /// </returns>
    /// <remarks> This property is required. </remarks>
    function Model(const Value: string): TFineTuningJobParams;

    /// <summary>
    /// Sets the IDs of uploaded files that contain training data.
    /// </summary>
    /// <param name="Value">
    /// An array of file IDs for training data.
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobParams"/> instance with the updated training files.
    /// </returns>
    /// <remarks> This property is required. </remarks>
    function TrainingFiles(const Value: TArray<string>): TFineTuningJobParams;

    /// <summary>
    /// Sets the IDs of uploaded files that contain validation data.
    /// </summary>
    /// <param name="Value">
    /// An array of file IDs for validation data.
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobParams"/> instance with the updated validation files.
    /// </returns>
    /// <remarks>
    /// If provided, the data is used to generate validation metrics periodically during fine-tuning.
    /// </remarks>
    function ValidationFiles(const Value: TArray<string>): TFineTuningJobParams;

    /// <summary>
    /// Sets the fine-tuning hyperparameter settings used in a fine-tune job.
    /// </summary>
    /// <param name="Value">
    /// The hyperparameters to use for fine-tuning.
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobParams"/> instance with the updated hyperparameters.
    /// </returns>
    /// <remarks> This property is required. </remarks>
    function Hyperparameters(Value: THyperparametersParams): TFineTuningJobParams; overload;

    /// <summary>
    /// Sets the fine-tuning hyperparameter settings used in a fine-tune job.
    /// </summary>
    /// <param name="Value">
    /// The hyperparameters to use for fine-tuning.
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobParams"/> instance with the updated hyperparameters.
    /// </returns>
    /// <remarks> This property is required. </remarks>
    function Hyperparameters(ParamProc: TProcRef<THyperparametersParams>): TFineTuningJobParams; overload;

    /// <summary>
    /// Sets a suffix to be added to the fine-tuned model name.
    /// <para>
    /// A string that will be added to your fine-tuning model name. For example, a suffix of
    /// "my-great-model" would produce a model name like ft:open-mistral-7b:my-great-model:xxx...
    /// </para>
    /// </summary>
    /// <param name="Value">
    /// A string less than 18 characters to be used as a suffix.
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobParams"/> instance with the updated suffix.
    /// </returns>
    function Suffix(const Value: string): TFineTuningJobParams;

    /// <summary>
    /// Sets the integrations to enable for the fine-tuning job.
    /// </summary>
    /// <param name="Value">
    /// An array of integration parameters.
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobParams"/> instance with the updated integrations.
    /// </returns>
    function Integrations(const Value: TArray<TJobIntegrationsParams>): TFineTuningJobParams; overload;

    /// <summary>
    /// Set the repositories reference .
    /// </summary>
    /// <param name="Value">
    /// An array of repository.
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobParams"/> instance with the updated integrations.
    /// </returns>
    function Repositories(const Value: TArray<TRepositoryParams>): TFineTuningJobParams;

    /// <summary>
    /// This field will be required in a future release.
    /// </summary>
    /// <param name="Value">
    /// Boolean value to manage the auto start
    /// </param>
    /// <returns>
    /// The <see cref="TFineTuningJobParams"/> instance with the updated integrations.
    /// </returns>
    function AutoStart(const Value: Boolean): TFineTuningJobParams;
  end;

  /// <summary>
  /// Represents the hyperparameters output in a fine-tuning job response.
  /// </summary>
  /// <remarks>
  /// Contains the hyperparameter settings used during fine-tuning.
  /// </remarks>
  TJobOutHyperparameters = class
  private
    [JsonNameAttribute('training_steps')]
    FTrainingSteps: Int64;
    [JsonNameAttribute('learning_rate')]
    FLearningRate: Double;
    [JsonNameAttribute('weight_decay')]
    FWeightDecay: Double;
    [JsonNameAttribute('warmup_fraction')]
    FWarmupFraction: Double;
    FEpochs: Double;
    [JsonNameAttribute('seq_len')]
    FSeqLen: Integer;
  public
    /// <summary>
    /// The number of training steps performed.
    /// </summary>
    /// <remarks>
    /// An integer value greater than or equal to 1. This value is required.
    /// </remarks>
    property TrainingSteps: Int64 read FTrainingSteps write FTrainingSteps;

    /// <summary>
    /// The learning rate used during fine-tuning.
    /// </summary>
    /// <remarks>
    /// A value in the range [1e-8 .. 1]. This value is required.
    /// </remarks>
    property LearningRate: Double read FLearningRate write FLearningRate;

    property WeightDecay: Double read FWeightDecay write FWeightDecay;

    property WarmupFraction: Double read FWarmupFraction write FWarmupFraction;

    property Epochs: Double read FEpochs write FEpochs;

    property SeqLen: Integer read FSeqLen write FSeqLen;
  end;

  /// <summary>
  /// Represents the integrations output in a fine-tuning job response.
  /// </summary>
  /// <remarks>
  /// Contains information about integrations enabled for the fine-tuning job.
  /// </remarks>
  TJobOutIntegrations = class
  private
    [JsonReflectAttribute(ctString, rtString, TFineTuningIntegrationTypeInterceptor)]
    FType: TFineTuningIntegrationType;
    FProject: string;
    FName: string;
    [JsonNameAttribute('run_name')]
    FRunName: string;
    FUrl: string;
  public
    /// <summary>
    /// The type of integration.
    /// </summary>
    /// <remarks>
    /// Default: "wandb". Currently, only "wandb" is defined.
    /// </remarks>
    property &Type: TFineTuningIntegrationType read FType write FType;

    /// <summary>
    /// The name of the project that the run was created under.
    /// </summary>
    /// <remarks> This value is required. </remarks>
    property Project: string read FProject write FProject;

    /// <summary>
    /// The display name set for the run.
    /// </summary>
    property Name: string read FName write FName;

    property RunName: string read FRunName write FRunName;

    property Url: string read FUrl write FUrl;
  end;

  /// <summary>
  /// Represents a repository used in the context of fine-tuning jobs.
  /// </summary>
  /// <remarks>
  /// This class encapsulates information about a repository, including its type, name, owner, reference, weight, and commit ID.
  /// It is used to provide detailed metadata about the repository in fine-tuning operations.
  /// </remarks>
  TRepository = class
  private
    [JsonReflectAttribute(ctString, rtString, TRepositoryTypeInterceptor)]
    FType: TRepositoryType;
    FName: string;
    FOwner: string;
    FRef: string;
    FWeight: Double;
    [JsonNameAttribute('commit_id')]
    FCommitId: string;
  public
    /// <summary>
    /// Gets or sets the type of the repository.
    /// </summary>
    /// <remarks>
    /// This property is required and determines the type of repository being used, such as "git" or "svn."
    /// </remarks>
    property &Type: TRepositoryType read FType write FType;

    /// <summary>
    /// Gets or sets the name of the repository.
    /// </summary>
    /// <remarks>
    /// This property represents the name of the repository as a string.
    /// </remarks>
    property Name: string read FName write FName;

    /// <summary>
    /// Gets or sets the owner of the repository.
    /// </summary>
    /// <remarks>
    /// This property specifies the owner of the repository, such as the username or organization name.
    /// </remarks>
    property Owner: string read FOwner write FOwner;

    /// <summary>
    /// Gets or sets the reference of the repository.
    /// </summary>
    /// <remarks>
    /// The reference can be a branch name, a tag, or a specific commit hash.
    /// </remarks>
    property Ref: string read FRef write FRef;

    /// <summary>
    /// Gets or sets the weight of the repository.
    /// </summary>
    /// <remarks>
    /// The weight is used to indicate the repository's relative importance or contribution in fine-tuning operations.
    /// </remarks>
    property Weight: Double read FWeight write FWeight;

    /// <summary>
    /// Gets or sets the commit ID of the repository.
    /// </summary>
    /// <remarks>
    /// This property specifies the exact commit used in the operation, ensuring reproducibility.
    /// </remarks>
    property CommitId: string read FCommitId write FCommitId;
  end;

  /// <summary>
  /// Represents metadata associated with data used in fine-tuning jobs.
  /// </summary>
  /// <remarks>
  /// This class provides detailed information about the cost, duration, and token usage
  /// for fine-tuning operations, offering insights into resource consumption.
  /// </remarks>
  TDataMetadata = class
  private
    [JsonNameAttribute('expected_duration_seconds')]
    FExpectedDurationSeconds: Int64;
    FCost: Double;
    [JsonNameAttribute('cost_currency')]
    FCostCurrency: string;
    [JsonNameAttribute('train_tokens_per_step')]
    FTrainTokensPerStep: Int64;
    [JsonNameAttribute('train_tokens')]
    FTrainTokens: Int64;
    [JsonNameAttribute('data_tokens')]
    FDataTokens: Int64;
    [JsonNameAttribute('estimated_start_time')]
    FEstimatedStartTime: Int64;
  public
    /// <summary>
    /// Gets or sets the expected duration of the fine-tuning job, in seconds.
    /// </summary>
    /// <remarks>
    /// This property provides an estimate of how long the job will take to complete.
    /// </remarks>
    property ExpectedDurationSeconds: Int64 read FExpectedDurationSeconds write FExpectedDurationSeconds;

    /// <summary>
    /// Gets or sets the total cost of the fine-tuning job.
    /// </summary>
    /// <remarks>
    /// This property reflects the overall monetary cost of the job.
    /// </remarks>
    property Cost: Double read FCost write FCost;

    /// <summary>
    /// Gets or sets the currency in which the cost is measured.
    /// </summary>
    /// <remarks>
    /// Examples include "USD" or "EUR."
    /// </remarks>
    property CostCurrency: string read FCostCurrency write FCostCurrency;

    /// <summary>
    /// Gets or sets the number of training tokens processed per step during fine-tuning.
    /// </summary>
    /// <remarks>
    /// This value helps analyze the efficiency of token processing in each training step.
    /// </remarks>
    property TrainTokensPerStep: Int64 read FTrainTokensPerStep write FTrainTokensPerStep;

    /// <summary>
    /// Gets or sets the total number of training tokens used in the fine-tuning process.
    /// </summary>
    /// <remarks>
    /// This property provides the cumulative count of tokens used for training the model.
    /// </remarks>
    property TrainTokens: Int64 read FTrainTokens write FTrainTokens;

    /// <summary>
    /// Gets or sets the total number of data tokens processed in the fine-tuning job.
    /// </summary>
    /// <remarks>
    /// This includes all tokens used in the training and validation datasets.
    /// </remarks>
    property DataTokens: Int64 read FDataTokens write FDataTokens;

    /// <summary>
    /// Gets or sets the estimated start time of the fine-tuning job, as a UNIX timestamp.
    /// </summary>
    /// <remarks>
    /// This property provides the predicted start time of the job for scheduling purposes.
    /// </remarks>
    property EstimatedStartTime: Int64 read FEstimatedStartTime write FEstimatedStartTime;
  end;

  TClassifierTarget = class
  private
    FName: string;
    FLabels: TArray<string>;
    FWeight: Double;
    [JsonNameAttribute('loss_function')]
    FLossFunction: string;
  public
    property Name: string read FName write FName;
    property Labels: TArray<string> read FLabels write FLabels;
    property Weight: Double read FWeight write FWeight;
    property LossFunction: string read FLossFunction write FLossFunction;
  end;

  /// <summary>
  /// Represents the output of a fine-tuning job.
  /// </summary>
  /// <remarks>
  /// Contains details about the fine-tuning job, including its status, parameters, and results.
  /// </remarks>
  TJobOut = class(TJSONFingerprint)
  private
    FId: string;
    [JsonNameAttribute('auto_start')]
    FAutoStart: Boolean;
    FHyperparameters: TJobOutHyperparameters;
    FModel: string;
    [JsonReflectAttribute(ctString, rtString, TFineTuningJobStatusInterceptor)]
    FStatus: TFineTuningJobStatus;
    [JsonNameAttribute('job_type')]
    FJobType: string;
    [JsonNameAttribute('created_at')]
    FCreatedAt: Int64;
    [JsonNameAttribute('modified_at')]
    FModifiedAt: Int64;
    [JsonNameAttribute('training_files')]
    FTrainingFiles: TArray<string>;
    [JsonNameAttribute('validation_files')]
    FValidationFiles: TArray<string>;
    [JsonReflectAttribute(ctString, rtString, TFineTuningDataObjectKindInterceptor)]
    FObject: TFineTuningDataObjectKind;
    [JsonNameAttribute('fine_Tuning_model')]
    FFineTuningModel: string;
    FSuffix: string;
    FIntegrations: TArray<TJobOutIntegrations>;
    [JsonNameAttribute('trained_tokens')]
    FTrainedTokens: Int64;
    FRepositories: TArray<TRepository>;
    FMetadata: TDataMetadata;
    [JsonNameAttribute('classifier_targets')]
    FClassifierTargets: TArray<TClassifierTarget>;
  public
    /// <summary>
    /// The ID of the job.
    /// </summary>
    /// <remarks> This value is required. </remarks>
    property Id: string read FId write FId;

    /// <summary>
    /// The auto_start of the job.
    /// </summary>
    /// <remarks> This value is required. </remarks>
    property AutoStart: Boolean read FAutoStart write FAutoStart;

    /// <summary>
    /// The hyperparameters used in the fine-tuning job.
    /// </summary>
    /// <remarks> This value is required. </remarks>
    property Hyperparameters: TJobOutHyperparameters read FHyperparameters write FHyperparameters;

    /// <summary>
    /// The name of the model that was fine-tuned.
    /// </summary>
    /// <remarks> This value is required. </remarks>
    property Model: string read FModel write FModel;

    /// <summary>
    /// The current status of the fine-tuning job.
    /// </summary>
    /// <remarks> This value is required. </remarks>
    property Status: TFineTuningJobStatus read FStatus write FStatus;

    /// <summary>
    /// The type of job (e.g., "FT" for fine-tuning).
    /// </summary>
    /// <remarks> This value is required. </remarks>
    property JobType: string read FJobType write FJobType;

    /// <summary>
    /// The UNIX timestamp (in seconds) when the fine-tuning job was created.
    /// </summary>
    /// <remarks> This value is required. </remarks>
    property CreatedAt: Int64 read FCreatedAt write FCreatedAt;

    /// <summary>
    /// The UNIX timestamp (in seconds) when the fine-tuning job was last modified.
    /// </summary>
    /// <remarks> This value is required. </remarks>
    property ModifiedAt: Int64 read FModifiedAt write FModifiedAt;

    /// <summary>
    /// A list of IDs of uploaded files that contain training data.
    /// </summary>
    /// <remarks> This value is required. </remarks>
    property TrainingFiles: TArray<string> read FTrainingFiles write FTrainingFiles;

    //// <summary>
    /// A list of IDs of uploaded files that contain validation data.
    /// </summary>
    property ValidationFiles: TArray<string> read FValidationFiles write FValidationFiles;

    /// <summary>
    /// The kind of data object. Default is "job".
    /// </summary>
    /// <remarks>
    /// Currently only "job" is defined.
    /// </remarks>
    property &Object: TFineTuningDataObjectKind read FObject write FObject;

    /// <summary>
    /// The name of the fine-tuned model that was created. The value will be null if the fine-tuning job is still running.
    /// </summary>
    property FineTuningModel: string read FFineTuningModel write FFineTuningModel;

    /// <summary>
    /// Optional text/code that adds more context for the model. When given a prompt and a suffix
    /// the model will fill what is between them. When suffix is not provided, the model will simply
    /// execute completion starting with prompt.
    /// </summary>
    property Suffix: string read FSuffix write FSuffix;

    /// <summary>
    /// A list of integrations enabled for the fine-tuning job.
    /// </summary>
    property Integrations: TArray<TJobOutIntegrations> read FIntegrations write FIntegrations;

    /// <summary>
    /// Total number of tokens trained.
    /// </summary>
    property TrainedTokens: Int64 read FTrainedTokens write FTrainedTokens;

    /// <summary>
    /// Array of repositories (e.g. repository on GitHub) max <= 20 items
    /// </summary>
    property Repositories: TArray<TRepository> read FRepositories write FRepositories;

    /// <summary>
    /// JobMetadataOut
    /// </summary>
    property Metadata: TDataMetadata read FMetadata write FMetadata;

    property ClassifierTargets: TArray<TClassifierTarget> read FClassifierTargets write FClassifierTargets;

    /// <summary>
    /// Destructor for TJobOut.
    /// </summary>
    /// <remarks>
    /// Frees associated objects.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a list of fine-tuning jobs.
  /// </summary>
  /// <remarks>
  /// Contains an array of fine-tuning job outputs.
  /// </remarks>
  TListFineTuningJobs = class(TJSONFingerprint)
  private
    FData: TArray<TJobOut>;
    [JsonReflectAttribute(ctString, rtString, TFineTuningObjectKindInterceptor)]
    FObject: TFineTuningObjectKind;
    FTotal: Int64;
  public
    /// <summary>
    /// An array of fine-tuning job outputs.
    /// </summary>
    property Data: TArray<TJobOut> read FData write FData;

    /// <summary>
    /// The kind of object. Default is "list".
    /// </summary>
    /// <remarks>
    /// Currently only "list" is defined.
    /// </remarks>
    property &Object: TFineTuningObjectKind read FObject write FObject;

    /// <summary>
    /// Count of Data
    /// </summary>
    property Total: Int64 read FTotal write FTotal;

    /// <summary>
    /// Destructor for TListFineTuningJobs.
    /// </summary>
    /// <remarks>
    /// Frees associated objects.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Status and error dot a fine-tune job.
  /// </summary>
  TJobOutEventData = class
  private
    [JsonReflectAttribute(ctString, rtString, TFineTuningJobStatusInterceptor)]
    FStatus: TFineTuningJobStatus;
    FError: string;
  public
    /// <summary>
    /// Status for a fine-tuning job
    /// </summary>
    property Status: TFineTuningJobStatus read FStatus write FStatus;

    /// <summary>
    /// Error message
    /// </summary>
    property Error: string read FError write FError;
  end;

  /// <summary>
  /// Represents an event in the fine-tuning job lifecycle.
  /// </summary>
  /// <remarks>
  /// Contains information about status changes during the job.
  /// </remarks>
  TJobOutEvent = class
  private
    FName: string;
    FData: TJobOutEventData;
    [JsonNameAttribute('created_at')]
    FCreatedAt: int64;
  public
    //// <summary>
    /// The name of the event.
    /// </summary>
    /// <remarks>
    /// This value is required.
    /// </remarks>
    property Name: string read FName write FName;

    /// <summary>
    /// The status of the fine-tuning job at the time of the event.
    /// </summary>
    /// <remarks>
    /// Enum values: "QUEUED", "STARTED", "RUNNING", "FAILED", "SUCCESS", "CANCELLED", "CANCELLATION_REQUESTED".
    /// </remarks>
    property Data: TJobOutEventData read FData write FData;

    /// <summary>
    /// The UNIX timestamp (in seconds) of the event.
    /// </summary>
    /// <remarks>
    /// This value is required.
    /// </remarks>
    property CreatedAt: int64 read FCreatedAt write FCreatedAt;

    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents metrics associated with a checkpoint during fine-tuning.
  /// </summary>
  /// <remarks>
  /// Contains loss and accuracy metrics.
  /// </remarks>
  TJobOutMetrics = class
  private
    [JsonNameAttribute('train_loss')]
    FTrainLoss: Double;
    [JsonNameAttribute('valid_loss')]
    FValidLoss: Double;
    [JsonNameAttribute('valid_mean_token_accuracy')]
    FValidMeanTokenAccuracy: Double;
  public
    /// <summary>
    /// Training data loss rate.
    /// </summary>
    property TrainLoss: Double read FTrainLoss write FTrainLoss;

    /// <summary>
    /// Validation data loss rate.
    /// </summary>
    property ValidLoss: Double read FValidLoss write FValidLoss;

    /// <summary>
    /// Mean token accuracy on the validation set.
    /// </summary>
    property ValidMeanTokenAccuracy: Double read FValidMeanTokenAccuracy write FValidMeanTokenAccuracy;
  end;

  /// <summary>
  /// Represents a checkpoint during the fine-tuning job.
  /// </summary>
  /// <remarks>
  /// Contains metrics and timing information at a specific step.
  /// </remarks>
  TJobOutCheckpoints = class
  private
    FMetrics: TJobOutMetrics;
    [JsonNameAttribute('step_number')]
    FStepNumber: Int64;
    [JsonNameAttribute('created_at')]
    FCreatedAt: Int64;
  public
    /// <summary>
    /// Metrics at the step number during the fine-tuning job.
    /// </summary>
    /// <remarks>
    /// Use these metrics to assess if the training is progressing as expected (e.g., loss should decrease).
    /// </remarks>
    property Metrics: TJobOutMetrics read FMetrics write FMetrics;

    /// <summary>
    /// The step number at which the checkpoint was created.
    /// </summary>
    property StepNumber: Int64 read FStepNumber write FStepNumber;

    /// <summary>
    /// The UNIX timestamp (in seconds) when the checkpoint was created.
    /// </summary>
    property CreatedAt: Int64 read FCreatedAt write FCreatedAt;

    /// <summary>
    /// Destructor for TJobOutCheckpoints.
    /// </summary>
    /// <remarks>
    /// Frees associated objects.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents detailed progress information for a fine-tuning job.
  /// </summary>
  /// <remarks>
  /// Extends <see cref="TJobOut"/> with events and checkpoints.
  /// </remarks>
  TJobOutProgress = class(TJobOut)
  private
    FEvents: TArray<TJobOutEvent>;
    FCheckpoints: TArray<TJobOutCheckpoints>;
  public
    /// <summary>
    /// Event items created every time the status of a fine-tuning job changes.
    /// </summary>
    /// <remarks>
    /// The timestamped list of all events is accessible here. Default value is an empty array.
    /// </remarks>
    property Events: TArray<TJobOutEvent> read FEvents write FEvents;

    /// <summary>
    /// An array with details of all intermediate checkpoints, including monitoring metrics.
    /// </summary>
    property Checkpoints: TArray<TJobOutCheckpoints> read FCheckpoints write FCheckpoints;

    /// <summary>
    /// Destructor for TJobOutProgress.
    /// </summary>
    /// <remarks>
    /// Frees associated objects.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Asynchronous callback parameters for listing fine-tuning jobs.
  /// </summary>
  TAsynListFineTuningJobs = TAsyncCallBack<TListFineTuningJobs>;

  /// <summary>
  /// Represents a promise‑based asynchronous callback that resolves to a list of fine‑tuning jobs.
  /// </summary>
  /// <remarks>
  /// This is an alias for <c>TPromiseCallback&lt;TListFineTuningJobs&gt;</c>, allowing callers to await
  /// the result of the <see cref="TFineTuningRoute.List"/> operation in a promise‑style workflow.
  /// </remarks>
  TPromiseListFineTuningJobs = TPromiseCallback<TListFineTuningJobs>;

  /// <summary>
  /// Asynchronous callback parameters for fine-tuning job output.
  /// </summary>
  TAsynJobOut = TAsyncCallBack<TJobOut>;

  /// <summary>
  /// Represents a promise‑based asynchronous callback that resolves to a fine‑tuning job output.
  /// </summary>
  /// <remarks>
  /// This is an alias for <c>TPromiseCallback&lt;TJobOut&gt;</c>, enabling callers to await
  /// the result of the <see cref="TFineTuningRoute.CreateJob"/> operation in a promise‑style workflow.
  /// </remarks>
  TPromiseJobOut = TPromiseCallback<TJobOut>;

  /// <summary>
  /// Asynchronous callback parameters for fine-tuning job progress.
  /// </summary>
  TAsynJobOutProgress = TAsyncCallBack<TJobOutProgress>;

  /// <summary>
  /// Represents a promise‑based asynchronous callback that resolves to detailed fine‑tuning job progress.
  /// </summary>
  /// <remarks>
  /// This is an alias for <c>TPromiseCallback&lt;TJobOutProgress&gt;</c>, allowing callers to await
  /// the result of the <see cref="TFineTuningRoute.Retrieve"/> (or <see cref="TFineTuningRoute.Cancel"/>)
  /// operation in a promise‑style workflow.
  /// </remarks>
  TPromiseJobOutProgress = TPromiseCallback<TJobOutProgress>;

  /// <summary>
  /// Provides methods to interact with fine-tuning jobs in the MistralAI API.
  /// </summary>
  /// <remarks>
  /// Includes synchronous and asynchronous methods for listing, creating, retrieving, and cancelling fine-tuning jobs.
  /// </remarks>
  TFineTuningRoute = class(TMistralAIAPIRoute)
    /// <summary>
    /// Asynchronously retrieves a paginated list of fine‑tuning jobs.
    /// </summary>
    /// <param name="ParamProc">
    /// A callback to configure the <see cref="TFineTuningJobListParams"/> (e.g. page, page size, filters).
    /// </param>
    /// <param name="Callbacks">
    /// An optional function that returns a promise‑style callback wrapper (<see cref="TPromiseListFineTuningJobs"/>)
    /// for handling success, error, and cancellation events.
    /// </param>
    /// <returns>
    /// A <see cref="TPromise{TListFineTuningJobs}"/> that resolves to a <see cref="TListFineTuningJobs"/> instance
    /// containing the retrieved jobs when the API call succeeds.
    /// </returns>
    function AsyncAwaitList(ParamProc: TProc<TFineTuningJobListParams>;
      const Callbacks: TFunc<TPromiseListFineTuningJobs> = nil): TPromise<TListFineTuningJobs>;

    /// <summary>
    /// Asynchronously creates and starts a new fine‑tuning job.
    /// </summary>
    /// <param name="ParamProc">
    /// A callback to configure the <see cref="TFineTuningJobParams"/>,
    /// specifying the model, training files, hyperparameters, and other settings.
    /// </param>
    /// <param name="Callbacks">
    /// An optional function that returns a promise‑style callback wrapper (<see cref="TPromiseJobOut"/>)
    /// for handling success, error, and cancellation events.
    /// </param>
    /// <returns>
    /// A <see cref="TPromise{TJobOut}"/> that resolves to a <see cref="TJobOut"/> instance
    /// containing details of the created job when the API call succeeds.
    /// </returns>
    function AsyncAwaitCreateJob(ParamProc: TProc<TFineTuningJobParams>;
      const Callbacks: TFunc<TPromiseJobOut> = nil): TPromise<TJobOut>;

    /// <summary>
    /// Asynchronously retrieves detailed progress for an existing fine‑tuning job.
    /// </summary>
    /// <param name="JobId">
    /// The identifier of the fine‑tuning job to retrieve.
    /// </param>
    /// <param name="Callbacks">
    /// An optional function that returns a promise‑style callback wrapper (<see cref="TPromiseJobOutProgress"/>)
    /// for handling success, error, and cancellation events.
    /// </param>
    /// <returns>
    /// A <see cref="TPromise{TJobOutProgress}"/> that resolves to a <see cref="TJobOutProgress"/> instance
    /// containing the job’s current status, events, and checkpoints when the API call succeeds.
    /// </returns>
    function AsyncAwaitRetrieve(const JobId: string;
      const Callbacks: TFunc<TPromiseJobOutProgress> = nil): TPromise<TJobOutProgress>;

    /// <summary>
    /// Asynchronously requests cancellation of an active fine‑tuning job.
    /// </summary>
    /// <param name="JobId">
    /// The identifier of the fine‑tuning job to cancel.
    /// </param>
    /// <param name="Callbacks">
    /// An optional function that returns a promise‑style callback wrapper (<see cref="TPromiseJobOutProgress"/>)
    /// for handling success, error, and cancellation confirmation events.
    /// </param>
    /// <returns>
    /// A <see cref="TPromise{TJobOutProgress}"/> that resolves to a <see cref="TJobOutProgress"/> instance
    /// reflecting the job’s updated status and progress events when the cancellation request completes.
    /// </returns>
    function AsyncAwaitCancel(const JobId: string;
      const Callbacks: TFunc<TPromiseJobOutProgress> = nil): TPromise<TJobOutProgress>;

    /// <summary>
    /// Asynchronously starts a preconfigured fine‑tuning job.
    /// </summary>
    /// <param name="JobId">
    /// The identifier of the fine‑tuning job to start.
    /// </param>
    /// <param name="Callbacks">
    /// An optional function that returns a promise‑style callback wrapper (<see cref="TPromiseJobOutProgress"/>)
    /// for handling success, error, and cancellation events.
    /// </param>
    /// <returns>
    /// A <see cref="TPromise{TJobOutProgress}"/> that resolves to a <see cref="TJobOutProgress"/> instance
    /// containing the job’s updated status, events, and checkpoints when the start request completes.
    /// </returns>
    function AsyncAwaitStart(const JobId: string;
      const Callbacks: TFunc<TPromiseJobOutProgress> = nil): TPromise<TJobOutProgress>;

    /// <summary>
    /// Asynchronously retrieves a list of fine-tuning jobs based on the specified parameters.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure that configures the parameters for the fine-tuning job list.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns the asynchronous callback parameters.
    /// </param>
    procedure AsyncList(ParamProc: TProc<TFineTuningJobListParams>;
      const CallBacks: TFunc<TAsynListFineTuningJobs>);

    /// <summary>
    /// Asynchronously creates and runs a new fine-tuning job.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure that configures the parameters for the fine-tuning job.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns the asynchronous callback parameters.
    /// </param>
    procedure AsyncCreateJob(ParamProc: TProc<TFineTuningJobParams>;
      const CallBacks: TFunc<TAsynJobOut>);

    /// <summary>
    /// Asynchronously retrieves detailed information about a specific fine-tuning job.
    /// </summary>
    /// <param name="Value">
    /// The ID of the job to retrieve.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns the asynchronous callback parameters.
    /// </param>
    procedure ASyncRetrieve(const JobId: string;
      const CallBacks: TFunc<TAsynJobOutProgress>);

    /// <summary>
    /// Asynchronously requests the cancellation of a fine-tuning job.
    /// </summary>
    /// <param name="Value">
    /// The ID of the job to cancel.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns the asynchronous callback parameters.
    /// </param>
    procedure AsyncCancel(const JobId: string;
      const CallBacks: TFunc<TAsynJobOutProgress>);

    /// <summary>
    /// Asynchronously start a fine-tuning job.
    /// </summary>
    /// <param name="Value">
    /// The ID of the job to cancel.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns the asynchronous callback parameters.
    /// </param>
    procedure AsyncStart(const JobId: string;
      const CallBacks: TFunc<TAsynJobOutProgress>);

    /// <summary>
    /// Retrieves a list of fine-tuning jobs based on the specified parameters.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure that configures the parameters for the fine-tuning job list.
    /// </param>
    /// <returns>
    /// A <see cref="TListFineTuningJobs"/> instance containing the list of jobs.
    /// </returns>
    function List(ParamProc: TProc<TFineTuningJobListParams>): TListFineTuningJobs;

    /// <summary>
    /// Creates and runs a new fine-tuning job.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure that configures the parameters for the fine-tuning job.
    /// </param>
    /// <returns>
    /// A <see cref="TJobOut"/> instance containing details about the created job.
    /// </returns>
    /// <remarks>
    /// The job is started immediately after creation.
    /// </remarks>
    function CreateJob(ParamProc: TProc<TFineTuningJobParams>): TJobOut;

    /// <summary>
    /// Retrieves detailed information about a specific fine-tuning job.
    /// </summary>
    /// <param name="Value">
    /// The ID of the job to retrieve.
    /// </param>
    /// <returns>
    /// A <see cref="TJobOutProgress"/> instance containing detailed progress information about the job.
    /// </returns>
    function Retrieve(const JobId: string): TJobOutProgress;

    /// <summary>
    /// Requests the cancellation of a fine-tuning job.
    /// </summary>
    /// <param name="Value">
    /// The ID of the job to cancel.
    /// </param>
    /// <returns>
    /// A <see cref="TJobOutProgress"/> instance reflecting the updated status of the job.
    /// </returns>
    function Cancel(const JobId: string): TJobOutProgress;

    /// <summary>
    /// Start a fine-tuning job.
    /// </summary>
    /// <param name="Value">
    /// The ID of the job to cancel.
    /// </param>
    /// <returns>
    /// A <see cref="TJobOutProgress"/> instance reflecting the updated status of the job.
    /// </returns>
    function Start(const JobId: string): TJobOutProgress;
  end;

implementation

uses
  System.StrUtils, Rest.Json, System.Rtti;

{ TFineTuningJobListParams }

function TFineTuningJobListParams.CreatedAfter(
  const Value: string): TFineTuningJobListParams;
begin
  Result := TFineTuningJobListParams(Add('created_after', Value));
end;

function TFineTuningJobListParams.CreatedByMe(
  const Value: Boolean): TFineTuningJobListParams;
begin
  Result := TFineTuningJobListParams(Add('created_by_me', Value));
end;

function TFineTuningJobListParams.Model(
  const Value: string): TFineTuningJobListParams;
begin
  Result := TFineTuningJobListParams(Add('model', Value));
end;

function TFineTuningJobListParams.Page(const Value: Int64): TFineTuningJobListParams;
begin
  Result := TFineTuningJobListParams(Add('page', Value));
end;

function TFineTuningJobListParams.PageSize(
  const Value: Int64): TFineTuningJobListParams;
begin
  Result := TFineTuningJobListParams(Add('page_size', Value));
end;

function TFineTuningJobListParams.Status(
  const Value: TFineTuningJobStatus): TFineTuningJobListParams;
begin
  Result := TFineTuningJobListParams(Add('status', Value.ToString));
end;

function TFineTuningJobListParams.Suffix(
  const Value: string): TFineTuningJobListParams;
begin
  Result := TFineTuningJobListParams(Add('suffix', Value));
end;

function TFineTuningJobListParams.WandbName(
  const Value: string): TFineTuningJobListParams;
begin
  Result := TFineTuningJobListParams(Add('wandb_name', Value));
end;

function TFineTuningJobListParams.WandbProject(
  const Value: string): TFineTuningJobListParams;
begin
  Result := TFineTuningJobListParams(Add('wandb_project', Value));
end;

{ TJobOut }

destructor TJobOut.Destroy;
begin
  if Assigned(FHyperparameters) then
    FHyperparameters.Free;
  for var Item in FIntegrations do
    Item.Free;
  for var Item in FRepositories do
    Item.Free;
  if Assigned(FMetadata) then
    FMetadata.Free;
  for var Item in FClassifierTargets do
    Item.Free;
  inherited;
end;

{ TFineTuningRoute }

function TFineTuningRoute.AsyncAwaitCancel(const JobId: string;
  const Callbacks: TFunc<TPromiseJobOutProgress>): TPromise<TJobOutProgress>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TJobOutProgress>(
    procedure(const CallbackParams: TFunc<TAsynJobOutProgress>)
    begin
      AsyncCancel(JobId, CallbackParams);
    end,
    Callbacks);
end;

function TFineTuningRoute.AsyncAwaitCreateJob(
  ParamProc: TProc<TFineTuningJobParams>;
  const Callbacks: TFunc<TPromiseJobOut>): TPromise<TJobOut>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TJobOut>(
    procedure(const CallbackParams: TFunc<TAsynJobOut>)
    begin
      AsyncCreateJob(ParamProc, CallbackParams);
    end,
    Callbacks);
end;

function TFineTuningRoute.AsyncAwaitList(
  ParamProc: TProc<TFineTuningJobListParams>;
  const Callbacks: TFunc<TPromiseListFineTuningJobs>): TPromise<TListFineTuningJobs>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TListFineTuningJobs>(
    procedure(const CallbackParams: TFunc<TAsynListFineTuningJobs>)
    begin
      AsyncList(ParamProc, CallbackParams);
    end,
    Callbacks);
end;

function TFineTuningRoute.AsyncAwaitRetrieve(const JobId: string;
  const Callbacks: TFunc<TPromiseJobOutProgress>): TPromise<TJobOutProgress>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TJobOutProgress>(
    procedure(const CallbackParams: TFunc<TAsynJobOutProgress>)
    begin
      AsyncRetrieve(JobId, CallbackParams);
    end,
    Callbacks);
end;

function TFineTuningRoute.AsyncAwaitStart(const JobId: string;
  const Callbacks: TFunc<TPromiseJobOutProgress>): TPromise<TJobOutProgress>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TJobOutProgress>(
    procedure(const CallbackParams: TFunc<TAsynJobOutProgress>)
    begin
      AsyncStart(JobId, CallbackParams);
    end,
    Callbacks);
end;

procedure TFineTuningRoute.AsyncCancel(const JobId: string;
  const CallBacks: TFunc<TAsynJobOutProgress>);
begin
  with TAsyncCallBackExec<TAsynJobOutProgress, TJobOutProgress>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TJobOutProgress
      begin
        Result := Cancel(JobId);
      end);
  finally
    Free;
  end;
end;

procedure TFineTuningRoute.AsyncCreateJob(
  ParamProc: TProc<TFineTuningJobParams>;
  const CallBacks: TFunc<TAsynJobOut>);
begin
  with TAsyncCallBackExec<TAsynJobOut, TJobOut>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TJobOut
      begin
        Result := Self.CreateJob(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TFineTuningRoute.AsyncList(ParamProc: TProc<TFineTuningJobListParams>;
  const CallBacks: TFunc<TAsynListFineTuningJobs>);
begin
  with TAsyncCallBackExec<TAsynListFineTuningJobs, TListFineTuningJobs>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TListFineTuningJobs
      begin
        Result := Self.List(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TFineTuningRoute.ASyncRetrieve(const JobId: string;
  const CallBacks: TFunc<TAsynJobOutProgress>);
begin
  with TAsyncCallBackExec<TAsynJobOutProgress, TJobOutProgress>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TJobOutProgress
      begin
        Result := Self.Retrieve(JobId);
      end);
  finally
    Free;
  end;
end;

procedure TFineTuningRoute.AsyncStart(const JobId: string;
  const CallBacks: TFunc<TAsynJobOutProgress>);
begin
  with TAsyncCallBackExec<TAsynJobOutProgress, TJobOutProgress>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TJobOutProgress
      begin
        Result := Self.Start(JobId);
      end);
  finally
    Free;
  end;
end;

function TFineTuningRoute.Cancel(const JobId: string): TJobOutProgress;
begin
  Result := API.PostEx<TJobOutProgress>(Format('fine_tuning/jobs/%s/cancel', [JobId]));
end;

function TFineTuningRoute.CreateJob(
  ParamProc: TProc<TFineTuningJobParams>): TJobOut;
begin
  Result := API.Post<TJobOut, TFineTuningJobParams>('fine_tuning/jobs', ParamProc);
end;

function TFineTuningRoute.List(
  ParamProc: TProc<TFineTuningJobListParams>): TListFineTuningJobs;
begin
  Result := API.Get<TListFineTuningJobs, TFineTuningJobListParams>('fine_tuning/jobs', ParamProc);
end;

function TFineTuningRoute.Retrieve(const JobId: string): TJobOutProgress;
begin
  Result := API.GetEx<TJobOutProgress>(Format('fine_tuning/jobs/%s', [JobId]));
end;

function TFineTuningRoute.Start(const JobId: string): TJobOutProgress;
begin
  Result := API.Post<TJobOutProgress>(Format('fine_tuning/jobs/%s/start', [JobId]));
end;

{ TListFineTuningJobs }

destructor TListFineTuningJobs.Destroy;
begin
  for var Item in Data do
    Item.Free;
  inherited;
end;

{ TFineTuningJobParams }

function TFineTuningJobParams.AutoStart(
  const Value: Boolean): TFineTuningJobParams;
begin
  Result := TFineTuningJobParams(Add('auto_start', Value));
end;

function TFineTuningJobParams.Hyperparameters(
  Value: THyperparametersParams): TFineTuningJobParams;
begin
  Result := TFineTuningJobParams(Add('hyperparameters', Value.Detach));
end;

function TFineTuningJobParams.Hyperparameters(
  ParamProc: TProcRef<THyperparametersParams>): TFineTuningJobParams;
begin
  if Assigned(ParamProc) then
    begin
      var Value := THyperparametersParams.Create;
      ParamProc(Value);
      Result := Hyperparameters(Value);
    end
  else Result := Self;
end;

function TFineTuningJobParams.Integrations(
  const Value: TArray<TJobIntegrationsParams>): TFineTuningJobParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TFineTuningJobParams(Add('integrations', JSONArray));
end;

function TFineTuningJobParams.Model(const Value: string): TFineTuningJobParams;
begin
  Result := TFineTuningJobParams(Add('model', Value));
end;

function TFineTuningJobParams.Repositories(
  const Value: TArray<TRepositoryParams>): TFineTuningJobParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TFineTuningJobParams(Add('repositories', JSONArray));
end;

function TFineTuningJobParams.Suffix(const Value: string): TFineTuningJobParams;
begin
  var S := Trim(Value);
  if Length(S) > 18 then
    raise Exception.CreateFmt('%s : The length of the "suffix" string cannot exceed 18 characters', [S]);
  Result := TFineTuningJobParams(Add('suffix', S));
end;

function TFineTuningJobParams.TrainingFiles(
  const Value: TArray<string>): TFineTuningJobParams;
begin
  Result := TFineTuningJobParams(Add('training_files', Value));
end;

function TFineTuningJobParams.ValidationFiles(
  const Value: TArray<string>): TFineTuningJobParams;
begin
  Result := TFineTuningJobParams(Add('validation_files', Value));
end;

{ TJobOutCheckpoints }

destructor TJobOutCheckpoints.Destroy;
begin
  if Assigned(FMetrics) then
   FMetrics.Free;
  inherited;
end;

{ TJobOutProgress }

destructor TJobOutProgress.Destroy;
begin
  for var Item in FEvents do
    Item.Free;
  for var Item in FCheckpoints do
    Item.Free;
  inherited;
end;

{ TRepositoryParams }

function TRepositoryParams.Name(const Value: string): TRepositoryParams;
begin
  Result := TRepositoryParams(Add('name', Value));
end;

class function TRepositoryParams.New(
  const ParamProc: TProcRef<TRepositoryParams>): TRepositoryParams;
begin
  Result := TRepositoryParams.Create;
  if Assigned(ParamProc) then
    begin
      ParamProc(Result);
    end;
end;

function TRepositoryParams.Owner(const Value: string): TRepositoryParams;
begin
  Result := TRepositoryParams(Add('owner', Value));
end;

function TRepositoryParams.Ref(const Value: string): TRepositoryParams;
begin
  Result := TRepositoryParams(Add('ref', Value));
end;

function TRepositoryParams.Token(const Value: string): TRepositoryParams;
begin
  Result := TRepositoryParams(Add('token', Value));
end;

function TRepositoryParams.&Type(
  const Value: TRepositoryType): TRepositoryParams;
begin
  Result := TRepositoryParams(Add('type', Value.ToString));
end;

function TRepositoryParams.Weight(const Value: Double): TRepositoryParams;
begin
  Result := TRepositoryParams(Add('weight', Value));
end;

{ THyperparametersParams }

function THyperparametersParams.Epochs(
  const Value: Double): THyperparametersParams;
begin
  Result := THyperparametersParams(Add('epochs', Value));
end;

function THyperparametersParams.FimRatio(
  const Value: Double): THyperparametersParams;
begin
  Result := THyperparametersParams(Add('fim_ratio', Value));
end;

function THyperparametersParams.LearningRate(
  const Value: Double): THyperparametersParams;
begin
  Result := THyperparametersParams(Add('learning_rate', Value));
end;

class function THyperparametersParams.New(
  const ParamProc: TProcRef<THyperparametersParams>): THyperparametersParams;
begin
  Result := THyperparametersParams.Create;
  if Assigned(ParamProc) then
    begin
      ParamProc(Result);
    end;
end;

function THyperparametersParams.SeqLen(
  const Value: Integer): THyperparametersParams;
begin
  Result := THyperparametersParams(Add('seq_len', Value));
end;

function THyperparametersParams.TrainingSteps(
  const Value: Integer): THyperparametersParams;
begin
  Result := THyperparametersParams(Add('training_steps', Value));
end;

function THyperparametersParams.WarmupFraction(
  const Value: Double): THyperparametersParams;
begin
  Result := THyperparametersParams(Add('warmup_fraction', Value));
end;

function THyperparametersParams.WeightDecay(
  const Value: Double): THyperparametersParams;
begin
  Result := THyperparametersParams(Add('weight_decay', Value));
end;

{ TJobIntegrationsParams }

function TJobIntegrationsParams.ApiKey(
  const Value: string): TJobIntegrationsParams;
begin
  Result := TJobIntegrationsParams(Add('api_key', Value));
end;

function TJobIntegrationsParams.Name(
  const Value: string): TJobIntegrationsParams;
begin
  Result := TJobIntegrationsParams(Add('name', Value));
end;

class function TJobIntegrationsParams.New(
  const ParamProc: TProcRef<TJobIntegrationsParams>): TJobIntegrationsParams;
begin
  Result := TJobIntegrationsParams.Create;
  if Assigned(ParamProc) then
    begin
      ParamProc(Result);
    end;
end;

function TJobIntegrationsParams.Project(
  const Value: string): TJobIntegrationsParams;
begin
  Result := TJobIntegrationsParams(Add('project', Value));
end;

function TJobIntegrationsParams.RunName(
  const Value: string): TJobIntegrationsParams;
begin
  Result := TJobIntegrationsParams(Add('run_name', Value));
end;

function TJobIntegrationsParams.&Type(
  const Value: TFineTuningIntegrationType): TJobIntegrationsParams;
begin
  Result := TJobIntegrationsParams(Add('type', Value.ToString));
end;

{ TJobOutEvent }

destructor TJobOutEvent.Destroy;
begin
  if Assigned(FData) then
    FData.Free;
  inherited;
end;

end.

unit MistralAI.Functions.Core;

{-------------------------------------------------------------------------------

      Github repository : https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.JSON;

type
  /// <summary>
  /// Interface defining the core structure and functionality of a function in the system.
  /// </summary>
  /// <remarks>
  /// This interface outlines the basic properties and methods that any function implementation must include.
  /// </remarks>
  IFunctionCore = interface
    ['{2D8EA8C5-1E60-481D-B95F-2EFFE2CF6A7D}']
    /// <summary>
    /// Retrieves the description of the function.
    /// </summary>
    function GetDescription: string;
    /// <summary>
    /// Retrieves the name of the function.
    /// </summary>
    function GetName: string;
    /// <summary>
    /// Retrieves the parameters required by the function, represented as a JSON schema.
    /// </summary>
    function GetParameters: string;
    /// <summary>
    /// Retrieves the strict schema adherence switch value.
    /// </summary>
    function GetStrict: Boolean;
    /// <summary>
    /// Set value to the strict schema adherence switch.
    /// </summary>
    procedure SetStrict(const Value: Boolean);
    /// <summary>
    /// Retrieves the type of the function, typically "function".
    /// </summary>
    function GetType: string;
    /// <summary>
    /// Executes the function with the provided arguments and returns the result as a string.
    /// </summary>
    /// <param name="Arguments">The arguments passed to the function in JSON format.</param>
    /// <returns>The result of the function execution as a string.</returns>
    function Execute(const Arguments: string): string;
     /// <summary>
    /// Converts the TFunctionCore instance to a JSON object that contains its type and representation.
    /// </summary>
    /// <returns>A JSON object representing the function instance.</returns>
    function ToJson: TJSONObject;
    /// <summary>
    /// Creates a string representation of the TFunctionCore instance in JSON format, including its description, name, and parameters.
    /// </summary>
    /// <returns>A string representation of the function in JSON format.</returns>
    function ToString: string;
    /// <summary>
    /// A brief description of the function's purpose, used by the model to determine when and how to call the function.
    /// </summary>
    property Description: string read GetDescription;
    /// <summary>
    /// The unique identifier of the function that will be called. It must only contain characters from a-z, A-Z, 0-9, underscores, or dashes, and should not exceed 64 characters in length.
    /// </summary>
    property Name: string read GetName;
    //// <summary>
    /// The parameters required by the function, specified as a JSON schema. If no parameters are required, use the schema: {"type": "object", "properties": {}}.
    /// </summary>
    property Parameters: string read GetParameters;
    /// <summary>
    /// The type of the tool. Currently, only "function" is supported.
    /// </summary>
    property &Type: string read GetType;
    /// <summary>
    /// Retrieves the strict schema adherence switch value.
    /// </summary>
    property &Strict: Boolean read GetStrict write SetStrict;
  end;

  /// <summary>
  /// Abstract base class for implementing core function behavior.
  /// </summary>
  /// <remarks>
  /// This class provides basic implementations for some methods and defines the structure that derived classes must follow.
  /// </remarks>
  TFunctionCore = class abstract(TinterfacedObject, IFunctionCore)
  protected
    FStrict: Boolean;
    /// <summary>
    /// Retrieves the description of the function. Derived classes must implement this method.
    /// </summary>
    function GetDescription: string; virtual; abstract;
     /// <summary>
    /// Retrieves the name of the function. Derived classes must implement this method.
    /// </summary>
    function GetName: string; virtual; abstract;
    /// <summary>
    /// Retrieves the parameters required by the function, represented as a JSON schema. Derived classes must implement this method.
    /// </summary>
    function GetParameters: string; virtual; abstract;
    /// <summary>
    /// Retrieves the strict schema adherence switch value.
    /// </summary>
    function GetStrict: Boolean;
    /// <summary>
    /// Set value to the strict schema adherence switch.
    /// </summary>
    procedure SetStrict(const Value: Boolean);
    /// <summary>
    /// Retrieves the type of the function, which is "function" by default.
    /// </summary>
    function GetType: string; virtual;
  public
    constructor Create(const IsStrict: Boolean = False);
    /// <summary>
    /// Executes the function with the provided arguments and returns the result as a string. Derived classes must implement this method.
    /// </summary>
    /// <param name="Arguments">The arguments passed to the function in JSON format.</param>
    /// <returns>The result of the function execution as a string.</returns>
    function Execute(const Arguments: string): string; virtual; abstract;
    /// <summary>
    /// Converts the TFunctionCore instance to a JSON object that contains its type and representation.
    /// </summary>
    /// <returns>A JSON object representing the function instance.</returns>
    function ToJson: TJSONObject;
    /// <summary>
    /// Creates a string representation of the TFunctionCore instance in JSON format, including its description, name, and parameters.
    /// </summary>
    /// <returns>A string representation of the function in JSON format.</returns>
    function ToString: string; override;
    /// <summary>
    /// A brief description of the function's purpose, used by the model to determine when and how to call the function.
    /// </summary>
    property Description: string read GetDescription;
    /// <summary>
    /// The unique identifier of the function that will be called. It must only contain characters from a-z, A-Z, 0-9, underscores, or dashes, and should not exceed 64 characters in length.
    /// </summary>
    property Name: string read GetName;
    /// <summary>
    /// The parameters required by the function, specified as a JSON schema. If no parameters are required, use the schema: {"type": "object", "properties": {}}.
    /// </summary>
    property Parameters: string read GetParameters;
    /// <summary>
    /// The type of the tool. Currently, only "function" is supported.
    /// </summary>
    property &Type: string read GetType;
    /// <summary>
    /// Retrieves the strict schema adherence switch value.
    /// </summary>
    property &Strict: Boolean read GetStrict write SetStrict;
  end;

implementation

{ TFunctionCore }

constructor TFunctionCore.Create(const IsStrict: Boolean);
begin
  inherited Create;
  &Strict := IsStrict;
end;

function TFunctionCore.GetStrict: Boolean;
begin
  Result := FStrict;
end;

function TFunctionCore.GetType: string;
begin
  Result := 'function';
end;

procedure TFunctionCore.SetStrict(const Value: Boolean);
begin
  FStrict := Value;
end;

function TFunctionCore.ToJson: TJSONObject;
begin
  Result := TJSONObject.Create;
  try
    Result.AddPair('type', &Type);
    Result.AddPair('function', TJSONObject.ParseJSONValue(ToString));
  except
    on E: Exception do
      begin
        Result.Free;
        raise;
      end;
  end;
end;

function TFunctionCore.ToString: string;
begin
  with TStringWriter.Create do
    try
      Write('"description": "%s",', [Description]);
      Write('"name": "%s",', [Name]);
      Write('"parameters": %s', [Parameters]);
      if &Strict then
        Write(',"strict": %s', [BoolToStr(&Strict, True).ToLower]);
      Result := Format('{%s}', [ToString]);
    finally
      Free;
    end;
end;

end.


unit MistralAI.Functions.Example;

{-------------------------------------------------------------------------------

      Github repository : https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, MistralAI.Functions.Core, MistralAI.Schema;

type
  TWeatherReportFunction = class(TFunctionCore)
  protected
    function GetDescription: string; override;
    function GetName: string; override;
    function GetParameters: string; override;
  public
    function Execute(const Arguments: string): string; override;
    class function CreateInstance(const AStrict: Boolean = false): IFunctionCore;
  end;

implementation

uses
  System.StrUtils, System.JSON;

{ TWeatherReportFunction }

class function TWeatherReportFunction.CreateInstance(const AStrict: Boolean = false): IFunctionCore;
begin
  Result := TWeatherReportFunction.create(AStrict);
end;

function TWeatherReportFunction.Execute(const Arguments: string): string;

  procedure AddToReport(const Value: TJSONObject;
    Temperature: Integer; Forecast: TArray<string>);
  begin
    Value.AddPair('temperature', TJSONNumber.Create(Temperature));
    Value.AddPair('forecast', TJSONArray.Create(Forecast[0], Forecast[1]));
  end;

begin
  Result := EmptyStr;
  var Location := EmptyStr;
  var UnitType := EmptyStr;

  {--- Parse arguments to retrieve parameters }
  var JSON := TJSONObject.ParseJSONValue(Arguments) as TJSONObject;
  try
    if Assigned(JSON) then
    try
      Location := JSON.GetValue('location', '');
      UnitType := JSON.GetValue('unit', '');
    finally
      JSON.Free;
    end;
  except
    Location := EmptyStr;
  end;

  {--- Stop the treatment if location is empty }
  if Location.IsEmpty then
    Exit;

  {--- Build the response }
  JSON := TJSONObject.Create;
  try
    JSON.AddPair('location', Location);
    JSON.AddPair('unit', UnitType);
    case IndexStr(AnsiLowerCase(Location), [
      'paris', 'paris, 75',
      'marseille', 'marseille, 13']) of
      0,1 :
        AddToReport(JSON, 17, ['rainy', 'low visibility']);

      2,3 :
        AddToReport(JSON, 29, ['sunny', 'windy']);
    end;
    Result := JSON.ToJSON;
  finally
    JSON.Free;
  end;
end; {Execute}

function TWeatherReportFunction.GetDescription: string;
begin
  Result := 'Get the current weather in a given location.';
end;

function TWeatherReportFunction.GetName: string;
begin
  Result := 'get_weather';
end;

function TWeatherReportFunction.GetParameters: string;
begin
//  Result :=
//    '{'+
//    '"type": "object",'+
//    '"properties": {'+
//         '"location": {'+
//             '"type": "string",'+
//             '"description": "The city and department, e.g. Marseille, 13"'+
//         '},'+
//         '"unit": {'+
//             '"type": "string",'+
//             '"enum": ["celsius", "fahrenheit"]'+
//         '}'+
//     '},'+
//     '"required": ["location"]'+
//  '}';

  {--- If we use the TSchemaParams class defined in the MistralAI.Schema.pas unit }
  var Schema := TSchemaParams.New(
    procedure (var Params: TSchemaParams)
    begin
      Params.&Type(TSchemaType.Object);
      Params.Properties('properties',
        procedure (var Params: TSchemaParams)
        begin
          Params.Properties('location',
            procedure (var Params: TSchemaParams)
            begin
              Params.&Type(TSchemaType.String);
              Params.Description('The city and state, e.g. San Francisco, CA');
            end);
          Params.Properties('unit',
            procedure (var Params: TSchemaParams)
            begin
              Params.&Type(TSchemaType.String);
              Params.Enum(['celsius', 'fahrenheit']);
            end);
        end);
      Params.Required(['location', 'unit']);
    end);
  Result := Schema.ToJsonString(True);
end;

end.

unit MistralAI.Functions.Tools;

{-------------------------------------------------------------------------------

      Github repository : https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, REST.Json.Types,
  MistralAI.Functions.Core, MistralAI.Types;

type
  /// <summary>
  /// Represents a tool used for interacting with chat messages, including the ability to convert
  /// functions to JSON format.
  /// </summary>
  TChatMessageTool = record
  private
    FFunction: IFunctionCore;
  public
    /// <summary>
    /// This method converts the TFunctionCore instance to a JSON object containing the type and
    /// representation of the function, and handles exceptions by deleting the JSON object and
    /// propagating the exception if an error occurs
    /// </summary>
    /// <returns>
    /// A <c>TJSONObject</c> representing the function in JSON format.
    /// </returns>
    function ToJson: TJSONObject;
    /// <summary>
    /// The function properties
    /// </summary>
    property &Function: IFunctionCore read FFunction write FFunction;
    /// <summary>
    /// Adds a function to the chat message tool.
    /// </summary>
    /// <param name="AFunction">
    /// The function to be added.
    /// </param>
    /// <returns>
    /// An instance of <c>TChatMessageTool</c> containing the specified function.
    /// </returns>
    class function Add(const AFunction: IFunctionCore): TChatMessageTool; static;
  end;

  /// <summary>
  /// Represents the specifics of a called function, including its name and calculated arguments.
  /// </summary>
  TCalledFunctionSpecifics = class
  private
    FName: string;
    FArguments: string;
  public
    /// <summary>
    /// Gets or sets the name of the called function
    /// </summary>
    property Name: string read FName write FName;
    /// <summary>
    /// Gets or sets the calculed Arguments for the called function
    /// </summary>
    property Arguments: string read FArguments write FArguments;
  end;

  /// <summary>
  /// Represents a called function, containing its specifics such as name and arguments.
  /// </summary>
  TCalledFunction = class
  private
    FId: string;
    FType: string;
    FFunction: TCalledFunctionSpecifics;
  public
    /// <summary>
    /// Gets or sets the id of the called function
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Gets or sets the type of the called function
    /// </summary>
    property &Type: string read FType write FType;
    /// <summary>
    /// Gets or sets the specifics of the called function
    /// </summary>
    property &Function: TCalledFunctionSpecifics read FFunction write FFunction;
    /// <summary>
    /// Destructor that ensures proper memory management by freeing the <c>FFunction</c> property
    /// when the <c>TCalledFunction</c> instance is destroyed.
    /// </summary>
    destructor Destroy; override;
  end;

implementation

{ TChatMessageTool }

class function TChatMessageTool.Add(
  const AFunction: IFunctionCore): TChatMessageTool;
begin
  Result.&Function := AFunction;
end;

function TChatMessageTool.ToJson: TJSONObject;
begin
  Result := FFunction.ToJson;
end;

{ TCalledFunction }

destructor TCalledFunction.Destroy;
begin
  if Assigned(FFunction) then
    FFunction.Free;
  inherited;
end;

end.

unit MistralAI.HttpClientAPI;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Net.HttpClient, System.Net.URLClient,
  System.Net.Mime, System.JSON, System.NetConsts,
  MistralAI.API.Params, MistralAI.HttpClientInterface;

type
  /// <summary>
  /// Provides an implementation of the <c>IHttpClientAPI</c> interface using Delphi's <c>THTTPClient</c>.
  /// </summary>
  /// <remarks>
  /// This class facilitates making HTTP requests such as GET, POST, DELETE, and PATCH
  /// by wrapping Delphi's <c>THTTPClient</c> and adhering to the <c>IHttpClientAPI</c> interface.
  /// It supports setting timeouts, proxy configurations, and handling response callbacks.
  /// </remarks>
  THttpClientAPI = class(TInterfacedObject, IHttpClientAPI)
  private
    FHttpClient: THttpClient;
    FCheckSettingsProc: TProc;
    procedure SetSendTimeOut(const Value: Integer);
    function GetSendTimeOut: Integer;
    function GetConnectionTimeout: Integer;
    procedure SetConnectionTimeout(const Value: Integer);
    function GetResponseTimeout: Integer;
    procedure SetResponseTimeout(const Value: Integer);
    function GetProxySettings: TProxySettings;
    procedure SetProxySettings(const Value: TProxySettings);
    procedure CheckAPISettings; virtual;
  public
    /// <summary>
    /// Sends an HTTP GET request to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the GET request to.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Get(const URL: string; Response: TStringStream; const Headers: TNetHeaders): Integer; overload;

    /// <summary>
    /// Sends an HTTP GET request to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the GET request to.
    /// </param>
    /// <param name="Response">
    /// A stream to capture the binary response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Get(const URL: string; const Response: TStream; const Headers: TNetHeaders): Integer; overload;

    /// <summary>
    /// Sends an HTTP DELETE request to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the DELETE request to.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Delete(const URL: string; Response: TStringStream; const Headers: TNetHeaders): Integer; overload;

    /// <summary>
    /// Sends an HTTP DELETE request with a JSON body to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to which the DELETE request is sent.
    /// </param>
    /// <param name="Body">
    /// A <c>TJSONObject</c> representing the JSON payload to include in the DELETE request body.
    /// </param>
    /// <param name="Response">
    /// A <c>TStringStream</c> instance used to capture the server's response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers (<c>TNetHeaders</c>) to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server in response to the request.
    /// </returns>
    /// <remarks>
    /// This overload is useful when the DELETE request requires additional data
    /// in the body, such as filter criteria or resource identifiers.
    /// The JSON body is automatically serialized from the provided <c>TJSONObject</c>.
    /// </remarks>
    function Delete(const URL: string; Body: TJSONObject; Response: TStringStream; const Headers: TNetHeaders): Integer; overload;

    /// <summary>
    /// Sends an HTTP POST request to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the POST request to.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Post(const URL: string; Response: TStringStream; const Headers: TNetHeaders): Integer; overload;

    /// <summary>
    /// Sends an HTTP POST request with multipart form data to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the POST request to.
    /// </param>
    /// <param name="Body">
    /// The multipart form data to include in the POST request.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Post(const URL: string; Body: TMultipartFormData; Response: TStringStream; const Headers: TNetHeaders): Integer; overload;

    /// <summary>
    /// Sends an HTTP POST request with a JSON body to the specified URL and handles streamed responses.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the POST request to.
    /// </param>
    /// <param name="Body">
    /// The JSON object to include in the POST request body.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <param name="OnReceiveData">
    /// A callback procedure to handle data as it is received during the streaming process.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Post(const URL: string; Body: TJSONObject; Response: TStringStream; const Headers: TNetHeaders; OnReceiveData: TReceiveDataCallback): Integer; overload;

    /// <summary>
    /// Sends an HTTP POST request with a JSON body to the specified URL and handles a full streamed responses.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the POST request to.
    /// </param>
    /// <param name="Body">
    /// The JSON object to include in the POST request body.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <param name="OnReceiveData">
    /// A callback procedure to handle data as it is received during the streaming process.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Post(const URL: string; Body: TJSONObject; Response: TStream; const Headers: TNetHeaders; OnReceiveData: TReceiveDataCallback): Integer; overload;

    /// <summary>
    /// Sends an HTTP PATCH request with a JSON body to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the PATCH request to.
    /// </param>
    /// <param name="Body">
    /// The JSON object to include in the PATCH request body.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Patch(const URL: string; Body: TJSONObject; Response: TStringStream; const Headers: TNetHeaders): Integer; overload;

    /// <summary>
    /// Sends an HTTP PUT request with a JSON body to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the PUT request to.
    /// </param>
    /// <param name="Body">
    /// The JSON object to include in the PUT request body. It will be encoded as UTF‑8.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Put(const URL: string; Body: TJSONObject; Response: TStringStream; const Headers: TNetHeaders): Integer;

    /// <summary>
    /// Initializes a new instance of the <c>THttpClientAPI</c> class.
    /// </summary>
    /// <param name="CheckProc">
    /// A callback procedure to verify API settings before each request.
    /// </param>
    constructor Create(const CheckProc: TProc);

   /// <summary>
    /// Creates and returns an instance of <c>IHttpClientAPI</c>.
    /// </summary>
    /// <param name="CheckProc">
    /// A callback procedure to verify API settings before each request.
    /// </param>
    /// <returns>
    /// An instance implementing the <c>IHttpClientAPI</c> interface.
    /// </returns>
    class function CreateInstance(const CheckProc: TProc): IHttpClientAPI;

    destructor Destroy; override;
  end;

implementation

{ THttpClientAPI }

procedure THttpClientAPI.CheckAPISettings;
begin
  if Assigned(FCheckSettingsProc) then
    FCheckSettingsProc;
end;

constructor THttpClientAPI.Create(const CheckProc: TProc);
begin
  inherited Create;
  FHttpClient := THTTPClient.Create;
  FHttpClient.AcceptCharSet := 'utf-8';
  FCheckSettingsProc := CheckProc;
end;

class function THttpClientAPI.CreateInstance(
  const CheckProc: TProc): IHttpClientAPI;
begin
  Result := THttpClientAPI.Create(CheckProc);
end;

function THttpClientAPI.Delete(const URL: string;
  Response: TStringStream; const Headers: TNetHeaders): Integer;
begin
  CheckAPISettings;
  Result := FHttpClient.Delete(URL, Response, Headers).StatusCode;
end;

function THttpClientAPI.Delete(const URL: string; Body: TJSONObject;
  Response: TStringStream; const Headers: TNetHeaders): Integer;
begin
  CheckAPISettings;
  var Stream := TStringStream.Create;
  try
    Stream.WriteString(Body.ToJSON);
    Stream.Position := 0;
    Result := FHttpClient.Delete(URL, Stream, Response, Headers).StatusCode;
  finally
    Stream.Free;
  end;
end;

destructor THttpClientAPI.Destroy;
begin
  FHttpClient.Free;
  inherited;
end;

function THttpClientAPI.Get(const URL: string; const Response: TStream;
  const Headers: TNetHeaders): Integer;
begin
  CheckAPISettings;
  Result := FHttpClient.Get(URL, Response, Headers).StatusCode;
end;

function THttpClientAPI.GetConnectionTimeout: Integer;
begin
  Result := FHttpClient.ConnectionTimeout;
end;

function THttpClientAPI.GetProxySettings: TProxySettings;
begin
  Result := FHttpClient.ProxySettings;
end;

function THttpClientAPI.GetResponseTimeout: Integer;
begin
  Result := FHttpClient.ResponseTimeout;
end;

function THttpClientAPI.GetSendTimeOut: Integer;
begin
  Result := FHttpClient.SendTimeout;
end;

function THttpClientAPI.Get(const URL: string;
  Response: TStringStream; const Headers: TNetHeaders): Integer;
begin
  CheckAPISettings;
  Result := FHttpClient.Get(URL, Response, Headers).StatusCode;
end;

function THttpClientAPI.Patch(const URL: string; Body: TJSONObject;
  Response: TStringStream; const Headers: TNetHeaders): Integer;
begin
  CheckAPISettings;
  var Stream := TStringStream.Create;
  try
    if Assigned(Body) then
      begin
        Stream.WriteString(Body.ToJSON);
        Stream.Position := 0;
      end;
    Result := FHttpClient.Patch(URL, Stream, Response, Headers).StatusCode;
  finally
    Stream.Free;
  end;
end;

function THttpClientAPI.Post(const URL: string; Body: TJSONObject;
  Response: TStringStream; const Headers: TNetHeaders;
  OnReceiveData: TReceiveDataCallback): Integer;
begin
  CheckAPISettings;
  var Stream := TStringStream.Create;
  FHttpClient.ReceiveDataCallBack := OnReceiveData;
  try
    Stream.WriteString(Body.ToJSON);
    Stream.Position := 0;
    Result := FHttpClient.Post(URL, Stream, Response, Headers).StatusCode;
  finally
    FHttpClient.ReceiveDataCallBack := nil;
    Stream.Free;
  end;
end;

procedure THttpClientAPI.SetConnectionTimeout(const Value: Integer);
begin
  FHttpClient.ConnectionTimeout := Value;
end;

procedure THttpClientAPI.SetProxySettings(const Value: TProxySettings);
begin
  FHttpClient.ProxySettings := Value;
end;

procedure THttpClientAPI.SetResponseTimeout(const Value: Integer);
begin
  FHttpClient.ResponseTimeout := Value;
end;

procedure THttpClientAPI.SetSendTimeOut(const Value: Integer);
begin
  FHttpClient.SendTimeout := Value;
end;

function THttpClientAPI.Post(const URL: string; Body: TMultipartFormData;
  Response: TStringStream; const Headers: TNetHeaders): Integer;
begin
  CheckAPISettings;
  Result := FHttpClient.Post(URL, Body, Response, Headers).StatusCode;
end;

function THttpClientAPI.Post(const URL: string; Response: TStringStream;
  const Headers: TNetHeaders): Integer;
begin
  CheckAPISettings;
  var Stream: TStringStream := nil;
  Result := FHttpClient.Post(URL, Stream, Response, Headers).StatusCode;
end;

function THttpClientAPI.Post(const URL: string; Body: TJSONObject;
  Response: TStream; const Headers: TNetHeaders;
  OnReceiveData: TReceiveDataCallback): Integer;
begin
  CheckAPISettings;

  {--- Query always encoded in explicit UTF-8 }
  var Bytes := TEncoding.UTF8.GetBytes(Body.ToJSON);
  var Req := TMemoryStream.Create;
  Req.WriteBuffer(Bytes, Length(Bytes));
  Req.Position := 0;

  FHttpClient.ReceiveDataCallback := OnReceiveData;
  try
    Result := FHttpClient.Post(URL, Req, Response, Headers).StatusCode;
  finally
    FHttpClient.ReceiveDataCallback := nil;
    Req.Free;
  end;
end;

function THttpClientAPI.Put(const URL: string; Body: TJSONObject;
  Response: TStringStream; const Headers: TNetHeaders): Integer;
begin
  CheckAPISettings;

  {--- Query always encoded in explicit UTF-8 }
  var Bytes := TEncoding.UTF8.GetBytes(Body.ToJSON);
  var Req := TMemoryStream.Create;
  Req.WriteBuffer(Bytes, Length(Bytes));
  Req.Position := 0;

  try
    Result := FHttpClient.Put(URL, Req, Response, Headers).StatusCode;
  finally
    Req.Free;
  end;
end;

end.

unit MistralAI.HttpClientInterface;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Net.HttpClient, System.Net.URLClient,
  System.JSON, System.Net.Mime;

type
  /// <summary>
  /// Interface for configuring HTTP client parameters such as timeouts and proxy settings.
  /// </summary>
  /// <remarks>
  /// This interface provides properties and methods to set and retrieve various HTTP client configurations,
  /// including send timeout, connection timeout, response timeout, and proxy settings.
  /// Implementers of this interface should ensure that these configurations are appropriately applied
  /// to the underlying HTTP client used for making web requests.
  /// </remarks>
  IHttpClientParam = interface
    ['{BCF51E39-B8CF-4706-90CC-FC93D07230BD}']
    /// <summary>
    /// Sets the send timeout for HTTP requests.
    /// </summary>
    /// <param name="Value">
    /// The timeout duration in milliseconds.
    /// </param>
    procedure SetSendTimeOut(const Value: Integer);

    /// <summary>
    /// Retrieves the send timeout value.
    /// </summary>
    /// <returns>
    /// The send timeout duration in milliseconds.
    /// </returns>
    function GetSendTimeOut: Integer;

    /// <summary>
    /// Retrieves the connection timeout value.
    /// </summary>
    /// <returns>
    /// The connection timeout duration in milliseconds.
    /// </returns>
    function GetConnectionTimeout: Integer;

    /// <summary>
    /// Sets the connection timeout for HTTP requests.
    /// </summary>
    /// <param name="Value">
    /// The timeout duration in milliseconds.
    /// </param>
    procedure SetConnectionTimeout(const Value: Integer);

    /// <summary>
    /// Retrieves the response timeout value.
    /// </summary>
    /// <returns>
    /// The response timeout duration in milliseconds.
    /// </returns>
    function GetResponseTimeout: Integer;

    /// <summary>
    /// Sets the response timeout for HTTP requests.
    /// </summary>
    /// <param name="Value">
    /// The timeout duration in milliseconds.
    /// </param>
    procedure SetResponseTimeout(const Value: Integer);

    /// <summary>
    /// Retrieves the current proxy settings.
    /// </summary>
    /// <returns>
    /// An instance of <c>TProxySettings</c> representing the proxy configuration.
    /// </returns>
    function GetProxySettings: TProxySettings;

    /// <summary>
    /// Sets the proxy settings for HTTP requests.
    /// </summary>
    /// <param name="Value">
    /// An instance of <c>TProxySettings</c> representing the desired proxy configuration.
    /// </param>
    procedure SetProxySettings(const Value: TProxySettings);

    /// <summary>
    /// The send timeout duration in milliseconds.
    /// </summary>
    /// <remarks>
    /// Defines how long the HTTP client will wait while sending a request before timing out.
    /// </remarks>
    property SendTimeOut: Integer read GetSendTimeOut write SetSendTimeOut;

    /// <summary>
    /// The connection timeout duration in milliseconds.
    /// </summary>
    /// <remarks>
    /// Defines how long the HTTP client will wait while establishing a connection before timing out.
    /// </remarks>
    property ConnectionTimeout: Integer read GetConnectionTimeout write SetConnectionTimeout;

    /// <summary>
    /// The response timeout duration in milliseconds.
    /// </summary>
    /// <remarks>
    /// Defines how long the HTTP client will wait for a response after a request has been sent before timing out.
    /// </remarks>
    property ResponseTimeout: Integer read GetResponseTimeout write SetResponseTimeout;

    /// <summary>
    /// The proxy settings for HTTP requests.
    /// </summary>
    /// <remarks>
    /// Configures the HTTP client to route requests through a specified proxy server.
    /// This is useful in environments where direct internet access is restricted.
    /// </remarks>
    property ProxySettings: TProxySettings read GetProxySettings write SetProxySettings;
  end;

  /// <summary>
  /// Interface for performing HTTP operations such as GET, POST, DELETE, and PATCH.
  /// </summary>
  /// <remarks>
  /// Extends <c>IHttpClientParam</c> to include methods for executing various HTTP requests,
  /// allowing for flexible and configurable API interactions.
  /// Implementers should provide concrete implementations for these methods to handle
  /// the specifics of making HTTP requests and processing responses.
  /// </remarks>
  IHttpClientAPI = interface(IHttpClientParam)
    ['{CEE0EB49-85AA-42EB-B147-0E3C3C09EA6D}']
    /// <summary>
    /// Sends an HTTP GET request to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the GET request to.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Get(const URL: string; Response: TStringStream; const Headers: TNetHeaders): Integer; overload;

    /// <summary>
    /// Sends an HTTP GET request to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the GET request to.
    /// </param>
    /// <param name="Response">
    /// A stream to capture the binary response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Get(const URL: string; const Response: TStream; const Headers: TNetHeaders): Integer; overload;

    /// <summary>
    /// Sends an HTTP DELETE request to the specified URL.
    /// </summary>
    /// <param name="Path">
    /// The endpoint URL to send the DELETE request to.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Delete(const Path: string; Response: TStringStream; const Headers: TNetHeaders): Integer; overload;

    /// <summary>
    /// Sends an HTTP DELETE request with a JSON body to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to which the DELETE request is sent.
    /// </param>
    /// <param name="Body">
    /// A <c>TJSONObject</c> representing the JSON payload to include in the DELETE request body.
    /// </param>
    /// <param name="Response">
    /// A <c>TStringStream</c> instance used to capture the server's response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers (<c>TNetHeaders</c>) to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server in response to the request.
    /// </returns>
    /// <remarks>
    /// This overload is useful when the DELETE request requires additional data
    /// in the body, such as filter criteria or resource identifiers.
    /// The JSON body is automatically serialized from the provided <c>TJSONObject</c>.
    /// </remarks>
    function Delete(const URL: string; Body: TJSONObject; Response: TStringStream; const Headers: TNetHeaders): Integer; overload;

    /// <summary>
    /// Sends an HTTP POST request to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the POST request to.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Post(const URL: string; Response: TStringStream; const Headers: TNetHeaders): Integer; overload;

    /// <summary>
    /// Sends an HTTP POST request with multipart form data to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the POST request to.
    /// </param>
    /// <param name="Body">
    /// The multipart form data to include in the POST request.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Post(const URL: string; Body: TMultipartFormData; Response: TStringStream; const Headers: TNetHeaders): Integer; overload;

    /// <summary>
    /// Sends an HTTP POST request with a JSON body to the specified URL and handles streamed responses.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the POST request to.
    /// </param>
    /// <param name="Body">
    /// The JSON object to include in the POST request body.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <param name="OnReceiveData">
    /// A callback procedure to handle data as it is received during the streaming process.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Post(const URL: string; Body: TJSONObject; Response: TStringStream; const Headers: TNetHeaders; OnReceiveData: TReceiveDataCallback): Integer; overload;

    /// <summary>
    /// Sends an HTTP POST request with a JSON body to the specified URL and handles full streamed responses.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the POST request to.
    /// </param>
    /// <param name="Body">
    /// The JSON object to include in the POST request body.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <param name="OnReceiveData">
    /// A callback procedure to handle data as it is received during the streaming process.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Post(const URL: string; Body: TJSONObject; Response: TStream; const Headers: TNetHeaders; OnReceiveData: TReceiveDataCallback): Integer; overload;

    /// <summary>
    /// Sends an HTTP PATCH request with a JSON body to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the PATCH request to.
    /// </param>
    /// <param name="Body">
    /// The JSON object to include in the PATCH request body.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Patch(const URL: string; Body: TJSONObject; Response: TStringStream; const Headers: TNetHeaders): Integer;

    /// <summary>
    /// Sends an HTTP PUT request with a JSON body to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the PUT request to.
    /// </param>
    /// <param name="Body">
    /// The JSON object to include in the PUT request body. It will be encoded as UTF‑8.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Put(const URL: string; Body: TJSONObject; Response: TStringStream; const Headers: TNetHeaders): Integer;
  end;

implementation

end.

unit MistralAI.Httpx;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  Winapi.Windows, Winapi.ShellAPI, System.SysUtils, System.Classes, System.Net.URLClient,
  System.Net.HttpClient, System.Net.HttpClientComponent, System.NetEncoding;

type
  /// <summary>
  /// THttpx provides utility methods for handling HTTP-related tasks such as
  /// downloading data, encoding it in Base64, and retrieving MIME types.
  /// </summary>
  THttpx = class
    /// <summary>
    /// Extracts the file name from the specified URI, omitting any query string.
    /// </summary>
    /// <param name="URI">
    /// The full URI (optionally containing a '?' query portion) from which to extract the file name.
    /// </param>
    /// <returns>
    /// The substring after the last '/' in the URI, without any query parameters.
    /// </returns>
    class function GetFileNameFromURI(const URI: string): string;

    /// <summary>
    /// Launches the specified file or application using the default system handler.
    /// </summary>
    /// <param name="FilePath">
    /// The full path of the file or executable to open.
    /// </param>
    /// <exception cref="EOSError">
    /// Raised if the ShellExecute call fails (i.e. returns a value ≤ 32).
    /// </exception>
    class procedure Open(const FilePath: string);

    /// <summary>
    /// Downloads the file at the specified signed URL into the current directory,
    /// using the file name derived from the URI, and optionally opens it.
    /// </summary>
    /// <param name="Uri">
    /// The signed URL pointing to the file to download.
    /// </param>
    /// <param name="Open">
    /// If <c>True</c>, automatically open the downloaded file after the download completes;
    /// otherwise leave it saved only to disk. Defaults to <c>False</c>.
    /// </param>
    /// <exception cref="ENetHTTPClientException">
    /// Raised if the HTTP download fails.
    /// </exception>
    /// <exception cref="EOSError">
    /// Raised if opening the file fails (ShellExecute returns ≤ 32).
    /// </exception>
    class procedure DownloadFromSignedUrl(const Uri: string; const Open: Boolean = False); overload;

    /// <summary>
    /// Downloads the file from the specified signed URL into the given directory,
    /// using the file name derived from the URI, and optionally opens it.
    /// </summary>
    /// <param name="Uri">
    /// The signed URL pointing to the file to download.
    /// </param>
    /// <param name="Path">
    /// The target directory in which to save the file. If empty, the current directory is used.
    /// </param>
    /// <param name="Open">
    /// If <c>True</c>, automatically open the downloaded file after saving;
    /// otherwise leave it saved only to disk. Defaults to <c>False</c>.
    /// </param>
    /// <exception cref="ENetHTTPClientException">
    /// Raised if the HTTP download fails.
    /// </exception>
    /// <exception cref="EOSError">
    /// Raised if opening the file fails (ShellExecute returns ≤ 32).
    /// </exception>
    class procedure DownloadFromSignedUrl(const Uri: string; const Path: string; const Open: Boolean = False); overload;
  end;

implementation

{ THttpx }

class procedure THttpx.DownloadFromSignedUrl(const Uri: string;
  const Path: string;
  const Open: Boolean);
var
  HttpClient: THTTPClient;
  FileStream: TFileStream;
  FilePath: string;
begin
  FilePath := GetFileNameFromURI(Uri);
  if not Path.IsEmpty then
    FilePath := Format('%s\%s', [Path, FilePath]);

  HttpClient := THTTPClient.Create;
  try
    FileStream := TFileStream.Create(FilePath, fmCreate);
    try
      HttpClient.Get(URI, FileStream);
      if Open then
        THttpx.Open(FilePath);
    finally
      FileStream.Free;
    end;
  finally
    HttpClient.Free;
  end;
end;

class procedure THttpx.DownloadFromSignedUrl(const Uri: string;
  const Open: Boolean);
begin
  DownloadFromSignedUrl(Uri, '', Open);
end;

class function THttpx.GetFileNameFromURI(const URI: string): string;
begin
  var CleanURI := URI.Split(['?'])[0];
  Result := Copy(CleanURI, LastDelimiter('/', CleanURI) + 1, MaxInt);
end;

class procedure THttpx.Open(const FilePath: string);
var
  Ret: HINST;
begin
  Ret := ShellExecuteW(0, nil, PWideChar(FilePath), nil, nil, SW_SHOWNORMAL);
  if Ret <= 32 then
    RaiseLastOSError;
end;

end.

unit MistralAI.Libraries.Access;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Threading, System.JSON,
  REST.Json.Types, REST.JsonReflect,
  MistralAI.Types, MistralAI.API, MistralAI.API.Params,
  MistralAI.Async.Params, MistralAI.Async.Support, MistralAI.Async.Promise;

type
  /// <summary>
  /// Represents the parameters required to create or update access levels for a library.
  /// </summary>
  /// <remarks>
  /// The <c>TAccessParams</c> class is used to build the request payload when assigning or modifying
  /// access levels to a specific entity (user, workspace, or organization) for a library.
  /// It provides fluent methods for configuring organization ID, access level, and the target entity.
  /// </remarks>
  TAccessParams = class(TJSONParam)
    /// <summary>
    /// Sets the organization ID associated with the library.
    /// </summary>
    /// <param name="Value">
    /// The unique identifier (<c>UUID</c>) of the organization.
    /// </param>
    /// <returns>
    /// The current <c>TAccessParams</c> instance for fluent chaining.
    /// </returns>
    function OrgId(const Value: string): TAccessParams;

    /// <summary>
    /// Sets the access level for the entity using a <c>TLevelType</c> value.
    /// </summary>
    /// <param name="Value">
    /// A <c>TLevelType</c> enumeration value indicating the level of access (e.g., Viewer or Editor).
    /// </param>
    /// <returns>
    /// The current <c>TAccessParams</c> instance for fluent chaining.
    /// </returns>
    function Level(const Value: TLevelType): TAccessParams; overload;

    /// <summary>
    /// Sets the access level for the entity using a string value.
    /// </summary>
    /// <param name="Value">
    /// A string representing the level of access (e.g., "Viewer" or "Editor").
    /// </param>
    /// <returns>
    /// The current <c>TAccessParams</c> instance for fluent chaining.
    /// </returns>
    function Level(const Value: string): TAccessParams; overload;

    /// <summary>
    /// Sets the unique identifier (<c>UUID</c>) of the entity to share the library with.
    /// </summary>
    /// <param name="Value">
    /// The entity's unique ID (<c>UUID</c>), such as a user ID, workspace ID, or organization ID.
    /// </param>
    /// <returns>
    /// The current <c>TAccessParams</c> instance for fluent chaining.
    /// </returns>
    function ShareWithUuid(const Value: string): TAccessParams;

    /// <summary>
    /// Sets the type of the entity to share the library with using a <c>TShareWithType</c> value.
    /// </summary>
    /// <param name="Value">
    /// A <c>TShareWithType</c> enumeration value indicating the target entity type (User, Workspace, or Org).
    /// </param>
    /// <returns>
    /// The current <c>TAccessParams</c> instance for fluent chaining.
    /// </returns>
    function ShareWithType(const Value: TShareWithType): TAccessParams; overload;

    /// <summary>
    /// Sets the type of the entity to share the library with using a string value.
    /// </summary>
    /// <param name="Value">
    /// A string representing the entity type (e.g., "User", "Workspace", or "Org").
    /// </param>
    /// <returns>
    /// The current <c>TAccessParams</c> instance for fluent chaining.
    /// </returns>
    function ShareWithType(const Value: string): TAccessParams; overload;
  end;

  /// <summary>
  /// Represents the parameters required to delete access levels for a library.
  /// </summary>
  /// <remarks>
  /// The <c>TAccessDeleteParams</c> class is used to build the request payload when
  /// revoking access rights for a specific entity (user, workspace, or organization)
  /// associated with a library.
  /// </remarks>
  TAccessDeleteParams = class(TJSONParam)
    /// <summary>
    /// Sets the organization ID associated with the library.
    /// </summary>
    /// <param name="Value">
    /// The unique identifier (<c>UUID</c>) of the organization.
    /// </param>
    /// <returns>
    /// The current <c>TAccessDeleteParams</c> instance for fluent chaining.
    /// </returns>
    function OrgId(const Value: string): TAccessDeleteParams;

    /// <summary>
    /// Sets the unique identifier (<c>UUID</c>) of the entity whose access will be revoked.
    /// </summary>
    /// <param name="Value">
    /// The entity's unique ID (<c>UUID</c>), such as a user ID, workspace ID, or organization ID.
    /// </param>
    /// <returns>
    /// The current <c>TAccessDeleteParams</c> instance for fluent chaining.
    /// </returns>
    function ShareWithUuid(const Value: string): TAccessDeleteParams;

    /// <summary>
    /// Sets the type of the entity whose access will be revoked using a <c>TShareWithType</c> value.
    /// </summary>
    /// <param name="Value">
    /// A <c>TShareWithType</c> enumeration value indicating the target entity type (User, Workspace, or Org).
    /// </param>
    /// <returns>
    /// The current <c>TAccessDeleteParams</c> instance for fluent chaining.
    /// </returns>
    function ShareWithType(const Value: TShareWithType): TAccessDeleteParams; overload;

    /// <summary>
    /// Sets the type of the entity whose access will be revoked using a string value.
    /// </summary>
    /// <param name="Value">
    /// A string representing the entity type (e.g., "User", "Workspace", or "Org").
    /// </param>
    /// <returns>
    /// The current <c>TAccessDeleteParams</c> instance for fluent chaining.
    /// </returns>
    function ShareWithType(const Value: string): TAccessDeleteParams; overload;
  end;

  /// <summary>
  /// Represents the access rights of an entity (user, workspace, or organization) to a specific library.
  /// </summary>
  /// <remarks>
  /// The <c>TLibrariesAccess</c> class models the response object for library access queries or updates.
  /// It contains information about the library, the organization, the entity with which it is shared,
  /// and the access role granted.
  /// </remarks>
  TLibrariesAccess = class(TJSONFingerprint)
  private
    [JsonNameAttribute('library_id')]
    FLibraryId: string;
    [JsonNameAttribute('user_id')]
    FUserId: string;
    [JsonNameAttribute('org_id')]
    FOrgId: string;
    FRole: string;
    [JsonNameAttribute('share_with_type')]
    [JsonReflectAttribute(ctString, rtString, TShareWithTypeInterceptor)]
    FShareWithType: TShareWithType;
    [JsonNameAttribute('share_with_uuid')]
    FShareWithUuid: string;
  public
    /// <summary>
    /// Gets or sets the unique identifier (<c>UUID</c>) of the library.
    /// </summary>
    /// <value>
    /// A string representing the library ID.
    /// </value>
    property LibraryId: string read FLibraryId write FLibraryId;

    /// <summary>
    /// Gets or sets the user ID associated with the access, if applicable.
    /// </summary>
    /// <value>
    /// A string representing the user ID, or <c>nil</c> if the access is not user-specific.
    /// </value>
    property UserId: string read FUserId write FUserId;

    /// <summary>
    /// Gets or sets the organization ID associated with the access.
    /// </summary>
    /// <value>
    /// A string representing the organization ID (<c>UUID</c>).
    /// </value>
    property OrgId: string read FOrgId write FOrgId;

    /// <summary>
    /// Gets or sets the role assigned to the entity.
    /// </summary>
    /// <value>
    /// A string describing the access role (e.g., "Viewer" or "Editor").
    /// </value>
    property Role: string read FRole write FRole;

    /// <summary>
    /// Gets or sets the type of the entity that has access to the library.
    /// </summary>
    /// <value>
    /// A <c>TShareWithType</c> enumeration value indicating the entity type (User, Workspace, or Org).
    /// </value>
    property ShareWithType: TShareWithType read FShareWithType write FShareWithType;

    /// <summary>
    /// Gets or sets the unique identifier (<c>UUID</c>) of the entity with access.
    /// </summary>
    /// <value>
    /// A string representing the entity ID (<c>UUID</c>).
    /// </value>
    property ShareWithUuid: string read FShareWithUuid write FShareWithUuid;
  end;

  /// <summary>
  /// Represents a list of access rights for a specific library.
  /// </summary>
  /// <remarks>
  /// The <c>TLibrariesAccessList</c> class models the response when querying all entities that have access
  /// to a library. It encapsulates an array of <c>TLibrariesAccess</c> objects, each describing the
  /// access details for a single entity (user, workspace, or organization).
  /// </remarks>
  TLibrariesAccessList = class(TJSONFingerprint)
  private
    FData: TArray<TLibrariesAccess>;
  public
    /// <summary>
    /// Gets or sets the list of access entries for the library.
    /// </summary>
    /// <value>
    /// An array of <c>TLibrariesAccess</c> objects, where each object represents
    /// the access information of an entity.
    /// </value>
    property Data: TArray<TLibrariesAccess> read FData write FData;

    /// <summary>
    /// Destroys the current instance of <c>TLibrariesAccessList</c> and releases
    /// any resources associated with the contained <c>TLibrariesAccess</c> objects.
    /// </summary>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents an asynchronous callback handler for library access operations.
  /// </summary>
  /// <remarks>
  /// <c>TAsyncLibrariesAccess</c> is a type alias for <c>TAsyncCallback&lt;TLibrariesAccess&gt;</c>.
  /// It is used to manage non-blocking operations related to a single library access entry,
  /// providing event hooks such as <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c>.
  /// </remarks>
  TAsyncLibrariesAccess = TAsyncCallback<TLibrariesAccess>;

  /// <summary>
  /// Represents a promise-based asynchronous handler for library access operations.
  /// </summary>
  /// <remarks>
  /// <c>TPromiseLibrariesAccess</c> is a type alias for <c>TPromiseCallback&lt;TLibrariesAccess&gt;</c>.
  /// It is used in asynchronous workflows to retrieve or update a single library access entry,
  /// resolving with a <c>TLibrariesAccess</c> result when the operation completes successfully,
  /// or rejecting with an exception if an error occurs.
  /// </remarks>
  TPromiseLibrariesAccess = TPromiseCallback<TLibrariesAccess>;

  /// <summary>
  /// Represents an asynchronous callback handler for operations returning a list of library access entries.
  /// </summary>
  /// <remarks>
  /// <c>TAsyncLibrariesAccessList</c> is a type alias for <c>TAsyncCallback&lt;TLibrariesAccessList&gt;</c>.
  /// It is used for non-blocking operations that retrieve all access entries of a specific library,
  /// providing event hooks such as <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c> to manage the asynchronous workflow.
  /// </remarks>
  TAsyncLibrariesAccessList = TAsyncCallback<TLibrariesAccessList>;

  /// <summary>
  /// Represents a promise-based asynchronous handler for operations returning a list of library access entries.
  /// </summary>
  /// <remarks>
  /// <c>TPromiseLibrariesAccessList</c> is a type alias for <c>TPromiseCallback&lt;TLibrariesAccessList&gt;</c>.
  /// It is used in asynchronous workflows to retrieve all access entries of a specific library,
  /// resolving with a <c>TLibrariesAccessList</c> when the operation completes successfully,
  /// or rejecting with an exception if an error occurs.
  /// </remarks>
  TPromiseLibrariesAccessList = TPromiseCallback<TLibrariesAccessList>;


  /// <summary>
  /// Provides methods to manage and query access permissions for libraries.
  /// </summary>
  /// <remarks>
  /// The <c>TLibrariesAccessRoute</c> class acts as a client-side abstraction for the
  /// <c>/v1/libraries/{library_id}/share</c> API endpoints.
  /// It allows retrieving, creating, updating, and deleting access levels for users,
  /// workspaces, or organizations associated with a library.
  /// <para>
  /// The class supports both synchronous operations (e.g., <c>List</c>, <c>CreateOrUpdate</c>, <c>Delete</c>)
  /// and asynchronous operations using callbacks (e.g., <c>AsyncList</c>) or promises
  /// (e.g., <c>AsyncAwaitList</c>).
  /// </para>
  /// <para>
  /// To modify access rights, the caller must have ownership permissions for the specified library.
  /// An owner cannot remove their own access.
  /// </para>
  /// </remarks>
  TLibrariesAccessRoute = class(TMistralAIAPIRoute)
    /// <summary>
    /// Asynchronously retrieves the list of all entities that have access to the specified library,
    /// returning a promise that resolves with the result.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier (<c>UUID</c>) of the library whose access permissions are being queried.
    /// </param>
    /// <param name="Callbacks">
    /// An optional function returning a <c>TPromiseLibrariesAccessList</c>, allowing configuration of
    /// promise-style handlers such as <c>OnSuccess</c> and <c>OnError</c>.
    /// If not provided, default behavior is applied.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TLibrariesAccessList&gt;</c> that resolves with a <c>TLibrariesAccessList</c>
    /// when the operation completes successfully or rejects with an exception if an error occurs.
    /// </returns>
    /// <remarks>
    /// This method performs a non-blocking <c>GET</c> request to the API endpoint
    /// <c>/v1/libraries/{library_id}/share</c>.
    /// Use this function in asynchronous workflows where <c>await</c> or promise chaining is preferred.
    /// </remarks>
    function AsyncAwaitList(const LibraryId: string;
      const Callbacks: TFunc<TPromiseLibrariesAccessList> = nil): TPromise<TLibrariesAccessList>;

    /// <summary>
    /// Asynchronously creates or updates the access level of an entity for a specified library,
    /// returning a promise that resolves with the result.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier (<c>UUID</c>) of the library for which the access level will be created or updated.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure that configures the <c>TAccessParams</c> object, specifying details such as
    /// organization ID, access level (<c>Viewer</c> or <c>Editor</c>), and the target entity
    /// (user, workspace, or organization) to share the library with.
    /// </param>
    /// <param name="Callbacks">
    /// An optional function returning a <c>TPromiseLibrariesAccess</c>, allowing configuration of
    /// promise-style handlers such as <c>OnSuccess</c> and <c>OnError</c>.
    /// If not provided, default promise behavior is used.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TLibrariesAccess&gt;</c> that resolves with a <c>TLibrariesAccess</c> instance
    /// containing the updated access information, or rejects with an exception if an error occurs.
    /// </returns>
    /// <remarks>
    /// This method performs a non-blocking <c>PUT</c> request to the API endpoint
    /// <c>/v1/libraries/{library_id}/share</c>.
    /// It is ideal for asynchronous workflows using <c>await</c> or promise chaining.
    /// </remarks>
    function AsyncAwaitCreateOrUpdate(const LibraryId: string;
      const ParamProc: TProc<TAccessParams>;
      const Callbacks: TFunc<TPromiseLibrariesAccess> = nil): TPromise<TLibrariesAccess>;

    /// <summary>
    /// Asynchronously deletes the access rights of an entity for a specified library,
    /// returning a promise that resolves with the result.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier (<c>UUID</c>) of the library from which the access rights will be revoked.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure that configures the <c>TAccessParams</c> object, specifying details such as
    /// the organization ID and the target entity (user, workspace, or organization) whose access should be removed.
    /// </param>
    /// <param name="Callbacks">
    /// An optional function returning a <c>TPromiseLibrariesAccess</c>, allowing configuration of
    /// promise-style handlers such as <c>OnSuccess</c> and <c>OnError</c>.
    /// If not provided, default promise behavior is applied.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TLibrariesAccess&gt;</c> that resolves with a <c>TLibrariesAccess</c> instance
    /// describing the deleted access entry, or rejects with an exception if an error occurs.
    /// </returns>
    /// <remarks>
    /// This method performs a non-blocking <c>DELETE</c> request to the API endpoint
    /// <c>/v1/libraries/{library_id}/share</c>.
    /// It is designed for asynchronous workflows using <c>await</c> or promise chaining.
    /// </remarks>
    function AsyncAwaitDelete(const LibraryId: string;
      const ParamProc: TProc<TAccessParams>;
      const Callbacks: TFunc<TPromiseLibrariesAccess> = nil): TPromise<TLibrariesAccess>;

    /// <summary>
    /// Retrieves the list of all entities that have access to the specified library.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier (<c>UUID</c>) of the library whose access permissions are being queried.
    /// </param>
    /// <returns>
    /// A <c>TLibrariesAccessList</c> instance containing all access entries for the specified library,
    /// including entity type, UUID, organization ID, and assigned role.
    /// </returns>
    /// <remarks>
    /// This method performs a synchronous call to the API endpoint
    /// <c>GET /v1/libraries/{library_id}/share</c> and blocks until the response is received.
    /// Use this method when immediate access to the complete list of entities is required.
    /// </remarks>
    function List(const LibraryId: string): TLibrariesAccessList;

    /// <summary>
    /// Creates or updates the access level of an entity for a specified library.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier (<c>UUID</c>) of the library for which the access level will be created or updated.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure that configures the <c>TAccessParams</c> object, specifying details such as
    /// organization ID, access level (<c>Viewer</c> or <c>Editor</c>), and the entity (user, workspace, or organization)
    /// to share the library with.
    /// </param>
    /// <returns>
    /// A <c>TLibrariesAccess</c> instance containing the updated access information for the specified entity.
    /// </returns>
    /// <remarks>
    /// This method sends a synchronous <c>PUT</c> request to the API endpoint
    /// <c>/v1/libraries/{library_id}/share</c>.
    /// The caller must have ownership rights for the library in order to create or modify access levels.
    /// </remarks>
    function CreateOrUpdate(const LibraryId: string;
      const ParamProc: TProc<TAccessParams>): TLibrariesAccess;

    /// <summary>
    /// Deletes the access rights of an entity for a specified library.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier (<c>UUID</c>) of the library for which the access rights will be removed.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure that configures the <c>TAccessParams</c> object, specifying details such as
    /// organization ID and the entity (user, workspace, or organization) whose access must be revoked.
    /// </param>
    /// <returns>
    /// A <c>TLibrariesAccess</c> instance containing the access information that was removed.
    /// </returns>
    /// <remarks>
    /// This method sends a synchronous <c>DELETE</c> request to the API endpoint
    /// <c>/v1/libraries/{library_id}/share</c>.
    /// The caller must be the owner of the library to revoke access from other entities.
    /// An owner cannot delete their own access.
    /// </remarks>
    function Delete(const LibraryId: string;
      const ParamProc: TProc<TAccessParams>): TLibrariesAccess;

    /// <summary>
    /// Asynchronously retrieves the list of all entities that have access to the specified library.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier (<c>UUID</c>) of the library whose access permissions are being queried.
    /// </param>
    /// <param name="Callbacks">
    /// A function returning a <c>TAsyncLibrariesAccessList</c> record, which allows configuration
    /// of asynchronous event handlers such as <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c>.
    /// </param>
    /// <remarks>
    /// This method triggers a non-blocking operation to call the API endpoint
    /// <c>GET /v1/libraries/{library_id}/share</c>.
    /// The result, encapsulated in a <c>TLibrariesAccessList</c>, is delivered through the
    /// <c>OnSuccess</c> callback when the request completes successfully, or <c>OnError</c> if it fails.
    /// </remarks>
    procedure AsyncList(const LibraryId: string;
      const Callbacks: TFunc<TAsyncLibrariesAccessList>);

    /// <summary>
    /// Asynchronously creates or updates the access level of an entity for a specified library.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier (<c>UUID</c>) of the library for which the access level will be created or updated.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure that configures the <c>TAccessParams</c> object, specifying details such as
    /// organization ID, access level (<c>Viewer</c> or <c>Editor</c>), and the target entity
    /// (user, workspace, or organization) with which to share the library.
    /// </param>
    /// <param name="Callbacks">
    /// A function returning a <c>TAsyncLibrariesAccess</c> record, which allows configuration
    /// of asynchronous event handlers such as <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c>.
    /// </param>
    /// <remarks>
    /// This method performs a non-blocking <c>PUT</c> request to the API endpoint
    /// <c>/v1/libraries/{library_id}/share</c>.
    /// The resulting <c>TLibrariesAccess</c> instance is provided through the <c>OnSuccess</c> callback
    /// when the operation completes, or <c>OnError</c> if an error occurs.
    /// </remarks>
    procedure AsyncCreateOrUpdate(const LibraryId: string;
      const ParamProc: TProc<TAccessParams>;
      const Callbacks: TFunc<TAsyncLibrariesAccess>);

    /// <summary>
    /// Asynchronously deletes the access rights of an entity for a specified library.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier (<c>UUID</c>) of the library for which the access rights will be revoked.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure that configures the <c>TAccessParams</c> object, specifying details such as
    /// organization ID and the entity (user, workspace, or organization) whose access will be removed.
    /// </param>
    /// <param name="Callbacks">
    /// A function returning a <c>TAsyncLibrariesAccess</c> record, allowing configuration
    /// of asynchronous event handlers such as <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c>.
    /// </param>
    /// <remarks>
    /// This method performs a non-blocking <c>DELETE</c> request to the API endpoint
    /// <c>/v1/libraries/{library_id}/share</c>.
    /// The result, a <c>TLibrariesAccess</c> instance describing the deleted access,
    /// is delivered through the <c>OnSuccess</c> callback, or <c>OnError</c> if the operation fails.
    /// </remarks>
    procedure AsyncDelete(const LibraryId: string;
      const ParamProc: TProc<TAccessParams>;
      const Callbacks: TFunc<TAsyncLibrariesAccess>);
  end;

implementation

{ TAccessParams }

function TAccessParams.Level(
  const Value: TLevelType): TAccessParams;
begin
  Result := TAccessParams(Add('level', Value.ToString));
end;

function TAccessParams.Level(
  const Value: string): TAccessParams;
begin
  Result := TAccessParams(Add('level',  TLevelType.Create(Value).ToString));
end;

function TAccessParams.OrgId(
  const Value: string): TAccessParams;
begin
  Result := TAccessParams(Add('org_id', Value));
end;

function TAccessParams.ShareWithType(
  const Value: TShareWithType): TAccessParams;
begin
  Result := TAccessParams(Add('share_with_type', Value.ToString));
end;

function TAccessParams.ShareWithType(
  const Value: string): TAccessParams;
begin
  Result := TAccessParams(Add('share_with_type', TShareWithType.Create(Value).ToString));
end;

function TAccessParams.ShareWithUuid(
  const Value: string): TAccessParams;
begin
  Result := TAccessParams(Add('share_with_uuid', Value));
end;

{ TAccessDeleteParams }

function TAccessDeleteParams.OrgId(const Value: string): TAccessDeleteParams;
begin
  Result := TAccessDeleteParams(Add('org_id', Value));
end;

function TAccessDeleteParams.ShareWithType(
  const Value: TShareWithType): TAccessDeleteParams;
begin
  Result := TAccessDeleteParams(Add('share_with_type', Value.ToString));
end;

function TAccessDeleteParams.ShareWithType(
  const Value: string): TAccessDeleteParams;
begin
  Result := TAccessDeleteParams(Add('share_with_type', TShareWithType.Create(Value).ToString));
end;

function TAccessDeleteParams.ShareWithUuid(const Value: string): TAccessDeleteParams;
begin
  Result := TAccessDeleteParams(Add('share_with_uuid', Value));
end;

{ TLibrariesAccessList }

destructor TLibrariesAccessList.Destroy;
begin
  for var Item in FData do
    Item.Free;
  inherited;
end;

{ TLibrariesAccessRoute }

function TLibrariesAccessRoute.AsyncAwaitCreateOrUpdate(const LibraryId: string;
  const ParamProc: TProc<TAccessParams>;
  const Callbacks: TFunc<TPromiseLibrariesAccess>): TPromise<TLibrariesAccess>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TLibrariesAccess>(
    procedure(const CallbackParams: TFunc<TAsyncLibrariesAccess>)
    begin
      AsyncCreateOrUpdate(LibraryId, ParamProc, CallbackParams);
    end,
    Callbacks);
end;

function TLibrariesAccessRoute.AsyncAwaitDelete(const LibraryId: string;
  const ParamProc: TProc<TAccessParams>;
  const Callbacks: TFunc<TPromiseLibrariesAccess>): TPromise<TLibrariesAccess>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TLibrariesAccess>(
    procedure(const CallbackParams: TFunc<TAsyncLibrariesAccess>)
    begin
      AsyncDelete(LibraryId, ParamProc, CallbackParams);
    end,
    Callbacks);
end;

function TLibrariesAccessRoute.AsyncAwaitList(const LibraryId: string;
  const Callbacks: TFunc<TPromiseLibrariesAccessList>): TPromise<TLibrariesAccessList>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TLibrariesAccessList>(
    procedure(const CallbackParams: TFunc<TAsyncLibrariesAccessList>)
    begin
      AsyncList(LibraryId, CallbackParams);
    end,
    Callbacks);
end;

procedure TLibrariesAccessRoute.AsyncCreateOrUpdate(const LibraryId: string;
  const ParamProc: TProc<TAccessParams>;
  const Callbacks: TFunc<TAsyncLibrariesAccess>);
begin
  with TAsyncCallBackExec<TAsyncLibrariesAccess, TLibrariesAccess>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TLibrariesAccess
      begin
        Result := Self.CreateOrUpdate(LibraryId, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TLibrariesAccessRoute.AsyncDelete(const LibraryId: string;
  const ParamProc: TProc<TAccessParams>;
  const Callbacks: TFunc<TAsyncLibrariesAccess>);
begin
  with TAsyncCallBackExec<TAsyncLibrariesAccess, TLibrariesAccess>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TLibrariesAccess
      begin
        Result := Self.Delete(LibraryId, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TLibrariesAccessRoute.AsyncList(const LibraryId: string;
  const Callbacks: TFunc<TAsyncLibrariesAccessList>);
begin
  with TAsyncCallBackExec<TAsyncLibrariesAccessList, TLibrariesAccessList>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TLibrariesAccessList
      begin
        Result := Self.List(LibraryId);
      end);
  finally
    Free;
  end;
end;

function TLibrariesAccessRoute.CreateOrUpdate(const LibraryId: string;
  const ParamProc: TProc<TAccessParams>): TLibrariesAccess;
begin
  Result := API.Put<TLibrariesAccess, TAccessParams>('libraries/' + LibraryId + '/share', ParamProc);
end;

function TLibrariesAccessRoute.Delete(const LibraryId: string;
  const ParamProc: TProc<TAccessParams>): TLibrariesAccess;
begin
  Result := API.Delete<TLibrariesAccess, TAccessParams>('libraries/' + LibraryId + '/share', ParamProc);
end;

function TLibrariesAccessRoute.List(
  const LibraryId: string): TLibrariesAccessList;
begin
  Result := API.Get<TLibrariesAccessList>('libraries/' + LibraryId + '/share');
end;

end.

unit MistralAI.Libraries.Documents;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Threading, System.JSON, System.Net.Mime,
  REST.Json.Types, REST.JsonReflect,
  MistralAI.API.Params, MistralAI.API, MistralAI.Types, MistralAI.Files,
  MistralAI.Async.Params, MistralAI.Async.Support, MistralAI.Async.Promise;

type
  /// <summary>
  /// Represents the URL query parameters used when listing documents in a Mistral library.
  /// </summary>
  /// <remarks>
  /// This class provides a fluent interface to configure pagination, sorting, and search options
  /// for document retrieval via the <c>/v1/libraries/{library_id}/documents</c> endpoint.
  /// </remarks>
  TLibrariesDocumentsUrlParams = class(TUrlParam)
    /// <summary>
    /// Sets the search filter to match document names or content.
    /// </summary>
    /// <param name="Value">
    /// A keyword or phrase to search for, or an empty string for no filtering.
    /// </param>
    /// <returns>
    /// The current <c>TLibrariesDocumentsUrlParams</c> instance for method chaining.
    /// </returns>
    function Search(const Value: string): TLibrariesDocumentsUrlParams;

    /// <summary>
    /// Sets the number of documents to return per page.
    /// </summary>
    /// <param name="Value">
    /// The maximum number of documents to return per page. Defaults to 100.
    /// </param>
    /// <returns>
    /// The current <c>TLibrariesDocumentsUrlParams</c> instance for method chaining.
    /// </returns>
    function PageSize(const Value: Integer = 100): TLibrariesDocumentsUrlParams;

    /// <summary>
    /// Sets the page number to retrieve.
    /// </summary>
    /// <param name="Value">
    /// The page index to retrieve, starting from 0. Defaults to 0.
    /// </param>
    /// <returns>
    /// The current <c>TLibrariesDocumentsUrlParams</c> instance for method chaining.
    /// </returns>
    function Page(const Value: Integer = 0): TLibrariesDocumentsUrlParams;

    /// <summary>
    /// Sets the field by which to sort the document list.
    /// </summary>
    /// <param name="Value">
    /// The field to sort by. Defaults to <c>"created_at"</c>.
    /// </param>
    /// <returns>
    /// The current <c>TLibrariesDocumentsUrlParams</c> instance for method chaining.
    /// </returns>
    function SortBy(const Value: string = 'created_at'): TLibrariesDocumentsUrlParams;

    /// <summary>
    /// Sets the sort order for the document list.
    /// </summary>
    /// <param name="Value">
    /// The sort order, either <c>"asc"</c> or <c>"desc"</c>. Defaults to <c>"desc"</c>.
    /// </param>
    /// <returns>
    /// The current <c>TLibrariesDocumentsUrlParams</c> instance for method chaining.
    /// </returns>
    function SortOrder(const Value: string = 'desc'): TLibrariesDocumentsUrlParams;
  end;

  /// <summary>
  /// Represents the multipart/form-data parameters used for uploading documents
  /// to a Mistral library.
  /// </summary>
  /// <remarks>
  /// This class provides helper methods to add file streams or file paths
  /// when performing a document upload via the
  /// <c>/v1/libraries/{library_id}/documents</c> endpoint.
  /// </remarks>
  TLibrariesDocumentsUploadParams = class(TMultipartFormData)
    /// <summary>
    /// Adds a file to be uploaded using its file path.
    /// </summary>
    /// <param name="FileName">
    /// The full path to the file on the local file system.
    /// </param>
    /// <returns>
    /// The current <c>TLibrariesDocumentsUploadParams</c> instance for method chaining.
    /// </returns>
    /// <remarks>
    /// The file is sent using the "file" form field in the multipart request.
    /// </remarks>
    function &File(const FileName: string): TLibrariesDocumentsUploadParams; overload;

    /// <summary>
    /// Adds a file to be uploaded using a <c>TStream</c>.
    /// </summary>
    /// <param name="Stream">
    /// The stream containing the file content to be uploaded.
    /// </param>
    /// <param name="FileName">
    /// The name of the file to associate with the stream.
    /// </param>
    /// <returns>
    /// The current <c>TLibrariesDocumentsUploadParams</c> instance for method chaining.
    /// </returns>
    /// <remarks>
    /// This overload allows uploading files that are not stored on disk,
    /// such as dynamically generated files.
    /// </remarks>
    function &File(const Stream: TStream; const FileName: string): TLibrariesDocumentsUploadParams; overload;

    /// <summary>
    /// Initializes a new instance of <c>TLibrariesDocumentsUploadParams</c>
    /// with multipart form-data configuration enabled.
    /// </summary>
    constructor Create; reintroduce;
  end;

  /// <summary>
  /// Represents the JSON body parameters used for updating the metadata
  /// of a document within a Mistral library.
  /// </summary>
  /// <remarks>
  /// This class is primarily used to update the name of an existing document
  /// via the <c>/v1/libraries/{library_id}/documents/{document_id}</c> endpoint.
  /// </remarks>
  TLibrariesDocumentsUpdateParams = class(TJSONParam)
    /// <summary>
    /// Sets a new name for the document.
    /// </summary>
    /// <param name="Value">
    /// The new name to assign to the document.
    /// </param>
    /// <returns>
    /// The current <c>TLibrariesDocumentsUpdateParams</c> instance for method chaining.
    /// </returns>
    /// <remarks>
    /// The name must follow the naming rules of the Mistral API.
    /// </remarks>
    function Name(const Value: string): TLibrariesDocumentsUpdateParams;
  end;

  /// <summary>
  /// Represents pagination metadata for document listings in a Mistral library.
  /// </summary>
  /// <remarks>
  /// This class holds information about the total number of items,
  /// pages, the current page, and other pagination details returned
  /// by the <c>/v1/libraries/{library_id}/documents</c> endpoint.
  /// </remarks>
  TLibrariesPagination = class
  private
    [JsonNameAttribute('total_items')]
    FTotalItems: Int64;
    [JsonNameAttribute('total_pages')]
    FTotalPages: Int64;
    [JsonNameAttribute('current_page')]
    FCurrentPage: Int64;
    [JsonNameAttribute('page_size')]
    FPageSize: Int64;
    [JsonNameAttribute('has_more')]
    FHasMore: Boolean;
  public
    /// <summary>
    /// The total number of items (documents) available in the library.
    /// </summary>
    property TotalItems: Int64 read FTotalItems write FTotalItems;

    /// <summary>
    /// The total number of pages calculated based on <c>TotalItems</c> and <c>PageSize</c>.
    /// </summary>
    property TotalPages: Int64 read FTotalPages write FTotalPages;

    /// <summary>
    /// The current page index, starting from 0.
    /// </summary>
    property CurrentPage: Int64 read FCurrentPage write FCurrentPage;

    /// <summary>
    /// The number of items returned per page.
    /// </summary>
    property PageSize: Int64 read FPageSize write FPageSize;

    /// <summary>
    /// Indicates whether there are more pages to retrieve.
    /// </summary>
    property HasMore: Boolean read FHasMore write FHasMore;
  end;

  /// <summary>
  /// Represents the metadata of a document stored in a Mistral library.
  /// </summary>
  /// <remarks>
  /// This class maps the response structure of the
  /// <c>/v1/libraries/{library_id}/documents</c> endpoint and related document endpoints.
  /// It contains essential information such as file details, upload metadata,
  /// processing status, and token usage for the document.
  /// </remarks>
  TLibrariesDocuments = class(TJSONFingerprint)
  private
    FId: string;
    [JsonNameAttribute('library_id')]
    FLibraryId: string;
    FHash: string;
    [JsonNameAttribute('mime_type')]
    FMimeType: string;
    FExtension: string;
    FSize: Int64;
    FName: string;
    FSummary: string;
    [JsonNameAttribute('created_at')]
    FCreatedAt: string;
    [JsonNameAttribute('last_processed_at')]
    FLastProcessedAt: string;
    [JsonNameAttribute('number_of_pages')]
    FNumberOfPages: Int64;
    [JsonNameAttribute('processing_status')]
    FProcessingStatus: string;
    [JsonNameAttribute('uploaded_by_id')]
    FUploadedById: string;
    [JsonNameAttribute('uploaded_by_type')]
    FUploadedByType: string;
    [JsonNameAttribute('tokens_processing_main_content')]
    FTokensProcessingMainContent: Int64;
    [JsonNameAttribute('tokens_processing_summary')]
    FTokensProcessingSummary: Int64;
    [JsonNameAttribute('tokens_processing_total')]
    FTokensProcessingTotal: Int64;
  public
    /// <summary>
    /// Unique identifier of the document.
    /// </summary>
    property Id: string read FId write FId;

    /// <summary>
    /// Identifier of the library to which the document belongs.
    /// </summary>
    property LibraryId: string read FLibraryId write FLibraryId;

    /// <summary>
    /// Hash value of the document content (used for deduplication).
    /// </summary>
    property Hash: string read FHash write FHash;

    /// <summary>
    /// MIME type of the uploaded file (e.g., application/pdf).
    /// </summary>
    property MimeType: string read FMimeType write FMimeType;

    /// <summary>
    /// File extension of the document (e.g., pdf, docx).
    /// </summary>
    property Extension: string read FExtension write FExtension;

    /// <summary>
    /// Size of the file in bytes.
    /// </summary>
    property Size: Int64 read FSize write FSize;

    /// <summary>
    /// Original or updated name of the document.
    /// </summary>
    property Name: string read FName write FName;

    /// <summary>
    /// Optional summary generated or stored for the document.
    /// </summary>
    property Summary: string read FSummary write FSummary;

    /// <summary>
    /// Timestamp (ISO 8601) indicating when the document was created.
    /// </summary>
    property CreatedAt: string read FCreatedAt write FCreatedAt;

    /// <summary>
    /// Timestamp (ISO 8601) of the last processing completion.
    /// </summary>
    property LastProcessedAt: string read FLastProcessedAt write FLastProcessedAt;

    /// <summary>
    /// Number of pages detected in the document (if applicable).
    /// </summary>
    property NumberOfPages: Int64 read FNumberOfPages write FNumberOfPages;

    /// <summary>
    /// Current processing status of the document
    /// (e.g., queued, processing, completed).
    /// </summary>
    property ProcessingStatus: string read FProcessingStatus write FProcessingStatus;

    /// <summary>
    /// Identifier of the user or entity who uploaded the document.
    /// </summary>
    property UploadedById: string read FUploadedById write FUploadedById;

    /// <summary>
    /// Type of the uploader (e.g., User, Workspace, Org).
    /// </summary>
    property UploadedByType: string read FUploadedByType write FUploadedByType;

    /// <summary>
    /// Number of tokens processed from the main content of the document.
    /// </summary>
    property TokensProcessingMainContent: Int64 read FTokensProcessingMainContent write FTokensProcessingMainContent;

    /// <summary>
    /// Number of tokens processed for the document summary.
    /// </summary>
    property TokensProcessingSummary: Int64 read FTokensProcessingSummary write FTokensProcessingSummary;

    /// <summary>
    /// Total number of tokens processed for the document.
    /// </summary>
    property TokensProcessingTotal: Int64 read FTokensProcessingTotal write FTokensProcessingTotal;
  end;

  /// <summary>
  /// Represents the response structure when listing documents in a Mistral library.
  /// </summary>
  /// <remarks>
  /// This class encapsulates both the pagination information and the array of document metadata
  /// (<c>TLibrariesDocuments</c>) returned by the
  /// <c>/v1/libraries/{library_id}/documents</c> endpoint.
  /// </remarks>
  TLibrariesDocumentsList = class(TJSONFingerprint)
  private
    FPagination: TLibrariesPagination;
    FData: TArray<TLibrariesDocuments>;
  public
    /// <summary>
    /// Contains pagination details such as total items, pages, and current page.
    /// </summary>
    property Pagination: TLibrariesPagination read FPagination write FPagination;

    /// <summary>
    /// The collection of documents (<c>TLibrariesDocuments</c>) in the current page of results.
    /// </summary>
    property Data: TArray<TLibrariesDocuments> read FData write FData;

    /// <summary>
    /// Cleans up resources by freeing the pagination object
    /// and each document instance in the <c>Data</c> array.
    /// </summary>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents the response indicating whether a document operation
  /// (such as delete or reprocess) was successfully completed.
  /// </summary>
  /// <remarks>
  /// This class is used by endpoints like
  /// <c>/v1/libraries/{library_id}/documents/{document_id}</c> (DELETE)
  /// and
  /// <c>/v1/libraries/{library_id}/documents/{document_id}/reprocess</c> (POST),
  /// where the API returns a flag indicating the operation status.
  /// </remarks>
  TLibraryDocumentsProcessed = class(TJSONFingerprint)
  private
    FProcessed: Boolean;
  public
    /// <summary>
    /// Indicates whether the document operation was successfully processed.
    /// </summary>
    property Processed: Boolean read FProcessed write FProcessed;
  end;

  /// <summary>
  /// Represents the extracted text content of a document from a Mistral library.
  /// </summary>
  /// <remarks>
  /// This class maps the response of the
  /// <c>/v1/libraries/{library_id}/documents/{document_id}/text_content</c> endpoint.
  /// It contains the raw text extracted by the OCR or document processing pipeline.
  /// </remarks>
  TLibraryDocumentsText = class(TJSONFingerprint)
  private
    FText: string;
  public
    /// <summary>
    /// The full text content extracted from the document.
    /// </summary>
    property Text: string read FText write FText;
  end;

  /// <summary>
  /// Represents the processing status of a document in a Mistral library.
  /// </summary>
  /// <remarks>
  /// This class maps the response of the
  /// <c>/v1/libraries/{library_id}/documents/{document_id}/status</c> endpoint.
  /// It provides information about the document's unique identifier and its current processing state.
  /// </remarks>
  TLibraryDocumentsStatus = class(TJSONFingerprint)
  private
    [JsonNameAttribute('document_id')]
    FDocumentId: string;
    [JsonNameAttribute('processing_status')]
    FProcessingStatus: string;
  public
    /// <summary>
    /// The unique identifier of the document whose status is being queried.
    /// </summary>
    property DocumentId: string read FDocumentId write FDocumentId;

    /// <summary>
    /// The current processing status of the document (e.g., queued, processing, completed).
    /// </summary>
    property ProcessingStatus: string read FProcessingStatus write FProcessingStatus;
  end;

  /// <summary>
  /// Asynchronous callback type for operations returning a <c>TLibrariesDocuments</c> instance.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TAsyncCallback&lt;TLibrariesDocuments&gt;</c> is used for non-blocking
  /// document operations (e.g., retrieve, upload, update) where callbacks such as
  /// <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c> can be assigned to handle the result.
  /// </remarks>
  TAsyncLibrariesDocuments = TAsyncCallback<TLibrariesDocuments>;

  /// <summary>
  /// Promise-based callback type for operations returning a <c>TLibrariesDocuments</c> instance.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TPromiseCallback&lt;TLibrariesDocuments&gt;</c> is used for asynchronous
  /// document operations (e.g., upload, retrieve, update) that follow a promise-style interface.
  /// It enables chaining of success and error handlers, providing a cleaner, event-driven workflow.
  /// </remarks>
  TPromiseLibrariesDocuments = TPromiseCallback<TLibrariesDocuments>;

  /// <summary>
  /// Asynchronous callback type for operations returning a <c>TLibrariesDocumentsList</c> instance.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TAsyncCallback&lt;TLibrariesDocumentsList&gt;</c> is used for non-blocking
  /// document listing operations. It allows attaching event handlers such as <c>OnStart</c>,
  /// <c>OnSuccess</c>, and <c>OnError</c> to manage the response lifecycle when retrieving
  /// paginated lists of documents from a library.
  /// </remarks>
  TAsyncLibrariesDocumentsList = TAsyncCallback<TLibrariesDocumentsList>;

  /// <summary>
  /// Promise-based callback type for operations returning a <c>TLibrariesDocumentsList</c> instance.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TPromiseCallback&lt;TLibrariesDocumentsList&gt;</c> is designed for asynchronous
  /// document listing operations that follow a promise-style pattern.
  /// It enables chaining success and error handlers for handling paginated document retrieval results.
  /// </remarks>
  TPromiseLibrariesDocumentsList = TPromiseCallback<TLibrariesDocumentsList>;

  /// <summary>
  /// Asynchronous callback type for operations returning a <c>TLibraryDocumentsProcessed</c> instance.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TAsyncCallback&lt;TLibraryDocumentsProcessed&gt;</c> is used for non-blocking
  /// operations such as document deletion or reprocessing, where event handlers
  /// (<c>OnStart</c>, <c>OnSuccess</c>, <c>OnError</c>) can be attached to monitor the operation's outcome.
  /// </remarks>
  TAsyncLibraryDocumentsProcessed = TAsyncCallback<TLibraryDocumentsProcessed>;

  /// <summary>
  /// Promise-based callback type for operations returning a <c>TLibraryDocumentsProcessed</c> instance.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TPromiseCallback&lt;TLibraryDocumentsProcessed&gt;</c> is used for asynchronous
  /// operations such as document deletion or reprocessing, following a promise-style interface.
  /// It allows chaining success and error handlers to handle the final result of the operation.
  /// </remarks>
  TPromiseLibraryDocumentsProcessed = TPromiseCallback<TLibraryDocumentsProcessed>;

  /// <summary>
  /// Asynchronous callback type for operations returning a <c>TLibraryDocumentsText</c> instance.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TAsyncCallback&lt;TLibraryDocumentsText&gt;</c> is used for non-blocking
  /// operations that retrieve the extracted text content of a document.
  /// Event handlers such as <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c> can be attached
  /// to monitor the asynchronous text retrieval process.
  /// </remarks>
  TAsyncLibraryDocumentsText = TAsyncCallback<TLibraryDocumentsText>;

  /// <summary>
  /// Promise-based callback type for operations returning a <c>TLibraryDocumentsText</c> instance.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TPromiseCallback&lt;TLibraryDocumentsText&gt;</c> is used for asynchronous
  /// operations that retrieve the text content of a document.
  /// It enables a promise-style workflow, allowing chaining of success and error handlers
  /// to manage the final result of the text extraction process.
  /// </remarks>
  TPromiseLibraryDocumentsText = TPromiseCallback<TLibraryDocumentsText>;

  /// <summary>
  /// Asynchronous callback type for operations returning a <c>TLibraryDocumentsStatus</c> instance.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TAsyncCallback&lt;TLibraryDocumentsStatus&gt;</c> is used for non-blocking
  /// operations that check the processing status of a document.
  /// It allows attaching event handlers (<c>OnStart</c>, <c>OnSuccess</c>, <c>OnError</c>)
  /// to monitor the status retrieval process.
  /// </remarks>
  TAsyncLibraryDocumentsStatus = TAsyncCallback<TLibraryDocumentsStatus>;

  /// <summary>
  /// Promise-based callback type for operations returning a <c>TLibraryDocumentsStatus</c> instance.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TPromiseCallback&lt;TLibraryDocumentsStatus&gt;</c> is used for asynchronous
  /// operations that check the processing status of a document, following a promise-style pattern.
  /// It enables chaining of success and error handlers to handle the final result of the status query.
  /// </remarks>
  TPromiseLibraryDocumentsStatus = TPromiseCallback<TLibraryDocumentsStatus>;

  /// <summary>
  /// Provides a set of methods for managing documents within a specific library
  /// in the Mistral AI API.
  /// </summary>
  /// <remarks>
  /// The <c>TLibrariesDocumentsRoute</c> class offers a structured interface for
  /// performing document-related operations.
  /// <para>It allows listing all documents contained in a library.</para>
  /// <para>It supports uploading new documents with associated metadata.</para>
  /// <para>It enables retrieval of detailed document metadata by ID.</para>
  /// <para>It allows updating properties of a document, such as its name.</para>
  /// <para>It supports deletion of documents and reprocessing for OCR or indexing.</para>
  /// <para>It provides access to extracted text content and document processing status.</para>
  /// <para>
  /// This class serves as the main entry point for working with the
  /// <c>/v1/libraries/{library_id}/documents</c> endpoint group.
  /// </para>
  /// <example>
  /// Example of listing documents in a library:
  /// <code>
  /// var
  ///   DocsList: TLibrariesDocumentsList;
  /// begin
  ///   DocsList := MistralAI.LibrariesDocuments.List('my_library_id',
  ///     procedure(Params: TLibrariesDocumentsUrlParams)
  ///     begin
  ///       Params.Limit(10).Order('asc');
  ///     end
  ///   );
  /// end;
  /// </code>
  /// </example>
  /// </remarks>
  TLibrariesDocumentsRoute = class(TMistralAIAPIRoute)
    /// <summary>
    /// Asynchronously retrieves a paginated list of documents from a specified library using a promise-based interface.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library from which to list documents.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure <c>TLibrariesDocumentsUrlParams</c>,
    /// such as search filters, pagination options, and sorting criteria.
    /// </param>
    /// <param name="Callbacks">
    /// An optional function returning a <c>TPromiseLibrariesDocumentsList</c> instance
    /// to chain success and error handlers for the asynchronous operation.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TLibrariesDocumentsList&gt;</c> that resolves with a paginated list of documents
    /// or rejects with an error if the operation fails.
    /// </returns>
    /// <remarks>
    /// This method does not block the main thread and follows a promise-based pattern.
    /// Use <c>List</c> for a synchronous version or <c>AsyncList</c> for a callback-based asynchronous approach.
    /// </remarks>
    function AsyncAwaitList(const LibraryId: string;
      const ParamProc: TProc<TLibrariesDocumentsUrlParams>;
      const Callbacks: TFunc<TPromiseLibrariesDocumentsList> = nil): TPromise<TLibrariesDocumentsList>;

    /// <summary>
    /// Asynchronously uploads a document to a specified library using a promise-based interface.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library where the document will be uploaded.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TLibrariesDocumentsUploadParams</c>,
    /// such as specifying the file path or stream for the document to upload.
    /// </param>
    /// <param name="Callbacks">
    /// An optional function returning a <c>TPromiseLibrariesDocuments</c> instance
    /// to attach success and error handlers for the asynchronous upload.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TLibrariesDocuments&gt;</c> that resolves with the metadata
    /// of the uploaded document or rejects with an error if the upload fails.
    /// </returns>
    /// <remarks>
    /// This method performs the upload without blocking the main thread.
    /// Use <c>Upload</c> for a synchronous version or <c>AsyncUpload</c> for a callback-based asynchronous approach.
    /// </remarks>
    function AsyncAwaitUpload(const LibraryId: string;
      const ParamProc: TProc<TLibrariesDocumentsUploadParams>;
      const Callbacks: TFunc<TPromiseLibrariesDocuments> = nil): TPromise<TLibrariesDocuments>;

    /// <summary>
    /// Asynchronously retrieves the metadata of a specific document in a given library using a promise-based interface.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library containing the document.
    /// </param>
    /// <param name="DocumentId">
    /// The unique identifier of the document to retrieve.
    /// </param>
    /// <param name="Callbacks">
    /// An optional function returning a <c>TPromiseLibrariesDocuments</c> instance
    /// to attach success and error handlers for the asynchronous retrieval.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TLibrariesDocuments&gt;</c> that resolves with the document's metadata
    /// or rejects with an error if the retrieval fails.
    /// </returns>
    /// <remarks>
    /// This method does not block the main thread.
    /// Use <c>Retrieve</c> for a synchronous version or <c>AsyncRetrieve</c> for a callback-based asynchronous approach.
    /// </remarks>
    function AsyncAwaitRetrieve(const LibraryId: string;
      const DocumentId: string;
      const Callbacks: TFunc<TPromiseLibrariesDocuments> = nil): TPromise<TLibrariesDocuments>;

    /// <summary>
    /// Asynchronously updates the metadata of a specific document in a given library using a promise-based interface.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library containing the document.
    /// </param>
    /// <param name="DocumentId">
    /// The unique identifier of the document to update.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TLibrariesDocumentsUpdateParams</c>,
    /// such as setting a new document name.
    /// </param>
    /// <param name="Callbacks">
    /// An optional function returning a <c>TPromiseLibrariesDocuments</c> instance
    /// to attach success and error handlers for the asynchronous update.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TLibrariesDocuments&gt;</c> that resolves with the updated document metadata
    /// or rejects with an error if the update fails.
    /// </returns>
    /// <remarks>
    /// This method executes the update operation without blocking the main thread.
    /// Use <c>Update</c> for a synchronous version or <c>AsyncUpdate</c> for a callback-based asynchronous approach.
    /// </remarks>
    function AsyncAwaitUpdate(const LibraryId: string;
      const DocumentId: string;
      const ParamProc: TProc<TLibrariesDocumentsUpdateParams>;
      const Callbacks: TFunc<TPromiseLibrariesDocuments> = nil): TPromise<TLibrariesDocuments>;

    /// <summary>
    /// Asynchronously deletes a specific document from the given library using a promise-based interface.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library containing the document to delete.
    /// </param>
    /// <param name="DocumentId">
    /// The unique identifier of the document to delete.
    /// </param>
    /// <param name="Callbacks">
    /// An optional function returning a <c>TPromiseLibraryDocumentsProcessed</c> instance
    /// to attach success and error handlers for the asynchronous deletion.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TLibraryDocumentsProcessed&gt;</c> that resolves when the document is successfully deleted
    /// or rejects with an error if the operation fails.
    /// </returns>
    /// <remarks>
    /// This method triggers the deletion without blocking the main thread.
    /// Use <c>Delete</c> for a synchronous version or <c>AsyncDelete</c> for a callback-based asynchronous approach.
    /// </remarks>
    function AsyncAwaitDelete(const LibraryId: string;
      const DocumentId: string;
      const Callbacks: TFunc<TPromiseLibraryDocumentsProcessed> = nil): TPromise<TLibraryDocumentsProcessed>;

    /// <summary>
    /// Asynchronously retrieves the extracted text content of a specific document from a given library using a promise-based interface.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library containing the document.
    /// </param>
    /// <param name="DocumentId">
    /// The unique identifier of the document from which to retrieve text content.
    /// </param>
    /// <param name="Callbacks">
    /// An optional function returning a <c>TPromiseLibraryDocumentsText</c> instance
    /// to attach success and error handlers for the asynchronous text retrieval.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TLibraryDocumentsText&gt;</c> that resolves with the extracted text content
    /// or rejects with an error if the retrieval fails.
    /// </returns>
    /// <remarks>
    /// This method performs text retrieval without blocking the main thread.
    /// Use <c>RetrieveText</c> for a synchronous version or <c>AsyncRetrieveText</c> for a callback-based asynchronous approach.
    /// </remarks>
    function AsyncAwaitRetrieveText(const LibraryId: string;
      const DocumentId: string;
      const Callbacks: TFunc<TPromiseLibraryDocumentsText> = nil): TPromise<TLibraryDocumentsText>;

    /// <summary>
    /// Asynchronously retrieves the processing status of a specific document from a given library using a promise-based interface.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library containing the document.
    /// </param>
    /// <param name="DocumentId">
    /// The unique identifier of the document for which to retrieve the processing status.
    /// </param>
    /// <param name="Callbacks">
    /// An optional function returning a <c>TPromiseLibraryDocumentsStatus</c> instance
    /// to attach success and error handlers for the asynchronous status retrieval.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TLibraryDocumentsStatus&gt;</c> that resolves with the document's current processing status
    /// or rejects with an error if the retrieval fails.
    /// </returns>
    /// <remarks>
    /// This method retrieves the document status without blocking the main thread.
    /// Use <c>RetrieveStatus</c> for a synchronous version or <c>AsyncRetrieveStatus</c> for a callback-based asynchronous approach.
    /// </remarks>
    function AsyncAwaitRetrieveStatus(const LibraryId: string;
      const DocumentId: string;
      const Callbacks: TFunc<TPromiseLibraryDocumentsStatus> = nil): TPromise<TLibraryDocumentsStatus>;

    /// <summary>
    /// Asynchronously retrieves a temporary signed URL to access a specific document in a given library using a promise-based interface.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library containing the document.
    /// </param>
    /// <param name="DocumentId">
    /// The unique identifier of the document for which to generate the signed URL.
    /// </param>
    /// <param name="Callbacks">
    /// An optional function returning a <c>TPromiseSignedUrl</c> instance
    /// to attach success and error handlers for the asynchronous signed URL retrieval.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TSignedUrl&gt;</c> that resolves with the signed URL
    /// or rejects with an error if the URL generation fails.
    /// </returns>
    /// <remarks>
    /// The signed URL is valid for a limited time (typically 30 minutes).
    /// Use <c>GetDocumentSignedUrl</c> for a synchronous version
    /// or <c>AsyncGetDocumentSignedUrl</c> for a callback-based asynchronous approach.
    /// </remarks>
    function AsyncAwaitGetDocumentSignedUrl(const LibraryId: string;
      const DocumentId: string;
      const Callbacks: TFunc<TPromiseSignedUrl> = nil): TPromise<TSignedUrl>;

    /// <summary>
    /// Asynchronously retrieves a temporary signed URL to access the extracted text of a specific document
    /// in a given library using a promise-based interface.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library containing the document.
    /// </param>
    /// <param name="DocumentId">
    /// The unique identifier of the document for which to generate the signed text URL.
    /// </param>
    /// <param name="Callbacks">
    /// An optional function returning a <c>TPromiseSignedUrl</c> instance
    /// to attach success and error handlers for the asynchronous signed URL retrieval.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TSignedUrl&gt;</c> that resolves with the signed URL
    /// to access the document's extracted text or rejects with an error if the operation fails.
    /// </returns>
    /// <remarks>
    /// The signed URL is valid for a limited time (typically 30 minutes).
    /// Use <c>GetTextSignedUrl</c> for a synchronous version
    /// or <c>AsyncGetTextSignedUrl</c> for a callback-based asynchronous approach.
    /// </remarks>
    function AsyncAwaitGetTextSignedUrl(const LibraryId: string;
      const DocumentId: string;
      const Callbacks: TFunc<TPromiseSignedUrl> = nil): TPromise<TSignedUrl>;

    /// <summary>
    /// Asynchronously triggers the reprocessing of a specific document in a given library using a promise-based interface.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library containing the document.
    /// </param>
    /// <param name="DocumentId">
    /// The unique identifier of the document to reprocess.
    /// </param>
    /// <param name="Callbacks">
    /// An optional function returning a <c>TPromiseLibraryDocumentsProcessed</c> instance
    /// to attach success and error handlers for the asynchronous reprocess operation.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TLibraryDocumentsProcessed&gt;</c> that resolves when the reprocess operation is successfully triggered
    /// or rejects with an error if the request fails.
    /// </returns>
    /// <remarks>
    /// This method initiates the reprocess operation without blocking the main thread.
    /// Use <c>Reprocess</c> for a synchronous version or <c>AsyncReprocess</c> for a callback-based asynchronous approach.
    /// </remarks>
    function AsyncAwaitReprocess(const LibraryId: string;
      const DocumentId: string;
      const Callbacks: TFunc<TPromiseLibraryDocumentsProcessed> = nil): TPromise<TLibraryDocumentsProcessed>;

    /// <summary>
    /// Retrieves a paginated list of documents from a specified library.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library from which to list documents.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TLibrariesDocumentsUrlParams</c>
    /// (e.g., search filters, pagination, sorting options).
    /// </param>
    /// <returns>
    /// A <c>TLibrariesDocumentsList</c> instance containing the pagination information
    /// and an array of <c>TLibrariesDocuments</c> objects representing the listed documents.
    /// </returns>
    /// <remarks>
    /// This is a synchronous call that blocks until the list of documents is retrieved
    /// or an exception occurs.
    /// Use the asynchronous counterpart (<c>AsyncList</c> or <c>AsyncAwaitList</c>)
    /// for non-blocking operations.
    /// </remarks>
    function List(const LibraryId: string;
      const ParamProc: TProc<TLibrariesDocumentsUrlParams>): TLibrariesDocumentsList;

    /// <summary>
    /// Uploads a new document to the specified library.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the target library where the document will be uploaded.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TLibrariesDocumentsUploadParams</c>,
    /// including the file path or stream of the document to upload.
    /// </param>
    /// <returns>
    /// A <c>TLibrariesDocuments</c> instance containing the metadata of the uploaded document.
    /// </returns>
    /// <remarks>
    /// This is a synchronous operation and will block until the upload completes or an error occurs.
    /// If a document with the same hash already exists in the library,
    /// the existing document information is returned instead of creating a new one.
    /// Use the asynchronous counterparts (<c>AsyncUpload</c> or <c>AsyncAwaitUpload</c>) for non-blocking workflows.
    /// </remarks>
    function Upload(const LibraryId: string;
      const ParamProc: TProc<TLibrariesDocumentsUploadParams>): TLibrariesDocuments;

    /// <summary>
    /// Retrieves the metadata of a specific document within a given library.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library containing the document.
    /// </param>
    /// <param name="DocumentId">
    /// The unique identifier of the document to retrieve.
    /// </param>
    /// <returns>
    /// A <c>TLibrariesDocuments</c> instance containing the full metadata of the specified document.
    /// </returns>
    /// <remarks>
    /// This is a synchronous operation and will block until the document metadata is fully retrieved.
    /// Use the asynchronous counterparts (<c>AsyncRetrieve</c> or <c>AsyncAwaitRetrieve</c>)
    /// for non-blocking retrieval of document information.
    /// </remarks>
    function Retrieve(const LibraryId: string;
      const DocumentId: string): TLibrariesDocuments;

    /// <summary>
    /// Updates the metadata of a specific document in a given library.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library containing the document.
    /// </param>
    /// <param name="DocumentId">
    /// The unique identifier of the document to update.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TLibrariesDocumentsUpdateParams</c>,
    /// such as setting a new document name.
    /// </param>
    /// <returns>
    /// A <c>TLibrariesDocuments</c> instance containing the updated metadata of the document.
    /// </returns>
    /// <remarks>
    /// This is a synchronous operation that blocks until the update is applied.
    /// Use the asynchronous counterparts (<c>AsyncUpdate</c> or <c>AsyncAwaitUpdate</c>)
    /// for non-blocking updates.
    /// </remarks>
    function Update(const LibraryId: string;
      const DocumentId: string;
      const ParamProc: TProc<TLibrariesDocumentsUpdateParams>): TLibrariesDocuments;

    /// <summary>
    /// Deletes a specific document from the given library.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library containing the document.
    /// </param>
    /// <param name="DocumentId">
    /// The unique identifier of the document to delete.
    /// </param>
    /// <returns>
    /// A <c>TLibraryDocumentsProcessed</c> instance indicating whether the deletion was successfully processed.
    /// </returns>
    /// <remarks>
    /// This is a synchronous operation that blocks until the document is removed from both the library
    /// and the search index.
    /// Use the asynchronous counterparts (<c>AsyncDelete</c> or <c>AsyncAwaitDelete</c>)
    /// for non-blocking document deletion.
    /// </remarks>
    function Delete(const LibraryId: string;
      const DocumentId: string): TLibraryDocumentsProcessed;

    /// <summary>
    /// Retrieves the extracted text content of a specific document in a given library.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library containing the document.
    /// </param>
    /// <param name="DocumentId">
    /// The unique identifier of the document from which to extract text.
    /// </param>
    /// <returns>
    /// A <c>TLibraryDocumentsText</c> instance containing the extracted text content of the document.
    /// </returns>
    /// <remarks>
    /// This is a synchronous operation that blocks until the text content is fully retrieved.
    /// Use the asynchronous counterparts (<c>AsyncRetrieveText</c> or <c>AsyncAwaitRetrieveText</c>)
    /// for non-blocking text retrieval.
    /// </remarks>
    function RetrieveText(const LibraryId: string;
      const DocumentId: string): TLibraryDocumentsText;

    /// <summary>
    /// Retrieves the current processing status of a specific document in a given library.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library containing the document.
    /// </param>
    /// <param name="DocumentId">
    /// The unique identifier of the document for which to retrieve the processing status.
    /// </param>
    /// <returns>
    /// A <c>TLibraryDocumentsStatus</c> instance containing the document ID and its current processing status.
    /// </returns>
    /// <remarks>
    /// This is a synchronous operation that blocks until the status information is retrieved.
    /// Use the asynchronous counterparts (<c>AsyncRetrieveStatus</c> or <c>AsyncAwaitRetrieveStatus</c>)
    /// for non-blocking status checks.
    /// </remarks>
    function RetrieveStatus(const LibraryId: string;
      const DocumentId: string): TLibraryDocumentsStatus;

    /// <summary>
    /// Retrieves a temporary signed URL to access the specified document in a library.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library containing the document.
    /// </param>
    /// <param name="DocumentId">
    /// The unique identifier of the document for which to generate a signed URL.
    /// </param>
    /// <returns>
    /// A <c>TSignedUrl</c> instance containing a signed URL that can be used to download the document.
    /// </returns>
    /// <remarks>
    /// The signed URL is valid for a limited time (typically 30 minutes) and can be accessed by anyone with the link.
    /// This is a synchronous call; use <c>AsyncGetDocumentSignedUrl</c> or <c>AsyncAwaitGetDocumentSignedUrl</c>
    /// for non-blocking operations.
    /// </remarks>
    function GetDocumentSignedUrl(const LibraryId: string;
      const DocumentId: string): TSignedUrl;

    /// <summary>
    /// Retrieves a temporary signed URL for accessing the extracted text of a specific document in a library.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library containing the document.
    /// </param>
    /// <param name="DocumentId">
    /// The unique identifier of the document for which to generate a signed text URL.
    /// </param>
    /// <returns>
    /// A <c>TSignedUrl</c> instance containing a signed URL to download or access the extracted text content.
    /// </returns>
    /// <remarks>
    /// The signed URL is valid for a limited duration (typically 30 minutes) and can be accessed by anyone with the link.
    /// This is a synchronous call; use <c>AsyncGetTextSignedUrl</c> or <c>AsyncAwaitGetTextSignedUrl</c>
    /// for non-blocking retrieval of text URLs.
    /// </remarks>
    function GetTextSignedUrl(const LibraryId: string;
      const DocumentId: string): TSignedUrl;

    /// <summary>
    /// Reprocesses a specific document in the given library.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library containing the document to be reprocessed.
    /// </param>
    /// <param name="DocumentId">
    /// The unique identifier of the document to reprocess.
    /// </param>
    /// <returns>
    /// A <c>TLibraryDocumentsProcessed</c> instance indicating whether the reprocessing was successfully initiated.
    /// </returns>
    /// <remarks>
    /// This is a synchronous call that blocks until the reprocess request is sent.
    /// The operation may incur additional costs as it triggers a new processing cycle for the document.
    /// Use the asynchronous counterparts (<c>AsyncReprocess</c> or <c>AsyncAwaitReprocess</c>)
    /// for non-blocking reprocessing.
    /// </remarks>
    function Reprocess(const LibraryId: string;
      const DocumentId: string): TLibraryDocumentsProcessed;

    /// <summary>
    /// Asynchronously retrieves a paginated list of documents from a specified library.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library from which to list documents.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TLibrariesDocumentsUrlParams</c>
    /// (e.g., search filters, pagination, sorting options).
    /// </param>
    /// <param name="Callbacks">
    /// A function returning a <c>TAsyncLibrariesDocumentsList</c> instance
    /// with event handlers (<c>OnStart</c>, <c>OnSuccess</c>, <c>OnError</c>)
    /// to handle the asynchronous operation lifecycle.
    /// </param>
    /// <remarks>
    /// This method executes the document listing operation without blocking the main thread.
    /// Use <c>AsyncAwaitList</c> for a promise-based asynchronous pattern or <c>List</c> for the synchronous version.
    /// </remarks>
    procedure AsyncList(const LibraryId: string;
      const ParamProc: TProc<TLibrariesDocumentsUrlParams>;
      const Callbacks: TFunc<TAsyncLibrariesDocumentsList>);

    /// <summary>
    /// Asynchronously uploads a new document to the specified library.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library where the document will be uploaded.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TLibrariesDocumentsUploadParams</c>,
    /// such as specifying the file path or stream to upload.
    /// </param>
    /// <param name="Callbacks">
    /// A function returning a <c>TAsyncLibrariesDocuments</c> instance
    /// with event handlers (<c>OnStart</c>, <c>OnSuccess</c>, <c>OnError</c>)
    /// to manage the lifecycle of the asynchronous upload operation.
    /// </param>
    /// <remarks>
    /// This method performs the upload operation without blocking the main thread.
    /// Use <c>AsyncAwaitUpload</c> for a promise-based workflow or <c>Upload</c> for the synchronous version.
    /// </remarks>
    procedure AsyncUpload(const LibraryId: string;
      const ParamProc: TProc<TLibrariesDocumentsUploadParams>;
      const Callbacks: TFunc<TAsyncLibrariesDocuments>);

    /// <summary>
    /// Asynchronously retrieves the metadata of a specific document in a given library.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library containing the document.
    /// </param>
    /// <param name="DocumentId">
    /// The unique identifier of the document to retrieve.
    /// </param>
    /// <param name="Callbacks">
    /// A function returning a <c>TAsyncLibrariesDocuments</c> instance
    /// with event handlers (<c>OnStart</c>, <c>OnSuccess</c>, <c>OnError</c>)
    /// to handle the asynchronous retrieval process.
    /// </param>
    /// <remarks>
    /// This method performs the retrieval operation without blocking the main thread.
    /// Use <c>AsyncAwaitRetrieve</c> for a promise-based approach or <c>Retrieve</c> for the synchronous version.
    /// </remarks>
    procedure AsyncRetrieve(const LibraryId: string;
      const DocumentId: string;
      const Callbacks: TFunc<TAsyncLibrariesDocuments>);

    /// <summary>
    /// Asynchronously updates the metadata of a specific document in a given library.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library containing the document.
    /// </param>
    /// <param name="DocumentId">
    /// The unique identifier of the document to update.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TLibrariesDocumentsUpdateParams</c>,
    /// for example, to set a new document name.
    /// </param>
    /// <param name="Callbacks">
    /// A function returning a <c>TAsyncLibrariesDocuments</c> instance
    /// with event handlers (<c>OnStart</c>, <c>OnSuccess</c>, <c>OnError</c>)
    /// to manage the asynchronous update operation.
    /// </param>
    /// <remarks>
    /// This method executes the update without blocking the main thread.
    /// Use <c>AsyncAwaitUpdate</c> for a promise-based approach or <c>Update</c> for the synchronous version.
    /// </remarks>
    procedure AsyncUpdate(const LibraryId: string;
      const DocumentId: string;
      const ParamProc: TProc<TLibrariesDocumentsUpdateParams>;
      const Callbacks: TFunc<TAsyncLibrariesDocuments>);

    /// <summary>
    /// Asynchronously deletes a specific document from the given library.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library containing the document to delete.
    /// </param>
    /// <param name="DocumentId">
    /// The unique identifier of the document to delete.
    /// </param>
    /// <param name="Callbacks">
    /// A function returning a <c>TAsyncLibraryDocumentsProcessed</c> instance
    /// with event handlers (<c>OnStart</c>, <c>OnSuccess</c>, <c>OnError</c>)
    /// to monitor the asynchronous deletion operation.
    /// </param>
    /// <remarks>
    /// This method performs the delete operation without blocking the main thread.
    /// Use <c>AsyncAwaitDelete</c> for a promise-based approach or <c>Delete</c> for the synchronous version.
    /// </remarks>
    procedure AsyncDelete(const LibraryId: string;
      const DocumentId: string;
      const Callbacks: TFunc<TAsyncLibraryDocumentsProcessed>);

    /// <summary>
    /// Asynchronously retrieves the extracted text content of a specific document from a given library.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library containing the document.
    /// </param>
    /// <param name="DocumentId">
    /// The unique identifier of the document from which to retrieve text content.
    /// </param>
    /// <param name="Callbacks">
    /// A function returning a <c>TAsyncLibraryDocumentsText</c> instance
    /// with event handlers (<c>OnStart</c>, <c>OnSuccess</c>, <c>OnError</c>)
    /// to manage the asynchronous text retrieval process.
    /// </param>
    /// <remarks>
    /// This method retrieves text without blocking the main thread.
    /// Use <c>AsyncAwaitRetrieveText</c> for a promise-based approach or <c>RetrieveText</c> for the synchronous version.
    /// </remarks>
    procedure AsyncRetrieveText(const LibraryId: string;
      const DocumentId: string;
      const Callbacks: TFunc<TAsyncLibraryDocumentsText>);

    /// <summary>
    /// Asynchronously retrieves the processing status of a specific document from a given library.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library containing the document.
    /// </param>
    /// <param name="DocumentId">
    /// The unique identifier of the document for which to retrieve the processing status.
    /// </param>
    /// <param name="Callbacks">
    /// A function returning a <c>TAsyncLibraryDocumentsStatus</c> instance
    /// with event handlers (<c>OnStart</c>, <c>OnSuccess</c>, <c>OnError</c>)
    /// to manage the asynchronous status retrieval process.
    /// </param>
    /// <remarks>
    /// This method retrieves the document status without blocking the main thread.
    /// Use <c>AsyncAwaitRetrieveStatus</c> for a promise-based approach or <c>RetrieveStatus</c> for the synchronous version.
    /// </remarks>
    procedure AsyncRetrieveStatus(const LibraryId: string;
      const DocumentId: string;
      const Callbacks: TFunc<TAsyncLibraryDocumentsStatus>);

    /// <summary>
    /// Asynchronously retrieves a temporary signed URL to access a specific document in a given library.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library containing the document.
    /// </param>
    /// <param name="DocumentId">
    /// The unique identifier of the document for which to generate the signed URL.
    /// </param>
    /// <param name="Callbacks">
    /// A function returning a <c>TAsyncSignedUrl</c> instance
    /// with event handlers (<c>OnStart</c>, <c>OnSuccess</c>, <c>OnError</c>)
    /// to manage the asynchronous URL generation process.
    /// </param>
    /// <remarks>
    /// The generated signed URL is valid for a limited time (typically 30 minutes).
    /// Use <c>AsyncAwaitGetDocumentSignedUrl</c> for a promise-based workflow or <c>GetDocumentSignedUrl</c> for the synchronous version.
    /// </remarks>
    procedure AsyncGetDocumentSignedUrl(const LibraryId: string;
      const DocumentId: string;
      const Callbacks: TFunc<TAsyncSignedUrl>);

    /// <summary>
    /// Asynchronously retrieves a temporary signed URL to access the extracted text of a specific document in a given library.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library containing the document.
    /// </param>
    /// <param name="DocumentId">
    /// The unique identifier of the document for which to generate the signed text URL.
    /// </param>
    /// <param name="Callbacks">
    /// A function returning a <c>TAsyncSignedUrl</c> instance
    /// with event handlers (<c>OnStart</c>, <c>OnSuccess</c>, <c>OnError</c>)
    /// to manage the asynchronous URL generation process.
    /// </param>
    /// <remarks>
    /// The signed URL is valid for a limited time (typically 30 minutes).
    /// Use <c>AsyncAwaitGetTextSignedUrl</c> for a promise-based workflow
    /// or <c>GetTextSignedUrl</c> for the synchronous version.
    /// </remarks>
    procedure AsyncGetTextSignedUrl(const LibraryId: string;
      const DocumentId: string;
      const Callbacks: TFunc<TAsyncSignedUrl>);

    /// <summary>
    /// Asynchronously triggers reprocessing of a specific document in the given library.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library containing the document.
    /// </param>
    /// <param name="DocumentId">
    /// The unique identifier of the document to reprocess.
    /// </param>
    /// <param name="Callbacks">
    /// A function returning a <c>TAsyncLibraryDocumentsProcessed</c> instance
    /// with event handlers (<c>OnStart</c>, <c>OnSuccess</c>, <c>OnError</c>)
    /// to monitor the asynchronous reprocessing operation.
    /// </param>
    /// <remarks>
    /// This method performs the reprocess operation without blocking the main thread.
    /// Use <c>AsyncAwaitReprocess</c> for a promise-based approach
    /// or <c>Reprocess</c> for the synchronous version.
    /// </remarks>
    procedure AsyncReprocess(const LibraryId: string;
      const DocumentId: string;
      const Callbacks: TFunc<TAsyncLibraryDocumentsProcessed>);
  end;

implementation

{ TLibrariesDocumentsUrlParams }

function TLibrariesDocumentsUrlParams.Page(
  const Value: Integer): TLibrariesDocumentsUrlParams;
begin
  Result := TLibrariesDocumentsUrlParams(Add('page', Value));
end;

function TLibrariesDocumentsUrlParams.PageSize(
  const Value: Integer): TLibrariesDocumentsUrlParams;
begin
  Result := TLibrariesDocumentsUrlParams(Add('page_size', Value));
end;

function TLibrariesDocumentsUrlParams.Search(
  const Value: string): TLibrariesDocumentsUrlParams;
begin
  Result := TLibrariesDocumentsUrlParams(Add('search', Value));
end;

function TLibrariesDocumentsUrlParams.SortBy(
  const Value: string): TLibrariesDocumentsUrlParams;
begin
  Result := TLibrariesDocumentsUrlParams(Add('sort_by', Value));
end;

function TLibrariesDocumentsUrlParams.SortOrder(
  const Value: string): TLibrariesDocumentsUrlParams;
begin
  Result := TLibrariesDocumentsUrlParams(Add('sort_order', Value));
end;

{ TLibrariesDocumentsUploadParams }

function TLibrariesDocumentsUploadParams.&File(
  const FileName: string): TLibrariesDocumentsUploadParams;
begin
  AddFile('file', FileName);
  Result := Self;
end;

constructor TLibrariesDocumentsUploadParams.Create;
begin
  inherited Create(True);
end;

function TLibrariesDocumentsUploadParams.&File(const Stream: TStream;
  const FileName: string): TLibrariesDocumentsUploadParams;
begin
  {$IF RTLVersion > 35.0}
  AddStream('file', Stream, True, FileName);
  {$ELSE}
  AddStream('file', Stream, FileName);
  {$ENDIF}
  Result := Self;
end;

{ TLibrariesDocumentsUpdateParams }

function TLibrariesDocumentsUpdateParams.Name(
  const Value: string): TLibrariesDocumentsUpdateParams;
begin
  Result := TLibrariesDocumentsUpdateParams(Add('name', Value));
end;

{ TLibrariesDocumentsList }

destructor TLibrariesDocumentsList.Destroy;
begin
  if Assigned(FPagination) then
    FPagination.Free;
  for var Item in FData do
    Item.Free;
  inherited;
end;

{ TLibrariesDocumentsRoute }

function TLibrariesDocumentsRoute.AsyncAwaitDelete(const LibraryId,
  DocumentId: string;
  const Callbacks: TFunc<TPromiseLibraryDocumentsProcessed>): TPromise<TLibraryDocumentsProcessed>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TLibraryDocumentsProcessed>(
    procedure(const CallbackParams: TFunc<TAsyncLibraryDocumentsProcessed>)
    begin
      AsyncDelete(LibraryId, DocumentId, CallbackParams);
    end,
    Callbacks);
end;

function TLibrariesDocumentsRoute.AsyncAwaitGetDocumentSignedUrl(
  const LibraryId, DocumentId: string;
  const Callbacks: TFunc<TPromiseSignedUrl>): TPromise<TSignedUrl>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TSignedUrl>(
    procedure(const CallbackParams: TFunc<TAsyncSignedUrl>)
    begin
      AsyncGetDocumentSignedUrl(LibraryId, DocumentId, CallbackParams);
    end,
    Callbacks);
end;

function TLibrariesDocumentsRoute.AsyncAwaitGetTextSignedUrl(const LibraryId,
  DocumentId: string;
  const Callbacks: TFunc<TPromiseSignedUrl>): TPromise<TSignedUrl>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TSignedUrl>(
    procedure(const CallbackParams: TFunc<TAsyncSignedUrl>)
    begin
      AsyncGetTextSignedUrl(LibraryId, DocumentId, CallbackParams);
    end,
    Callbacks);
end;

function TLibrariesDocumentsRoute.AsyncAwaitList(const LibraryId: string;
  const ParamProc: TProc<TLibrariesDocumentsUrlParams>;
  const Callbacks: TFunc<TPromiseLibrariesDocumentsList>): TPromise<TLibrariesDocumentsList>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TLibrariesDocumentsList>(
    procedure(const CallbackParams: TFunc<TAsyncLibrariesDocumentsList>)
    begin
      AsyncList(LibraryId, ParamProc, CallbackParams);
    end,
    Callbacks);
end;

function TLibrariesDocumentsRoute.AsyncAwaitReprocess(const LibraryId,
  DocumentId: string;
  const Callbacks: TFunc<TPromiseLibraryDocumentsProcessed>): TPromise<TLibraryDocumentsProcessed>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TLibraryDocumentsProcessed>(
    procedure(const CallbackParams: TFunc<TAsyncLibraryDocumentsProcessed>)
    begin
      AsyncReprocess(LibraryId, DocumentId, CallbackParams);
    end,
    Callbacks);
end;

function TLibrariesDocumentsRoute.AsyncAwaitRetrieve(const LibraryId,
  DocumentId: string;
  const Callbacks: TFunc<TPromiseLibrariesDocuments>): TPromise<TLibrariesDocuments>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TLibrariesDocuments>(
    procedure(const CallbackParams: TFunc<TAsyncLibrariesDocuments>)
    begin
      AsyncRetrieve(LibraryId, DocumentId, CallbackParams);
    end,
    Callbacks);
end;

function TLibrariesDocumentsRoute.AsyncAwaitRetrieveStatus(const LibraryId,
  DocumentId: string;
  const Callbacks: TFunc<TPromiseLibraryDocumentsStatus>): TPromise<TLibraryDocumentsStatus>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TLibraryDocumentsStatus>(
    procedure(const CallbackParams: TFunc<TAsyncLibraryDocumentsStatus>)
    begin
      AsyncRetrieveStatus(LibraryId, DocumentId, CallbackParams);
    end,
    Callbacks);
end;

function TLibrariesDocumentsRoute.AsyncAwaitRetrieveText(const LibraryId,
  DocumentId: string;
  const Callbacks: TFunc<TPromiseLibraryDocumentsText>): TPromise<TLibraryDocumentsText>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TLibraryDocumentsText>(
    procedure(const CallbackParams: TFunc<TAsyncLibraryDocumentsText>)
    begin
      AsyncRetrieveText(LibraryId, DocumentId, CallbackParams);
    end,
    Callbacks);
end;

function TLibrariesDocumentsRoute.AsyncAwaitUpdate(const LibraryId,
  DocumentId: string;
  const ParamProc: TProc<TLibrariesDocumentsUpdateParams>;
  const Callbacks: TFunc<TPromiseLibrariesDocuments>): TPromise<TLibrariesDocuments>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TLibrariesDocuments>(
    procedure(const CallbackParams: TFunc<TAsyncLibrariesDocuments>)
    begin
      AsyncUpdate(LibraryId, DocumentId, ParamProc, CallbackParams);
    end,
    Callbacks);
end;

function TLibrariesDocumentsRoute.AsyncAwaitUpload(const LibraryId: string;
  const ParamProc: TProc<TLibrariesDocumentsUploadParams>;
  const Callbacks: TFunc<TPromiseLibrariesDocuments>): TPromise<TLibrariesDocuments>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TLibrariesDocuments>(
    procedure(const CallbackParams: TFunc<TAsyncLibrariesDocuments>)
    begin
      AsyncUpload(LibraryId, ParamProc, CallbackParams);
    end,
    Callbacks);
end;

procedure TLibrariesDocumentsRoute.AsyncDelete(const LibraryId,
  DocumentId: string; const Callbacks: TFunc<TAsyncLibraryDocumentsProcessed>);
begin
  with TAsyncCallBackExec<TAsyncLibraryDocumentsProcessed, TLibraryDocumentsProcessed>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TLibraryDocumentsProcessed
      begin
        Result := Self.Delete(LibraryId, DocumentId);
      end);
  finally
    Free;
  end;
end;

procedure TLibrariesDocumentsRoute.AsyncGetDocumentSignedUrl(const LibraryId,
  DocumentId: string; const Callbacks: TFunc<TAsyncSignedUrl>);
begin
  with TAsyncCallBackExec<TAsyncSignedUrl, TSignedUrl>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TSignedUrl
      begin
        Result := Self.GetDocumentSignedUrl(LibraryId, DocumentId);
      end);
  finally
    Free;
  end;
end;

procedure TLibrariesDocumentsRoute.AsyncGetTextSignedUrl(const LibraryId,
  DocumentId: string; const Callbacks: TFunc<TAsyncSignedUrl>);
begin
  with TAsyncCallBackExec<TAsyncSignedUrl, TSignedUrl>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TSignedUrl
      begin
        Result := Self.GetTextSignedUrl(LibraryId, DocumentId);
      end);
  finally
    Free;
  end;
end;

procedure TLibrariesDocumentsRoute.AsyncList(const LibraryId: string;
  const ParamProc: TProc<TLibrariesDocumentsUrlParams>;
  const Callbacks: TFunc<TAsyncLibrariesDocumentsList>);
begin
  with TAsyncCallBackExec<TAsyncLibrariesDocumentsList, TLibrariesDocumentsList>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TLibrariesDocumentsList
      begin
        Result := Self.List(LibraryId, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TLibrariesDocumentsRoute.AsyncReprocess(const LibraryId,
  DocumentId: string; const Callbacks: TFunc<TAsyncLibraryDocumentsProcessed>);
begin
  with TAsyncCallBackExec<TAsyncLibraryDocumentsProcessed, TLibraryDocumentsProcessed>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TLibraryDocumentsProcessed
      begin
        Result := Self.Reprocess(LibraryId, DocumentId);
      end);
  finally
    Free;
  end;
end;

procedure TLibrariesDocumentsRoute.AsyncRetrieve(const LibraryId, DocumentId: string;
  const Callbacks: TFunc<TAsyncLibrariesDocuments>);
begin
  with TAsyncCallBackExec<TAsyncLibrariesDocuments, TLibrariesDocuments>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TLibrariesDocuments
      begin
        Result := Self.Retrieve(LibraryId, DocumentId);
      end);
  finally
    Free;
  end;
end;

procedure TLibrariesDocumentsRoute.AsyncRetrieveStatus(const LibraryId,
  DocumentId: string; const Callbacks: TFunc<TAsyncLibraryDocumentsStatus>);
begin
  with TAsyncCallBackExec<TAsyncLibraryDocumentsStatus, TLibraryDocumentsStatus>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TLibraryDocumentsStatus
      begin
        Result := Self.RetrieveStatus(LibraryId, DocumentId);
      end);
  finally
    Free;
  end;
end;

procedure TLibrariesDocumentsRoute.AsyncRetrieveText(const LibraryId,
  DocumentId: string; const Callbacks: TFunc<TAsyncLibraryDocumentsText>);
begin
  with TAsyncCallBackExec<TAsyncLibraryDocumentsText, TLibraryDocumentsText>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TLibraryDocumentsText
      begin
        Result := Self.RetrieveText(LibraryId, DocumentId);
      end);
  finally
    Free;
  end;
end;

procedure TLibrariesDocumentsRoute.AsyncUpdate(const LibraryId,
  DocumentId: string; const ParamProc: TProc<TLibrariesDocumentsUpdateParams>;
  const Callbacks: TFunc<TAsyncLibrariesDocuments>);
begin
  with TAsyncCallBackExec<TAsyncLibrariesDocuments, TLibrariesDocuments>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TLibrariesDocuments
      begin
        Result := Self.Update(LibraryId, DocumentId, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TLibrariesDocumentsRoute.AsyncUpload(const LibraryId: string;
  const ParamProc: TProc<TLibrariesDocumentsUploadParams>;
  const Callbacks: TFunc<TAsyncLibrariesDocuments>);
begin
  with TAsyncCallBackExec<TAsyncLibrariesDocuments, TLibrariesDocuments>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TLibrariesDocuments
      begin
        Result := Self.Upload(LibraryId, ParamProc);
      end);
  finally
    Free;
  end;
end;

function TLibrariesDocumentsRoute.Delete(const LibraryId,
  DocumentId: string): TLibraryDocumentsProcessed;
begin
  Result := API.DeleteEx<TLibraryDocumentsProcessed>('libraries/' + LibraryId + '/documents/' + DocumentId);
end;

function TLibrariesDocumentsRoute.GetDocumentSignedUrl(const LibraryId,
  DocumentId: string): TSignedUrl;
begin
  Result := API.Get<TSignedUrl>('libraries/' + LibraryId + '/documents/' + DocumentId + '/signed-url', 'url');
end;

function TLibrariesDocumentsRoute.GetTextSignedUrl(const LibraryId,
  DocumentId: string): TSignedUrl;
begin
  Result := API.Get<TSignedUrl>('libraries/' + LibraryId + '/documents/' + DocumentId + '/extracted-text-signed-url', 'url');
end;

function TLibrariesDocumentsRoute.List(const LibraryId: string;
  const ParamProc: TProc<TLibrariesDocumentsUrlParams>): TLibrariesDocumentsList;
begin
  Result := API.Get<TLibrariesDocumentsList, TLibrariesDocumentsUrlParams>('libraries/' + LibraryId + '/documents', ParamProc);
end;

function TLibrariesDocumentsRoute.Reprocess(const LibraryId,
  DocumentId: string): TLibraryDocumentsProcessed;
begin
  Result := API.PostEx<TLibraryDocumentsProcessed>('libraries/' + LibraryId + '/documents/' + DocumentId + '/reprocess');
end;

function TLibrariesDocumentsRoute.Retrieve(const LibraryId,
  DocumentId: string): TLibrariesDocuments;
begin
  Result := API.Get<TLibrariesDocuments>('libraries/' + LibraryId + '/documents/' + DocumentId);
end;

function TLibrariesDocumentsRoute.RetrieveStatus(const LibraryId,
  DocumentId: string): TLibraryDocumentsStatus;
begin
  Result := API.Get<TLibraryDocumentsStatus>('libraries/' + LibraryId + '/documents/' + DocumentId + '/status');
end;

function TLibrariesDocumentsRoute.RetrieveText(const LibraryId,
  DocumentId: string): TLibraryDocumentsText;
begin
  Result := API.Get<TLibraryDocumentsText>('libraries/' + LibraryId + '/documents/' + DocumentId + '/text_content');
end;

function TLibrariesDocumentsRoute.Update(const LibraryId, DocumentId: string;
  const ParamProc: TProc<TLibrariesDocumentsUpdateParams>): TLibrariesDocuments;
begin
  Result := API.Put<TLibrariesDocuments, TLibrariesDocumentsUpdateParams>('libraries/' + LibraryId + '/documents/' + DocumentId, ParamProc);
end;

function TLibrariesDocumentsRoute.Upload(const LibraryId: string;
  const ParamProc: TProc<TLibrariesDocumentsUploadParams>): TLibrariesDocuments;
begin
  Result := API.PostForm<TLibrariesDocuments, TLibrariesDocumentsUploadParams>('libraries/' + LibraryId + '/documents', ParamProc);
end;

end.

unit MistralAI.Libraries.Main;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Threading, System.JSON,
  REST.Json.Types, REST.JsonReflect,
  MistralAI.Types, MistralAI.API, MistralAI.API.Params,
  MistralAI.Async.Params, MistralAI.Async.Support, MistralAI.Async.Promise;

type
  /// <summary>
  /// Represents the parameters required to create or configure a document library
  /// within the Mistral AI API.
  /// </summary>
  /// <remarks>
  /// This class provides a fluent interface for defining the main properties of a library,
  /// such as its name, description, and chunk size for document indexing.
  /// Instances of this class are typically passed to methods like
  /// <c>TLibrariesMainRoute.Create</c> to create a new library.
  /// </remarks>
  TLibrariesMainParams = class(TJSONParam)
    /// <summary>
    /// Sets the name of the library.
    /// </summary>
    /// <param name="Value">
    /// The library name as a string.
    /// </param>
    /// <returns>
    /// The current instance of <c>TLibrariesMainParams</c> to allow method chaining.
    /// </returns>
    /// <remarks>
    /// The name should be unique within your organization and descriptive of the
    /// library's content.
    /// </remarks>
    function Name(const Value: string): TLibrariesMainParams;

    /// <summary>
    /// Sets the description of the library.
    /// </summary>
    /// <param name="Value">
    /// A string describing the purpose or content of the library.
    /// </param>
    /// <returns>
    /// The current instance of <c>TLibrariesMainParams</c> for fluent configuration.
    /// </returns>
    /// <remarks>
    /// The description can be updated later with the <c>Update</c> method on
    /// <c>TLibrariesMainRoute</c>.
    /// </remarks>
    function Description(const Value: string): TLibrariesMainParams;

    /// <summary>
    /// Sets the chunk size for the library.
    /// </summary>
    /// <param name="Value">
    /// The maximum chunk size (in characters or tokens, depending on backend settings)
    /// used to split documents during indexing.
    /// </param>
    /// <returns>
    /// The current instance of <c>TLibrariesMainParams</c> for method chaining.
    /// </returns>
    /// <remarks>
    /// Adjusting the chunk size can impact retrieval performance and accuracy when querying
    /// large documents. Larger chunks may improve context but reduce search granularity.
    /// </remarks>
    function ChunkSize(const Value: Integer): TLibrariesMainParams;
  end;

  /// <summary>
  /// Represents the parameters required to update the properties of an existing
  /// document library in the Mistral AI API.
  /// </summary>
  /// <remarks>
  /// This class provides a fluent interface for defining updated values such as
  /// the library name or description. It is primarily used with the
  /// <c>TLibrariesMainRoute.Update</c> method to modify an existing library's metadata.
  /// </remarks>
  TUpdateLibrariesMainParams = class(TJSONParam)
    /// <summary>
    /// Updates the name of the library.
    /// </summary>
    /// <param name="Value">
    /// The new name for the library as a string.
    /// </param>
    /// <returns>
    /// The current instance of <c>TUpdateLibrariesMainParams</c> for fluent configuration.
    /// </returns>
    /// <remarks>
    /// If not specified, the library's name remains unchanged.
    /// </remarks>
    function Name(const Value: string): TUpdateLibrariesMainParams;

    /// <summary>
    /// Updates the description of the library.
    /// </summary>
    /// <param name="Value">
    /// A new description providing details about the library's content or purpose.
    /// </param>
    /// <returns>
    /// The current instance of <c>TUpdateLibrariesMainParams</c> for method chaining.
    /// </returns>
    /// <remarks>
    /// If not specified, the library's description remains unchanged.
    /// </remarks>
    function Description(const Value: string): TUpdateLibrariesMainParams;
  end;

  /// <summary>
  /// Represents a document library in the Mistral AI API.
  /// </summary>
  /// <remarks>
  /// This class models the metadata of a document library, including its unique
  /// identifier, name, owner information, creation and update timestamps, as well as
  /// document statistics such as total size and number of documents.
  /// Instances of <c>TLibrariesMain</c> are typically returned by calls to
  /// <c>TLibrariesMainRoute.List</c>, <c>TLibrariesMainRoute.Create</c>,
  /// <c>TLibrariesMainRoute.Retrieve</c>, or <c>TLibrariesMainRoute.Update</c>.
  /// </remarks>
  TLibrariesMain = class(TJSONFingerprint)
  private
    FId: string;
    FName: string;
    [JsonNameAttribute('created_at')]
    FCreatedAt: string;
    [JsonNameAttribute('updated_at')]
    FUpdatedAt: string;
    [JsonNameAttribute('owner_id')]
    FOwnerId: string;
    [JsonNameAttribute('owner_type')]
    FOwnerType: string;
    [JsonNameAttribute('total_size')]
    FTotalSize: Int64;
    [JsonNameAttribute('nb_documents')]
    FNbDocuments: Int64;
    [JsonNameAttribute('chunk_size')]
    FChunkSize: Int64;
    FEmoji: string;
    FDescription: string;
    [JsonNameAttribute('generated_name')]
    FGeneratedName: string;
    [JsonNameAttribute('generated_description')]
    FGeneratedDescription: string;
    [JsonNameAttribute('explicit_user_members_count')]
    FExplicitUserMembersCount: Int64;
    [JsonNameAttribute('explicit_workspace_members_count')]
    FExplicitWorkspaceMembersCount: Int64;
    [JsonNameAttribute('org_sharing_role')]
    FOrgSharingRole: string;
  public
    /// <summary>
    /// Unique identifier of the library.
    /// </summary>
    property Id: string read FId write FId;

    /// <summary>
    /// Name of the library.
    /// </summary>
    property Name: string read FName write FName;

    /// <summary>
    /// ISO 8601 timestamp indicating when the library was created.
    /// </summary>
    property CreatedAt: string read FCreatedAt write FCreatedAt;

    /// <summary>
    /// ISO 8601 timestamp indicating when the library was last updated.
    /// </summary>
    property UpdatedAt: string read FUpdatedAt write FUpdatedAt;

    /// <summary>
    /// Identifier of the owner (user, workspace, or organization) that created the library.
    /// </summary>
    property OwnerId: string read FOwnerId write FOwnerId;

    /// <summary>
    /// Type of the owner (e.g., "User", "Workspace", or "Org").
    /// </summary>
    property OwnerType: string read FOwnerType write FOwnerType;

    /// <summary>
    /// Total size of all documents in the library, expressed in bytes.
    /// </summary>
    property TotalSize: Int64 read FTotalSize write FTotalSize;

    /// <summary>
    /// Total number of documents in the library.
    /// </summary>
    property NbDocuments: Int64 read FNbDocuments write FNbDocuments;

    /// <summary>
    /// Size of the chunks used for document indexing.
    /// </summary>
    property ChunkSize: Int64 read FChunkSize write FChunkSize;

    /// <summary>
    /// Emoji associated with the library (if any).
    /// </summary>
    property Emoji: string read FEmoji write FEmoji;

    /// <summary>
    /// User-provided description of the library.
    /// </summary>
    property Description: string read FDescription write FDescription;

    /// <summary>
    /// Automatically generated name for the library (if no explicit name was provided).
    /// </summary>
    property GeneratedName: string read FGeneratedName write FGeneratedName;

    /// <summary>
    /// Automatically generated description for the library (if no explicit description was provided).
    /// </summary>
    property GeneratedDescription: string read FGeneratedDescription write FGeneratedDescription;

    /// <summary>
    /// Number of users explicitly granted access to the library.
    /// </summary>
    property ExplicitUserMembersCount: Int64 read FExplicitUserMembersCount write FExplicitUserMembersCount;

    /// <summary>
    /// Number of workspaces explicitly granted access to the library.
    /// </summary>
    property ExplicitWorkspaceMembersCount: Int64 read FExplicitWorkspaceMembersCount write FExplicitWorkspaceMembersCount;

    /// <summary>
    /// Access level shared with the organization (e.g., "Viewer" or "Editor").
    /// </summary>
    property OrgSharingRole: string read FOrgSharingRole write FOrgSharingRole;
  end;

  /// <summary>
  /// Represents a list of document libraries retrieved from the Mistral AI API.
  /// </summary>
  /// <remarks>
  /// This class encapsulates an array of <c>TLibrariesMain</c> objects, each representing
  /// a single document library and its metadata (e.g., ID, name, description, and statistics).
  /// It is typically returned by calls such as <c>TLibrariesMainRoute.List</c> to enumerate
  /// all existing libraries.
  /// </remarks>
  TLibrariesMainList = class(TJSONFingerprint)
  private
    FData: TArray<TLibrariesMain>;
  public
    /// <summary>
    /// Array of <c>TLibrariesMain</c> objects representing the libraries.
    /// </summary>
    property Data: TArray<TLibrariesMain> read FData write FData;

    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents an asynchronous callback handler for operations returning a
  /// <c>TLibrariesMain</c> instance.
  /// </summary>
  /// <remarks>
  /// This type alias specializes <c>TAsyncCallback</c> with <c>TLibrariesMain</c> as the
  /// result type. It is commonly used in non-blocking API calls such as
  /// <c>TLibrariesMainRoute.AsyncCreate</c>, <c>AsyncRetrieve</c>, or <c>AsyncUpdate</c>.
  /// <para>
  /// Handlers such as <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c> can be assigned
  /// to respond to the various stages of an asynchronous library operation.
  /// </para>
  /// </remarks>
  TAsyncLibrariesMain = TAsyncCallback<TLibrariesMain>;

  /// <summary>
  /// Represents a promise-based asynchronous handler for operations that return
  /// a <c>TLibrariesMain</c> instance.
  /// </summary>
  /// <remarks>
  /// This type alias specializes <c>TPromiseCallback</c> with <c>TLibrariesMain</c> as
  /// the result type. It is typically used with asynchronous workflows that follow a
  /// promise pattern, such as <c>TLibrariesMainRoute.AsyncAwaitCreate</c> or
  /// <c>AsyncAwaitUpdate</c>.
  /// <para>
  /// Using this type allows you to attach <c>OnSuccess</c> and <c>OnError</c> handlers
  /// in a chained style, simplifying non-blocking execution and result handling.
  /// </para>
  /// </remarks>
  TPromiseLibrariesMain = TPromiseCallback<TLibrariesMain>;

  /// <summary>
  /// Represents an asynchronous callback handler for operations that return
  /// a <c>TLibrariesMainList</c> instance.
  /// </summary>
  /// <remarks>
  /// This type alias specializes <c>TAsyncCallback</c> with <c>TLibrariesMainList</c>
  /// as the result type. It is typically used for non-blocking calls such as
  /// <c>TLibrariesMainRoute.AsyncList</c> to retrieve all libraries.
  /// <para>
  /// Assign event handlers like <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c>
  /// to respond to the different stages of the asynchronous operation.
  /// </para>
  /// </remarks>
  TAsyncLibrariesMainList = TAsyncCallback<TLibrariesMainList>;

  /// <summary>
  /// Represents a promise-based asynchronous handler for operations that return
  /// a <c>TLibrariesMainList</c> instance.
  /// </summary>
  /// <remarks>
  /// This type alias specializes <c>TPromiseCallback</c> with <c>TLibrariesMainList</c>
  /// as the result type. It is typically used with promise-oriented workflows,
  /// such as <c>TLibrariesMainRoute.AsyncAwaitList</c>, to retrieve all libraries.
  /// <para>
  /// This type allows attaching <c>OnSuccess</c> and <c>OnError</c> handlers in a
  /// chained style, making asynchronous code easier to manage compared to
  /// traditional callback patterns.
  /// </para>
  /// </remarks>
  TPromiseLibrariesMainList = TPromiseCallback<TLibrariesMainList>;

  TLibrariesMainRoute = class(TMistralAIAPIRoute)
    /// <summary>
    /// Asynchronously retrieves the list of document libraries and returns a promise
    /// that resolves with a <c>TLibrariesMainList</c> instance.
    /// </summary>
    /// <param name="Callbacks">
    /// An optional function that returns a <c>TPromiseLibrariesMainList</c> instance,
    /// allowing you to attach <c>OnSuccess</c> and <c>OnError</c> handlers in a
    /// promise-like style. If <c>nil</c>, no additional callbacks are registered.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TLibrariesMainList&gt;</c> that resolves with the list of
    /// libraries or rejects with an error if the operation fails.
    /// </returns>
    /// <remarks>
    /// Use this method when you want to perform a non-blocking call to retrieve all
    /// libraries, while benefiting from promise chaining and asynchronous error handling.
    /// </remarks>
    function AsyncAwaitList(
      const Callbacks: TFunc<TPromiseLibrariesMainList> = nil): TPromise<TLibrariesMainList>;

    /// <summary>
    /// Asynchronously creates a new document library and returns a promise
    /// that resolves with the resulting <c>TLibrariesMain</c> instance.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters of the new library
    /// through a <c>TLibrariesMainParams</c> instance (e.g., setting the
    /// name, description, and chunk size).
    /// </param>
    /// <param name="Callbacks">
    /// An optional function that returns a <c>TPromiseLibrariesMain</c> instance,
    /// allowing the assignment of <c>OnSuccess</c> and <c>OnError</c> handlers
    /// in a promise-like style. If <c>nil</c>, no additional callbacks are registered.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TLibrariesMain&gt;</c> that resolves with the newly
    /// created library or rejects with an error if the operation fails.
    /// </returns>
    /// <remarks>
    /// Use this method when you want to create a library in a non-blocking
    /// manner while benefiting from promise chaining for post-creation
    /// processing or error handling.
    /// </remarks>
    function AsyncAwaitCreate(
      const ParamProc: TProc<TLibrariesMainParams>;
      const Callbacks: TFunc<TPromiseLibrariesMain> = nil): TPromise<TLibrariesMain>;

    /// <summary>
    /// Asynchronously retrieves the details of a specific document library
    /// identified by its unique ID, and returns a promise that resolves
    /// with a <c>TLibrariesMain</c> instance.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library to retrieve.
    /// </param>
    /// <param name="Callbacks">
    /// An optional function that returns a <c>TPromiseLibrariesMain</c> instance,
    /// allowing you to attach <c>OnSuccess</c> and <c>OnError</c> handlers
    /// in a promise-like style. If <c>nil</c>, no additional callbacks are registered.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TLibrariesMain&gt;</c> that resolves with the requested
    /// library details or rejects with an error if the operation fails.
    /// </returns>
    /// <remarks>
    /// Use this method for non-blocking retrieval of a library’s metadata,
    /// particularly when integrating with asynchronous workflows.
    /// </remarks>
    function AsyncAwaitRetrieve(const LibraryId: string;
      const Callbacks: TFunc<TPromiseLibrariesMain> = nil): TPromise<TLibrariesMain>;

    /// <summary>
    /// Asynchronously deletes a specific document library identified by its unique ID,
    /// and returns a promise that resolves with the deleted <c>TLibrariesMain</c> instance.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library to delete.
    /// </param>
    /// <param name="Callbacks">
    /// An optional function that returns a <c>TPromiseLibrariesMain</c> instance,
    /// allowing you to attach <c>OnSuccess</c> and <c>OnError</c> handlers
    /// in a promise-like style. If <c>nil</c>, no additional callbacks are registered.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TLibrariesMain&gt;</c> that resolves with information
    /// about the deleted library or rejects with an error if the deletion fails.
    /// </returns>
    /// <remarks>
    /// Use this method to perform non-blocking deletions of libraries, typically in
    /// asynchronous workflows where promise chaining and error propagation are required.
    /// </remarks>
    function AsyncAwaitDelete(const LibraryId: string;
      const Callbacks: TFunc<TPromiseLibrariesMain> = nil): TPromise<TLibrariesMain>;

    /// <summary>
    /// Asynchronously updates the metadata of an existing document library identified
    /// by its unique ID, and returns a promise that resolves with the updated
    /// <c>TLibrariesMain</c> instance.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library to update.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure that configures the update parameters via a
    /// <c>TUpdateLibrariesMainParams</c> instance (e.g., updating the name or description).
    /// </param>
    /// <param name="Callbacks">
    /// An optional function that returns a <c>TPromiseLibrariesMain</c> instance,
    /// allowing you to attach <c>OnSuccess</c> and <c>OnError</c> handlers in a
    /// promise-like style. If <c>nil</c>, no additional callbacks are registered.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TLibrariesMain&gt;</c> that resolves with the updated library
    /// details or rejects with an error if the update operation fails.
    /// </returns>
    /// <remarks>
    /// Use this method for non-blocking updates of library metadata while benefiting
    /// from promise chaining and structured error handling.
    /// </remarks>
    function AsyncAwaitUpdate(const LibraryId: string;
      const ParamProc: TProc<TUpdateLibrariesMainParams>;
      const Callbacks: TFunc<TPromiseLibrariesMain> = nil): TPromise<TLibrariesMain>;

    /// <summary>
    /// Retrieves the list of all document libraries in a synchronous (blocking) manner.
    /// </summary>
    /// <returns>
    /// A <c>TLibrariesMainList</c> instance containing all libraries accessible
    /// within the current organization or context.
    /// </returns>
    /// <remarks>
    /// This method performs a blocking API call to fetch all libraries and their
    /// associated metadata. Use the asynchronous counterpart <c>AsyncList</c> or
    /// <c>AsyncAwaitList</c> for non-blocking operations.
    /// </remarks>
    function List: TLibrariesMainList;

    /// <summary>
    /// Creates a new document library in a synchronous (blocking) manner and returns
    /// the resulting <c>TLibrariesMain</c> instance.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the new library via a
    /// <c>TLibrariesMainParams</c> instance (e.g., setting name, description, or chunk size).
    /// </param>
    /// <returns>
    /// A <c>TLibrariesMain</c> instance representing the newly created library,
    /// including its unique ID and metadata.
    /// </returns>
    /// <remarks>
    /// This method performs a blocking API call. Use the asynchronous counterparts
    /// <c>AsyncCreate</c> or <c>AsyncAwaitCreate</c> if you need non-blocking behavior.
    /// An exception will be raised if the API call fails or if parameters are invalid.
    /// </remarks>
    function Create(const ParamProc: TProc<TLibrariesMainParams>): TLibrariesMain;

    /// <summary>
    /// Retrieves the details of a specific document library identified by its unique ID
    /// in a synchronous (blocking) manner.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library to retrieve.
    /// </param>
    /// <returns>
    /// A <c>TLibrariesMain</c> instance containing the metadata of the requested library,
    /// such as its name, description, creation date, and document statistics.
    /// </returns>
    /// <remarks>
    /// This method performs a blocking API call. Use <c>AsyncRetrieve</c> or
    /// <c>AsyncAwaitRetrieve</c> for non-blocking operations.
    /// An exception will be raised if the specified library ID does not exist
    /// or if the request fails.
    /// </remarks>
    function Retrieve(const LibraryId: string): TLibrariesMain;

    /// <summary>
    /// Deletes a specific document library identified by its unique ID in a synchronous
    /// (blocking) manner.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library to delete.
    /// </param>
    /// <returns>
    /// A <c>TLibrariesMain</c> instance representing the deleted library, including its
    /// metadata at the time of deletion.
    /// </returns>
    /// <remarks>
    /// This method performs a blocking API call to delete the library.
    /// Use <c>AsyncDelete</c> or <c>AsyncAwaitDelete</c> for non-blocking operations.
    /// An exception will be raised if the library ID is invalid, does not exist,
    /// or if the deletion fails due to permission issues.
    /// </remarks>
    function Delete(const LibraryId: string): TLibrariesMain;

    /// <summary>
    /// Updates the metadata of an existing document library identified by its unique ID
    /// in a synchronous (blocking) manner.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library to update.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure that configures the update parameters via a
    /// <c>TUpdateLibrariesMainParams</c> instance (e.g., modifying the library name or description).
    /// </param>
    /// <returns>
    /// A <c>TLibrariesMain</c> instance representing the updated library, including its
    /// new metadata after the update operation.
    /// </returns>
    /// <remarks>
    /// This method performs a blocking API call. Use <c>AsyncUpdate</c> or
    /// <c>AsyncAwaitUpdate</c> for non-blocking updates.
    /// An exception will be raised if the library ID is invalid, if no parameters are provided,
    /// or if the update operation fails due to permission issues.
    /// </remarks>
    function Update(const LibraryId: string;
      const ParamProc: TProc<TUpdateLibrariesMainParams>): TLibrariesMain;

    /// <summary>
    /// Asynchronously retrieves the list of all document libraries and triggers
    /// the specified callbacks at each stage of the operation.
    /// </summary>
    /// <param name="Callbacks">
    /// A function that returns a <c>TAsyncLibrariesMainList</c> instance,
    /// allowing you to assign <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c>
    /// event handlers to manage the lifecycle of the asynchronous call.
    /// </param>
    /// <remarks>
    /// This method performs a non-blocking retrieval of all libraries. Use
    /// <c>AsyncAwaitList</c> for a promise-based alternative that can be awaited.
    /// </remarks>
    procedure AsyncList(const Callbacks: TFunc<TAsyncLibrariesMainList>);

    /// <summary>
    /// Asynchronously creates a new document library and triggers the specified callbacks
    /// at each stage of the operation.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the new library through a
    /// <c>TLibrariesMainParams</c> instance (e.g., setting name, description, and chunk size).
    /// </param>
    /// <param name="Callbacks">
    /// A function that returns a <c>TAsyncLibrariesMain</c> instance, allowing you to
    /// assign <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c> event handlers
    /// to manage the lifecycle of the asynchronous call.
    /// </param>
    /// <remarks>
    /// This method performs a non-blocking library creation. Use <c>AsyncAwaitCreate</c>
    /// for a promise-based alternative.
    /// </remarks>
    procedure AsyncCreate(const ParamProc: TProc<TLibrariesMainParams>;
      const Callbacks: TFunc<TAsyncLibrariesMain>);

    /// <summary>
    /// Asynchronously retrieves the details of a specific document library
    /// identified by its unique ID and triggers the specified callbacks at
    /// each stage of the operation.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library to retrieve.
    /// </param>
    /// <param name="Callbacks">
    /// A function that returns a <c>TAsyncLibrariesMain</c> instance,
    /// allowing you to assign <c>OnStart</c>, <c>OnSuccess</c>, and
    /// <c>OnError</c> event handlers to manage the asynchronous call.
    /// </param>
    /// <remarks>
    /// This method performs a non-blocking retrieval of a library's metadata.
    /// Use <c>AsyncAwaitRetrieve</c> if you prefer a promise-based approach.
    /// </remarks>
    procedure AsyncRetrieve(const LibraryId: string;
      const Callbacks: TFunc<TAsyncLibrariesMain>);

    /// <summary>
    /// Asynchronously deletes a specific document library identified by its unique ID,
    /// and triggers the specified callbacks at each stage of the operation.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library to delete.
    /// </param>
    /// <param name="Callbacks">
    /// A function that returns a <c>TAsyncLibrariesMain</c> instance,
    /// allowing you to assign <c>OnStart</c>, <c>OnSuccess</c>, and
    /// <c>OnError</c> event handlers to manage the asynchronous call.
    /// </param>
    /// <remarks>
    /// This method performs a non-blocking deletion of a library.
    /// Use <c>AsyncA
    procedure AsyncDelete(const LibraryId: string;
      const Callbacks: TFunc<TAsyncLibrariesMain>);

    /// <summary>
    /// Asynchronously updates the metadata of an existing document library identified
    /// by its unique ID and triggers the specified callbacks at each stage of the operation.
    /// </summary>
    /// <param name="LibraryId">
    /// The unique identifier of the library to update.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure used to configure the update parameters via a
    /// <c>TUpdateLibrariesMainParams</c> instance (e.g., updating the name or description).
    /// </param>
    /// <param name="Callbacks">
    /// A function that returns a <c>TAsyncLibrariesMain</c> instance,
    /// allowing you to assign <c>OnStart</c>, <c>OnSuccess</c>, and
    /// <c>OnError</c> event handlers to manage the asynchronous call.
    /// </param>
    /// <remarks>
    /// This method performs a non-blocking update of library metadata.
    /// Use <c>AsyncAwaitUpdate</c> for a promise-based alternative.
    /// </remarks>
    procedure AsyncUpdate(const LibraryId: string;
      const ParamProc: TProc<TUpdateLibrariesMainParams>;
      const Callbacks: TFunc<TAsyncLibrariesMain>);
  end;

implementation

{ TLibrariesMainList }

destructor TLibrariesMainList.Destroy;
begin
  for var Item in FData do
    Item.Free;
  inherited;
end;

{ TLibrariesMainRoute }

function TLibrariesMainRoute.AsyncAwaitCreate(
  const ParamProc: TProc<TLibrariesMainParams>;
  const Callbacks: TFunc<TPromiseLibrariesMain>): TPromise<TLibrariesMain>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TLibrariesMain>(
    procedure(const CallbackParams: TFunc<TAsyncLibrariesMain>)
    begin
      AsyncCreate(ParamProc, CallbackParams);
    end,
    Callbacks);
end;

function TLibrariesMainRoute.AsyncAwaitDelete(const LibraryId: string;
  const Callbacks: TFunc<TPromiseLibrariesMain>): TPromise<TLibrariesMain>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TLibrariesMain>(
    procedure(const CallbackParams: TFunc<TAsyncLibrariesMain>)
    begin
      AsyncDelete(LibraryId, CallbackParams);
    end,
    Callbacks);
end;

function TLibrariesMainRoute.AsyncAwaitList(
  const Callbacks: TFunc<TPromiseLibrariesMainList>): TPromise<TLibrariesMainList>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TLibrariesMainList>(
    procedure(const CallbackParams: TFunc<TAsyncLibrariesMainList>)
    begin
      AsyncList(CallbackParams);
    end,
    Callbacks);
end;

function TLibrariesMainRoute.AsyncAwaitRetrieve(const LibraryId: string;
  const Callbacks: TFunc<TPromiseLibrariesMain>): TPromise<TLibrariesMain>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TLibrariesMain>(
    procedure(const CallbackParams: TFunc<TAsyncLibrariesMain>)
    begin
      AsyncRetrieve(LibraryId, CallbackParams);
    end,
    Callbacks);
end;

function TLibrariesMainRoute.AsyncAwaitUpdate(const LibraryId: string;
  const ParamProc: TProc<TUpdateLibrariesMainParams>;
  const Callbacks: TFunc<TPromiseLibrariesMain>): TPromise<TLibrariesMain>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TLibrariesMain>(
    procedure(const CallbackParams: TFunc<TAsyncLibrariesMain>)
    begin
      AsyncUpdate(LibraryId, ParamProc, CallbackParams);
    end,
    Callbacks);
end;

procedure TLibrariesMainRoute.AsyncCreate(
  const ParamProc: TProc<TLibrariesMainParams>;
  const Callbacks: TFunc<TAsyncLibrariesMain>);
begin
  with TAsyncCallBackExec<TAsyncLibrariesMain, TLibrariesMain>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TLibrariesMain
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TLibrariesMainRoute.AsyncDelete(const LibraryId: string;
  const Callbacks: TFunc<TAsyncLibrariesMain>);
begin
  with TAsyncCallBackExec<TAsyncLibrariesMain, TLibrariesMain>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TLibrariesMain
      begin
        Result := Self.Delete(LibraryId);
      end);
  finally
    Free;
  end;
end;

procedure TLibrariesMainRoute.AsyncList(
  const Callbacks: TFunc<TAsyncLibrariesMainList>);
begin
  with TAsyncCallBackExec<TAsyncLibrariesMainList, TLibrariesMainList>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TLibrariesMainList
      begin
        Result := Self.List;
      end);
  finally
    Free;
  end;
end;

procedure TLibrariesMainRoute.AsyncRetrieve(const LibraryId: string;
  const Callbacks: TFunc<TAsyncLibrariesMain>);
begin
  with TAsyncCallBackExec<TAsyncLibrariesMain, TLibrariesMain>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TLibrariesMain
      begin
        Result := Self.Retrieve(LibraryId);
      end);
  finally
    Free;
  end;
end;

procedure TLibrariesMainRoute.AsyncUpdate(const LibraryId: string;
  const ParamProc: TProc<TUpdateLibrariesMainParams>;
  const Callbacks: TFunc<TAsyncLibrariesMain>);
begin
  with TAsyncCallBackExec<TAsyncLibrariesMain, TLibrariesMain>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TLibrariesMain
      begin
        Result := Self.Update(LibraryId, ParamProc);
      end);
  finally
    Free;
  end;
end;

function TLibrariesMainRoute.Create(
  const ParamProc: TProc<TLibrariesMainParams>): TLibrariesMain;
begin
  Result := API.Post<TLibrariesMain, TLibrariesMainParams>('libraries', ParamProc);
end;

function TLibrariesMainRoute.Delete(const LibraryId: string): TLibrariesMain;
begin
  Result := API.Delete<TLibrariesMain>('libraries/' + LibraryId);
end;

function TLibrariesMainRoute.List: TLibrariesMainList;
begin
  Result := API.Get<TLibrariesMainList>('libraries');
end;

function TLibrariesMainRoute.Retrieve(const LibraryId: string): TLibrariesMain;
begin
  Result := API.Get<TLibrariesMain>('libraries/' + LibraryId);
end;

function TLibrariesMainRoute.Update(const LibraryId: string;
  const ParamProc: TProc<TUpdateLibrariesMainParams>): TLibrariesMain;
begin
  Result := API.Put<TLibrariesMain, TUpdateLibrariesMainParams>('libraries/' + LibraryId, ParamProc);
end;

{ TLibrariesMainParams }

function TLibrariesMainParams.ChunkSize(
  const Value: Integer): TLibrariesMainParams;
begin
  Result := TLibrariesMainParams(Add('chunk_size', Value));
end;

function TLibrariesMainParams.Description(
  const Value: string): TLibrariesMainParams;
begin
  Result := TLibrariesMainParams(Add('description', Value));
end;

function TLibrariesMainParams.Name(const Value: string): TLibrariesMainParams;
begin
  Result := TLibrariesMainParams(Add('name', Value));
end;

{ TUpdateLibrariesMainParams }

function TUpdateLibrariesMainParams.Description(
  const Value: string): TUpdateLibrariesMainParams;
begin
  Result := TUpdateLibrariesMainParams(Add('description', Value));
end;

function TUpdateLibrariesMainParams.Name(
  const Value: string): TUpdateLibrariesMainParams;
begin
  Result := TUpdateLibrariesMainParams(Add('name', Value));
end;

end.

unit MistralAI.Models;

{-------------------------------------------------------------------------------

      Github repository : https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Threading, REST.Json.Types,
  MistralAI.API.Params, MistralAI.API, MistralAI.Async.Support,
  MistralAI.Async.Promise;

type
  /// <summary>
  /// The TModelParams class is used to specify parameters for updating the properties
  /// of a fine-tuned model in the MistralAI environment. It allows you to set new values
  /// for the model's name and  description.
  /// </summary>
  /// <remarks>
  /// This class provides a fluent interface for configuring model parameters before
  /// submitting an update request. The Name and Description methods allow you to set
  /// these attributes individually and return the updated TModelParams object, enabling
  /// method chaining for concise configuration.
  /// </remarks>
  TModelParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets a new name for the fine-tuned model.
    /// </summary>
    /// <param name="Value">The new name to assign to the model.</param>
    /// <returns>Returns the updated TModelParams object.</returns>
    /// <remarks>
    /// The name specified here should be a human-readable identifier for the model.
    /// It is not to be confused with the model's unique ID, which remains constant
    /// and is used for API operations. Changing the name only affects the metadata
    /// of the model.
    /// </remarks>
    function Name(const Value: string): TModelParams;

    /// <summary>
    /// Sets a new description for the fine-tuned model.
    /// </summary>
    /// <param name="Value">The new description to assign to the model.</param>
    /// <returns>Returns the updated TModelParams object.</returns>
    /// <remarks>
    /// Use this method to provide a detailed explanation of the model's purpose,
    /// capabilities, or any other relevant information. This description is useful
    /// for documentation purposes and for understanding the context in which the
    /// model is intended to be used.
    /// </remarks>
    function Description(const Value: string): TModelParams;
  end;

  /// <summary>
  /// The TCapabilities class represents the various features and functionalities
  /// that a MistralAI model can support. It indicates whether the model is capable of
  /// performing specific tasks such as chat completion, function calling, or fine-tuning.
  /// </summary>
  /// <remarks>
  /// This class is used to describe the capabilities of a model, helping users
  /// to understand what operations can be performed with the model. Each property
  /// corresponds to a specific capability, which can be checked to see if the model
  /// supports that feature. This information is typically used when selecting or
  /// configuring models for specific use cases.
  /// </remarks>
  TCapabilities = class
  private
    [JsonNameAttribute('completion_chat')]
    FCompletionChat: Boolean;
    [JsonNameAttribute('completion_fim')]
    FCompletionFim: Boolean;
    [JsonNameAttribute('function_calling')]
    FFunctionCalling: Boolean;
    [JsonNameAttribute('fine_tuning')]
    FFineTuning: Boolean;
    FVision: Boolean;
  public
    /// <summary>
    /// Indicates whether the model supports chat-based completions.
    /// </summary>
    /// <remarks>
    /// If True, the model can be used in applications that involve conversational
    /// agents or chatbots. This capability is crucial for creating interactive
    /// dialogue systems and enhancing user engagement through natural language
    /// interactions.
    /// </remarks>
    property CompletionChat: Boolean read FCompletionChat write FCompletionChat;

    /// <summary>
    /// Indicates whether the model supports "Fill-in-the-Middle" (FIM) completions.
    /// </summary>
    /// <remarks>
    /// FIM capabilities enable the model to generate text by filling in the blanks
    /// within a given context, which is useful for advanced text editing, code
    /// completion, and other scenarios where context-aware suggestions are needed.
    /// </remarks>
    property CompletionFim: Boolean read FCompletionFim write FCompletionFim;

    /// <summary>
    /// Indicates whether the model supports function calling.
    /// </summary>
    /// <remarks>
    /// If True, the model can trigger and call predefined functions based on
    /// the input it receives. This feature is particularly useful for building
    /// applications that require integration with external services or dynamic
    /// behaviors triggered by user input.
    /// </remarks>
    property FunctionCalling: Boolean read FFunctionCalling write FFunctionCalling;

    /// <summary>
    /// Indicates whether the model supports fine-tuning.
    /// </summary>
    /// <remarks>
    /// Fine-tuning allows the model to be further trained on specific datasets to
    /// improve its performance in specialized tasks. This capability is essential
    /// for customizing the model to better suit particular applications or domains.
    /// </remarks>
    property FineTuning: Boolean read FFineTuning write FFineTuning;

    /// <summary>
    /// Indicates whether the model supports vision.
    /// </summary>
    property Vision: Boolean read FVision write FVision;
  end;

  /// <summary>
  /// The TCoreModel class represents a generic model object that can be used with the MistralAI API.
  /// It contains all the essential properties and metadata required to describe a model, including
  /// its identifier, creation date, capabilities, and other attributes.
  /// </summary>
  /// <remarks>
  /// This class serves as the base class for more specific model types and provides a comprehensive
  /// view of a model's characteristics. The properties in this class are primarily used for
  /// interacting with the MistralAI API and retrieving model metadata. It is designed to be
  /// extended by other classes that represent more specialized model types.
  /// </remarks>
  TCoreModel = class(TJSONFingerprint)
  private
    FId: string;
    FObject: string;
    FCreated: Int64;
    [JsonNameAttribute('owned_by')]
    FOwnedBy: string;
    FCapabilities: TCapabilities;
    FName: string;
    FDescription: string;
    [JsonNameAttribute('max_context_length')]
    FMaxContextLength: Int64;
    FAliases: TArray<string>;
  public
    /// <summary>
    /// The unique identifier of the model, used to reference the model in API operations.
    /// </summary>
    /// <remarks>
    /// This ID is a unique string that remains constant throughout the model's lifecycle.
    /// It is used to identify the model in API calls such as retrieving details or performing
    /// actions like updating or deleting the model.
    /// </remarks>
    property Id: string read FId write FId;

    /// <summary>
    /// The type of the object, which is always set to "model" for model instances.
    /// </summary>
    /// <remarks>
    /// This property indicates the type of object being represented. It is used internally
    /// by the API to differentiate between different types of entities.
    /// </remarks>
    property &Object: string read FObject write FObject;

    /// <summary>
    /// The Unix timestamp (in seconds) representing when the model was created.
    /// </summary>
    /// <remarks>
    /// This timestamp is useful for tracking the model's age and for auditing purposes.
    /// It can be used to determine when the model was first made available in the MistralAI
    /// environment.
    /// </remarks>
    property Created: Int64 read FCreated write FCreated;

    /// <summary>
    /// The owner of the model, typically represented as a user or organization.
    /// </summary>
    /// <remarks>
    /// This property shows who has ownership of the model. Ownership can affect
    /// permissions and accessibility, especially in shared environments.
    /// </remarks>
    property OwnedBy: string read FOwnedBy write FOwnedBy;

    /// <summary>
    /// Represents the capabilities of the model, such as whether it supports fine-tuning or chat-based completion.
    /// </summary>
    /// <remarks>
    /// The capabilities provide a quick overview of what the model can do. Each capability is
    /// represented as a boolean value, indicating whether the model supports that feature. This
    /// information is essential for determining the suitability of the model for specific tasks.
    /// </remarks>
    property Capabilities: TCapabilities read FCapabilities write FCapabilities;

    /// <summary>
    /// The name of the model, which is used for display and identification purposes.
    /// </summary>
    /// <remarks>
    /// The name is a human-readable string that helps to identify the model. It is not
    /// unique and can be modified as needed without affecting the model's functionality.
    /// </remarks>
    property Name: string read FName write FName;

    /// <summary>
    /// A detailed description of the model, providing information about its purpose, capabilities, and other relevant details.
    /// </summary>
    /// <remarks>
    /// The description helps users understand what the model is designed to do, its intended
    /// use cases, and any special characteristics. It is especially useful for documentation
    /// and communication within teams.
    /// </remarks>
    property Description: string read FDescription write FDescription;

    /// <summary>
    /// The maximum context length that the model can handle.
    /// </summary>
    /// <remarks>
    /// This value represents the maximum number of tokens or characters that the model can process
    /// in a single request. It is an important parameter to consider when working with large inputs,
    /// as exceeding this limit may result in truncated responses or errors.
    /// </remarks>
    property MaxContextLength: Int64 read FMaxContextLength write FMaxContextLength;

    /// <summary>
    /// An array of alternative names or aliases for the model.
    /// </summary>
    /// <remarks>
    /// Aliases provide additional identifiers for the model, which can be useful in scenarios
    /// where multiple names are used to reference the same model. This property helps in
    /// maintaining consistency and flexibility in model references.
    /// </remarks>
    property Aliases: TArray<string> read FAliases write FAliases;

    /// <summary>
    /// Destructor to clean up allocated resources.
    /// </summary>
    /// <remarks>
    /// This destructor ensures that all dynamically allocated objects and resources associated
    /// with the TCoreModel instance are properly released, preventing memory leaks.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// The TModel class extends TCoreModel to include additional information about
  /// the model's deprecation status. It inherits all the properties of TCoreModel
  /// and adds a field to track when the model is considered deprecated.
  /// </summary>
  /// <remarks>
  /// This class is used to represent models that are still available in the MistralAI environment
  /// but are marked as deprecated. Deprecation indicates that the model may no longer be supported
  /// in future versions, and users are encouraged to migrate to newer models if possible.
  /// This class is particularly useful for managing model lifecycles and ensuring that applications
  /// do not rely on outdated or unsupported models.
  /// </remarks>
  TModel = class(TCoreModel)
  private
    [JsonNameAttribute('deprecation')]
    FDeprecation: string;
    [JsonNameAttribute('default_model_temperature')]
    FDefaultModelTemperature: Double;
    FType: string;
  public
    /// <summary>
    /// Indicates the deprecation date of the model as a string.
    /// </summary>
    /// <remarks>
    /// This property provides the date or version at which the model was deprecated.
    /// Deprecation means that the model is no longer recommended for use and may be
    /// removed or become unsupported in the future. Applications using deprecated
    /// models should plan to transition to updated models to maintain compatibility
    /// and support.
    /// </remarks>
    property Deprecation: string read FDeprecation write FDeprecation;

    /// <summary>
    /// Value of the default temperature for the model.
    /// </summary>
    property DefaultModelTemperature: Double read FDefaultModelTemperature write FDefaultModelTemperature;

    /// <summary>
    /// Type of model, Enum: base, fine-tuned
    /// </summary>
    /// <remarks>
    /// base is the default value
    /// </remarks>
    property &Type: string read FType write FType;
  end;

  /// <summary>
  /// The TFineTunedModel class extends the TCoreModel class to represent a fine-tuned model
  /// within the MistralAI environment. It includes additional information specific to the
  /// fine-tuning process, such as the job identifier associated with the fine-tuning operation.
  /// </summary>
  /// <remarks>
  /// This class is used to manage and interact with fine-tuned models, which are variants of
  /// base models that have been further trained on specific datasets to improve performance
  /// in specialized tasks. It inherits all properties from TCoreModel and adds specific
  /// attributes related to the fine-tuning process.
  /// </remarks>
  TFineTunedModel = class(TCoreModel)
  private
    FRoot: string;
    [JsonNameAttribute('job')]
    FJob: string;
    FArchived: Boolean;
  public
    /// <summary>
    /// Model uses for fine-tuning
    /// </summary>
    property Root: string read FRoot write FRoot;

    /// <summary>
    /// The identifier of the job associated with the fine-tuning process.
    /// </summary>
    /// <remarks>
    /// The Job property represents the ID of the fine-tuning task that created or modified
    /// the model. This ID can be used to track the details of the fine-tuning operation,
    /// such as the dataset used, training parameters, and performance metrics. It is
    /// particularly useful for auditing purposes and for understanding the history of the model.
    /// </remarks>
    property Job: string read FJob write FJob;

    /// <summary>
    /// Return True when the model is archived.
    /// </summary>
    property Archived: Boolean read FArchived write FArchived;
  end;

  /// <summary>
  /// The TModels class represents a collection of available models in the MistralAI environment.
  /// It provides basic information about each model, including the owner and availability,
  /// allowing users to list and inspect the models they have access to.
  /// </summary>
  /// <remarks>
  /// This class serves as a container for multiple `TModel` instances, each representing
  /// a different model. It is primarily used to retrieve a comprehensive list of models
  /// from the MistralAI API, and it can be helpful for applications that need to display
  /// or manage multiple models at once.
  /// </remarks>
  TModels = class(TJSONFingerprint)
  private
    [JsonNameAttribute('object')]
    FObject: string;
    [JsonNameAttribute('data')]
    FData: TArray<TModel>;
  public
    /// <summary>
    /// The type of the object, typically "list" for collections.
    /// </summary>
    /// <remarks>
    /// This property indicates the type of the object represented by the class instance.
    /// For collections like `TModels`, it is usually set to "list", signifying that the
    /// object contains a list of other objects, in this case, models.
    /// </remarks>
    property &Object: string read FObject write FObject;

    /// <summary>
    /// An array of `TModel` objects, each representing an individual model.
    /// </summary>
    /// <remarks>
    /// This property contains the data returned by the API, which is a list of models
    /// that are currently available. Each model in the array provides detailed information
    /// about its properties, capabilities, and ownership. This property is essential for
    /// accessing the complete set of models in a structured format.
    /// </remarks>
    property Data: TArray<TModel> read FData write FData;

    /// <summary>
    /// Destructor to clean up allocated resources.
    /// </summary>
    /// <remarks>
    /// This destructor ensures that all dynamically allocated objects and resources associated
    /// with the `TModels` instance are properly released, preventing memory leaks.
    /// It also frees each `TModel` object contained in the `Data` array.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// The TModelDeletion class manages the data returned after the successful deletion
  /// of a fine-tuned model in the MistralAI environment. It contains information
  /// about the model that was deleted, such as its ID and deletion status.
  /// </summary>
  /// <remarks>
  /// This class is used to capture the result of a model deletion request.
  /// It provides confirmation that the specified model has been successfully deleted
  /// from the system. This information is important for auditing and tracking purposes,
  /// especially in environments where model management and lifecycle tracking are critical.
  /// </remarks>
  TModelDeletion = class
  private
    FId: string;
    FObject: string;
    FDeleted: Boolean;
  public
    /// <summary>
    /// The ID of the fine-tuned model that was deleted.
    /// </summary>
    /// <remarks>
    /// This ID uniquely identifies the model that was removed from the system.
    /// It can be used to verify which model was deleted, particularly when managing
    /// multiple models or when logging deletion activities for compliance purposes.
    /// </remarks>
    property Id: string read FId write FId;

    /// <summary>
    /// The type of the object that was deleted, which is always "model" for model deletions.
    /// </summary>
    /// <remarks>
    /// This property confirms that the deleted object was a model. It is used internally
    /// by the API to verify the type of entity that was removed, ensuring that the correct
    /// object type was deleted.
    /// </remarks>
    property &Object: string read FObject write FObject;

    /// <summary>
    /// Indicates whether the model was successfully deleted.
    /// </summary>
    /// <remarks>
    /// If True, the model has been successfully deleted from the MistralAI environment.
    /// This flag serves as confirmation that the deletion operation completed without
    /// errors, and the model is no longer available in the system.
    /// </remarks>
    property Deleted: Boolean read FDeleted write FDeleted;
  end;

  /// <summary>
  /// The TArchivingModel class represents the state of a fine-tuned model in terms of its
  /// archiving status. It is used to track whether a model has been archived or unarchived
  /// within the MistralAI environment.
  /// </summary>
  /// <remarks>
  /// This class is primarily used for operations that involve archiving or unarchiving models.
  /// Archiving a model makes it inactive, while unarchiving restores it to an active state.
  /// The class provides properties to check the current state and to identify the model being
  /// affected.
  /// </remarks>
  TArchivingModel = class
  private
    FId: string;
    FObject: string;
    FArchived: Boolean;
  public
    /// <summary>
    /// The unique identifier of the fine-tuned model to be archived or unarchived.
    /// </summary>
    /// <remarks>
    /// This ID is used to reference the model in archiving operations. It is essential
    /// for identifying the specific model whose state is being changed. Ensure that the
    /// correct ID is provided when performing archiving or unarchiving actions to avoid
    /// unintentional changes to other models.
    /// </remarks>
    property Id: string read FId write FId;

    /// <summary>
    /// The type of the object, which is always set to "model" for models being archived or unarchived.
    /// </summary>
    /// <remarks>
    /// This property indicates the type of the entity involved in the operation. For all models,
    /// this value will be "model", confirming that the object being archived or unarchived is indeed
    /// a model and not another type of entity.
    /// </remarks>
    property &Object: string read FObject write FObject;

    /// <summary>
    /// Indicates whether the model is currently archived.
    /// </summary>
    /// <remarks>
    /// If True, the model is archived and not available for use. If False, the model is active and
    /// can be used normally. This property helps in tracking the current state of the model and is
    /// particularly useful for managing large sets of models where some may be inactive.
    /// </remarks>
    property Archived: Boolean read FArchived write FArchived;
  end;

  /// <summary>
  /// Represents an asynchronous callback parameter for retrieving details of a specific model.
  /// </summary>
  /// <remarks>
  /// This type is used when performing asynchronous operations to fetch detailed information
  /// about a specific model. It allows for handling the response containing the model's metadata
  /// and capabilities in a non-blocking fashion. This is particularly useful for updating UI elements
  /// or triggering additional actions based on the model's properties.
  /// </remarks>
  TAsynModel = TAsyncCallback<TModel>;

  /// <summary>
  /// Defines a promise-based asynchronous callback that resolves with a <c>TModel</c> instance.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TPromiseCallBack&lt;TModel&gt;</c> allows consumers to await the
  /// result of a model-retrieval operation in a promise-style workflow, handling success
  /// or failure through Callback rather than blocking the calling thread.
  /// </remarks>
  TPromiseModel = TPromiseCallback<TModel>;

  /// <summary>
  /// Represents an asynchronous callback parameter for retrieving a list of models.
  /// </summary>
  /// <remarks>
  /// This type is used when performing asynchronous operations to list models in the
  /// MistralAI environment. It enables the handling of the response containing a collection
  /// of models through a callback mechanism, facilitating non-blocking data retrieval.
  /// </remarks>
  TAsynModels = TAsyncCallback<TModels>;

  /// <summary>
  /// Defines a promise-based asynchronous callback that resolves with a <c>TModels</c> collection.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TPromiseCallBack&lt;TModels&gt;</c> enables a promise-style workflow
  /// for listing models, allowing consumers to handle the returned collection asynchronously
  /// without blocking the calling thread.
  /// </remarks>
  TPromiseModels = TPromiseCallback<TModels>;

  /// <summary>
  /// Represents an asynchronous callback parameter for model deletion operations.
  /// </summary>
  /// <remarks>
  /// This type is used when performing asynchronous delete operations on a model. It
  /// allows the handling of the response which indicates the status of the deletion request.
  /// This type is essential for managing deletion results in a non-blocking manner, enabling
  /// efficient UI updates or further processing based on the deletion status.
  /// </remarks>
  TAsynModelDeletion = TAsyncCallback<TModelDeletion>;

  /// <summary>
  /// Defines a promise-based asynchronous callback that resolves with a <c>TModelDeletion</c> result.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TPromiseCallBack&lt;TModelDeletion&gt;</c> allows consumers to await
  /// the result of a model deletion operation using a promise-style API, handling success
  /// or error scenarios without blocking the calling thread.
  /// </remarks>
  TPromiseModelDeletion = TPromiseCallback<TModelDeletion>;

  /// <summary>
  /// Represents an asynchronous callback parameter for updating a fine-tuned model.
  /// </summary>
  /// <remarks>
  /// This type is used during asynchronous update operations on fine-tuned models. It enables
  /// handling the response, which contains the updated model details, through a callback mechanism.
  /// This is useful for reflecting changes in the user interface or performing further processing
  /// based on the updated model information.
  /// </remarks>
  TAsynFineTuneModel = TAsyncCallback<TFineTunedModel>;

  /// <summary>
  /// Defines a promise-based asynchronous callback that resolves with a <c>TFineTunedModel</c> instance.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TPromiseCallBack&lt;TFineTunedModel&gt;</c> enables a promise-style workflow
  /// for retrieving the result of a fine-tune operation, allowing consumers to handle the updated
  /// model or any errors asynchronously without blocking the calling thread.
  /// </remarks>
  TPromiseFineTuneModel = TPromiseCallback<TFineTunedModel>;

  /// <summary>
  /// Represents an asynchronous callback parameter for archiving or unarchiving a model.
  /// </summary>
  /// <remarks>
  /// This type is used when performing asynchronous archiving or unarchiving operations on a model.
  /// It allows handling the response, which indicates the status of the operation, in a non-blocking manner.
  /// This type is essential for updating the state of the model in the application without blocking the main thread.
  /// </remarks>
  TAsynArchivingModel = TAsyncCallback<TArchivingModel>;

  /// <summary>
  /// Defines a promise-based asynchronous callback that resolves with a <c>TArchivingModel</c> result.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TPromiseCallBack&lt;TArchivingModel&gt;</c> enables a promise-style workflow
  /// for archiving or unarchiving operations, allowing consumers to handle the archiving status
  /// asynchronously without blocking the calling thread.
  /// </remarks>
  TPromiseArchivingModel = TPromiseCallback<TArchivingModel>;

  /// <summary>
  /// The TModelsRoute class provides various methods for managing Large Language Models (LLMs)
  /// through MistralAI's API. It offers both synchronous and asynchronous methods to list, retrieve,
  /// delete, update, archive, and un-archive models.
  /// </summary>
  /// <remarks>
  /// This class is designed to interact with the MistralAI API to facilitate management operations
  /// on models. It supports fine-tuning models as well as handling models' metadata and status.
  /// Each method provides detailed interaction with the API, ensuring efficient model management.
  /// </remarks>
  TModelsRoute = class(TMistralAIAPIRoute)
  public
    /// <summary>
    /// Returns a promise that resolves to the full collection of available models.
    /// </summary>
    /// <param name="Callback">
    /// Optional promise-style Callback for handling success or failure of the list operation.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TModels&gt;</c> that resolves with the <c>TModels</c> instance containing
    /// the list of all models, or rejects with an exception on error.
    /// </returns>
    /// <remarks>
    /// This method wraps the <see cref="AsyncList"/> callback pattern in a promise-based API,
    /// simplifying asynchronous model listing by allowing consumers to <c>await</c> the result
    /// rather than managing Callback directly.
    /// </remarks>
    function AsyncAwaitList(
      const Callback: TFunc<TPromiseModels> = nil): TPromise<TModels>;

    /// <summary>
    /// Returns a promise that resolves when the specified model has been deleted.
    /// </summary>
    /// <param name="ModelId">
    /// The unique identifier of the model to delete.
    /// </param>
    /// <param name="Callback">
    /// Optional promise-style Callback for handling success or failure of the delete operation.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TModelDeletion&gt;</c> that resolves with the <c>TModelDeletion</c> result
    /// indicating deletion success, or rejects with an exception on error.
    /// </returns>
    /// <remarks>
    /// This method wraps the <see cref="AsyncDelete"/> callback pattern in a promise-based API,
    /// allowing consumers to <c>await</c> the deletion result instead of managing Callback directly.
    /// </remarks>
    function AsyncAwaitDelete(const ModelId: string;
      const Callback: TFunc<TPromiseModelDeletion> = nil): TPromise<TModelDeletion>;

    /// <summary>
    /// Returns a promise that resolves with the details of the specified model.
    /// </summary>
    /// <param name="ModelId">
    /// The unique identifier of the model to retrieve.
    /// </param>
    /// <param name="Callback">
    /// Optional promise-style Callback for handling success or failure of the retrieve operation.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TModel&gt;</c> that resolves with the <c>TModel</c> instance containing
    /// the model’s metadata, or rejects with an exception on error.
    /// </returns>
    /// <remarks>
    /// This method wraps the <see cref="AsyncRetrieve"/> callback pattern in a promise-based API,
    /// enabling consumers to <c>await</c> the retrieval result instead of managing Callback directly.
    /// </remarks>
    function AsyncAwaitRetrieve(const ModelId: string;
      const Callback: TFunc<TPromiseModel> = nil): TPromise<TModel>;

    /// <summary>
    /// Returns a promise that resolves with the updated fine-tuned model.
    /// </summary>
    /// <param name="ModelId">
    /// The unique identifier of the fine-tuned model to update.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TModelParams</c> containing the new name or description.
    /// </param>
    /// <param name="Callback">
    /// Optional promise-style Callback for handling success or failure of the update operation.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TFineTunedModel&gt;</c> that resolves with the <c>TFineTunedModel</c>
    /// instance reflecting the updated model details, or rejects with an exception on error.
    /// </returns>
    /// <remarks>
    /// This method wraps the <see cref="AsyncUpdate"/> callback pattern in a promise-based API,
    /// allowing consumers to <c>await</c> the update result rather than managing Callback directly.
    /// </remarks>
    function AsyncAwaitUpdate(const ModelId: string;
      const ParamProc: TProc<TModelParams>;
      const Callback: TFunc<TPromiseFineTuneModel> = nil): TPromise<TFineTunedModel>;

    /// <summary>
    /// Returns a promise that resolves with the archiving status of the specified model.
    /// </summary>
    /// <param name="ModelId">
    /// The unique identifier of the fine-tuned model to archive.
    /// </param>
    /// <param name="Callback">
    /// Optional promise-style Callback for handling success or failure of the archive operation.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TArchivingModel&gt;</c> that resolves with the <c>TArchivingModel</c>
    /// result indicating the model’s archived state, or rejects with an exception on error.
    /// </returns>
    /// <remarks>
    /// This method wraps the <see cref="AsyncArchive"/> callback pattern in a promise-based API,
    /// enabling consumers to <c>await</c> the archiving result instead of managing Callback directly.
    /// </remarks>
    function AsyncAwaitArchive(const ModelId: string;
      const Callback: TFunc<TPromiseArchivingModel> = nil): TPromise<TArchivingModel>;

    /// <summary>
    /// Returns a promise that resolves with the un-archiving status of the specified model.
    /// </summary>
    /// <param name="ModelId">
    /// The unique identifier of the fine-tuned model to un-archive.
    /// </param>
    /// <param name="Callback">
    /// Optional promise-style Callback for handling success or failure of the un-archive operation.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TArchivingModel&gt;</c> that resolves with the <c>TArchivingModel</c>
    /// result indicating the model’s active state, or rejects with an exception on error.
    /// </returns>
    /// <remarks>
    /// This method wraps the <see cref="AsyncUnarchive"/> callback pattern in a promise-based API,
    /// allowing consumers to <c>await</c> the un-archiving result instead of managing Callback directly.
    /// </remarks>
    function AsyncAwaitUnarchive(const ModelId: string;
      const Callback: TFunc<TPromiseArchivingModel> = nil): TPromise<TArchivingModel>;

    /// <summary>
    /// Asynchronously lists the currently available models.
    /// </summary>
    /// <param name="Callback">A callback function that receives the list of models asynchronously.</param>
    /// <remarks>
    /// Use this method to get a list of all models available in the MistralAI environment.
    /// This is useful for obtaining an overview of the models you have access to.
    ///
    /// <code>
    ///  MistralAI.Models.AsyncList(
    ///     function : TAsynModels
    ///     begin
    ///       Result.OnSuccess :=
    ///         procedure (Sender: TObject; List: TModels)
    ///         begin
    ///           // Handle List
    ///         end
    ///     end);
    /// </code>
    /// </remarks>
    procedure AsyncList(const Callback: TFunc<TAsynModels>);

    /// <summary>
    /// Asynchronously deletes a fine-tuned model.
    /// </summary>
    /// <param name="ModelId">The ID of the fine-tuned model to be deleted.</param>
    /// <param name="Callback">A callback function that receives the deletion status asynchronously.</param>
    /// <remarks>
    /// Deleting a model is a permanent action. Use this method with caution, as it will remove
    /// the model and its metadata from the MistralAI environment.
    ///
    /// <code>
    ///  MistralAI.Models.AsyncDelete( ModelId,
    ///     function : TAsynModelDeletion
    ///     begin
    ///       Result.OnSuccess :=
    ///         procedure (Sender: TObject; Model: TModels)
    ///         begin
    ///           //Handle success
    ///         end
    ///     end);
    /// </code>
    /// </remarks>
    procedure AsyncDelete(const ModelId: string; const Callback: TFunc<TAsynModelDeletion>);

    /// <summary>
    /// Asynchronously retrieves the details of a model.
    /// </summary>
    /// <param name="ModelId">The ID of the model to be retrieved.</param>
    /// <param name="Callback">A callback function that receives the model details asynchronously.</param>
    /// <remarks>
    /// This method is useful for fetching detailed information about a specific model,
    /// including its metadata, capabilities, and current status.
    ///
    /// <code>
    ///  MistralAI.Models.AsyncRetrieve( ModelId,
    ///     function : TAsynModel
    ///     begin
    ///       Result.OnSuccess :=
    ///         procedure (Sender: TObject; Model: TModel)
    ///         begin
    ///           //Handle success
    ///         end
    ///     end);
    /// </code>
    /// </remarks>
    procedure AsyncRetrieve(const ModelId: string; const Callback: TFunc<TAsynModel>);

    /// <summary>
    /// Asynchronously updates the details of a fine-tuned model.
    /// </summary>
    /// <param name="ModelId">The ID of the fine-tuned model to be updated.</param>
    /// <param name="ParamProc">A procedure that specifies the parameters to be updated.</param>
    /// <param name="Callback">A callback function that receives the updated model details asynchronously.</param>
    /// <remarks>
    /// Use this method to change the name or description of a fine-tuned model. Ensure that the
    /// provided parameters are valid, as incorrect data might result in unexpected behavior.
    ///
    /// <code>
    ///  MistralAI.Models.AsyncUpdate( ModelId,
    ///     procedure (Params: TModelParams)
    ///     begin
    ///       // Define updating params
    ///     end,
    ///     function : TAsynFineTuneModel
    ///     begin
    ///       Result.OnSuccess :=
    ///         procedure (Sender: TObject; Model: TFineTunedModel)
    ///         begin
    ///           //Handle success
    ///         end
    ///     end);
    /// </code>
    /// </remarks>
    procedure AsyncUpdate(const ModelId: string; const ParamProc: TProc<TModelParams>;
      const Callback: TFunc<TAsynFineTuneModel>);

    /// <summary>
    /// Asynchronously archives a fine-tuned model.
    /// </summary>
    /// <param name="ModelId">The ID of the fine-tuned model to be archived.</param>
    /// <param name="Callback">A callback function that receives the archiving status asynchronously.</param>
    /// <remarks>
    /// Archiving a model will make it unavailable for use. This is typically used to manage
    /// storage or to keep the model's state intact while it is not actively in use.
    ///
    /// <code>
    ///  MistralAI.Models.AsyncArchive( ModelId,
    ///     function : TAsynArchivingModel
    ///     begin
    ///       Result.OnSuccess :=
    ///         procedure (Sender: TObject; Model: TArchivingModel)
    ///         begin
    ///           //Handle success
    ///         end
    ///     end);
    /// </code>
    /// </remarks>
    procedure AsyncArchive(const ModelId: string; const Callback: TFunc<TAsynArchivingModel>);

    /// <summary>
    /// Asynchronously un-archives a fine-tuned model.
    /// </summary>
    /// <param name="ModelId">The ID of the fine-tuned model to be un-archived.</param>
    /// <param name="Callback">A callback function that receives the un-archiving status asynchronously.</param>
    /// <remarks>
    /// Un-archiving a model will restore it to an active state, making it available for use again.
    /// This is typically used for bringing back models that were previously archived.
    ///
    ///  <code>
    ///  MistralAI.Models.AsyncUnarchive( ModelId,
    ///     function : TAsynArchivingModel
    ///     begin
    ///       Result.OnSuccess :=
    ///         procedure (Sender: TObject; Model: TArchivingModel)
    ///         begin
    ///           //Handle success
    ///         end
    ///     end);
    /// </code>
    /// </remarks>
    procedure AsyncUnarchive(const ModelId: string; const Callback: TFunc<TAsynArchivingModel>);

    /// <summary>
    /// Lists the currently available models.
    /// </summary>
    /// <returns>Returns a list of currently available models.</returns>
    /// <remarks>
    /// This method provides a synchronous way to fetch all models in the MistralAI environment.
    /// It is useful for applications where synchronous data access is required.
    /// <code>
    ///   var Models := MistralAI.Models.List;
    ///   try
    ///     // List processing
    ///   finally
    ///     Models.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function List: TModels;

    /// <summary>
    /// Deletes a fine-tuned model.
    /// </summary>
    /// <param name="ModelId">The ID of the fine-tuned model to be deleted.</param>
    /// <returns>Returns the deletion status of the model.</returns>
    /// <remarks>
    /// Deleting a fine-tuned model removes it permanently from the MistralAI environment.
    /// This action cannot be undone, so use it with caution.
    /// <code>
    ///   with MistralAI.Models.Delete('ModelId');
    ///   try
    ///     if Deleted then
    ///       WriteLn('Modèle deleted');
    ///   finally
    ///     Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Delete(const ModelId: string): TModelDeletion;

    /// <summary>
    /// Retrieves the details of a model.
    /// </summary>
    /// <param name="ModelId">The ID of the model to be retrieved.</param>
    /// <returns>Returns the details of the specified model.</returns>
    /// <remarks>
    /// This method is used to access detailed information about a specific model, including its
    /// creation date, owner, and capabilities. This is useful for managing and reviewing model
    /// details.
    /// <code>
    ///   with MistralAI.Models.Retrieve('ModelId');
    ///   try
    ///     // Model found processing
    ///   finally
    ///     Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Retrieve(const ModelId: string): TModel;

    /// <summary>
    /// Updates the details of a fine-tuned model.
    /// </summary>
    /// <param name="ModelId">The ID of the fine-tuned model to be updated.</param>
    /// <param name="ParamProc">A procedure that specifies the parameters to be updated.</param>
    /// <returns>Returns the updated model details.</returns>
    /// <remarks>
    /// Use this method to change specific details of a fine-tuned model, such as its name or
    /// description. This is useful for managing model metadata.
    /// <code>
    ///   var FineTuned := MistralAI.Models.Retrieve(
    ///          'ModelId',
    ///          procedure (Params: TModelParams)
    ///          begin
    ///            // Define params to retrieve the model
    ///          end);
    ///   if Assigned(FineTuned) then
    ///     try
    ///       // Handle FineTuned.job
    ///     finally
    ///       FineTuned.Free;
    ///     end;
    /// </code>
    /// </remarks>
    function Update(const ModelId: string; ParamProc: TProc<TModelParams>): TFineTunedModel;

    /// <summary>
    /// Archives a fine-tuned model.
    /// </summary>
    /// <param name="ModelId">The ID of the fine-tuned model to be archived.</param>
    /// <returns>Returns the archiving status of the model.</returns>
    /// <remarks>
    /// Archiving a model makes it unavailable for use but preserves its state and metadata.
    /// This is useful for managing storage and ensuring that models are not used when they are
    /// not needed.
    /// <code>
    ///   with MistralAI.Models.Archive('ModelId');
    ///   try
    ///     // Model is archived
    ///   finally
    ///     Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Archive(const ModelId: string): TArchivingModel;

    /// <summary>
    /// Un-archives a fine-tuned model.
    /// </summary>
    /// <param name="ModelId">The ID of the fine-tuned model to be un-archived.</param>
    /// <returns>Returns the un-archiving status of the model.</returns>
    /// <remarks>
    /// Un-archiving a model restores it to an active state, making it available for use again.
    /// This is useful for reactivating models that were previously archived.
    /// <code>
    ///   with MistralAI.Models.Unarchive('ModelId');
    ///   try
    ///     // Model is unarchived
    ///   finally
    ///     Free;
    ///   end;
    /// </remarks>
    function Unarchive(const ModelId: string): TArchivingModel;
  end;

implementation

{ TModels }

destructor TModels.Destroy;
begin
  for var Item in FData do
    Item.Free;
  inherited;
end;

{ TModelsRoute }

function TModelsRoute.Archive(const ModelId: string): TArchivingModel;
begin
  Result := API.Post<TArchivingModel>(Format('fine_tuning/models/%s/archive', [ModelId]));
end;

procedure TModelsRoute.AsyncArchive(const ModelId: string;
  const Callback: TFunc<TAsynArchivingModel>);
begin
  with TAsyncCallBackExec<TAsynArchivingModel, TArchivingModel>.Create(Callback) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TArchivingModel
      begin
        Result := Archive(ModelId);
      end);
  finally
    Free;
  end;
end;

function TModelsRoute.AsyncAwaitArchive(const ModelId: string;
  const Callback: TFunc<TPromiseArchivingModel>): TPromise<TArchivingModel>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TArchivingModel>(
    procedure(const CallbackParams: TFunc<TAsynArchivingModel>)
    begin
      AsyncArchive(ModelId, CallbackParams);
    end,
    Callback);
end;

function TModelsRoute.AsyncAwaitDelete(const ModelId: string;
  const Callback: TFunc<TPromiseModelDeletion>): TPromise<TModelDeletion>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TModelDeletion>(
    procedure(const CallbackParams: TFunc<TAsynModelDeletion>)
    begin
      AsyncDelete(ModelId, CallbackParams);
    end,
    Callback);
end;

function TModelsRoute.AsyncAwaitList(
  const Callback: TFunc<TPromiseModels>): TPromise<TModels>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TModels>(
    procedure(const CallbackParams: TFunc<TAsynModels>)
    begin
      AsyncList(CallbackParams);
    end,
    Callback);
end;

function TModelsRoute.AsyncAwaitRetrieve(const ModelId: string;
  const Callback: TFunc<TPromiseModel>): TPromise<TModel>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TModel>(
    procedure(const CallbackParams: TFunc<TAsynModel>)
    begin
      AsyncRetrieve(ModelId, CallbackParams);
    end,
    Callback);
end;

function TModelsRoute.AsyncAwaitUnarchive(const ModelId: string;
  const Callback: TFunc<TPromiseArchivingModel>): TPromise<TArchivingModel>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TArchivingModel>(
    procedure(const CallbackParams: TFunc<TAsynArchivingModel>)
    begin
      AsyncUnarchive(ModelId, CallbackParams);
    end,
    Callback);
end;

function TModelsRoute.AsyncAwaitUpdate(const ModelId: string;
  const ParamProc: TProc<TModelParams>;
  const Callback: TFunc<TPromiseFineTuneModel>): TPromise<TFineTunedModel>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TFineTunedModel>(
    procedure(const CallbackParams: TFunc<TAsynFineTuneModel>)
    begin
      AsyncUpdate(ModelId, ParamProc, CallbackParams);
    end,
    Callback);
end;

procedure TModelsRoute.AsyncDelete(const ModelId: string;
  const Callback: TFunc<TAsynModelDeletion>);
begin
  with TAsyncCallBackExec<TAsynModelDeletion, TModelDeletion>.Create(Callback) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TModelDeletion
      begin
        Result := Delete(ModelId);
      end);
  finally
    Free;
  end;
end;

procedure TModelsRoute.AsyncList(const Callback: TFunc<TAsynModels>);
begin
  with TAsyncCallBackExec<TAsynModels, TModels>.Create(Callback) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TModels
      begin
        Result := List;
      end);
  finally
    Free;
  end;
end;

procedure TModelsRoute.AsyncRetrieve(const ModelId: string;
  const Callback: TFunc<TAsynModel>);
begin
  with TAsyncCallBackExec<TAsynModel, TModel>.Create(Callback) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TModel
      begin
        Result := Retrieve(ModelId);
      end);
  finally
    Free;
  end;
end;

procedure TModelsRoute.AsyncUnarchive(const ModelId: string;
  const Callback: TFunc<TAsynArchivingModel>);
begin
  with TAsyncCallBackExec<TAsynArchivingModel, TArchivingModel>.Create(Callback) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TArchivingModel
      begin
        Result := Unarchive(ModelId);
      end);
  finally
    Free;
  end;
end;

procedure TModelsRoute.AsyncUpdate(const ModelId: string;
  const ParamProc: TProc<TModelParams>;
  const Callback: TFunc<TAsynFineTuneModel>);
begin
  with TAsyncCallBackExec<TAsynFineTuneModel, TFineTunedModel>.Create(Callback) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TFineTunedModel
      begin
        Result := Update(ModelId, ParamProc);
      end);
  finally
    Free;
  end;
end;

function TModelsRoute.Delete(const ModelId: string): TModelDeletion;
begin
  Result := API.Delete<TModelDeletion>(Format('models/%s', [ModelId]));
end;

function TModelsRoute.List: TModels;
begin
  Result := API.Get<TModels>('models');
end;

function TModelsRoute.Retrieve(const ModelId: string): TModel;
begin
  Result := API.Get<TModel>(Format('models/%s', [ModelId]));
end;

function TModelsRoute.Unarchive(const ModelId: string): TArchivingModel;
begin
  Result := API.Delete<TArchivingModel>(Format('fine_tuning/models/%s/archive', [ModelId]));
end;

function TModelsRoute.Update(const ModelId: string;
  ParamProc: TProc<TModelParams>): TFineTunedModel;
begin
  Result := API.Patch<TFineTunedModel, TModelParams>(Format('fine_tuning/models/%s', [ModelId]), ParamProc);
end;

{ TCoreModel }

destructor TCoreModel.Destroy;
begin
  if Assigned(FCapabilities) then
    FCapabilities.Free;
  inherited;
end;

{ TModelParams }

function TModelParams.Description(const Value: string): TModelParams;
begin
  Result := TModelParams(Add('description', Value));
end;

function TModelParams.Name(const Value: string): TModelParams;
begin
  Result := TModelParams(Add('name', Value));
end;

end.

unit MistralAI.Monitoring;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Generics.Collections, System.SyncObjs;

type
  /// <summary>
  /// Interface for monitoring request counts in a thread-safe manner.
  /// </summary>
  /// <remarks>
  /// This interface defines methods to increment and decrement a request counter,
  /// as well as a method to check if any requests are currently being processed.
  /// </remarks>
  IRequestMonitor = interface
    ['{4FE090AE-EC69-418A-8B1D-4DB6DB93ECA5}']
    /// <summary>
    /// Increments the request counter.
    /// </summary>
    /// <returns>
    /// The updated number of active requests.
    /// </returns>
    function Inc: Integer;

    /// <summary>
    /// Decrements the request counter.
    /// </summary>
    /// <returns>
    /// The updated number of active requests.
    /// </returns>
    function Dec: Integer;

    /// <summary>
    /// Checks if there are active requests being processed.
    /// </summary>
    /// <returns>
    /// <c>True</c> if there are active requests, otherwise <c>False</c>.
    /// </returns>
    function IsBusy: Boolean;
  end;

  /// <summary>
  /// Implements a thread-safe request monitor.
  /// </summary>
  /// <remarks>
  /// This class provides synchronized methods to track the number of active requests.
  /// It ensures thread safety using a critical section.
  /// </remarks>
  TRequestMonitor = class(TInterfacedObject, IRequestMonitor)
  private
    FLock: TCriticalSection;
    FCount: Integer;
  public
    constructor Create;

    destructor Destroy; override;

    /// <summary>
    /// Increments the request counter in a thread-safe manner.
    /// </summary>
    /// <returns>
    /// The updated number of active requests.
    /// </returns>
    function Inc: Integer;

    /// <summary>
    /// Decrements the request counter in a thread-safe manner.
    /// </summary>
    /// <returns>
    /// The updated number of active requests.
    /// </returns>
    function Dec: Integer;

    /// <summary>
    /// Checks if there are any active requests.
    /// </summary>
    /// <returns>
    /// <c>True</c> if there are active requests, otherwise <c>False</c>.
    /// </returns>
    function IsBusy: Boolean;
  end;

var
  Monitoring: IRequestMonitor;

implementation

{ TRequestMonitor }

constructor TRequestMonitor.Create;
begin
  inherited Create;
  FLock := TCriticalSection.Create;
  FCount := 0;
end;

function TRequestMonitor.Dec: Integer;
begin
  FLock.Enter;
  try
    if FCount > 0 then
      System.Dec(FCount);
    Result := FCount;
  finally
    FLock.Leave;
  end;
end;

destructor TRequestMonitor.Destroy;
begin
  FLock.Free;
  inherited;
end;

function TRequestMonitor.Inc: Integer;
begin
  FLock.Enter;
  try
    System.Inc(FCount);
    Result := FCount;
  finally
    FLock.Leave;
  end;
end;

function TRequestMonitor.IsBusy: Boolean;
begin
  FLock.Enter;
  try
    Result := FCount > 0;
  finally
    FLock.Leave;
  end;
end;

initialization
  Monitoring := TRequestMonitor.Create;
end.

unit MistralAI.NetEncoding.Base64;

interface

uses
  System.SysUtils, System.Classes, System.NetEncoding, System.Net.Mime;

  /// <summary>
  /// Retrieves the MIME type of the specified file based on its location.
  /// </summary>
  /// <param name="FileLocation">The full path to the file whose MIME type is to be resolved.</param>
  /// <returns>
  /// A string representing the MIME type of the file.
  /// If the file does not exist, an exception will be raised.
  /// </returns>
  /// <exception cref="Exception">
  /// Thrown if the specified file cannot be found at the provided location.
  /// </exception>
  /// <remarks>
  /// This method checks if the specified file exists and retrieves its MIME type
  /// using the <c>TMimeTypes.Default.GetFileInfo</c> method.
  /// Ensure the provided path is valid before calling this function.
  /// </remarks>
  function ResolveMimeType(const FileLocation: string): string;

  /// <summary>
  /// Validates a URL or file location and converts it into a Base64 data URI if appropriate.
  /// </summary>
  /// <param name="Value">
  /// The input string, which can either be a URL or a file path.
  /// </param>
  /// <returns>
  /// A string representing the validated URL or a Base64-encoded data URI for supported image files.
  /// </returns>
  /// <exception cref="Exception">
  /// Thrown in the following cases:
  /// <para>If the URL starts with "http:" (insecure connection).</para>
  /// <para>If the file MIME type is not among the supported image formats: "image/png", "image/jpeg", "image/gif", "image/webp".</para>
  /// <para>If the file does not exist at the specified location.</para>
  /// </exception>
  /// <remarks>
  /// This function performs the following actions:
  /// <para>Checks if the input starts with "https:" and returns it directly if valid.</para>
  /// <para>Throws an exception if the input starts with "http:" to enforce secure connections.</para>
  /// <para>If the input is a file path, resolves its MIME type and verifies if it is a supported image format.</para>
  /// <para>Encodes the file content as a Base64 data URI if it is a supported image.</para>
  /// </remarks>
  function ImageUrlCheck(const Value: string): string;

  function AudioUrlCheck(const Value: string): string;

  /// <summary>
  /// Validates a PDF URL or file path and returns a secure link or a Base64-encoded data URI.
  /// </summary>
  /// <param name="Value">
  /// <para>The input string, which can be either:</para>
  /// <para>- An HTTPS URL (returned unchanged).</para>
  /// <para>- An HTTP URL (throws an exception).</para>
  /// <para>- A local file path to a PDF file (returns a Base64 data URI).</para>
  /// </param>
  /// <returns>
  /// <para>If <paramref name="Value"/> starts with “https:”, returns it directly.</para>
  /// <para>Otherwise, returns a data URI in the form “data:application/pdf;base64,{encoded content}”.</para>
  /// </returns>
  /// <exception cref="Exception">
  /// <para>Thrown when:</para>
  /// <para>- The URL starts with “http:” (insecure connection).</para>
  /// <para>- The file path does not point to an existing PDF file or is not a PDF.</para>
  /// </exception>
  /// <remarks>
  /// <para>This function enforces secure connections by rejecting “http:” URLs.</para>
  /// <para>When given a file path, it uses <see cref="ResolveMimeType"/> to confirm the MIME type is “application/pdf”
  /// and then calls <see cref="EncodeBase64(FileLocation)"/> to produce the Base64 string.</para>
  /// </remarks>
  function PdfUrlCheck(const Value: string): string;

  /// <summary>
  /// Converts a byte array into a Base64-encoded string.
  /// </summary>
  /// <param name="Value">
  /// A <c>TBytes</c> array containing the binary data to be encoded.
  /// </param>
  /// <returns>
  /// A <c>string</c> representing the Base64-encoded content of the byte array.
  /// </returns>
  /// <exception cref="Exception">
  /// Raised if the provided byte array is empty.
  /// </exception>
  /// <remarks>
  /// This function processes the provided byte array, converts it into a memory stream, and encodes the content as a Base64 string.
  /// Ensure the byte array contains data before calling this function.
  /// </remarks>
  function BytesToBase64(const Value: TBytes): string;

  /// <summary>
  /// Converts a byte array into a UTF-8 encoded string.
  /// </summary>
  /// <param name="Value">
  /// A <c>TBytes</c> array containing the binary data to be converted.
  /// </param>
  /// <returns>
  /// A <c>string</c> representing the UTF-8 encoded content of the byte array.
  /// </returns>
  /// <exception cref="Exception">
  /// Raised if the provided byte array is empty.
  /// </exception>
  /// <remarks>
  /// This function processes the provided byte array by writing it to a memory stream,
  /// then reads and converts the data into a string using UTF-8 encoding.
  /// Ensure the byte array contains data before calling this function.
  /// </remarks>
  function BytesToString(const Value: TBytes): string;

  /// <summary>
  /// Encodes the content of a file into a Base64-encoded string.
  /// </summary>
  /// <param name="FileLocation">The full path to the file that will be encoded.</param>
  /// <returns>A Base64-encoded string representing the content of the file.</returns>
  /// <exception cref="Exception">Thrown if the specified file does not exist at the provided location.</exception>
  /// <remarks>
  /// This method reads the file from the specified location and converts it to a Base64 string.
  /// It uses different encoding methods depending on the version of  the RTL.
  /// For RTL version 35.0 and later, it uses <c>TNetEncoding.Base64String.Encode</c>,
  /// and for earlier versions, it uses <c>TNetEncoding.Base64.Encode</c>.
  /// </remarks>
  function EncodeBase64(FileLocation : string) : WideString; overload;

  /// <summary>
  /// Encodes the content of a stream into a Base64-encoded string.
  /// </summary>
  /// <param name="Value">
  /// A <c>TStream</c> containing the data to be encoded.
  /// </param>
  /// <returns>
  /// A <c>WideString</c> representing the Base64-encoded content of the stream.
  /// </returns>
  /// <exception cref="Exception">
  /// Raised if an error occurs while reading from the stream or during encoding.
  /// </exception>
  /// <remarks>
  /// This function reads the content of the provided stream and converts it into a Base64-encoded string.
  /// Ensure that the stream is properly positioned and contains readable data before calling this function.
  /// For RTL version 35.0 and later, it uses <c>TNetEncoding.Base64String.Encode</c>.
  /// For earlier versions, it uses <c>TNetEncoding.Base64.Encode</c>.
  /// </remarks>
  function EncodeBase64(const Value: TStream): WideString; overload;

  /// <summary>
  /// Decodes a Base64-encoded string and writes the resulting binary data to a specified file.
  /// </summary>
  /// <param name="Base64Str">The Base64-encoded string to decode.</param>
  /// <param name="FileName">The full path and name of the file where the decoded data will be written.</param>
  /// <exception cref="Exception">
  /// Thrown if the Base64 string cannot be decoded or if there is an error writing to the specified file.
  /// </exception>
  procedure DecodeBase64ToFile(const Base64Str: string; const FileName: string);

  /// <summary>
  /// Decodes a Base64-encoded string and writes the resulting binary data to the provided stream.
  /// </summary>
  /// <param name="Base64Str">The Base64-encoded string to decode.</param>
  /// <param name="Stream">The stream where the decoded binary data will be written. The stream should be writable.</param>
  /// <exception cref="Exception">
  /// Thrown if the Base64 string cannot be decoded or if there is an error writing to the provided stream.
  /// </exception>
  /// <remarks>
  /// After decoding, the stream's position is reset to the beginning.
  /// Ensure that the stream is properly managed and freed after use to avoid memory leaks.
  /// </remarks>
  procedure DecodeBase64ToStream(const Base64Str: string; const Stream: TStream);

implementation

uses
  System.StrUtils;

function EncodeBase64(FileLocation : string): WideString;
begin
  if not FileExists(FileLocation) then
    raise Exception.CreateFmt('File not found : %s', [FileLocation]);

  var Stream := TMemoryStream.Create;
  var StreamOutput := TStringStream.Create('', TEncoding.UTF8);
  try
    Stream.LoadFromFile(FileLocation);
    Stream.Position := 0;
    {$IF RTLVersion >= 35.0}
    TNetEncoding.Base64String.Encode(Stream, StreamOutput);
    {$ELSE}
    TNetEncoding.Base64.Encode(Stream, StreamOutput);
    {$ENDIF}
    Result := StreamOutput.DataString;
  finally
    Stream.Free;
    StreamOutput.Free;
  end;
end;

function ResolveMimeType(const FileLocation: string): string;
begin
  if not FileExists(FileLocation) then
    raise Exception.CreateFmt('File not found: %s', [FileLocation]);

  var LKind: TMimeTypes.TKind;
  TMimeTypes.Default.GetFileInfo(FileLocation, Result, LKind);
end;

function ImageUrlCheck(const Value: string): string;
begin
  if Value.StartsWith('https:') then
    Exit(Value);
  if Value.StartsWith('http:') then
    raise Exception.Create('Invalid URL: Secure HTTPS connection required');

  var MimeType := ResolveMimeType(Value);
  if IndexStr(MimeType, ['image/png', 'image/jpeg', 'image/gif', 'image/webp']) = -1 then
    raise Exception.Create('Unsupported image format');
  Result :=  Format('data:%s;base64,%s', [MimeType, EncodeBase64(Value)]);
end;

function AudioUrlCheck(const Value: string): string;
begin
  if Value.StartsWith('https:') then
    Exit(Value);
  if Value.StartsWith('http:') then
    raise Exception.Create('Invalid URL: Secure HTTPS connection required');

  var MimeType := ResolveMimeType(Value);
  if IndexStr(MimeType, ['audio/mpeg', 'audio/wav', 'audio/x-wav']) = -1 then
    raise Exception.Create('Unsupported image format');

  Result :=  Format('%s', [EncodeBase64(Value)]);
//  Result :=  Format('data:%s;base64,%s', [MimeType, EncodeBase64(Value)]);
end;

function PdfUrlCheck(const Value: string): string;
begin
  if Value.StartsWith('https:') then
    Exit(Value);
  if Value.StartsWith('http:') then
    raise Exception.Create('Invalid URL: Secure HTTPS connection required');

  var MimeType := ResolveMimeType(Value);
  if IndexStr(MimeType, ['application/pdf']) = -1 then
    raise Exception.Create('Unsupported document format');
  Result :=  Format('data:%s;base64,%s', [MimeType, EncodeBase64(Value)]);
end;

function BytesToBase64(const Value: TBytes): String;
begin
  if Length(Value) = 0 then
    raise Exception.Create('No data recieved.');
  var MemStream := TMemoryStream.Create;
  try
    MemStream.WriteBuffer(Value[0], Length(Value));
    MemStream.Position := 0;
    Result := EncodeBase64(MemStream);
  finally
    MemStream.Free;
  end;
end;

function BytesToString(const Value: TBytes): string;
begin
  if Length(Value) = 0 then
    raise Exception.Create('No data recieved.');
  var MemStream := TMemoryStream.Create;
  try
    MemStream.WriteBuffer(Value[0], Length(Value));
    MemStream.Position := 0;
    var Reader := TStreamReader.Create(MemStream, TEncoding.UTF8);
    try
      Result := Reader.ReadToEnd;
    finally
      Reader.Free;
    end;
  finally
    MemStream.Free;
  end;
end;

function EncodeBase64(const Value: TStream): WideString; overload;
begin
  var Stream := TMemoryStream.Create;
  var StreamOutput := TStringStream.Create('', TEncoding.UTF8);
  try
    Stream.LoadFromStream(Value);
    Stream.Position := 0;
    {$IF RTLVersion >= 35.0}
    TNetEncoding.Base64String.Encode(Stream, StreamOutput);
    {$ELSE}
    TNetEncoding.Base64.Encode(Stream, StreamOutput);
    {$ENDIF}
    Result := StreamOutput.DataString;
  finally
    Stream.Free;
    StreamOutput.Free;
  end;
end;

procedure DecodeBase64ToFile(const Base64Str: string; const FileName: string);
begin
  {--- Convert Base64 string to byte array for input stream }
  var Bytes := TEncoding.UTF8.GetBytes(Base64Str);

  {--- Create the flows }
  var InputStream := TBytesStream.Create(Bytes);
  var OutputStream := TFileStream.Create(FileName, fmCreate);
  try
    {--- Decode using TNetEncoding.Base64.Decode (stream) }
    TNetEncoding.Base64.Decode(InputStream, OutputStream);
  finally
    InputStream.Free;
    OutputStream.Free;
  end;
end;

procedure DecodeBase64ToStream(const Base64Str: string; const Stream: TStream);
begin
  {--- Converts the base64 string directly into the memory stream }
  var InputStream := TBytesStream.Create(TEncoding.UTF8.GetBytes(Base64Str));
    try
      TNetEncoding.Base64.Decode(InputStream, Stream);
      Stream.Position := 0;
    finally
      InputStream.Free;
    end;
end;

end.

unit MistralAI.OCR;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Threading,
  REST.Json.Types, REST.JsonReflect, System.JSON,
  MistralAI.API.Params, MistralAI.API, MistralAI.Functions.Core, MistralAI.Functions.Tools,
  MistralAI.Async.Support, MistralAI.Async.Params, MistralAI.Types, MistralAI.Async.Promise,
  MistralAI.Schema;

type
  TOcrImageUrl = class(TJSONParam)
    /// <summary>
    /// string (Url)
    /// </summary>
    function Url(const Value: string): TOcrImageUrl;

    /// <summary>
    /// Detail (string) or Detail (null) (Detail)
    /// </summary>
    function Detail(const Value: string): TOcrImageUrl;
  end;

  TOcrDocumentParams = class(TJSONParam)
    /// <summary>
    /// Enum: "document_url" or "image_url"
    /// </summary>
    function &Type(const Value: string): TOcrDocumentParams;

    /// <summary>
    /// string (Document Url)
    /// </summary>
    function DocumentUrl(const Value: string): TOcrDocumentParams;

    /// <summary>
    /// The filename of the document
    /// </summary>
    function DocumentName(const Value: string): TOcrDocumentParams;

    /// <summary>
    /// ImageURL (object) or Image Url (string) (Image Url)
    /// </summary>
    function ImageUrl(const Value: TOcrImageUrl): TOcrDocumentParams;

    class function NewDocument: TOcrDocumentParams;
    class function NewImage: TOcrDocumentParams;
  end;

  TAnnotationFormat = class(TJSONParam)
    /// <summary>
    /// An object specifying the format that the model must output. Setting to { "type": "json_object" }
    /// enables JSON mode, which guarantees the message the model generates is in JSON. When using JSON
    /// mode you MUST also instruct the model to produce JSON yourself with a system or a user message.
    /// </summary>
    /// <param name="Value">
    /// Enum: "text" "json_object" "json_schema"
    /// </param>
    function &Type(const Value: string): TAnnotationFormat;

    /// <summary>
    /// JsonSchema (object)
    /// </summary>
    function JsonSchema(const Value: TResponseSchemaParams): TAnnotationFormat;
  end;

  TOCRFormat = record
  public
    /// <summary>
    /// Creates an annotation format configured for plain text output.
    /// </summary>
    /// <returns>
    /// A <c>TAnnotationFormat</c> instance with its type set to <c>"text"</c>, instructing the OCR to return unstructured text.
    /// </returns>
    /// <remarks>
    /// Use this format when you require the OCR result as simple text rather than JSON or schema‑based annotations.
    /// </remarks>
    class function Text: TAnnotationFormat; static;

    /// <summary>
    /// Creates an annotation format configured for JSON object output.
    /// </summary>
    /// <returns>
    /// A <c>TAnnotationFormat</c> instance with its type set to <c>"json_object"</c>, instructing the OCR to return the result as a structured JSON object.
    /// </returns>
    /// <remarks>
    /// Use this format when you need the OCR result in JSON mode, ensuring the response is valid JSON that can be parsed directly into data structures.
    /// Remember to include explicit instructions to the model to produce JSON if using JSON mode.
    /// </remarks>
    class function Json_object: TAnnotationFormat; static;

    /// <summary>
    /// Creates an annotation format configured for JSON schema output.
    /// </summary>
    /// <param name="Value">
    /// A <c>TResponseSchemaParams</c> instance defining the JSON schema that the OCR should use to structure its output.
    /// </param>
    /// <returns>
    /// A <c>TAnnotationFormat</c> instance with its type set to <c>"json_schema"</c> and the specified schema, instructing the OCR to return data annotated according to that schema.
    /// </returns>
    /// <remarks>
    /// Use this format when you need the OCR results to conform to a predefined JSON schema for structured data extraction.
    /// Make sure the provided <c>Value</c> accurately represents the schema you expect in the response.
    /// </remarks>
    class function Json_schema(const Value: TResponseSchemaParams): TAnnotationFormat; static;
  end;

  TOcrParams = class(TJSONParam)
    /// <summary>
    /// OCR model eg mistral-ocr-latest.
    /// </summary>
    function Model(const Value: string): TOCRParams;

    /// <summary>
    /// string(Id)
    /// </summary>
    function Id(const Value: string): TOCRParams;

    /// <summary>
    /// Document to run OCR on
    /// </summary>
    function Document(const Value: TOcrDocumentParams): TOCRParams;

    /// <summary>
    /// Specific pages user wants to process in various formats: single number, range, or list of both.
    /// Starts from 0
    /// </summary>
    function Pages(const Value: TArray<Integer>): TOCRParams;

    /// <summary>
    /// Include image URLs in response
    /// </summary>
    function IncludeImageBase64(const Value: Boolean = True): TOCRParams;

    /// <summary>
    /// Max images to extract
    /// </summary>
    function ImageLimit(const Value: Integer): TOCRParams;

    /// <summary>
    /// Minimum height and width of image to extract
    /// </summary>
    function ImageMinSize(const Value: Integer): TOCRParams;

    /// <summary>
    /// Structured output class for extracting useful information from each extracted bounding box / image
    /// from document. Only json_schema is valid for this field
    /// </summary>
    function BboxAnnotationFormat(const Value: TAnnotationFormat): TOCRParams; overload;

    /// <summary>
    /// Structured output class for extracting useful information from each extracted bounding box / image
    /// from document. Only json_schema is valid for this field
    /// </summary>
    function BboxAnnotationFormat(const Value: TJSONObject): TOCRParams; overload;

    /// <summary>
    /// Structured output class for extracting useful information from the entire document. Only json_schema
    /// is valid for this field
    /// </summary>
    function DocumentAnnotationFormat(const Value: TAnnotationFormat): TOCRParams; overload;

    /// <summary>
    /// Structured output class for extracting useful information from the entire document. Only json_schema
    /// is valid for this field
    /// </summary>
    function DocumentAnnotationFormat(const Value: TJSONObject): TOCRParams; overload;
  end;

  TOcrPageImageCore = class
  private
    FId: string;
    [JsonNameAttribute('top_left_x')]
    FTopLeftX: Integer;
    [JsonNameAttribute('top_left_y')]
    FTopLeftY: Integer;
    [JsonNameAttribute('bottom_right_x')]
    FBottomRightX: Integer;
    [JsonNameAttribute('bottom_right_y')]
    FBottomRightY: Integer;
    [JsonNameAttribute('image_base64')]
    FImageBase64: string;
    [JsonNameAttribute('image_annotation')]
    FImageAnnotation: string;
  public
    /// <summary>
    /// Image ID for extracted image in a page
    /// </summary>
    property Id: string read FId write FId;

    /// <summary>
    /// X coordinate of top-left corner of the extracted image
    /// </summary>
    property TopLeftX: Integer read FTopLeftX write FTopLeftX;

    /// <summary>
    /// Y coordinate of top-left corner of the extracted image
    /// </summary>
    property TopLeftY: Integer read FTopLeftY write FTopLeftY;

    /// <summary>
    /// X coordinate of bottom-right corner of the extracted image
    /// </summary>
    property BottomRightX: Integer read FBottomRightX write FBottomRightX;

    /// <summary>
    /// Y coordinate of bottom-right corner of the extracted image
    /// </summary>
    property BottomRightY: Integer read FBottomRightY write FBottomRightY;

    /// <summary>
    /// Base64 string of the extracted image
    /// </summary>
    property ImageBase64: string read FImageBase64 write FImageBase64;

    /// <summary>
    /// Annotation of the extracted image in json str
    /// </summary>
    property ImageAnnotation: string read FImageAnnotation write FImageAnnotation;
  end;

  TOcrPageImage = class(TOcrPageImageCore)
  private
    FFileName: string;
  public
    /// <summary>
    /// Retrieves the generated image as a <c>TStream</c>.
    /// </summary>
    /// <returns>
    /// A <c>TStream</c> containing the decoded image data.
    /// </returns>
    /// <remarks>
    /// This method decodes the base64-encoded image data and returns it as a stream.
    /// The caller is responsible for freeing the returned stream.
    /// </remarks>
    /// <exception cref="Exception">
    /// Raises an exception if both the image data are empty.
    /// </exception>
    function GetStream: TStream;

    /// <summary>
    /// Saves the generated image to a file.
    /// </summary>
    /// <param name="FileName">
    /// The file path where the image will be saved.
    /// </param>
    /// <remarks>
    /// This method decodes the base64-encoded image data and saves it to the specified file.
    /// </remarks>
    /// <exception cref="Exception">
    /// Raises an exception if the image data cannot be decoded or saved.
    /// </exception>
    procedure SaveToFile(const FileName: string);

    /// <summary>
    /// Gets the file name where the image was saved.
    /// </summary>
    /// <value>
    /// The file path as a string.
    /// </value>
    /// <remarks>
    /// This property holds the file name specified in the last call to <c>SaveToFile</c>.
    /// </remarks>
    property FileName: string read FFileName write FFileName;
  end;

  TOcrPageDimensions = class
  private
    FDpi: Integer;
    FHeight: Integer;
    FWidth: Integer;
  public
    /// <summary>
    /// Dots per inch of the page-image
    /// </summary>
    property Dpi: Integer read FDpi write FDpi;

    /// <summary>
    /// Height of the image in pixels
    /// </summary>
    property Height: Integer read FHeight write FHeight;

    /// <summary>
    /// Width of the image in pixels
    /// </summary>
    property Width: Integer read FWidth write FWidth;
  end;

  TOcrPage = class
  private
    FIndex: Integer;
    FMarkdown: string;
    FImages: TArray<TOcrPageImage>;
    FDimensions: TOcrPageDimensions;
  public
    /// <summary>
    /// The page index in a pdf document starting from 0
    /// </summary>
    property Index: Integer read FIndex write FIndex;

    /// <summary>
    /// The markdown string response of the page
    /// </summary>
    property Markdown: string read FMarkdown write FMarkdown;

    /// <summary>
    /// List of all extracted images in the page
    /// </summary>
    property Images: TArray<TOcrPageImage> read FImages write FImages;

    /// <summary>
    /// The dimensions of the PDF Page's screenshot image
    /// </summary>
    property Dimensions: TOcrPageDimensions read FDimensions write FDimensions;

    destructor Destroy; override;
  end;

  TUsageInfo = class
  private
    [JsonNameAttribute('pages_processed')]
    FPagesProcessed: Integer;
    [JsonNameAttribute('doc_size_bytes')]
    FDocSizeBytes: Integer;
  public
    /// <summary>
    /// Number of pages processed
    /// </summary>
    property PagesProcessed: Integer read FPagesProcessed write FPagesProcessed;

    /// <summary>
    /// Document size in bytes
    /// </summary>
    property DocSizeBytes: Integer read FDocSizeBytes write FDocSizeBytes;
  end;

  TOcr = class(TJSONFingerprint)
  private
    FPages: TArray<TOcrPage>;
    FModel: string;
    [JsonNameAttribute('document_annotation')]
    FDocumentAnnotation: string;
    [JsonNameAttribute('usage_info')]
    FUsageInfo: TUsageInfo;
  public
    /// <summary>
    /// List of OCR info for pages.
    /// </summary>
    property Pages: TArray<TOcrPage> read FPages write FPages;

    /// <summary>
    /// The model used to generate the OCR.
    /// </summary>
    property Model: string read FModel write FModel;

    /// <summary>
    /// Formatted response in the request_format if provided in json str
    /// </summary>
    property DocumentAnnotation: string read FDocumentAnnotation write FDocumentAnnotation;

    /// <summary>
    /// Usage info for the OCR request.
    /// </summary>
    property UsageInfo: TUsageInfo read FUsageInfo write FUsageInfo;

    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous OCR callbacks for a document processing request using <c>TOcr</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsyncOcr</c> type is an alias for <c>TAsyncCallback&lt;TOcr&gt;</c>, providing event handlers to track
  /// the lifecycle of an OCR operation. Assign handlers such as OnStart, OnSuccess, and OnError to respond to
  /// the various stages of the asynchronous OCR process, enabling non‐blocking, event‐driven document recognition.
  /// </remarks>
  TAsyncOcr = TAsyncCallback<TOcr>;

  /// <summary>
  /// Provides a promise‐based interface for an asynchronous OCR operation, returning a <c>TOcr</c> result when complete.
  /// </summary>
  /// <remarks>
  /// <c>TPromiseOcr</c> is an alias for <c>TPromiseCallback&lt;TOcr&gt;</c>. Use this type to initiate an OCR request
  /// and await its completion in a promise style, simplifying asynchronous flows by resolving with the OCR response
  /// or rejecting with an error if the operation fails.
  /// </remarks>
  TPromiseOcr = TPromiseCallback<TOcr>;

  /// <summary>
  /// Provides client routing for OCR operations against the Document AI API.
  /// </summary>
  /// <remarks>
  /// <para><c>TOcrRoute</c> inherits from <c>TMistralAIAPIRoute</c> and exposes methods to perform OCR requests.</para>
  /// <para>The <c>Create</c> method performs a synchronous OCR request and returns a <c>TOcr</c> result.</para>
  /// <para>The <c>AsyncCreate</c> method executes an OCR request with event handlers for OnStart, OnSuccess, and OnError, enabling non‑blocking, callback‑driven workflows.</para>
  /// <para>The <c>AsyncAwaitCreate</c> method returns a <c>TPromise&lt;TOcr&gt;</c>, allowing promise‑based asynchronous OCR operations that resolve with a <c>TOcr</c> or reject on error.</para>
  /// </remarks>
  TOcrRoute = class(TMistralAIAPIRoute)
    /// <summary>
    /// Asynchronously submits an OCR request configured by <paramref name="ParamProc"/> and returns a promise for the result.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure in which you configure the <c>TOcrParams</c>—for example, selecting the OCR model, specifying the document or image source, pages to process, and annotation formats.
    /// </param>
    /// <param name="Callbacks">
    /// An optional function that returns a <c>TPromiseOcr</c> to attach OnSuccess and OnError handlers in promise style. If <c>nil</c>, no additional callbacks are registered.
    /// </param>
    /// <returns>
    /// A <c>TPromise&lt;TOcr&gt;</c> that resolves with the completed <c>TOcr</c> response when the OCR operation finishes, or rejects with an exception if an error occurs.
    /// </returns>
    /// <remarks>
    /// Use this method for promise‑based asynchronous workflows, allowing you to await the OCR result directly or chain further processing steps.
    /// </remarks>
    function AsyncAwaitCreate(const ParamProc: TProc<TOcrParams>;
      const Callbacks: TFunc<TPromiseOcr> = nil): TPromise<TOcr>;

    /// <summary>
    /// Sends a synchronous OCR request configured by <paramref name="ParamProc"/> and returns the OCR result.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure in which you configure the <c>TOcrParams</c>—for example, selecting the OCR model, specifying the document or image source, pages to process, and annotation formats.
    /// </param>
    /// <returns>
    /// A <c>TOcr</c> object containing the OCR results, including page markdown, extracted images, annotations, and usage information.
    /// </returns>
    /// <remarks>
    /// Use this method for blocking, synchronous workflows. The call will raise an exception if the request fails or if parameters are invalid. Ensure that you free the returned <c>TOcr</c> instance when it is no longer needed.
    /// </remarks>
    function Create(const ParamProc: TProc<TOcrParams>): TOcr;

    /// <summary>
    /// Executes an OCR request asynchronously using callback handlers.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure in which you configure the <c>TOcrParams</c>—for example, selecting the OCR model, specifying the document or image source, pages to process, and annotation formats.
    /// </param>
    /// <param name="Callbacks">
    /// A function that returns a <c>TAsyncOcr</c> record, allowing you to assign handlers such as OnStart, OnSuccess, and OnError for event‑driven, non‑blocking workflows.
    /// </param>
    /// <remarks>
    /// Use this method when you need fine‑grained control over the OCR process via callbacks, enabling your application to respond to each stage of the operation without blocking the main thread.
    /// </remarks>
    procedure AsyncCreate(const ParamProc: TProc<TOcrParams>;
      const Callbacks: TFunc<TAsyncOcr>);
  end;

implementation

uses
  MistralAI.NetEncoding.Base64;

{ TOCRParams }

function TOcrParams.BboxAnnotationFormat(
  const Value: TAnnotationFormat): TOCRParams;
begin
  Result := TOCRParams(Add('bbox_annotation_format', Value.Detach));
end;

function TOcrParams.BboxAnnotationFormat(
  const Value: TJSONObject): TOCRParams;
begin
  Result := TOCRParams(Add('bbox_annotation_format', Value));
end;

function TOcrParams.Document(const Value: TOcrDocumentParams): TOCRParams;
begin
  Result := TOCRParams(Add('document', Value.Detach));
end;

function TOcrParams.DocumentAnnotationFormat(
  const Value: TJSONObject): TOCRParams;
begin
  Result := TOCRParams(Add('document_annotation_format', Value));
end;

function TOcrParams.DocumentAnnotationFormat(
  const Value: TAnnotationFormat): TOCRParams;
begin
  Result := TOCRParams(Add('document_annotation_format', Value.Detach));
end;

function TOcrParams.Id(const Value: string): TOCRParams;
begin
  Result := TOCRParams(Add('id', Value));
end;

function TOcrParams.ImageLimit(const Value: Integer): TOCRParams;
begin
  Result := TOCRParams(Add('image_limit', Value));
end;

function TOcrParams.ImageMinSize(const Value: Integer): TOCRParams;
begin
  Result := TOCRParams(Add('image_min_size', Value));
end;

function TOcrParams.IncludeImageBase64(const Value: Boolean): TOCRParams;
begin
  Result := TOCRParams(Add('include_image_base64', Value));
end;

function TOcrParams.Model(const Value: string): TOCRParams;
begin
  Result := TOCRParams(Add('model', Value));
end;

function TOcrParams.Pages(const Value: TArray<Integer>): TOCRParams;
begin
  Result := TOCRParams(Add('pages', Value));
end;

{ TOcrDocumentParams }

function TOcrDocumentParams.&Type(const Value: string): TOcrDocumentParams;
begin
  Result := TOcrDocumentParams(Add('type', Value));
end;

function TOcrDocumentParams.DocumentName(
  const Value: string): TOcrDocumentParams;
begin
  Result := TOcrDocumentParams(Add('document_name', Value));
end;

function TOcrDocumentParams.DocumentUrl(
  const Value: string): TOcrDocumentParams;
begin
  Result := TOcrDocumentParams(Add('document_url', PdfUrlCheck(Value)));
end;

function TOcrDocumentParams.ImageUrl(
  const Value: TOcrImageUrl): TOcrDocumentParams;
begin
  Result := TOcrDocumentParams(Add('image_url', Value.Detach));
end;

class function TOcrDocumentParams.NewDocument: TOcrDocumentParams;
begin
  Result := TOcrDocumentParams.Create.&Type('document_url');
end;

class function TOcrDocumentParams.NewImage: TOcrDocumentParams;
begin
  Result := TOcrDocumentParams.Create.&Type('image_url');
end;

{ TOcrImageUrl }

function TOcrImageUrl.Detail(const Value: string): TOcrImageUrl;
begin
  Result := TOcrImageUrl(Add('detail', Value));
end;

function TOcrImageUrl.Url(const Value: string): TOcrImageUrl;
begin
  Result := TOcrImageUrl(Add('url', ImageUrlCheck(Value)));
end;

{ TAnnotationFormat }

function TAnnotationFormat.JsonSchema(
  const Value: TResponseSchemaParams): TAnnotationFormat;
begin
  Result := TAnnotationFormat(Add('json_schema', Value.Detach));
end;

function TAnnotationFormat.&Type(const Value: string): TAnnotationFormat;
begin
  Result := TAnnotationFormat(Add('type', Value));
end;

{ TOCRFormat }

class function TOCRFormat.Json_object: TAnnotationFormat;
begin
  Result := TAnnotationFormat.Create.&Type('json_object');
end;

class function TOCRFormat.Json_schema(
  const Value: TResponseSchemaParams): TAnnotationFormat;
begin
  Result := TAnnotationFormat.Create.&Type('json_schema').JsonSchema(Value);
end;

class function TOCRFormat.Text: TAnnotationFormat;
begin
  Result := TAnnotationFormat.Create.&Type('text');
end;

{ TOcr }

destructor TOcr.Destroy;
begin
  for var Item in FPages do
    Item.Free;
  if Assigned(FUsageInfo) then
    FUsageInfo.Free;
  inherited;
end;

{ TOcrPage }

destructor TOcrPage.Destroy;
begin
  for var Item in FImages do
    Item.Free;
  if Assigned(FDimensions) then
    FDimensions.Free;
  inherited;
end;

{ TOcrRoute }

function TOcrRoute.AsyncAwaitCreate(const ParamProc: TProc<TOcrParams>;
  const Callbacks: TFunc<TPromiseOcr>): TPromise<TOcr>;
begin
  Result := TAsyncAwaitHelper.WrapAsyncAwait<TOcr>(
    procedure(const CallbackParams: TFunc<TAsyncOcr>)
    begin
      AsyncCreate(ParamProc, CallbackParams);
    end,
    Callbacks);
end;

procedure TOcrRoute.AsyncCreate(const ParamProc: TProc<TOcrParams>;
  const Callbacks: TFunc<TAsyncOcr>);
begin
  with TAsyncCallBackExec<TAsyncOcr, TOcr>.Create(Callbacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TOcr
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TOcrRoute.Create(const ParamProc: TProc<TOcrParams>): TOcr;
begin
  Result := API.Post<TOcr, TOcrParams>('ocr', ParamProc);
end;

{ TOcrPageImage }

function TOcrPageImage.GetStream: TStream;
begin
  {--- Create a memory stream to write the decoded content. }
  Result := TMemoryStream.Create;
  try
    {--- Convert the base-64 string directly into the memory stream. }
    DecodeBase64ToStream(ImageBase64, Result)
  except
    Result.Free;
    raise;
  end;
end;

procedure TOcrPageImage.SaveToFile(const FileName: string);
begin
  try
    Self.FFileName := FileName;
    {--- Perform the decoding operation and save it into the file specified by the FileName parameter. }
    DecodeBase64ToFile(ImageBase64, FileName)
  except
    raise;
  end;
end;

end.


unit MistralAI;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, MistralAI.API, System.Net.URLClient,
  MistralAI.Httpx, MistralAI.Chat, MistralAI.Embeddings, MistralAI.Models, MistralAI.Codestral,
  MistralAI.Files, MistralAI.FineTunings, MistralAI.Agents, MistralAI.Classifiers,
  MistralAI.Functions.Tools, MistralAI.Functions.Core, MistralAI.Batch, MistralAI.Monitoring,
  MistralAI.Schema, MistralAI.Conversations.Params, MistralAI.Conversations.Chunks,
  MistralAI.Conversations, MistralAI.Conversations.Manager, MistralAI.Conversations.EventStreaming,
  MistralAI.Conversations.Internal, MistralAI.Conversations.Agents, MistralAI.OCR,
  MistralAI.Async.Parallel, MistralAI.API.Params, MistralAI.HttpClientInterface,
  MistralAI.Libraries.Main, MistralAI.Libraries.Documents, MistralAI.Libraries.Access,
  MistralAI.Audio;

const
  VERSION = 'DelphiMistralAIv1.3.0';

type
  /// <summary>
  /// The IMistralAI interface provides access to the various features and routes of the Mistral AI API.
  /// This interface allows interaction with different services such as agents, chat, code completion,
  /// embeddings, file management, fine-tuning, and model information.
  /// </summary>
  /// <remarks>
  /// This interface should be implemented by any class that wants to provide a structured way of accessing
  /// the Mistral AI services. It includes methods and properties for authenticating with an API key,
  /// configuring the base URL, and accessing different API routes.
  ///
  /// To use this interface, instantiate a class that implements it, set the required properties such as
  /// <see cref="Token"/> and <see cref="BaseURL"/>, and call the relevant methods for the desired operations.
  /// <code>
  ///   var MistralAI: IMistralAI := TMistralAI.Create(API_TOKEN);
  ///   or
  ///   var CodestralAI: IMistralAI := TMistralAI.Create(API_TOKEN, [CodestralSpec]);
  /// </code>
  /// <seealso cref="TMistralAI"/>
  /// </remarks>
  IMistralAI = interface
    ['{CB506753-77B2-4BD6-A2F8-216433D444A8}']
    function GetAPI: TMistralAIAPI;
    procedure SetToken(const Value: string);
    function GetToken: string;
    function GetHttpClient: IHttpClientAPI;
    function GetBaseUrl: string;
    procedure SetBaseUrl(const Value: string);
    function GetVersion: string;
    function GetAgentRoute: TAgentRoute;
    function GetChatRoute: TChatRoute;
    function GetCodestralRoute: TCodestralRoute;
    function GetEmbeddingsRoute: TEmbeddingsRoute;
    function GetFilesRoute: TFilesRoute;
    function GetFineTuningRoute: TFineTuningRoute;
    function GetModelsRoute: TModelsRoute;
    function GetClassifiersRoute: TClassifiersRoute;
    function GetBatchRoute: TBatchRoute;
    function GetConversationsRoute: TConversationsRoute;
    function GetConversationsAgentRoute: TConversationsAgentRoute;
    function GetOcrRoute: TOcrRoute;
    function GetLibrariesMainRoute: TLibrariesMainRoute;
    function GetLibrariesDocumentsRoute: TLibrariesDocumentsRoute;
    function GetLibrariesAccessRoute: TLibrariesAccessRoute;
    function GetAudioRoute: TAudioRoute;

    /// <summary>
    /// Gets the current version of the MistralAI library.
    /// </summary>
    /// <remarks>
    /// The <c>Version</c> property provides the semantic version number of the library as a string.
    /// This can be used for compatibility checks or displaying version information in your application.
    /// </remarks>
    /// <returns>
    /// A string representing the library version.
    /// </returns>
    property Version: string read GetVersion;

    /// <summary>
    /// Provides access to agent completion API.
    /// An AI agent is an autonomous system using large language models (LLM) to perform tasks based on high-level instructions.
    /// </summary>
    /// <returns>
    /// An instance of TAgentRoute for agent-related operations.
    /// </returns>
    property Agent: TAgentRoute read GetAgentRoute;

    property Audio: TAudioRoute read GetAudioRoute;

    /// <summary>
    /// A batch is composed of a list of API requests. The structure of an individual request includes:
    /// <para>
    /// - A unique custom_id for identifying each request and referencing results after completion
    /// </para>
    /// <para>
    /// - A body object with message information
    /// </para>
    /// </summary>
    /// <returns>
    /// An instance of GetBatchRoute for batch-related operations.
    /// </returns>
    property Batch: TBatchRoute read GetBatchRoute;

    /// <summary>
    /// Provides access to the chat completion API.
    /// Allows for interaction with models fine-tuned for instruction-based dialogue.
    /// </summary>
    /// <returns>
    /// An instance of TChatRoute for chat-related operations.
    /// </returns>
    property Chat: TChatRoute read GetChatRoute;

    /// <summary>
    /// Moderation service, which is powered by the Mistral Moderation model, Ministral 8B 24.10
    /// </summary>
    /// <returns>
    /// An instance of TModelsRoute for model-related operations.
    /// </returns>
    property Classifiers: TClassifiersRoute read GetClassifiersRoute;

    /// <summary>
    /// Provides access to the Codestral Completion API.
    /// Allows for code design or completion using a template configured to follow specific instructions.
    /// </summary>
    /// <returns>
    /// An instance of TCodestralRoute for code completion operations.
    /// </returns>
    property Codestral: TCodestralRoute read GetCodestralRoute;

    /// <summary>
    /// Provides access to the Conversations API route.
    /// </summary>
    /// <remarks>
    /// This property allows interaction with conversation-specific endpoints, enabling the creation,
    /// management, and retrieval of conversations that maintain message history and context.
    /// Use this route to build structured, multi-turn interactions with the AI, where conversational memory is preserved
    /// across exchanges.
    /// </remarks>
    /// <returns>
    /// An instance of <c>TConversationsRoute</c> for conversation-related operations.
    /// </returns>
    property Conversations: TConversationsRoute read GetConversationsRoute;

    /// <summary>
    /// Provides access to the Conversations Agent API route.
    /// </summary>
    /// <remarks>
    /// This property allows interaction with agent-driven conversation endpoints,
    /// enabling advanced dialog management, agent handoff, and automated orchestration
    /// of conversation flows. It is designed to complement the <see cref="Conversations"/>
    /// route by focusing on agent-related operations such as managing agent context,
    /// retrieving agent states, or coordinating multiple agents within a single
    /// conversation.
    /// </remarks>
    /// <returns>
    /// An instance of <c>TConversationsAgentRoute</c> for performing agent-specific
    /// conversation operations.
    /// </returns>
    property ConversationsAgent: TConversationsAgentRoute read GetConversationsAgentRoute;

    /// <summary>
    /// Provides access to the embeddings API.
    /// Enables the embedding of sentences or documents.
    /// </summary>
    /// <returns>
    /// An instance of TEmbeddingsRoute for embedding operations.
    /// </returns>
    property Embeddings: TEmbeddingsRoute read GetEmbeddingsRoute;

    /// <summary>
    /// Provides access to the file management API.
    /// Files can be uploaded and used with features such as fine-tuning.
    /// </summary>
    /// <returns>
    /// An instance of TFilesRoute for file-related operations.
    /// </returns>
    property &File: TFilesRoute read GetFilesRoute;

    /// <summary>
    /// Provides access to fine-tuning API for user and organization.
    /// Allows managing fine-tuning jobs.
    /// </summary>
    /// <returns>
    /// An instance of TFineTuningRoute for fine-tuning operations.
    /// </returns>
    property FineTuning: TFineTuningRoute read GetFineTuningRoute;

    /// <summary>
    /// Provides access to the Libraries Main API route.
    /// </summary>
    /// <remarks>
    /// This property allows interaction with the document libraries endpoints,
    /// including creating, listing, retrieving, updating, and deleting document
    /// libraries. Use this route to manage library metadata and associated
    /// document collections within the Mistral AI platform.
    /// <para>
    /// Example usage:
    /// <code>
    ///   var Libraries: TLibrariesMainList;
    ///   Libraries := MistralAI.LibrariesMain.List;
    /// </code>
    /// </para>
    /// </remarks>
    /// <returns>
    /// An instance of <c>TLibrariesMainRoute</c> providing all library-related
    /// operations.
    /// </returns>
    property LibrariesMain: TLibrariesMainRoute read GetLibrariesMainRoute;

    /// <summary>
    /// Provides access to the Libraries Documents API route.
    /// </summary>
    /// <remarks>
    /// This property allows interaction with the documents stored within a specific library,
    /// including operations such as listing, uploading, retrieving, updating, deleting, and
    /// reprocessing documents.
    /// Use this route to manage the lifecycle and metadata of documents within a library.
    /// <para>
    /// Example usage:
    /// <code>
    ///   var Docs: TLibrariesDocumentsList;
    ///   Docs := MistralAI.LibrariesDocuments.List('library_id',
    ///     procedure(Params: TLibrariesDocumentsUrlParams)
    ///     begin
    ///       Params.Limit(20).Order('desc');
    ///     end
    ///   );
    /// </code>
    /// </para>
    /// </remarks>
    /// <returns>
    /// An instance of <c>TLibrariesDocumentsRoute</c> for performing document-related operations
    /// within a library.
    /// </returns>
    property LibrariesDocuments: TLibrariesDocumentsRoute read GetLibrariesDocumentsRoute;

    /// <summary>
    /// Provides access to the Libraries Access API route.
    /// </summary>
    /// <remarks>
    /// This property enables interaction with the access control and permission
    /// management endpoints for libraries within the Mistral AI platform.
    /// Use this route to manage user and team access to specific libraries,
    /// including granting or revoking permissions and listing access configurations.
    /// <para>
    /// Example usage:
    /// <code>
    ///   var AccessList: TLibrariesAccessList;
    ///   AccessList := MistralAI.LibrariesAccess.List('library_id');
    /// </code>
    /// </para>
    /// </remarks>
    /// <returns>
    /// An instance of <c>TLibrariesAccessRoute</c> for managing library access operations.
    /// </returns>
    property LibrariesAccess: TLibrariesAccessRoute read GetLibrariesAccessRoute;

    /// <summary>
    /// Lists and describes the various models available in the API.
    /// You can refer to the Models documentation to understand what models are available and the differences between them.
    /// </summary>
    /// <returns>
    /// An instance of TModelsRoute for model-related operations.
    /// </returns>
    property Models: TModelsRoute read GetModelsRoute;

    /// <summary>
    /// Provides access to the Optical Character Recognition (OCR) API route.
    /// </summary>
    /// <remarks>
    /// This property allows interaction with OCR-specific endpoints, enabling the
    /// extraction of text and structured information from images or scanned documents.
    /// Use this route to perform operations such as document parsing, layout detection,
    /// and text recognition across multiple page formats or image types.
    /// </remarks>
    /// <returns>
    /// An instance of <c>TOcrRoute</c> for OCR-related operations.
    /// </returns>
    property Ocr: TOcrRoute read GetOcrRoute;

    /// <summary>
    /// the main API object used for making requests.
    /// </summary>
    /// <returns>
    /// An instance of TMistralAIAPI for making API calls.
    /// </returns>
    property API: TMistralAIAPI read GetAPI;

    /// Sets or retrieves the API token for authentication.
    /// </summary>
    /// <param name="Value">
    /// The API token as a string.
    /// </param>
    /// <returns>
    /// The current API token.
    /// </returns>
    property Token: string read GetToken write SetToken;

    /// <summary>
    /// Sets or retrieves the base URL for API requests.
    /// Default is https://api.mistral.ai/v1.
    /// </summary>
    /// <param name="Value">
    /// The base URL as a string.
    /// </param>
    /// <returns>
    /// The current base URL.
    /// </returns>
    property BaseURL: string read GetBaseUrl write SetBaseUrl;

    /// <summary>
    /// Provides access to the underlying HTTP client used for all API requests.
    /// </summary>
    /// <remarks>
    /// The <c>HttpClient</c> property exposes the <see cref="IHttpClientAPI"/> instance
    /// that handles the low-level HTTP communication with the Mistral AI API.
    /// This can be useful for customizing request behavior, adding headers,
    /// configuring timeouts, or implementing logging and monitoring features.
    /// <para>
    /// It is recommended to use this property only if you need fine-grained control
    /// over HTTP requests or responses. For standard operations,
    /// interact with the higher-level API routes instead.
    /// </para>
    /// </remarks>
    /// <returns>
    /// An <see cref="IHttpClientAPI"/> instance representing the internal HTTP client.
    /// </returns>
    property HttpClient: IHttpClientAPI read GetHttpClient;
  end;

  /// <summary>
  /// Specification taken into account
  /// </summary>
  TSpec = (
    /// <summary>
    /// The "codestral" specification is taken into account in the instantiation of the class
    /// </summary>
    CodestralSpec);

  /// <summary>
  /// List of specifications taken into account
  /// </summary>
  TSpecs = set of TSpec;

  TMistralAIFactory = class
    class function CreateInstance(const AToken: string; Specs: TSpecs = []): IMistralAI;
  end;

  /// <summary>
  /// The TMistralAI class provides access to the various features and routes of the Mistral AI API.
  /// This class allows interaction with different services such as agents, chat, code completion,
  /// embeddings, file management, fine-tuning, and model information.
  /// </summary>
  /// <remarks>
  /// This class should be implemented by any class that wants to provide a structured way of accessing
  /// the Mistral AI services. It includes methods and properties for authenticating with an API key,
  /// configuring the base URL, and accessing different API routes.
  /// <seealso cref="TMistralAI"/>
  /// </remarks>
  TMistralAI = class(TInterfacedObject, IMistralAI)
  strict private
    FSpecs: TSpecs;
    procedure CodestralCheck;

  private
    FAPI: TMistralAIAPI;
    FAgentRoute: TAgentRoute;
    FChatRoute: TChatRoute;
    FCodestralRoute: TCodestralRoute;
    FEmbeddingsRoute: TEmbeddingsRoute;
    FFileRoute: TFilesRoute;
    FFineTuningRoute: TFineTuningRoute;
    FModelsRoute: TModelsRoute;
    FClassifiersRoute: TClassifiersRoute;
    FBatchRoute: TBatchRoute;
    FConversationsRoute: TConversationsRoute;
    FConversationsAgentRoute: TConversationsAgentRoute;
    FOcrRoute: TOcrRoute;
    FLibrariesMainRoute: TLibrariesMainRoute;
    FLibrariesDocumentsRoute: TLibrariesDocumentsRoute;
    FLibrariesAccessRoute: TLibrariesAccessRoute;
    FAudioRoute: TAudioRoute;

    function GetAPI: TMistralAIAPI;
    function GetToken: string;
    procedure SetToken(const Value: string);
    function GetBaseUrl: string;
    procedure SetBaseUrl(const Value: string);
    function GetHttpClient: IHttpClientAPI;
    function GetVersion: string;
    function GetAgentRoute: TAgentRoute;
    function GetChatRoute: TChatRoute;
    function GetCodestralRoute: TCodestralRoute;
    function GetEmbeddingsRoute: TEmbeddingsRoute;
    function GetFilesRoute: TFilesRoute;
    function GetFineTuningRoute: TFineTuningRoute;
    function GetModelsRoute: TModelsRoute;
    function GetClassifiersRoute: TClassifiersRoute;
    function GetBatchRoute: TBatchRoute;
    function GetConversationsRoute: TConversationsRoute;
    function GetConversationsAgentRoute: TConversationsAgentRoute;
    function GetOcrRoute: TOcrRoute;
    function GetLibrariesMainRoute: TLibrariesMainRoute;
    function GetLibrariesDocumentsRoute: TLibrariesDocumentsRoute;
    function GetLibrariesAccessRoute: TLibrariesAccessRoute;
    function GetAudioRoute: TAudioRoute;

  public
    /// <summary>
    /// the main API object used for making requests.
    /// </summary>
    /// <returns>
    /// An instance of TMistralAIAPI for making API calls.
    /// </returns>
    property API: TMistralAIAPI read GetAPI;

    /// <summary>
    /// Sets or retrieves the API token for authentication.
    /// </summary>
    /// <param name="Value">
    /// The API token as a string.
    /// </param>
    /// <returns>
    /// The current API token.
    /// </returns>
    property Token: string read GetToken write SetToken;

    /// <summary>
    /// Sets or retrieves the base URL for API requests.
    /// Default is https://api.mistral.ai/v1.
    /// </summary>
    /// <param name="Value">
    /// The base URL as a string.
    /// </param>
    /// <returns>
    /// The current base URL.
    /// </returns>
    property BaseURL: string read GetBaseUrl write SetBaseUrl;

    /// <summary>
    /// Provides access to the underlying HTTP client used for all API requests.
    /// </summary>
    /// <remarks>
    /// The <c>HttpClient</c> property exposes the <see cref="IHttpClientAPI"/> instance
    /// that handles the low-level HTTP communication with the Mistral AI API.
    /// This can be useful for customizing request behavior, adding headers,
    /// configuring timeouts, or implementing logging and monitoring features.
    /// <para>
    /// It is recommended to use this property only if you need fine-grained control
    /// over HTTP requests or responses. For standard operations,
    /// interact with the higher-level API routes instead.
    /// </para>
    /// </remarks>
    /// <returns>
    /// An <see cref="IHttpClientAPI"/> instance representing the internal HTTP client.
    /// </returns>
    property HttpClient: IHttpClientAPI read GetHttpClient;
  public
    constructor Create; overload;
    constructor Create(const AToken: string; Specs: TSpecs = []); overload;
    destructor Destroy; override;
  end;

  {$REGION 'MistralAI.API.Params'}

  TJSONParam = MistralAI.API.Params.TJSONParam;

  TUrlParam = MistralAI.API.Params.TUrlParam;

  /// <summary>
  /// Represents a generic key-value parameter manager.
  /// </summary>
  /// <remarks>
  /// This class allows storing and retrieving various types of parameters as key-value pairs.
  /// It supports basic types (integers, strings, booleans, floating-point numbers), objects,
  /// as well as arrays of these types.
  /// </remarks>
  /// <example>
  ///   <code>
  ///     var Params: TParameters;
  ///     begin
  ///       Params := TParameters.Create;
  ///       Params.Add('Limit', 100)
  ///             .Add('Order', 'Asc')
  ///             .Add('IsEnabled', True);
  ///       if Params.Exists('Limit') then
  ///         ShowMessage(IntToStr(Params.GetInteger('Limit')));
  ///       Params.Free;
  ///     end;
  ///   </code>
  /// </example>
  TParameters = MistralAI.API.Params.TParameters;

  {$ENDREGION}

  {$REGION 'MistralAI.Schema'}

  /// <summary>
  /// Provides helper methods for creating property items in OpenAPI schema definitions.
  /// </summary>
  /// <remarks>
  /// This record simplifies the creation of property entries when building schema objects,
  /// particularly for object properties in OpenAPI specifications.
  /// </remarks>
  TPropertyItem = MistralAI.Schema.TPropertyItem;

  /// <summary>
  /// Represents the Schema Object in OpenAPI, enabling the definition of input and output data types.
  /// These types can be objects, primitives, or arrays. This class provides methods to build and
  /// configure schema definitions as per the OpenAPI 3.0 Specification.
  /// </summary>
  /// <remarks>
  /// The Schema Object allows the definition of input and output data types in the OpenAPI Specification.
  /// This class provides a fluent interface to construct schema definitions programmatically.
  /// </remarks>
  TSchemaParams = MistralAI.Schema.TSchemaParams;

  /// <summary>
  /// Defines a response format and its schema structure for the MistralAI API.
  /// </summary>
  /// <remarks>
  /// <para>This class allows specifying:</para>
  /// <para>- The name of the response format (Name property).</para>
  /// <para>- The description of the format (Description property).</para>
  /// <para>- The JSON schema describing the expected response structure (Schema overload).</para>
  /// <para>- Enabling strict mode to enforce exact adherence to the schema (Strict property).</para>
  /// </remarks>
  TResponseSchemaParams = MistralAI.Schema.TResponseSchemaParams;

  /// <summary>
  /// Configures the expected output format (text, JSON object, or JSON schema) and its parameters for the MistralAI API.
  /// </summary>
  /// <remarks>
  /// <para>This class allows:</para>
  /// <para>- Selecting the output format type via <c>Type</c> ("text", "json_object", or "json_schema").</para>
  /// <para>- Specifying the JSON schema to use in JSON mode via <c>JsonSchema</c>.</para>
  /// </remarks>
  TResponseFormatParams = MistralAI.Schema.TResponseFormatParams;

  {$ENDREGION}

  {$REGION 'MistralAI.Chat'}

  /// <summary>
  /// Represents a message payload that includes an image, identified by a URL or a base-64 encoded string.
  /// </summary>
  /// <remarks>
  /// This class is used to encapsulate details of an image message, including its source (URL or base-64 string)
  /// and additional descriptive information. It extends <c>TJSONParam</c> for JSON serialization and integration with APIs.
  /// </remarks>
  /// <example>
  /// This class can be utilized to construct structured image messages for communication in chat systems.
  /// </example>
  TMessageImageURL = MistralAI.Chat.TMessageImageURL;

  TDocumentUrlParams = MistralAI.Chat.TDocumentUrlParams;

  /// <summary>
  /// Represents the content of a message, which can be either text or an image URL.
  /// </summary>
  /// <remarks>
  /// This class is used to define the structure and type of content within a message,
  /// such as textual data or image references. It extends <c>TJSONParam</c> for
  /// seamless JSON serialization and integration with APIs.
  /// </remarks>
  TMessageContent = MistralAI.Chat.TMessageContent;

  /// <summary>
  /// Represents the metadata and arguments of a function invoked during a chat interaction.
  /// </summary>
  /// <remarks>
  /// This class is used to define the structure of function calls, including the function's name and its associated arguments.
  /// It is designed to be serialized into JSON format for integration with APIs or other systems requiring structured function data.
  /// </remarks>
  TFunctionCalled = MistralAI.Chat.TFunctionCalled;

  /// <summary>
  /// Represents a tool call configuration used in chat-based operations.
  /// </summary>
  /// <remarks>
  /// This class is designed to define and manage tool calls within chat contexts, including
  /// their type, identifier, and associated functions. It integrates with <c>TJSONParam</c>
  /// for seamless serialization and API interactions.
  /// </remarks>
  TToolCalls = MistralAI.Chat.TToolCalls;

  /// <summary>
  /// Represents the payload structure for a chat message in the context of a conversation.
  /// </summary>
  /// <remarks>
  /// This class encapsulates the essential elements of a chat message, including its role, content,
  /// and associated metadata. It extends <c>TJSONParam</c>, enabling seamless integration with JSON-based
  /// APIs for chat functionalities. This class is a foundational building block for managing the flow of
  /// conversations between users, systems, and assistants.
  /// </remarks>
  TChatMessagePayload = MistralAI.Chat.TChatMessagePayload;

  /// <summary>
  /// Represents the payload structure for a chat message in the context of a conversation.
  /// </summary>
  /// <remarks>
  /// This class encapsulates the essential elements of a chat message, including its role, content,
  /// and associated metadata. It extends <c>TJSONParam</c>, enabling seamless integration with JSON-based
  /// APIs for chat functionalities. This class is a foundational building block for managing the flow of
  /// conversations between users, systems, and assistants.
  /// </remarks>
  PayLoad = MistralAI.Chat.PayLoad;

  /// <summary>
  /// The <c>TChatParams</c> class represents the set of parameters used to configure a chat interaction with an AI model.
  /// </summary>
  /// <remarks>
  /// This class allows you to define various settings that control how the model behaves, including which model to use, how many tokens to generate,
  /// what kind of messages to send, and how the model should handle its output. By using this class, you can fine-tune the AI's behavior and response format
  /// based on your application's specific needs.
  /// <para>
  /// It inherits from <c>TJSONParam</c>, which provides methods for handling and serializing the parameters as JSON, allowing seamless integration
  /// with JSON-based APIs.
  /// </para>
  /// <code>
  /// var
  ///   Params: TChatParams;
  /// begin
  ///   Params := TChatParams.Create
  ///     .Model('my_model')
  ///     .MaxTokens(100)
  ///     .Messages([TChatMessagePayload.User('Hello!')])
  ///     .ResponseFormat('json_object')
  ///     .Temperature(0.7)
  ///     .TopP(1)
  ///     .SafePrompt(True);
  /// end;
  /// </code>
  /// This example shows how to instantiate and configure a <c>TChatParams</c> object for interacting with an AI model.
  /// </remarks>
  TChatParams = MistralAI.Chat.TChatParams;

  TChatContent = MistralAI.Chat.TChatContent;

  /// <summary>
  /// Represents the token usage statistics for a chat interaction, including the number of tokens
  /// used in the prompt, the completion, and the total number of tokens consumed.
  /// </summary>
  /// <remarks>
  /// The <c>TChatUsage</c> class provides insight into the number of tokens used during a chat interaction.
  /// This information is critical for understanding the cost of a request when using token-based billing systems
  /// or for monitoring the model's behavior in terms of input (prompt) and output (completion) size.
  /// </remarks>
  TChatUsage = MistralAI.Chat.TChatUsage;

  /// <summary>
  /// Represents a chat message exchanged between participants (user, assistant, or system) in a conversation.
  /// </summary>
  /// <remarks>
  /// The <c>TChatMessage</c> class encapsulates the essential information of a message within a chat application, including:
  /// - The role of the sender (user, assistant, or system).
  /// - The content of the message itself.
  /// - Optionally, a list of tool calls that may be required to complete the message response.
  /// This class is fundamental for managing the flow of a conversation, allowing the system to track who said what and what actions need to be taken.
  /// </remarks>
  TChatMessage = MistralAI.Chat.TChatMessage;

  /// <summary>
  /// Represents a single completion option generated by the AI model during a chat interaction.
  /// </summary>
  /// <remarks>
  /// The <c>TChatChoices</c> class stores the results of the AI model's response to a user prompt. Each instance of this class represents one of potentially
  /// many choices that the model could return. This includes:
  /// - An index identifying the choice.
  /// - A message generated by the model.
  /// - Optional deltas for streamed responses.
  /// - The reason the model stopped generating tokens.
  /// This class is useful when multiple potential responses are generated and evaluated, or when streaming responses incrementally.
  /// </remarks>
  TChatChoices = MistralAI.Chat.TChatChoices;

  /// <summary>
  /// Represents a chat completion response generated by an AI model, containing the necessary metadata,
  /// the generated choices, and usage statistics.
  /// </summary>
  /// <remarks>
  /// The <c>TChat</c> class encapsulates the results of a chat request made to an AI model.
  /// It contains details such as a unique identifier, the model used, when the completion was created,
  /// the choices generated by the model, and token usage statistics.
  /// This class is crucial for managing the results of AI-driven conversations and understanding the
  /// underlying usage and response characteristics of the AI.
  /// </remarks>
  TChat = MistralAI.Chat.TChat;

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TChat</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynChat</c> type extends the <c>TAsynParams&lt;TChat&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynChat = MistralAI.Chat.TAsynChat;

  /// <summary>
  /// Represents a promise-based asynchronous callback for chat completion operations.
  /// </summary>
  /// <remarks>
  /// Alias of <c>TPromiseCallBack&lt;TChat&gt;</c>, this type allows you to await the result
  /// of a chat completion request and handle it as a <see cref="TChat"/> instance.
  /// </remarks>
  TPromiseChat = MistralAI.Chat.TPromiseChat;

  /// <summary>
  /// Manages asynchronous streaming chat callBacks for a chat request using <c>TChat</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynChatStream</c> type extends the <c>TAsynStreamParams&lt;TChat&gt;</c> record to support the lifecycle of an asynchronous streaming chat operation.
  /// It provides callbacks for different stages, including when the operation starts, progresses with new data chunks, completes successfully, or encounters an error.
  /// This structure is ideal for handling scenarios where the chat response is streamed incrementally, providing real-time updates to the user interface.
  /// </remarks>
  TAsynChatStream = MistralAI.Chat.TAsynChatStream;

  /// <summary>
  /// Represents a promise-based asynchronous callback for streaming chat completion operations.
  /// </summary>
  /// <remarks>
  /// Alias of <c>TPromiseStreamCallBack&lt;TChat&gt;</c>, this type provides a <see cref="TChat"/> stream
  /// that can be awaited, delivering partial <see cref="TChat"/> updates as they arrive.
  /// </remarks>
  TPromiseChatStream = MistralAI.Chat.TPromiseChatStream;

  /// <summary>
  /// Represents a callback procedure used during the reception of responses from a chat request in streaming mode.
  /// </summary>
  /// <param name="Chat">
  /// The <c>TChat</c> object containing the current information about the response generated by the model.
  /// If this value is <c>nil</c>, it indicates that the data stream is complete.
  /// </param>
  /// <param name="IsDone">
  /// A boolean flag indicating whether the streaming process is complete.
  /// If <c>True</c>, it means the model has finished sending all response data.
  /// </param>
  /// <param name="Cancel">
  /// A boolean flag that can be set to <c>True</c> within the callback to cancel the streaming process.
  /// If set to <c>True</c>, the streaming will be terminated immediately.
  /// </param>
  /// <remarks>
  /// This callback is invoked multiple times during the reception of the response data from the model.
  /// It allows for real-time processing of received messages and interaction with the user interface or other systems
  /// based on the state of the data stream.
  /// When the <c>IsDone</c> parameter is <c>True</c>, it indicates that the model has finished responding,
  /// and the <c>Chat</c> parameter will be <c>nil</c>.
  /// </remarks>
  TChatEvent = MistralAI.Chat.TChatEvent;

  {$ENDREGION}

  {$REGION 'MistralAI.Embeddings'}

  /// <summary>
  /// Represents the parameters for an embedding request.
  /// </summary>
  /// <remarks>
  /// Use this class to specify the input text and other parameters for generating embeddings.
  /// </remarks>
  TEmbeddingParams = MistralAI.Embeddings.TEmbeddingParams;

  /// <summary>
  /// Represents token usage statistics for an embedding request.
  /// </summary>
  /// <remarks>
  /// Contains information about the number of tokens used in the request.
  /// </remarks>
  TEmbeddingUsage = MistralAI.Embeddings.TEmbeddingUsage;

  /// <summary>
  /// Represents an embedding result for a single input.
  /// </summary>
  /// <remarks>
  /// Contains the embedding vector and associated metadata for a single input text.
  /// </remarks>
  TEmbeddingData = MistralAI.Embeddings.TEmbeddingData;

  /// <summary>
  /// Represents the response from an embedding request.
  /// </summary>
  /// <remarks>
  /// Contains the embeddings, model information, and usage statistics returned by the API.
  /// </remarks>
  TEmbeddings = MistralAI.Embeddings.TEmbeddings;

  /// <summary>
  /// Represents the asynchronous callback parameters for embedding requests.
  /// </summary>
  /// <remarks>
  /// Used to handle asynchronous responses for embedding operations.
  /// </remarks>
  TAsyncEmbeddings = MistralAI.Embeddings.TAsyncEmbeddings;

  /// <summary>
  /// Defines a promise-style callback wrapper for embedding results.
  /// </summary>
  /// <remarks>
  /// <c>TPromiseEmbeddings</c> is an alias of <c>TPromiseCallBack&lt;TEmbeddings&gt;</c>,
  /// offering a concise way to handle asynchronous embedding operations that
  /// yield a <c>TEmbeddings</c> instance once completed.
  /// </remarks>
  TPromiseEmbeddings = MistralAI.Embeddings.TPromiseEmbeddings;

  {$ENDREGION}

  {$REGION 'MistralAI.Models'}

  /// <summary>
  /// The TModelParams class is used to specify parameters for updating the properties
  /// of a fine-tuned model in the MistralAI environment. It allows you to set new values
  /// for the model's name and description.
  /// </summary>
  /// <remarks>
  /// This class provides a fluent interface for configuring model parameters before
  /// submitting an update request. The Name and Description methods allow you to set
  /// these attributes individually and return the updated TModelParams object, enabling
  /// method chaining for concise configuration.
  /// </remarks>
  TModelParams = MistralAI.Models.TModelParams;

  /// <summary>
  /// The TCapabilities class represents the various features and functionalities
  /// that a MistralAI model can support. It indicates whether the model is capable of
  /// performing specific tasks such as chat completion, function calling, or fine-tuning.
  /// </summary>
  /// <remarks>
  /// This class is used to describe the capabilities of a model, helping users
  /// to understand what operations can be performed with the model. Each property
  /// corresponds to a specific capability, which can be checked to see if the model
  /// supports that feature. This information is typically used when selecting or
  /// configuring models for specific use cases.
  /// </remarks>
  TCapabilities = MistralAI.Models.TCapabilities;

  /// <summary>
  /// The TCoreModel class represents a generic model object that can be used with the MistralAI API.
  /// It contains all the essential properties and metadata required to describe a model, including
  /// its identifier, creation date, capabilities, and other attributes.
  /// </summary>
  /// <remarks>
  /// This class serves as the base class for more specific model types and provides a comprehensive
  /// view of a model's characteristics. The properties in this class are primarily used for
  /// interacting with the MistralAI API and retrieving model metadata. It is designed to be
  /// extended by other classes that represent more specialized model types.
  /// </remarks>
  TCoreModel = MistralAI.Models.TCoreModel;

  /// <summary>
  /// The TModel class extends TCoreModel to include additional information about
  /// the model's deprecation status. It inherits all the properties of TCoreModel
  /// and adds a field to track when the model is considered deprecated.
  /// </summary>
  /// <remarks>
  /// This class is used to represent models that are still available in the MistralAI environment
  /// but are marked as deprecated. Deprecation indicates that the model may no longer be supported
  /// in future versions, and users are encouraged to migrate to newer models if possible.
  /// This class is particularly useful for managing model lifecycles and ensuring that applications
  /// do not rely on outdated or unsupported models.
  /// </remarks>
  TModel = MistralAI.Models.TModel;

  /// <summary>
  /// The TFineTunedModel class extends the TCoreModel class to represent a fine-tuned model
  /// within the MistralAI environment. It includes additional information specific to the
  /// fine-tuning process, such as the job identifier associated with the fine-tuning operation.
  /// </summary>
  /// <remarks>
  /// This class is used to manage and interact with fine-tuned models, which are variants of
  /// base models that have been further trained on specific datasets to improve performance
  /// in specialized tasks. It inherits all properties from TCoreModel and adds specific
  /// attributes related to the fine-tuning process.
  /// </remarks>
  TFineTunedModel = MistralAI.Models.TFineTunedModel;

  /// <summary>
  /// The TModels class represents a collection of available models in the MistralAI environment.
  /// It provides basic information about each model, including the owner and availability,
  /// allowing users to list and inspect the models they have access to.
  /// </summary>
  /// <remarks>
  /// This class serves as a container for multiple `TModel` instances, each representing
  /// a different model. It is primarily used to retrieve a comprehensive list of models
  /// from the MistralAI API, and it can be helpful for applications that need to display
  /// or manage multiple models at once.
  /// </remarks>
  TModels = MistralAI.Models.TModels;

  /// <summary>
  /// The TModelDeletion class manages the data returned after the successful deletion
  /// of a fine-tuned model in the MistralAI environment. It contains information
  /// about the model that was deleted, such as its ID and deletion status.
  /// </summary>
  /// <remarks>
  /// This class is used to capture the result of a model deletion request.
  /// It provides confirmation that the specified model has been successfully deleted
  /// from the system. This information is important for auditing and tracking purposes,
  /// especially in environments where model management and lifecycle tracking are critical.
  /// </remarks>
  TModelDeletion = MistralAI.Models.TModelDeletion;

  /// <summary>
  /// The TArchivingModel class represents the state of a fine-tuned model in terms of its
  /// archiving status. It is used to track whether a model has been archived or unarchived
  /// within the MistralAI environment.
  /// </summary>
  /// <remarks>
  /// This class is primarily used for operations that involve archiving or unarchiving models.
  /// Archiving a model makes it inactive, while unarchiving restores it to an active state.
  /// The class provides properties to check the current state and to identify the model being
  /// affected.
  /// </remarks>
  TArchivingModel = MistralAI.Models.TArchivingModel;

  /// <summary>
  /// Represents an asynchronous callback parameter for retrieving a list of models.
  /// </summary>
  /// <remarks>
  /// This type is used when performing asynchronous operations to list models in the
  /// MistralAI environment. It enables the handling of the response containing a collection
  /// of models through a callback mechanism, facilitating non-blocking data retrieval.
  /// </remarks>
  TAsynModels = MistralAI.Models.TAsynModels;

  /// <summary>
  /// Defines a promise-based asynchronous callback that resolves with a <c>TModels</c> collection.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TPromiseCallBack&lt;TModels&gt;</c> enables a promise-style workflow
  /// for listing models, allowing consumers to handle the returned collection asynchronously
  /// without blocking the calling thread.
  /// </remarks>
  TPromiseModels = MistralAI.Models.TPromiseModels;

  /// <summary>
  /// Represents an asynchronous callback parameter for model deletion operations.
  /// </summary>
  /// <remarks>
  /// This type is used when performing asynchronous delete operations on a model. It
  /// allows the handling of the response which indicates the status of the deletion request.
  /// This type is essential for managing deletion results in a non-blocking manner, enabling
  /// efficient UI updates or further processing based on the deletion status.
  /// </remarks>
  TAsynModelDeletion = MistralAI.Models.TAsynModelDeletion;

  /// <summary>
  /// Defines a promise-based asynchronous callback that resolves with a <c>TModelDeletion</c> result.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TPromiseCallBack&lt;TModelDeletion&gt;</c> allows consumers to await
  /// the result of a model deletion operation using a promise-style API, handling success
  /// or error scenarios without blocking the calling thread.
  /// </remarks>
  TPromiseModelDeletion = MistralAI.Models.TPromiseModelDeletion;

  /// <summary>
  /// Represents an asynchronous callback parameter for retrieving details of a specific model.
  /// </summary>
  /// <remarks>
  /// This type is used when performing asynchronous operations to fetch detailed information
  /// about a specific model. It allows for handling the response containing the model's metadata
  /// and capabilities in a non-blocking fashion. This is particularly useful for updating UI elements
  /// or triggering additional actions based on the model's properties.
  /// </remarks>
  TAsynModel = MistralAI.Models.TAsynModel;

  /// <summary>
  /// Defines a promise-based asynchronous callback that resolves with a <c>TModel</c> instance.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TPromiseCallBack&lt;TModel&gt;</c> allows consumers to await the
  /// result of a model-retrieval operation in a promise-style workflow, handling success
  /// or failure through callbacks rather than blocking the calling thread.
  /// </remarks>
  TPromiseModel = MistralAI.Models.TPromiseModel;

  /// <summary>
  /// Represents an asynchronous callback parameter for updating a fine-tuned model.
  /// </summary>
  /// <remarks>
  /// This type is used during asynchronous update operations on fine-tuned models. It enables
  /// handling the response, which contains the updated model details, through a callback mechanism.
  /// This is useful for reflecting changes in the user interface or performing further processing
  /// based on the updated model information.
  /// </remarks>
  TAsynFineTuneModel = MistralAI.Models.TAsynFineTuneModel;

  /// <summary>
  /// Defines a promise-based asynchronous callback that resolves with a <c>TFineTunedModel</c> instance.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TPromiseCallBack&lt;TFineTunedModel&gt;</c> enables a promise-style workflow
  /// for retrieving the result of a fine-tune operation, allowing consumers to handle the updated
  /// model or any errors asynchronously without blocking the calling thread.
  /// </remarks>
  TPromiseFineTuneModel = MistralAI.Models.TPromiseFineTuneModel;

  /// <summary>
  /// Represents an asynchronous callback parameter for archiving or unarchiving a model.
  /// </summary>
  /// <remarks>
  /// This type is used when performing asynchronous archiving or unarchiving operations on a model.
  /// It allows handling the response, which indicates the status of the operation, in a non-blocking manner.
  /// This type is essential for updating the state of the model in the application without blocking the main thread.
  /// </remarks>
  TAsynArchivingModel = MistralAI.Models.TAsynArchivingModel;

  /// <summary>
  /// Defines a promise-based asynchronous callback that resolves with a <c>TArchivingModel</c> result.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TPromiseCallBack&lt;TArchivingModel&gt;</c> enables a promise-style workflow
  /// for archiving or unarchiving operations, allowing consumers to handle the archiving status
  /// asynchronously without blocking the calling thread.
  /// </remarks>
  TPromiseArchivingModel = MistralAI.Models.TPromiseArchivingModel;

  {$ENDREGION}

  {$REGION 'MistralAI.FineTunings'}

  /// <summary>
  /// Represents the parameters for listing fine-tuning jobs.
  /// </summary>
  /// <remarks>
  /// Allows filtering and pagination of fine-tuning jobs when retrieving them via the API.
  /// </remarks>
  TFineTuningJobListParams = MistralAI.FineTunings.TFineTuningJobListParams;

  /// <summary>
  /// Represents the hyperparameters used in a fine-tuning job.
  /// </summary>
  /// <remarks>
  /// Includes settings such as the number of training steps and the learning rate.
  /// </remarks>
  THyperparametersParams = MistralAI.FineTunings.THyperparametersParams;

  /// <summary>
  /// Represents the integration parameters for a fine-tuning job.
  /// </summary>
  /// <remarks>
  /// Specifies details for integrating with external platforms for monitoring fine-tuning jobs, such as Weights and Biases.
  /// </remarks>
  TJobIntegrationsParams = MistralAI.FineTunings.TJobIntegrationsParams;

  /// <summary>
  /// Represents the parameters required for configuring a repository in fine-tuning jobs.
  /// </summary>
  /// <remarks>
  /// This class is used to specify details about a repository, including its type, name, owner, reference,
  /// weight, and token. These parameters are typically used when setting up repositories for fine-tuning jobs.
  /// </remarks>
  TRepositoryParams = MistralAI.FineTunings.TRepositoryParams;

  /// <summary>
  /// Represents the parameters for creating a fine-tuning job.
  /// </summary>
  /// <remarks>
  /// Includes settings such as the model to fine-tune, training files, hyperparameters, and integrations.
  /// </remarks>
  TFineTuningJobParams = MistralAI.FineTunings.TFineTuningJobParams;

  /// <summary>
  /// Represents the hyperparameters output in a fine-tuning job response.
  /// </summary>
  /// <remarks>
  /// Contains the hyperparameter settings used during fine-tuning.
  /// </remarks>
  TJobOutHyperparameters = MistralAI.FineTunings.TJobOutHyperparameters;

  /// <summary>
  /// Represents the integrations output in a fine-tuning job response.
  /// </summary>
  /// <remarks>
  /// Contains information about integrations enabled for the fine-tuning job.
  /// </remarks>
  TJobOutIntegrations = MistralAI.FineTunings.TJobOutIntegrations;

  /// <summary>
  /// Represents a repository used in the context of fine-tuning jobs.
  /// </summary>
  /// <remarks>
  /// This class encapsulates information about a repository, including its type, name, owner, reference, weight, and commit ID.
  /// It is used to provide detailed metadata about the repository in fine-tuning operations.
  /// </remarks>
  TRepository = MistralAI.FineTunings.TRepository;

  /// <summary>
  /// Represents metadata associated with data used in fine-tuning jobs.
  /// </summary>
  /// <remarks>
  /// This class provides detailed information about the cost, duration, and token usage
  /// for fine-tuning operations, offering insights into resource consumption.
  /// </remarks>
  TDataMetadata = MistralAI.FineTunings.TDataMetadata;

  /// <summary>
  /// Represents the output of a fine-tuning job.
  /// </summary>
  /// <remarks>
  /// Contains details about the fine-tuning job, including its status, parameters, and results.
  /// </remarks>
  TJobOut = MistralAI.FineTunings.TJobOut;

  /// <summary>
  /// Represents a list of fine-tuning jobs.
  /// </summary>
  /// <remarks>
  /// Contains an array of fine-tuning job outputs.
  /// </remarks>
  TListFineTuningJobs = MistralAI.FineTunings.TListFineTuningJobs;

  /// <summary>
  /// Status and error dot a fine-tune job.
  /// </summary>
  TJobOutEventData = MistralAI.FineTunings.TJobOutEventData;

  /// <summary>
  /// Represents an event in the fine-tuning job lifecycle.
  /// </summary>
  /// <remarks>
  /// Contains information about status changes during the job.
  /// </remarks>
  TJobOutEvent = MistralAI.FineTunings.TJobOutEvent;

  /// <summary>
  /// Represents metrics associated with a checkpoint during fine-tuning.
  /// </summary>
  /// <remarks>
  /// Contains loss and accuracy metrics.
  /// </remarks>
  TJobOutMetrics = MistralAI.FineTunings.TJobOutMetrics;

  /// <summary>
  /// Represents a checkpoint during the fine-tuning job.
  /// </summary>
  /// <remarks>
  /// Contains metrics and timing information at a specific step.
  /// </remarks>
  TJobOutCheckpoints = MistralAI.FineTunings.TJobOutCheckpoints;

  /// <summary>
  /// Represents detailed progress information for a fine-tuning job.
  /// </summary>
  /// <remarks>
  /// Extends <see cref="TJobOut"/> with events and checkpoints.
  /// </remarks>
  TJobOutProgress = MistralAI.FineTunings.TJobOutProgress;

  /// <summary>
  /// Asynchronous callback parameters for listing fine-tuning jobs.
  /// </summary>
  TAsynListFineTuningJobs = MistralAI.FineTunings.TAsynListFineTuningJobs;

  /// <summary>
  /// Represents a promise‑based asynchronous callback that resolves to a list of fine‑tuning jobs.
  /// </summary>
  /// <remarks>
  /// This is an alias for <c>TPromiseCallback&lt;TListFineTuningJobs&gt;</c>, allowing callers to await
  /// the result of the <see cref="TFineTuningRoute.List"/> operation in a promise‑style workflow.
  /// </remarks>
  TPromiseListFineTuningJobs = MistralAI.FineTunings.TPromiseListFineTuningJobs;

  /// <summary>
  /// Asynchronous callback parameters for fine-tuning job output.
  /// </summary>
  TAsynJobOut = MistralAI.FineTunings.TAsynJobOut;

  /// <summary>
  /// Represents a promise‑based asynchronous callback that resolves to a fine‑tuning job output.
  /// </summary>
  /// <remarks>
  /// This is an alias for <c>TPromiseCallback&lt;TJobOut&gt;</c>, enabling callers to await
  /// the result of the <see cref="TFineTuningRoute.CreateJob"/> operation in a promise‑style workflow.
  /// </remarks>
  TPromiseJobOut = MistralAI.FineTunings.TPromiseJobOut;

  /// <summary>
  /// Asynchronous callback parameters for fine-tuning job progress.
  /// </summary>
  TAsynJobOutProgress = MistralAI.FineTunings.TAsynJobOutProgress;

  /// <summary>
  /// Represents a promise‑based asynchronous callback that resolves to detailed fine‑tuning job progress.
  /// </summary>
  /// <remarks>
  /// This is an alias for <c>TPromiseCallback&lt;TJobOutProgress&gt;</c>, allowing callers to await
  /// the result of the <see cref="TFineTuningRoute.Retrieve"/> (or <see cref="TFineTuningRoute.Cancel"/>)
  /// operation in a promise‑style workflow.
  /// </remarks>
  TPromiseJobOutProgress = MistralAI.FineTunings.TPromiseJobOutProgress;

  {$ENDREGION}

  {$REGION 'MistralAI.Codestral'}

  /// <summary>
  /// The <c>TCodestralParams</c> class represents the set of parameters used to configure the behavior and output generation of the Codestral model.
  /// </summary>
  /// <remarks>
  /// This class allows you to define various settings that control how the model generates completions, including which model to use, the temperature of the output,
  /// and how many tokens to generate. By using this class, you can customize the model's response and fine-tune its behavior to suit the specific requirements of your application.
  /// <para>
  /// It inherits from <c>TJSONParam</c>, which provides methods for handling and serializing the parameters as JSON, enabling easy integration
  /// with JSON-based APIs. The parameters include options for setting prompts, suffixes, streaming preferences, and random seeds, among others.
  /// </para>
  /// <code>
  /// var
  ///   Params: TCodestralParams;
  /// begin
  ///   Params := TCodestralParams.Create
  ///     .Model('codestral-latest')
  ///     .Prompt('Generate a code snippet')
  ///     .MaxTokens(100)
  ///     .Temperature(0.7)
  ///     .TopP(0.9)
  ///     .Stop(['\n\n'])
  ///     .Stream(True);          // or Stream();
  /// end;
  /// </code>
  /// This example demonstrates how to instantiate and configure a <c>TCodestralParams</c> object to generate a code snippet using the Codestral model.
  /// </remarks>
  TCodestralParams = MistralAI.Codestral.TCodestralParams;

  /// <summary>
  /// Represents the token usage statistics for a request, including the number of tokens used in the prompt,
  /// the completion, and the total number of tokens consumed.
  /// </summary>
  /// <remarks>
  /// The <c>TCodestralUsage</c> class provides information on the number of tokens utilized during a request.
  /// This data is essential for understanding the token cost associated with a request, particularly in contexts
  /// where token-based billing is employed, or for monitoring the model's behavior in terms of input and output sizes.
  /// </remarks>
  TCodestralUsage = MistralAI.Codestral.TCodestralUsage;

  /// <summary>
  /// Represents a message exchanged in a conversation, containing the role of the sender and the message content.
  /// </summary>
  /// <remarks>
  /// The <c>TCodestralMessage</c> class captures the essential details of a message in a chat interaction,
  /// including the role of the sender (e.g., user or assistant) and the content of the message.
  /// This class is fundamental for managing and interpreting the flow of a conversation, providing context on who sent
  /// the message and what was communicated.
  /// </remarks>
  TCodestralMessage = MistralAI.Codestral.TCodestralMessage;

  /// <summary>
  /// Represents a single completion option generated by the AI model during a chat or completion interaction.
  /// </summary>
  /// <remarks>
  /// The <c>TCodestralChoices</c> class encapsulates the details of a single choice made by the AI model.
  /// Each instance of this class represents one possible response that the model could generate.
  /// This includes:
  /// - An index indicating the position of this choice among multiple options.
  /// - A complete message response generated by the model.
  /// - Optional deltas representing partial responses in the case of streamed outputs.
  /// - The reason why the model stopped generating tokens.
  /// This class is useful when evaluating multiple response options or handling streaming outputs that build over time.
  /// </remarks>
  TCodestralChoices = MistralAI.Codestral.TCodestralChoices;

  /// <summary>
  /// Represents a codestral completion response generated by an AI model, containing metadata,
  /// generated choices, and usage statistics.
  /// </summary>
  /// <remarks>
  /// The <c>TCodestral</c> class encapsulates the results of a completion request made to an AI model.
  /// It includes details such as a unique identifier, the model used, when the completion was created,
  /// the choices generated by the model, and usage statistics.
  /// This class is essential for managing and understanding the results of AI-driven completions,
  /// as well as tracking the underlying usage and response characteristics.
  /// </remarks>
  TCodestral = MistralAI.Codestral.TCodestral;

  /// <summary>
  /// Manages asynchronous chat events for a chat request using <c>TCodestral</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynCode</c> type extends the <c>TAsynParams&lt;TCodestral&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynCode = MistralAI.Codestral.TAsynCode;

  /// <summary>
  /// Represents a promise-based asynchronous callback for code completion operations using the Codestral model.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TPromiseCallBack&lt;TCodestral&gt;</c> enables awaiting a <see cref="TCodestral"/> result
  /// in promise-style flows. Use it when you need to handle success, error, or cancellation events
  /// for a Codestral completion without blocking the calling thread.
  /// </remarks>
  TPromiseCode = MistralAI.Codestral.TPromiseCode;

  /// <summary>
  /// Manages asynchronous streaming chat events for a chat request using <c>TCodestral</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynCodeStream</c> type extends the <c>TAsynStreamParams&lt;TCodestral&gt;</c> record to support the lifecycle of an asynchronous streaming chat operation.
  /// It provides callbacks for different stages, including when the operation starts, progresses with new data chunks, completes successfully, or encounters an error.
  /// This structure is ideal for handling scenarios where the chat response is streamed incrementally, providing real-time updates to the user interface.
  /// </remarks>
  TAsynCodeStream = MistralAI.Codestral.TAsynCodeStream;

  /// <summary>
  /// Represents a promise-based asynchronous streaming callback for code completion operations using the Codestral model.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TPromiseStreamCallBack&lt;TCodestral&gt;</c> enables awaiting both partial results and the final
  /// <see cref="TCodestral"/> response in a promise-style flow. Use it to handle on-progress updates, successful completion,
  /// errors, or cancellation for a streaming Codestral completion without blocking the calling thread.
  /// </remarks>
  TPromiseCodeStream = MistralAI.Codestral.TPromiseCodeStream;

  /// <summary>
  /// Represents a callback procedure used during the reception of responses from a codestral request in streaming mode.
  /// </summary>
  /// <param name="Codestral">
  /// The <c>TCodestral</c> object containing the current information about the response generated by the model.
  /// If this value is <c>nil</c>, it indicates that the data stream is complete.
  /// </param>
  /// <param name="IsDone">
  /// A boolean flag indicating whether the streaming process is complete.
  /// If <c>True</c>, it means the model has finished sending all response data.
  /// </param>
  /// <param name="Cancel">
  /// A boolean flag that can be set to <c>True</c> within the callback to cancel the streaming process.
  /// If set to <c>True</c>, the streaming will be terminated immediately.
  /// </param>
  /// <remarks>
  /// This callback is invoked multiple times during the reception of the response data from the model.
  /// It allows for real-time processing of received messages and interaction with the user interface or other systems
  /// based on the state of the data stream.
  /// When the <c>IsDone</c> parameter is <c>True</c>, it indicates that the model has finished responding,
  /// and the <c>Codestral</c> parameter will be <c>nil</c>.
  /// </remarks>
  TCodestralEvent = MistralAI.Codestral.TCodestralEvent;

  {$ENDREGION}

  {$REGION 'MistralAI.Httpx'}

  /// <summary>
  /// THttpx provides utility methods for handling HTTP-related tasks such as
  /// downloading data, encoding it in Base64, and retrieving MIME types.
  /// </summary>
  THttpx = MistralAI.Httpx.THttpx;

  {$ENDREGION}

  {$REGION 'MistralAI.Files'}

  /// <summary>
  /// Parameters for uploading a file.
  /// </summary>
  /// <remarks>
  /// This class is used to construct the multipart form data for file uploads.
  /// Example usage:
  /// <code>
  /// var
  ///   UploadParams: TUploadParams;
  /// begin
  ///   UploadParams := TUploadParams.Create;
  ///   try
  ///     UploadParams.File('path/to/file.jsonl');
  ///     UploadParams.Purpose(TFilePurpose.finetune);
  ///     // Use UploadParams with the API upload method
  ///   finally
  ///     UploadParams.Free;
  ///   end;
  /// end;
  /// </code>
  /// </remarks>
  TUploadParams = MistralAI.Files.TUploadParams;

  /// <summary>
  /// Represents the parameters for listing files with specific criteria.
  /// </summary>
  /// <remarks>
  /// This class is used to configure and pass parameters when listing files from the API.
  /// It provides methods to set pagination, filtering, and searching options.
  /// </remarks>
  TListParams = MistralAI.Files.TListParams;

  /// <summary>
  /// Represents a file in the Mistral AI system.
  /// </summary>
  /// <remarks>
  /// This class contains properties that represent the attributes of a file as returned by the API.
  /// </remarks>
  TFile = MistralAI.Files.TFile;

  /// <summary>
  /// Represents a collection of files.
  /// </summary>
  /// <remarks>
  /// This class is used to hold a list of files as returned by the API.
  /// Example usage:
  /// <code>
  /// var
  ///   Files: TFiles;
  ///   FileItem: TFile;
  /// begin
  ///   Files := FilesRoute.List;
  ///   try
  ///     for FileItem in Files.Data do
  ///     begin
  ///       // Process each file
  ///     end;
  ///   finally
  ///     Files.Free;
  ///   end;
  /// end;
  /// </code>
  /// </remarks>
  TFiles = MistralAI.Files.TFiles;

  /// <summary>
  /// Represents the result of a file deletion operation.
  /// </summary>
  /// <remarks>
  /// Contains information about the deletion status and the ID of the deleted file.
  /// </remarks>
  TDeletedResult = MistralAI.Files.TDeletedResult;

  /// <summary>
  /// Represents a downloaded file, providing functionality to access and save its data.
  /// </summary>
  /// <remarks>
  /// This class encapsulates a downloaded file and provides methods to retrieve its data as a stream
  /// or save it to a file. The file data is expected to be in a base64-encoded format.
  /// </remarks>
  TDownLoadFile = MistralAI.Files.TDownLoadFile;

  /// <summary>
  /// Asynchronous callback parameters for operations returning a single <c>TFile</c>.
  /// </summary>
  /// <remarks>
  /// Used when performing asynchronous operations that return a <c>TFile</c> instance.
  /// </remarks>
  TAsyncFile = MistralAI.Files.TAsyncFile;

  /// <summary>
  /// Promise-based callback parameters for operations returning a single <c>TFile</c>.
  /// </summary>
  /// <remarks>
  /// Use this type when you prefer a promise-style API over traditional callbacks.
  /// </remarks>
  TPromiseFile = MistralAI.Files.TPromiseFile;

  /// <summary>
  /// Asynchronous callback parameters for operations returning <c>TFiles</c>.
  /// </summary>
  /// <remarks>
  /// Used when performing asynchronous operations that return a <c>TFiles</c> instance.
  /// </remarks>
  TAsyncFiles = MistralAI.Files.TAsyncFiles;

  /// <summary>
  /// Promise-based callback parameters for operations returning a collection of <c>TFile</c> objects.
  /// </summary>
  /// <remarks>
  /// Use this type when you prefer a promise-style API over traditional callbacks for file list operations.
  /// </remarks>
  TPromiseFiles = MistralAI.Files.TPromiseFiles;

  /// <summary>
  /// Asynchronous callback parameters for file deletion operations.
  /// </summary>
  /// <remarks>
  /// Used when performing asynchronous operations that return a <c>TDeletedResult</c> instance.
  /// </remarks>
  TAsyncFilesDelete = MistralAI.Files.TAsyncFilesDelete;

  /// <summary>
  /// Promise-based callback parameters for operations that delete a file, returning a <c>TDeletedResult</c>.
  /// </summary>
  /// <remarks>
  /// Use this type when you prefer a promise-style API over traditional callbacks for file deletion operations.
  /// </remarks>
  TPromiseFilesDelete = MistralAI.Files.TPromiseFilesDelete;

  /// <summary>
  /// Asynchronous callback parameters for file download operations.
  /// </summary>
  /// <remarks>
  /// Used when performing asynchronous operations that return a <c>TDownLoadFile</c> instance.
  /// </remarks>
  TAsyncDownLoadFile = MistralAI.Files.TAsyncDownLoadFile;

  /// <summary>
  /// Promise-based callback parameters for operations returning a downloaded <c>TDownLoadFile</c>.
  /// </summary>
  /// <remarks>
  /// Use this type when you prefer a promise-style API over traditional callbacks for file download operations.
  /// </remarks>
  TPromiseDownLoadFile = MistralAI.Files.TPromiseDownLoadFile;

  /// <summary>
  /// Represents URL signing parameters for file access requests.
  /// </summary>
  /// <remarks>
  /// Use this class to specify how long a pre-signed URL remains valid.
  /// The default expiry is 24 hours.
  /// </remarks>
  TSignedUrlParams = MistralAI.Files.TSignedUrlParams;

  /// <summary>
  /// Represents a pre-signed URL returned by the API for temporary file access.
  /// </summary>
  /// <remarks>
  /// This class holds the URL that grants time-limited access to a file resource.
  /// Use the <see cref="Url"/> property before it expires.
  /// </remarks>
  TSignedUrl = MistralAI.Files.TSignedUrl;

  /// <summary>
  /// Asynchronous callback parameters for operations returning a <c>TSignedUrl</c>.
  /// </summary>
  /// <remarks>
  /// Use this type when performing an asynchronous request to obtain a pre-signed URL.
  /// Configure its <c>OnSuccess</c> and <c>OnError</c> handlers to handle the result or any errors.
  /// Example:
  /// <code>
  /// MistralAI.File.AsyncGetSignedUrl(
  ///   'file_id',
  ///   procedure(Params: TSignedUrlParams)
  ///   begin
  ///     Params.Expiry(24);
  ///   end,
  ///   function: TAsyncSignedUrl
  ///   begin
  ///     Result.OnSuccess :=
  ///       procedure(Sender: TObject; UrlResult: TSignedUrl)
  ///       begin
  ///         // Use UrlResult.Url
  ///       end;
  ///     Result.OnError :=
  ///       procedure(Sender: TObject; ErrorMsg: string)
  ///       begin
  ///         // Handle error
  ///       end;
  ///   end);
  /// </code>
  /// </remarks>
  TAsyncSignedUrl = MistralAI.Files.TAsyncSignedUrl;

  /// <summary>
  /// Promise-style callback parameters for operations returning a <c>TSignedUrl</c>.
  /// </summary>
  /// <remarks>
  /// Use this type when you prefer a promise-based API to request a pre-signed URL.
  /// The returned promise exposes <c>Then</c> for success and <c>Catch</c> for error handling.
  /// Example:
  /// <code>
  /// FilesRoute.AsyncAwaitGetSignedUrl(
  ///   'file_id',
  ///   procedure(Params: TSignedUrlParams)
  ///   begin
  ///     Params.Expiry(24);
  ///   end
  /// ).Then(
  ///   function(UrlResult: TSignedUrl): TSignedUrl
  ///   begin
  ///     // Use UrlResult.Url
  ///   end
  /// ).Catch(
  ///   procedure(E: Exception)
  ///   begin
  ///     // Handle error
  ///   end
  /// );
  /// </code>
  /// </remarks>
  TPromiseSignedUrl = MistralAI.Files.TPromiseSignedUrl;

  {$ENDREGION}

  {$REGION 'MistralAI.Functions.Tools'}

  /// <summary>
  /// Represents a tool used for interacting with chat messages, including the ability to convert
  /// functions to JSON format.
  /// </summary>
  TChatMessageTool = MistralAI.Functions.Tools.TChatMessageTool;

  /// <summary>
  /// Represents the specifics of a called function, including its name and calculated arguments.
  /// </summary>
  TCalledFunctionSpecifics = MistralAI.Functions.Tools.TCalledFunctionSpecifics;

  /// <summary>
  /// Represents a called function, containing its specifics such as name and arguments.
  /// </summary>
  TCalledFunction = MistralAI.Functions.Tools.TCalledFunction;

  {$ENDREGION}

  {$REGION 'MistralAI.Agents'}

  /// <summary>
  /// Alias for <c>TChatMessagePayload</c>, representing an agent message payload.
  /// </summary>
  TAgentMessagePayload = MistralAI.Agents.TAgentMessagePayload;

  /// <summary>
  /// Provides methods to interact with agents, including creating completions and handling asynchronous operations.
  /// </summary>
  /// <remarks>
  /// Use this class to manage agent interactions, including synchronous and asynchronous requests.
  /// </remarks>
  TAgentParams = MistralAI.Agents.TAgentParams;

  {$ENDREGION}

  {$REGION 'MistralAI.Functions.Core'}

  /// <summary>
  /// Interface defining the core structure and functionality of a function in the system.
  /// </summary>
  /// <remarks>
  /// This interface outlines the basic properties and methods that any function implementation must include.
  /// </remarks>
  IFunctionCore = MistralAI.Functions.Core.IFunctionCore;

  /// <summary>
  /// Abstract base class for implementing core function behavior.
  /// </summary>
  /// <remarks>
  /// This class provides basic implementations for some methods and defines the structure that derived classes must follow.
  /// </remarks>
  TFunctionCore = MistralAI.Functions.Core.TFunctionCore;

  {$ENDREGION}

  {$REGION 'MistralAI.Classifiers'}

  /// <summary>
  /// <c>TModerationParams</c> class to manage params for guardrails in a text.
  /// </summary>
  /// <remarks>
  /// The policy threshold is determined based on the optimal performance of oan internal test set.
  /// You can use the raw score or adjust the threshold according to your specific use cases.
  /// </remarks>
  TModerationParams = MistralAI.Classifiers.TModerationParams;

  /// <summary>
  /// <c>TModerationChatParams</c> class to manage params for guardrails in a chat generation.
  /// </summary>
  /// <remarks>
  /// The policy threshold is determined based on the optimal performance of oan internal test set.
  /// You can use the raw score or adjust the threshold according to your specific use cases.
  /// </remarks>
  TModerationChatParams = MistralAI.Classifiers.TModerationChatParams;

  /// <summary>
  /// <c>TModerationCategories</c> class defines the categories for moderation checks.
  /// </summary>
  /// <remarks>
  /// This class provides a structured representation of the moderation categories
  /// used to evaluate the content against predefined guardrails. Each property corresponds
  /// to a specific moderation category and indicates whether the content violates that category.
  /// </remarks>
  TModerationCategories = MistralAI.Classifiers.TModerationCategories;

  /// <summary>
  /// <c>TModerationScores</c> class defines the scoring system for moderation categories.
  /// </summary>
  /// <remarks>
  /// This class provides a structured representation of the scores associated with each moderation category.
  /// Each property contains a numerical value indicating the likelihood that the content violates the corresponding category.
  /// </remarks>
  TModerationScores = MistralAI.Classifiers.TModerationScores;

  /// <summary>
  /// Represents a warning item in the moderation results, containing the category and its associated score.
  /// </summary>
  /// <remarks>
  /// This record is used to store information about a specific moderation category violation,
  /// including the category name and the numerical score indicating the likelihood of the violation.
  /// </remarks>
  TWarningItem = MistralAI.Classifiers.TWarningItem;

  /// <summary>
  /// <c>TModerationResult</c> class represents the results of a moderation check.
  /// </summary>
  /// <remarks>
  /// This class contains information about the moderation categories and their associated scores.
  /// It provides a detailed breakdown of whether content violates predefined moderation categories
  /// and the likelihood of such violations.
  /// </remarks>
  TModerationResult = MistralAI.Classifiers.TModerationResult;

  /// <summary>
  /// <c>TModeration</c> class represents the overall result of a moderation request.
  /// </summary>
  /// <remarks>
  /// This class provides a high-level summary of the moderation operation,
  /// including the request ID, the model used for moderation, and the detailed results
  /// for each category and score. It is the main structure returned by the moderation API.
  /// </remarks>
  TModeration = MistralAI.Classifiers.TModeration;

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TModeration</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynModeration</c> type extends the <c>TAsynParams&lt;TModeration&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynModeration = MistralAI.Classifiers.TAsynModeration;

  /// <summary>
  /// Defines a promise-style callback wrapper for moderation results.
  /// </summary>
  /// <remarks>
  /// <c>TPromiseModeration</c> is an alias of <c>TPromiseCallBack&lt;TModeration&gt;</c>,
  /// providing a streamlined way to handle asynchronous moderation operations
  /// that yield a <c>TModeration</c> instance when completed.
  /// </remarks>
  TPromiseModeration = MistralAI.Classifiers.TPromiseModeration;

  {$ENDREGION}

  {$REGION 'MistralAI.Batch'}

  /// <summary>
  /// Represents a class for constructing and managing query parameters to list batch jobs in the MistralAI API.
  /// </summary>
  /// <remarks>
  /// This class provides methods to define filters such as page size, model name, creation date, and batch status,
  /// allowing precise control over the listing of batch jobs.
  /// </remarks>
  TBatchJobListParams = MistralAI.Batch.TBatchJobListParams;

  /// <summary>
  /// Represents a class for managing parameters required to create a batch job for the MistralAI API.
  /// This class, <c>TBatchJobParams</c>, extends <c>TJSONParam</c> to construct and handle JSON payloads for batch job creation.
  ///</summary>
  ///<remarks>
  /// A batch job consists of multiple API requests, each identified by a unique <c>custom_id</c>.
  /// This class simplifies the process of defining the parameters and generating the required JSON payloads for a batch job.
  ///</remarks>
  TBatchJobParams = MistralAI.Batch.TBatchJobParams;

  /// <summary>
  /// Represents a class for capturing error information related to batch job processing in the MistralAI API.
  /// </summary>
  /// <remarks>
  /// This class provides details about errors encountered during batch job processing, including error messages and counts.
  /// </remarks>
  TBatchJobListDataError = MistralAI.Batch.TBatchJobListDataError;

  /// <summary>
  /// Represents a batch job in the MistralAI API.
  /// </summary>
  /// <remarks>
  /// A batch job contains details about the processing status, input files, model used, metadata, and
  /// the results of the batch operation.
  /// </remarks>
  TBatchJob = MistralAI.Batch.TBatchJob;

  /// <summary>
  /// Represents a collection of batch jobs in the MistralAI API.
  /// </summary>
  /// <remarks>
  /// This class contains a list of batch jobs along with metadata about the collection,
  /// such as the total number of jobs and the object type.
  /// </remarks>
  TBatchJobList = MistralAI.Batch.TBatchJobList;

  /// <summary>
  /// Asynchronous callback parameters for operations returning a single <c>TBatchJob</c>.
  /// </summary>
  /// <remarks>
  /// Used when performing asynchronous operations that return a <c>TBatchJob</c> instance.
  /// </remarks>
  TAsynBatchJob = MistralAI.Batch.TAsynBatchJob;

  /// <summary>
  /// Defines a promise‐style callback record for asynchronous batch‐job operations.
  /// </summary>
  /// <remarks>
  /// An alias of <c>TPromiseCallBack&lt;TBatchJob&gt;</c> that provides fields
  /// for OnStart, OnSuccess, OnError, and OnCancellation handlers, and resolves
  /// with a <see cref="TBatchJob"/> instance when the operation completes.
  /// </remarks>
  TPromiseBatchJob = MistralAI.Batch.TPromiseBatchJob;

  /// <summary>
  /// Asynchronous callback parameters for operations returning a single <c>TBatchJobList</c>.
  /// </summary>
  /// <remarks>
  /// Used when performing asynchronous operations that return a <c>TBatchJobList</c> instance.
  /// </remarks>
  TAsynBatchJobList = MistralAI.Batch.TAsynBatchJobList;

  /// <summary>
  /// Defines a promise‐style callback record for asynchronous batch‐job‐list operations.
  /// </summary>
  /// <remarks>
  /// An alias of <c>TPromiseCallBack&lt;TBatchJobList&gt;</c> that provides fields
  /// for OnStart, OnSuccess, OnError, and OnCancellation handlers, and resolves
  /// with a <see cref="TBatchJobList"/> instance when the operation completes.
  /// </remarks>
  TPromiseBatchJobList = MistralAI.Batch.TPromiseBatchJobList;

  {$ENDREGION}

  {$REGION 'MistralAI.Conversations.Params'}

  TEntryParams = MistralAI.Conversations.Params.TEntryParams;

  TContentParams = MistralAI.Conversations.Params.TContentParams;

  TTextChunkParams = MistralAI.Conversations.Params.TTextChunkParams;

  TImageUrlParams = MistralAI.Conversations.Params.TImageUrlParams;

  TImageURLChunkParams = MistralAI.Conversations.Params.TImageURLChunkParams;

  TToolFileChunkParams = MistralAI.Conversations.Params.TToolFileChunkParams;

  TDocumentUrlChunkParams = MistralAI.Conversations.Params.TDocumentUrlChunkParams;

  TMessageInputEntryParams = MistralAI.Conversations.Params.TMessageInputEntryParams;

  TFunctionResultEntryParams = MistralAI.Conversations.Params.TFunctionResultEntryParams;

  TCompletionArgsParams = MistralAI.Conversations.Params.TCompletionArgsParams;

  TConnectorParams = MistralAI.Conversations.Params.TConnectorParams;

  TConnector = MistralAI.Conversations.Params.TConnector;

  TConversationsParams = MistralAI.Conversations.Params.TConversationsParams;

  TConversationsAgentParams = MistralAI.Conversations.Params.TConversationsAgentParams;

  {$ENDREGION}

  {$REGION 'MistralAI.Conversations.Chunks'}

  TImageUrl = MistralAI.Conversations.Chunks.TImageUrl;

  TMessageOutputContentChunksCommon = MistralAI.Conversations.Chunks.TMessageOutputContentChunksCommon;

  TTextChunk = MistralAI.Conversations.Chunks.TTextChunk;

  TImageURLChunk = MistralAI.Conversations.Chunks.TImageURLChunk;

  TToolFileChunk = MistralAI.Conversations.Chunks.TToolFileChunk;

  TDocumentURLChunk = MistralAI.Conversations.Chunks.TDocumentURLChunk;

  TToolReferenceChunk = MistralAI.Conversations.Chunks.TToolReferenceChunk;

  TContentChunk = MistralAI.Conversations.Chunks.TContentChunk;

  TOutputCommon = MistralAI.Conversations.Chunks.TOutputCommon;

  TMessageOutputEntry = MistralAI.Conversations.Chunks.TMessageOutputEntry;

  TToolExecutionEntry = MistralAI.Conversations.Chunks.TToolExecutionEntry;

  TFunctionCallEntry = MistralAI.Conversations.Chunks.TFunctionCallEntry;

  TAgentHandoffEntry = MistralAI.Conversations.Chunks.TAgentHandoffEntry;

  TConversationUsage = MistralAI.Conversations.Chunks.TConversationUsage;

  TConversation = MistralAI.Conversations.Chunks.TConversation;

  TConversationChunk = MistralAI.Conversations.Chunks.TConversationChunk;

  TRetrievedContent = MistralAI.Conversations.Chunks.TRetrievedContent;

  TEntry = MistralAI.Conversations.Chunks.TEntry;

  TRetrievedEntries = MistralAI.Conversations.Chunks.TRetrievedEntries;

  TMessage = MistralAI.Conversations.Chunks.TMessage;

  TRetrieveMessages = MistralAI.Conversations.Chunks.TRetrieveMessages;

  {$ENDREGION}

  {$REGION 'MistralAI.Conversations.Internal'}

  TAsyncConversation = MistralAI.Conversations.Internal.TAsyncConversation;

  TAsyncConversationsEvent = MistralAI.Conversations.Internal.TAsyncConversationsEvent;

  TPromiseConversation = MistralAI.Conversations.Internal.TPromiseConversation;

  TPromiseConversationsEvent = MistralAI.Conversations.Internal.TPromiseConversationsEvent;

  TAsyncConversationsList = MistralAI.Conversations.Internal.TAsyncConversationsList;

  TPromiseConversationsList = MistralAI.Conversations.Internal.TPromiseConversationsList;

  TAsyncConversationsListItem = MistralAI.Conversations.Internal.TAsyncConversationsListItem;

  TPromiseConversationsListItem = MistralAI.Conversations.Internal.TPromiseConversationsListItem;

  TAsyncRetrievedEntries = MistralAI.Conversations.Internal.TAsyncRetrievedEntries;

  TPromiseRetrievedEntries = MistralAI.Conversations.Internal.TPromiseRetrievedEntries;

  TAsyncRetrieveMessages = MistralAI.Conversations.Internal.TAsyncRetrieveMessages;

  TPromiseRetrieveMessages = MistralAI.Conversations.Internal.TPromiseRetrieveMessages;

  {$ENDREGION}

  {$REGION 'MistralAI.Conversations.Manager'}

  TAgentVersionParams = MistralAI.Conversations.Manager.TAgentVersionParams;

  TConversationsListParams = MistralAI.Conversations.Manager.TConversationsListParams;

  TAgentConversation = MistralAI.Conversations.Manager.TAgentConversation;

  TModelConversation = MistralAI.Conversations.Manager.TModelConversation;

  TConversationsListItem = MistralAI.Conversations.Manager.TConversationsListItem;

  TConversationsList = MistralAI.Conversations.Manager.TConversationsList;

  TConversationsAgent = MistralAI.Conversations.Manager.TConversationsAgent;

  TConversationsAgentList = MistralAI.Conversations.Manager.TConversationsAgentList;

  {$ENDREGION}

  {$REGION 'MistralAI.Conversations.EventStreaming'}

  TConversationsEvent = MistralAI.Conversations.EventStreaming.TConversationsEvent;

  {$ENDREGION}

  {$REGION 'MistralAI.Conversations.Agents'}

  TAsyncConversationsAgent = MistralAI.Conversations.Agents.TAsyncConversationsAgent;

  TPromiseConversationsAgent = MistralAI.Conversations.Agents.TPromiseConversationsAgent;

  TAsyncConversationsAgentList = MistralAI.Conversations.Agents.TAsyncConversationsAgentList;

  TPromiseConversationsAgentList = MistralAI.Conversations.Agents.TPromiseConversationsAgentList;

  {$ENDREGION}

  {$REGION 'MistralAI.OCR'}

  TOcrImageUrl = MistralAI.OCR.TOcrImageUrl;

  TOcrDocumentParams = MistralAI.OCR.TOcrDocumentParams;

  TAnnotationFormat = MistralAI.OCR.TAnnotationFormat;

  TOCRFormat = MistralAI.OCR.TOCRFormat;

  TOcrParams = MistralAI.OCR.TOcrParams;

  TOcrPageImage = MistralAI.OCR.TOcrPageImage;

  TOcrPageDimensions = MistralAI.OCR.TOcrPageDimensions;

  TOcrPage = MistralAI.OCR.TOcrPage;

  TUsageInfo = MistralAI.OCR.TUsageInfo;

  TOcr = MistralAI.OCR.TOcr;

  TAsyncOcr = MistralAI.OCR.TAsyncOcr;

  TPromiseOcr = MistralAI.OCR.TPromiseOcr;

  {$ENDREGION}

  {$REGION 'MistralAI.Async.Parallel'}

  /// <summary>
  /// Represents the parameters used for configuring a chat request bundle.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TParameters</c> and provides specific methods for setting chat-related
  /// parameters, such as prompts, model selection, and reasoning effort.
  /// It is used to structure and pass multiple requests efficiently in parallel processing.
  /// </remarks>
  TBundleParams = MistralAI.Async.Parallel.TBundleParams;

  /// <summary>
  /// Represents an item in a bundle of chat prompts and responses.
  /// </summary>
  /// <remarks>
  /// This class stores information about a single chat request, including its index,
  /// associated prompt, generated response, and related chat object.
  /// It is used within a <c>TBundleList</c> to manage multiple asynchronous chat requests.
  /// </remarks>
  TBundleItem = MistralAI.Async.Parallel.TBundleItem;

  /// <summary>
  /// Manages a collection of <c>TBundleItem</c> objects.
  /// </summary>
  /// <remarks>
  /// This class provides methods to add, retrieve, and count items in a bundle.
  /// It is designed to store multiple chat request items processed in parallel.
  /// The internal storage uses a <c>TObjectList&lt;TBundleItem&gt;</c> with automatic memory management.
  /// </remarks>
  TBundleList = MistralAI.Async.Parallel.TBundleList;

  /// <summary>
  /// Represents an asynchronous callback buffer for handling chat responses.
  /// </summary>
  /// <remarks>
  /// This class is a specialized type used to manage asynchronous operations
  /// related to chat request processing. It inherits from <c>TAsynCallBack&lt;TBundleList&gt;</c>,
  /// enabling structured handling of callback events.
  /// </remarks>
  TAsynBundleList = MistralAI.Async.Parallel.TAsynBundleList;

  /// <summary>
  /// Represents a promise-based callback for handling a bundle of chat responses.
  /// </summary>
  /// <remarks>
  /// The <c>TPromiseBundleList</c> alias extends <see cref="TPromiseCallBack&lt;TBundleList&gt;"/>
  /// to provide a promise-style API for parallel chat prompt execution, resolving with a
  /// <see cref="TBundleList"/> when all responses are complete or rejecting on error.
  /// </remarks>
  TPromiseBundleList = MistralAI.Async.Parallel.TPromiseBundleList;

  {$ENDREGION}

  {$REGION 'MistralAI.Libraries.Main'}

  /// <summary>
  /// Represents the parameters required to create or configure a document library
  /// within the Mistral AI API.
  /// </summary>
  /// <remarks>
  /// This class provides a fluent interface for defining the main properties of a library,
  /// such as its name, description, and chunk size for document indexing.
  /// Instances of this class are typically passed to methods like
  /// <c>TLibrariesMainRoute.Create</c> to create a new library.
  /// </remarks>
  TLibrariesMainParams = MistralAI.Libraries.Main.TLibrariesMainParams;

  /// <summary>
  /// Represents the parameters required to update the properties of an existing
  /// document library in the Mistral AI API.
  /// </summary>
  /// <remarks>
  /// This class provides a fluent interface for defining updated values such as
  /// the library name or description. It is primarily used with the
  /// <c>TLibrariesMainRoute.Update</c> method to modify an existing library's metadata.
  /// </remarks>
  TUpdateLibrariesMainParams = MistralAI.Libraries.Main.TUpdateLibrariesMainParams;

  /// <summary>
  /// Represents a document library in the Mistral AI API.
  /// </summary>
  /// <remarks>
  /// This class models the metadata of a document library, including its unique
  /// identifier, name, owner information, creation and update timestamps, as well as
  /// document statistics such as total size and number of documents.
  /// Instances of <c>TLibrariesMain</c> are typically returned by calls to
  /// <c>TLibrariesMainRoute.List</c>, <c>TLibrariesMainRoute.Create</c>,
  /// <c>TLibrariesMainRoute.Retrieve</c>, or <c>TLibrariesMainRoute.Update</c>.
  /// </remarks>
  TLibrariesMain = MistralAI.Libraries.Main.TLibrariesMain;

  /// <summary>
  /// Represents a list of document libraries retrieved from the Mistral AI API.
  /// </summary>
  /// <remarks>
  /// This class encapsulates an array of <c>TLibrariesMain</c> objects, each representing
  /// a single document library and its metadata (e.g., ID, name, description, and statistics).
  /// It is typically returned by calls such as <c>TLibrariesMainRoute.List</c> to enumerate
  /// all existing libraries.
  /// </remarks>
  TLibrariesMainList = MistralAI.Libraries.Main.TLibrariesMainList;

  /// <summary>
  /// Represents an asynchronous callback handler for operations that return
  /// a <c>TLibrariesMainList</c> instance.
  /// </summary>
  /// <remarks>
  /// This type alias specializes <c>TAsyncCallback</c> with <c>TLibrariesMainList</c>
  /// as the result type. It is typically used for non-blocking calls such as
  /// <c>TLibrariesMainRoute.AsyncList</c> to retrieve all libraries.
  /// <para>
  /// Assign event handlers like <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c>
  /// to respond to the different stages of the asynchronous operation.
  /// </para>
  /// </remarks>
  TAsyncLibrariesMainList = MistralAI.Libraries.Main.TAsyncLibrariesMainList;

  /// <summary>
  /// Represents a promise-based asynchronous handler for operations that return
  /// a <c>TLibrariesMainList</c> instance.
  /// </summary>
  /// <remarks>
  /// This type alias specializes <c>TPromiseCallback</c> with <c>TLibrariesMainList</c>
  /// as the result type. It is typically used with promise-oriented workflows,
  /// such as <c>TLibrariesMainRoute.AsyncAwaitList</c>, to retrieve all libraries.
  /// <para>
  /// This type allows attaching <c>OnSuccess</c> and <c>OnError</c> handlers in a
  /// chained style, making asynchronous code easier to manage compared to
  /// traditional callback patterns.
  /// </para>
  /// </remarks>
  TPromiseLibrariesMainList = MistralAI.Libraries.Main.TPromiseLibrariesMainList;

  /// <summary>
  /// Represents an asynchronous callback handler for operations returning a
  /// <c>TLibrariesMain</c> instance.
  /// </summary>
  /// <remarks>
  /// This type alias specializes <c>TAsyncCallback</c> with <c>TLibrariesMain</c> as the
  /// result type. It is commonly used in non-blocking API calls such as
  /// <c>TLibrariesMainRoute.AsyncCreate</c>, <c>AsyncRetrieve</c>, or <c>AsyncUpdate</c>.
  /// <para>
  /// Handlers such as <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c> can be assigned
  /// to respond to the various stages of an asynchronous library operation.
  /// </para>
  /// </remarks>
  TAsyncLibrariesMain = MistralAI.Libraries.Main.TAsyncLibrariesMain;

  /// <summary>
  /// Represents a promise-based asynchronous handler for operations that return
  /// a <c>TLibrariesMain</c> instance.
  /// </summary>
  /// <remarks>
  /// This type alias specializes <c>TPromiseCallback</c> with <c>TLibrariesMain</c> as
  /// the result type. It is typically used with asynchronous workflows that follow a
  /// promise pattern, such as <c>TLibrariesMainRoute.AsyncAwaitCreate</c> or
  /// <c>AsyncAwaitUpdate</c>.
  /// <para>
  /// Using this type allows you to attach <c>OnSuccess</c> and <c>OnError</c> handlers
  /// in a chained style, simplifying non-blocking execution and result handling.
  /// </para>
  /// </remarks>
  TPromiseLibrariesMain = MistralAI.Libraries.Main.TPromiseLibrariesMain;

  {$ENDREGION}

  {$REGION 'MistralAI.Libraries.Documents'}

  /// <summary>
  /// Represents the URL query parameters used when listing documents in a Mistral library.
  /// </summary>
  /// <remarks>
  /// This class provides a fluent interface to configure pagination, sorting, and search options
  /// for document retrieval via the <c>/v1/libraries/{library_id}/documents</c> endpoint.
  /// </remarks>
  TLibrariesDocumentsUrlParams = MistralAI.Libraries.Documents.TLibrariesDocumentsUrlParams;

  /// <summary>
  /// Represents the multipart/form-data parameters used for uploading documents
  /// to a Mistral library.
  /// </summary>
  /// <remarks>
  /// This class provides helper methods to add file streams or file paths
  /// when performing a document upload via the
  /// <c>/v1/libraries/{library_id}/documents</c> endpoint.
  /// </remarks>
  TLibrariesDocumentsUploadParams = MistralAI.Libraries.Documents.TLibrariesDocumentsUploadParams;

  /// <summary>
  /// Represents the JSON body parameters used for updating the metadata
  /// of a document within a Mistral library.
  /// </summary>
  /// <remarks>
  /// This class is primarily used to update the name of an existing document
  /// via the <c>/v1/libraries/{library_id}/documents/{document_id}</c> endpoint.
  /// </remarks>
  TLibrariesDocumentsUpdateParams = MistralAI.Libraries.Documents.TLibrariesDocumentsUpdateParams;

  /// <summary>
  /// Represents the metadata of a document stored in a Mistral library.
  /// </summary>
  /// <remarks>
  /// This class maps the response structure of the
  /// <c>/v1/libraries/{library_id}/documents</c> endpoint and related document endpoints.
  /// It contains essential information such as file details, upload metadata,
  /// processing status, and token usage for the document.
  /// </remarks>
  TLibrariesDocuments = MistralAI.Libraries.Documents.TLibrariesDocuments;

  /// <summary>
  /// Asynchronous callback type for operations returning a <c>TLibrariesDocuments</c> instance.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TAsyncCallback&lt;TLibrariesDocuments&gt;</c> is used for non-blocking
  /// document operations (e.g., retrieve, upload, update) where callbacks such as
  /// <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c> can be assigned to handle the result.
  /// </remarks>
  TAsyncLibrariesDocuments = MistralAI.Libraries.Documents.TAsyncLibrariesDocuments;

  /// <summary>
  /// Promise-based callback type for operations returning a <c>TLibrariesDocuments</c> instance.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TPromiseCallback&lt;TLibrariesDocuments&gt;</c> is used for asynchronous
  /// document operations (e.g., upload, retrieve, update) that follow a promise-style interface.
  /// It enables chaining of success and error handlers, providing a cleaner, event-driven workflow.
  /// </remarks>
  TPromiseLibrariesDocuments = MistralAI.Libraries.Documents.TPromiseLibrariesDocuments;

  /// <summary>
  /// Represents the response structure when listing documents in a Mistral library.
  /// </summary>
  /// <remarks>
  /// This class encapsulates both the pagination information and the array of document metadata
  /// (<c>TLibrariesDocuments</c>) returned by the
  /// <c>/v1/libraries/{library_id}/documents</c> endpoint.
  /// </remarks>
  TLibrariesDocumentsList = MistralAI.Libraries.Documents.TLibrariesDocumentsList;

  /// <summary>
  /// Asynchronous callback type for operations returning a <c>TLibrariesDocumentsList</c> instance.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TAsyncCallback&lt;TLibrariesDocumentsList&gt;</c> is used for non-blocking
  /// document listing operations. It allows attaching event handlers such as <c>OnStart</c>,
  /// <c>OnSuccess</c>, and <c>OnError</c> to manage the response lifecycle when retrieving
  /// paginated lists of documents from a library.
  /// </remarks>
  TAsyncLibrariesDocumentsList = MistralAI.Libraries.Documents.TAsyncLibrariesDocumentsList;

  /// <summary>
  /// Promise-based callback type for operations returning a <c>TLibrariesDocumentsList</c> instance.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TPromiseCallback&lt;TLibrariesDocumentsList&gt;</c> is designed for asynchronous
  /// document listing operations that follow a promise-style pattern.
  /// It enables chaining success and error handlers for handling paginated document retrieval results.
  /// </remarks>
  TPromiseLibrariesDocumentsList = MistralAI.Libraries.Documents.TPromiseLibrariesDocumentsList;

  /// <summary>
  /// Represents the response indicating whether a document operation
  /// (such as delete or reprocess) was successfully completed.
  /// </summary>
  /// <remarks>
  /// This class is used by endpoints like
  /// <c>/v1/libraries/{library_id}/documents/{document_id}</c> (DELETE)
  /// and
  /// <c>/v1/libraries/{library_id}/documents/{document_id}/reprocess</c> (POST),
  /// where the API returns a flag indicating the operation status.
  /// </remarks>
  TLibraryDocumentsProcessed = MistralAI.Libraries.Documents.TLibraryDocumentsProcessed;

  /// <summary>
  /// Asynchronous callback type for operations returning a <c>TLibraryDocumentsProcessed</c> instance.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TAsyncCallback&lt;TLibraryDocumentsProcessed&gt;</c> is used for non-blocking
  /// operations such as document deletion or reprocessing, where event handlers
  /// (<c>OnStart</c>, <c>OnSuccess</c>, <c>OnError</c>) can be attached to monitor the operation's outcome.
  /// </remarks>
  TAsyncLibraryDocumentsProcessed = MistralAI.Libraries.Documents.TAsyncLibraryDocumentsProcessed;

  /// <summary>
  /// Promise-based callback type for operations returning a <c>TLibraryDocumentsProcessed</c> instance.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TPromiseCallback&lt;TLibraryDocumentsProcessed&gt;</c> is used for asynchronous
  /// operations such as document deletion or reprocessing, following a promise-style interface.
  /// It allows chaining success and error handlers to handle the final result of the operation.
  /// </remarks>
  TPromiseLibraryDocumentsProcessed = MistralAI.Libraries.Documents.TPromiseLibraryDocumentsProcessed;

  /// <summary>
  /// Represents the extracted text content of a document from a Mistral library.
  /// </summary>
  /// <remarks>
  /// This class maps the response of the
  /// <c>/v1/libraries/{library_id}/documents/{document_id}/text_content</c> endpoint.
  /// It contains the raw text extracted by the OCR or document processing pipeline.
  /// </remarks>
  TLibraryDocumentsText = MistralAI.Libraries.Documents.TLibraryDocumentsText;

  /// <summary>
  /// Asynchronous callback type for operations returning a <c>TLibraryDocumentsText</c> instance.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TAsyncCallback&lt;TLibraryDocumentsText&gt;</c> is used for non-blocking
  /// operations that retrieve the extracted text content of a document.
  /// Event handlers such as <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c> can be attached
  /// to monitor the asynchronous text retrieval process.
  /// </remarks>
  TAsyncLibraryDocumentsText = MistralAI.Libraries.Documents.TAsyncLibraryDocumentsText;

  /// <summary>
  /// Promise-based callback type for operations returning a <c>TLibraryDocumentsText</c> instance.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TPromiseCallback&lt;TLibraryDocumentsText&gt;</c> is used for asynchronous
  /// operations that retrieve the text content of a document.
  /// It enables a promise-style workflow, allowing chaining of success and error handlers
  /// to manage the final result of the text extraction process.
  /// </remarks>
  TPromiseLibraryDocumentsText = MistralAI.Libraries.Documents.TPromiseLibraryDocumentsText;

  /// <summary>
  /// Represents the processing status of a document in a Mistral library.
  /// </summary>
  /// <remarks>
  /// This class maps the response of the
  /// <c>/v1/libraries/{library_id}/documents/{document_id}/status</c> endpoint.
  /// It provides information about the document's unique identifier and its current processing state.
  /// </remarks>
  TLibraryDocumentsStatus = MistralAI.Libraries.Documents.TLibraryDocumentsStatus;

  /// <summary>
  /// Asynchronous callback type for operations returning a <c>TLibraryDocumentsStatus</c> instance.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TAsyncCallback&lt;TLibraryDocumentsStatus&gt;</c> is used for non-blocking
  /// operations that check the processing status of a document.
  /// It allows attaching event handlers (<c>OnStart</c>, <c>OnSuccess</c>, <c>OnError</c>)
  /// to monitor the status retrieval process.
  /// </remarks>
  TAsyncLibraryDocumentsStatus = MistralAI.Libraries.Documents.TAsyncLibraryDocumentsStatus;

  /// <summary>
  /// Promise-based callback type for operations returning a <c>TLibraryDocumentsStatus</c> instance.
  /// </summary>
  /// <remarks>
  /// This alias of <c>TPromiseCallback&lt;TLibraryDocumentsStatus&gt;</c> is used for asynchronous
  /// operations that check the processing status of a document, following a promise-style pattern.
  /// It enables chaining of success and error handlers to handle the final result of the status query.
  /// </remarks>
  TPromiseLibraryDocumentsStatus = MistralAI.Libraries.Documents.TPromiseLibraryDocumentsStatus;

  {$ENDREGION}

  {$REGION 'MistralAI.Libraries.Access'}

  /// <summary>
  /// Represents the parameters required to create or update access levels for a library.
  /// </summary>
  /// <remarks>
  /// The <c>TAccessParams</c> class is used to build the request payload when assigning or modifying
  /// access levels to a specific entity (user, workspace, or organization) for a library.
  /// It provides fluent methods for configuring organization ID, access level, and the target entity.
  /// </remarks>
  TAccessParams = MistralAI.Libraries.Access.TAccessParams;

  /// <summary>
  /// Represents the parameters required to delete access levels for a library.
  /// </summary>
  /// <remarks>
  /// The <c>TAccessDeleteParams</c> class is used to build the request payload when
  /// revoking access rights for a specific entity (user, workspace, or organization)
  /// associated with a library.
  /// </remarks>
  TAccessDeleteParams = MistralAI.Libraries.Access.TAccessDeleteParams;

  /// <summary>
  /// Represents the access rights of an entity (user, workspace, or organization) to a specific library.
  /// </summary>
  /// <remarks>
  /// The <c>TLibrariesAccess</c> class models the response object for library access queries or updates.
  /// It contains information about the library, the organization, the entity with which it is shared,
  /// and the access role granted.
  /// </remarks>
  TLibrariesAccess = MistralAI.Libraries.Access.TLibrariesAccess;

  /// <summary>
  /// Represents an asynchronous callback handler for library access operations.
  /// </summary>
  /// <remarks>
  /// <c>TAsyncLibrariesAccess</c> is a type alias for <c>TAsyncCallback&lt;TLibrariesAccess&gt;</c>.
  /// It is used to manage non-blocking operations related to a single library access entry,
  /// providing event hooks such as <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c>.
  /// </remarks>
  TAsyncLibrariesAccess = MistralAI.Libraries.Access.TAsyncLibrariesAccess;

  /// <summary>
  /// Represents a promise-based asynchronous handler for library access operations.
  /// </summary>
  /// <remarks>
  /// <c>TPromiseLibrariesAccess</c> is a type alias for <c>TPromiseCallback&lt;TLibrariesAccess&gt;</c>.
  /// It is used in asynchronous workflows to retrieve or update a single library access entry,
  /// resolving with a <c>TLibrariesAccess</c> result when the operation completes successfully,
  /// or rejecting with an exception if an error occurs.
  /// </remarks>
  TPromiseLibrariesAccess = MistralAI.Libraries.Access.TPromiseLibrariesAccess;

  /// <summary>
  /// Represents a list of access rights for a specific library.
  /// </summary>
  /// <remarks>
  /// The <c>TLibrariesAccessList</c> class models the response when querying all entities that have access
  /// to a library. It encapsulates an array of <c>TLibrariesAccess</c> objects, each describing the
  /// access details for a single entity (user, workspace, or organization).
  /// </remarks>
  TLibrariesAccessList = MistralAI.Libraries.Access.TLibrariesAccessList;

  /// <summary>
  /// Represents an asynchronous callback handler for operations returning a list of library access entries.
  /// </summary>
  /// <remarks>
  /// <c>TAsyncLibrariesAccessList</c> is a type alias for <c>TAsyncCallback&lt;TLibrariesAccessList&gt;</c>.
  /// It is used for non-blocking operations that retrieve all access entries of a specific library,
  /// providing event hooks such as <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c> to manage the asynchronous workflow.
  /// </remarks>
  TAsyncLibrariesAccessList = MistralAI.Libraries.Access.TAsyncLibrariesAccessList;

  /// <summary>
  /// Represents a promise-based asynchronous handler for operations returning a list of library access entries.
  /// </summary>
  /// <remarks>
  /// <c>TPromiseLibrariesAccessList</c> is a type alias for <c>TPromiseCallback&lt;TLibrariesAccessList&gt;</c>.
  /// It is used in asynchronous workflows to retrieve all access entries of a specific library,
  /// resolving with a <c>TLibrariesAccessList</c> when the operation completes successfully,
  /// or rejecting with an exception if an error occurs.
  /// </remarks>
  TPromiseLibrariesAccessList = MistralAI.Libraries.Access.TPromiseLibrariesAccessList;

  {$ENDREGION}

  {$REGION 'MistralAI.Audio'}

  /// <summary>
  /// Represents the parameter builder for configuring an audio transcription request.
  /// </summary>
  /// <remarks>
  /// Use <c>TAudioTranscriptionParams</c> to set various input fields such as file path or URL, model name,
  /// language, and timestamp options. The configured instance is submitted to the transcription endpoint to
  /// obtain speech-to-text results from an audio source.
  /// </remarks>
  TAudioTranscriptionParams = MistralAI.Audio.TAudioTranscriptionParams;

  /// <summary>
  /// Represents the result of an audio transcription request.
  /// </summary>
  /// <remarks>
  /// <c>TAudioTranscription</c> encapsulates the output of a transcription task, including the full transcribed text,
  /// detected language, model used, timestamped segments, and usage statistics. It is returned as the response
  /// object from the audio transcription API endpoint.
  /// </remarks>
  TAudioTranscription = MistralAI.Audio.TAudioTranscription;

  /// <summary>
  /// Represents the asynchronous callback structure for audio transcription operations.
  /// </summary>
  /// <remarks>
  /// <c>TAsyncAudioTranscription</c> is a type alias for <c>TAsyncCallback&lt;TAudioTranscription&gt;</c>.
  /// It allows you to assign lifecycle event handlers such as <c>OnStart</c>, <c>OnSuccess</c>, and <c>OnError</c>
  /// when performing non-blocking transcription requests.
  /// This is useful for integrating event-driven logic into your application when working with
  /// <c>TAudioRoute.AsyncTranscription</c> to process audio asynchronously without blocking the main thread.
  /// </remarks>
  TAsyncAudioTranscription = MistralAI.Audio.TAsyncAudioTranscription;

  /// <summary>
  /// Represents the promise-based interface for audio transcription operations.
  /// </summary>
  /// <remarks>
  /// <c>TPromiseAudioTranscription</c> is a type alias for <c>TPromiseCallback&lt;TAudioTranscription&gt;</c>.
  /// It provides a structured way to handle asynchronous transcription results using a promise-like API,
  /// allowing chaining of <c>OnSuccess</c> and <c>OnError</c> handlers.
  /// This type is typically used with <c>TAudioRoute.AsyncAwaitTranscription</c> for workflows where you want
  /// to react to the transcription result once it's completed, without relying on event callbacks.
  /// </remarks>
  TPromiseAudioTranscription = MistralAI.Audio.TPromiseAudioTranscription;

  {$ENDREGION}

function HttpMonitoring: IRequestMonitor;

function web_search_premium: TConnectorParams;
function web_search: TConnectorParams;
function image_generation: TConnectorParams;
function code_interpreter: TConnectorParams;
function &function(const Value: IFunctionCore): TConnectorParams; overload;
function &function(const Value: TToolFunctionParams): TConnectorParams; overload;
function document_library(const Value: TArray<string>): TConnectorParams;

implementation

function HttpMonitoring: IRequestMonitor;
begin
  Result := Monitoring;
end;

function web_search_premium: TConnectorParams;
begin
  Result := TConnector.web_search_premium;
end;

function web_search: TConnectorParams;
begin
  Result := TConnector.web_search;
end;

function image_generation: TConnectorParams;
begin
  Result := TConnector.image_generation;
end;

function code_interpreter: TConnectorParams;
begin
  Result := TConnector.code_interpreter;
end;

function &function(const Value: IFunctionCore): TConnectorParams;
begin
  Result := TConnector.&function(Value);
end;

function &function(const Value: TToolFunctionParams): TConnectorParams;
begin
  Result := TConnector.&function(Value);
end;

function document_library(const Value: TArray<string>): TConnectorParams;
begin
  Result := TConnector.document_library(Value);
end;

{ TMistralAI }

constructor TMistralAI.Create;
begin
  inherited;
  FAPI := TMistralAIAPI.Create;
end;

procedure TMistralAI.CodestralCheck;
begin
  if not (CodestralSpec in FSpecs) then
    raise Exception.Create(
       'The MistralAI instance cannot manage "Codestral", for this you must indicate '+
       '[CodestralSpec] as a specification when instantiating the TMistralAI type interface:'#13#13+
       '   TMistralAI.Create(''Your key'', [CodestralSpec])');
end;

constructor TMistralAI.Create(const AToken: string; Specs: TSpecs);
begin
  Create;
  Token := AToken;

  {--- Managing specifications for an instance of the class }
  if CodestralSpec in Specs then
    begin
      FSpecs := FSpecs + [CodestralSpec];
      FAPI.BaseUrl := TMistralAIAPI.URL_BASE_CODESTRAL;
    end;
end;

destructor TMistralAI.Destroy;
begin
  FModelsRoute.Free;
  FEmbeddingsRoute.Free;
  FAgentRoute.Free;
  FChatRoute.Free;
  if CodestralSpec in FSpecs then
    FCodestralRoute.Free;
  FFileRoute.Free;
  FFineTuningRoute.Free;
  FClassifiersRoute.Free;
  FBatchRoute.Free;
  FConversationsRoute.Free;
  FConversationsAgentRoute.Free;
  FOcrRoute.Free;
  FAPI.Free;
  FLibrariesMainRoute.Free;
  FLibrariesDocumentsRoute.Free;
  FLibrariesAccessRoute.Free;
  FAudioRoute.Free;
  inherited;
end;

function TMistralAI.GetAgentRoute: TAgentRoute;
begin
  if not Assigned(FAgentRoute) then
    FAgentRoute := TAgentRoute.CreateRoute(API);
  Result := FAgentRoute;
end;

function TMistralAI.GetAPI: TMistralAIAPI;
begin
  Result := FAPI;
end;

function TMistralAI.GetAudioRoute: TAudioRoute;
begin
  if not Assigned(FAudioRoute) then
    FAudioRoute := TAudioRoute.CreateRoute(API);
  Result := FAudioRoute;
end;

function TMistralAI.GetBaseUrl: string;
begin
  Result := FAPI.BaseURL;
end;

function TMistralAI.GetBatchRoute: TBatchRoute;
begin
  if not Assigned(FBatchRoute) then
    FBatchRoute := TBatchRoute.CreateRoute(API);
  Result := FBatchRoute;
end;

function TMistralAI.GetChatRoute: TChatRoute;
begin
  if not Assigned(FChatRoute) then
    FChatRoute := TChatRoute.CreateRoute(API);
  Result := FChatRoute;
end;

function TMistralAI.GetClassifiersRoute: TClassifiersRoute;
begin
  if not Assigned(FClassifiersRoute) then
    FClassifiersRoute := TClassifiersRoute.CreateRoute(API);
  Result := FClassifiersRoute;
end;

function TMistralAI.GetCodestralRoute: TCodestralRoute;
begin
  CodestralCheck;
  if not Assigned(FCodestralRoute) then
    FCodestralRoute := TCodestralRoute.CreateRoute(API);
  Result := FCodestralRoute;
end;

function TMistralAI.GetConversationsAgentRoute: TConversationsAgentRoute;
begin
  if not Assigned(FConversationsAgentRoute) then
    FConversationsAgentRoute := TConversationsAgentRoute.CreateRoute(API);
  Result := FConversationsAgentRoute;
end;

function TMistralAI.GetConversationsRoute: TConversationsRoute;
begin
  if not Assigned(FConversationsRoute) then
    FConversationsRoute := TConversationsRoute.CreateRoute(API);
  Result := FConversationsRoute;
end;

function TMistralAI.GetEmbeddingsRoute: TEmbeddingsRoute;
begin
  if not Assigned(FEmbeddingsRoute) then
    FEmbeddingsRoute := TEmbeddingsRoute.CreateRoute(API);
  Result := FEmbeddingsRoute;
end;

function TMistralAI.GetFilesRoute: TFilesRoute;
begin
  if not Assigned(FFileRoute) then
    FFileRoute := TFilesRoute.CreateRoute(API);
  Result := FFileRoute;
end;

function TMistralAI.GetFineTuningRoute: TFineTuningRoute;
begin
  if not Assigned(FFineTuningRoute) then
    FFineTuningRoute := TFineTuningRoute.CreateRoute(API);
  Result := FFineTuningRoute;
end;

function TMistralAI.GetHttpClient: IHttpClientAPI;
begin
  Result := API.HttpClient;
end;

function TMistralAI.GetLibrariesAccessRoute: TLibrariesAccessRoute;
begin
  if not Assigned(FLibrariesAccessRoute) then
    FLibrariesAccessRoute := TLibrariesAccessRoute.CreateRoute(API);
  Result := FLibrariesAccessRoute;
end;

function TMistralAI.GetLibrariesDocumentsRoute: TLibrariesDocumentsRoute;
begin
  if not Assigned(FLibrariesDocumentsRoute) then
    FLibrariesDocumentsRoute := TLibrariesDocumentsRoute.CreateRoute(API);
  Result := FLibrariesDocumentsRoute;
end;

function TMistralAI.GetLibrariesMainRoute: TLibrariesMainRoute;
begin
  if not Assigned(FLibrariesMainRoute) then
    FLibrariesMainRoute := TLibrariesMainRoute.CreateRoute(API);
  Result := FLibrariesMainRoute;
end;

function TMistralAI.GetModelsRoute: TModelsRoute;
begin
  if not Assigned(FModelsRoute) then
    FModelsRoute := TModelsRoute.CreateRoute(API);
  Result := FModelsRoute;
end;

function TMistralAI.GetOcrRoute: TOcrRoute;
begin
  if not Assigned(FOcrRoute) then
    FOcrRoute := TOcrRoute.CreateRoute(API);
  Result := FOcrRoute;
end;

function TMistralAI.GetToken: string;
begin
  Result := FAPI.APIKey;
end;

function TMistralAI.GetVersion: string;
begin
  Result := VERSION;
end;

procedure TMistralAI.SetBaseUrl(const Value: string);
begin
  FAPI.BaseURL := Value;
end;

procedure TMistralAI.SetToken(const Value: string);
begin
  FAPI.APIKey := Value;
end;

{ TMistralAIFactory }

class function TMistralAIFactory.CreateInstance(const AToken: string;
  Specs: TSpecs): IMistralAI;
begin
  Result := TMistralAI.Create(AToken, Specs);
end;

end.

unit MistralAI.Schema;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, REST.Json.Types,
  MistralAI.API.Params, MistralAI.Types;

{$SCOPEDENUMS ON}

type
  /// <summary>
  /// Type contains the list of OpenAPI data types as defined by https://spec.openapis.org/oas/v3.0.3#data-types
  /// </summary>
  TSchemaType = (
    /// <summary>
    /// Not specified, should not be used.
    /// </summary>
    Type_unspecified,
    /// <summary>
    /// String type.
    /// </summary>
    &String,
    /// <summary>
    /// Number type.
    /// </summary>
    Number,
    /// <summary>
    /// Integer type.
    /// </summary>
    &Integer,
    /// <summary>
    /// Boolean type.
    /// </summary>
    &Boolean,
    /// <summary>
    /// Array type.
    /// </summary>
    &Array,
    /// <summary>
    /// Object type.
    /// </summary>
    &Object
  );

  /// <summary>
  /// Helper record for the <c>TSchemaType</c> enumeration, providing utility methods for converting
  /// between <c>TSchemaType</c> values and their string representations.
  /// </summary>
  TSchemaTypeHelper = record helper for TSchemaType
    /// <summary>
    /// Converts the current <c>TSchemaType</c> value to its corresponding string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>TSchemaType</c> value.
    /// </returns>
    function ToString: string;
  end;

  TSchemaParams = class;

  /// <summary>
  /// Provides helper methods for creating property items in OpenAPI schema definitions.
  /// </summary>
  /// <remarks>
  /// This record simplifies the creation of property entries when building schema objects,
  /// particularly for object properties in OpenAPI specifications.
  /// </remarks>
  TPropertyItem = record
  public
    /// <summary>
    /// Creates a JSON pair representing a property in a schema object.
    /// </summary>
    /// <param name="Key">The name of the property.</param>
    /// <param name="Value">The data type of the property as a <c>TSchemaType</c>.</param>
    /// <returns>A <c>TJSONPair</c> representing the property key-value pair.</returns>
    /// <remarks>
    /// This method facilitates the addition of properties to schema objects by creating
    /// a JSON pair with the specified key and data type.
    /// </remarks>
    class function Add(Key: string; Value: TSchemaType): TJSONPair; static;
  end;

  /// <summary>
  /// Represents the Schema Object in OpenAPI, enabling the definition of input and output data types.
  /// These types can be objects, primitives, or arrays. This class provides methods to build and
  /// configure schema definitions as per the OpenAPI 3.0 Specification.
  /// </summary>
  /// <remarks>
  /// The Schema Object allows the definition of input and output data types in the OpenAPI Specification.
  /// This class provides a fluent interface to construct schema definitions programmatically.
  /// </remarks>
  TSchemaParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the data type of the schema.
    /// </summary>
    /// <param name="Value">The data type to assign to the schema, specified as a <c>TSchemaType</c> value.</param>
    /// <returns>The current <c>TSchemaParams</c> instance to allow for method chaining.</returns>
    /// <remarks>
    /// The <c>type</c> keyword is required in the Schema Object to define the data type.
    /// Valid types include <c>string</c>, <c>number</c>, <c>integer</c>, <c>boolean</c>, <c>array</c>, and <c>object</c>.
    /// </remarks>
    function &Type(const Value: TSchemaType): TSchemaParams;

    /// <summary>
    /// Specifies the format of the data type.
    /// </summary>
    /// <param name="Value">The format of the data type, as a string.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>format</c> keyword is an optional modifier to provide more fine-grained data type information.
    /// Common formats include <c>int32</c>, <c>int64</c> for <c>integer</c> types; <c>float</c>, <c>double</c>
    /// for <c>number</c> types; and <c>byte</c>, <c>binary</c>, <c>date</c>, <c>date-time</c>, <c>password</c> for <c>string</c> types.
    /// </remarks>
    function Format(const Value: string): TSchemaParams;

    /// <summary>
    /// Adds a description to the schema.
    /// </summary>
    /// <param name="Value">A brief description of the schema. Supports Markdown for formatting.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>description</c> keyword provides a description of the schema and can include examples of use.
    /// This field supports Markdown syntax for rich text representation.
    /// </remarks>
    function Description(const Value: string): TSchemaParams;

    /// <summary>
    /// Specifies whether the schema's value can be null.
    /// </summary>
    /// <param name="Value">A boolean indicating if the schema allows null values.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>nullable</c> keyword is a boolean property that indicates if the value of the schema can be null.
    /// By default, this is false.
    /// </remarks>
    function Nullable(const Value: Boolean): TSchemaParams;

    /// <summary>
    /// Specifies an enumeration of possible values.
    /// </summary>
    /// <param name="Value">An array of string values that the schema can take.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>enum</c> keyword restricts the value of the schema to a fixed set of values.
    /// The schema's type must be <c>string</c> when using enum.
    /// </remarks>
    function Enum(const Value: TArray<string>): TSchemaParams;

    /// <summary>
    /// Specifies the maximum number of items allowed in an array schema.
    /// </summary>
    /// <param name="Value">The maximum number of items as a string.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>maxItems</c> keyword applies to schemas of type <c>array</c> and restricts the maximum number
    /// of items the array can contain.
    /// </remarks>
    function MaxItems(const Value: string): TSchemaParams;

    /// <summary>
    /// Specifies the minimum number of items required in an array schema.
    /// </summary>
    /// <param name="Value">The minimum number of items as a string.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>minItems</c> keyword applies to schemas of type <c>array</c> and defines the minimum number
    /// of items the array must contain.
    /// </remarks>
    function MinItems(const Value: string): TSchemaParams;

    /// <summary>
    /// Adds a property to an object schema.
    /// </summary>
    /// <param name="Key">The name of the property.</param>
    /// <param name="Value">A <c>TSchemaParams</c> instance defining the property's schema.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>properties</c> keyword is used to define the properties of an object schema.
    /// Each property is a key-value pair where the key is the property name and the value is a schema defining the property.
    /// </remarks>
    function Properties(const Key: string; const Value: TSchemaParams): TSchemaParams; overload;

    /// <summary>
    /// Adds a property to an object schema using a parameterized procedure to configure the property's schema.
    /// </summary>
    /// <param name="Key">The name of the property.</param>
    /// <param name="ParamProc">A procedure that takes a <c>TSchemaParams</c> instance to configure the property's schema.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// This overload allows you to define the property's schema inline using a procedural configuration.
    /// </remarks>
    function Properties(const Key: string; const ParamProc: TProcRef<TSchemaParams>): TSchemaParams; overload;

    /// <summary>
    /// Adds multiple properties to an object schema.
    /// </summary>
    /// <param name="Value">An array of <c>TJSONPair</c> instances representing the properties.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// This overload allows adding multiple properties at once to the object schema.
    /// </remarks>
    function Properties(const Value: TArray<TJSONPair>): TSchemaParams; overload;

    /// <summary>
    /// Specifies which properties are required in an object schema.
    /// </summary>
    /// <param name="Value">An array of property names that are required.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>required</c> keyword lists the property names that must be included when an object instance
    /// is validated against the schema.
    /// </remarks>
    function Required(const Value: TArray<string>): TSchemaParams;

    /// <summary>
    /// Specifies the schema of the items in an array schema.
    /// </summary>
    /// <param name="Value">A <c>TSchemaParams</c> instance defining the schema of the array items.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>items</c> keyword is used in array schemas to define the schema of each item in the array.
    /// </remarks>
    function Items(const Value: TSchemaParams): TSchemaParams; overload;

    /// <summary>
    /// Specifies the schema of the items in an array schema using a parameterized procedure.
    /// </summary>
    /// <param name="ParamProc">A procedure that configures a <c>TSchemaParams</c> instance to define the array items' schema.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// This overload allows you to define the items' schema inline using a procedural configuration.
    /// </remarks>
    function Items(const ParamProc: TProcRef<TSchemaParams>): TSchemaParams; overload;

    /// <summary>
    /// Creates a new instance of <c>TSchemaParams</c>.
    /// </summary>
    /// <returns>A new <c>TSchemaParams</c> instance.</returns>
    class function New: TSchemaParams; overload;

    /// <summary>
    /// Creates and configures a new instance of <c>TSchemaParams</c> using a parameterized procedure.
    /// </summary>
    /// <param name="ParamProc">A procedure that configures the new <c>TSchemaParams</c> instance.</param>
    /// <returns>A new <c>TSchemaParams</c> instance.</returns>
    /// <remarks>
    /// This overload allows you to create and configure the instance inline.
    /// </remarks>
    class function New(const ParamProc: TProcRef<TSchemaParams>): TSchemaParams; overload;
  end;

  /// <summary>
  /// Defines a response format and its schema structure for the MistralAI API.
  /// </summary>
  /// <remarks>
  /// <para>This class allows specifying:</para>
  /// <para>- The name of the response format (Name property).</para>
  /// <para>- The description of the format (Description property).</para>
  /// <para>- The JSON schema describing the expected response structure (Schema overload).</para>
  /// <para>- Enabling strict mode to enforce exact adherence to the schema (Strict property).</para>
  /// </remarks>
  TResponseSchemaParams = class(TJSONParam)
    /// <summary>
    /// The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
    /// </summary>
    function Name(const Value: string): TResponseSchemaParams;

    /// <summary>
    /// A description of what the response format is for, used by the model to determine how to respond in the format.
    /// </summary>
    function Description(const Value: string): TResponseSchemaParams;

    /// <summary>
    /// The schema for the response format, described as a JSON Schema object. Learn how to build JSON schemas here.
    /// </summary>
    function Schema(const Value: TSchemaParams): TResponseSchemaParams; overload;

    /// <summary>
    /// The schema for the response format, described as a JSON Schema object. Learn how to build JSON schemas here.
    /// </summary>
    function Schema(const Value: string): TResponseSchemaParams; overload;

    /// <summary>
    /// Whether to enable strict schema adherence when generating the output. If set to true, the model will always
    /// follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict
    /// is true.
    /// </summary>
    function Strict(const Value: Boolean): TResponseSchemaParams;
  end;

  /// <summary>
  /// Configures the expected output format (text, JSON object, or JSON schema) and its parameters for the MistralAI API.
  /// </summary>
  /// <remarks>
  /// <para>This class allows:</para>
  /// <para>- Selecting the output format type via <c>Type</c> ("text", "json_object", or "json_schema").</para>
  /// <para>- Specifying the JSON schema to use in JSON mode via <c>JsonSchema</c>.</para>
  /// </remarks>
  TResponseFormatParams = class(TJSONParam)
    /// <summary>
    /// Enum: "text" "json_object" "json_schema"
    /// An object specifying the format that the model must output. Setting to { "type": "json_object" }
    /// enables JSON mode, which guarantees the message the model generates is in JSON. When using JSON
    /// mode you MUST also instruct the model to produce JSON yourself with a system or a user message.
    /// </summary>
    function &Type(const Value: string): TResponseFormatParams; overload;

    /// <summary>
    /// Enum: "text" "json_object" "json_schema"
    /// An object specifying the format that the model must output. Setting to { "type": "json_object" }
    /// enables JSON mode, which guarantees the message the model generates is in JSON. When using JSON
    /// mode you MUST also instruct the model to produce JSON yourself with a system or a user message.
    /// </summary>
    function &Type(const Value: TResponseFormatType): TResponseFormatParams; overload;

    /// <summary>
    /// The JsonSchema
    /// </summary>
    function JsonSchema(const Value: TResponseSchemaParams): TResponseFormatParams;

    class function New(const Value: string): TResponseFormatParams; overload;
    class function New(const Value: TResponseFormatType): TResponseFormatParams; overload;
    class function Json_Schema(const Value: string): TJsonObject;
    class function Json_Oject: TResponseFormatParams;
  end;

implementation

uses
  System.StrUtils, System.Rtti, Rest.Json;

{ TSchemaTypeHelper }

function TSchemaTypeHelper.ToString: string;
begin
  case Self of
    TSchemaType.Type_unspecified:
      Exit('type_unspecified');
    TSchemaType.String:
      Exit('string');
    TSchemaType.Number:
      Exit('number');
    TSchemaType.Integer:
      Exit('integer');
    TSchemaType.Boolean:
      Exit('boolean');
    TSchemaType.Array:
      Exit('array');
    TSchemaType.Object:
      Exit('object');
  end;
end;

{ TSchemaParams }

function TSchemaParams.Description(const Value: string): TSchemaParams;
begin
  Result := TSchemaParams(Add('description', Value));
end;

function TSchemaParams.Enum(const Value: TArray<string>): TSchemaParams;
begin
  Result := TSchemaParams(Add('enum', Value));
end;

function TSchemaParams.Format(const Value: string): TSchemaParams;
begin
  Result := TSchemaParams(Add('format', Value));
end;

function TSchemaParams.Items(
  const ParamProc: TProcRef<TSchemaParams>): TSchemaParams;
begin
  if Assigned(ParamProc) then
    begin
      var Value := TSchemaParams.Create;
      ParamProc(Value);
      Result := Items(Value);
    end
  else Result := Self;
end;

function TSchemaParams.Items(const Value: TSchemaParams): TSchemaParams;
begin
  Result := TSchemaParams(Add('items', Value.Detach));
end;

function TSchemaParams.MaxItems(const Value: string): TSchemaParams;
begin
  Result := TSchemaParams(Add('maxItems', Value));
end;

function TSchemaParams.MinItems(const Value: string): TSchemaParams;
begin
  Result := TSchemaParams(Add('minItems', Value));
end;

class function TSchemaParams.New: TSchemaParams;
begin
  Result := TSchemaParams.Create;
end;

class function TSchemaParams.New(
  const ParamProc: TProcRef<TSchemaParams>): TSchemaParams;
begin
  Result := TSchemaParams.Create;
  if Assigned(ParamProc) then
    begin
      ParamProc(Result);
    end;
end;

function TSchemaParams.Nullable(const Value: Boolean): TSchemaParams;
begin
  Result := TSchemaParams(Add('nullable', Value.ToString));
end;

function TSchemaParams.Properties(
  const Value: TArray<TJSONPair>): TSchemaParams;
begin
  var JSONValue := TJSONObject.Create;
  for var Item in Value do
    begin
      JSONValue.AddPair(Item);
    end;
  Result := TSchemaParams(Add('properties', JSONValue));
end;

function TSchemaParams.Properties(const Key: string;
  const ParamProc: TProcRef<TSchemaParams>): TSchemaParams;
begin
  if Assigned(ParamProc) then
    begin
      var Value := TSchemaParams.Create;
      ParamProc(Value);
      Result := Properties(Key, Value);
    end
  else Result := Self;
end;

function TSchemaParams.Properties(const Key: string;
  const Value: TSchemaParams): TSchemaParams;
begin
  Result := TSchemaParams(Add(Key, Value.Detach));
end;

function TSchemaParams.Required(const Value: TArray<string>): TSchemaParams;
begin
  Result := TSchemaParams(Add('required', Value));
end;

function TSchemaParams.&Type(const Value: TSchemaType): TSchemaParams;
begin
  Result := TSchemaParams(Add('type', Value.ToString));
end;

{ TPropertyItem }

class function TPropertyItem.Add(Key: string; Value: TSchemaType): TJSONPair;
begin
  Result := TJSONPair.Create(Key, Value.ToString);
end;

{ TResponseSchemaParams }

function TResponseSchemaParams.Description(const Value: string): TResponseSchemaParams;
begin
  Result := TResponseSchemaParams(Add('description', Value));
end;

function TResponseSchemaParams.Name(const Value: string): TResponseSchemaParams;
begin
  Result := TResponseSchemaParams(Add('name', Value));
end;

function TResponseSchemaParams.Schema(
  const Value: TSchemaParams): TResponseSchemaParams;
begin
  Result := TResponseSchemaParams(Add('schema', Value.Detach));
end;

function TResponseSchemaParams.Schema(
  const Value: string): TResponseSchemaParams;
begin
  var JSON := TJSONObject.ParseJSONValue(Value.ToLower.Replace(sLineBreak, '').Replace(#10, '').Replace(#13, '')) as TJSONObject;
  Result := TResponseSchemaParams(Add('schema', JSON));
end;

function TResponseSchemaParams.Strict(const Value: Boolean): TResponseSchemaParams;
begin
  Result := TResponseSchemaParams(Add('strict', Value));
end;

{ TResponseFormatParams }

class function TResponseFormatParams.New(
  const Value: string): TResponseFormatParams;
begin
  Result := TResponseFormatParams.Create.&Type(Value);
end;

function TResponseFormatParams.JsonSchema(
  const Value: TResponseSchemaParams): TResponseFormatParams;
begin
  Result := TResponseFormatParams(Add('json_schema', Value.Detach));
end;

class function TResponseFormatParams.Json_Oject: TResponseFormatParams;
begin
  Result := TResponseFormatParams.New(TResponseFormatType.json_object.ToString);
end;

class function TResponseFormatParams.Json_Schema(
  const Value: string): TJsonObject;
begin
  Result := TJSONObject.Create;
  try
    Result.AddPair('type', TResponseFormatType.json_schema.ToString);
    Result.AddPair('json_schema', TJSONObject.ParseJSONValue(Value));
  except
    on E: Exception do
      begin
        Result.Free;
        raise;
      end;
  end;
end;

class function TResponseFormatParams.New(
  const Value: TResponseFormatType): TResponseFormatParams;
begin
  Result := TResponseFormatParams.Create.&Type(Value);
end;

function TResponseFormatParams.&Type(
  const Value: string): TResponseFormatParams;
begin
  Result := TResponseFormatParams(Add('type', TResponseFormatType.Create(Value).ToString));
end;


function TResponseFormatParams.&Type(
  const Value: TResponseFormatType): TResponseFormatParams;
begin
  Result := TResponseFormatParams(Add('type', Value.ToString));
end;

end.

unit MistralAI.Tutorial.FMX;

{ Tutorial Support Unit

   WARNING:
     This module is intended solely to illustrate the examples provided in the
     README.md file of the repository :
          https://github.com/MaxiDonkey/DelphiMistralAI
     Under no circumstances should the methods described below be used outside
     of the examples presented on the repository's page.
}

interface

uses
  System.SysUtils, System.Classes, Winapi.Messages, FMX.Types, FMX.StdCtrls, FMX.ExtCtrls,
  FMX.Controls, FMX.Forms, Winapi.Windows, FMX.Graphics, FMX.Dialogs, FMX.Memo.Types,
  FMX.Media, FMX.Objects, FMX.Controls.Presentation, FMX.ScrollBox, FMX.Memo, System.UITypes,
  System.Types, System.JSON,
  MistralAI, MistralAI.Types, MistralAI.Functions.Core,
  MistralAI.Httpx;

type
  TToolProc = procedure (const Value: TCalledFunction; Func: IFunctionCore) of object;
  TToolProcEx = procedure (const Value: TMessageOutputEntry; Func: IFunctionCore) of object;

  /// <summary>
  /// Represents a tutorial hub for handling visual components in a Delphi application,
  /// including text display, button interactions, and navigation through pages.
  /// </summary>
  TFMXTutorialHub = class
  private
    FClient: IMistralAI;
    FMemo1: TMemo;
    FMemo2: TMemo;
    FMemo3: TMemo;
    FMemo4: TMemo;
    FButton: TButton;
    FFileId: string;
    FJobId: string;
    FBatchId: string;
    FFileName: string;
    FTool: IFunctionCore;
    FToolCall: TToolProc;
    FToolCallEx: TToolProcEx;
    FPage: Integer;
    FFileOverride: Boolean;
    FCancel: Boolean;
    procedure OnButtonClick(Sender: TObject);
    procedure SetButton(const Value: TButton);
    procedure SetMemo1(const Value: TMemo);
    procedure SetMemo2(const Value: TMemo);
    procedure SetMemo3(const Value: TMemo);
    procedure SetMemo4(const Value: TMemo);
    procedure SetJSONRequest(const Value: string);
    procedure SetJSONResponse(const Value: string);
  public
    /// <summary>
    /// Advances the tutorial to the next page.
    /// </summary>
    procedure NextPage;
    /// <summary>
    /// Gets or sets the first memo component for displaying messages or data.
    /// </summary>
    property Memo1: TMemo read FMemo1 write SetMemo1;
    /// <summary>
    /// Gets or sets the second memo component for displaying additional messages or data.
    /// </summary>
    property Memo2: TMemo read FMemo2 write SetMemo2;
    /// <summary>
    /// Gets or sets the second memo component for displaying additional messages or data.
    /// </summary>
    property Memo3: TMemo read FMemo3 write SetMemo3;
    /// <summary>
    /// Gets or sets the second memo component for displaying additional messages or data.
    /// </summary>
    property Memo4: TMemo read FMemo4 write SetMemo4;
    /// <summary>
    /// Sets text for displaying JSON request.
    /// </summary>
    property JSONRequest: string write SetJSONRequest;
    /// <summary>
    /// Sets text for displaying JSON response.
    /// </summary>
    property JSONResponse: string write SetJSONResponse;
    /// <summary>
    /// Gets or sets the button component used to trigger actions or handle cancellation.
    /// </summary>
    property Button: TButton read FButton write SetButton;
    /// <summary>
    /// Gets or sets a value indicating whether the operation has been canceled.
    /// </summary>
    property Cancel: Boolean read FCancel write FCancel;
    /// <summary>
    /// Gets or sets the file identifier associated with the tutorial hub.
    /// </summary>
    property FileId: string read FFileId write FFileId;
    /// <summary>
    /// Gets or sets the job identifier associated with the tutorial hub.
    /// </summary>
    property JobId: string read FJobId write FJobId;
    /// <summary>
    /// Gets or sets the batch identifier associated with the tutorial hub.
    /// </summary>
    property BatchId: string read FBatchId write FBatchId;
    /// <summary>
    /// Gets or sets the name of the file associated with the tutorial hub.
    /// </summary>
    property FileName: string read FFileName write FFileName;
    /// <summary>
    /// Gets or sets the core function tool used for processing.
    /// </summary>
    property Tool: IFunctionCore read FTool write FTool;
    /// <summary>
    /// Gets or sets the procedure for handling tool-specific calls.
    /// </summary>
    property ToolCall: TToolProc read FToolCall write FToolCall;

    property ToolCallEx: TToolProcEx read FToolCallEx write FToolCallEx;

    /// <summary>
    /// Gets or sets the current page number within the tutorial.
    /// </summary>
    property Page: Integer read FPage write FPage;
    /// <summary>
    /// Gets or sets a value indicating whether file overrides are allowed.
    /// </summary>
    property FileOverride: Boolean read FFileOverride write FFileOverride;
    procedure JSONRequestClear;
    procedure JSONResponseClear;
    procedure LoadImage(const FilePath: string);
    procedure WeatherFunction(const Value: TCalledFunction; Func: IFunctionCore);
    procedure WeatherFunctionEx(const Value: TMessageOutputEntry; Func: IFunctionCore);
    constructor Create(const AClient: IMistralAI; const AMemo1, AMemo2, AMemo3, AMemo4: TMemo; const AButton: TButton);
  end;

  procedure Cancellation(Sender: TObject);
  function DoCancellation: Boolean;
  procedure Start(Sender: TObject);

  procedure Display(Sender: TObject); overload;
  procedure Display(Sender: TObject; Value: string); overload;
  procedure Display(Sender: TObject; Value: TArray<string>); overload;
  procedure Display(Sender: TObject; Value: TChat); overload;
  procedure Display(Sender: TObject; Value: TCodestral); overload;
  procedure Display(Sender: TObject; Value: TEmbeddings); overload;
  procedure Display(Sender: TObject; Value: TModel); overload;
  procedure Display(Sender: TObject; Value: TModels); overload;
  procedure Display(Sender: TObject; Value: TModerationResult); overload;
  procedure DisplayEx(Sender: TObject; Value: TModerationResult); overload;
  procedure Display(Sender: TObject; Value: TModeration); overload;
  procedure DisplayEx(Sender: TObject; Value: TModeration); overload;
  procedure Display(Sender: TObject; Value: TFile); overload;
  procedure Display(Sender: TObject; Value: TFiles); overload;
  procedure Display(Sender: TObject; Value: TDeletedResult); overload;
  procedure Display(Sender: TObject; Value: TDownLoadFile); overload;
  procedure Display(Sender: TObject; Value: TJobOut); overload;
  procedure Display(Sender: TObject; Value: TJobOutProgress); overload;
  procedure Display(Sender: TObject; Value: TListFineTuningJobs); overload;
  procedure Display(Sender: TObject; Value: TBatchJob); overload;
  procedure Display(Sender: TObject; Value: TBatchJobList); overload;
  procedure Display(Sender: TObject; Value: TSignedUrl); overload;
  procedure Display(Sender: TObject; Value: TConversation); overload;
  procedure Display(Sender: TObject; Value: TConversationsListItem); overload;
  procedure Display(Sender: TObject; Value: TRetrievedEntries); overload;
  procedure Display(Sender: TObject; Value: TRetrieveMessages); overload;
  procedure Display(Sender: TObject; Value: TOcr); overload;
  procedure Display(Sender: TObject; Value: TConversationsAgent); overload;
  procedure Display(Sender: TObject; Value: TConversationsAgentList); overload;
  procedure Display(Sender: TObject; Value: TConversationsList); overload;
  procedure Display(Sender: TObject; Value: TLibrariesMain); overload;
  procedure Display(Sender: TObject; Value: TLibrariesMainList); overload;
  procedure Display(Sender: TObject; Value: TLibrariesDocuments); overload;
  procedure Display(Sender: TObject; Value: TLibrariesDocumentsList); overload;
  procedure Display(Sender: TObject; Value: TLibraryDocumentsProcessed); overload;
  procedure Display(Sender: TObject; Value: TLibraryDocumentsText); overload;
  procedure Display(Sender: TObject; Value: TLibraryDocumentsStatus); overload;
  procedure Display(Sender: TObject; Value: TLibrariesAccess); overload;
  procedure Display(Sender: TObject; Value: TLibrariesAccessList); overload;

  procedure DisplayStream(Sender: TObject; Value: string); overload;
  procedure DisplayStream(Sender: TObject; Value: TChat); overload;
  procedure DisplayStream(Sender: TObject; Value: TCodestral); overload;
  procedure DisplayStream(Sender: TObject; Value: TConversationsEvent); overload;

  procedure DisplayChunk(Value: string); overload;
  procedure DisplayChunk(Value: TChat); overload;
  procedure DisplayChunk(Value: TCodestral); overload;
  procedure DisplayChunk(Value: TConversationsEvent); overload;

  function F(const Name, Value: string): string; overload;
  function F(const Name: string; const Value: TArray<string>): string; overload;
  function F(const Name: string; const Value: boolean): string; overload;
  function F(const Name: string; const State: Boolean; const Value: Double): string; overload;

  function CodeBefore: string;
  function CodeAfter: string;

var
  /// <summary>
  /// A global instance of the <see cref="TVCLTutorialHub"/> class used as the main tutorial hub.
  /// </summary>
  /// <remarks>
  /// This variable serves as the central hub for managing tutorial components, such as memos, buttons, and pages.
  /// It is initialized dynamically during the application's runtime, and its memory is automatically released during
  /// the application's finalization phase.
  /// </remarks>
  TutorialHub: TFMXTutorialHub = nil;

implementation

uses
  System.DateUtils;

function UnixIntToDateTime(const Value: Int64): TDateTime;
begin
  Result := TTimeZone.Local.ToLocalTime(UnixToDateTime(Value));
end;

function UnixDateTimeToString(const Value: Int64): string;
begin
  Result := DateTimeToStr(UnixIntToDateTime(Value))
end;

procedure Cancellation(Sender: TObject);
begin
  Display(Sender, 'The operation was cancelled' + sLineBreak);
  TutorialHub.Cancel := False;
end;

function DoCancellation: Boolean;
begin
  Result := TutorialHub.Cancel;
end;

procedure Start(Sender: TObject);
begin
  Display(Sender, 'Please wait...');
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: string);
var
  M: TMemo;
begin
  if Sender is TMemo then
    M := Sender as TMemo else
    M := (Sender as TFMXTutorialHub).Memo1;
  M.Lines.Add(Value);
  M.ViewportPosition := PointF(M.ViewportPosition.X, M.Content.Height - M.Height);
end;

procedure Display(Sender: TObject; Value: TArray<string>);
begin
  var index := 0;
  for var Item in Value do
    begin
      if not Item.IsEmpty then
        begin
          if index = 0 then
            Display(Sender, Item) else
            Display(Sender, '    ' + Item);
        end;
      Inc(index);
    end;
end;

procedure Display(Sender: TObject);
begin
  Display(Sender, sLineBreak);
end;

procedure Display(Sender: TObject; Value: TChat);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Choices do
    if Item.FinishReason = TFinishReason.tool_calls then
      begin
        if Assigned(TutorialHub.ToolCall) then
          TutorialHub.ToolCall(Item.Message.ToolsCalls[0], TutorialHub.Tool);
      end
    else
      begin
        for var SubItem in Item.Message.Content do
          begin
            case SubItem.&Type of
              TContentType.text:
                Display(Sender, SubItem.Text);
              TContentType.thinking:
                begin
                  for var Think in SubItem.Thinking do
                    Display(TutorialHub.Memo2, Think.Text);
                end;
            end;
          end;
      end;
end;

procedure Display(Sender: TObject; Value: TCodestral); overload;
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Choices do
    if Item.FinishReason = TCodestralFinishReason.tool_calls then
      begin
        if Assigned(TutorialHub.ToolCall) then
          TutorialHub.ToolCall(Item.Message.ToolsCalls[0], TutorialHub.Tool);
      end
    else
      begin
        Display(Sender, Item.Message.Content);
      end;
end;

procedure Display(Sender: TObject; Value: TEmbeddings); overload;
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  var i := 0;
  for var Item in Value.Data do
    begin
      var j := 0;
      for var SubItem in Item.Embedding do
          begin
            Display(Sender, Format('Vector[%d, %d] = %s', [i, j, SubItem.ToString(ffNumber, 8, 8)]));
            Inc(j);
            Application.ProcessMessages;
          end;
      Display(Sender);
      Inc(i);
    end;
end;

procedure Display(Sender: TObject; Value: TModel);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    Value.Id,
    F('Name', Value.Name),
    F('Description', Value.Description),
    F('Deprecation', Value.Deprecation),
    F('Default temperature', Value.DefaultModelTemperature.ToString(ffNumber, 3, 2)),
    F('Completion chat', BoolToStr(Value.Capabilities.CompletionChat, True)),
    F('Completion fim', BoolToStr(Value.Capabilities.CompletionFim, True)),
    F('Function calling', BoolToStr(Value.Capabilities.FunctionCalling, True)),
    F('Fine-tuning', BoolToStr(Value.Capabilities.FineTuning, True)),
    F('Vision', BoolToStr(Value.Capabilities.Vision, True))
  ]);
  Display(Sender, EmptyStr);
end;

procedure Display(Sender: TObject; Value: TModels);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  if Length(Value.Data) = 0 then
    begin
      Display(Sender, 'No model found');
      Exit;
    end;
  for var Item in Value.Data do
    begin
      Display(Sender, Item);
      Application.ProcessMessages;
    end;
  Display(Sender);
end;

procedure DisplayEx(Sender: TObject; Value: TModerationResult);
var
  Temp: TArray<string>;
begin
  if Value.Warning then
    begin
      Temp := [''];
      for var Item in Value.Warnings do
        Temp := Temp + [F(Item.Category, (Item.Score * 100).ToString(ffNumber, 3, 2)) + '%'];
      Display(Sender, Temp);
      Display(Sender);
    end
  else
    begin
      Display(Sender, 'No moderation is necessary');
    end;
end;

procedure Display(Sender: TObject; Value: TModerationResult);
begin
  if Value.Warning then
    begin
      Display(Sender, [EmptyStr,
        F(Classifiers[0], Value.Categories.Sexual, Value.Scores.Sexual),
        F(Classifiers[1], Value.Categories.Hate_and_discrimination, Value.Scores.Hate_and_discrimination),
        F(Classifiers[2], Value.Categories.Violence_and_threats, Value.Scores.Violence_and_threats),
        F(Classifiers[3], Value.Categories.Dangerous_and_criminal_content, Value.Scores.Dangerous_and_criminal_content),
        F(Classifiers[4], Value.Categories.Selfharm, Value.Scores.Selfharm),
        F(Classifiers[5], Value.Categories.Health, Value.Scores.Health),
        F(Classifiers[6], Value.Categories.Financial, Value.Scores.Financial),
        F(Classifiers[7], Value.Categories.Law, Value.Scores.Law),
        F(Classifiers[8], Value.Categories.Pii, Value.Scores.Pii)
      ]);
      Display(Sender);
    end
  else
    begin
      Display(Sender, 'No moderation is necessary');
    end;
end;

procedure Display(Sender: TObject; Value: TModeration);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Results do
    Display(Sender, Item);
end;

procedure DisplayEx(Sender: TObject; Value: TModeration);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Results do
    DisplayEx(Sender, Item);
end;

procedure Display(Sender: TObject; Value: TFile);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    F(Value.FileName, Value.Id),
    F('Source', [
      Value.Source.ToString,
      F('Purpose', Value.Purpose.ToString),
      F('Object', Value.&Object),
      F('Bytes', Value.Bytes.ToString),
      F('NumLines', Value.NumLines.ToString)
    ])
  ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TFiles);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  if Length(Value.Data) = 0 then
    begin
      Display(Sender, 'No file found');
      Exit;
    end;
  for var Item in Value.Data do
    Display(Sender, Item);
end;

procedure Display(Sender: TObject; Value: TDeletedResult);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    F('Id', Value.Id),
    F('Deleted', [
      BoolToStr(Value.Deleted, True),
      F('Object', Value.&Object)
    ])
  ]);
end;

procedure Display(Sender: TObject; Value: TDownLoadFile);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  if TutorialHub.FileName.IsEmpty then
    raise Exception.Create('No filename defined for download.');
  Value.SaveToFile(TutorialHub.FileName, not TutorialHub.FileOverride);
  Display(Sender, Format('File downloaded and saved as "%s"', [TutorialHub.FileName]));
end;

procedure Display(Sender: TObject; Value: TJobOut);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    Value.Id,
    F('AutoStart', [
      BoolToStr(Value.AutoStart, True),
      F('Model', Value.Model),
      F('Status', Value.Status.ToString),
      F('FineTuningModel', Value.FineTuningModel)
    ])
  ]);
end;

procedure Display(Sender: TObject; Value: TJobOutProgress);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    Value.Id,
    F('AutoStart', [
      BoolToStr(Value.AutoStart, True),
      F('Model', Value.Model),
      F('Status', Value.Status.ToString),
      F('FineTuningModel', Value.FineTuningModel)
    ])
  ]);
  for var Item in Value.Events do
    Display(Sender, [
      Item.Name,
      Item.Data.Status.ToString,
      Item.Data.Error,
      UnixDateTimeToString(Item.CreatedAt)
    ]);
end;

procedure Display(Sender: TObject; Value: TListFineTuningJobs);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, F('Total', [Value.Total.ToString, F('Object', Value.&Object.ToString)]));
  for var Item in Value.Data do
    Display(Sender, F('Id', [
      Item.Id,
      F('Model', Item.Model),
      F('Status', Item.Status.ToString)
    ]));
end;

procedure Display(Sender: TObject; Value: TBatchJob);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, F('Id', [
    Value.Id,
    F('Model', Value.Model),
    F('Endpoint', Value.Endpoint.ToString),
    F('Status', Value.Status.ToString),
    F('CreatedAt', UnixDateTimeToString(Value.CreatedAt))
  ]));
  if not Value.OutputFile.IsEmpty then
    Display(Sender, F('OutputFile', Value.OutputFile));
  Display(Sender, Value.Metadata);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TBatchJobList);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, F('Total', [
    Value.Total.ToString,
    F('Object', Value.&Object)]));
  for var Item in Value.Data do
    Display(Sender, Item);
end;

procedure Display(Sender: TObject; Value: TSignedUrl); overload;
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, Value.Url);
end;

procedure Display(Sender: TObject; Value: TConversation);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Outputs do
  begin
    case Item.&Type of
      TConversatonEvent.function_call :
        TutorialHub.ToolCallEx(Item, TutorialHub.Tool);

      TConversatonEvent.message_input,
      TConversatonEvent.message_output:
        begin
          for var SubItem in Item.Content do
            case SubItem.&Type of
              TContentChunkType.text:
                Display(Sender, SubItem.Text);

              TContentChunkType.tool_file:
                begin
                  case Subitem.Tool of
                    TConversationTool.image_generation:
                      TutorialHub.LoadImage(SubItem.FileId);
                  end;
                end;
            end;
        end;
    end;
  end;
end;

procedure Display(Sender: TObject; Value: TConversationsListItem);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  if Assigned(Value) then
    begin
      Display(Sender, F('objet', Value.&Object));
      Display(Sender, F('id', Value.Id));
      Display(Sender, F('stop', Value.CompletionArgs.Stop));
    end;
end;

procedure Display(Sender: TObject; Value: TRetrievedEntries); overload;
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(TutorialHub, F('object', Value.&Object));
  Display(TutorialHub, F('conversation_id', Value.ConversationId));
  Display(TutorialHub, EmptyStr);
  for var Item in Value.Entries do
    begin
      Display(TutorialHub, F('object', Item.&Object));
      Display(TutorialHub, F('type', Item.&Type.ToString));
      Display(TutorialHub, F('id', Item.Id));
      case Item.&Type of
        TConversatonEvent.message_input,
        TConversatonEvent.message_output:
          Display(TutorialHub, F('role', Item.Role.ToString));
        TConversatonEvent.tool_execution:
        Display(TutorialHub, F('function', Item.&Function));
      end;
      Display(TutorialHub, F('prefix', BoolToStr(Item.Prefix, True)));
      for var SubItem in Item.Content do
        begin
          if SubItem.&Type = TContentChunkType.text then
            Display(TutorialHub, F('content', SubItem.Text));
          Display(TutorialHub, EmptyStr);
        end;
      Display(TutorialHub, '----------------');
    end;
end;

procedure Display(Sender: TObject; Value: TRetrieveMessages);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(TutorialHub, F('object', Value.&Object));
  Display(TutorialHub, F('conversation_id', Value.ConversationId));
  Display(TutorialHub, EmptyStr);
  for var Item in Value.Messages do
    begin
      Display(TutorialHub, F('object', Item.&Object));
      Display(TutorialHub, F('type', Item.&Type.ToString));
      Display(TutorialHub, F('id', Item.Id));
      case Item.&Type of
        TConversatonEvent.message_input,
        TConversatonEvent.message_output:
          Display(TutorialHub, F('role', Item.Role.ToString));
      end;

      Display(TutorialHub, F('prefix', BoolToStr(Item.Prefix, True)));
      for var SubItem in Item.Content do
        begin
          if SubItem.&Type = TContentChunkType.text then
            Display(TutorialHub, F('content', SubItem.Text));
          Display(TutorialHub, EmptyStr);
        end;
      Display(TutorialHub, '----------------');
    end;
end;

procedure Display(Sender: TObject; Value: TOcr);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Pages do
    begin
      Display(Sender, F('page', Item.Index.ToString));
      Display(Sender, Item.Markdown);
    end;
end;

procedure Display(Sender: TObject; Value: TConversationsAgent);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, F('id', Value.Id));
  Display(Sender, F('name', Value.Name));
  if not Value.Model.IsEmpty then
    Display(Sender, F('model', Value.Model));
  if not Value.Description.IsEmpty then
    Display(Sender, F('description', Value.Description));
  if not Value.Instructions.IsEmpty then
    Display(Sender, F('instructions', Value.Instructions));
  Display(Sender, F('version', Value.Version.ToString));
  Display(Sender, EmptyStr);
end;

procedure Display(Sender: TObject; Value: TConversationsAgentList);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    Display(Sender, Item);
end;

procedure Display(Sender: TObject; Value: TConversationsList);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    Display(TutorialHub, Item.Id);
end;

procedure Display(Sender: TObject; Value: TLibrariesMain);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, F('id', F(Value.Id, F('name', Value.Name))));
  Display(Sender, F('chunk_size', Value.ChunkSize.ToString));
  Display(Sender, F('description',Value.Description));
  Display(Sender, EmptyStr);
end;

procedure Display(Sender: TObject; Value: TLibrariesMainList);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    Display(Sender, Item);
end;

procedure Display(Sender: TObject; Value: TLibrariesDocuments);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, F('id', F(Value.Id, F('name', Value.Name))));
  Display(Sender, F('processing_status', F(Value.ProcessingStatus, F('mime_type', Value.MimeType))));
  Display(Sender, F('summary', Value.Summary));
  Display(Sender, EmptyStr);
end;

procedure Display(Sender: TObject; Value: TLibrariesDocumentsList);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender,
    F('total_items',
      F(Value.Pagination.TotalItems.ToString,
        F('total_pages', Value.Pagination.TotalPages.ToString))));
  Display(Sender,
    F('current_page',
      F(Value.Pagination.CurrentPage.ToString,
        F('has_more', BoolToStr(Value.Pagination.HasMore, True)))));
  for var Item in Value.Data do
    Display(Sender, Item);
end;

procedure Display(Sender: TObject; Value: TLibraryDocumentsProcessed);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, F('processed', BoolToStr(Value.Processed, True)));
end;

procedure Display(Sender: TObject; Value: TLibraryDocumentsText);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, Value.Text);
end;

procedure Display(Sender: TObject; Value: TLibraryDocumentsStatus);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, F('document_id', Value.DocumentId));
  Display(Sender, F('processing_status', Value.ProcessingStatus));
  Display(Sender, EmptyStr);
end;

procedure Display(Sender: TObject; Value: TLibrariesAccess);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, F('library_id', Value.LibraryId));
  Display(Sender, F('role', Value.Role));
  Display(Sender, F('share_with_uuid', Value.ShareWithUuid));
  Display(Sender, F('share_with_type', Value.ShareWithType.ToString));
  Display(Sender, F('user_id', Value.UserId));
  Display(Sender, EmptyStr);
end;

procedure Display(Sender: TObject; Value: TLibrariesAccessList);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    Display(Sender, Item);
end;

procedure DisplayStream(Sender: TObject; Value: string);
var
  M: TMemo;
  CurrentLine: string;
begin
  if Sender is TMemo then
    M := Sender as TMemo
  else
    M := (Sender as TFMXTutorialHub).Memo1;
  var ShouldScroll := M.ViewportPosition.Y >= (M.Content.Height - M.Height - 16);
  M.Lines.BeginUpdate;
  try
    var Lines := Value.Replace(#13, '').Split([#10]);
    if System.Length(Lines) > 0 then
    begin
      if M.Lines.Count > 0 then
        CurrentLine := M.Lines[M.Lines.Count - 1]
      else
        CurrentLine := EmptyStr;
      CurrentLine := CurrentLine + Lines[0];
      if M.Lines.Count > 0 then
        M.Lines[M.Lines.Count - 1] := CurrentLine
      else
        M.Lines.Add(CurrentLine);
      for var i := 1 to High(Lines) do
        M.Lines.Add(Lines[i]);
    end;
  finally
    M.Lines.EndUpdate;
  end;
  if ShouldScroll then
    M.ViewportPosition := PointF(M.ViewportPosition.X, M.Content.Height - M.Height + 1);
end;

procedure DisplayStream(Sender: TObject; Value: TChat);
begin
  if Assigned(Value) then
    begin
      for var Item in Value.Choices do
        begin
          for var SubItem in Item.Delta.Content do
          begin
            case SubItem.&Type of
              TContentType.text:
                DisplayStream(Sender, SubItem.Text);
              TContentType.thinking:
                begin
                  for var Think in SubItem.Thinking do
                    DisplayStream(TutorialHub.Memo2, Think.Text);
                end;
            end;
          end;

        end;
      DisplayChunk(Value);
    end;
end;

procedure DisplayStream(Sender: TObject; Value: TCodestral);
begin
  if Assigned(Value) then
    begin
      for var Item in Value.Choices do
        begin
          DisplayStream(Sender, Item.Delta.Content);
        end;
      DisplayChunk(Value);
    end;
end;

procedure DisplayStream(Sender: TObject; Value: TConversationsEvent);
begin
  if Assigned(Value) then
    begin
      DisplayChunk(Value);
      if Value.&Type = TChunkEvent.message_output_delta then
        DisplayStream(Sender, Value.Content[0].Text);
    end;
end;

procedure DisplayChunk(Value: string); overload;
begin
  var JSONValue := TJSONObject.ParseJSONValue(Value);
  TutorialHub.Memo4.Lines.BeginUpdate;
  try
    Display(TutorialHub.Memo4, JSONValue.ToString);
  finally
    TutorialHub.Memo4.Lines.EndUpdate;
    JSONValue.Free;
  end;
end;

procedure DisplayChunk(Value: TChat); overload;
begin
  DisplayChunk(Value.JSONResponse);
end;

procedure DisplayChunk(Value: TCodestral); overload;
begin
  DisplayChunk(Value.JSONResponse);
end;

procedure DisplayChunk(Value: TConversationsEvent);
begin
  DisplayChunk(Value.JSONResponse);
end;

function F(const Name, Value: string): string;
begin
  if not Value.IsEmpty then
    Result := Format('%s: %s', [Name, Value])
end;

function F(const Name: string; const Value: TArray<string>): string;
begin
  var index := 0;
  for var Item in Value do
    begin
      if index = 0 then
        Result := Format('%s: %s', [Name, Item]) else
        Result := Result + '    ' + Item;
      Inc(index);
    end;
end;

function F(const Name: string; const Value: boolean): string;
begin
  Result := Format('%s: %s', [Name, BoolToStr(Value, True)])
end;

function F(const Name: string; const State: Boolean; const Value: Double): string;
begin
  Result := Format('%s (%s): %s%%', [Name, BoolToStr(State, True), (Value * 100).ToString(ffNumber, 3, 3)])
end;

function CodeBefore: string;
begin
  with TStringWriter.Create do
  try
    WriteLine('def is_odd(n):');
    WriteLine('  return n % 2 == 1');
    WriteLine('def test_is_odd():');
    Result := ToString;
  finally
    Free;
  end;
end;

function CodeAfter: string;
begin
  with TStringWriter.Create do
  try
    WriteLine('n = int(input(''Enter a number: ''))');
    WriteLine('print(fibonacci(n))');
    Result := ToString;
  finally
    Free;
  end;
end;

{ TFMXTutorialHub }

constructor TFMXTutorialHub.Create(const AClient: IMistralAI; const AMemo1, AMemo2, AMemo3, AMemo4: TMemo; const AButton: TButton);
begin
  inherited Create;
  Fclient := AClient;
  Memo1 := AMemo1;
  Memo2 := AMemo2;
  Memo3 := AMemo3;
  Memo4 := AMemo4;
  Button := AButton;
  FFileOverride := False;
end;

procedure TFMXTutorialHub.JSONRequestClear;
begin
  Memo3.Lines.Clear;
end;

procedure TFMXTutorialHub.JSONResponseClear;
begin
  Memo4.Lines.Clear;
end;

procedure TFMXTutorialHub.LoadImage(const FilePath: string);
begin
  FClient.&File.AsyncGetSignedUrl(FilePath,
  procedure (Params: TSignedUrlParams)
  begin
    Params.Expiry(1);
  end,
  function : TAsyncSignedUrl
  begin
    Result.OnSuccess :=
      procedure (Sender: TObject; Value: TSignedUrl)
      begin
        THttpx.DownloadFromSignedUrl(Value.Url, True);
      end;
    Result.OnError := Display;
  end);
end;

procedure TFMXTutorialHub.NextPage;
begin
  Inc(FPage);
end;

procedure TFMXTutorialHub.OnButtonClick(Sender: TObject);
begin
  Cancel := True;
end;

procedure TFMXTutorialHub.SetButton(const Value: TButton);
begin
  FButton := Value;
  FButton.OnClick := OnButtonClick;
  FButton.Text := 'Cancel';
end;

procedure TFMXTutorialHub.SetJSONRequest(const Value: string);
begin
  Memo3.Lines.Text := Value;
  Memo3.SelStart := 0;
  Application.ProcessMessages;
end;

procedure TFMXTutorialHub.SetJSONResponse(const Value: string);
begin
  Memo4.Lines.Text := Value;
  Memo4.SelStart := 0;
  Application.ProcessMessages;
end;

procedure TFMXTutorialHub.SetMemo1(const Value: TMemo);
begin
  FMemo1 := Value;
  FMemo1.TextSettings.WordWrap := True;
end;

procedure TFMXTutorialHub.SetMemo2(const Value: TMemo);
begin
  FMemo2 := Value;
  FMemo2.TextSettings.WordWrap := True;
end;

procedure TFMXTutorialHub.SetMemo3(const Value: TMemo);
begin
  FMemo3 := Value;
  FMemo3.TextSettings.WordWrap := False;
end;

procedure TFMXTutorialHub.SetMemo4(const Value: TMemo);
begin
  FMemo4 := Value;
  FMemo4.TextSettings.WordWrap := False;
end;

procedure TFMXTutorialHub.WeatherFunction(const Value: TCalledFunction;
  Func: IFunctionCore);
begin
  var ArgResult := Func.Execute(Value.&Function.Arguments);

  FClient.Chat.AsyncCreateStream(
    procedure (Params: TChatParams)
    begin
      Params.Model('open-mixtral-8x22b-2404');
      Params.Messages([
        PayLoad.System('Respond like a star weather presenter on a prime-time TV channel.'),
        Payload.User(ArgResult)
      ]);
      Params.Stream(True);
      Params.MaxTokens(1024);
    end,
    function : TAsynChatStream
    begin
      Result.Sender := TutorialHub;
      Result.OnProgress := DisplayStream;
      Result.OnSuccess := Display;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
      Result.OnError := Display;
    end);
end;

procedure TFMXTutorialHub.WeatherFunctionEx(const Value: TMessageOutputEntry;
  Func: IFunctionCore);
begin
  var ArgResult := Func.Execute(Value.Arguments);

  FClient.Conversations.AsyncCreateStream(
    procedure (Params: TConversationsParams)
    begin
      Params.Instructions('Respond like a star weather presenter on a prime-time TV channel.');
      Params.Inputs(ArgResult);
      Params.Model('mistral-medium-2505');
      Params.Stream;
      Params.Store(False);
      Params.CompletionArgs(TCompletionArgsParams.Create
        .Temperature(0.3)
        .TopP(0.95)
      )
    end,
    function : TAsyncConversationsEvent
    begin
      Result.Sender := TutorialHub;
      Result.OnProgress := DisplayStream;
      Result.OnSuccess := Display;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
      Result.OnError := Display;
    end);
end;

initialization
finalization
  if Assigned(TutorialHub) then
    TutorialHub.Free;
end.

unit MistralAI.Tutorial.VCL;

{ Tutorial Support Unit

   WARNING:
     This module is intended solely to illustrate the examples provided in the
     README.md file of the repository :
          https://github.com/MaxiDonkey/DelphiMistralAI
     Under no circumstances should the methods described below be used outside
     of the examples presented on the repository's page.
}

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes,
  Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.ExtCtrls,
  System.UITypes, System.JSON,
  MistralAI, MistralAI.Types, MistralAI.Functions.Core,
  MistralAI.Httpx;

type
  TToolProc = procedure (const Value: TCalledFunction; Func: IFunctionCore) of object;
  TToolProcEx = procedure (const Value: TMessageOutputEntry; Func: IFunctionCore) of object;

  /// <summary>
  /// Represents a tutorial hub for handling visual components in a Delphi application,
  /// including text display, button interactions, and navigation through pages.
  /// </summary>
  TVCLTutorialHub = class
  private
    FClient: IMistralAI;
    FMemo1: TMemo;
    FMemo2: TMemo;
    FMemo3: TMemo;
    FMemo4: TMemo;
    FButton: TButton;
    FFileId: string;
    FJobId: string;
    FBatchId: string;
    FFileName: string;
    FTool: IFunctionCore;
    FToolCall: TToolProc;
    FToolCallEx: TToolProcEx;
    FPage: Integer;
    FFileOverride: Boolean;
    FCancel: Boolean;
    procedure OnButtonClick(Sender: TObject);
    procedure SetButton(const Value: TButton);
    procedure SetMemo1(const Value: TMemo);
    procedure SetMemo2(const Value: TMemo);
    procedure SetMemo3(const Value: TMemo);
    procedure SetMemo4(const Value: TMemo);
    procedure SetJSONRequest(const Value: string);
    procedure SetJSONResponse(const Value: string);
  public
    /// <summary>
    /// Advances the tutorial to the next page.
    /// </summary>
    procedure NextPage;
    /// <summary>
    /// Gets or sets the first memo component for displaying messages or data.
    /// </summary>
    property Memo1: TMemo read FMemo1 write SetMemo1;
    /// <summary>
    /// Gets or sets the second memo component for displaying additional messages or data.
    /// </summary>
    property Memo2: TMemo read FMemo2 write SetMemo2;
    /// <summary>
    /// Gets or sets the second memo component for displaying additional messages or data.
    /// </summary>
    property Memo3: TMemo read FMemo3 write SetMemo3;
    /// <summary>
    /// Gets or sets the second memo component for displaying additional messages or data.
    /// </summary>
    property Memo4: TMemo read FMemo4 write SetMemo4;
    /// <summary>
    /// Sets text for displaying JSON request.
    /// </summary>
    property JSONRequest: string write SetJSONRequest;
    /// <summary>
    /// Sets text for displaying JSON response.
    /// </summary>
    property JSONResponse: string write SetJSONResponse;
    /// <summary>
    /// Gets or sets the button component used to trigger actions or handle cancellation.
    /// </summary>
    property Button: TButton read FButton write SetButton;
    /// <summary>
    /// Gets or sets a value indicating whether the operation has been canceled.
    /// </summary>
    property Cancel: Boolean read FCancel write FCancel;
    /// <summary>
    /// Gets or sets the file identifier associated with the tutorial hub.
    /// </summary>
    property FileId: string read FFileId write FFileId;
    /// <summary>
    /// Gets or sets the job identifier associated with the tutorial hub.
    /// </summary>
    property JobId: string read FJobId write FJobId;
    /// <summary>
    /// Gets or sets the batch identifier associated with the tutorial hub.
    /// </summary>
    property BatchId: string read FBatchId write FBatchId;
    /// <summary>
    /// Gets or sets the name of the file associated with the tutorial hub.
    /// </summary>
    property FileName: string read FFileName write FFileName;
    /// <summary>
    /// Gets or sets the core function tool used for processing.
    /// </summary>
    property Tool: IFunctionCore read FTool write FTool;
    /// <summary>
    /// Gets or sets the procedure for handling tool-specific calls.
    /// </summary>
    property ToolCall: TToolProc read FToolCall write FToolCall;

    property ToolCallEx: TToolProcEx read FToolCallEx write FToolCallEx;

    /// <summary>
    /// Gets or sets the current page number within the tutorial.
    /// </summary>
    property Page: Integer read FPage write FPage;
    /// <summary>
    /// Gets or sets a value indicating whether file overrides are allowed.
    /// </summary>
    property FileOverride: Boolean read FFileOverride write FFileOverride;
    procedure JSONRequestClear;
    procedure JSONResponseClear;
    procedure LoadImage(const FilePath: string);
    procedure WeatherFunction(const Value: TCalledFunction; Func: IFunctionCore);
    procedure WeatherFunctionEx(const Value: TMessageOutputEntry; Func: IFunctionCore);
    constructor Create(const AClient: IMistralAI; const AMemo1, AMemo2, AMemo3, AMemo4: TMemo; const AButton: TButton);
  end;

  procedure Cancellation(Sender: TObject);
  function DoCancellation: Boolean;
  procedure Start(Sender: TObject);

  procedure Display(Sender: TObject); overload;
  procedure Display(Sender: TObject; Value: string); overload;
  procedure Display(Sender: TObject; Value: TArray<string>); overload;
  procedure Display(Sender: TObject; Value: TChat); overload;
  procedure Display(Sender: TObject; Value: TCodestral); overload;
  procedure Display(Sender: TObject; Value: TEmbeddings); overload;
  procedure Display(Sender: TObject; Value: TModel); overload;
  procedure Display(Sender: TObject; Value: TModels); overload;
  procedure DisplayEx(Sender: TObject; Value: TModerationResult); overload;
  procedure Display(Sender: TObject; Value: TModerationResult); overload;
  procedure DisplayEx(Sender: TObject; Value: TModeration); overload;
  procedure Display(Sender: TObject; Value: TModeration); overload;
  procedure Display(Sender: TObject; Value: TFile); overload;
  procedure Display(Sender: TObject; Value: TFiles); overload;
  procedure Display(Sender: TObject; Value: TDeletedResult); overload;
  procedure Display(Sender: TObject; Value: TDownLoadFile); overload;
  procedure Display(Sender: TObject; Value: TJobOut); overload;
  procedure Display(Sender: TObject; Value: TJobOutProgress); overload;
  procedure Display(Sender: TObject; Value: TListFineTuningJobs); overload;
  procedure Display(Sender: TObject; Value: TBatchJob); overload;
  procedure Display(Sender: TObject; Value: TBatchJobList); overload;
  procedure Display(Sender: TObject; Value: TSignedUrl); overload;
  procedure Display(Sender: TObject; Value: TConversation); overload;
  procedure Display(Sender: TObject; Value: TConversationsListItem); overload;
  procedure Display(Sender: TObject; Value: TRetrievedEntries); overload;
  procedure Display(Sender: TObject; Value: TRetrieveMessages); overload;
  procedure Display(Sender: TObject; Value: TOcr); overload;
  procedure Display(Sender: TObject; Value: TConversationsAgent); overload;
  procedure Display(Sender: TObject; Value: TConversationsAgentList); overload;
  procedure Display(Sender: TObject; Value: TConversationsList); overload;
  procedure Display(Sender: TObject; Value: TLibrariesMain); overload;
  procedure Display(Sender: TObject; Value: TLibrariesMainList); overload;
  procedure Display(Sender: TObject; Value: TLibrariesDocuments); overload;
  procedure Display(Sender: TObject; Value: TLibrariesDocumentsList); overload;
  procedure Display(Sender: TObject; Value: TLibraryDocumentsProcessed); overload;
  procedure Display(Sender: TObject; Value: TLibraryDocumentsText); overload;
  procedure Display(Sender: TObject; Value: TLibraryDocumentsStatus); overload;
  procedure Display(Sender: TObject; Value: TLibrariesAccess); overload;
  procedure Display(Sender: TObject; Value: TLibrariesAccessList); overload;

  procedure Display(Sender: TObject; Value: TAudioTranscription); overload;

  procedure DisplayStream(Sender: TObject; Value: string); overload;
  procedure DisplayStream(Sender: TObject; Value: TChat); overload;
  procedure DisplayStream(Sender: TObject; Value: TCodestral); overload;
  procedure DisplayStream(Sender: TObject; Value: TConversationsEvent); overload;

  procedure DisplayChunk(Value: string); overload;
  procedure DisplayChunk(Value: TChat); overload;
  procedure DisplayChunk(Value: TCodestral); overload;
  procedure DisplayChunk(Value: TConversationsEvent); overload;

  function F(const Name, Value: string): string; overload;
  function F(const Name: string; const Value: TArray<string>): string; overload;
  function F(const Name: string; const Value: boolean): string; overload;
  function F(const Name: string; const State: Boolean; const Value: Double): string; overload;

  function CodeBefore: string;
  function CodeAfter: string;

var
  /// <summary>
  /// A global instance of the <see cref="TVCLTutorialHub"/> class used as the main tutorial hub.
  /// </summary>
  /// <remarks>
  /// This variable serves as the central hub for managing tutorial components, such as memos, buttons, and pages.
  /// It is initialized dynamically during the application's runtime, and its memory is automatically released during
  /// the application's finalization phase.
  /// </remarks>
  TutorialHub: TVCLTutorialHub = nil;

implementation

uses
  System.DateUtils;

function UnixIntToDateTime(const Value: Int64): TDateTime;
begin
  Result := TTimeZone.Local.ToLocalTime(UnixToDateTime(Value));
end;

function UnixDateTimeToString(const Value: Int64): string;
begin
  Result := DateTimeToStr(UnixIntToDateTime(Value))
end;

procedure Cancellation(Sender: TObject);
begin
  Display(Sender, 'The operation was cancelled');
  Display(Sender);
  TutorialHub.Cancel := False;
end;

function DoCancellation: Boolean;
begin
  Result := TutorialHub.Cancel;
end;

procedure Start(Sender: TObject);
begin
  Display(Sender, 'Please wait...');
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: string);
var
  M: TMemo;
begin
  if Sender is TMemo then
    M := TMemo(Sender) else
    M := (Sender as TVCLTutorialHub).Memo1;

  var S := Value.Split([#10]);
  if Length(S) = 0 then
    begin
      M.Lines.Add(Value)
    end
  else
    begin
      for var Item in S do
        M.Lines.Add(Item);
    end;

  M.Perform(WM_VSCROLL, SB_BOTTOM, 0);
end;

procedure Display(Sender: TObject; Value: TArray<string>);
begin
  var index := 0;
  for var Item in Value do
    begin
      if not Item.IsEmpty then
        begin
          if index = 0 then
            Display(Sender, Item) else
            Display(Sender, '    ' + Item);
        end;
      Inc(index);
    end;
end;

procedure Display(Sender: TObject);
begin
  Display(Sender, sLineBreak);
end;

procedure Display(Sender: TObject; Value: TChat);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Choices do
    if Item.FinishReason = TFinishReason.tool_calls then
      begin
        if Assigned(TutorialHub.ToolCall) then
          TutorialHub.ToolCall(Item.Message.ToolsCalls[0], TutorialHub.Tool);
      end
    else
      begin
        for var SubItem in Item.Message.Content do
          begin
            case SubItem.&Type of
              TContentType.text:
                Display(Sender, SubItem.Text);
              TContentType.thinking:
                begin
                  for var Think in SubItem.Thinking do
                    Display(TutorialHub.Memo2, Think.Text);
                end;
            end;
          end;
      end;
end;

procedure Display(Sender: TObject; Value: TCodestral); overload;
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Choices do
    if Item.FinishReason = TCodestralFinishReason.tool_calls then
      begin
        if Assigned(TutorialHub.ToolCall) then
          TutorialHub.ToolCall(Item.Message.ToolsCalls[0], TutorialHub.Tool);
      end
    else
      begin
        Display(Sender, Item.Message.Content);
      end;
end;

procedure Display(Sender: TObject; Value: TEmbeddings); overload;
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  var i := 0;
  for var Item in Value.Data do
    begin
      var j := 0;
      for var SubItem in Item.Embedding do
          begin
            Display(Sender, Format('Vector[%d, %d] = %s', [i, j, SubItem.ToString(ffNumber, 8, 8)]));
            Inc(j);
            Application.ProcessMessages;
          end;
      Display(Sender);
      Inc(i);
    end;
end;

procedure Display(Sender: TObject; Value: TModel);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    Value.Id,
    F('Name', Value.Name),
    F('Description', Value.Description),
    F('Deprecation', Value.Deprecation),
    F('Default temperature', Value.DefaultModelTemperature.ToString(ffNumber, 3, 2)),
    F('Completion chat', BoolToStr(Value.Capabilities.CompletionChat, True)),
    F('Completion fim', BoolToStr(Value.Capabilities.CompletionFim, True)),
    F('Function calling', BoolToStr(Value.Capabilities.FunctionCalling, True)),
    F('Fine-tuning', BoolToStr(Value.Capabilities.FineTuning, True)),
    F('Vision', BoolToStr(Value.Capabilities.Vision, True))
  ]);
  Display(Sender, EmptyStr);
end;

procedure Display(Sender: TObject; Value: TModels);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  if Length(Value.Data) = 0 then
    begin
      Display(Sender, 'No model found');
      Exit;
    end;
  for var Item in Value.Data do
    begin
      Display(Sender, Item);
      Application.ProcessMessages;
    end;
  Display(Sender);
end;

procedure DisplayEx(Sender: TObject; Value: TModerationResult);
var
  Temp: TArray<string>;
begin
  if Value.Warning then
    begin
      Temp := [''];
      for var Item in Value.Warnings do
        Temp := Temp + [F(Item.Category, (Item.Score * 100).ToString(ffNumber, 3, 2)) + '%'];
      Display(Sender, Temp);
      Display(Sender);
    end
  else
    begin
      Display(Sender, 'No moderation is necessary');
    end;
end;

procedure Display(Sender: TObject; Value: TModerationResult);
begin
  if Value.Warning then
    begin
      Display(Sender, [EmptyStr,
        F(Classifiers[0], Value.Categories.Sexual, Value.Scores.Sexual),
        F(Classifiers[1], Value.Categories.Hate_and_discrimination, Value.Scores.Hate_and_discrimination),
        F(Classifiers[2], Value.Categories.Violence_and_threats, Value.Scores.Violence_and_threats),
        F(Classifiers[3], Value.Categories.Dangerous_and_criminal_content, Value.Scores.Dangerous_and_criminal_content),
        F(Classifiers[4], Value.Categories.Selfharm, Value.Scores.Selfharm),
        F(Classifiers[5], Value.Categories.Health, Value.Scores.Health),
        F(Classifiers[6], Value.Categories.Financial, Value.Scores.Financial),
        F(Classifiers[7], Value.Categories.Law, Value.Scores.Law),
        F(Classifiers[8], Value.Categories.Pii, Value.Scores.Pii)
      ]);
    end
  else
    begin
      Display(Sender, 'No moderation is necessary');
    end;
end;

procedure Display(Sender: TObject; Value: TModeration);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Results do
    Display(Sender, Item);
end;

procedure DisplayEx(Sender: TObject; Value: TModeration);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Results do
    DisplayEx(Sender, Item);
end;

procedure Display(Sender: TObject; Value: TFile);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, F('id', Value.Id));
  Display(Sender, F('filename', Value.FileName));
  Display(Sender, F('Source', Value.Source.ToString));
  Display(Sender, F('Purpose', Value.Purpose.ToString));
  Display(Sender, F('Object', Value.&Object));
  Display(Sender, F('Bytes', Value.Bytes.ToString));
  Display(Sender, F('mimetype', Value.Mimetype));
  Display(Sender, F('numlines', Value.NumLines.ToString));
  Display(Sender, F('signature', Value.Signature));
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TFiles);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  if Length(Value.Data) = 0 then
    begin
      Display(Sender, 'No file found');
      Exit;
    end;
  for var Item in Value.Data do
    Display(Sender, Item);
end;

procedure Display(Sender: TObject; Value: TDeletedResult);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    F('Id', Value.Id),
    F('Deleted', [
      BoolToStr(Value.Deleted, True),
      F('Object', Value.&Object)
    ])
  ]);
end;

procedure Display(Sender: TObject; Value: TDownLoadFile);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  if TutorialHub.FileName.IsEmpty then
    raise Exception.Create('No filename defined for download.');
  Value.SaveToFile(TutorialHub.FileName, not TutorialHub.FileOverride);
  Display(Sender, Format('File downloaded and saved as "%s"', [TutorialHub.FileName]));
end;

procedure Display(Sender: TObject; Value: TJobOut);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    Value.Id,
    F('AutoStart', [
      BoolToStr(Value.AutoStart, True),
      F('Model', Value.Model),
      F('Status', Value.Status.ToString),
      F('FineTuningModel', VartoStr(Value.FineTuningModel))
    ])
  ]);
end;

procedure Display(Sender: TObject; Value: TJobOutProgress);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    Value.Id,
    F('AutoStart', [
      BoolToStr(Value.AutoStart, True),
      F('Model', Value.Model),
      F('Status', Value.Status.ToString),
      F('FineTuningModel', VartoStr(Value.FineTuningModel))
    ])
  ]);
  for var Item in Value.Events do
    Display(Sender, [
      Item.Name,
      Item.Data.Status.ToString,
      Item.Data.Error,
      UnixDateTimeToString(Item.CreatedAt)
    ]);
end;

procedure Display(Sender: TObject; Value: TListFineTuningJobs);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, F('Total', [Value.Total.ToString, F('Object', Value.&Object.ToString)]));
  for var Item in Value.Data do
    Display(Sender, F('Id', [
      Item.Id,
      F('Model', Item.Model),
      F('Status', Item.Status.ToString)
    ]));
end;

procedure Display(Sender: TObject; Value: TBatchJob);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, F('Id', [
    Value.Id,
    F('Model', Value.Model),
    F('Endpoint', Value.Endpoint.ToString),
    F('Status', Value.Status.ToString),
    F('CreatedAt', UnixDateTimeToString(Value.CreatedAt))
  ]));
  if not Value.OutputFile.IsEmpty then
    Display(Sender, F('OutputFile', Value.OutputFile));
  Display(Sender, Value.Metadata);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TBatchJobList);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, F('Total', [
    Value.Total.ToString,
    F('Object', Value.&Object)]));
  for var Item in Value.Data do
    Display(Sender, Item);
end;

procedure Display(Sender: TObject; Value: TSignedUrl);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, Value.Url);
end;

procedure Display(Sender: TObject; Value: TConversation);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Outputs do
  begin
    case Item.&Type of
      TConversatonEvent.function_call :
        TutorialHub.ToolCallEx(Item, TutorialHub.Tool);

      TConversatonEvent.message_input,
      TConversatonEvent.message_output:
        begin
          for var SubItem in Item.Content do
            case SubItem.&Type of
              TContentChunkType.text:
                Display(Sender, SubItem.Text);

              TContentChunkType.tool_file:
                begin
                  case Subitem.Tool of
                    TConversationTool.image_generation:
                      TutorialHub.LoadImage(SubItem.FileId);
                  end;
                end;
            end;
        end;
    end;
  end;
end;

procedure Display(Sender: TObject; Value: TConversationsListItem);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  if Assigned(Value) then
    begin
      Display(Sender, F('objet', Value.&Object));
      Display(Sender, F('id', Value.Id));
      Display(Sender, F('stop', Value.CompletionArgs.Stop));
    end;
end;

procedure Display(Sender: TObject; Value: TRetrievedEntries); overload;
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(TutorialHub, F('object', Value.&Object));
  Display(TutorialHub, F('conversation_id', Value.ConversationId));
  Display(TutorialHub, EmptyStr);
  for var Item in Value.Entries do
    begin
      Display(TutorialHub, F('object', Item.&Object));
      Display(TutorialHub, F('type', Item.&Type.ToString));
      Display(TutorialHub, F('id', Item.Id));
      case Item.&Type of
        TConversatonEvent.message_input,
        TConversatonEvent.message_output:
          Display(TutorialHub, F('role', Item.Role.ToString));
        TConversatonEvent.tool_execution:
        Display(TutorialHub, F('function', Item.&Function));
      end;
      Display(TutorialHub, F('prefix', BoolToStr(Item.Prefix, True)));
      for var SubItem in Item.Content do
        begin
          if SubItem.&Type = TContentChunkType.text then
            Display(TutorialHub, F('content', SubItem.Text));
          Display(TutorialHub, EmptyStr);
        end;
      Display(TutorialHub, '----------------');
    end;
end;

procedure Display(Sender: TObject; Value: TRetrieveMessages);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(TutorialHub, F('object', Value.&Object));
  Display(TutorialHub, F('conversation_id', Value.ConversationId));
  Display(TutorialHub, EmptyStr);
  for var Item in Value.Messages do
    begin
      Display(TutorialHub, F('object', Item.&Object));
      Display(TutorialHub, F('type', Item.&Type.ToString));
      Display(TutorialHub, F('id', Item.Id));
      case Item.&Type of
        TConversatonEvent.message_input,
        TConversatonEvent.message_output:
          Display(TutorialHub, F('role', Item.Role.ToString));
      end;

      Display(TutorialHub, F('prefix', BoolToStr(Item.Prefix, True)));
      for var SubItem in Item.Content do
        begin
          if SubItem.&Type = TContentChunkType.text then
            Display(TutorialHub, F('content', SubItem.Text));
          Display(TutorialHub, EmptyStr);
        end;
      Display(TutorialHub, '----------------');
    end;
end;

procedure Display(Sender: TObject; Value: TOcr);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Pages do
    begin
      Display(Sender, F('page', Item.Index.ToString));
      Display(Sender, Item.Markdown);
    end;
end;

procedure Display(Sender: TObject; Value: TConversationsAgent);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, F('id', Value.Id));
  Display(Sender, F('name', Value.Name));
  if not Value.Model.IsEmpty then
    Display(Sender, F('model', Value.Model));
  if not Value.Description.IsEmpty then
    Display(Sender, F('description', Value.Description));
  if not Value.Instructions.IsEmpty then
    Display(Sender, F('instructions', Value.Instructions));
  Display(Sender, F('version', Value.Version.ToString));
  Display(Sender, EmptyStr);
end;

procedure Display(Sender: TObject; Value: TConversationsAgentList);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    Display(Sender, Item);
end;

procedure Display(Sender: TObject; Value: TConversationsList);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    Display(TutorialHub, Item.Id);
end;

procedure Display(Sender: TObject; Value: TLibrariesMain);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, F('id', F(Value.Id, F('name', Value.Name))));
  Display(Sender, F('chunk_size', Value.ChunkSize.ToString));
  Display(Sender, F('description',Value.Description));
  Display(Sender, EmptyStr);
end;

procedure Display(Sender: TObject; Value: TLibrariesMainList);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    Display(Sender, Item);
end;

procedure Display(Sender: TObject; Value: TLibrariesDocuments);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, F('id', F(Value.Id, F('name', Value.Name))));
  Display(Sender, F('processing_status', F(Value.ProcessingStatus, F('mime_type', Value.MimeType))));
  Display(Sender, F('summary', Value.Summary));
  Display(Sender, EmptyStr);
end;

procedure Display(Sender: TObject; Value: TLibrariesDocumentsList);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender,
    F('total_items',
      F(Value.Pagination.TotalItems.ToString,
        F('total_pages', Value.Pagination.TotalPages.ToString))));
  Display(Sender,
    F('current_page',
      F(Value.Pagination.CurrentPage.ToString,
        F('has_more', BoolToStr(Value.Pagination.HasMore, True)))));
  for var Item in Value.Data do
    Display(Sender, Item);
end;

procedure Display(Sender: TObject; Value: TLibraryDocumentsProcessed);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, F('processed', BoolToStr(Value.Processed, True)));
end;

procedure Display(Sender: TObject; Value: TLibraryDocumentsText);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, Value.Text);
end;

procedure Display(Sender: TObject; Value: TLibraryDocumentsStatus);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, F('document_id', Value.DocumentId));
  Display(Sender, F('processing_status', Value.ProcessingStatus));
  Display(Sender, EmptyStr);
end;

procedure Display(Sender: TObject; Value: TLibrariesAccess);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, F('library_id', Value.LibraryId));
  Display(Sender, F('role', Value.Role));
  Display(Sender, F('share_with_uuid', Value.ShareWithUuid));
  Display(Sender, F('share_with_type', Value.ShareWithType.ToString));
  Display(Sender, F('user_id', Value.UserId));
  Display(Sender, EmptyStr);
end;

procedure Display(Sender: TObject; Value: TLibrariesAccessList);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    Display(Sender, Item);
end;

procedure Display(Sender: TObject; Value: TAudioTranscription);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, F('model', Value.Model));
  Display(Sender, F('language', Value.Language));
  Display(Sender, Value.Text);
  Display(Sender);
end;

procedure DisplayStream(Sender: TObject; Value: string);
var
  M: TMemo;
  CurrentLine: string;
  Lines: TArray<string>;
begin
  if Sender is TMemo then
    M := TMemo(Sender) else
    M := (Sender as TVCLTutorialHub).Memo1;
  var OldSelStart := M.SelStart;
  var ShouldScroll := (OldSelStart = M.GetTextLen);
  M.Lines.BeginUpdate;
  try
    Lines := Value.Split([#10]);
    if Length(Lines) > 0 then
    begin
      if M.Lines.Count > 0 then
        CurrentLine := M.Lines[M.Lines.Count - 1]
      else
        CurrentLine := '';
      CurrentLine := CurrentLine + Lines[0];
      if M.Lines.Count > 0 then
        M.Lines[M.Lines.Count - 1] := CurrentLine
      else
        M.Lines.Add(CurrentLine);
      for var i := 1 to High(Lines) do
        M.Lines.Add(Lines[i]);
    end;
  finally
    M.Lines.EndUpdate;
  end;
  if ShouldScroll then
  begin
    M.SelStart := M.GetTextLen;
    M.SelLength := 0;
    M.Perform(EM_SCROLLCARET, 0, 0);
  end;
end;

procedure DisplayStream(Sender: TObject; Value: TChat);
begin
  if Assigned(Value) then
    begin
      for var Item in Value.Choices do
        begin
          for var SubItem in Item.Delta.Content do
          begin
            case SubItem.&Type of
              TContentType.text:
                DisplayStream(Sender, SubItem.Text);
              TContentType.thinking:
                begin
                  for var Think in SubItem.Thinking do
                    DisplayStream(TutorialHub.Memo2, Think.Text);
                end;
            end;
          end;

        end;
      DisplayChunk(Value);
    end;
end;

procedure DisplayStream(Sender: TObject; Value: TCodestral); overload;
begin
  if Assigned(Value) then
    begin
      for var Item in Value.Choices do
        begin
          DisplayStream(Sender, Item.Delta.Content);
        end;
      DisplayChunk(Value);
    end;
end;

procedure DisplayStream(Sender: TObject; Value: TConversationsEvent);
begin
  if Assigned(Value) then
    begin
      DisplayChunk(Value);
      if Value.&Type = TChunkEvent.message_output_delta then
        DisplayStream(Sender, Value.Content[0].Text);
    end;
end;

procedure DisplayChunk(Value: string); overload;
begin
  var JSONValue := TJSONObject.ParseJSONValue(Value);
  TutorialHub.Memo4.Lines.BeginUpdate;
  try
    Display(TutorialHub.Memo4, JSONValue.ToString);
  finally
    TutorialHub.Memo4.Lines.EndUpdate;
    JSONValue.Free;
  end;
end;

procedure DisplayChunk(Value: TChat); overload;
begin
  DisplayChunk(Value.JSONResponse);
end;

procedure DisplayChunk(Value: TCodestral); overload;
begin
  DisplayChunk(Value.JSONResponse);
end;

procedure DisplayChunk(Value: TConversationsEvent); overload;
begin
  DisplayChunk(Value.JSONResponse);
end;

function F(const Name, Value: string): string;
begin
  if not Value.IsEmpty then
    Result := Format('%s: %s', [Name, Value])
end;

function F(const Name: string; const Value: TArray<string>): string;
begin
  var index := 0;
  for var Item in Value do
    begin
      if index = 0 then
        Result := Format('%s: %s', [Name, Item]) else
        Result := Result + '    ' + Item;
      Inc(index);
    end;
end;

function F(const Name: string; const Value: boolean): string;
begin
  Result := Format('%s: %s', [Name, BoolToStr(Value, True)])
end;

function F(const Name: string; const State: Boolean; const Value: Double): string;
begin
  Result := Format('%s (%s): %s%%', [Name, BoolToStr(State, True), (Value * 100).ToString(ffNumber, 3, 2)])
end;

function CodeBefore: string;
begin
  with TStringWriter.Create do
  try
    WriteLine('def is_odd(n):');
    WriteLine('  return n % 2 == 1');
    WriteLine('def test_is_odd():');
    Result := ToString;
  finally
    Free;
  end;
end;

function CodeAfter: string;
begin
  with TStringWriter.Create do
  try
    WriteLine('n = int(input(''Enter a number: ''))');
    WriteLine('print(fibonacci(n))');
    Result := ToString;
  finally
    Free;
  end;
end;

{ TVCLTutorialHub }

constructor TVCLTutorialHub.Create(const AClient: IMistralAI; const AMemo1, AMemo2, AMemo3, AMemo4: TMemo; const AButton: TButton);
begin
  inherited Create;
  FClient := AClient;
  Memo1 := AMemo1;
  Memo2 := AMemo2;
  Memo3 := AMemo3;
  Memo4 := AMemo4;
  Button := AButton;
  FFileOverride := False;
end;

procedure TVCLTutorialHub.JSONRequestClear;
begin
  Memo3.Clear;
end;

procedure TVCLTutorialHub.JSONResponseClear;
begin
  Memo4.Clear;
end;

procedure TVCLTutorialHub.LoadImage(const FilePath: string);
begin
  FClient.&File.AsyncGetSignedUrl(FilePath,
  procedure (Params: TSignedUrlParams)
  begin
    Params.Expiry(1);
  end,
  function : TAsyncSignedUrl
  begin
    Result.OnSuccess :=
      procedure (Sender: TObject; Value: TSignedUrl)
      begin
        THttpx.DownloadFromSignedUrl(Value.Url, True);
      end;
    Result.OnError := Display;
  end);
end;

procedure TVCLTutorialHub.NextPage;
begin
  Inc(FPage);
end;

procedure TVCLTutorialHub.OnButtonClick(Sender: TObject);
begin
  Cancel := True;
end;

procedure TVCLTutorialHub.SetButton(const Value: TButton);
begin
  FButton := Value;
  FButton.OnClick := OnButtonClick;
  FButton.Caption := 'Cancel';
end;

procedure TVCLTutorialHub.SetJSONRequest(const Value: string);
begin
  Memo3.Lines.Text := Value;
  Memo3.SelStart := 0;
  Application.ProcessMessages;
end;

procedure TVCLTutorialHub.SetJSONResponse(const Value: string);
begin
  Memo4.Lines.Text := Value;
  Memo4.SelStart := 0;
  Application.ProcessMessages;
end;

procedure TVCLTutorialHub.SetMemo1(const Value: TMemo);
begin
  FMemo1 := Value;
  FMemo1.ScrollBars := TScrollStyle.ssVertical;
end;

procedure TVCLTutorialHub.SetMemo2(const Value: TMemo);
begin
  FMemo2 := Value;
  FMemo2.ScrollBars := TScrollStyle.ssVertical;
end;

procedure TVCLTutorialHub.SetMemo3(const Value: TMemo);
begin
  FMemo3 := Value;
  FMemo3.ScrollBars := TScrollStyle.ssBoth;
end;

procedure TVCLTutorialHub.SetMemo4(const Value: TMemo);
begin
  FMemo4 := Value;
  FMemo4.ScrollBars := TScrollStyle.ssBoth;
end;

procedure TVCLTutorialHub.WeatherFunction(const Value: TCalledFunction;
  Func: IFunctionCore);
begin
  var ArgResult := Func.Execute(Value.&Function.Arguments);

  FClient.Chat.AsyncCreateStream(
    procedure (Params: TChatParams)
    begin
      Params.Model('open-mixtral-8x22b-2404');
      Params.Messages([
        PayLoad.System('Respond like a star weather presenter on a prime-time TV channel.'),
        Payload.User(ArgResult)
      ]);
      Params.Stream(True);
      Params.MaxTokens(1024);
    end,
    function : TAsynChatStream
    begin
      Result.Sender := TutorialHub;
      Result.OnProgress := DisplayStream;
      Result.OnSuccess := Display;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
      Result.OnError := Display;
    end);
end;

procedure TVCLTutorialHub.WeatherFunctionEx(const Value: TMessageOutputEntry;
  Func: IFunctionCore);
begin
  var ArgResult := Func.Execute(Value.Arguments);

  FClient.Conversations.AsyncCreateStream(
    procedure (Params: TConversationsParams)
    begin
      Params.Instructions('Respond like a star weather presenter on a prime-time TV channel.');
      Params.Inputs(ArgResult);
      Params.Model('mistral-medium-2505');
      Params.Stream;
      Params.Store(False);
      Params.CompletionArgs(TCompletionArgsParams.Create
        .Temperature(0.3)
        .TopP(0.95)
      )
    end,
    function : TAsyncConversationsEvent
    begin
      Result.Sender := TutorialHub;
      Result.OnProgress := DisplayStream;
      Result.OnSuccess := Display;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
      Result.OnError := Display;
    end);
end;

initialization
finalization
  if Assigned(TutorialHub) then
    TutorialHub.Free;
end.

unit MistralAI.Types;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiMistralAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, MistralAI.API.Params, System.JSON, REST.JsonReflect;

const
  ReasoningEnglishInstructions =
    'An end user will ask you to solve a task. Begin by drafting your thought process (inner monologue) until you arrive at the final answer. Then write a summary of your reflections (i.e., concise but containing all essential steps needed to reach the conclusion). Use Markdown to format your response. Write both your thoughts and your summary in the same language as the task presented by the user. NEVER use \boxed{} in your answer.'+ #10 +
    'Your thought process must follow the model below:'+ #10 +
    '<think>'+ #10 +
    'Your thoughts and/or your draft, as if working out a rough exercise on scrap paper. Feel free to be as casual and as long-winded as you like until you’re certain you can arrive at the correct answer.'+ #10 +
    '</think>'+ #10 +
    'Provide here a concise summary that reflects your reasoning and presents a clear final answer to the user. Do not indicate that it is a summary.';

{$SCOPEDENUMS ON}

type
  {$REGION 'MistralAI.Chat'}

  /// <summary>
  /// Type of message role
  /// </summary>
  TMessageRole = (
    /// <summary>
    /// System message
    /// </summary>
    system,
    /// <summary>
    /// User message
    /// </summary>
    user,
    /// <summary>
    /// Assistant message
    /// </summary>
    assistant,
    /// <summary>
    /// Function message
    /// </summary>
    tool);

  /// <summary>
  /// Helper record for the <c>TMessageRole</c> enumeration, providing utility methods for converting
  /// between <c>TMessageRole</c> values and their string representations.
  /// </summary>
  TMessageRoleHelper = record helper for TMessageRole
    constructor Create(const Value: string);
    /// <summary>
    /// Converts the current <c>TMessageRole</c> value to its corresponding string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>TMessageRole</c> value.
    /// </returns>
    /// <remarks>
    /// <code>
    /// var Role: TMessageRole;
    /// begin
    ///   Role := TMessageRole.system;
    ///   ShowMessage(Role.ToString);  // Outputs "system"
    /// end;
    /// </code>
    /// </remarks>
    function ToString: string;
  end;

  TMessageRoleInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// Converts the <c>TMessageRole</c> value of the specified field to a string during JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be converted.
    /// </param>
    /// <param name="Field">
    /// The field name representing the <c>TMessageRole</c> value.
    /// </param>
    /// <returns>
    /// The string representation of the <c>TMessageRole</c> value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string back to a <c>TMessageRole</c> value for the specified field during JSON deserialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be set.
    /// </param>
    /// <param name="Field">
    /// The field name where the <c>TMessageRole</c> value will be set.
    /// </param>
    /// <param name="Arg">
    /// The string representation of the <c>TMessageRole</c> to be converted back.
    /// </param>
    /// <remarks>
    /// This method converts the string argument back to the corresponding <c>TMessageRole</c> value and assigns it to the specified field in the object.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Represents the different reasons why the processing of a request can terminate.
  /// </summary>
  TFinishReason = (
    /// <summary>
    /// API returned complete model output
    /// </summary>
    stop,
    /// <summary>
    /// Incomplete model output due to max_tokens parameter or token limit
    /// </summary>
    length,
    /// <summary>
    /// model_length
    /// </summary>
    model_length,
    /// <summary>
    /// An error was encountered while processing the request
    /// </summary>
    error,
    /// <summary>
    /// A function must be invoked before further processing of the request
    /// </summary>
    tool_calls);

     /// <summary>
  /// Helper record for the <c>TFinishReason</c> enumeration, providing utility methods for conversion between string representations and <c>TFinishReason</c> values.
  /// </summary>
  TFinishReasonHelper = record helper for TFinishReason
    constructor Create(const Value: string);
    /// <summary>
    /// Converts the current <c>TFinishReason</c> value to its string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>TFinishReason</c> value.
    /// </returns>
    function ToString: string;
  end;

  /// <summary>
  /// Interceptor class for converting <c>TFinishReason</c> values to and from their string representations in JSON serialization and deserialization.
  /// </summary>
  /// <remarks>
  /// This class is used to facilitate the conversion between the <c>TFinishReason</c> enum and its string equivalents during JSON processing.
  /// It extends the <c>TJSONInterceptorStringToString</c> class to override the necessary methods for custom conversion logic.
  /// </remarks>
  TFinishReasonInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// Converts the <c>TFinishReason</c> value of the specified field to a string during JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be converted.
    /// </param>
    /// <param name="Field">
    /// The field name representing the <c>TFinishReason</c> value.
    /// </param>
    /// <returns>
    /// The string representation of the <c>TFinishReason</c> value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string back to a <c>TFinishReason</c> value for the specified field during JSON deserialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be set.
    /// </param>
    /// <param name="Field">
    /// The field name where the <c>TFinishReason</c> value will be set.
    /// </param>
    /// <param name="Arg">
    /// The string representation of the <c>TFinishReason</c> to be converted back.
    /// </param>
    /// <remarks>
    /// This method converts the string argument back to the corresponding <c>TFinishReason</c> value and assigns it to the specified field in the object.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Represents the type of the content: text or image_url
  /// </summary>
  TContentType = (
    text,
    image_url,
    reference,
    document_url,
    input_audio,
    thinking
  );

  /// <summary>
  /// Helper record for the <c>TContentType</c> enumeration, providing utility methods for conversion between string representations and <c>TContentType</c> values.
  /// </summary>
  TContentTypeHelper = record Helper for TContentType
    constructor Create(const Value: string);
    /// <summary>
    /// Converts the current <c>TFinishReason</c> value to its string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>TFinishReason</c> value.
    /// </returns>
    function ToString: string;
  end;

  TContentTypeInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// Converts the <c>TContentType</c> value of the specified field to a string during JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be converted.
    /// </param>
    /// <param name="Field">
    /// The field name representing the <c>TContentType</c> value.
    /// </param>
    /// <returns>
    /// The string representation of the <c>TContentType</c> value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string back to a <c>TContentType</c> value for the specified field during JSON deserialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be set.
    /// </param>
    /// <param name="Field">
    /// The field name where the <c>TContentType</c> value will be set.
    /// </param>
    /// <param name="Arg">
    /// The string representation of the <c>TContentType</c> to be converted back.
    /// </param>
    /// <remarks>
    /// This method converts the string argument back to the corresponding <c>TFinishReason</c> value and assigns it to the specified field in the object.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Represents the type of tool type: only "function" available
  /// </summary>
  TToolType = (
    web_search_premium,
    web_search,
    image_generation,
    &function,
    document_library,
    code_interpreter
  );

  /// <summary>
  /// Helper record for the <c>TToolType</c> enumeration, providing utility methods for conversion between string representations and <c>TToolType</c> values.
  /// </summary>
  TToolTypeHelper = record Helper for TToolType
    constructor Create(const Value: string);
    /// <summary>
    /// Converts the current <c>TFinishReason</c> value to its string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>TFinishReason</c> value.
    /// </returns>
    function ToString: string;
  end;

  TResponseFormatType = (
    text,
    json_object,
    json_schema
  );

  TResponseFormatTypeHelper = record Helper for TResponseFormatType
    constructor Create(const Value: string);
    function ToString: string;
  end;

  {$ENDREGION}

  {$REGION 'MistralAI.FineTunings'}

  /// <summary>
  /// Enum of the different statuses for a fine-tuning job.
  /// </summary>
  /// <remarks>
  /// Represents the various statuses that a fine-tuning job can have during its lifecycle.
  /// </remarks>
  TFineTuningJobStatus = (
    /// <summary>
    /// The job is queued and waiting to start.
    /// </summary>
    Queued,
    /// <summary>
    /// The job has started
    /// </summary>
    Started,
    /// <summary>
    /// Yhe job is currently being validated
    /// </summary>
    Validating,
    /// <summary>
    /// The job has been validated
    /// </summary>
    Validated,
    /// <summary>
    /// The job is currently running.
    /// </summary>
    Running,
    /// <summary>
    /// The validation failed.
    /// </summary>
    Failed_validation,
    /// <summary>
    /// The job has failed.
    /// </summary>
    Failed,
    /// <summary>
    /// The job ended successfully.
    /// </summary>
    Success,
    /// <summary>
    /// The job has been cancelled.
    /// </summary>
    Cancelled,
    /// <summary>
    /// A cancellation request has been made; the job is awaiting cancellation.
    /// </summary>
    CancellationRequested);

  /// <summary>
  /// Provides helper methods for the TFineTuningJobStatus enum.
  /// </summary>
  /// <remarks>
  /// Includes methods to convert enum values to strings and create enum values from strings.
  /// </remarks>
  TFineTuningJobStatusHelper = record helper for TFineTuningJobStatus
    constructor Create(const Value: string);
    /// <summary>
    /// Converts the TFineTuningJobStatus value to its string representation.
    /// </summary>
    /// <returns>
    /// The string representation of the TFineTuningJobStatus value.
    /// </returns>
    function ToString: string;
  end;

  /// <summary>
  /// JSON interceptor for converting TFineTuningJobStatus enum values to strings and vice versa during JSON serialization and deserialization.
  /// </summary>
  TFineTuningJobStatusInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// Converts a TFineTuningJobStatus enum value to its string representation for JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to convert.
    /// </param>
    /// <param name="Field">
    /// The name of the field to convert.
    /// </param>
    /// <returns>
    /// The string representation of the TFineTuningJobStatus enum value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string from JSON deserialization back to a TFineTuningJobStatus enum value.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to revert.
    /// </param>
    /// <param name="Field">
    /// The name of the field to revert.
    /// </param>
    /// <param name="Arg">
    /// The string value to convert back to the enum.
    /// </param>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Represents the kind of data object in fine-tuning operations.
  /// </summary>
  /// <remarks>
  /// Currently only 'Job' is defined.
  /// </remarks>
  TFineTuningDataObjectKind = (
    /// <summary>
    /// Indicates a fine-tuning job object.
    /// </summary>
    Job
  );

  /// <summary>
  /// Provides helper methods for the TFineTuningDataObjectKind enum.
  /// </summary>
  /// <remarks>
  /// Includes methods to convert enum values to strings and create enum values from strings.
  /// </remarks>
  TFineTuningDataObjectKindHelper = record helper for TFineTuningDataObjectKind
    constructor Create(const Value: string);
    /// <summary>
    /// Converts the TFineTuningDataObjectKind value to its string representation.
    /// </summary>
    /// <returns>
    /// The string representation of the TFineTuningDataObjectKind value.
    /// </returns>
    function ToString: string;
  end;

  /// <summary>
  /// JSON interceptor for converting TFineTuningDataObjectKind enum values to strings and vice versa during JSON serialization and deserialization.
  /// </summary>
  TFineTuningDataObjectKindInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// Converts a TFineTuningDataObjectKind enum value to its string representation for JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to convert.
    /// </param>
    /// <param name="Field">
    /// The name of the field to convert.
    /// </param>
    /// <returns>
    /// The string representation of the TFineTuningDataObjectKind enum value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string from JSON deserialization back to a TFineTuningDataObjectKind enum value.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to revert.
    /// </param>
    /// <param name="Field">
    /// The name of the field to revert.
    /// </param>
    /// <param name="Arg">
    /// The string value to convert back to the enum.
    /// </param>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Type of platform with which to integrate monitoring information for fine-tuning operations.
  /// </summary>
  TFineTuningIntegrationType = (
    /// <summary>
    /// See "Weights and Biases" solutions at the website "https://wandb.ai/site".
    /// </summary>
    Wandb
  );

  /// <summary>
  /// Provides helper methods for the TFineTuningIntegrationType enum.
  /// </summary>
  /// <remarks>
  /// Includes methods to convert enum values to strings and create enum values from strings.
  /// </remarks>
  TFineTuningIntegrationTypeHelper = record helper for TFineTuningIntegrationType
    constructor Create(const Value: string);
    /// <summary>
    /// Converts the TFineTuningIntegrationType value to its string representation.
    /// </summary>
    /// <returns>
    /// The string representation of the TFineTuningIntegrationType value.
    /// </returns>
    function ToString: string;
  end;

  /// <summary>
  /// JSON interceptor for converting TFineTuningIntegrationType enum values to strings and vice versa during JSON serialization and deserialization.
  /// </summary>
  TFineTuningIntegrationTypeInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// Converts a TFineTuningIntegrationType enum value to its string representation for JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to convert.
    /// </param>
    /// <param name="Field">
    /// The name of the field to convert.
    /// </param>
    /// <returns>
    /// The string representation of the TFineTuningIntegrationType enum value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string from JSON deserialization back to a TFineTuningIntegrationType enum value.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to revert.
    /// </param>
    /// <param name="Field">
    /// The name of the field to revert.
    /// </param>
    /// <param name="Arg">
    /// The string value to convert back to the enum.
    /// </param>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Represents the kind of object returned by fine-tuning operations.
  /// </summary>
  /// <remarks>
  /// Currently only 'List' is defined.
  /// </remarks>
  TFineTuningObjectKind = (
    /// <summary>
    /// Indicates a list of fine-tuning jobs.
    /// </summary>
    List
  );

  /// <summary>
  /// Provides helper methods for the TFineTuningObjectKind enum.
  /// </summary>
  /// <remarks>
  /// Includes methods to convert enum values to strings and create enum values from strings.
  /// </remarks>
  TFineTuningObjectKindHelper = record helper for TFineTuningObjectKind
    constructor Create(const Value: string);
    /// <summary>
    /// Converts the TFineTuningObjectKind value to its string representation.
    /// </summary>
    /// <returns>
    /// The string representation of the TFineTuningObjectKind value.
    /// </returns>
    function ToString: string;
  end;

  /// <summary>
  /// JSON interceptor for converting TFineTuningObjectKind enum values to strings and vice versa during JSON serialization and deserialization.
  /// </summary>
  TFineTuningObjectKindInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// Converts a TFineTuningObjectKind enum value to its string representation for JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to convert.
    /// </param>
    /// <param name="Field">
    /// The name of the field to convert.
    /// </param>
    /// <returns>
    /// The string representation of the TFineTuningObjectKind enum value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string from JSON deserialization back to a TFineTuningObjectKind enum value.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to revert.
    /// </param>
    /// <param name="Field">
    /// The name of the field to revert.
    /// </param>
    /// <param name="Arg">
    /// The string value to convert back to the enum.
    /// </param>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  TRepositoryType = (
    github
  );

  /// <summary>
  /// Provides helper methods for the TRepositoryType enum.
  /// </summary>
  /// <remarks>
  /// Includes methods to convert enum values to strings and create enum values from strings.
  /// </remarks>
  TRepositoryTypeHelper = record Helper for TRepositoryType
    constructor Create(const Value: string);
    /// <summary>
    /// Converts the TRepositoryType value to its string representation.
    /// </summary>
    /// <returns>
    /// The string representation of the TRepositoryType value.
    /// </returns>
    function ToString: string;
  end;

  /// <summary>
  /// JSON interceptor for converting TRepositoryType enum values to strings and vice versa during JSON serialization and deserialization.
  /// </summary>
  TRepositoryTypeInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// Converts a TRepositoryType enum value to its string representation for JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to convert.
    /// </param>
    /// <param name="Field">
    /// The name of the field to convert.
    /// </param>
    /// <returns>
    /// The string representation of the TRepositoryType enum value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string from JSON deserialization back to a TRepositoryType enum value.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to revert.
    /// </param>
    /// <param name="Field">
    /// The name of the field to revert.
    /// </param>
    /// <param name="Arg">
    /// The string value to convert back to the enum.
    /// </param>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Interceptor class for converting <c>args</c> and <c>response</c> values into JSON string format in JSON deserialization.
  /// </summary>
  /// <remarks>
  /// This class is used to facilitate the conversion between the <c>args</c>, <c>response</c> and theirs string equivalent during JSON processing.
  /// It extends the <c>TJSONInterceptorStringToString</c> class to override the necessary methods for custom conversion logic.
  /// </remarks>
  TMetadataInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// When JSON deserialization, converts <c>args</c>, <c>response<c/> values into JSON string to retrieve arguments made by the tool.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be set.
    /// </param>
    /// <param name="Field">
    /// The field name where the <c>input</c> value will be set.
    /// </param>
    /// <param name="Arg">
    /// The string representation of the <c>args</c> or <c>response</c> to be converted back.
    /// </param>
    /// <remarks>
    /// This method converts the string argument back to the corresponding <c>args</c> or <c>response</c> value and assigns it to the specified field in the object.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  {$ENDREGION}

  {$REGION 'MistralAI.Codestral'}

  /// <summary>
  /// Represents the different reasons why the processing of a request can terminate.
  /// </summary>
  TCodestralFinishReason = (
    /// <summary>
    /// API returned complete model output
    /// </summary>
    stop,
    /// <summary>
    /// Incomplete model output due to max_tokens parameter or token limit
    /// </summary>
    length_limite,
    /// <summary>
    /// model_length
    /// </summary>
    model_length,
    /// <summary>
    /// An error was encountered while processing the request
    /// </summary>
    error,
    /// <summary>
    /// A function must be invoked before further processing of the request
    /// </summary>
    tool_calls);

  /// <summary>
  /// Provides helper methods for the TCodestralFinishReason enumeration.
  /// </summary>
  TCodestralFinishReasonHelper = record helper for TCodestralFinishReason
    constructor Create(const Value: string);
    /// <summary>
    /// Returns the string representation of the TCodestralFinishReason value.
    /// </summary>
    function ToString: string;
  end;

  /// <summary>
  /// Interceptor class for converting and reverting TCodestralFinishReason values to and from strings in JSON.
  /// </summary>
  TCodestralFinishReasonInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// Converts a TCodestralFinishReason value to its string representation for JSON serialization.
    /// </summary>
    /// <param name="Data">The object containing the field to be converted.</param>
    /// <param name="Field">The name of the field to be converted.</param>
    /// <returns>The string representation of the TCodestralFinishReason value.</returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Reverts a string representation back to a TCodestralFinishReason value during JSON deserialization.
    /// </summary>
    /// <param name="Data">The object containing the field to be reverted.</param>
    /// <param name="Field">The name of the field to be reverted.</param>
    /// <param name="Arg">
    /// The string representation of the TCodestralFinishReason value.
    ///</param>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  {$ENDREGION}

  {$REGION 'MistralAI.Files'}

  /// <summary>
  /// Specifies the intended purpose of the uploaded file.
  /// </summary>
  /// <remarks>
  /// Enum :
  /// <para>
  /// finetune, batch
  /// </para>
  /// </remarks>
  TFilePurpose = (
    /// <summary>
    /// The file will be used for fine-tuning.
    /// </summary>
    finetune,
    /// <summary>
    /// The file will be used for batch operation
    /// </summary>
    batch,
    /// <summary>
    /// The file will be used for ocr operation
    /// </summary>
    ocr,
    audio,
    image_generation
  );

  /// <summary>
  /// Helper methods for <c>TFilePurpose</c> enumeration.
  /// </summary>
  TFilePurposeHelper = record helper for TFilePurpose
    constructor Create(const Value: string);
    /// <summary>
    /// Converts the <c>TFilePurpose</c> value to its string representation.
    /// </summary>
    /// <returns>
    /// A string representing the <c>TFilePurpose</c> value.
    /// </returns>
    /// <remarks>
    /// For example:
    /// <code>
    /// var
    ///   Purpose: TFilePurpose;
    /// begin
    ///   Purpose := TFilePurpose.finetune;
    ///   ShowMessage(Purpose.ToString); // Outputs 'fine-tune'
    /// end;
    /// </code>
    /// </remarks>
    function ToString: string;
  end;

  /// <summary>
  /// JSON interceptor to convert <c>TFilePurpose</c> to and from its string representation during JSON serialization.
  /// </summary>
  TFilePurposeInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// Converts the <c>TFilePurpose</c> field value to its string representation.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field.
    /// </param>
    /// <param name="Field">
    /// The name of the field to convert.
    /// </param>
    /// <returns>
    /// The string representation of the <c>TFilePurpose</c> value.
    /// </returns>
    /// <remarks>
    /// This method is used internally during JSON serialization.
    /// </remarks>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string to the <c>TFilePurpose</c> field value during JSON deserialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field.
    /// </param>
    /// <param name="Field">
    /// The name of the field to convert.
    /// </param>
    /// <param name="Arg">
    /// The string value to convert to <c>TFilePurpose</c>.
    /// </param>
    /// <remarks>
    /// This method is used internally during JSON deserialization.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Specifies the sample_type of the file.
  /// </summary>
  /// <remarks>
  /// Enum :
  /// <para>
  /// pretrain, instruct, batch_request, batch_result, batch_error
  /// </para>
  /// </remarks>
  TSampleType = (
    pretrain,
    instruct,
    batch_request,
    batch_result,
    batch_error,
    audio_input,
    image_generation,
    ocr_input
  );

  /// <summary>
  /// Helper methods for <c>TSampleType</c> enumeration.
  /// </summary>
  TSampleTypeHelper = record Helper for TSampleType
    constructor Create(const Value: string);
    /// <summary>
    /// Converts the <c>TSampleType</c> value to its string representation.
    /// </summary>
    /// <returns>
    /// A string representing the <c>TSampleType</c> value.
    /// </returns>
    function ToString: string;
  end;

  /// <summary>
  /// JSON interceptor to convert <c>TSampleType</c> to and from its string representation during JSON serialization.
  /// </summary>
  TSampleTypeInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// Converts the <c>TSampleType</c> field value to its string representation.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field.
    /// </param>
    /// <param name="Field">
    /// The name of the field to convert.
    /// </param>
    /// <returns>
    /// The string representation of the <c>TSampleType</c> value.
    /// </returns>
    /// <remarks>
    /// This method is used internally during JSON serialization.
    /// </remarks>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string to the <c>TSampleType</c> field value during JSON deserialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field.
    /// </param>
    /// <param name="Field">
    /// The name of the field to convert.
    /// </param>
    /// <param name="Arg">
    /// The string value to convert to <c>TSampleType</c>.
    /// </param>
    /// <remarks>
    /// This method is used internally during JSON deserialization.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Specifies the source of the file.
  /// </summary>
  /// <remarks>
  /// Enum :
  /// <para>
  /// upload, repository, mistral
  /// </para>
  /// </remarks>
  TSourceType = (
    upload,
    repository,
    mistral
  );

  TSourceTypeHelper = record Helper for TSourceType
    constructor Create(const Value: string);
    /// <summary>
    /// Converts the <c>TSourceType</c> value to its string representation.
    /// </summary>
    /// <returns>
    /// A string representing the <c>TSourceType</c> value.
    /// </returns>
    function ToString: string;
  end;

  /// <summary>
  /// JSON interceptor to convert <c>TSourceType</c> to and from its string representation during JSON serialization.
  /// </summary>
  TSourceTypeInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// Converts the <c>TSourceType</c> field value to its string representation.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field.
    /// </param>
    /// <param name="Field">
    /// The name of the field to convert.
    /// </param>
    /// <returns>
    /// The string representation of the <c>TSourceType</c> value.
    /// </returns>
    /// <remarks>
    /// This method is used internally during JSON serialization.
    /// </remarks>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string to the <c>TSourceType</c> field value during JSON deserialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field.
    /// </param>
    /// <param name="Field">
    /// The name of the field to convert.
    /// </param>
    /// <param name="Arg">
    /// The string value to convert to <c>TSourceType</c>.
    /// </param>
    /// <remarks>
    /// This method is used internally during JSON deserialization.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  {$ENDREGION}

  {$REGION 'MistralAI.Functions.Tools'}

  /// <summary>
  /// Defines the model's function call behavior. This type determines whether the model generates
  /// a response, calls a function, or decides between the two.
  /// </summary>
  TToolChoice = (
    /// <summary>
    /// The model won't call a function and will generate a message instead
    /// </summary>
    none,
    /// <summary>
    /// The model can choose to either generate a message or call a function
    /// </summary>
    auto,
    /// <summary>
    /// The model is forced to call a function
    /// </summary>
    any,
    /// <summary>
    /// The model is required to call a function
    /// </summary>
    required);

  /// <summary>
  /// A helper record for the <c>TToolChoice</c> type, providing additional functionality.
  /// </summary>
  TToolChoiceHelper = record helper for TToolChoice
    constructor Create(const Value: string);
    /// <summary>
    /// Converts the <c>TToolChoice</c> value to its string representation.
    /// </summary>
    /// <returns>A string representing the current <c>TToolChoice</c> value.</returns>
    function ToString: string;
  end;

  {$ENDREGION}

  {$REGION 'MistralAI.Batch'}

  /// <summary>
  /// Represents the different status of a batch.
  /// </summary>
  TBatchStatus = (
    /// <summary>
    /// The batch is waiting to be processed. It is placed on the queue.
    /// </summary>
    Queued,
    /// <summary>
    /// The batch is being processed.
    /// </summary>
    Running,
    /// <summary>
    /// Batch processing completed successfully.
    /// </summary>
    Success,
    /// <summary>
    /// Batch processing failed.
    /// </summary>
    Failed,
    /// <summary>
    /// The execution deadline has been reached.
    /// </summary>
    Timeout_exceeded,
    /// <summary>
    /// A request to abandon batch processing has been submitted.
    /// </summary>
    Cancellation_requested,
    /// <summary>
    /// Batch processing has been aborted.
    /// </summary>
    Cancelled
  );

  /// <summary>
  /// Provides helper methods for the TBatchStatus enumeration.
  /// </summary>
  TBatchStatusHelper = record Helper for TBatchStatus
    constructor Create(const Value: string);
    /// <summary>
    /// Returns the string representation of the TBatchStatus value.
    /// </summary>
    function ToString: string;
  end;

  /// <summary>
  /// Interceptor class for converting and reverting TBatchStatus values to and from strings in JSON.
  /// </summary>
  TBatchStatusInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// Converts a TBatchStatus value to its string representation for JSON serialization.
    /// </summary>
    /// <param name="Data">The object containing the field to be converted.</param>
    /// <param name="Field">The name of the field to be converted.</param>
    /// <returns>The string representation of the TBatchStatus value.</returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Reverts a string representation back to a TBatchStatus value during JSON deserialization.
    /// </summary>
    /// <param name="Data">The object containing the field to be reverted.</param>
    /// <param name="Field">The name of the field to be reverted.</param>
    /// <param name="Arg">
    /// The string representation of the TBatchStatus value.
    ///</param>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Endpoint for batch job.
  /// </summary>
  /// <remarks>
  /// Enum : epChatCompletion, epEmbeddings, epFimCompletions, epModeration
  /// <para>
  /// respectively for :
  /// </para>
  /// <para>
  /// - epChatCompletion : /v1/chat/completions
  /// </para>
  /// <para>
  /// - epEmbeddings : /v1/embeddings
  /// </para>
  /// <para>
  /// - epFimCompletions : /v1/fim/completions
  /// </para>
  /// <para>
  /// - epModeration : /v1/moderations
  /// </para>
  /// </remarks>
  TEndPointType = (
    /// <summary>
    /// /v1/chat/completions
    /// </summary>
    ChatCompletion,
    /// <summary>
    /// /v1/embeddings
    /// </summary>
    Embeddings,
    /// <summary>
    /// /v1/fim/completions
    /// </summary>
    FimCompletions,
    /// <summary>
    /// /v1/moderations
    /// </summary>
    Moderation
  );

  /// <summary>
  /// Provides helper methods for the TEndPointType enumeration.
  /// </summary>
  TEndPointTypeHelper = record Helper for TEndPointType
    constructor Create(const Value: string);
    /// <summary>
    /// Returns the string representation of the TEndPointType value.
    /// </summary>
    /// <remarks>
    /// Enum : epChatCompletion, epEmbeddings, epFimCompletions, epModeration
    /// <para>
    /// respectively for :
    /// </para>
    /// <para>
    /// - epChatCompletion : /v1/chat/completions
    /// </para>
    /// <para>
    /// - epEmbeddings : /v1/embeddings
    /// </para>
    /// <para>
    /// - epFimCompletions : /v1/fim/completions
    /// </para>
    /// <para>
    /// - epModeration : /v1/moderations
    /// </para>
    /// </remarks>
    function ToString: string;
  end;

  /// <summary>
  /// Interceptor class for converting and reverting TEndPointType values to and from strings in JSON.
  /// </summary>
  TEndPointTypeInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// Converts a TEndPointType value to its string representation for JSON serialization.
    /// </summary>
    /// <param name="Data">The object containing the field to be converted.</param>
    /// <param name="Field">The name of the field to be converted.</param>
    /// <returns>The string representation of the TEndPointType value.</returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Reverts a string representation back to a TEndPointType value during JSON deserialization.
    /// </summary>
    /// <param name="Data">The object containing the field to be reverted.</param>
    /// <param name="Field">The name of the field to be reverted.</param>
    /// <param name="Arg">
    /// The string representation of the TEndPointType value.
    ///</param>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  {$ENDREGION}

  {$REGION 'MistralAI.Conversations'}

  THandoffExecutionType = (
    client,
    server
  );

  THandoffExecutionTypeHelper = record Helper for THandoffExecutionType
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TContentChunkType = (
    text,
    image_url,
    tool_file,
    document_url,
    tool_reference,
    thinking
  );

  TContentChunkTypeHelper = record Helper for TContentChunkType
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TContentChunkTypeInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// Converts the <c>TContentChunkType</c> value of the specified field to a string during JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be converted.
    /// </param>
    /// <param name="Field">
    /// The field name representing the <c>TContentChunkType</c> value.
    /// </param>
    /// <returns>
    /// The string representation of the <c>TContentChunkType</c> value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string back to a <c>TContentChunkType</c> value for the specified field during JSON deserialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be set.
    /// </param>
    /// <param name="Field">
    /// The field name where the <c>TContentChunkType</c> value will be set.
    /// </param>
    /// <param name="Arg">
    /// The string representation of the <c>TContentChunkType</c> to be converted back.
    /// </param>
    /// <remarks>
    /// This method converts the string argument back to the corresponding <c>TContentChunkType</c> value and assigns it to the specified field in the object.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  TConversationTool = (
    web_search,
    web_search_premium,
    code_interpreter,
    image_generation,
    document_library
  );

  TConversationToolHelper = record Helper for TConversationTool
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TConversationToolInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// Converts the <c>TConversationTool</c> value of the specified field to a string during JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be converted.
    /// </param>
    /// <param name="Field">
    /// The field name representing the <c>TConversationTool</c> value.
    /// </param>
    /// <returns>
    /// The string representation of the <c>TConversationTool</c> value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string back to a <c>TConversationTool</c> value for the specified field during JSON deserialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be set.
    /// </param>
    /// <param name="Field">
    /// The field name where the <c>TConversationTool</c> value will be set.
    /// </param>
    /// <param name="Arg">
    /// The string representation of the <c>TConversationTool</c> to be converted back.
    /// </param>
    /// <remarks>
    /// This method converts the string argument back to the corresponding <c>TConversationTool</c> value and assigns it to the specified field in the object.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  TChunkEvent = (
    conversation_response_started,
    conversation_response_done,
    conversation_response_error,
    message_output_delta,
    tool_execution_started,
    tool_execution_done,
    agent_handoff_started,
    agent_handoff_done,
    function_call_delta
  );

  TChunkEventHelper = record Helper for TChunkEvent
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TChunkEventInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// Converts the <c>TChunkEvent</c> value of the specified field to a string during JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be converted.
    /// </param>
    /// <param name="Field">
    /// The field name representing the <c>TChunkEvent</c> value.
    /// </param>
    /// <returns>
    /// The string representation of the <c>TChunkEvent</c> value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string back to a <c>TChunkEvent</c> value for the specified field during JSON deserialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be set.
    /// </param>
    /// <param name="Field">
    /// The field name where the <c>TChunkEvent</c> value will be set.
    /// </param>
    /// <param name="Arg">
    /// The string representation of the <c>TChunkEvent</c> to be converted back.
    /// </param>
    /// <remarks>
    /// This method converts the string argument back to the corresponding <c>TChunkEvent</c> value and assigns it to the specified field in the object.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  TConversatonEvent = (
    message_input,
    message_output,
    tool_execution,
    function_call,
    agent_handoff
  );

  TConversatonEventHelper = record Helper for TConversatonEvent
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TConversatonEventInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// Converts the <c>TConversatonEvent</c> value of the specified field to a string during JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be converted.
    /// </param>
    /// <param name="Field">
    /// The field name representing the <c>TConversatonEvent</c> value.
    /// </param>
    /// <returns>
    /// The string representation of the <c>TConversatonEvent</c> value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string back to a <c>TConversatonEvent</c> value for the specified field during JSON deserialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be set.
    /// </param>
    /// <param name="Field">
    /// The field name where the <c>TConversatonEvent</c> value will be set.
    /// </param>
    /// <param name="Arg">
    /// The string representation of the <c>TConversatonEvent</c> to be converted back.
    /// </param>
    /// <remarks>
    /// This method converts the string argument back to the corresponding <c>TConversatonEvent</c> value and assigns it to the specified field in the object.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  {$SCOPEDENUMS OFF}

  TReasoningInstruction = (
    Custom,
    Default
  );

  {$SCOPEDENUMS ON}

  TReasoningInstructionHelper = record Helper for TReasoningInstruction
    function ToString: string;
  end;

  {$ENDREGION}

  {$REGION 'MistralAI.Libraries.Access'}

  TLevelType = (
    viewer,
    editor
  );

  TLevelTypeHelper = record Helper for TLevelType
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TShareWithType = (
    user,
    workspace,
    org
  );

  TShareWithTypeHelper = record Helper for TShareWithType
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TShareWithTypeInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// Converts the <c>TShareWithType</c> value of the specified field to a string during JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be converted.
    /// </param>
    /// <param name="Field">
    /// The field name representing the <c>TShareWithType</c> value.
    /// </param>
    /// <returns>
    /// The string representation of the <c>TShareWithType</c> value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string back to a <c>TShareWithType</c> value for the specified field during JSON deserialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be set.
    /// </param>
    /// <param name="Field">
    /// The field name where the <c>TShareWithType</c> value will be set.
    /// </param>
    /// <param name="Arg">
    /// The string representation of the <c>TShareWithType</c> to be converted back.
    /// </param>
    /// <remarks>
    /// This method converts the string argument back to the corresponding <c>TShareWithType</c> value and assigns it to the specified field in the object.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  {$ENDREGION}

  {$REGION 'MistralAI.Classifiers'}

  resourcestring
    SexualCategory = 'Sexual';
    HateAndDiscriminationCategory = 'Hate and discrimination';
    ViolenceAndThreatsCategory = 'Violence and threats';
    DangerousAndCriminalContentCategory = 'Dangerous and criminal content';
    SelfharmCategory = 'Selfharm';
    HealthCategory = 'Health';
    FinancialCategory = 'Financial';
    LawCategory = 'Law';
    PiiCategory = 'Pii';

  var
    Classifiers: TArray<string> =
      [SexualCategory, HateAndDiscriminationCategory, ViolenceAndThreatsCategory,
       DangerousAndCriminalContentCategory, SelfharmCategory, HealthCategory,
       FinancialCategory, LawCategory, PiiCategory];

  {$ENDREGION}



implementation

uses
  System.StrUtils, Rest.Json, System.Rtti, System.TypInfo, System.Classes;

type
  TEnumValueRecovery = class
    class function TypeRetrieve<T>(const Value: string; const References: TArray<string>): T;
  end;

{ TMessageRoleHelper }

constructor TMessageRoleHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TMessageRole>(Value,
            ['system', 'user', 'assistant', 'tool']);
end;

function TMessageRoleHelper.ToString: string;
begin
  case Self of
    TMessageRole.system:
      Exit('system');
    TMessageRole.user:
      Exit('user');
    TMessageRole.assistant:
      Exit('assistant');
    TMessageRole.tool:
      Exit('tool');
  end;
end;

{ TFinishReasonHelper }

constructor TFinishReasonHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TFinishReason>(Value,
            ['stop', 'length', 'model_length', 'error', 'tool_calls']);
end;

function TFinishReasonHelper.ToString: string;
begin
  case Self of
    TFinishReason.stop:
      Exit('stop');
    TFinishReason.length:
      Exit('length');
    TFinishReason.model_length:
      Exit('model_length');
    TFinishReason.error:
      Exit('error');
    TFinishReason.tool_calls:
      Exit('tool_calls');
  end;
end;

{ TFinishReasonInterceptor }

function TFinishReasonInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TFinishReason>.ToString;
end;

procedure TFinishReasonInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TFinishReason.Create(Arg)));
end;

{ TContentTypeHelper }

constructor TContentTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TContentType>(Value,
            ['text', 'image_url', 'reference', 'document_url', 'input_audio', 'thinking']);
end;

function TContentTypeHelper.ToString: string;
begin
  case Self of
    TContentType.text:
      Exit('text');
    TContentType.image_url:
      Exit('image_url');
    TContentType.reference:
      Exit('reference');
    TContentType.document_url:
      Exit('document_url');
    TContentType.input_audio:
      Exit('input_audio');
    TContentType.thinking:
      Exit('thinking');
  end;
end;

{ TContentTypeInterceptor }

function TContentTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TContentType>.ToString;
end;

procedure TContentTypeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TContentType.Create(Arg)));
end;

{ TToolTypeHelper }

constructor TToolTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TToolType>(Value,
            ['web_search_premium', 'web_search', 'image_generation',
             'function', 'document_library', 'code_interpreter']);
end;

function TToolTypeHelper.ToString: string;
begin
  case Self of
    TToolType.web_search_premium:
      Exit('web_search_premium');
    TToolType.web_search:
      Exit('web_search');
    TToolType.image_generation:
      Exit('image_generation');
    TToolType.function:
      Exit('function');
    TToolType.document_library:
      Exit('document_library');
    TToolType.code_interpreter:
      Exit('code_interpreter');
  end;
end;

{ TFineTuningJobStatusHelper }

constructor TFineTuningJobStatusHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TFineTuningJobStatus>(Value, [
    'queued', 'started', 'validating', 'validated', 'running', 'failed_validation', 'failed',
    'success', 'cancelled', 'cancellation_requested']);
end;

function TFineTuningJobStatusHelper.ToString: string;
begin
  case Self of
    TFineTuningJobStatus.Queued:
      Exit('QUEUED');
    TFineTuningJobStatus.Started:
      Exit('STARTED');
    TFineTuningJobStatus.Validating:
      Exit('VALIDATING');
    TFineTuningJobStatus.Validated:
      Exit('VALIDATED');
    TFineTuningJobStatus.Running:
      Exit('RUNNING');
    TFineTuningJobStatus.Failed_validation:
      Exit('FAILED_VALIDATION');
    TFineTuningJobStatus.Failed:
      Exit('FAILED');
    TFineTuningJobStatus.Success:
      Exit('SUCCESS');
    TFineTuningJobStatus.Cancelled:
      Exit('CANCELLED');
    TFineTuningJobStatus.CancellationRequested:
      Exit('CANCELLATION_REQUESTED');
  end;
end;

{ TFineTuningJobStatusInterceptor }

function TFineTuningJobStatusInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TFineTuningJobStatus>.ToString;
end;

procedure TFineTuningJobStatusInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TFineTuningJobStatus.Create(Arg)));
end;

{ TFineTuningDataObjectKindHelper }

constructor TFineTuningDataObjectKindHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TFineTuningDataObjectKind>(Value,
            ['job']);
end;

function TFineTuningDataObjectKindHelper.ToString: string;
begin
  case Self of
    TFineTuningDataObjectKind.Job:
      Exit('job');
  end;
end;

{ TFineTuningDataObjectKindInterceptor }

function TFineTuningDataObjectKindInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TFineTuningDataObjectKind>.ToString;
end;

procedure TFineTuningDataObjectKindInterceptor.StringReverter(Data: TObject;
  Field, Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TFineTuningDataObjectKind.Create(Arg)));
end;

{ TFineTuningIntegrationTypeHelper }

constructor TFineTuningIntegrationTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TFineTuningIntegrationType>(Value,
            ['wandb']);
end;

function TFineTuningIntegrationTypeHelper.ToString: string;
begin
  case self of
    TFineTuningIntegrationType.Wandb:
      Exit('wandb');
  end;
end;

{ TFineTuningIntegrationTypeInterceptor }

function TFineTuningIntegrationTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TFineTuningIntegrationType>.ToString;
end;

procedure TFineTuningIntegrationTypeInterceptor.StringReverter(Data: TObject;
  Field, Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TFineTuningIntegrationType.Create(Arg)));
end;

{ TFineTuningObjectKindHelper }

constructor TFineTuningObjectKindHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TFineTuningObjectKind>(Value,
            ['list']);
end;

function TFineTuningObjectKindHelper.ToString: string;
begin
  case self of
    TFineTuningObjectKind.List:
      Exit('list');
  end;
end;

{ TFineTuningObjectKindInterceptor }

function TFineTuningObjectKindInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TFineTuningObjectKind>.ToString;
end;

procedure TFineTuningObjectKindInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TFineTuningObjectKind.Create(Arg)));
end;

{ TCodestralFinishReasonHelper }

constructor TCodestralFinishReasonHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TCodestralFinishReason>(Value,
            ['stop', 'length', 'model_length', 'error', 'tool_calls']);
end;

function TCodestralFinishReasonHelper.ToString: string;
begin
  case Self of
    TCodestralFinishReason.stop:
      Exit('stop');
    TCodestralFinishReason.length_limite:
      Exit('length');
    TCodestralFinishReason.model_length:
      Exit('model_length');
    TCodestralFinishReason.error:
      Exit('error');
    TCodestralFinishReason.tool_calls:
      Exit('tool_calls');
  end;
end;

{ TCodestralFinishReasonInterceptor }

function TCodestralFinishReasonInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TCodestralFinishReason>.ToString;
end;

procedure TCodestralFinishReasonInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TCodestralFinishReason.Create(Arg)));
end;

{ TFilePurposeHelper }

constructor TFilePurposeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TFilePurpose>(Value,
            ['fine-tune', 'batch', 'ocr', 'audio', 'image_generation']);
end;

function TFilePurposeHelper.ToString: string;
begin
  case self of
    TFilePurpose.FineTune:
      Exit('fine-tune');
    TFilePurpose.batch:
      Exit('batch');
    TFilePurpose.ocr:
      Exit('ocr');
    TFilePurpose.audio:
      Exit('audio');
    TFilePurpose.image_generation:
      Exit('image_generation');
  end;
end;

{ TFilePurposeInterceptor }

function TFilePurposeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TFilePurpose>.ToString;
end;

procedure TFilePurposeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TFilePurpose.Create(Arg)));
end;

{ TToolChoiceHelper }

constructor TToolChoiceHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TToolChoice>(Value,
            ['auto', 'any', 'required', 'none']);
end;

function TToolChoiceHelper.ToString: string;
begin
  case Self of
    TToolChoice.auto:
      Exit('auto');
    TToolChoice.any:
      Exit('any');
    TToolChoice.required:
      Exit('required');
    TToolChoice.none:
      Exit('none');
  end;
end;

{ TSampleTypeHelper }

constructor TSampleTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TSampleType>(Value,
            ['pretrain', 'instruct', 'batch_request', 'batch_result', 'batch_error',
             'audio_input', 'image_generation', 'ocr_input']);
end;

function TSampleTypeHelper.ToString: string;
begin
  case Self of
    TSampleType.pretrain:
      Exit('pretrain');
    TSampleType.instruct:
      Exit('instruct');
    TSampleType.batch_request:
      Exit('batch_request');
    TSampleType.batch_result:
      Exit('batch_result');
    TSampleType.batch_error:
      Exit('batch_error');
    TSampleType.audio_input:
      Exit('audio_input');
    TSampleType.image_generation:
      Exit('image_generation');
    TSampleType.ocr_input:
      Exit('ocr_input');
  end;
end;

{ TSourceTypeHelper }

constructor TSourceTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TSourceType>(Value,
            ['upload', 'repository', 'mistral']);
end;

function TSourceTypeHelper.ToString: string;
begin
  case Self of
    TSourceType.upload:
      Exit('upload');
    TSourceType.repository:
      Exit('repository');
    TSourceType.mistral:
      Exit('mistral');
  end;
end;

{ TSampleTypeInterceptor }

function TSampleTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TSampleType>.ToString;
end;

procedure TSampleTypeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TSampleType.Create(Arg)));
end;

{ TSourceTypeInterceptor }

function TSourceTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TSourceType>.ToString;
end;

procedure TSourceTypeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TSourceType.Create(Arg)));
end;

{ TRepositoryTypeHelper }

constructor TRepositoryTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TRepositoryType>(Value,
            ['github']);
end;

function TRepositoryTypeHelper.ToString: string;
begin
  case Self of
    TRepositoryType.github:
      Exit('github');
  end;
end;

{ TRepositoryTypeInterceptor }

function TRepositoryTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TRepositoryType>.ToString;
end;

procedure TRepositoryTypeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TRepositoryType.Create(Arg)));
end;

{ TBatchStatusHelper }

constructor TBatchStatusHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TBatchStatus>(Value,
            ['queued', 'running', 'success', 'failed', 'timeout_exceeded',
             'cancellation_requested', 'cancelled']);
end;

function TBatchStatusHelper.ToString: string;
begin
  case Self of
    TBatchStatus.Queued:
      Exit('QUEUED');
    TBatchStatus.Running:
      Exit('RUNNING');
    TBatchStatus.Success:
      Exit('SUCCESS');
    TBatchStatus.Failed:
      Exit('FAILED');
    TBatchStatus.Timeout_exceeded:
      Exit('TIMEOUT_EXCEEDED');
    TBatchStatus.Cancellation_requested:
      Exit('CANCELLATION_REQUESTED');
    TBatchStatus.Cancelled:
      Exit('CANCELLED');
  end;
end;

{ TBatchStatusInterceptor }

function TBatchStatusInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TBatchStatus>.ToString;
end;

procedure TBatchStatusInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TBatchStatus.Create(Arg)));
end;

{ TEndPointTypeHelper }

constructor TEndPointTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TEndPointType>(Value,
            ['/v1/chat/completions', '/v1/embeddings', '/v1/fim/completions', '/v1/moderations']);
end;

function TEndPointTypeHelper.ToString: string;
begin
  case Self of
    TEndPointType.ChatCompletion:
      Exit('/v1/chat/completions');
    TEndPointType.Embeddings:
      Exit('/v1/embeddings');
    TEndPointType.FimCompletions:
      Exit('/v1/fim/completions');
    TEndPointType.Moderation:
      Exit('/v1/moderations');
  end;
end;

{ TEndPointTypeInterceptor }

function TEndPointTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TEndPointType>.ToString;
end;

procedure TEndPointTypeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TEndPointType.Create(Arg)));
end;

{ TMetadataInterceptor }

procedure TMetadataInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  Arg := Format('{%s}', [Trim(Arg.Replace('`', '"').Replace(#10, ''))]);
  while Arg.Contains(', ') do Arg := Arg.Replace(', ', ',');
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, Arg.Replace(',', ', '));
end;

{ TEnumValueRecovery }

class function TEnumValueRecovery.TypeRetrieve<T>(const Value: string;
  const References: TArray<string>): T;
var
  pInfo: PTypeInfo;
begin
  pInfo := TypeInfo(T);
  if pInfo.Kind <> tkEnumeration then
    raise Exception.Create('TRecovery.TypeRetrieve<T>: T is not an enumerated type');

  var index := IndexStr(Value.ToLower, References);
  if index = -1 then
    raise Exception.CreateFmt('%s : Unable to retrieve enum value.', [Value]);

  Move(index, Result, SizeOf(Result));
end;

{ THandoffExecutionTypeHelper }

constructor THandoffExecutionTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<THandoffExecutionType>(Value,
            ['client', 'server']);
end;

function THandoffExecutionTypeHelper.ToString: string;
begin
  case Self of
    THandoffExecutionType.client:
      Exit('client');
    THandoffExecutionType.server:
      Exit('server');
  end;
end;

{ TResponseFormatTypeHelper }

constructor TResponseFormatTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TResponseFormatType>(Value,
            ['text', 'json_object', 'json_schema']);
end;

function TResponseFormatTypeHelper.ToString: string;
begin
  case Self of
    TResponseFormatType.text:
      Exit('text');
    TResponseFormatType.json_object:
      Exit('json_object');
    TResponseFormatType.json_schema:
      Exit('json_schema');
  end;
end;

{ TMessageRoleInterceptor }

function TMessageRoleInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TMessageRole>.ToString;
end;

procedure TMessageRoleInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TMessageRole.Create(Arg)));
end;

{ TContentChunkTypeHelper }

constructor TContentChunkTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TContentChunkType>(Value,
            ['text', 'image_url', 'tool_file', 'document_url', 'tool_reference', 'thinking']);
end;

function TContentChunkTypeHelper.ToString: string;
begin
  case self of
    TContentChunkType.text:
      Exit('text');
    TContentChunkType.image_url:
      Exit('image_url');
    TContentChunkType.tool_file:
      Exit('tool_file');
    TContentChunkType.document_url:
      Exit('document_url');
    TContentChunkType.tool_reference:
      Exit('tool_reference');
    TContentChunkType.thinking:
      Exit('thinking');
  end;
end;

{ TContentChunkTypeInterceptor }

function TContentChunkTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TContentChunkType>.ToString;
end;

procedure TContentChunkTypeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TContentChunkType.Create(Arg)));
end;

{ TConversationToolHelper }

constructor TConversationToolHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TConversationTool>(Value,
            ['web_search', 'web_search_premium', 'code_interpreter',
             'image_generation', 'document_library']);
end;

function TConversationToolHelper.ToString: string;
begin
  case self of
    TConversationTool.web_search:
      Exit('web_search');
    TConversationTool.web_search_premium:
      Exit('web_search_premium');
    TConversationTool.code_interpreter:
      Exit('code_interpreter');
    TConversationTool.image_generation:
      Exit('image_generation');
    TConversationTool.document_library:
      Exit('document_library');
  end;
end;

{ TConversationToolInterceptor }

function TConversationToolInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TConversationTool>.ToString;
end;

procedure TConversationToolInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TConversationTool.Create(Arg)));
end;

{ TChunkEventHelper }

constructor TChunkEventHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TChunkEvent>(Value,
            ['conversation.response.started', 'conversation.response.done',
             'conversation.response.error', 'message.output.delta',
             'tool.execution.started', 'tool.execution.done',
             'agent.handoff.started', 'agent.handoff.done',
             'function.call.delta']);
end;

function TChunkEventHelper.ToString: string;
begin
  case self of
    TChunkEvent.conversation_response_started:
      Exit('conversation.response.started');
    TChunkEvent.conversation_response_done:
      Exit('conversation.response.done');
    TChunkEvent.conversation_response_error:
      Exit('conversation.response.error');
    TChunkEvent.message_output_delta:
      Exit('message.output.delta');
    TChunkEvent.tool_execution_started:
      Exit('tool.execution.started');
    TChunkEvent.tool_execution_done:
      Exit('tool.execution.done');
    TChunkEvent.agent_handoff_started:
      Exit('agent.handoff.started');
    TChunkEvent.agent_handoff_done:
      Exit('agent.handoff.done');
    TChunkEvent.function_call_delta:
      Exit('function.call.delta');
  end;
end;

{ TChunkEventInterceptor }

function TChunkEventInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TChunkEvent>.ToString;
end;

procedure TChunkEventInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TChunkEvent.Create(Arg)));
end;

{ TReasoningInstructionHelper }

function TReasoningInstructionHelper.ToString: string;
begin
  case Self of
    Custom:
      Exit('custom');
    Default:
      Exit(ReasoningEnglishInstructions);
  end;
end;

{ TLevelTypeHelper }

constructor TLevelTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TLevelType>(Value,
            ['viewer', 'editor']);
end;

function TLevelTypeHelper.ToString: string;
begin
  case Self of
    TLevelType.viewer:
      Exit('Viewer');
    TLevelType.editor:
      Exit('Editor');
  end;
end;

{ TShareWithTypeHelper }

constructor TShareWithTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TShareWithType>(Value,
            ['user', 'workspace', 'org']);
end;

function TShareWithTypeHelper.ToString: string;
begin
  case Self of
    TShareWithType.user:
      Exit('User');
    TShareWithType.workspace:
      Exit('Workspace');
    TShareWithType.org:
      Exit('Org');
  end;
end;

{ TShareWithTypeInterceptor }

function TShareWithTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TShareWithType>.ToString;
end;

procedure TShareWithTypeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TShareWithType.Create(Arg)));
end;

{ TConversatonEventHelper }

constructor TConversatonEventHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TConversatonEvent>(Value,
            ['message.input', 'message.output', 'tool.execution', 'function.call', 'agent.handoff']);
end;

function TConversatonEventHelper.ToString: string;
begin
  case Self of
    TConversatonEvent.message_input:
      Exit('message.input');
    TConversatonEvent.message_output:
      Exit('message.output');
    TConversatonEvent.tool_execution:
      Exit('tool.execution');
    TConversatonEvent.function_call:
      Exit('function.call');
    TConversatonEvent.agent_handoff:
      Exit('agent.handoff');
  end;
end;

{ TConversatonEventInterceptor }

function TConversatonEventInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TConversatonEvent>.ToString;
end;

procedure TConversatonEventInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TConversatonEvent.Create(Arg)));
end;

end.


# Partie 2: Documentation dans le dossier "guides" du repository

 # Agents completions (v1/agents/completions)

- [Introduction](#introduction)
- [Agent creation](#agent-Creation)
- [Agent using](#agent-using)

<br>

___

## Introduction

Think of an **AI agent** as an autonomous executor driven by an LLM: you give it a high-level intent, and it orchestrates the necessary steps, selecting and using tools, processing data, and making decisions, to fulfill that intent. Its language comprehension lets it navigate ambiguity and complexity, while multi-agent coordination allows several such executors to collaborate, sequence work, and tackle sophisticated workflows that exceed the scope of any single actor.

<br>

___

## Agent creation

There is no API to create a new agent directly; creation must be done through the platform’s UI at the [designated location](https://console.mistral.ai/build/agents). 

>[!NOTE]
>Agents created this way can be shared in “The Chat.”

<br>

___

## Agent using

The agent’s identifier, available on the platform, is required to initiate its execution.

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

  var Agent_id := 'id'; //e.g. ag:cd365907:20450201:untitled-agent:2be7ed6c

  //Asynchronous promise example
  var Promise := Client.Agent.AsyncAwaitCreateStream(
    procedure (Params: TAgentParams)
    begin
      Params.Messages([
        Payload.User('What is the joual?')
        ]);
      Params.ResponseFormat('text');
      Params.AgentId(Agent_id);
      Params.Stream;
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TPromiseChatStream
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;

      Result.OnProgress :=
        procedure (Sender: TObject; Chunk: TChat)
        begin
          DisplayStream(Sender, Chunk);
        end;

      Result.OnDoCancel := DoCancellation;

      Result.OnCancellation :=
        function (Sender: TObject): string
        begin
          Cancellation(Sender);
        end
    end);

  Promise
    .&Then<string>(
      function (Value: string): string
      begin
        Result := Value;
        ShowMessage(Result);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Agent.AsyncCreateStream(
//    procedure (Params: TAgentParams)
//    begin
//      Params.MaxTokens(1024);
//      Params.Messages([
//        Payload.User('What is the joual?')
//        ]);
//      Params.ResponseFormat('text');
//      Params.AgentId(Agent_id);
//      Params.Stream;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    function : TAsynChatStream
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnProgress := DisplayStream;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var WeatherFunc: IFunctionCore := TWeatherReportFunction.Create;
//  var Agent := Client.Agent.Create(
//    procedure (Params: TAgentParams)
//    begin
//      Params.MaxTokens(1024);
//      Params.Messages([
//        Payload.User('What is the joual?')
//        ]);
//      Params.AgentId(Agent_id);
//    end);
//  try
//    Display(TutorialHub, Agent);
//  finally
//    Agent.Free;
//  end;
```

# Agents & connectors (v1/agents)

- [Introduction](#introduction)
- [Agent creation](#agent-creation)
- [Agent listing](#agent-listing)
- [Get agent](#get-agent)
- [Agent update](#agent-update)
- [Agent version update](#agent-version-update)
- [Connectors](#connectors)
    - [Reasoning](#reasoning)
    - [Web search](#web-search)
    - [Image generation](#image-generation)
    - [Document library](#document-library)
    - [Code interpreter](#code-interpreter)

<br>

___

## Introduction

The API revolves around three primary entities:

- Agent: A predefined configuration that enhances a model’s capabilities—combining tools, instructions, and completion settings to steer behavior.

- Conversation: The stored sequence of interactions, including messages, tool invocations, and other events. Conversations can be initiated either by an Agent or directly by a model.

- Entry: A discrete action produced by a user or assistant. Entries offer a richer, more granular way to represent and control the flow of multi-party interactions and events within a conversation.

Importantly, you don’t need to create an Agent to take advantage of the platform’s functionality. You can interact with the API directly, using built-in conversation features and connectors without wrapping them in an Agent.

For the full specification and all details, consult the [Agents and Conversations](https://docs.mistral.ai/agents/agents_basics/) and [API documentation](https://docs.mistral.ai/api/#tag/beta.agents).

<br>

___

## Agent creation

When you set up a new Agent, you’ll need to configure several key properties up front:

- **model:** Specifies which chat‑completion model the agent will use.
- **description:** A brief summary of the agent’s purpose or the use case it’s intended to handle.
- **name:** The identifier you give your agent.
- **instructions (optional):** The core guidelines or “system” prompt that define the agent’s primary task.
- **tools (optional):** An array of helper utilities the agent can invoke. Available tool types include:
- **function:** Your own custom functions, used much like the standard function‑calling feature in chat completion.
- **web_search / web_search_premium:** Built‑in web‑search capabilities (standard or premium).
- **code_interpreter:** The native code‑execution environment.
- **image_generation:** The integrated image‑creation engine.
- **document_library:** The RAG‑style tool for grounding responses on your own document set.
- **completion_args (optional):** Any standard sampler parameters for chat completions—essentially the same settings you’d pass when making a standalone chat‑completion call.

<br>

___

Create a new agent giving it instructions, tools, description. The agent is then available to be used as a regular assistant in a conversation or as part of an agent pool from which it can be used.

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

  //Asynchronous promise example
  var Promise := Client.ConversationsAgent.AsyncAwaitCreate(
    procedure (Params: TConversationsAgentParams)
    begin
      Params.Model('mistral-medium-2505');
      Params.Name('just an agent');
      Params.Description('Agent reduced to its simplest form.');
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  Promise
    .&Then<TConversationsAgent>(
      function (Value: TConversationsAgent): TConversationsAgent
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.ConversationsAgent.AsyncCreate(
//    procedure (Params: TConversationsAgentParams)
//    begin
//      Params.Model('mistral-medium-2505');
//      Params.Name('just an agent');
//      Params.Description('Agent reduced to its simplest form.');
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    function : TAsyncConversationsAgent
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.ConversationsAgent.Create(
//    procedure (Params: TConversationsAgentParams)
//    begin
//      Params.Model('mistral-medium-2505');
//      Params.Name('just an agent');
//      Params.Description('Agent reduced to its simplest form.');
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

## Agent listing

Retrieve a list of agent entities sorted by creation time.

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

  //Asynchronous promise example
  var Promise := Client.ConversationsAgent.AsyncAwaitList(
    procedure (Params: TConversationsListParams)
    begin
      Params.Page(0);
      Params.PageSize(100);
    end);

  Promise
    .&Then<TConversationsAgentList>(
      function (Value: TConversationsAgentList): TConversationsAgentList
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.ConversationsAgent.AsyncList(
//    procedure (Params: TConversationsListParams)
//    begin
//      Params.Page(0);
//      Params.PageSize(100);
//    end,
//    function : TAsyncConversationsAgentList
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.ConversationsAgent.List(
//    procedure (Params: TConversationsListParams)
//    begin
//      Params.Page(0);
//      Params.PageSize(100);
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

## Get agent

Given an agent retrieve an agent entity with its attributes.

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

  var Agent_id := 'agent_id'; //e.g. 'ag_01985efe4b657539a2d6380dad6c3c38';

  //Asynchronous promise example
  var Promise := Client.ConversationsAgent.AsyncAwaitRetrieve(Agent_id);

  Promise
    .&Then<TConversationsAgent>(
      function (Value: TConversationsAgent): TConversationsAgent
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.ConversationsAgent.AsyncRetrieve(Agent_id,
//    function : TAsyncConversationsAgent
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.ConversationsAgent.Retrieve(Agent_id);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

## Agent update

Update an agent attributes and create a new version.

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

  var Agent_id := 'agent_id'; //e.g. 'ag_01985efe4b657539a2d6380dad6c3c38';

  //Asynchronous promise example
  var Promise := Client.ConversationsAgent.AsyncAwaitUpdate(Agent_id,
    procedure (Params: TConversationsAgentParams)
    begin
      Params.Model('magistral-medium-2506');
    end);

  Promise
    .&Then<TConversationsAgent>(
      function (Value: TConversationsAgent): TConversationsAgent
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.ConversationsAgent.AsyncUpdate(Agent_id,
//    procedure (Params: TConversationsAgentParams)
//    begin
//      Params.Model('mistral-large-latest');
//    end,
//    function : TAsyncConversationsAgent
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.ConversationsAgent.Update(Agent_id,
//    procedure (Params: TConversationsAgentParams)
//    begin
//      Params.Model('magistral-medium-2506');
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

## Agent version update

Switch the version of an agent.

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

  var Agent_id := 'agent_id'; //e.g. 'ag_01985efe4b657539a2d6380dad6c3c38';

  //Asynchronous promise example
  var Promise := Client.ConversationsAgent.AsyncAwaitVersionSwitch(Agent_id,
    procedure (Params: TAgentVersionParams)
    begin
      Params.Version(4);
    end);

  Promise
    .&Then<TConversationsAgent>(
      function (Value: TConversationsAgent): TConversationsAgent
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.ConversationsAgent.AsyncVersionSwitch(Agent_id,
//    procedure (Params: TAgentVersionParams)
//    begin
//      Params.Version(3);
//    end,
//    function : TAsyncConversationsAgent
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.ConversationsAgent.VersionSwitch(Agent_id,
//    procedure (Params: TAgentVersionParams)
//    begin
//      Params.Version(1);
//    end);
//  try
//    Display(TutorialHub, Value.Name);
//  finally
//    Value.Free;
//  end;
```

<br>

___

## Connectors

Only code snippets for the asynchronous approach (returning a Promise) are included. Templates for synchronous implementations and straightforward asynchronous cases have already been provided; adapting them takes only seconds and is left to the reader.

- [Reasoning](#reasoning)
- [Web search](#web-search)
- [Image generation](#image-generation)
- [Document library](#document-library)
- [Code interpreter](#code-interpreter)

<br>

___

### Reasoning

#### Agent creation

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

  //Asynchronous promise example
  var Promise := Client.ConversationsAgent.AsyncAwaitCreate(
    procedure (Params: TConversationsAgentParams)
    begin
      Params.Model('magistral-medium-2506');
      Params.Name('Web Search Agent');
      Params.Description('Agent able to reasoning');
      Params.Instructions; //use the string `ReasoningEnglishInstructions` defined in the MistralAI.Types unit.
      Params.Tools([web_search]);
      Params.CompletionArgs(
        TCompletionArgsParams.Create
          .Temperature(0.3)
          .TopP(0.95)
        );
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  Promise
    .&Then<TConversationsAgent>(
      function (Value: TConversationsAgent): TConversationsAgent
      begin
        Result := Value;
        Display(TutorialHub, 'Agent created');
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);
```

<br>

___

#### Using the agent

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

  var Agent_id := 'id_value';  //e.g. ag_01985efe4b657539a2d6380dad6c5c66

  //Asynchronous promise example
  var Promise := Client.Conversations.AsyncAwaitCreateStream(
    procedure (Params: TConversationsParams)
    begin
      Params.Inputs('John is one of 4 children. The first sister is 4 years old. Next year, the second sister will be twice as old as the first sister. The third sister is two years older than the second sister. The third sister is half the age of her older brother. How old is John?');
      Params.Stream;
      Params.AgentId(Agent_id);
      Params.Store(False);
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TPromiseConversationsEvent
    begin
      Result.Sender := TutorialHub;
      Result.OnProgress :=
        procedure (Sender: TObject; Event: TConversationsEvent)
        begin
          DisplayStream(Sender, Event);
        end;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation :=
        function (Sender: TObject): string
        begin
          Cancellation(Sender);
        end;
    end);

  Promise
    .&Then<string>(
      function (Value: string): string
      begin
        Result := Value;
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);  
```

<br>

___

### Web search

#### Agent creation

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;
  
  TutorialHub.JSONRequestClear;

  //Asynchronous promise example
  var Promise := Client.ConversationsAgent.AsyncAwaitCreate(
    procedure (Params: TConversationsAgentParams)
    begin
      Params.Model('mistral-medium-2505');
      Params.Name('Websearch Agent');
      Params.Description('Agent able to search information over the web, such as news, weather, sport results...');
      Params.Instructions('You have the ability to perform web searches with `web_search` to find up-to-date information.');
      Params.Tools([web_search]); // or Params.Tools([web_search_premium]);
      Params.CompletionArgs(
        TCompletionArgsParams.Create
          .Temperature(0.3)
          .TopP(0.95)
        );
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  Promise
    .&Then<TConversationsAgent>(
      function (Value: TConversationsAgent): TConversationsAgent
      begin
        Result := Value;
        Display(TutorialHub, 'Agent created');
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);
```

<br>

___

#### Using the agent

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

  var Agent_id := 'id_value';  //e.g. ag_01985efe4b657539a2d6380dad6c5c66

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.Conversations.AsyncAwaitCreate(
    procedure (Params: TConversationsParams)
    begin
      Params
        .Inputs('Donne-moi les nouvelles du jour pour la France.')
        .AgentId(Agent_id)
        .Store(False);
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  Promise
    .&Then<TConversation>(
      function (Value: TConversation): TConversation
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);
end;
```

<br>

___

### Image generation

#### Agent creation

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

  //Asynchronous promise example
  var Promise := Client.ConversationsAgent.AsyncAwaitCreate(
    procedure (Params: TConversationsAgentParams)
    begin
      Params.Model('mistral-medium-2505');
      Params.Name('Image generation Agent');
      Params.Description('Agent used to generate images.');
      Params.Instructions('Use the image generation tool when you have to create images.');
      Params.Tools([image_generation]);
      Params.CompletionArgs(
        TCompletionArgsParams.Create
          .Temperature(0.3)
          .TopP(0.95)
        );
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  Promise
    .&Then<TConversationsAgent>(
      function (Value: TConversationsAgent): TConversationsAgent
      begin
        Result := Value;
        Display(TutorialHub, 'Agent created');
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);
```

<br>

___

#### Using the agent

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

  var Agent_id := 'id_value';  //e.g. ag_01985efe4b657539a2d6380dad6c5c66

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.Conversations.AsyncAwaitCreate(
    procedure (Params: TConversationsParams)
    begin
      Params
        .Inputs('Generate an image of a neutron star interacting directly with a black hole')
        .AgentId(Agent_id)
        .Store(False);
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  Promise
    .&Then<TConversation>(
      function (Value: TConversation): TConversation
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);
```

<br>

___

### Document library

#### Agent creation

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  //Asynchronous promise example
  var Promise := Client.ConversationsAgent.AsyncAwaitCreate(
    procedure (Params: TConversationsAgentParams)
    begin
      Params.Model('mistral-medium-2505');
      Params.Name('Library Agent');
      Params.Instructions('You have the ability to perform searches with `document_library` to find relevant information.');
      Params.Description('Agent able to search information in your library to answer all questions regarding the Raoul project');
      Params.Tools([document_library([library_id])]); //e.g. library_id = '0198502a-6f55-578e-9976-570167da0f14'
      Params.CompletionArgs(
        TCompletionArgsParams.Create
          .Temperature(0.3)
          .TopP(0.95)
        );
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  Promise
    .&Then<TConversationsAgent>(
      function (Value: TConversationsAgent): TConversationsAgent
      begin
        Result := Value;
        Display(TutorialHub, 'Agent created');
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);
```

<br>

___

#### Using the agent

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

    TutorialHub.JSONRequestClear;

  var Agent_id := 'id_value';  //e.g. ag_01985efe4b657539a2d6380dad6c5c66

  //Asynchronous promise example
  var Promise := Client.Conversations.AsyncAwaitCreateStream(
     procedure (Params: TConversationsParams)
    begin
      Params
        .Inputs(Memo2.Text)
        .AgentId(Agent_id)
        .Stream
        .Store;
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TPromiseConversationsEvent
    begin
      Result.Sender := TutorialHub;
      Result.OnProgress :=
        procedure (Sender: TObject; Event: TConversationsEvent)
        begin
          if Event.&Type = TChunkEvent.conversation_response_started then
            ConvId := Event.ConversationId;
          DisplayStream(Sender, Event);
        end;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation :=
        function (Sender: TObject): string
        begin
          Cancellation(Sender);
        end;
    end);

  Promise
    .&Then<string>(
      function (Value: string): string
      begin
        Result := Value;
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);
```

<br>

___

### Code interpreter

#### Agent creation

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  //Asynchronous promise example
  var Promise := Client.ConversationsAgent.AsyncAwaitCreate(
    procedure (Params: TConversationsAgentParams)
    begin
      Params.Model('mistral-medium-2505');
      Params.Name('Coding Agent');
      Params.Description('Agent used to execute code using the interpreter tool.');
      Params.Instructions('Use the code interpreter tool when you have to run code.');
      Params.Tools([code_interpreter]);
      Params.CompletionArgs(
        TCompletionArgsParams.Create
          .Temperature(0.3)
          .TopP(0.95)
        );
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  Promise
    .&Then<TConversationsAgent>(
      function (Value: TConversationsAgent): TConversationsAgent
      begin
        Result := Value;
        Display(TutorialHub, 'Agent created');
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);
```

<br>

___

#### Using the agent

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

  var Agent_id := 'id_value';  //e.g. ag_01985efe4b657539a2d6380dad6c5c66

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.Conversations.AsyncAwaitCreate(
    procedure (Params: TConversationsParams)
    begin
      Params
        .Inputs('Run a fibonacci function for the first 20 values.')
        .AgentId(Agent_id)
        .Store;
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  Promise
    .&Then<TConversation>(
      function (Value: TConversation): TConversation
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);
```

# Audio

- [Introduction](#introduction)
- [Transcription](#transcription)
- [Chat with Audio](#chat-with-audio)

<br>

___

## Introduction

These APIs expose two core audio capabilities: **multimodal conversation** (chat with audio) and **optimized transcription**.

### 1. Audio chat:

You can send an audio file—either embedded directly or referenced via a URL (***local, remote, or through a signed upload URL***)—and the model will respond as in a normal conversation. The audio is treated as input just like text: it’s analyzed, meaning is extracted, and you can ask follow-ups such as “what’s in this file?” or continue an interaction. There are two model variants depending on latency/quality needs (`Voxtral Small` and `Voxtral Mini`), with a practical upper bound of roughly 20 minutes per recording in this mode.

### 2. Transcription:

A dedicated endpoint converts audio into text, with automatic language detection or the option to specify the language if known to improve accuracy. It also supports temporal granularity (e.g., segmentation) so you can know not just what was said but when. Audio can be provided directly, via a public URL, or by uploading first and using a signed URL. The transcription-optimized model has a slightly tighter practical limit (≈15 minutes) and returns structured text, optionally with time markers per segment.

### 3. File handling:

To avoid embedding large binaries directly (like base64), you can upload audio files to the service, retrieve a temporary signed URL, and then reuse that URL for chat or transcription calls. This cleanly separates transport of the raw audio from the business logic.

### 4. Fine-grained options:

- ***Language:*** auto-detected or manually specified when known.

- ***Timestamps:*** useful for post-processing, alignment, or slicing based on when content was spoken.

- ***Segmentation:*** receive the transcript broken into segments with start/end times—valuable for navigation or indexing.

### 5. Constraints and best practices:

- Max duration per call varies by mode: about 20 minutes for audio chat, 15 minutes for transcription.

- For longer recordings, split into chunks—being mindful of potential context loss and the need to stitch transcripts together cleanly.

- Another lever is adjusting playback speed to feed audio faster, which requires recalibrating timestamps if the speed was modified.

### 6. Typical use cases:

- Extracting and summarizing meetings or interviews.

- Conversational interfaces driven by speech instead of typing.

- Indexed search within recordings using time anchors.

- Audio+NLP pipelines (language detection, segmentation, automated note-taking, triggerable actions).

<br>

___

## Transcription

The Transcription API converts audio into time-aligned text with automatic language detection. It hides all input mechanics: whether the audio comes as base64, a public URL, or a signed URL from an upload, the wrapper detects and normalizes it transparently—just supply your audio source and get back a structured transcript with optional timestamps. Designed for short-to-medium recordings (≈15 minutes per request), it’s a low-friction building block for meeting notes, searchable audio archives, voice-driven interfaces, and downstream NLP.

Refer to [official documentation](https://docs.mistral.ai/capabilities/audio/)

### Exemple

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;
  
  TutorialHub.JSONRequestClear;
  var SignedUrl := 'https://signed_url';
  var Url := 'https://docs.mistral.ai/audio/obama.mp3';
  var FilePath := 'C:\my_path\my_audio_file.mp3';

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.Audio.AsyncAwaitTranscription(
    procedure (Params: TAudioTranscriptionParams)
    begin
      Params.Model('voxtral-mini-latest');
      Params.FileUrl(SignedUrl);  //or Params.FileUrl(Url); or Params.FileUrl(FilePath);
      Params.Language('fr');
      TutorialHub.JSONRequest := 'multipart';
    end);

  promise
    .&Then<TAudioTranscription>(
      function (Value: TAudioTranscription): TAudioTranscription
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Audio.AsyncTranscription(
//    procedure (Params: TAudioTranscriptionParams)
//    begin
//      Params.Model('voxtral-mini-latest');
//      Params.FileUrl(SignedUrl); //or Params.FileUrl(Url); or Params.FileUrl(FilePath);
//      Params.Language('fr');
//      TutorialHub.JSONRequest := 'multipart';
//    end,
//    function : TAsyncAudioTranscription
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.Audio.Transcription(
//    procedure (Params: TAudioTranscriptionParams)
//    begin
//      Params.Model('voxtral-mini-latest');
//      Params.FileUrl(SignedUrl); //or Params.FileUrl(Url); or Params.FileUrl(FilePath);
//      Params.Language('fr');
//      TutorialHub.JSONRequest := 'multipart';
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

## Chat with Audio

Refer to Input [Audio for Chat](https://github.com/MaxiDonkey/DelphiMistralAI/blob/main/guides/ChatCompletion.md#input-audio-for-chat) section.

# Batch Inference (v1/batch/jobs)

- [Introduction](#introduction)
- [List of batch](#list-of-batch)
- [Batch job creation](#batch-job-creation)
- [Batch job cancellation](#batch-job-cancellation)
- [Batch job retrieve](#batch-job-retrieve)
- [Batch job result file](#batchjob-result-file)

<br>

___

## Introduction

The batch processing feature allows sending a large number of requests simultaneously to various endpoints (chat, embeddings, moderations, etc.). Each batch contains uniquely identified requests and is processed asynchronously. This enables tracking the progress of the processing, accessing results once completed, and handling potential timeouts.

Requests can be customized using metadata, and it is possible to view or cancel ongoing processes. Final results are available as downloadable files and remain accessible afterward.

This approach provides more efficient management of high volumes of requests without imposing a strict limit on the number of batches, while adhering to an overall limit on pending requests. It is particularly useful for automating and consolidating processing, especially in cases of large-scale or repetitive requests.

Refer to the [official documentation](https://docs.mistral.ai/capabilities/batch/).

<br>

___

## List of batch

The list of batch processes can be retrieved using the following API. The pagination mechanism described for the [file list](https://github.com/MaxiDonkey/DelphiMistralAI/blob/main/guides/Files.md#list-of-files) can also be used.

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.Batch.AsyncAwaitList(
    procedure (Params: TBatchJobListParams)
    begin
      Params.PageSize(100);
    end);

  promise
    .&Then<TBatchJobList>(
      function (Value: TBatchJobList): TBatchJobList
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Batch.ASyncList(
//    procedure (Params: TBatchJobListParams)
//    begin
//      Params.PageSize(100);
//    end,
//    function : TAsynBatchJobList
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var List := Client.Batch.List(
//    procedure (Params: TBatchJobListParams)
//    begin
//      Params.PageSize(100);
//    end);
//  try
//    Display(TutorialHub, List);
//  finally
//    List.Free;
//  end;
```

<br>

___

## Batch job creation

We take the batch given in the example on the official site

Here's an example of how to structure a batch request:

```Json
{"custom_id": "0", "body": {"max_tokens": 100, "messages": [{"role": "user", "content": "What is the best French cheese?"}]}}
{"custom_id": "1", "body": {"max_tokens": 100, "messages": [{"role": "user", "content": "What is the best French wine?"}]}}
```

<br/>

1. Save this text in a file and name it as you prefer.
2. Next, upload the file using the code provided in the [File Upload section](https://github.com/MaxiDonkey/DelphiMistralAI/blob/main/guides/Files.md#file-upload).
3. Be sure to set the value of Purpose to batch.
4. Note the file ID after it has been uploaded, as this `ID` will be required when creating the batch processing job.

<br/>

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

  //Asynchronous promise example
  Display(TutorialHub, 'This may take a few seconds.');
  var Promise := Client.Batch.AsyncAwaitCreateJob(
    procedure (Params: TBatchJobParams)
    begin
      Params.InputFiles(['229744f2-67fd-422a-bd32-4c6ab5ea3c44']);
      Params.Model('mistral-large-latest');
      Params.Endpoint(TEndPointType.ChatCompletion);
      Params.Metadata(TJSONObject.Create.AddPair('job_type', 'texting'));
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  promise
    .&Then<TBatchJob>(
      function (Value: TBatchJob): TBatchJob
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Batch.ASyncCreateJob(
//    procedure (Params: TBatchJobParams)
//    begin
//      Params.InputFiles(['229744f2-67fd-422a-bd32-4c6ab5ea3c44']);
//      Params.Model('mistral-large-latest');
//      Params.Endpoint(TEndPointType.ChatCompletion);
//      Params.Metadata(TJSONObject.Create.AddPair('job_type', 'texting'));
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    function : TAsynBatchJob
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.Batch.CreateJob(
//    procedure (Params: TBatchJobParams)
//    begin
//      Params.InputFiles(['229744f2-67fd-422a-bd32-4c6ab5ea3c44']);
//      Params.Model('mistral-large-latest');
//      Params.Endpoint(TEndPointType.epChatCompletion);
//      Params.Metadata(TJSONObject.Create.AddPair('job_type', 'texting'));
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

>[!NOTE]
> Note: The following metadata was specified during creation as a label: 
>```Json
> {"job_type": "texting"}
>```


<br>

___

## Batch job cancellation

A job can be interrupted as long as it is still being processed. To perform this action, ensure that you have obtained the job ID beforehand, then use the following code:

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  TutorialHub.BatchId := 'batch_id'; //e.g. 982d2bbc-adbb-4c6e-b072-5aec973b4c86

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.Batch.AsyncAwaitCancel(TutorialHub.BatchId);

  promise
    .&Then<TBatchJob>(
      function (Value: TBatchJob): TBatchJob
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Batch.ASyncCancel(TutorialHub.BatchId,
//    function : TAsynBatchJob
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.Batch.Cancel(TutorialHub.BatchId);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

## Batch job retrieve

A batch can be retrieved using its ID, allowing you to check its status to track progress or obtain the ID of the file generated at the end of the process containing the expected results. To do so, use the following code:

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  TutorialHub.BatchId := 'batch_id'; //e.g. 982d2bbc-adbb-4c6e-b072-5aec973b4c86

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.Batch.AsyncAwaitRetrieve(TutorialHub.BatchId);

  promise
    .&Then<TBatchJob>(
      function (Value: TBatchJob): TBatchJob
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Batch.ASyncRetrieve(TutorialHub.BatchId,
//    function : TAsynBatchJob
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.Batch.Retrieve(TutorialHub.BatchId);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

## Batch job result file

If the batch processing completes successfully, an ID pointing to a file containing the results is provided. This ID can be accessed through the OutputFile field of the TBatchJob class.
In this case, you can use the [File Download API](https://github.com/MaxiDonkey/DelphiMistralAI/blob/main/guides/Files.md#file-download), demonstrated in this code example, to retrieve the file.
Alternatively, you can download the file directly from the platform.


# Chat API (v1/chat/completions)

- [Text generation](#text-generation)
    - [Non streamed](#non-streamed) 
    - [Streamed](#streamed)
    - [Multi-turn conversations](#multi-turn-conversations) 
    - [Parallel method for generating text](#parallel-method-for-generating-text)
    - [Reasoning](#reasoning)
- [Input Audio for Chat](#input-audio-for-chat)
- [Vision](#vision)
    - [Analyze single source](#analyze-single-source)
    - [Analyze multi-source](#analyze-multi-source)
- [Function calling](#function-calling)
- [Structured Output](#structured-output)

<br>

___

## Text generation

You can send a structured list of input messages containing only text content, and the model will generate the corresponding response message.

The Chat API supports both single‑turn requests and multi‑turn, stateless conversations.

>[!IMPORTANT]
> The async/await methods were introduced on the v1/chat/completion endpoint. Below are two usage examples: <br>
>  - **Non‑streaming response** <br>
>  - **Streaming response**

We assume that you have already unzipped one of the test applications—[TestMistralAI_VCL](https://github.com/MaxiDonkey/DelphiMistralAI/tree/main/sample) or [TestMistralAI_FMX](https://github.com/MaxiDonkey/DelphiMistralAI/tree/main/sample)—so you can integrate the code snippets below with a simple copy and paste.

<br>

___

### Non streamed

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.Chat.AsyncAwaitCreate(
    procedure (Params: TChatParams)
    begin
      Params.Model('mistral-tiny');
      Params.Messages([Payload.User('Explain to me what joual is for Quebecers.')]);
      Params.MaxTokens(1024);
      TutorialHub.JSONRequest := Params.ToFormat(); //to display JSON Request
    end);

  promise
    .&Then<string>(
      function (Value: TChat): string
      begin
        for var Item in Value.Choices do
          Result := Result + Item.Message.Content[0].Text;
        Display(TutorialHub, Value);
        ShowMessage(Result);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Chat.ASyncCreate(
//    procedure (Params: TChatParams)
//    begin
//      Params.Model('mistral-tiny');
//      Params.Messages([Payload.User('Explain to me what joual is for Quebecers.')]);
//      Params.MaxTokens(1024);
//      TutorialHub.JSONRequest := Params.ToFormat(); //to display JSON Request
//    end,
//    function : TAsynChat
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Chat := Client.Chat.Create(
//    procedure (Params: TChatParams)
//    begin
//      Params.Model('mistral-tiny');
//      Params.Messages([Payload.User('Explain to me what joual is for Quebecers.')]);
//      Params.MaxTokens(1024);
//      TutorialHub.JSONRequest := Params.ToFormat(); //to display JSON Request
//    end);
//  try
//    Display(Memo1, Chat);
//  finally
//    Chat.Free;
//  end;
```

<br>

By using the MistralAI.Tutorial.VCL unit along with the initialization described [above](https://github.com/MaxiDonkey/DelphiMistralAI#strategies-for-quickly-using-the-code-examples), you can achieve results similar to the example shown below.

![Preview](https://github.com/MaxiDonkey/DelphiMistralAI/blob/main/sample/ChatCompletionsNS.png?raw=true "Preview")

<br>

___

### Streamed

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;
  
  TutorialHub.JSONResponseClear;

  //Asynchronous promise example
  var Promise := Client.Chat.AsyncAwaitCreateStream(
    procedure(Params: TChatParams)
    begin
      Params.Model('mistral-large-latest');
      Params.Messages([
          Payload.System('You are a literature professor for graduate students and you often mention Jack Kerouac.'),
          Payload.User('Explain to me what joual is for Quebecers.')]);
      Params.MaxTokens(1024);
      Params.Stream;
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TPromiseChatStream
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;

      Result.OnProgress :=
        procedure (Sender: TObject; Chunk: TChat)
        begin
          DisplayStream(Sender, Chunk);
        end;

      Result.OnDoCancel := DoCancellation;

      Result.OnCancellation :=
        function (Sender: TObject): string
        begin
          Cancellation(Sender);
        end
    end);

  Promise
    .&Then<string>(
      function (Value: string): string
      begin
        Result := Value;
        ShowMessage(Result);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Chat.ASyncCreateStream(
//    procedure(Params: TChatParams)
//    begin
//      Params.Model('mistral-large-latest');
//      Params.Messages([
//          Payload.System('You are a literature professor for graduate students and you often mention Jack Kerouac.'),
//          Payload.User('Explain to me what joual is for Quebecers.')]);
//      Params.MaxTokens(1024);
//      Params.Stream;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    function : TAsynChatStream
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnProgress := DisplayStream;
//      Result.OnSuccess := Display;
//      Result.OnDoCancel := DoCancellation;
//      Result.OnCancellation := Cancellation;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  Client.Chat.CreateStream(
//    procedure(Params: TChatParams)
//    begin
//      Params.Model('mistral-large-latest');
//      Params.Messages([
//          Payload.System('You are a teacher for 8 year old children, you have to adapt your language to your students.'),
//          Payload.User('Explain to me what joual is for Quebecers.')]);
//      Params.MaxTokens(1024);
//      Params.Stream;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    procedure(var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
//    begin
//      if (not IsDone) and Assigned(Chat) then
//        begin
//          DisplayStream(Memo1, Chat);
//        end;
//    end);
```

![Preview](https://github.com/MaxiDonkey/DelphiMistralAI/blob/main/sample/ChatCompletionsS.png?raw=true "Preview")

<br>

___

### Multi-turn conversations

The `MistralAI Chat API` enables the creation of interactive chat experiences tailored to your users' needs. Its chat functionality supports multiple rounds of questions and answers, allowing users to gradually work toward solutions or receive help with complex, multi-step issues. This capability is especially useful for applications requiring ongoing interaction, such as:

- **Chatbots**
- **Educational tools**
- **Customer support assistants**

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  //Asynchronous example
  Client.Chat.ASyncCreateStream(
    procedure(Params: TChatParams)
    begin
      Params.Model('mistral-large-latest');
      Params.Messages([
          Payload.System('You are a funny domestic assistant.'),
          Payload.User('Hello'),
          Payload.Assistant('Great to meet you. What would you like to know?'),
          Payload.User('I have two dogs in my house. How many paws are in my house?')
      ]);
      Params.MaxTokens(1024);
      Params.Stream;
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynChatStream
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnProgress := DisplayStream;
      Result.OnSuccess := Display;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
      Result.OnError := Display;
    end);

  //Synchronous example
//  Client.Chat.CreateStream(
//    procedure(Params: TChatParams)
//    begin
//      Params.Model('mistral-large-latest');
//      Params.Messages([
//          Payload.System('You are a funny domestic assistant.'),
//          Payload.User('Hello'),
//          Payload.Assistant('Great to meet you. What would you like to know?'),
//          Payload.User('I have two dogs in my house. How many paws are in my house?')
//      ]);
//      Params.MaxTokens(1024);
//      Params.Stream;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    procedure(var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
//    begin
//      if (not IsDone) and Assigned(Chat) then
//        begin
//          DisplayStream(Memo1, Chat);
//        end;
//    end); 
```

<br>

___

### Parallel method for generating text

This approach enables the simultaneous execution of multiple prompts, provided they are all processed by the same model. It also supports parallel web requests.

#### Example : Two prompts processed in parallel.

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  Client.HttpClient.ResponseTimeout := 120000;

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.Chat.AsyncAwaitCreateParallel(
    procedure (Params: TBundleParams)
    begin
      Params.Prompts([
        'How many television channels were there in France in 1980?',
        'How many TV channels were there in Germany in 1980?.'
      ]);
      Params.System('Write the response in capital letters.');
      Params.Model('mistral-tiny');
    end);

  Promise
    .&Then<TBundleList>(
      function (Value: TBundleList): TBundleList
      begin
        Result := Value;
        for var Item in Value.Items do
        begin
          Display(TutorialHub, TChat(Item.Chat).Choices[0].Message.Content[0].Text);
        end;
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);


  //Asynchronous example
//  Client.Chat.CreateParallel(
//    procedure (Params: TBundleParams)
//    begin
//      Params.Prompts([
//        'How many television channels were there in France in 1980?',
//        'How many TV channels were there in Germany in 1980?.'
//      ]);
//      Params.System('Write the response in capital letters.');
//      Params.Model('mistral-tiny');
//    end,
//    function : TAsynBundleList
//    begin
//      Result.Sender := TutorialHub;
//
//      Result.OnStart :=
//        procedure (Sender: TObject)
//        begin
//          Display(Sender, 'Start the job' + sLineBreak);
//        end;
//
//      Result.OnSuccess :=
//        procedure (Sender: TObject; Bundle: TBundleList)
//        begin
//          // Background bundle processing
//          for var Item in Bundle.Items do
//            begin
//              Display(Sender, 'Index : ' + Item.Index.ToString);
//              Display(Sender, 'FinishIndex : ' + Item.FinishIndex.ToString);
//              Display(Sender, Item.Prompt + sLineBreak);
//              Display(Sender, Item.Response + sLineBreak + sLineBreak);
//              // or Display(Sender, TChat(Item.Chat).Choices[0].Message.Content);
//            end;
//        end;
//
//      Result.OnError := Display;
//    end);
```

<br>

___

### Reasoning

Refer to the [official documentation](https://docs.mistral.ai/capabilities/reasoning/)

Reasoning is the follow-up phase to Chain of Thought (CoT); it refers to the logical progression the model generates internally before arriving at a final response. Enhancing reasoning involves training the model to freely produce these chains of thought ahead of the answer, enabling deeper exploration of the problem. By allocating additional computation at inference time—often called Test Time Computation—the model can emit more intermediate tokens, refine its internal deliberation, and ultimately deliver a stronger, more accurate solution.

>[!NOTE]
>Two approaches are available to enable reasoning: rely on MistralAI’s built-in instruction chain or supply your own custom instructions.

Here, we’re providing only the streaming approach based on Promises; the simpler scenarios are left to the reader’s discretion.

<br>

___

#### Based on MistralAI’s built-in instruction

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONResponseClear;

  //Asynchronous promise example
  var Promise := Client.Chat.AsyncAwaitCreateStream(
    procedure (Params: TChatParams)
    begin
      Params.Model('magistral-medium-latest');
      Params.Messages([
        Payload.User('John is one of 4 children. The first sister is 4 years old. Next year, the second sister will be twice as old as the first sister. The third sister is two years older than the second sister. The third sister is half the age of her older brother. How old is John?')]);
      Params.Stream;
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TPromiseChatStream
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;

      Result.OnProgress :=
        procedure (Sender: TObject; Chunk: TChat)
        begin
          DisplayStream(Sender, Chunk);
        end;

      Result.OnDoCancel := DoCancellation;

      Result.OnCancellation :=
        function (Sender: TObject): string
        begin
          Cancellation(Sender);
        end
    end);

  Promise
    .&Then<string>(
      function (Value: string): string
      begin
        Result := Value;
        ShowMessage(Result);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);
```

<br>

___

#### Based on your own custom instructions

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONResponseClear;

  //Asynchronous promise example
  var Promise := Client.Chat.AsyncAwaitCreateStream(
    procedure (Params: TChatParams)
    begin
      Params.Model('magistral-medium-latest');
      Params.Messages([
        PayLoad.System(ReasoningEnglishInstructions), //insert your own custom instructions
        Payload.User('John is one of 4 children. The first sister is 4 years old. Next year, the second sister will be twice as old as the first sister. The third sister is two years older than the second sister. The third sister is half the age of her older brother. How old is John?')]);
      Params.Stream;
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TPromiseChatStream
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;

      Result.OnProgress :=
        procedure (Sender: TObject; Chunk: TChat)
        begin
          DisplayStream(Sender, Chunk);
        end;

      Result.OnDoCancel := DoCancellation;

      Result.OnCancellation :=
        function (Sender: TObject): string
        begin
          Cancellation(Sender);
        end
    end);

  Promise
    .&Then<string>(
      function (Value: string): string
      begin
        Result := Value;
        ShowMessage(Result);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);
```

>[!NOTE]
> The string `ReasoningEnglishInstructions` is available in the `MistralAI.Types` unit.

<br>
___

## Input Audio for Chat

It’s possible to include an audio file when calling the `v1/chat/completions` endpoint to process its content within a conversation. You can provide the audio data in two ways: <br>
 - **Via URL (signed or unsigned)**
 - **As a Base64‑encoded string**

Refer to [official documentation](https://docs.mistral.ai/capabilities/audio/)

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

   var audio_url := 'url, signedurl or string encoded base-64';

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.Chat.AsyncAwaitCreate(
    procedure (Params: TChatParams)
    begin
      Params.Model('voxtral-mini-latest');

      Params.Messages([
        Payload.User('Detail the exchanges in this audio conversation.', audio_url)
      ]);
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  promise
    .&Then<string>(
      function (Value: TChat): string
      begin
        for var Item in Value.Choices do
          Result := Result + Item.Message.Content[0].Text;
        Display(TutorialHub, Value);
        ShowMessage(Result);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);
```

<br>

___

## Vision

Refer to the [official documentation](https://docs.mistral.ai/capabilities/vision/).

### Analyze single source

`MistralAI` processes images from both web sources and local files uniformly. It manages the submission of the source to the API, thereby simplifying the developer's task. Therefore, in this example, we will handle sources in the form of a ***URL*** and ***base-64 encoded*** data.

**Non streamed code example**

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  var Ref := '..\..\sample\Invoice.png';
  var Image_url := 'https://assets.visitorscoverage.com/production/wp-content/uploads/2024/04/AdobeStock_626542468-min-1024x683.jpeg';

  //Asynchronous promise example
  var Promise := Client.Chat.AsyncAwaitCreate(
    procedure (Params: TChatParams)
    begin
      Params.Model('pixtral-12b-2409');
      Params.Messages([PayLoad.User('Describe the image', [Ref])]);
      //or 
      // Params.Messages([PayLoad.User('Describe the image', [Ref])]);
      Params.MaxTokens(1024);
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  Promise
    .&Then<TChat>(
      function (Value: TChat): TChat
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Chat.ASyncCreate(
//    procedure (Params: TChatParams)
//    begin
//      Params.Model('pixtral-12b-2409');
//      Params.Messages([PayLoad.User('Describe the image', [Ref])]);
//      Params.MaxTokens(1024);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    function : TAsynChat
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Vision := Client.Chat.Create(
//    procedure (Params: TChatParams)
//    begin
//      Params.Model('pixtral-12b-2409');
//      Params.Messages([PayLoad.User('Describe the image', [Ref])]);
//      Params.MaxTokens(1024);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Vision);
//  finally
//    Vision.Free;
//  end;
```

<br>

___

### Analyze multi-source

**Streamed code example**

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  var Ref := '..\..\sample\Invoice.png';
  var Image_url := 'https://assets.visitorscoverage.com/production/wp-content/uploads/2024/04/AdobeStock_626542468-min-1024x683.jpeg';

  //Asynchronous promise example
  var Promise := Client.Chat.AsyncAwaitCreateStream(
    procedure (Params: TChatParams)
    begin
      Params.Model('pixtral-12b-2409');
      Params.Messages([PayLoad.User('What difference between images.', [Ref, Image_url])]);
      Params.MaxTokens(1024);
      Params.Stream;
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TPromiseChatStream
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;

      Result.OnProgress :=
        procedure (Sender: TObject; Chunk: TChat)
        begin
          DisplayStream(Sender, Chunk);
        end;

      Result.OnDoCancel := DoCancellation;

      Result.OnCancellation :=
        function (Sender: TObject): string
        begin
          Cancellation(Sender);
        end
    end);

  Promise
    .&Then<string>(
      function (Value: string): string
      begin
        Result := Value;
        ShowMessage(Result);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Chat.ASyncCreateStream(
//    procedure (Params: TChatParams)
//    begin
//      Params.Model('pixtral-12b-2409');
//      Params.Messages([PayLoad.User('What difference between images.', [Ref, Image_url])]);
//      Params.MaxTokens(1024);
//      Params.Stream;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    function : TAsynChatStream
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnProgress := DisplayStream;
//      Result.OnSuccess := Display;
//      Result.OnDoCancel := DoCancellation;
//      Result.OnCancellation := Cancellation;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  Client.Chat.CreateStream(
//    procedure (Params: TChatParams)
//    begin
//      Params.Model('pixtral-12b-2409');
//      Params.Messages([PayLoad.User('What difference between images.', [Ref, Image_url])]);
//      Params.MaxTokens(1024);
//      Params.Stream;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    procedure(var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
//    begin
//      if (not IsDone) and Assigned(Chat) then
//        begin
//          DisplayStream(Memo1, Chat);
//        end;
//    end);
```

<br>

___

## Function calling

Allow models to access data and execute actions. <br/>
Function calling offers a robust and versatile method for MistralAI models to interact with your code or external services, serving two main purposes:

- **Data Retrieval:** Access real-time information to enhance the model's responses (RAG). This is particularly beneficial for searching knowledge bases and extracting specific data from APIs (e.g., obtaining the current weather).

- **Action Execution:** Carry out tasks such as form submissions, API calls, updating the application state (UI/frontend or backend), or executing agent-driven workflows (e.g., transferring a conversation).

Refer to the [official documentation](https://docs.mistral.ai/capabilities/function_calling/).

<br>

___

### How build a plugin

Use case : **What’s the weather in Paris?**

In the `MistralAI.Functions.Example` unit, there is a class that defines a function which DelphiMistralAI can choose to use or not, depending on the options provided. This class inherits from a parent class defined in the `MistralAI.Functions.Core` unit. To create new functions, you can derive from the `TFunctionCore` class and define a new plugin.

<br>

### Plan
 - [Use a schema](#use-a-schema)
 - [Methods to display result](#methods-to-display-result)
 - [Display a stream text](#display-a-stream-text) 
 - [The main method](#the-main-method)
 - [The FinishReason](#the-finishreason)

<br>

___

#### Use a schema

In this unit, this schema will be used for function calls.
```Json
{
    "type": "object",
    "properties": {
         "location": {
             "type": "string",
             "description": "The city and department, e.g. Marseille, 13"
         },
         "unit": {
             "type": "string",
             "enum": ["celsius", "fahrenheit"]
         }
     },
     "required": ["location"],
     "additionalProperties": false
}
```

<br/>

We will use the TWeatherReportFunction plugin defined in the `MistralAI.Functions.Example` unit.

```Pascal
  var Weather := TWeatherReportFunction.CreateInstance;
  //or
  var Weather := TWeatherReportFunction.CreateInstance(True);  //To activate `Strict` option

  //See step : Main method
```
<br/>

___

#### Methods to display result

We then define a method to display the result of the query using the Weather tool.

With this tutorial, a method is defined within TutorialHub. Let’s take a closer look at how this method works.

<br>

___

#### Display a stream text

```Pascal
procedure TVCLTutorialHub.WeatherFunction(const Value: TCalledFunction;
  Func: IFunctionCore);
begin
  var ArgResult := Func.Execute(Value.&Function.Arguments);

  FClient.Chat.AsyncCreateStream(
    procedure (Params: TChatParams)
    begin
      Params.Model('open-mixtral-8x22b-2404');
      Params.Messages([
        PayLoad.System('Respond like a star weather presenter on a prime-time TV channel.'),
        Payload.User(ArgResult)
      ]);
      Params.Stream(True);
      Params.MaxTokens(1024);
    end,
    function : TAsynChatStream
    begin
      Result.Sender := TutorialHub;
      Result.OnProgress := DisplayStream;
      Result.OnSuccess := Display;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
      Result.OnError := Display;
    end);
end;  
```

>[!NOTE]
> The same method also exists with the FMX version of the TutorialHub wizard.

<br/>

___

#### The main method

Building the query using the Weather tool. (Simply copy/paste this last code to test the usage of the functions.)

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL, MistralAI.Functions.Example or Mistral.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  var WeatherFunc: IFunctionCore := TWeatherReportFunction.Create;

  TutorialHub.Tool := WeatherFunc;
  TutorialHub.ToolCall := TutorialHub.WeatherFunction;

  //Asynchronous example
  Client.Chat.ASyncCreate(
    procedure (Params: TChatParams)
    begin
      Params.Model('mistral-large-latest');
      Params.Messages([TChatMessagePayload.User('What''s the weather like in Paris?')]);
      Params.Tools([TChatMessageTool.Add(WeatherFunc)]);
      Params.ToolChoice(TToolChoice.auto);
      Params.MaxTokens(1024);
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynChat
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Chat := Client.Chat.Create(
//    procedure (Params: TChatParams)
//    begin
//      Params.Model('mistral-large-latest');
//      Params.Messages([TChatMessagePayload.User('What''s the weather like in Paris?')]);
//      Params.Tools([TChatMessageTool.Add(WeatherFunc)]);
//      Params.ToolChoice(auto);
//      Params.MaxTokens(1024);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Chat);
//  finally
//    Chat.Free;
//  end;
``` 

<br>

___

#### The FinishReason

Let's look at how the display method handles the function call.

```Pascal
procedure Display(Sender: TObject; Value: TChat);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Choices do
    if Item.FinishReason = TFinishReason.tool_calls then
      begin
        if Assigned(TutorialHub.ToolCall) then
          TutorialHub.ToolCall(Item.Message.ToolsCalls[0], TutorialHub.Tool);
      end
    else
      begin
        for var SubItem in Item.Message.Content do
          begin
            case SubItem.&Type of
              TContentType.text:
                Display(Sender, SubItem.Text);

              TContentType.thinking:
                begin
                  for var Think in SubItem.Thinking do
                    Display(TutorialHub.Memo2, Think.Text);
                end;
            end;
          end;
      end;
end;
```

>[!CAUTION]
>Ensure user confirmation for actions like sending emails or making purchases to avoid unintended consequences.

<br/>

___

## Structured Output

 - [JSON mode](#json-mode)
 - [Custom Structured Outputs](#custom-structured-outputs)

### JSON mode

To activate JSON mode, set response_format to {"type":"json_object"}. This JSON output option is now supported for every model via our API.

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.Chat.AsyncAwaitCreate(
    procedure (Params: TChatParams)
    begin
      Params.Model('mistral-large-latest');
      Params.Messages([
        Payload.User('What is the best French meal? Return the name and the ingredients in short JSON object.')
      ]);
      Params.ResponseFormat(TResponseFormatParams.Json_Oject);
      Params.MaxTokens(1024);
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  promise
    .&Then<string>(
      function (Value: TChat): string
      begin
        for var Item in Value.Choices do
          Result := Result + Item.Message.Content[0].Text;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);
```

**Example output:**
```Json
{
  "name": "Boeuf Bourguignon",
  "ingredients": [
    "Beef",
    "Red wine",
    "Carrots",
    "Onions",
    "Garlic",
    "Bacon",
    "Mushrooms",
    "Herbs (thyme, bay leaf, parsley)"
  ]
}
```

<br>

___

### Custom Structured Outputs

By defining a strict JSON schema up front, Custom Structured Outputs compel the model to emit responses that match your exact structure—right down to field names and data types. In practice, this means you get reliably formatted JSON every time, with the correct keywords and types baked in.

Refer to the [official documentation](https://docs.mistral.ai/capabilities/structured-output/custom_structured_output/)

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

  var Schema :=
    '{' +
    '    "schema": {' +
    '      "properties": {' +
    '        "name": {' +
    '          "title": "Name",' +
    '          "type": "string"' +
    '        },' +
    '        "authors": {' +
    '          "items": {' +
    '            "type": "string"' +
    '          },' +
    '          "title": "Authors",' +
    '          "type": "array"' +
    '        }' +
    '      },' +
    '      "required": ["name", "authors"],' +
    '      "title": "Book",' +
    '      "type": "object",' +
    '      "additionalProperties": false' +
    '    },' +
    '    "name": "book",' +
    '    "strict": true' +
    '  }';

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.Chat.AsyncAwaitCreate(
    procedure (Params: TChatParams)
    begin
      Params.Model('mistral-large-latest');
      Params.Messages([
        Payload.System('Extract the books information.'),
        Payload.User('I recently read To Kill a Mockingbird by Harper Lee.')
      ]);
      Params.ResponseFormat(Schema);
      Params.MaxTokens(1024);
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  promise
    .&Then<string>(
      function (Value: TChat): string
      begin
        for var Item in Value.Choices do
          Result := Result + Item.Message.Content[0].Text;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);
```

**Example output:**
```Json
{
  "name": "To Kill a Mockingbird",
  "authors": ["Harper Lee"]
}
```

# Moderation 

- [Moderation API](#moderation-api)
- [Validation and security system layer](#validation-and-security-system-layer)

<br>

___

## Moderation API

The moderation service, leveraging the advanced Mistral Moderation model—a classifier built on the Ministral 8B 24.10 framework—empowers users to identify harmful text content across multiple policy dimensions.

- [Raw-text endpoint](#raw-text-endpoint)
- [Conversational endpoint](#conversational-endpoint)
- [Managing moderation categories](#managing-moderation-categories)

<br>

___

### Raw-text endpoint

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  var text_to_classify := 'text_to_classify';

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.Classifiers.AsyncAwaitModeration(
    procedure (Params: TModerationParams)
    begin
      Params.Model('mistral-moderation-latest');
      Params.Input(text_to_classify);
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  promise
    .&Then<TModeration>(
      function (Value: TModeration): TModeration
      begin
        Result := Value;
        DisplayEx(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Classifiers.ASyncModeration(
//    procedure (Params: TModerationParams)
//    begin
//      Params.Model('mistral-moderation-latest');
//      Params.Input(text_to_classify);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    function : TAsynModeration
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnSuccess := DisplayEx;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Moderation := Client.Classifiers.Moderation(
//    procedure (Params: TModerationParams)
//    begin
//      Params.Model('mistral-moderation-latest');
//      Params.Input(text_to_classify);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Moderation);
//  finally
//    Moderation.Free;
//  end;
```

<br>

___

### Conversational endpoint

For conversational use of the moderation API, it's best to call the conversational endpoint and submit your dialogue as illustrated below. The model evaluates the most recent turn in the context of the preceding conversation.

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

  var text_to_classify := 'text_to_classify';

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.Classifiers.AsyncAwaitModerationChat(
    procedure (Params: TModerationChatParams)
    begin
      Params.Model('mistral-moderation-latest');
      Params.Input([Payload.User(text_to_classify)]);
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  promise
    .&Then<TModeration>(
      function (Value: TModeration): TModeration
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Classifiers.ASyncModerationChat(
//    procedure (Params: TModerationChatParams)
//    begin
//      Params.Model('mistral-moderation-latest');
//      Params.Input([Payload.User(text_to_classify)]);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    function : TAsynModeration
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Moderation := Client.Classifiers.ModerationChat(
//    procedure (Params: TModerationChatParams)
//    begin
//      Params.Model('mistral-moderation-latest');
//      Params.Input([Payload.User(text_to_classify)]);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Moderation);
//  finally
//    Moderation.Free;
//  end;
```

<br>

___

### Managing moderation categories

Moderation categories can be easily customized for simplified display. The examples below demonstrate how this can be achieved through code.

<br>

**Show all categories with each associated score.**

```Pascal
procedure Display(Sender: TObject; Value: TModerationResult);
begin
  if Value.Warning then
    begin
      Display(Sender, [EmptyStr,
        F(Classifiers[0], Value.Categories.Sexual, Value.Scores.Sexual),
        F(Classifiers[1], Value.Categories.Hate_and_discrimination, Value.Scores.Hate_and_discrimination),
        F(Classifiers[2], Value.Categories.Violence_and_threats, Value.Scores.Violence_and_threats),
        F(Classifiers[3], Value.Categories.Dangerous_and_criminal_content, Value.Scores.Dangerous_and_criminal_content),
        F(Classifiers[4], Value.Categories.Selfharm, Value.Scores.Selfharm),
        F(Classifiers[5], Value.Categories.Health, Value.Scores.Health),
        F(Classifiers[6], Value.Categories.Financial, Value.Scores.Financial),
        F(Classifiers[7], Value.Categories.Law, Value.Scores.Law),
        F(Classifiers[8], Value.Categories.Pii, Value.Scores.Pii)
      ]);
    end
  else
    begin
      Display(Sender, 'No moderation is necessary');
    end;
end;
```

<br>

**Show categories with a non-zero score.**

```Pascal
procedure DisplayEx(Sender: TObject; Value: TModerationResult);
var
  Temp: TArray<string>;
begin
  if Value.Warning then
    begin
      Temp := [''];
      for var Item in Value.Warnings do
        Temp := Temp + [F(Item.Category, (Item.Score * 100).ToString(ffNumber, 3, 2)) + '%'];
      Display(Sender, Temp);
      Display(Sender);
    end
  else
    begin
      Display(Sender, 'No moderation is necessary');
    end;
end;
```

<br>

___

## Validation and security system layer

Enforcing guardrails in chat responses is essential for user-facing applications. To support this, an optional system prompt designed to apply safety constraints on top of the models. This feature can be enabled by setting the `safe_prompt` boolean flag in your API request, as shown below:

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

   var text_to_classify := 'text_to_classify';

  TutorialHub.JSONRequestClear;

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.Chat.AsyncAwaitCreate(
    procedure (Params: TChatParams)
    begin
      Params.Model('mistral-tiny');
      Params.Messages([Payload.User(text_to_classify)]);
      Params.SafePrompt(True);
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  promise
    .&Then<string>(
      function (Value: TChat): string
      begin
        for var Item in Value.Choices do
          Result := Result + Item.Message.Content[0].Text;
        Display(TutorialHub, Value);
        ShowMessage(Result);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);
```

# Conversations API (v1/conversations)

- [Introduction](#introduction)
- [Text generation](#text-generation)
    - [Non streamed](#non-streamed)
    - [Streamed](#streamed)
    - [Multi-turn conversations](#multi-turn-conversations) 
    - [Parallel method for generating text](#parallel-method-for-generating-text)
    - [Reasoning](#reasoning)
- [Conversations managment](#conversations-managment)
    - [Continue a conversation](#continue-a-conversation)
    - [Retrieve conversations](#retrieve-conversations)
    - [Restart a conversation](#restart-a-conversation)
    - [List all created conversations](#list-all-created-conversations)
    - [Retrieve all entries in a conversation](#retrieve-all-entries-in-a-conversation)
    - [Retrieve all messages in a conversation](#retrieve-all-messages-in-a-conversation)
- [Tools for conversations](#tools-for-conversations)
- [Function calling](#function-calling)
- [Structured Output](#structured-output)
- [Agents & connectors](#agents--connectors)

<br>

___

## Introduction

Once your agent is created, you can start or resume a conversation at any time using the same thread. To open a new conversation, send:
- **agent_id:** the unique identifier you received when creating the agent
- **inputs:** the initial message (a string, either the user’s question or the conversation history)

The call will return a **conversation_id**.

To continue the dialogue and append to the history, simply reuse:
- **conversation_id:** the ID of the ongoing conversation (stored server-side)
- **inputs:** the next message or response (either a string or a list of messages)

Each new message returns an updated **conversation_id**.

If you prefer not to automatically persist the history in our cloud, include store=false in your call; the exchange will not be saved.

Finally, the handoff_execution parameter controls the transfer mode:
- **`server` (default):** the handoff is executed automatically on our cloud
- **`client`:** the user receives the handoff response directly and handles it themselves.

<br>

___

## Text generation

First, let’s take a structured look at how to craft a request to the `v1/conversations` endpoint, whether in streaming or non-streaming mode.

___

### Non streamed

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.Conversations.AsyncAwaitCreate(
    procedure (Params: TConversationsParams)
    begin
      Params.Inputs('Explain to me what Joual represents for Quebecers.');
      Params.Model('mistral-medium-2505');
      Params.Store(False);
      Params.CompletionArgs(TCompletionArgsParams.Create
        .Temperature(0.3)
        .TopP(0.95)
      );
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  Promise
    .&Then<TConversation>(
      function (Value: TConversation): TConversation
      begin
        Result := Value;
        ConvId := Value.ConversationId;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Conversations.ASyncCreate(
//    procedure (Params: TConversationsParams)
//    begin
//      Params.Inputs('Explain to me what Joual represents for Quebecers.');
//      Params.Model('mistral-medium-2505');
//      Params.Store(False);
//      Params.CompletionArgs(TCompletionArgsParams.Create
//        .Temperature(0.3)
//        .TopP(0.95)
//      );
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    function : TAsyncConversation
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.Conversations.Create(
//    procedure (Params: TConversationsParams)
//    begin
//      Params.Inputs('Explain to me what Joual represents for Quebecers.');
//      Params.Model('mistral-medium-2505');
//      Params.Store(False);
//      Params.CompletionArgs(TCompletionArgsParams.Create
//        .Temperature(0.3)
//        .TopP(0.95)
//      );
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```  

<br>

By using the MistralAI.Tutorial.VCL unit along with the initialization described [above](https://github.com/MaxiDonkey/DelphiMistralAI#strategies-for-quickly-using-the-code-examples), you can achieve results similar to the example shown below.

![Preview](https://github.com/MaxiDonkey/DelphiMistralAI/blob/main/sample/ConversationxNS.png?raw=true "Preview")

<br>

___

### Streamed

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

  //Asynchronous promise example
  var Promise := Client.Conversations.AsyncAwaitCreateStream(
    procedure (Params: TConversationsParams)
    begin
      Params.Inputs('Explain to me what Joual represents for Quebecers.');
      Params.Model('mistral-medium-2505');
      Params.Store(False);
      Params.Stream;
      Params.CompletionArgs(TCompletionArgsParams.Create
        .Temperature(0.3)
        .TopP(0.95)
      );
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TPromiseConversationsEvent
    begin
      Result.Sender := TutorialHub;
      Result.OnProgress :=
        procedure (Sender: TObject; Event: TConversationsEvent)
        begin
          DisplayStream(Sender, Event);
        end;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation :=
        function (Sender: TObject): string
        begin
          Cancellation(Sender);
        end;
    end);

  Promise
    .&Then<string>(
      function (Value: string): string
      begin
        Result := Value;
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Conversations.AsyncCreateStream(
//    procedure (Params: TConversationsParams)
//    begin
//      Params.Inputs('Explain to me what Joual represents for Quebecers.');
//      Params.Model('mistral-medium-2505');
//      Params.Store(False);
//      Params.Stream;
//      Params.CompletionArgs(TCompletionArgsParams.Create
//        .Temperature(0.3)
//        .TopP(0.95)
//      );
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    function : TAsyncConversationsEvent
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnProgress := DisplayStream;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  Client.Conversations.CreateStream(
//    procedure(Params: TConversationsParams)
//    begin
//      Params.Inputs('Explain to me what Joual represents for Quebecers.');
//      Params.Model('mistral-medium-2505');
//      Params.Store(False);
//      Params.Stream;
//      Params.CompletionArgs(TCompletionArgsParams.Create
//        .Temperature(0.3)
//        .TopP(0.95)
//      );
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    procedure(var Chunk: TConversationsEvent; IsDone: Boolean; var Cancel: Boolean)
//    begin
//      if (not IsDone) and Assigned(Chunk) then
//        begin
//          DisplayStream(TutorialHub, Chunk);
//        end;
//    end);
```

<br>

By using the MistralAI.Tutorial.VCL unit along with the initialization described [above](https://github.com/MaxiDonkey/DelphiMistralAI#strategies-for-quickly-using-the-code-examples), you can achieve results similar to the example shown below.

![Preview](https://github.com/MaxiDonkey/DelphiMistralAI/blob/main/sample/ConversationxS.png?raw=true "Preview")

<br>

___

### Multi-turn conversations

We’ll outline the most efficient method for orchestrating a multi-turn exchange via the v1/conversation endpoint.

First, we’ll leverage conversation agents. For more details, please refer to the [Agents & Connectors](https://github.com/MaxiDonkey/DelphiMistralAI/blob/main/guides/AgentsConnectors.md) guide.

The example below illustrates only the ***asynchronous, Promise-based approach***; the other two implementation strategies are left to the reader’s discretion.

#### Operational Plan
- [Step 1](#step-1): Initialize the conversational agent
- [Step 2](#step-2): Send the initial request to the endpoint to start the exchange and retrieve the conversation_id
- [Step 3](#step-3): For subsequent turns, reuse the conversation_id to continue the dialogue

<br>

___

##### Step 1 
**Initialize the conversational agent**

```Pascal
var AgentId: string;

//Asynchronous promise example
  var Promise := Client.ConversationsAgent.AsyncAwaitCreate(
    procedure (Params: TConversationsAgentParams)
    begin
      Params.Model('mistral-medium-2505');
      Params.Name('just an agent');
      Params.Description('Agent reduced to its simplest form.');
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  Promise
    .&Then<TConversationsAgent>(
      function (Value: TConversationsAgent): TConversationsAgent
      begin
        Result := Value;
        Display(TutorialHub, Value);
        AgentId := Value.Id;  //e.g. ag_01985efe4b657539a2d6380dad6c3c55
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);
```
>[!NOTE]
> You can get the list of active agents by referring to the [Agents & Connectors](https://github.com/MaxiDonkey/DelphiMistralAI/blob/main/guides/AgentsConnectors.md) 

<br>

___
 
##### Step 2
**Send the initial request to the endpoint to start the exchange and retrieve the conversation_id**

```Pascal
  var Promise := Client.Conversations.AsyncAwaitCreateStream(
     procedure (Params: TConversationsParams)
    begin
      Params
        .Inputs('my_text_1')
        .AgentId(AgentId); //e.g. ag_01985efe4b657539a2d6380dad6c3c55
        .Stream
        .Store;  //Use the storing
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TPromiseConversationsEvent
    begin
      Result.Sender := TutorialHub;
      Result.OnProgress :=
        procedure (Sender: TObject; Event: TConversationsEvent)
        begin
          if Event.&Type = TChunkEvent.conversation_response_started then
            ConvId := Event.ConversationId; //IMPORTANT : Get then conversation Id
          DisplayStream(Sender, Event);
        end;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation :=
        function (Sender: TObject): string
        begin
          Cancellation(Sender);
        end;
    end);
```

>[!NOTE]
>We have now retrieved the conversation ID, which will allow us to continue the conversation by supplying it in our subsequent interactions.

<br>

___
 
##### Step 3
**For subsequent turns, reuse the conversation_id to continue the dialogue**

We can continue the conversation by using the Append or AppendStream methods, as well as their asynchronous variants.

```Pascal
  var Promise := Client.Conversations.AsyncAwaitAppendStream(ConvId,
    procedure(Params: TConversationsParams)
    begin
      Params.Inputs('my_text_2');
      Params.Stream;
      Params.Store;  //Use the storing
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TPromiseConversationsEvent
    begin
      Result.Sender := TutorialHub;
      Result.OnProgress :=
        procedure (Sender: TObject; Event: TConversationsEvent)
        begin
          DisplayStream(Sender, Event);
        end;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation :=
        function (Sender: TObject): string
        begin
          Cancellation(Sender);
        end;
    end);
```

<br>

___

### Parallel method for generating text

This approach enables the simultaneous execution of multiple prompts, provided they are all processed by the same model. It also supports parallel web requests.

#### Example : Two prompts processed in parallel.

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  Client.HttpClient.ResponseTimeout := 120000;

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.Conversations.AsyncAwaitCreateParallel(
    procedure (Params: TBundleParams)
    begin
      Params.Prompts([
        'How many television channels were there in France in 1980?',
        'How many TV channels were there in Germany in 1980?.'
      ]);
      Params.System('Write the response in capital letters.');
      Params.Model('mistral-medium-2505');
    end);

  Promise
    .&Then<TBundleList>(
      function (Value: TBundleList): TBundleList
      begin
        Result := Value;
        for var Item in Value.Items do
          begin
            Display(TutorialHub, F('index', Item.Index.ToString));
            Display(TutorialHub, TConversation(Item.Chat).Outputs[0].Content[0].Text);
            Display(TutorialHub, EmptyStr);
          end;
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Conversations.CreateParallel(
//    procedure (Params: TBundleParams)
//    begin
//      Params.Prompts([
//        'How many television channels were there in France in 1980?',
//        'How many TV channels were there in Germany in 1980?.'
//      ]);
//      Params.System('Write the response in capital letters.');
//      Params.Model('mistral-medium-2505');
//    end,
//    function : TAsynBundleList
//    begin
//      Result.Sender := TutorialHub;
//
//      Result.OnStart :=
//        procedure (Sender: TObject)
//        begin
//          Display(Sender, 'Start the job' + sLineBreak);
//        end;
//
//      Result.OnSuccess :=
//        procedure (Sender: TObject; Bundle: TBundleList)
//        begin
//          // Background bundle processing
//          for var Item in Bundle.Items do
//            begin
//              Display(Sender, 'Index : ' + Item.Index.ToString);
//              Display(Sender, 'FinishIndex : ' + Item.FinishIndex.ToString);
//              Display(Sender, Item.Prompt + sLineBreak);
//              Display(Sender, Item.Response + sLineBreak + sLineBreak);
//              // or Display(Sender, TChat(Item.Chat).Choices[0].Message.Content);
//            end;
//        end;
//
//      Result.OnError := Display;
//    end);
```

<br>

___

### Reasoning

The implementation of reasoning with the `v1/conversations` endpoint differs from that of `v1/chat/completions`. In particular, the `v1/conversations` API does not incorporate tokenized “thought” blocks via control tokens; consequently, there is no explicit trace of reflection within the content segments.

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

  //Asynchronous promise example
  var Promise := Client.Conversations.AsyncAwaitCreateStream(
    procedure (Params: TConversationsParams)
    begin
      Params.Model('magistral-small-latest');
      Params.Instructions;
      Params.Inputs('John is one of 4 children. The first sister is 4 years old. Next year, the second sister will be twice as old as the first sister. The third sister is two years older than the second sister. The third sister is half the age of her older brother. How old is John?');
      Params.Store(False);
      Params.Stream;
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TPromiseConversationsEvent
    begin
      Result.Sender := TutorialHub;
      Result.OnProgress :=
        procedure (Sender: TObject; Event: TConversationsEvent)
        begin
          DisplayStream(Sender, Event);
        end;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation :=
        function (Sender: TObject): string
        begin
          Cancellation(Sender);
        end;
    end);

    Promise
    .&Then<string>(
      function (Value: string): string
      begin
        Result := Value;
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Conversations.AsyncCreateStream(
//    procedure (Params: TConversationsParams)
//    begin
//      Params.Model('magistral-small-latest');
//      Params.Instructions;
//      Params.Inputs('John is one of 4 children. The first sister is 4 years old. Next year, the second sister will be twice as old as the first sister. The third sister is two years older than the second sister. The third sister is half the age of her older brother. How old is John?');
//      Params.Store(False);
//      Params.Stream;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    function : TAsyncConversationsEvent
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnProgress := DisplayStream;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  Client.Conversations.CreateStream(
//    procedure (Params: TConversationsParams)
//    begin
//      Params.Model('magistral-small-latest');
//      Params.Instructions;
//      Params.Inputs('John is one of 4 children. The first sister is 4 years old. Next year, the second sister will be twice as old as the first sister. The third sister is two years older than the second sister. The third sister is half the age of her older brother. How old is John?');
//      Params.Store(False);
//      Params.Stream;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    procedure(var Chunk: TConversationsEvent; IsDone: Boolean; var Cancel: Boolean)
//    begin
//      if (not IsDone) and Assigned(Chunk) then
//        begin
//          DisplayStream(TutorialHub, Chunk);
//        end;
//    end);
```

>[!NOTE]
> The string `ReasoningEnglishInstructions` is available in the `MistralAI.Types` unit.

<br>

___

## Conversations managment

### Continue a conversation

#### Non streamed

Refer to the [official documentation](https://docs.mistral.ai/api/#tag/beta.conversations/operation/agents_api_v1_conversations_append)

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  ConvId := 'conversation_id'; //e.g. conv_0198261f353271a4bd9e95ef32105994

  //Asynchronous promise example
  var Promise := Client.Conversations.AsyncAwaitAppend(ConvId,
    procedure (Params: TConversationsParams)
    begin
      Params.Inputs('In what proportion of the Canadian population is joual used?');
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  Promise
    .&Then<TConversation>(
      function (Value: TConversation): TConversation
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Conversations.AsyncAppend(ConvId,
//    procedure (Params: TConversationsParams)
//    begin
//      Params.Inputs('In what proportion of the Canadian population is joual used?);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    function : TAsyncConversation
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.Conversations.Append(ConvId,
//    procedure (Params: TConversationsParams)
//    begin
//      Params.Inputs('In what proportion of the Canadian population is joual used?);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;  
```
<br>

___

#### Streamed

Refer to the [official documentation](https://docs.mistral.ai/api/#tag/beta.conversations/operation/agents_api_v1_conversations_append_stream)

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  ConvId := 'conversation_id'; //e.g. conv_0198261f353271a4bd9e95ef32105994 

  //Asynchronous promise example
  var Promise := Client.Conversations.AsyncAwaitAppendStream(ConvId,
    procedure(Params: TConversationsParams)
    begin
      Params.Inputs('In what proportion of the Canadian population is joual used?');
      Params.Stream;
      Params.Store;
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TPromiseConversationsEvent
    begin
      Result.Sender := TutorialHub;
      Result.OnProgress :=
        procedure (Sender: TObject; Event: TConversationsEvent)
        begin
          DisplayStream(Sender, Event);
        end;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation :=
        function (Sender: TObject): string
        begin
          Cancellation(Sender);
        end;
    end);

  Promise
    .&Then<string>(
       function (Value: string): string
       begin
         Result := Value;
         ShowMessage(Value);
       end)
    .Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Conversations.AsyncAppendStream(ConvId,
//    procedure(Params: TConversationsParams)
//    begin
//      Params.Inputs('In what proportion of the Canadian population is joual used?');
//      Params.Stream;
//      Params.Store;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    function : TAsyncConversationsEvent
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnProgress := DisplayStream;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  Client.Conversations.AppendStream(ConvId,
//    procedure(Params: TConversationsParams)
//    begin
//      Params.Inputs('In what proportion of the Canadian population is joual used?');
//      Params.Stream;
//      Params.Store;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    procedure(var Chunk: TConversationsEvent; IsDone: Boolean; var Cancel: Boolean)
//    begin
//      if (not IsDone) and Assigned(Chunk) then
//        begin
//          DisplayStream(TutorialHub, Chunk);
//        end;
//    end);
```

<br>

___

### Retrieve conversations

Refer to the [official documentation](https://docs.mistral.ai/api/#tag/beta.conversations/operation/agents_api_v1_conversations_get)

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  ConvId := 'conversation_id'; //e.g. conv_0198261f353271a4bd9e95ef32105994
  
  //Asynchronous promise example
  var Promise := Client.Conversations.AsyncAwaitRetrieve(ConvId);

  Promise
    .&Then<TConversationsListItem>(
       function (Value: TConversationsListItem): TConversationsListItem
       begin
         Result := Value;
         Display(TutorialHub, Value);
       end)
    .Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Conversations.AsyncRetrieve(ConvId,
//    function : TAsyncConversationsListItem
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.Conversations.Retrieve(ConvId);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

### Restart a conversation

#### Non streamed

Refer to the [official documentation](https://docs.mistral.ai/api/#tag/beta.conversations/operation/agents_api_v1_conversations_restart)

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  ConvId := 'conversation_id'; //e.g. conv_0198261f353271a4bd9e95ef32105994
  
  //Asynchronous promise example
  var Promise := Client.Conversations.AsyncAwaitRestart(ConvId,
    procedure (Params: TConversationsParams)
    begin
      Params.Inputs('Name some dialects of French, such as Joual.');
      Params.FromEntryId(Restart_id); //e.g. msg_019835d44cd47796b0066c6e10951eac
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  Promise
    .&Then<TConversation>(
      function (Value: TConversation): TConversation
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Conversations.AsyncRestart(ConvId,
//    procedure (Params: TConversationsParams)
//    begin
//      Params.Inputs('Name some dialects of French, such as Joual.');
//      Params.FromEntryId(Restart_id); //e.g. msg_019835d44cd47796b0066c6e10951eac
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    function : TAsyncConversation
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.Conversations.Restart(ConvId,
//    procedure (Params: TConversationsParams)
//    begin
//      Params.Inputs('Name some dialects of French, such as Joual.');
//      Params.FromEntryId(Restart_id); //e.g. msg_019835d44cd47796b0066c6e10951eac
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```
<br>

___

#### Streamed

Refer to the [official documentation](https://docs.mistral.ai/api/#tag/beta.conversations/operation/agents_api_v1_conversations_restart_stream)

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  ConvId := 'conversation_id'; //e.g. conv_0198261f353271a4bd9e95ef32105994
  
  //Asynchronous promise example
  var Promise := Client.Conversations.AsyncAwaitRestartStream(ConvId,
    procedure (Params: TConversationsParams)
    begin
      Params.Inputs('Name some dialects of French, such as Joual.l');
      Params.FromEntryId(Restart_id); //e.g. msg_019835d44cd47796b0066c6e10951eac
      Params.Stream;
      Params.Store;
      Params.HandoffExecution('server');
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TPromiseConversationsEvent
    begin
      Result.Sender := TutorialHub;
      Result.OnProgress :=
        procedure (Sender: TObject; Event: TConversationsEvent)
        begin
          DisplayStream(Sender, Event);
        end;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation :=
        function (Sender: TObject): string
        begin
          Cancellation(Sender);
        end;
    end);

  Promise
    .&Then<string>(
       function (Value: string): string
       begin
         Result := Value;
         ShowMessage(Value);
       end)
    .Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Conversations.AsyncRestartStream(ConvId,
//    procedure (Params: TConversationsParams)
//    begin
//      Params.Inputs('Name some dialects of French, such as Joual.');
//      Params.FromEntryId(Restart_id); //e.g. msg_019835d44cd47796b0066c6e10951eac
//      Params.Stream;
//      Params.Store;
//      Params.HandoffExecution('server');
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    function : TAsyncConversationsEvent
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnProgress := DisplayStream;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  Client.Conversations.RestartStream(ConvId,
//    procedure (Params: TConversationsParams)
//    begin
//      Params.Inputs('Name some dialects of French, such as Joual.');
//      Params.FromEntryId(Restart_id); //e.g. msg_019835d44cd47796b0066c6e10951eac
//      Params.Stream;
//      Params.Store;
//      Params.HandoffExecution('server');
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    procedure(var Chunk: TConversationsEvent; IsDone: Boolean; var Cancel: Boolean)
//    begin
//      if (not IsDone) and Assigned(Chunk) then
//        begin
//          DisplayStream(TutorialHub, Chunk);
//        end;
//    end);
```

<br>

___


### List all created conversations

Refer to the [official documentation](https://docs.mistral.ai/api/#tag/beta.conversations/operation/agents_api_v1_conversations_list)

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

  //Asynchronous promise example
  var Promise := Client.Conversations.AsyncAwaitList(
    procedure (Params: TConversationsListParams)
    begin
      Params.Page(0);
      Params.PageSize(100);
    end);

  Promise
    .&Then<TConversationsList>(
      function (Value: TConversationsList): TConversationsList
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Conversations.AsyncList(
//    procedure (Params: TConversationsListParams)
//    begin
//      Params.Page(0);
//      Params.PageSize(100);
//    end,
//    function : TAsyncConversationsList
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.Conversations.List(
//    procedure (Params: TConversationsListParams)
//    begin
//      Params.Page(0);
//      Params.PageSize(100);
//    end);
//
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

### Retrieve all entries in a conversation

Refer to the [official documentation](https://docs.mistral.ai/api/#tag/beta.conversations/operation/agents_api_v1_conversations_history)

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  ConvId := 'conversation_id'; //e.g. conv_0198261f353271a4bd9e95ef32105994
  
  //Asynchronous promise example
  var Promise := Client.Conversations.AsyncAwaitGetHistory(ConvId);

  Promise
    .&Then<TRetrievedEntries>(
       function (Value: TRetrievedEntries): TRetrievedEntries
       begin
         Result := Value;
         Display(TutorialHub, Value);
       end)
    .Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Conversations.AsyncGetHistory(ConvId,
//    function : TAsyncRetrievedEntries
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.Conversations.GetHistory(ConvId);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

### Retrieve all messages in a conversation

Refer to the [official documentation](https://docs.mistral.ai/api/#tag/beta.conversations/operation/agents_api_v1_conversations_messages)

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  ConvId := 'conversation_id'; //e.g. conv_0198261f353271a4bd9e95ef32105994
  
  //Asynchronous promise example
  var Promise := Client.Conversations.AsyncAwaitGetMessages(ConvId);

  Promise
    .&Then<TRetrieveMessages>(
       function (Value: TRetrieveMessages): TRetrieveMessages
       begin
         Result := Value;
         Display(TutorialHub, Value);
       end)
    .Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Conversations.AsyncGetMessages(ConvId,
//    function : TAsyncRetrieveMessages
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.Conversations.GetMessages(ConvId);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

## Tools for conversations

Connectors are tools that conversations—or the agents driving them—can invoke at any point to fulfill requests. They are deployed and available for on-demand use within agent workflows.

Additionally, connectors can be called directly by users through the Conversations API without the need to create an agent first.

There are four primary tools available:
- **Web Search**
- **Code Interpreter**
- **Image Generation**
- **Document Library**

Additionally, **reasoning** can be treated as a de facto tool in its own right.

We do not provide code snippets that demonstrate direct use of the tools within conversations; instead, those tool-specific snippets are exposed via agents. Since a conversation can delegate to agents, this simplifies the tutorial.

Please refer to the [Conversation & Agents](https://github.com/MaxiDonkey/DelphiMistralAI/blob/main/guides/AgentsConnectors.md) section.

<br>

___

## Function calling

The step-by-step process is already covered in the [Function calling](https://github.com/MaxiDonkey/DelphiMistralAI/blob/main/guides/ChatCompletion.md#function-calling) section of the chat/completions chapter. Refer to that section for the general approach to invoking a function with DelphiMistralAI.
Here, we will only outline the specific differences applicable when using the v1/conversations endpoint.

 - [Display a stream text](#display-a-stream-text) 
 - [The main method](#the-main-method)
 - [The FinishReason](#the-finishreason)

<br>

___

### Display a stream text

```Pascal
procedure TVCLTutorialHub.WeatherFunctionEx(const Value: TMessageOutputEntry;
  Func: IFunctionCore);
begin
  var ArgResult := Func.Execute(Value.Arguments);

  FClient.Conversations.AsyncCreateStream(
    procedure (Params: TConversationsParams)
    begin
      Params.Instructions('Respond like a star weather presenter on a prime-time TV channel.');
      Params.Inputs(ArgResult);
      Params.Model('mistral-medium-2505');
      Params.Stream;
      Params.Store(False);
      Params.CompletionArgs(TCompletionArgsParams.Create
        .Temperature(0.3)
        .TopP(0.95)
      )
    end,
    function : TAsyncConversationsEvent
    begin
      Result.Sender := TutorialHub;
      Result.OnProgress := DisplayStream;
      Result.OnSuccess := Display;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
      Result.OnError := Display;
    end);
end;  
```
>[!NOTE]
>The same method also exists with the FMX version of the TutorialHub wizard.

<br>

___

### The main method

Building the query using the Weather tool. (Simply copy/paste this last code to test the usage of the functions.)

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL, MistralAI.Functions.Example or Mistral.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  var WeatherFunc: IFunctionCore := TWeatherReportFunction.Create;

  TutorialHub.Tool := WeatherFunc;
  TutorialHub.ToolCallEx := TutorialHub.WeatherFunctionEx;

  //Asynchronous example
  Client.Conversations.ASyncCreate(
    procedure (Params: TConversationsParams)
    begin
      Params.Model('mistral-large-latest');
      Params.Inputs('What''s the weather like in Paris temperature in celcius?');
      Params.Tools([TConnectorParams.New(WeatherFunc)]);
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsyncConversation
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br>

___

### The FinishReason

Let's look at how the display method handles the function call.

```Pascal
procedure Display(Sender: TObject; Value: TConversation);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Outputs do
  begin
    case Item.&Type of
      TConversatonEvent.function_call :
        TutorialHub.ToolCallEx(Item, TutorialHub.Tool);  //call the function execution

      TConversatonEvent.message_input,
      TConversatonEvent.message_output:
        begin
          for var SubItem in Item.Content do
            case SubItem.&Type of
              TContentChunkType.text:
                Display(Sender, SubItem.Text);

              TContentChunkType.tool_file:
                begin
                  case Subitem.Tool of
                    TConversationTool.image_generation:
                      TutorialHub.LoadImage(SubItem.FileId);
                  end;
                end;
            end;
        end;
    end;
  end;
end;
```

>[!CAUTION]
>Ensure user confirmation for actions like sending emails or making purchases to avoid unintended consequences.

<br>

___

## Structured Output

 - [Custom Structured Outputs](#custom-structured-outputs)
 - [JSON mode](#json-mode)

### Custom Structured Outputs

To activate JSON mode, set response_format to {"type":"json_object"}. This JSON output option is now supported for every model via our API.

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

  var Schema :=
    '{' +
    '    "schema": {' +
    '      "properties": {' +
    '        "name": {' +
    '          "title": "Name",' +
    '          "type": "string"' +
    '        },' +
    '        "authors": {' +
    '          "items": {' +
    '            "type": "string"' +
    '          },' +
    '          "title": "Authors",' +
    '          "type": "array"' +
    '        }' +
    '      },' +
    '      "required": ["name", "authors"],' +
    '      "title": "Book",' +
    '      "type": "object",' +
    '      "additionalProperties": false' +
    '    },' +
    '    "name": "book",' +
    '    "strict": true' +
    '  }';

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.Conversations.AsyncAwaitCreate(
    procedure (Params: TConversationsParams)
    begin
      Params.Model('mistral-large-latest');
      Params.Instructions('Extract the books information.');
      Params.Inputs('I recently read To Kill a Mockingbird by Harper Lee.');
      Params.CompletionArgs(
        TCompletionArgsParams.Create
          .ResponseFormat(Schema)
      );
      Params.Store(False);
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  promise
    .&Then<string>(
      function (Value: TConversation): string
      begin
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);
```

**Example output:**

```Json
{
 "name": "To Kill a Mockingbird",
 "authors": [
  "Harper Lee"
 ]
}
```

<br>

___

### JSON mode

By defining a strict JSON schema up front, Custom Structured Outputs compel the model to emit responses that match your exact structure—right down to field names and data types. In practice, this means you get reliably formatted JSON every time, with the correct keywords and types baked in.

Refer to the [official documentation](https://docs.mistral.ai/capabilities/structured-output/custom_structured_output/)

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.Conversations.AsyncAwaitCreate(
    procedure (Params: TConversationsParams)
    begin
      Params.Model('mistral-large-latest');
      Params.Inputs('What is the best French meal? Return the name and the ingredients in short JSON object.');
      Params.CompletionArgs(
        TCompletionArgsParams.Create
          .ResponseFormat(TResponseFormatParams.Json_Oject)
      );
      Params.Store(False);
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  promise
    .&Then<string>(
      function (Value: TConversation): string
      begin
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);
```

**Example output:**

```Json
{
  "name": "Boeuf Bourguignon",
  "ingredients": [
    "beef",
    "red wine",
    "carrots",
    "onions",
    "garlic",
    "bacon",
    "mushrooms",
    "herbs",
    "beef stock"
  ]
}
```

<br>

___

## Agents & connectors

An agent is a preconfigured entity that bundles a model, instructions, and tools to enrich and steer the model’s capabilities.
It’s used to automate and tailor interactions by supplying context and dedicated functionality without having to reconfigure for each request.

Follow the link to learn [how to create agents and use connectors](https://github.com/MaxiDonkey/DelphiMistralAI/blob/main/guides/AgentsConnectors.md).


# Embeddings (v1/embeddings)

- [Introduction](#introduction)
- [Text embeddings](#text-embeddings)
- [Code Embeddings](#code-embeddings)

<br>

___

## Introduction

Embeddings make it possible to vectorize one or more texts in order, for example, to calculate the similarity between sentences. Each vector resulted will be of dimension 1024. This vector representation captures deep semantic aspects of texts, allowing for more nuanced comparisons.
Distance measures such as cosine, Euclidean distance or other custom measures can be applied to these embeddings. 

See also [tokenization](https://docs.mistral.ai/guides/tokenization/) at the MistralAI web site.

<br>

___

## Text embeddings

The Mistral AI embeddings API lets you convert text into vector representations. You send a request with the list of texts to process and specify the `mistral-embed` model. The service returns a series of embeddings—numeric vectors—that can be used as the foundation for semantic analysis, indexing, or any other advanced logic within an NLP processing pipeline.

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.Embeddings.AsyncAwaitCreate(
    procedure (Params: TEmbeddingParams)
    begin
      Params.Model('mistral-embed');
      Params.Input([
        'Text to vectorize'
      ]);
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  promise
    .&Then<TEmbeddings>(
      function (Value: TEmbeddings): TEmbeddings
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Embeddings.AsyncCreate(
//    procedure (Params: TEmbeddingParams)
//    begin
//      Params.Model('mistral-embed');
//      Params.Input([
//        'Text to vectorize'
//      ]);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//
//    function : TAsyncEmbeddings
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Embeddings := Client.Embeddings.Create(
//    procedure (Params: TEmbeddingParams)
//    begin
//      Params.Model('mistral-embed');
//      Params.Input([
//        'Text to vectorize'
//      ]);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Embeddings);
//  finally
//    Embeddings.Free;
//  end;
```

<br>

___

## Code Embeddings

To produce code embeddings with Mistral AI’s `embeddings` API, send a request to the endpoint specifying the codestral-embed model and supplying the texts to embed. The API responds with numerical vector representations for each input, which can be consumed downstream in NLP workflows (e.g., similarity search, indexing, semantic analysis).

Two optional parameters let you tailor the output:

output_dtype controls the numeric format and precision of the embeddings:

- **float (default):** 32-bit single-precision floats, offering the highest fidelity and retrieval quality.

- **int8:** Signed 8-bit integers (−128 to 127).

- **uint8:** Unsigned 8-bit integers (0 to 255).

- **binary:** Bit-packed, quantized single-bit embeddings stored as int8; length is output_dimension / 8. Uses offset binary encoding.

- **ubinary:** Like binary but uses uint8 as the underlying container.

`output_dimension` lets you specify the embedding size. It defaults to 1536 and can be increased up to 3072. When you request a target dimension n, the API returns the first n components of the full embedding; those dimensions are ordered by relevance to provide a controlled quality/cost trade-off.

<br>

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

  var problem_description :=
    'Given an array of integers nums and an integer target, return indices of the two numbers '+
    'such that they add up to target. You may assume that each input would have exactly one '+
    'solution, and you may not use the same element twice. You can return the answer in any '+
    'order. Example 1: Input: nums = [2,7,11,15], target = 9 Output: [0,1] Explanation: Because '+
    'nums[0] + nums[1] == 9, we return [0, 1]. Example 2: Input: nums = [3,2,4], target = 6 Output: '+
    '[1,2] Example 3: Input: nums = [3,3], target = 6 Output: [0,1] Constraints: 2 <= nums.length <= '+
    '104 -109 <= nums[i] <= 109 -109 <= target <= 109 Only one valid answer exists.';

  var solution :=
    'class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: d = {} for i, '+
    'x in enumerate(nums): if (y := target - x) in d: return [d[y], i] d[x] = i';

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.Embeddings.AsyncAwaitCreate(
    procedure (Params: TEmbeddingParams)
    begin
      Params.Model('codestral-embed');
      Params.output_dimension(10);
      Params.output_dtype('binary');
      Params.Input([problem_description, solution]);
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  promise
    .&Then<TEmbeddings>(
      function (Value: TEmbeddings): TEmbeddings
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Embeddings.AsyncCreate(
//    procedure (Params: TEmbeddingParams)
//    begin
//      Params.Model('codestral-embed');
//      Params.output_dimension(10);
//      Params.output_dtype('binary');
//      Params.Input([problem_description, solution]);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//
//    function : TAsyncEmbeddings
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Embeddings := Client.Embeddings.Create(
//    procedure (Params: TEmbeddingParams)
//    begin
//      Params.Model('codestral-embed');
//      Params.output_dimension(10);
//      Params.output_dtype('binary');
//      Params.Input([problem_description, solution]);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Embeddings);
//  finally
//    Embeddings.Free;
//  end;
```

# Files (v1/files)

- [Introduction](#introduction)
- [Files managing](#files-managing)

<br>

___

## Introduction

The file management APIs play a key role in use cases such as fine-tuning and batch processing.

- For **fine-tuning**, they allow you to upload the necessary training and validation data files. These files can also be listed for review or management purposes.

- In **batch processing workflows**, files can be uploaded, retrieved, or deleted. Once processing is complete, a result file is generated and can be downloaded via the same APIs.

- During **image generation**, any generated files are automatically made available within the file management space. A **signed URL** can be constructed to enable direct access to these files.

<br>

___

## Files managing

- [List of files](#list-of-files)
- [File Retrieve](#file-retrieve)
- [File Upload](#file-upload)
- [File Delete](#file-delete)
- [File Download](#file-download) 
- [Get Signed Url](#get-signed-url) 

<br>

___

### List of files

To retrieve the list of files, proceed as follows.

1. The list can be paginated, and you can also specify the number of items to return as a parameter. Below is an example of code to display the first page:

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  TutorialHub.Page := 0;

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.&File.AsyncAwaitList(
    procedure (Params: TListParams)
    begin
      Params.PageSize(4);
    end);

  promise
    .&Then<TFiles>(
      function (Value: TFiles): TFiles
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.&File.ASyncList(
//    procedure (Params: TListParams)
//    begin
//      Params.PageSize(4);
//    end,
//    function : TAsyncFiles
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var List := Client.&File.List(
//    procedure (Params: TListParams)
//    begin
//      Params.PageSize(4);
//    end);
//  try
//    Display(TutorialHub, List);
//  finally
//    List.Free;
//  end;
```

<br>

2. To navigate to the next page, use the following code:

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  TutorialHub.NextPage;

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.&File.AsyncAwaitList(
    procedure (Params: TListParams)
    begin
      Params.Page(TutorialHub.Page);
      Params.PageSize(4);
    end);

  promise
    .&Then<TFiles>(
      function (Value: TFiles): TFiles
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.&File.ASyncList(
//    procedure (Params: TListParams)
//    begin
//      Params.Page(TutorialHub.Page);
//      Params.PageSize(4);
//    end,
//    function : TAsyncFiles
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var List := Client.&File.List(
//    procedure (Params: TListParams)
//    begin
//      Params.Page(TutorialHub.Page);
//      Params.PageSize(4);
//    end);
//  try
//    Display(TutorialHub, List);
//  finally
//    List.Free;
//  end;
``` 

<br>

___

### File Retrieve

To locate a file, you need to know its ID, which can be retrieved by displaying the list of files.

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  TutorialHub.FileId := 'id_file_to retrieve';  //e.g. 8c19c63e-c361-4034-9378-220c56e8c27b


  //Asynchronous promise example
  Display(TutorialHub, 'Please wait...');
  var Promise := Client.&File.AsyncAwaitRetrieve(TutorialHub.FileId);

  promise
    .&Then<TFile>(
      function (Value: TFile): TFile
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.&File.ASyncRetrieve(TutorialHub.FileId,
//    function : TAsyncFile
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Retrieve := Client.&File.Retrieve(TutorialHub.FileId);
//  try
//    Display(Memo1, Retrieve);
//  finally
//    Retrieve.Free;
//  end;
```

<br>

___

### File Upload

It is essential to populate the Purpose field to specify the category to which the file to be uploaded belongs. This can be, for instance, fine-tune or batch.

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  TutorialHub.FileName := 'FileName_to_upload';

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.&File.AsyncAwaitUpload(
    procedure (Params: TUploadParams)
    begin
      Params.Purpose(TFilePurpose.batch);
      // or Params.Purpose(TFilePurpose.finetune); ...
      Params.&File(TutorialHub.FileName);
    end);

  promise
    .&Then<TFile>(
      function (Value: TFile): TFile
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.&File.AsyncUpload(
//    procedure (Params: TUploadParams)
//    begin
//      Params.Purpose(TFilePurpose.batch);
//      // or Params.Purpose(TFilePurpose.finetune); ...
//      Params.&File(TutorialHub.FileName);
//    end,
//    function : TAsyncFile
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Upload := Client.&File.Upload(
//    procedure (Params: TUploadParams)
//    begin
//      Params.Purpose(TFilePurpose.finetune);
//      // or Params.Purpose(TFilePurpose.finetune); ...
//      Params.&File(TutorialHub.FileName);
//    end);
//  try
//    Display(Memo1, Upload);
//  finally
//    Upload.Free;
//  end;
```

<br>

___

### File Delete

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  TutorialHub.FileId := 'id_file_to_delete';

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.&File.AsyncAwaitDelete(TutorialHub.FileId);

  promise
    .&Then<TDeletedResult>(
      function (Value: TDeletedResult): TDeletedResult
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.&File.ASyncDelete(TutorialHub.FileId,
//    function : TAsyncFilesDelete
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Delete := Client.&File.Delete(TutorialHub.FileId);
//  try
//    Display(Memo1, Delete);
//  finally
//    Delete.Free;
//  end;
```

<br>

___

### File Download

Used to download a file generated following batch processing. To obtain the file ID, you need to view the list of available files. Alternatively, the ID can also be retrieved directly from the platform.

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  TutorialHub.FileId := 'if_file_to_download';
  TutorialHub.FileOverride := True;
  TutorialHub.FileName := 'ResultFile.ext';

  //Asynchronous promise example
  Display(TutorialHub, 'Please wait...');
  var Promise := Client.&File.AsyncAwaitDownload(TutorialHub.FileId);

  promise
    .&Then<TDownLoadFile>(
      function (Value: TDownLoadFile): TDownLoadFile
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.&File.ASyncDownload(TutorialHub.FileId,
//    function : TAsyncDownLoadFile
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Download := Client.&File.Download(TutorialHub.FileId);
//  try
//    Display(TutorialHub, Download);
//  finally
//    DownLoad.Free;
//  end;
```

<br>

___

### Get Signed Url

Retrieve a signed URL to the file with a defined expiration time.


```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  TutorialHub.FileId := 'id_file';

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.&File.AsyncAwaitGetSignedUrl(TutorialHub.FileId,
    procedure (Params: TSignedUrlParams)
    begin
      Params.Expiry(5);  //expires after 5 hours
    end);

  promise
    .&Then<TSignedUrl>(
      function (Value: TSignedUrl): TSignedUrl
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.&File.AsyncGetSignedUrl(TutorialHub.FileId,
//    procedure (Params: TSignedUrlParams)
//    begin
//      Params.Expiry(5);  //expires after 5 hours
//    end,
//    function : TAsyncSignedUrl
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.&File.GetSignedUrl(TutorialHub.FileId,
//    procedure (Params: TSignedUrlParams)
//    begin
//      Params.Expiry(5);  //expires after 5 hours
//    end);
//  try
//    Display(TutorialHub, Value.Url);
//  finally
//    Value.Free;
//  end;
```

**Example output:**

```Json
https://mistralaifilesapiprodswe.blob.core.windows.net/fine-tune/cd368904-ac72-4704-ae52-c35df79fe40f/714e2b3a-18a4-46d3-888c-823914ff0447/8c19c93ec96140349378220c56e8c17d.jpg?se=2025-08-01T19%3A18%3A18Z&sp=r&sv=2025-07-05&sr=b&sig=0FqNifAjs5dxfIp50lCHwjl6AlbnKsjEkfCYLQGvElU%3D
```

# Fill-in-the-middle (v1/fim/completions)

- [Code generation](#code-generation)
    - [Before using](#before-using)
    - [Codestral initialization](#codestral-initialization)
- [Code completion](#code-completion)
    - [Streamed Code completion](#streamed-code-completion)
- [Fill in the middle](#fill-in-the-middle)
- [Stop tokens](#stop-tokens)

<br>

___

## Code generation

**Codestral** is an advanced generative model optimized for code generation, including **fill-in-the-middle** and code completion. Trained on over 80 programming languages, it performs well on both common and rare languages.
See also [Code generation](https://docs.mistral.ai/capabilities/code_generation/) at the MistralAI web site.

<br/>

___

### Before using

To utilize the Delphi classes managing the **Codestral** function, you are required to create a new KEY on the ***Mistral.ai website***. Please note that obtaining this key necessitates providing a valid phone number. 
Go to this address to create a key for using **Codestral** [Key creation](https://console.mistral.ai/codestral)

<br/>

___

### Codestral initialization

When instantiating the interface managing the ***TMistralAI*** type class, the `CodestralSpec` specification must be specified in the `create` constructor.

The resulting interface will handle both **CodeStral** functionality as well as chat-type interactions.

```Pascal
uses MistralAI;

var CodingModel: IMistralAI := TMistralAI.Create(API_TOKEN, [CodestralSpec]);
```

You can also use the factory:
> [!NOTE]
> ```Pascal
> uses MistralAI;
>
> var CodingModel := TMistralAIFactory.CreateInstance(API_TOKEN, [CodestralSpec]);
> ```

<br/>

___

## Code completion

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  TutorialHub.Memo2.Text := CodeBefore;
  Start(TutorialHub);

  //Asynchronous promise example
  var Promise := ClientCoding.Codestral.AsyncAwaitCreate(
    procedure (Params: TCodestralParams)
    begin
      Params.Model('codestral-latest');
      Params.Prompt(CodeBefore);
      Params.MaxTokens(1024);
      Params.Stop(['\n\n']);
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  promise
    .&Then<string>(
      function (Value: TCodestral): string
      begin
        for var Item in Value.Choices do
          Result := Result + Item.Message.Content;
        Display(TutorialHub, Value);
        ShowMessage(Result);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  ClientCoding.Codestral.AsyncCreate(
//    procedure (Params: TCodestralParams)
//    begin
//      Params.Model('codestral-latest');
//      Params.Prompt(CodeBefore);
//      Params.MaxTokens(1024);
//      Params.Stop(['\n\n']);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    function : TAsynCode
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Codestral := ClientCoding.Codestral.Create(
//    procedure (Params: TCodestralParams)
//    begin
//      Params.Model('codestral-latest');
//      Params.Prompt(CodeBefore);
//      Params.MaxTokens(1024);
//      Params.Stop(['\n\n']);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, CodeStral);
//  finally
//    Codestral.Free;
//  end;
```

<br/>

___

### Streamed Code completion

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONResponseClear;
  Memo2.Text := string.Join(sLineBreak, [CodeBefore, '//Insert code here' + sLineBreak, CodeAfter]);

  //Asynchronous promise example
  var Promise := ClientCoding.Codestral.AsyncAwaitCreateStream(
    procedure(Params: TCodestralParams)
    begin
      Params.Model('codestral-latest');
      Params.Prompt(CodeBefore);
      Params.Suffix(CodeAfter);
      Params.MaxTokens(1024);
      Params.Stream;
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TPromiseCodeStream
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;

      Result.OnProgress :=
        procedure (Sender: TObject; Chunk: TCodestral)
        begin
          DisplayStream(Sender, Chunk);
        end;

      Result.OnDoCancel := DoCancellation;

      Result.OnCancellation :=
        function (Sender: TObject): string
        begin
          Cancellation(Sender);
        end
    end);

  Promise
    .&Then<string>(
      function (Value: string): string
      begin
        Result := Value;
        ShowMessage(Result);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  ClientCoding.Codestral.ASyncCreateStream(
//    procedure(Params: TCodestralParams)
//    begin
//      Params.Model('codestral-latest');
//      Params.Prompt(CodeBefore);
//      Params.MaxTokens(1024);
//      Params.Stream;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    function : TAsynCodeStream
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnProgress := DisplayStream;
//      Result.OnDoCancel := DoCancellation;
//      Result.OnCancellation := Cancellation;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  ClientCoding.Codestral.CreateStream(
//    procedure(Params: TCodestralParams)
//    begin
//      Params.Model('codestral-latest');
//      Params.Prompt(CodeBefore);
//      Params.MaxTokens(1024);
//      Params.Stream;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    procedure(var Code: TCodestral; IsDone: Boolean; var Cancel: Boolean)
//    begin
//      if (not IsDone) and Assigned(Code) then
//        begin
//          DisplayStream(TutorialHub, Code);
//        end
//    end);
```

<br/>

___

## Fill in the middle

This feature allows users to set the beginning of their code with a `prompt` and to specify the end of the code using an optional `suffix` and an optional `stop` condition. The Codestral model will then produce the code that seamlessly fits between these markers, making it perfect for tasks that need a particular segment of code to be created.

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONResponseClear;
  Memo2.Text := string.Join(sLineBreak, [CodeBefore, '//Insert code here' + sLineBreak, CodeAfter]);

  //Asynchronous promise example
  var Promise := ClientCoding.Codestral.AsyncAwaitCreateStream(
    procedure(Params: TCodestralParams)
    begin
      Params.Model('codestral-latest');
      Params.Prompt(CodeBefore);
      Params.Suffix(CodeAfter);
      Params.Stop(['\n\n']);
      Params.MaxTokens(1024);
      Params.Stream;
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TPromiseCodeStream
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;

      Result.OnProgress :=
        procedure (Sender: TObject; Chunk: TCodestral)
        begin
          DisplayStream(Sender, Chunk);
        end;

      Result.OnDoCancel := DoCancellation;

      Result.OnCancellation :=
        function (Sender: TObject): string
        begin
          Cancellation(Sender);
        end
    end);

  Promise
    .&Then<string>(
      function (Value: string): string
      begin
        Result := Value;
        ShowMessage(Result);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);
```

The model will create the intermediate code completing the codes provided to the `prompt` and `suffix` parameters.

<br/>

___

## Stop tokens

It is advisable to include stop tokens when integrating with IDE autocomplete to ensure the model doesn't provide overly verbose output.

```Pascal
// MistralAI, MistralAI.Types, MistralAI.Tutorial.FMX;

  TutorialHub.Memo2.Text := string.Join(sLineBreak, [CodeBefore, '//Insert code here'+sLineBreak, CodeAfter]); // For tutorial tool use only

  CodingModel.Codestral.ASyncCreateStream(
    procedure(Params: TCodestralParams)
    begin
      Params.Model('codestral-latest');
      Params.Prompt(CodeBefore);
      Params.Suffix(CodeAfter);
      Params.MaxTokens(1024);
      Params.Stream;
      Params.Stop(['\n\n']); // <-- Include here the strings responsible for stopping processing
    end,
    function : TAsynCodeStream
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnProgress := DisplayStream;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
      Result.OnError := Display;
    end); 
```

# Fine-tuning API  (v1/fine_tuning/jobs)

- [Introduction](#introduction)
- [Fine-tuning managing](#fine-tuning-managing)

<br>

___

## Introduction

When choosing between prompt engineering and fine-tuning for an AI model, it's advisable to start with prompt engineering due to its speed and lower resource requirements. Fine-tuning, however, offers better performance and alignment with specific tasks, making it ideal for specialized applications and cost reduction.

See also [Fine-tuning description](https://docs.mistral.ai/capabilities/finetuning/) at the **MistralAI** web site.

> [!TIP]
> Synchronous and asynchronous methods also exist for fine-tuning as well as file handling. See the TFilesRoute class in the MistralAI.Files unit and the TFineTuningRoute class in the MistralAI.FineTunings unit

<br/>

Data should be stored in **JSON** Lines files `(.jsonl)`, where each line corresponds to a separate **JSON object**. This format enables efficient storage of multiple **JSON objects**.

The datasets must adhere to an instruction-following format that simulates a conversation between a user and an assistant. Each JSON record should either contain only messages exchanged between the user and the assistant (referred to as ***"Default Instruct"***), or include additional logic for function calls (referred to as ***"Function-calling Instruct"***). 

See also [Default Instruct](https://docs.mistral.ai/capabilities/finetuning/#1-default-instruct) and [Function-calling Instruct](https://docs.mistral.ai/capabilities/finetuning/#2-function-calling-instruct)

**`Warning:`**
Please remember to remove any line breaks if you copy and paste the examples provided by Mistral AI for the "Dataset Format."

<br>

___

## Fine-tuning managing

The next step involves creating a fine-tuning job.

- **model**: Specify the model you want to fine-tune. Available options include "open-mistral-7b" and "mistral-small-latest"
- **training_files**: Provide one or more training file IDs.
- **validation_files**: Optionally provide one or more validation file IDs.
- **hyperparameters**: You can adjust two parameters: "training_step" and "learning_rate", based on your training requirements.


You can also manage fine-tuning jobs using the available List, Retrieve, and Cancel methods. For the Retrieve and Cancel operations, you will need to supply the job ID as a parameter.


### Operations
- [Create a Fine-tuning Job](#create-a-fine-tuning-job)
- [Delete a Fine-tuned Model](#delete-a-fine-tuned-model)
- [List of Fine-tune Job](#list-of-fine-tune-job)
- [Retrieve a Fine-tune Job](#retrieve-a-fine-tune-job)
- [Start a Fine-tune Job](#start-a-fine-tune-job)
- [Cancel a Fine-tune Job](#cancel-a-fine-tune-job)

<br>

___

### Create a Fine-tuning Job

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

  //Asynchronous promise example
  var Promise := Client.FineTuning.AsyncAwaitCreateJob(
    procedure (Params: TFineTuningJobParams)
    begin
      Params.Model('open-mistral-nemo');
      Params.TrainingFiles(['a3fddf94-2fc8-4b0e-9040-73c6a776f6b2']);
      Params.Hyperparameters(
        procedure (var Params: THyperparametersParams)
        begin
          Params.TrainingSteps(10);
          Params.LearningRate(0.0005);
        end);
      Params.Suffix('ft-model-01');
      Params.AutoStart(False);
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  Promise
    .&Then<TJobOut>(
      function (Value: TJobOut): TJobOut
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.FineTuning.AsyncCreateJob(
//    procedure (Params: TFineTuningJobParams)
//    begin
//      Params.Model('open-mistral-nemo');
//      Params.TrainingFiles(['a3fddf94-2fc8-4b0e-9040-73c6a776f6b2']);
//      Params.Hyperparameters(
//        procedure (var Params: THyperparametersParams)
//        begin
//          Params.TrainingSteps(10);
//          Params.LearningRate(0.0005);
//        end);
//      Params.Suffix('ft-model-01');
//      Params.AutoStart(False);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    function : TAsynJobOut
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var FineTuneJob := Client.FineTuning.CreateJob(
//    procedure (Params: TFineTuningJobParams)
//    begin
//      Params.Model('open-mistral-nemo');
//      Params.TrainingFiles(['a3fddf94-2fc8-4b0e-9040-73c6a776f6b2']);
//      Params.Hyperparameters(
//        procedure (var Params: THyperparametersParams)
//        begin
//          Params.TrainingSteps(10);
//          Params.LearningRate(0.0005);
//        end);
//      Params.Suffix('ft-model-01');
//      Params.AutoStart(False);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, FineTuneJob);
//  finally
//    FineTuneJob.Free;
//  end;
```

<br>

___

### Delete a Fine-tuned Model

`Note`: The method in charge of deleting a fine tuned model is found in the `MistralAI.Models.pas` unit.

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  with MistralAI.Models.Delete('Id_Model_to_delete') do
  try
    ShowMessage('Model Deleted');
  finally
    Free;
  end;
```

<br>

___

### List of Fine-tune Job

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

  //Asynchronous promise example
  var Promise := Client.FineTuning.AsyncAwaitList(
    procedure (Params: TFineTuningJobListParams)
    begin
      Params.Page(100);
    end);

  Promise
    .&Then<TListFineTuningJobs>(
      function (Value: TListFineTuningJobs): TListFineTuningJobs
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.FineTuning.ASyncList(
//    procedure (Params: TFineTuningJobListParams)
//    begin
//      Params.Page(100);
//    end,
//    function : TAsynListFineTuningJobs
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var List := Client.FineTuning.List(
//    procedure (Params: TFineTuningJobListParams)
//    begin
//      Params.Page(100);
//    end);
//  try
//    Display(TutorialHub, List);
//  finally
//    List.Free;
//  end;
```

>[!NOTE]
> You can use the pagination method described in the [`File List` section](https://github.com/MaxiDonkey/DelphiMistralAI/blob/main/guides/Files.md#list-of-files).
>

<br>

___

### Retrieve a Fine-tune Job

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  TutorialHub.JobId := 'job_id'; //e.g. '95a37dc0-8cd6-41d8-a505-53269047840a';

  //Asynchronous promise example
  var Promise := Client.FineTuning.AsyncAwaitRetrieve(TutorialHub.JobId);

  Promise
    .&Then<TJobOutProgress>(
      function (Value: TJobOutProgress): TJobOutProgress
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.FineTuning.ASyncRetrieve(TutorialHub.JobId,
//    function : TAsynJobOutProgress
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.FineTuning.Retrieve(TutorialHub.JobId);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

### Start a Fine-tune Job

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  TutorialHub.JobId := 'job_id'; //e.g. '95a37dc0-8cd6-41d8-a505-53269047840a';

  //Asynchronous promise example
  var Promise := Client.FineTuning.AsyncAwaitStart(TutorialHub.JobId);

  Promise
    .&Then<TJobOutProgress>(
      function (Value: TJobOutProgress): TJobOutProgress
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.FineTuning.ASyncStart(TutorialHub.JobId,
//    function : TAsynJobOutProgress
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.FineTuning.Start(TutorialHub.JobId);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

### Cancel a Fine-tune Job

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  TutorialHub.JobId := 'job_id'; //e.g. '95a37dc0-8cd6-41d8-a505-53269047840a';

  //Asynchronous promise example
  var Promise := Client.FineTuning.AsyncAwaitCancel(TutorialHub.JobId);

  Promise
    .&Then<TJobOutProgress>(
      function (Value: TJobOutProgress): TJobOutProgress
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.FineTuning.ASyncCancel(TutorialHub.JobId,
//    function : TAsynJobOutProgress
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.FineTuning.Cancel(TutorialHub.JobId);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

>[!WARNING]
> The APIs do not provide the ability to delete a fine-tuning job, and this limitation also applies to the platform. Consequently, creating a large number of jobs could become problematic over time.
>

# Libraries API - Access

- [Introduction](#introduction)
- [List all of the access to this library](#list-all-of-the-access-to-this-library)
- [Create or update an access level](#create-or-update-an-access-level)
- [Delete an access level](#delete-an-access-level)

<br>

___

## Introduction

The ***(beta) Libraries API – Access endpoints*** enable management of access rights for a library. They support three core operations:

- **Listing access:** Retrieve all entities (***users, workspaces, organizations***) that have permissions on a library, along with their access level.

- **Creating or updating access:** Grant or modify an entity’s permission level on a library. Only the library owner can share it or change others’ access. Owners cannot change their own role, and sharing is restricted to within the organization (external sharing is not allowed).

- **Deleting access:** Revoke an entity’s permission on a library. This operation also requires ownership, and an owner cannot remove their own access.

All access management requests require API key authentication. Entities are identified by type (***User, Workspace, Org***) and **UUID**, and when creating or updating access, a permission level such as `Viewer` or `Editor` must be specified.



<br>

___

## List all of the access to this library

Given a library, list all of the Entity that have access and to what level.

Refer to [official documentation](https://docs.mistral.ai/api/#tag/beta.libraries.accesses/operation/libraries_share_list_v1)

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  var lib_id := 'lib_id_to_retrieve'; //e.g. 0198502a-6f55-778e-6978-470167da0f28

  //Asynchronous promise example
  var Promise := Client.LibrariesAccess.AsyncAwaitList(lib_id);

  promise
    .&Then<TLibrariesAccessList>(
      function (Value: TLibrariesAccessList): TLibrariesAccessList
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.LibrariesAccess.AsyncList(lib_id,
//    function : TAsyncLibrariesAccessList
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.LibrariesAccess.List(lib_id);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

## Create or update an access level 

Given a library id, you can create or update the access level of an entity. You have to be owner of the library to share a library. An owner cannot change their own role. A library cannot be shared outside of the organization.

Authorizations:
ApiKey

Refer to [official documentation](https://docs.mistral.ai/api/#tag/beta.libraries.accesses/operation/libraries_share_create_v1)

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  var lib_id := 'lib_id_to_retrieve'; //e.g. 0198502a-6f55-778e-6978-470167da0f28
  var org_id := 'org_id'; //e.g. 4f36af3c-42f0-437d-a0c2-cdbfe421f348

  //Asynchronous promise example
  var Promise := Client.LibrariesAccess.AsyncAwaitCreateOrUpdate(Edit1.Text,
    procedure (Params: TAccessParams)
    begin
      Params.OrgId(org_id);
      Params.Level(TLevelType.viewer);
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  promise
    .&Then<TLibrariesAccess>(
      function (Value: TLibrariesAccess): TLibrariesAccess
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.LibrariesAccess.AsyncCreateOrUpdate(Edit1.Text,
//    procedure (Params: TAccessParams)
//    begin
//      Params.OrgId(org_id);
//      Params.Level(TLevelType.viewer);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    function : TAsyncLibrariesAccess
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.LibrariesAccess.CreateOrUpdate(Edit1.Text,
//    procedure (Params: TAccessParams)
//    begin
//      Params.OrgId(org_id);
//      Params.Level(TLevelType.viewer);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

## Delete an access level

Given a library id, you can delete the access level of an entity. An owner cannot delete it's own access. You have to be the owner of the library to delete an acces other than yours.

Refer to [official documentation](https://docs.mistral.ai/api/#tag/beta.libraries.accesses/operation/libraries_share_delete_v1)

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  var lib_id := 'lib_id_to_retrieve'; //e.g. 0198502a-6f55-778e-6978-470167da0f28
  var org_id := 'org_id'; //e.g. 4f36af3c-42f0-437d-a0c2-cdbfe421f348

  //Asynchronous promise example
  var Promise := Client.LibrariesAccess.AsyncAwaitDelete(lib_id,
    procedure (Params: TAccessParams)
    begin
      Params.OrgId(org_id);
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  promise
    .&Then<TLibrariesAccess>(
      function (Value: TLibrariesAccess): TLibrariesAccess
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);


  //Asynchronous example
//  Client.LibrariesAccess.AsyncDelete(lib_id,
//    procedure (Params: TAccessParams)
//    begin
//      Params.OrgId(org_id);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    function : TAsyncLibrariesAccess
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.LibrariesAccess.Delete(lib_id,
//    procedure (Params: TAccessParams)
//    begin
//      Params.OrgId(org_id);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

# Libraries API - Documents

- [Intoduction](#intoduction)
- [List document in a given library](#list-document-in-a-given-library)
- [Upload a new document](#upload-a-new-document)
- [Retrieve the metadata of a specific document](#retrieve-the-metadata-of-a-specific-document)
- [Update the metadata of a specific document](#update-the-metadata-of-a-specific-document)
- [Delete a document](#delete-a-document)
- [Retrieve the text content of a specific document](#retrieve-the-text-content-of-a-specific-document)
- [Retrieve the processing status of a specific document](#retrieve-the-processing-status-of-a-specific-document)
- [Retrieve the signed URL of a specific document](#retrieve-the-signed-url-of-a-specific-document)
- [Retrieve the signed URL of text extracted from a given document](#retrieve-the-signed-url-of-text-extracted-from-a-given-document)
- [Reprocess a document](#reprocess-a-document)

<br>

___

## Intoduction

***Document Library*** is a native connector that gives agents direct access to your documents hosted in **Mistral Cloud**. It serves as a dynamic knowledge base: you can list, sort, search, and leverage the documents to strengthen agent capabilities via a RAG integration. The library supports collection management, browsing recent documents, and easily fits into your existing workflows while respecting access controls and security best practices.

For detailed information on creating, modifying, deleting, and listing documents, please refer to the [Main API Libraries](https://github.com/MaxiDonkey/DelphiMistralAI/blob/main/guides/LibrariesMain.md#libraries-api---main) section.

<br>

___

## List document in a given library

Given a library, lists the document that have been uploaded to that library.

Refer to [official documentation](https://docs.mistral.ai/api/#tag/beta.libraries.documents/operation/libraries_documents_list_v1)

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  var lib_id := 'my_lib_id'; //e.g. 0198502a-6f55-778e-6978-470167da0f28


  //Asynchronous promise example
  var Promise := Client.LibrariesDocuments.AsyncAwaitList(lib_id,
    procedure (Params: TLibrariesDocumentsUrlParams)
    begin
      Params.PageSize(100);
      Params.Page(0);
      TutorialHub.JSONRequest := Params.Value;
    end);

  Promise
    .&Then<TLibrariesDocumentsList>(
      function (Value: TLibrariesDocumentsList): TLibrariesDocumentsList
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.LibrariesDocuments.AsyncList(lib_id,
//    procedure (Params: TLibrariesDocumentsUrlParams)
//    begin
//      Params.PageSize(100);
//      Params.Page(0);
//      TutorialHub.JSONRequest := Params.Value;
//    end,
//    function : TAsyncLibrariesDocumentsList
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.LibrariesDocuments.List(lib_id,
//    procedure (Params: TLibrariesDocumentsUrlParams)
//    begin
//      Params.PageSize(100);
//      Params.Page(0);
//      TutorialHub.JSONRequest := Params.Value;
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

## Upload a new document

Given a library, upload a new document to that library. It is queued for processing, it status will change it has been processed. The processing has to be completed in order be discoverable for the library search

Refer to [official documentation](https://docs.mistral.ai/api/#tag/beta.libraries.documents/operation/libraries_documents_upload_v1)

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  var lib_id := 'my_lib_id'; //e.g. 0198502a-6f55-778e-6978-470167da0f28

  //Asynchronous promise example
  var Promise := Client.LibrariesDocuments.AsyncAwaitUpload(lib_id,
    procedure (Params: TLibrariesDocumentsUploadParams)
    begin
      Params.&File('..\..\sample\File_Search_file.pdf');
      TutorialHub.JSONRequest := 'multipart/form-data';
    end);

  Promise
    .&Then<TLibrariesDocuments>(
      function (Value: TLibrariesDocuments): TLibrariesDocuments
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.LibrariesDocuments.AsyncUpload(lib_id,
//    procedure (Params: TLibrariesDocumentsUploadParams)
//    begin
//      Params.&File('..\..\sample\File_Search_file.pdf');
//      TutorialHub.JSONRequest := 'multipart/form-data';
//    end,
//    function : TAsyncLibrariesDocuments
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);


  //Synchronous example
//  var Value := Client.LibrariesDocuments.Upload(lib_id,
//    procedure (Params: TLibrariesDocumentsUploadParams)
//    begin
//      Params.&File('..\..\sample\File_Search_file.pdf');
//      TutorialHub.JSONRequest := 'multipart/form-data';
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

## Retrieve the metadata of a specific document

Given a library and a document in this library, you can retrieve the metadata of that document.

Refer to [official documentation](https://docs.mistral.ai/api/#tag/beta.libraries.documents/operation/libraries_documents_get_v1)

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  var lib_id := 'my_lib_id'; //e.g. 0198502a-6f55-778e-6978-470167da0f28
  var upload_id := 'my_upload_id'; //e.g. 3cece7413-3e66-42e4-9914-abdb42419dea

  //Asynchronous promise example
  var Promise := Client.LibrariesDocuments.AsyncAwaitRetrieve(lib_id, upload_id);

  Promise
    .&Then<TLibrariesDocuments>(
      function (Value: TLibrariesDocuments): TLibrariesDocuments
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.LibrariesDocuments.AsyncRetrieve(lib_id, upload_id,
//    function : TAsyncLibrariesDocuments
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.LibrariesDocuments.Retrieve(lib_id, upload_id);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

## Update the metadata of a specific document

Given a library and a document in that library, update the name of that document.

Refer to [official documentation](https://docs.mistral.ai/api/#tag/beta.libraries.documents/operation/libraries_documents_update_v1)

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  var lib_id := 'my_lib_id'; //e.g. 0198502a-6f55-778e-6978-470167da0f28
  var upload_id := 'my_upload_id'; //e.g. 3cece7413-3e66-42e4-9914-abdb42419dea

  //Asynchronous promise example
  var Promise := Client.LibrariesDocuments.AsyncAwaitUpdate(lib_id, upload_id,
    procedure (Params: TLibrariesDocumentsUpdateParams)
    begin
      Params.Name('Filename update');
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  Promise
    .&Then<TLibrariesDocuments>(
      function (Value: TLibrariesDocuments): TLibrariesDocuments
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.LibrariesDocuments.AsyncUpdate(lib_id, upload_id,
//    procedure (Params: TLibrariesDocumentsUpdateParams)
//    begin
//      Params.Name('Filename update');
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    function : TAsyncLibrariesDocuments
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.LibrariesDocuments.Update(lib_id, upload_id,
//    procedure (Params: TLibrariesDocumentsUpdateParams)
//    begin
//      Params.Name('Filename update');
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

## Delete a document

Given a library and a document in that library, delete that document. The document will be deleted from the library and the search index.

Refer to [official documentation](https://docs.mistral.ai/api/#tag/beta.libraries.documents/operation/libraries_documents_delete_v1)

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  var lib_id := 'my_lib_id'; //e.g. 0198502a-6f55-778e-6978-470167da0f28
  var upload_id := 'my_upload_id'; //e.g. 3cece7413-3e66-42e4-9914-abdb42419dea

  //Asynchronous promise example
  var Promise := Client.LibrariesDocuments.AsyncAwaitDelete(lib_id, upload_id);

  Promise
    .&Then<TLibraryDocumentsProcessed>(
      function (Value: TLibraryDocumentsProcessed): TLibraryDocumentsProcessed
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.LibrariesDocuments.AsyncDelete(lib_id, upload_id,
//    function : TAsyncLibraryDocumentsProcessed
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.LibrariesDocuments.Delete(lib_id, upload_id);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

## Retrieve the text content of a specific document

Given a library and a document in that library, you can retrieve the text content of that document if it exists. For documents like pdf, docx and pptx the text content results from our processing using Mistral OCR.

Refer to [official documentation](https://docs.mistral.ai/api/#tag/beta.libraries.documents/operation/libraries_documents_get_text_content_v1)

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  var lib_id := 'my_lib_id'; //e.g. 0198502a-6f55-778e-6978-470167da0f28
  var upload_id := 'my_upload_id'; //e.g. 3cece7413-3e66-42e4-9914-abdb42419dea

  //Asynchronous promise example
  var Promise := Client.LibrariesDocuments.AsyncAwaitRetrieveText(lib_id, upload_id);

  Promise
    .&Then<TLibraryDocumentsText>(
      function (Value: TLibraryDocumentsText): TLibraryDocumentsText
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.LibrariesDocuments.AsyncRetrieveText(lib_id, upload_id,
//    function : TAsyncLibraryDocumentsText
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.LibrariesDocuments.RetrieveText(lib_id, upload_id);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

## Retrieve the processing status of a specific document

Given a library and a document in that library, retrieve the processing status of that document.

Refer to [official documentation](https://docs.mistral.ai/api/#tag/beta.libraries.documents/operation/libraries_documents_get_status_v1)

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  var lib_id := 'my_lib_id'; //e.g. 0198502a-6f55-778e-6978-470167da0f28
  var upload_id := 'my_upload_id'; //e.g. 3cece7413-3e66-42e4-9914-abdb42419dea

  //Asynchronous promise example
  var Promise := Client.LibrariesDocuments.AsyncAwaitRetrieveStatus(lib_id, upload_id);

  Promise
    .&Then<TLibraryDocumentsStatus>(
      function (Value: TLibraryDocumentsStatus): TLibraryDocumentsStatus
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.LibrariesDocuments.AsyncRetrieveStatus(lib_id, upload_id,
//    function : TAsyncLibraryDocumentsStatus
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.LibrariesDocuments.RetrieveStatus(lib_id, upload_id);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

## Retrieve the signed URL of a specific document

Given a library and a document in that library, retrieve the signed URL of a specific document.The url will expire after 30 minutes and can be accessed by anyone with the link.

Refer to [official documentation](https://docs.mistral.ai/api/#tag/beta.libraries.documents/operation/libraries_documents_get_signed_url_v1)

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;
  
  TutorialHub.JSONRequestClear;
  var lib_id := 'my_lib_id'; //e.g. 0198502a-6f55-778e-6978-470167da0f28
  var upload_id := 'my_upload_id'; //e.g. 3cece7413-3e66-42e4-9914-abdb42419dea

  //Asynchronous promise example
  var Promise := Client.LibrariesDocuments.AsyncAwaitGetDocumentSignedUrl(lib_id, upload_id);

  Promise
    .&Then<TSignedUrl>(
      function (Value: TSignedUrl): TSignedUrl
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.LibrariesDocuments.AsyncGetDocumentSignedUrl(lib_id, upload_id,
//    function : TAsyncSignedUrl
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.LibrariesDocuments.GetDocumentSignedUrl(lib_id, upload_id);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

## Retrieve the signed URL of text extracted from a given document

Given a library and a document in that library, retrieve the signed URL of text extracted. For documents that are sent to the OCR this returns the result of the OCR queries.

Refer to [official documentation](https://docs.mistral.ai/api/#tag/beta.libraries.documents/operation/libraries_documents_get_extracted_text_signed_url_v1)

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  var lib_id := 'my_lib_id'; //e.g. 0198502a-6f55-778e-6978-470167da0f28
  var upload_id := 'my_upload_id'; //e.g. 3cece7413-3e66-42e4-9914-abdb42419dea

  //Asynchronous promise example
  var Promise := Client.LibrariesDocuments.AsyncAwaitGetTextSignedUrl(lib_id, upload_id);

  Promise
    .&Then<TSignedUrl>(
      function (Value: TSignedUrl): TSignedUrl
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.LibrariesDocuments.AsyncGetTextSignedUrl(lib_id, upload_id,
//    function : TAsyncSignedUrl
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.LibrariesDocuments.GetTextSignedUrl(lib_id, upload_id);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

## Reprocess a document

Given a library and a document in that library, reprocess that document, it will be billed again.

Refer to [official documentation](https://docs.mistral.ai/api/#tag/beta.libraries.documents/operation/libraries_documents_reprocess_v1)

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  var lib_id := 'my_lib_id'; //e.g. 0198502a-6f55-778e-6978-470167da0f28
  var upload_id := 'my_upload_id'; //e.g. 3cece7413-3e66-42e4-9914-abdb42419dea

  //Asynchronous promise example
  var Promise := Client.LibrariesDocuments.AsyncAwaitReprocess(lib_id, upload_id);

  Promise
    .&Then<TLibraryDocumentsProcessed>(
      function (Value: TLibraryDocumentsProcessed): TLibraryDocumentsProcessed
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.LibrariesDocuments.AsyncReprocess(lib_id, upload_id,
//    function : TAsyncLibraryDocumentsProcessed
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.LibrariesDocuments.Reprocess(lib_id, upload_id);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

# Libraries API - Main

- [Introduction](#introduction)
- [List all libraries you have access to](#list-all-libraries-you-have-access-to)
- [Create a new Library](#create-a-new-library)
- [Detailed information about a specific Library](#detailed-information-about-a-specific-library)
- [Delete a library and all of it's document](#delete-a-library-and-all-of-its-document)
- [Update a library](#update-a-library)

<br>

___

## Introduction

A ***Library*** is a logical container and access interface for curated knowledge used by agents to augment their reasoning. It encapsulates collections of content, supports listing, sorting, and search semantics, and serves as the primary entry point for pulling in relevant context. Libraries enable dynamic, contextual enrichment without prescribing the underlying content format, making them a flexible backbone for RAG-enabled systems.

<br>

___

## List all libraries you have access to

List all libraries that you have created or have been shared with you.

Refer to [official documentation](https://docs.mistral.ai/api/#tag/beta.libraries/operation/libraries_list_v1)

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

  //Asynchronous promise example
  var Promise := Client.LibrariesMain.AsyncAwaitList;

  promise
    .&Then<TLibrariesMainList>(
      function (Value: TLibrariesMainList): TLibrariesMainList
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.LibrariesMain.AsyncList(
//    function : TAsyncLibrariesMainList
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.LibrariesMain.List;
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

## Create a new Library

Create a new Library, you will be marked as the owner and only you will have the possibility to share it with others. When first created this will only be accessible by you.

Refer to [official documentation](https://docs.mistral.ai/api/#tag/beta.libraries/operation/libraries_create_v1)

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;
  
  TutorialHub.JSONRequestClear;

  //Asynchronous promise example
  var Promise := Client.LibrariesMain.AsyncAwaitCreate(
    procedure (Params: TLibrariesMainParams)
    begin
      Params.Name('first lib');
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  promise
    .&Then<TLibrariesMain>(
      function (Value: TLibrariesMain): TLibrariesMain
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.LibrariesMain.AsyncCreate(
//    procedure (Params: TLibrariesMainParams)
//    begin
//      Params.Name('first lib');
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    function : TAsyncLibrariesMain
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.LibrariesMain.Create(
//    procedure (Params: TLibrariesMainParams)
//    begin
//      Params.Name('first lib');
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

## Detailed information about a specific Library

Given a library id, details information about that Library.

Refer to [official documentation](https://docs.mistral.ai/api/#tag/beta.libraries/operation/libraries_get_v1)

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  var lib_id := 'lib_id_to_retrieve'; //e.g. 0198502a-6f55-778e-6978-470167da0f28

  //Asynchronous promise example
  var Promise := Client.LibrariesMain.AsyncAwaitRetrieve(lib_id);

  promise
    .&Then<TLibrariesMain>(
      function (Value: TLibrariesMain): TLibrariesMain
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.LibrariesMain.AsyncRetrieve(lib_id,
//    function : TAsyncLibrariesMain
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.LibrariesMain.Retrieve(lib_id);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

## Delete a library and all of it's document

Given a library id, deletes it together with all documents that have been uploaded to that library.

Refer to [official documentation](https://docs.mistral.ai/api/#tag/beta.libraries/operation/libraries_delete_v1)

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  var lib_id := 'lib_id_to_retrieve'; //e.g. 0198502a-6f55-778e-6978-470167da0f28

  //Asynchronous promise example
  var Promise := Client.LibrariesMain.AsyncAwaitDelete(lib_id);

  promise
    .&Then<TLibrariesMain>(
      function (Value: TLibrariesMain): TLibrariesMain
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.LibrariesMain.AsyncDelete(lib_id,
//    function : TAsyncLibrariesMain
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.LibrariesMain.Delete(lib_id);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

## Update a library

Given a library id, you can update the name and description.

Refer to [official documentation](https://docs.mistral.ai/api/#tag/beta.libraries/operation/libraries_update_v1)

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  var lib_id := 'lib_id_to_retrieve'; //e.g. 0198502a-6f55-778e-6978-470167da0f28

  //Asynchronous promise example
  var Promise := Client.LibrariesMain.AsyncAwaitUpdate(lib_id,
    procedure (Params: TUpdateLibrariesMainParams)
    begin
      Params.Name('vector modified');
      Params.Description('librarie modified');
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  promise
    .&Then<TLibrariesMain>(
      function (Value: TLibrariesMain): TLibrariesMain
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.LibrariesMain.AsyncUpdate(lib_id,
//    procedure (Params: TUpdateLibrariesMainParams)
//    begin
//      Params.Name('fisrt vector modified');
//      Params.Description('librarie modified');
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    function : TAsyncLibrariesMain
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.LibrariesMain.Update(lib_id,
//    procedure (Params: TUpdateLibrariesMainParams)
//    begin
//      Params.Name('fisrt vector modified');
//      Params.Description('librarie modified');
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

# Model Management API (v1/models)

- [Introduction](#introduction)
- [Retrieve the list of models](#retrieve-the-list-of-models)
- [Retrieve a model](#retrieve-a-model)
- [Fine tuned models](#fine-tuned-models)


<br>

___

## Introduction

The current model ecosystem is structured around clearly defined use cases: reasoning, code generation, multimodal processing (text, image, audio), transcription, embeddings, and content moderation. All models are accessible through a unified and versioned API, ensuring long-term stability and traceability while enabling gradual adoption of the latest iterations.

Each model category is designed to address specific constraints: depth of reasoning, context window size, low latency, or multimodal input support. The system follows a continuous update cycle, with frequent releases of improved versions and a controlled deprecation timeline for older ones.

Models are grouped into two main families: proprietary models optimized for industrial-grade performance, and open-source models under the Apache 2 license, allowing flexible integration, including on-prem deployment or custom pipelines. The size granularity (mini, small, medium, large) enables precise tuning of trade-offs between performance, cost, and memory footprint.

Finally, the platform encourages early adoption of new versions while maintaining the backward compatibility required for critical environments. Each model is accessible through a dedicated endpoint, with versioned documentation available to support continuous integration and evolution.

For more details on the available models, please refer to the [Models Documentation](https://docs.mistral.ai/models/)

<br>

___

## Retrieve the list of models

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.Models.AsyncAwaitList;

  promise
    .&Then<TModels>(
      function (Value: TModels): TModels
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Models.AsyncList(
//    function : TAsynModels
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Models := Client.Models.List;
//  try
//    Display(TutorialHub, Models);
//  finally
//    Models.Free;
//  end;
```

<br>

___

## Retrieve a model

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.Models.AsyncAwaitRetrieve('mistral-large-2407');

  promise
    .&Then<TModel>(
      function (Value: TModel): TModel
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Models.AsyncRetrieve('mistral-large-2407',
//    function : TAsynModel
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Model := Client.Models.Retrieve('mistral-large-2407');
//  try
//    Display(TutorialHub, Model);
//  finally
//    Model.Free;
//  end;
```

<br>

___

## Fine tuned models

Fine-tuned models can be managed through various operations, including deletion, renaming, archiving, and unarchiving. To perform these actions, the following functions are available in both synchronous and asynchronous modes:

**Synchronous Mode:** 
```Pascal
- function Delete(const ModelId: string): TModelDeletion;
- function Update(const ModelId: string; ParamProc: TProc<TModelParams>): TFineTunedModel;
- function Archive(const ModelId: string): TArchivingModel;
- function Unarchive(const ModelId: string): TArchivingModel;
```

**Asynchronous Mode:** 
```Pascal
- procedure AsyncDelete(const ModelId: string; const CallBacks: TFunc<TAsynModelDeletion>);
- procedure AsyncUpdate(const ModelId: string; ParamProc: TProc<TModelParams>;
      const CallBacks: TFunc<TAsynFineTuneModel>);
- procedure AsyncArchive(const ModelId: string; const CallBacks: TFunc<TAsynArchivingModel>);
- procedure AsyncUnarchive(const ModelId: string; const CallBacks: TFunc<TAsynArchivingModel>);
```

These functions provide a flexible and comprehensive approach to maintaining and organizing fine-tuned models.


# OCR API (v1/ocr)

- [Basic OCR](#basic-ocr)
   - [Example 1](#example-1)
- [Annotations](#annotations)
   - [BBox Annotation](#bbox-annotation)
   - [Document Annotation](#document-annotation)
   - [BBoxes Annotation and Document Annotation](#bboxes-annotation-and-document-annotation)
- [Document QnA](#document-qna)

<br>

___

## Basic OCR

The Mistral Document AI API includes a high-performance **OCR (Optical Character Recognition)*** processor, powered by the `mistral-ocr-latest` model. It enables accurate extraction of text and document structure from a wide variety of digital formats.

### Key Features
- **Text recognition with structural preservation** <br> 
Extracts content while **retaining the logical structure** of the document :

   - Headers, paragraphs, lists, and tables

   - Complex layouts like multi-column formats and mixed content (text + visuals)

- **Markdown output format** <br>
Results are returned in **Markdown**, making it easy to:

   - Preview content

   - Parse programmatically

   - Render in UI components or markdown-based workflows

- **Multi-format support**

   - Images (`image_url`): `.png`, `.jpeg/.jpg`, `.avif`, and more

   - Documents (`document_url`): `.pdf`, `.pptx`, `.docx`, and others

- **Scalable & accurate**

   - Optimized for **large-scale processing** with **high accuracy**, even on complex layouts.

- **Rich output**

   - The processor returns:

        - **Recognized text**

        - **Bounding boxes for images**

        - **Metadata** about the document’s structure

- Enables **fine-grained, programmable access** to the document’s content.

### In Summary

Mistral's `OCR engine` doesn’t just read text—it **understands and preserves document layout and semantics**, offering a **robust foundation** for downstream use cases like data extraction, content analysis, summarization, or advanced annotation.

<br>

### Example 1

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.Ocr.AsyncAwaitCreate(
    procedure (Params: TOcrParams)
    begin
      Params.Model('mistral-ocr-latest');
      Params.Document(
        TOcrDocumentParams.NewDocument
          .DocumentUrl('..\..\sample\File_Search_file.pdf'));
      Params.IncludeImageBase64;
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  Promise
    .&Then<TOcr>(
      function (Value: TOcr): TOcr
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Ocr.AsyncCreate(
//    procedure (Params: TOcrParams)
//    begin
//      Params.Model('mistral-ocr-latest');
//      Params.Document(
//        TOcrDocumentParams.NewDocument
//          .DocumentUrl('..\..\sample\File_Search_file.pdf'));
//      Params.IncludeImageBase64;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    function : TAsyncOcr
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.Ocr.Create(
//    procedure (Params: TOcrParams)
//    begin
//      Params.Model('mistral-ocr-latest');
//      Params.Document(
//        TOcrDocumentParams.NewDocument
//          .DocumentUrl('..\..\sample\File_Search_file.pdf'));
//      Params.IncludeImageBase64;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    TutorialHub.JSONResponse := Value.JSONResponse;
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

## Annotations

In addition to basic OCR, Mistral Document AI offers advanced annotation capabilities that enable structured information extraction in a custom JSON format defined by the user. This system supports two main types of annotations:

### Types of Annotations

1. `bbox_annotation`
Used to annotate specific visual elements within a document based on bounding boxes (e.g., figures, tables, charts, or signatures). This allows users to extract visual components according to their requirements and convert them into structured outputs. It also supports tasks like describing or captioning figures based on their content and layout.

2. `document_annotation`
Applies structured annotations at the document level. The user provides a target JSON structure, and the model extracts and maps relevant information from the entire document to match this structure. This is useful for turning semi-structured or unstructured content into machine-usable data.

### Key Capabilities
- Extraction of structured data from documents using a predefined schema.

- Automated data annotation and labeling, reducing manual processing effort.

- Minimization of input errors through consistent parsing.

- Scalability to handle high document volumes in enterprise contexts.

- Support for visual, textual, and semantic data processing.

### Common Use Cases

- Automated extraction of fields from forms or scanned documents.

- Document classification with metadata tagging (e.g., invoices, receipts, contracts).

- Conversion of charts and figures into structured data (e.g., tables).

- Extraction of key information from financial documents: 

    - From receipts: merchant name, date, total amount.

    - From invoices: supplier name, line items, tax values.

    - From contracts: key clauses, deadlines, and legal terms.

- Detection and annotation of fine print, footnotes, watermarks, and signatures.

### Annotations Explanation Graph

An optional component that provides a visual and logical trace of how annotations were derived. This can help with model validation, transparency, and debugging.

### Summary

Mistral Document AI is designed not just to recognize text, but to interpret and structure document content according to business-specific needs. Its annotation features make it especially well-suited for high-volume, high-accuracy use cases in fields such as finance, legal, compliance, and enterprise document management.

If you’d like, I can provide an example JSON schema or walk through a specific integration scenario.

<br>

### BBox Annotation

- [Example 2](#example-2)
- [Example 3](#example-3)

#### Example 2

The request is structured to ensure that the response adheres to the specified custom JSON schema. The schema defines the structure of a bbox_annotation object with image_type, short_description and summary properties.

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  Client.HttpClient.ResponseTimeout := 1200000;

  var Annotations :=
    '{' +
    '  "schema": {' +
    '      "properties": {' +
    '          "document_type": {"title": "Document_Type", "type": "string"},' +
    '          "short_description": {"title": "Short_Description", "type": "string"},' +
    '          "summary": {"title": "Summary", "type": "string"}' +
    '      },' +
    '      "required": ["document_type", "short_description", "summary"],' +
    '      "title": "BBOXAnnotation",' +
    '      "type": "object",' +
    '      "additionalProperties": false' +
    '  },' +
    '  "name": "document_annotation",' +
    '  "strict": true' +
    '}';

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.Ocr.AsyncAwaitCreate(
    procedure (Params: TOcrParams)
    begin
      Params.Model('mistral-ocr-latest');
      Params.Document(
        TOcrDocumentParams.NewDocument
          .DocumentUrl('https://arxiv.org/pdf/2410.07073'));
      Params.BboxAnnotationFormat(TResponseFormatParams.Json_Schema(Annotations));
      Params.IncludeImageBase64;
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  Promise
    .&Then<TOcr>(
      function (Value: TOcr): TOcr
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Ocr.AsyncCreate(
//    procedure (Params: TOcrParams)
//    begin
//      Params.Model('mistral-ocr-latest');
//      Params.Document(
//        TOcrDocumentParams.NewDocument
//          .DocumentUrl('https://arxiv.org/pdf/2410.07073'));
//      Params.BboxAnnotationFormat(TResponseFormatParams.Json_Schema(Annotations));
//      Params.IncludeImageBase64;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    function : TAsyncOcr
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.Ocr.Create(
//    procedure (Params: TOcrParams)
//    begin
//      Params.Model('mistral-ocr-latest');
//      Params.Document(
//        TOcrDocumentParams.NewDocument
//          .DocumentUrl('https://arxiv.org/pdf/2410.07073'));
//      Params.BboxAnnotationFormat(TResponseFormatParams.Json_Schema(Annotations));
//      Params.IncludeImageBase64;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    TutorialHub.JSONResponse := Value.JSONResponse;
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

#### Example 3

You can also add a description key in your properties object. The description will be used as detailed information and instructions during the annotation; for example:

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  Client.HttpClient.ResponseTimeout := 1200000;

  var Annotations :=
    '{' +
    '        "schema": {' +
    '            "properties": {' +
    '                "document_type": {"title": "Document_Type", "description": "The type of the image.", "type": "string"},' +
    '                "short_description": {"title": "Short_Description", "description": "A description in English describing the image.", "type": "string"},' +
    '                "summary": {"title": "Summary", "description": "Summarize the image.", "type": "string"}' +
    '            },' +
    '            "required": ["document_type", "short_description", "summary"],' +
    '            "title": "BBOXAnnotation",' +
    '            "type": "object",' +
    '            "additionalProperties": false' +
    '        },' +
    '        "name": "document_annotation",' +
    '        "strict": true' +
    '    }';

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.Ocr.AsyncAwaitCreate(
    procedure (Params: TOcrParams)
    begin
      Params.Model('mistral-ocr-latest');
      Params.Document(
        TOcrDocumentParams.NewDocument
          .DocumentUrl('https://arxiv.org/pdf/2410.07073'));
      Params.BboxAnnotationFormat(TResponseFormatParams.Json_Schema(Annotations));
      Params.IncludeImageBase64;
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  Promise
    .&Then<TOcr>(
      function (Value: TOcr): TOcr
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Ocr.AsyncCreate(
//    procedure (Params: TOcrParams)
//    begin
//      Params.Model('mistral-ocr-latest');
//      Params.Document(
//        TOcrDocumentParams.NewDocument
//          .DocumentUrl('https://arxiv.org/pdf/2410.07073'));
//      Params.BboxAnnotationFormat(TResponseFormatParams.Json_Schema(Annotations));
//      Params.IncludeImageBase64;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    function : TAsyncOcr
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.Ocr.Create(
//    procedure (Params: TOcrParams)
//    begin
//      Params.Model('mistral-ocr-latest');
//      Params.Document(
//        TOcrDocumentParams.NewDocument
//          .DocumentUrl('https://arxiv.org/pdf/2410.07073'));
//      Params.BboxAnnotationFormat(TResponseFormatParams.Json_Schema(Annotations));
//      Params.IncludeImageBase64;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    TutorialHub.JSONResponse := Value.JSONResponse;
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

### Document Annotation

The request is structured to ensure that the response adheres to the specified custom JSON schema. The schema defines the structure of a document_annotation object with with language, chapter_titles and urls properties.

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  Client.HttpClient.ResponseTimeout := 1200000;

  var Annotations :=
    '{' +
    '        "schema": {' +
    '            "properties": {' +
    '                "language": {"title": "Language", "type": "string"},' +
    '                "chapter_titles": {"title": "Chapter_Titles", "type": "string"},' +
    '                "urls": {"title": "urls", "type": "string"}' +
    '            },' +
    '            "required": ["language", "chapter_titles", "urls"],' +
    '            "title": "DocumentAnnotation",' +
    '            "type": "object",' +
    '            "additionalProperties": false' +
    '        },' +
    '        "name": "document_annotation",' +
    '        "strict": true' +
    '    }';

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.Ocr.AsyncAwaitCreate(
    procedure (Params: TOcrParams)
    begin
      Params.Model('mistral-ocr-latest');
      Params.Document(
        TOcrDocumentParams.NewDocument
          .DocumentUrl('https://arxiv.org/pdf/2410.07073'));
      Params.Pages([0, 1, 2, 3, 4, 5, 6, 7]);
      Params.DocumentAnnotationFormat(TResponseFormatParams.Json_Schema(Annotations));
      Params.IncludeImageBase64;
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  Promise
    .&Then<TOcr>(
      function (Value: TOcr): TOcr
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Ocr.AsyncCreate(
//    procedure (Params: TOcrParams)
//    begin
//      Params.Model('mistral-ocr-latest');
//      Params.Document(
//        TOcrDocumentParams.NewDocument
//          .DocumentUrl('https://arxiv.org/pdf/2410.07073'));
//      Params.Pages([0, 1, 2, 3, 4, 5, 6, 7]);
//      Params.BboxAnnotationFormat(TResponseFormatParams.Json_Schema(Annotations));
//      Params.IncludeImageBase64;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    function : TAsyncOcr
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.Ocr.Create(
//    procedure (Params: TOcrParams)
//    begin
//      Params.Model('mistral-ocr-latest');
//      Params.Document(
//        TOcrDocumentParams.NewDocument
//          .DocumentUrl('https://arxiv.org/pdf/2410.07073'));
//      Params.Pages([0, 1, 2, 3, 4, 5, 6, 7]);
//      Params.BboxAnnotationFormat(TResponseFormatParams.Json_Schema(Annotations));
//      Params.IncludeImageBase64;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    TutorialHub.JSONResponse := Value.JSONResponse;
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```
___

### BBoxes Annotation and Document Annotation

- [Example 4](#example-4)
- [Example 5](#example-5)

<br>

___

#### Example 4

The request is structured to ensure that the response adheres to the specified custom JSON schema. The schema defines the structure of a bbox_annotation object with image_type, short_description and summary properties and a document_annotation object with with language, chapter_titles and urls properties.

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  Client.HttpClient.ResponseTimeout := 1200000;

  var BoxAnnotations :=
    '{' +
    '        "schema": {' +
    '            "properties": {' +
    '                "document_type": {"title": "Document_Type", "description": "The type of the image.", "type": "string"},' +
    '                "short_description": {"title": "Short_Description", "description": "A description in English describing the image.", "type": "string"},' +
    '                "summary": {"title": "Summary", "description": "Summarize the image.", "type": "string"}' +
    '            },' +
    '            "required": ["document_type", "short_description", "summary"],' +
    '            "title": "BBOXAnnotation",' +
    '            "type": "object",' +
    '            "additionalProperties": false' +
    '        },' +
    '        "name": "document_annotation",' +
    '        "strict": true' +
    '    }';

  var DocumentAnnotations :=
    '{' +
    '        "schema": {' +
    '            "properties": {' +
    '                "language": {"title": "Language", "type": "string"},' +
    '                "chapter_titles": {"title": "Chapter_Titles", "type": "string"},' +
    '                "urls": {"title": "urls", "type": "string"}' +
    '            },' +
    '            "required": ["language", "chapter_titles", "urls"],' +
    '            "title": "DocumentAnnotation",' +
    '            "type": "object",' +
    '            "additionalProperties": false' +
    '        },' +
    '        "name": "document_annotation",' +
    '        "strict": true' +
    '    }';

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.Ocr.AsyncAwaitCreate(
    procedure (Params: TOcrParams)
    begin
      Params.Model('mistral-ocr-latest');
      Params.Document(
        TOcrDocumentParams.NewDocument
          .DocumentUrl('https://arxiv.org/pdf/2410.07073'));
      Params.Pages([0, 1, 2, 3, 4, 5, 6, 7]);
      Params.BBoxAnnotationFormat(TResponseFormatParams.Json_Schema(BoxAnnotations));
      Params.DocumentAnnotationFormat(TResponseFormatParams.Json_Schema(DocumentAnnotations));
      Params.IncludeImageBase64;
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  Promise
    .&Then<TOcr>(
      function (Value: TOcr): TOcr
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Ocr.AsyncCreate(
//    procedure (Params: TOcrParams)
//    begin
//      Params.Model('mistral-ocr-latest');
//      Params.Document(
//        TOcrDocumentParams.NewDocument
//          .DocumentUrl('https://arxiv.org/pdf/2410.07073'));
//      Params.Pages([0, 1, 2, 3, 4, 5, 6, 7]);
//      Params.BboxAnnotationFormat(TResponseFormatParams.Json_Schema(Annotations));
//      Params.IncludeImageBase64;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    function : TAsyncOcr
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.Ocr.Create(
//    procedure (Params: TOcrParams)
//    begin
//      Params.Model('mistral-ocr-latest');
//      Params.Document(
//        TOcrDocumentParams.NewDocument
//          .DocumentUrl('https://arxiv.org/pdf/2410.07073'));
//      Params.Pages([0, 1, 2, 3, 4, 5, 6, 7]);
//      Params.BboxAnnotationFormat(TResponseFormatParams.Json_Schema(Annotations));
//      Params.IncludeImageBase64;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    TutorialHub.JSONResponse := Value.JSONResponse;
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;  
```

<br>

___

#### Example 5

You can also add a description key in you properties object. The description will be used as detailed information and instructions during the annotation; for example:

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;
  Client.HttpClient.ResponseTimeout := 1200000;

  var BoxAnnotations :=
    '{' +
    '        "schema": {' +
    '            "properties": {' +
    '                "document_type": {"title": "Document_Type", "description": "The type of the image.", "type": "string"},' +
    '                "short_description": {"title": "Short_Description", "description": "A description in English describing the image.", "type": "string"},' +
    '                "summary": {"title": "Summary", "description": "Summarize the image.", "type": "string"}' +
    '            },' +
    '            "required": ["document_type", "short_description", "summary"],' +
    '            "title": "BBOXAnnotation",' +
    '            "type": "object",' +
    '            "additionalProperties": false' +
    '        },' +
    '        "name": "document_annotation",' +
    '        "strict": true' +
    '    }';

  var DocumentAnnotations :=
    '{' +
    '        "schema": {' +
    '            "properties": {' +
    '                "language": {"title": "Language", "type": "string"},' +
    '                "chapter_titles": {"title": "Chapter_Titles", "type": "string"},' +
    '                "urls": {"title": "urls", "type": "string"}' +
    '            },' +
    '            "required": ["language", "chapter_titles", "urls"],' +
    '            "title": "DocumentAnnotation",' +
    '            "type": "object",' +
    '            "additionalProperties": false' +
    '        },' +
    '        "name": "document_annotation",' +
    '        "strict": true' +
    '    }';

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.Ocr.AsyncAwaitCreate(
    procedure (Params: TOcrParams)
    begin
      Params.Model('mistral-ocr-latest');
      Params.Document(
        TOcrDocumentParams.NewDocument
          .DocumentUrl('https://arxiv.org/pdf/2410.07073'));
      Params.BBoxAnnotationFormat(TResponseFormatParams.Json_Schema(BoxAnnotations));
      Params.DocumentAnnotationFormat(TResponseFormatParams.Json_Schema(DocumentAnnotations));
      Params.IncludeImageBase64;
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  Promise
    .&Then<TOcr>(
      function (Value: TOcr): TOcr
      begin
        Result := Value;
        Display(TutorialHub, Value);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);

  //Asynchronous example
//  Client.Ocr.AsyncCreate(
//    procedure (Params: TOcrParams)
//    begin
//      Params.Model('mistral-ocr-latest');
//      Params.Document(
//        TOcrDocumentParams.NewDocument
//          .DocumentUrl('https://arxiv.org/pdf/2410.07073'));
//      Params.Pages([0, 1, 2, 3, 4, 5, 6, 7]);
//      Params.BboxAnnotationFormat(TResponseFormatParams.Json_Schema(Annotations));
//      Params.IncludeImageBase64;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    function : TAsyncOcr
//    begin
//      Result.Sender := TutorialHub;
//      Result.OnStart := Start;
//      Result.OnSuccess := Display;
//      Result.OnError := Display;
//    end);

  //Synchronous example
//  var Value := Client.Ocr.Create(
//    procedure (Params: TOcrParams)
//    begin
//      Params.Model('mistral-ocr-latest');
//      Params.Document(
//        TOcrDocumentParams.NewDocument
//          .DocumentUrl('https://arxiv.org/pdf/2410.07073'));
//      Params.Pages([0, 1, 2, 3, 4, 5, 6, 7]);
//      Params.BboxAnnotationFormat(TResponseFormatParams.Json_Schema(Annotations));
//      Params.IncludeImageBase64;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    TutorialHub.JSONResponse := Value.JSONResponse;
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;  
```

<br>

___

## Document QnA

The **Document QnA** feature combines Optical Character Recognition (OCR) with the power of a **large language model (LLM)** to enable **natural language interaction with document content**.

In practical terms, this means you can **ask questions directly about a document**—as if you were speaking to a subject matter expert—and receive **precise, context-aware answers** derived from the actual content.

<br>

### How It Works

The workflow consists of two main steps:

1. **Document Processing**

OCR analyzes the document to extract raw text, structural elements (headings, sections, tables, etc.), and formatting. The result is a machine-readable version of the document, ready for semantic analysis.

2. **Language Model Understanding**

The extracted content is passed to a** large language model**, which interprets the document in full. Users can then **ask natural language questions**, and the model provides answers that take into account the **full context and internal relationships** of the document.

<br>

### Key Capabilities

- **Natural language question answering** about specific document content

- **Targeted information extraction** without manual review

- **Automatic summarization** of key points

- **In-depth document analysis** (inference, reformulation, comparisons)

- **Multi-document querying** and content comparison

- **Context-aware responses** based on the document as a whole

<br>

### Common Use Cases

- **Analyzing research papers or technical reports** <br>
Example: extract experimental results or understand the methodology section.

- **Extracting structured information from business documents** <br>
Example: locate a contract number, payment terms, or approval conditions.

- **Processing legal and regulatory documents** <br>
Example: identify obligations, penalty clauses, or termination terms in a contract.

- **Building document-based Q&A applications** <br>
Example: create internal chatbots to assist with policy documents or compliance reports.

- **Automating document-driven workflows** <br>
Example: pre-validate annex content or auto-fill forms from PDF data.

<br>

### Summary

**Document QnA** turns static files like PDFs or scans into interactive information sources, accessible via natural language. It's especially well-suited for use cases that require fast, reliable, and structured access to complex content—such as legal, research, finance, and compliance workflows.

The examples below show how to interact with a PDF document using natural language:

### Upload the Image File

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  //Synchronous example
  var Upload := Client.&File.Upload(
    procedure (Params: TUploadParams)
    begin
      Params.Purpose(TFilePurpose.ocr);
      Params.&File('..\..\sample\File_Search_file.pdf');
    end);
  try
    Display(Memo1, Upload);
    //get id_file
  finally
    Upload.Free;
  end;
```

### Get the Signed URL

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  //Synchronous example
  var Value := Client.&File.GetSignedUrl(id_file,
    procedure (Params: TSignedUrlParams)
    begin
      Params.Expiry(24);  //expires after 24 hours
    end);
  try
    Display(TutorialHub, Value.Url);
  //get signed_url
  finally
    Value.Free;
  end;
```

### Chat Completion

```Pascal
//uses MistralAI, MistralAI.Types, MistralAI.Tutorial.VCL or MistralAI.Tutorial.FMX;

  TutorialHub.JSONRequestClear;

  var SignedUrl := 'signed_url';

  //Asynchronous promise example
  Start(TutorialHub);
  var Promise := Client.Chat.AsyncAwaitCreate(
    procedure (Params: TChatParams)
    begin
      Params.Model('mistral-small-latest');
      Params.Messages([
        Payload.User(
          'what is the last sentence in the document',
          TDocumentUrlParams.New.DocumentUrl(SignedUrl)
        )
      ]);
      Params.DocumentImageLimit(8);
      Params.DocumentPageLimit(64);
      TutorialHub.JSONRequest := Params.ToFormat();
    end);

  promise
    .&Then<string>(
      function (Value: TChat): string
      begin
        for var Item in Value.Choices do
          Result := Result + Item.Message.Content[0].Text;
        Display(TutorialHub, Value);
        ShowMessage(Result);
      end)
    .&Catch(
      procedure (E: Exception)
      begin
        Display(TutorialHub, E.Message);
      end);
```

# Partie 3: Changelog

### 2025, august 3 - version 1.3.0
- Http request monitoring.
- Injectable HTTP Methods (GET, POST, PUT, PATCH) for Simplified Mocking.
- Dunit-Powered Unit Testing for Effortless Execution of All Tests.
- New endpoints enabling an agentic approach:
   - Added `v1/conversations` and `v1/agents`, enabling agentic behaviors and integration with tools such as the code interpreter, web search, and libraries.
- Direct access to documentary content:
   - Introduced `v1/libraries`, `v1/libraries/{library_id}/documents`, and `v1/libraries/{library_id}/share` endpoints to manage, access, and share one or more document resources with fine-grained control.
- Audio processing:
  - Added the `v1/audio/transcriptions` endpoint for transcribing audio files.
- Embedding audio files in chat sessions:
  - Enabled inclusion of audio files directly within a chat session to enrich context or drive processing.
- Optical character recognition (OCR):
  - Provided the `v1/ocr` endpoint to extract information from a wide variety of digital formats.


## 2025, january 2 - version 1.2.0 (Getit version)
- Integrating Moderation Service APIs.
- Integrating Batch Inference.
- Revision of the Simplified Unit Declaration.
- Adding Tools to Simplify the Tutorial.
- Various Code Fixes.
- README.md Revision.


#Partie 4: Analyse du projet DelphiMistralAI

Analyse du projet DelphiMistralAI
Qualité de la documentation
La documentation de DelphiMistralAI est particulièrement soignée et exhaustive. Le README principal fait office de tutoriel complet, guidant pas à pas le développeur dans l’utilisation de la bibliothèque. On y trouve une table des matières structurée couvrant tous les aspects de l’API Mistral (génération de texte, embeddings, chat, vision, audio, moderation, fine-tuning, etc.)
github.com
en.delphipraxis.net
. Chaque section est agrémentée d’explications claires et de nombreux exemples de code en Delphi. Voici quelques points forts de la documentation :
Exhaustivité : Tous les endpoints de l’API MistralAI sont documentés avec leur équivalent dans la bibliothèque. Un tableau récapitulatif indique même la couverture fonctionnelle (presque tous les endpoints v1 sont pris en charge, y compris les plus récents en beta comme Conversations, Agents, Libraries, etc.). Les fonctionnalités vont de la génération de texte basique aux outils agentiques avancés (recherche web, exécution de code, génération d’images, OCR…) intégrés via l’endpoint v1/conversations. La doc mentionne explicitement le support de modèles spécialisés comme voxtral (voix), devstral (code/Codestral), mistral-ocr (vision) ou magistral (raisonnement), ce qui montre que la lib est à jour sur les capacités de MistralAI
github.com
.
Clarté et organisation : Le contenu est bien structuré avec des titres explicites et des sous-sections logiques. Chaque fonctionnalité (ex: listage des modèles, création d’un chat, upload de fichier, etc.) possède sa sous-section dédiée, avec distinction entre l’utilisation synchrone et asynchrone lorsque applicable. Des encadrés Important, Note, Tip sont utilisés pour attirer l’attention sur des points cruciaux (par ex. la nécessité de définir les clients globaux dans OnCreate, la gestion de la fermeture de l’appli si des requêtes sont en cours, etc.). L’ensemble est rédigé en anglais simple et compréhensible, ce qui le rend accessible même pour les non-anglophones techniques.
Exemples concrets : Pour chaque endpoint ou cas d’usage, la doc fournit du code Delphi prêt à l’emploi, souvent en double version synchrone et asynchrone. Par exemple, la section Chats montre comment appeler le modèle en mode bloquant classique, puis comment gérer la réponse en streaming, et enfin comment utiliser les méthodes asynchrones avec callbacks
github.com
github.com
. Ces exemples concrets, immédiatement exploitables, permettent de tester et comprendre facilement le fonctionnement de l’API. La doc insiste aussi sur les particularités (ex: comment passer des images aux modèles visuels via URL ou base64, avec l’ajout d’une surcharge de Payload.User pour inclure des références d’images
github.com
). Ce niveau de détail pédagogique est rare dans une bibliothèque open-source.
Mises à jour et références : La documentation semble suivre de très près l’évolution de l’API Mistral. Un lien vers un Changelog détaille les nouveautés, et un badge indique une mise à jour récente (août 2025). De plus, le README renvoie fréquemment à la documentation officielle de MistralAI pour les concepts sous-jacents, ce qui complète utilement les explications (par ex. lien vers la doc Mistral pour la tokenization, pour le prompting, etc.). Le fait que le projet soit également disponible via l’outil GetIt d’Embarcadero est mentionné, gage qu’il est facilement accessible et intégré à l’écosystème Delphi
en.delphipraxis.net
.
En somme, la documentation de DelphiMistralAI est d’une qualité professionnelle. Elle sert non seulement de guide d’utilisation, mais aussi de support pédagogique pour approfondir ses connaissances sur les LLMs et l’API de Mistral. L’auteur a visiblement conçu le README comme un tutoriel éducatif plutôt qu’une simple référence technique
en.delphipraxis.net
, ce qui est extrêmement bénéfique pour la communauté.
Qualité du code
Le code de la bibliothèque semble bien architecturé et suit les bonnes pratiques de conception modernes en Delphi. Bien qu’une analyse complète du code source nécessiterait une lecture approfondie, plusieurs indices dans la documentation et les discussions permettent de juger de sa qualité :
Couverture complète de l’API : La structure du code reflète fidèlement l’API Mistral. Par exemple, l’interface principale IMistralAI sert de point d’entrée et expose des sous-objets pour chaque groupe de fonctionnalités (Models, Chat, Files, FineTuning, etc.), ce qui permet un accès unifié et cohérent à tous les endpoints. Les exemples montrent des appels tels que MistralAI.Models.List ou MistralAI.Chat.Create, indiquant une organisation objet bien pensée où chaque domaine fonctionnel est encapsulé dans une classe ou interface dédiée. Cette modularité facilite la maintenance et l’évolution du code lorsque de nouveaux endpoints sont ajoutés.
Conception asynchrone robuste : DelphiMistralAI gère de façon transparente le double mode synchrone/asynchrone pour quasiment toutes les méthodes
github.com
. Sous le capot, l’auteur a mis en place le pattern des Promises et des callbacks génériques pour gérer l’asynchronicité de manière propre et non bloquante
en.delphipraxis.net
. La présence de types génériques comme TAsyncCallBack<T> ou TAsyncStreamCallBack<T> (définis dans MistralAI.Async.Support.pas) montre une volonté d’unifier le modèle de callback et d’éviter la duplication de code
github.com
github.com
. Ce design générique, couplé aux exemples fournis (utilisation de Result.OnStart, Result.OnSuccess, Result.OnError dans les callbacks), rend le code asynchrone assez lisible pour l’appelant. De plus, la bibliothèque intègre un mécanisme de streaming pour recevoir les réponses partielles des modèles en temps réel, avec la possibilité d’interrompre le flux (via un bouton qui invoque OnDoCancel, géré dans le callback)
github.com
. Tout ceci reflète une maîtrise des techniques de concurrence et une attention aux détails (gestion de l’annulation, etc.), ce qui est un signe de code de qualité.
Architecture et testabilité : L’auteur a prévu dès le départ une architecture mockable et modulaire. D’après les informations fournies, la couche HTTP utilisée pour contacter l’API peut être injectée (via l’inversion de dépendance), ce qui permet de la remplacer par un stub lors des tests unitaires
en.delphipraxis.net
. Cette approche de Dependency Injection est assez rare en Delphi pour être soulignée : elle facilite grandement les tests automatisés et garantit une séparation des responsabilités (la logique de la bibliothèque n’est pas couplée à un client HTTP spécifique). Par ailleurs, la présence de DUnit test helpers indique que l’auteur a probablement inclus des utilitaires pour écrire des tests unitaires plus facilement, gage qu’il a une démarche orientée vers la fiabilité du code. L’ensemble du code semble donc conçu pour être maintenable et extensible. Le fait que toutes les interactions HTTP soient centralisées via une interface injectable est un plus indéniable pour la qualité du code et la pérennité du projet.
Style et idiomes Delphi : Les extraits de code fournis montrent un style idiomatique et moderne en Object Pascal. Par exemple, l’utilisation de records structurés pour packager les callbacks, l’usage de classes helper (Payload.User(...) pour créer des messages utilisateur, etc.), ou encore la mise en place d’une factory (TMistralAIFactory.CreateInstance) pour obtenir l’interface principale, sont autant de choix de conception qui rendent l’API simple à utiliser côté développeur. Le code gère explicitement la mémoire (objets créés libérés dans des try..finally), ce qui témoigne de bonnes pratiques de gestion des ressources en Delphi. On note également que l’auteur fournit des unités utilitaires (ex: MistralAI.Tutorial.VCL/FMX) pour abstraire la partie IHM lors des démos, ce qui maintient le cœur du code propre, focalisé sur l’appel API.
En synthèse, la qualité du code semble très élevée pour un projet open-source Delphi. L’architecture est réfléchie (interfaces, factory, DI, callbacks génériques) et couvre un large éventail de fonctionnalités sans sacrifier la clarté pour l’utilisateur final. Il est à noter que l’auteur mentionne ne pas être un développeur de métier mais un mathématicien de formation, revenu à Delphi récemment
en.delphipraxis.net
 – pourtant, le résultat démontre une rigueur et une adoption des meilleures pratiques qui sont dignes d’un développement professionnel.
Aspect pédagogique et montée en compétence
L’un des points forts de DelphiMistralAI est son orientation pédagogique prononcée. La manière dont la documentation et les outils sont conçus vise clairement à accélérer la montée en compétence des développeurs Delphi sur les LLM et l’API MistralAI. Plusieurs éléments en témoignent :
README tutoriel : Comme mentionné plus haut, le README sert de guide pas-à-pas. Ce choix de présenter la bibliothèque sous forme de tutoriel est excellent pour apprendre progressivement. L’auteur couvre d’abord l’initialisation (obtention de la clé API, création du client), puis guide à travers des cas d’usage concrets, du plus simple au plus avancé. Chaque notion nouvelle (par ex. le mode conversation agentique vs le mode chat simple) est introduite avec explication et comparatif
github.com
github.com
. Cette progression structurée facilite l’apprentissage par la pratique. L’auteur a d’ailleurs adopté la même approche sur toutes ses bibliothèques (OpenAI, HuggingFace, etc.), signe d’une réelle volonté pédagogique
en.delphipraxis.net
.
Exemples prêts à l’emploi : La présence systématique d’exemples de code fonctionnels est un vrai plus pour la montée en compétence. Le développeur peut copier-coller ces snippets dans son propre projet ou, mieux, utiliser les projets exemples fournis. En effet, le dépôt inclut dans le dossier sample deux archives ZIP (VCL et FMX) qui servent de sandbox pour tester toutes les fonctionnalités présentées dans le tutoriel. Ces projets préconfigurés contiennent l’infrastructure (forms avec composants TMemo et TButton, instantiation du TutorialHub, etc.) permettant d’exécuter directement les exemples du README
github.com
github.com
. Cette initiative est extrêmement pédagogique car elle réduit la barrière à l’entrée : en quelques minutes on peut faire tourner des appels à l’API MistralAI dans un projet Delphi sans avoir à tout configurer soi-même. On apprend en modifiant les exemples fournis, ce qui est idéal pour progresser rapidement.
Outils d’assistance à l’apprentissage : Au-delà de la documentation écrite, l’auteur a développé des outils pour aider à explorer et comprendre la bibliothèque. Il mentionne le projet file2knowledge
en.delphipraxis.net
en.delphipraxis.net
, qui utilise l’IA (via OpenAI) pour permettre de poser des questions sur la documentation et le code. Ce projet, combiné à DelphiMistralAI, forme un véritable laboratoire éducatif où l’on peut interroger les fichiers sources et la doc pour éclaircir un point technique. C’est une approche innovante pour monter en compétence, en tirant parti de l’IA elle-même pour accélérer l’apprentissage de l’API. De plus, la bibliothèque en elle-même intègre des facilités comme le monitoring des requêtes HTTP en cours (HttpMonitoring.IsBusy) pour éviter des erreurs courantes (fermeture de l’appli pendant des appels asynchrones)
github.com
. Ces petits trucs et astuces disséminés dans la doc montrent l’attention portée à l’expérience développeur et à l’apprentissage des bonnes pratiques.
Communauté et support : Bien que récent, le projet dispose déjà de discussions GitHub et l’auteur est actif sur les forums (Delphi Praxis, etc.). Il invite aux retours et suggestions
en.delphipraxis.net
, signe qu’il se soucie de l’amélioration continue du projet et de l’accompagnement des utilisateurs. La disponibilité via GetIt facilite la diffusion auprès de la communauté Delphi, y compris ceux qui ne suivent pas GitHub de près. Tout cela contribue à créer un environnement propice pour un développeur qui souhaite apprendre à utiliser les modèles MistralAI dans Delphi : il a à la fois les outils, la doc, et la possibilité d’échanger avec le créateur en cas de besoin.
En résumé, DelphiMistralAI est un projet exemplaire du point de vue pédagogique. Que l’on soit débutant en API d’IA ou développeur Delphi aguerri, la ressource permet d’apprendre rapidement à intégrer des LLM dans ses applications. La courbe de progression est grandement facilitée par les explications claires, les exemples concrets et les outils mis à disposition. L’utilisateur est accompagné étape par étape, ce qui accélère sa montée en compétence sur ces technologies complexes.
Conclusion
Pour conclure, DelphiMistralAI apparaît comme une bibliothèque Delphi de très haute qualité, tant du point de vue de son code que de sa documentation. Le code est propre, moderne et bien structuré, couvrant l’ensemble des fonctionnalités de l’API MistralAI tout en offrant flexibilité (mode synchrone/asynchrone, extensibilité via DI). La documentation, quant à elle, est remarquable de pédagogie et de richesse, faisant office de tutoriel complet pour qui veut se lancer dans l’IA générative avec Delphi. En termes de qualité logicielle, ce projet n’a rien à envier à des bibliothèques officielles : on y retrouve tests, injection de dépendances, gestion fine de la mémoire et des threads, etc., le tout open-source et régulièrement mis à jour. Du côté utilisateur, l’expérience est fluide grâce aux nombreux exemples et outils d’accompagnement. En définitive, mon avis sur ce projet est extrêmement positif. DelphiMistralAI démontre ce qu’un développeur passionné peut accomplir pour rendre accessible une technologie pointue (les LLM de Mistral) à une communauté spécifique (les développeurs Delphi). La qualité de la doc facilite l’adoption rapide, l’aspect pédagogique accélère la montée en compétences, et la qualité du code inspire confiance pour une utilisation en conditions réelles. C’est donc une ressource à recommander chaleureusement pour tout Delphiiste intéressé par l’intégration de l’IA dans ses applications
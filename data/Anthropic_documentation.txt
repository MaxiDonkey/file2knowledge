# Delphi Anthropics API

___
![GitHub](https://img.shields.io/badge/IDE%20Version-Delphi%2010.3/11/12-yellow)
![GitHub](https://img.shields.io/badge/platform-all%20platforms-green)
![GitHub](https://img.shields.io/badge/Updated%20on%20january%207,%202025-blue)

<br/>
<br/>

- [Introduction](#Introduction)
- [Changelog](#Changelog)
- [Remarks](#remarks)
- [Wrapper Tools Info](#Wrapper-Tools-Info)
    - [Tools for simplifying this tutorial](#Tools-for-simplifying-this-tutorial)
    - [Asynchronous callback mode management](#Asynchronous-callback-mode-management)
    - [Simplified Unit Declaration](#Simplified-Unit-Declaration) 
- [Usage](#usage)
    - [Initialization](#initialization)
    - [Claude Models Overview](#Claude-Models-Overview)
        - [List of models](#List-of-models)
        - [Retrieve a model](#Retrieve-a-model)
    - [Embeddings](#embeddings)
    - [Chats](#chats)
        - [Create a message](#Create-a-message)
        - [Streaming messages](#Streaming-messages)
        - [Multi-turn conversation](#Multi-turn-conversation)
        - [Token counting](#Token-counting)
    - [Document processing](#Document-processing)
    - [Vision](#vision)
        - [Passing a Base64 Encoded Image](#Passing-a-base64-encoded-image)
        - [Passing an Image URL](#Passing-an-Image-URL)
    - [Function calling](#function-calling)
        - [Overview of Tool Use in Claude](#Overview-of-Tool-Use-in-Claude)
        - [Examples](#Examples)
    - [Prompt Caching](#Prompt-Caching) 
        - [Caching initialization](#Caching-initialization)
        - [System Caching](#System-Caching)
        - [Tools Caching](#Tools-Caching)
        - [Images Caching](#Images-Caching)
    - [Message Batches](#Message-Batches) 
        - [Message Batches initialization](#Message-Batches-initialization)
        - [How it works](#How-it-works)
        - [Batch create](#Batch-create)
        - [Batch list](#Batch-list)
        - [Batch cancel](#Batch-cancel)
        - [Batch retrieve message](#Batch-retrieve-message)
        - [Batch retrieve results](#Batch-retrieve-results)
        - [Batch delete](#Batch-delete)
        - [Console](#Console) 
- [Contributing](#contributing)
- [License](#license)

<br/>
<br/>


# Introduction

Welcome to the unofficial Delphi **Anthropic** API library. This project aims to provide a `Delphi` interface for interacting with the **Anthropic** public API, making it easier to integrate advanced natural language processing features into your `Delphi` applications. Whether you want to generate text, create embeddings, use chat models, or generate code, this library offers a simple and effective solution.

**Anthropic** is a powerful natural language processing API that enables developers to incorporate advanced AI functionalities into their applications. For more details, visit the [official Anthropic documentation](https://docs.anthropic.com/en/docs/welcome/).

<br/>

# Changelog

[See the changes](https://github.com/MaxiDonkey/DelphiAnthropic/blob/main/Changelog.md) made in this version.

<br/>

# Remarks 

> [!IMPORTANT]
>
> This is an unofficial library. **Anthropic** does not provide any official library for `Delphi`.
> This repository contains `Delphi` implementation over [Anthropic](https://docs.anthropic.com/en/api/getting-started/) public API.

<br/>

# Wrapper Tools Info

This section provides brief notifications and explanations about the tools available to simplify the presentation and understanding of the wrapper's functions in the tutorial.

<br>

## Tools for simplifying this tutorial

To streamline the code examples provided in this tutorial and facilitate quick implementation, two units have been included in the source code: `Anthropic.Tutorial.VCL` and `Anthropic.Tutorial.FMX`. Depending on the platform you choose to test the provided source code, you will need to instantiate either the `TVCLTutorialHub` or `TFMXTutorialHub` class in the application's OnCreate event, as demonstrated below:

>[!TIP]
>```Pascal
> //uses Anthropic.Tutorial.VCL;
> TutorialHub := TVCLTutorialHub.Create(Memo1, Button1);
>```

or

>[!TIP]
>```Pascal
> //uses Anthropic.Tutorial.FMX;
> TutorialHub := TFMXTutorialHub.Create(Memo1, Button1);
>```

Make sure to add a `TMemo` and a `TButton` component to your form beforehand.

The `TButton` will allow the interruption of any streamed reception.

<br/>

## Asynchronous callback mode management

In the context of asynchronous methods, for a method that does not involve streaming, callbacks use the following generic record: `TAsynCallBack<T> = record` defined in the `Anthropic.Async.Support.pas` unit. This record exposes the following properties:

```Pascal
   TAsynCallBack<T> = record
   ... 
       Sender: TObject;
       OnStart: TProc<TObject>;
       OnSuccess: TProc<TObject, T>;
       OnError: TProc<TObject, string>; 
```
<br/>

For methods requiring streaming, callbacks use the generic record `TAsynStreamCallBack<T> = record`, also defined in the `Anthropic.Async.Support.pas` unit. This record exposes the following properties:

```Pascal
   TAsynCallBack<T> = record
   ... 
       Sender: TObject;
       OnStart: TProc<TObject>;
       OnProgress: TProc<TObject, T>;
       OnSuccess: TProc<TObject, T>;
       OnError: TProc<TObject, string>;
       OnCancellation: TProc<TObject>;
       OnDoCancel: TFunc<Boolean>;
```

The name of each property is self-explanatory; if needed, refer to the internal documentation for more details.

<br>

>[!NOTE]
> All methods managed by the wrapper are designed to support both synchronous and asynchronous execution modes. This dual-mode functionality ensures greater flexibility for users, allowing them to choose the approach that best suits their application's requirements and workflow.

<br/>

## Simplified Unit Declaration

To streamline the use of the API wrapper, the process for declaring units has been simplified. Regardless of the methods being utilized, you only need to reference the following two core units:

```Pascal
  uses
    Anthropic, Anthropic.Types;
```

If required, you may also include any plugin units developed for specific function calls (e.g., `Anthropic.Functions.Example`). This simplification ensures a more intuitive and efficient integration process for developers.

<br/>

# Usage

## Initialization

To initialize the API instance, you need to [obtain an API key from Anthropic](https://console.anthropic.com/settings/keys/).

Once you have a token, you can initialize `IAnthropic` interface, which is an entry point to the API.


> [!NOTE]
>```Pascal
>uses Anthropic;
>
>var Anthropic := TAnthropicFactory.CreateInstance(API_KEY);
>```

<br/>

To implement batch processing or enable caching, it is necessary to specify the corresponding elements in the request header :
- `Prompt Caching (Beta)`: To access this feature, include the `anthropic-beta: prompt-caching-2024-07-31` header in your API requests. 
- `Message Batches API (Beta)`: To use this feature, include the `anthropic-beta: message-batches-2024-09-24` header in your API requests, or call client.beta.messages.batches in your SDK. 

To automate the process, the `TAnthropicFactory` class provides two class methods. These methods simplify the code by removing the need to manually handle request headers :
- **CreateBatchingInstance**
- **CreateCachingInstance**

<br/>

>[!WARNING]
>To fully leverage the examples featured in this tutorial—especially when working with asynchronous methods—I suggest configuring the HuggingFace interface with the broadest possible scope. To simplify the tutorial and provide practical, ready-to-use code, we will set up the following instances:
>

```Pascal
  Anthropic: IAnthropic;
  AnthropicBatch: IAnthropic;
  AnthropicCaching: IAnthropic;

.....
  // Configuration in the OnCreate event
  Anthropic := TAnthropicFactory.CreateInstance(API_KEY);
  AnthropicBatch := TAnthropicFactory.CreateBatchingInstance(API_KEY);
  AnthropicCaching := TAnthropicFactory.CreateCachingInstance(API_KEY); 
```

<br/>

## Claude Models Overview

Claude models include a snapshot date in their name, ensuring a stable and identical version across platforms. The `-latest` alias points to the most recent version for testing convenience, but using a specific version is recommended in production to ensure stability. The -latest alias is updated with new releases while maintaining the same usage conditions and pricing.

Refer to the [official documentation](https://docs.anthropic.com/en/docs/about-claude/models)

### List of models

The list of available models can be retrieved from the Models API response. The models are ordered by release date, with the most recently published appearing first.

>[!TIP]
> For the purposes of this tutorial, we have chosen to use the `Anthropic.Tutorial.FMX` unit in the examples. However, you are free to substitute it with its VCL equivalent, `Anthropic.Tutorial.VCL`.
>

```Pascal
// uses Anthropic, Anthropic.Types, Anthropic.Tutorial.FMX;
  
  //Asynchronous example
  Anthropic.Models.AsynList(
    procedure (Params: TListModelsParams)
    begin
      Params.Limite(10);
    end,
    function : TAsynModels
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Anthropic.Models.List(
//    procedure (Params: TListModelsParams)
//    begin
//      Params.Limite(10);
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br/>

### Retrieve a model

The Models API allows you to retrieve information about a specific model or map a model alias to its unique model ID.

```Pascal
// uses Anthropic, Anthropic.Types, Anthropic.Tutorial.FMX;

  //Asynchronous example
  Anthropic.Models.AsynRetrieve(Model_ID,
    function : TAsynModel
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Anthropic.Models.Retrieve(Model_ID);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

## Embeddings

`Anthropic` does not offer its own models for **text embeddings**. While the documentation mentions `Voyage AI` as an embeddings provider, we do not include access to their APIs in our **GitHub repository**. This is because providing tools for Voyage models falls outside the scope of our focus on `Anthropic` APIs exclusively. Users seeking embedding solutions are encouraged to explore various vendors to find the best fit for their needs, but our resources concentrate solely on supporting `Anthropic's` offerings.

<br/>

## Chats

`Claude` is capable of performing a wide range of text-based tasks. Trained on code, prose, and various natural language inputs, `Claude` excels in generating text outputs in response to detailed prompts. For optimal results, prompts should be written as detailed natural language instructions, and further improvements can be achieved through prompt engineering.

- **Text Summarization**: Condense lengthy content into key insights.
- **Content Generation:** Create engaging content like blog posts, emails, and product descriptions.
- **Data and Entity Extraction**: Extract structured information from unstructured text.
- **Question Answering**: Develop intelligent systems such as chatbots and educational tutors.
- **Text Translation**: Facilitate communication across different languages.
- **Text Analysis and Recommendations**: Analyze sentiment and patterns to personalize experiences.
- **Dialogue and Conversation**: Generate context-aware interactions for games and storytelling.
- **Code Explanation and Generation**: Assist in code reviews and generate boilerplate code.

Refer to [the prompt engineering overview](https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering/overview)

<br/>

### Create a message

You can send a structured list of input messages containing text and/or image content, and the model will generate the next message in the conversation.

The Messages API can be used for both single-turn requests and multi-turn, stateless conversations.

Example :
```Pascal
// uses Anthropic, Anthropic.Types, Anthropic.Tutorial.FMX;

  //Asynchronous example
  Anthropic.Chat.AsynCreate(
     procedure (Params: TChatParams)
     begin
       Params.Model('claude-3-5-sonnet-20241022');
       Params.MaxTokens(1024);
       Params.System('You are an expert in art history');
       Params.Messages([
         FromUser('Can you enlighten me on the technique of chiaroscuro and also on the Flemish school of painting in the 18th century ?')
       ]);
     end,
     function : TAsynChat
     begin
       Result.Sender := TutorialHub;
       Result.OnStart := Start;
       Result.OnSuccess := Display;
       Result.OnError := Display;
     end);

    //Synchronous example
//  var Chat := Anthropic.Chat.Create(
//     procedure (Params: TChatParams)
//     begin
//       Params.Model('claude-3-5-sonnet-20241022');
//       Params.MaxTokens(1024);
//       Params.System('You are an expert in art history');
//       Params.Messages([
//         FromUser('Can you enlighten me on the technique of chiaroscuro and also on the Flemish school of painting in the 18th century ?')
//       ]);
//     end);
//  try
//    Display(TutorialHub, Chat);
//    DisplayUsage(TutorialHub, Chat);
//  finally
//    Chat.Free;
//  end;
```

<br/>

### Streaming messages

When generating a Message, you can enable "stream": true to progressively receive the response through server-sent events (SSE).

Example :
```Pascal
// uses Anthropic, Anthropic.Types, Anthropic.Tutorial.FMX;

  //Asynchronous example
  Anthropic.Chat.AsynCreateStream(
     procedure (Params: TChatParams)
     begin
       Params.Model('claude-3-5-sonnet-20241022');
       Params.MaxTokens(1024);
       Params.System('You are an expert in art history');
       Params.Messages([
         FromUser('Can you enlighten me on the technique of chiaroscuro and also on the Flemish school of painting in the 18th century ?')
       ]);
       Params.Stream;
     end,
     function : TAsynChatStream
     begin
       Result.Sender := TutorialHub;
       Result.OnStart := Start;
       Result.OnProgress := DisplayStream;
       Result.OnSuccess := DisplayUsage;
       Result.OnError := Display;
       Result.OnDoCancel := DoCancellation;
       Result.OnCancellation := Cancellation;
     end);

    //Synchronous example
//  Anthropic.Chat.CreateStream(
//     procedure (Params: TChatParams)
//     begin
//       Params.Model('claude-3-5-sonnet-20241022');
//       Params.MaxTokens(1024);
//       Params.System('You are an expert in art history');
//       Params.Messages([
//         FromUser('Can you enlighten me on the technique of chiaroscuro and also on the Flemish school of painting in the 18th century ?')
//       ]);
//       Params.Stream;
//     end,
//     procedure (var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
//     begin
//       if not IsDone then
//         DisplayStream(TutorialHub, Chat) else
//         DisplayUsage(TutorialHub, Chat);
//       Application.ProcessMessages;
//     end);
```

<br/>

### Multi-turn conversation

The `Anthropic API` enables the creation of interactive chat experiences tailored to your users' needs. Its chat functionality supports multiple rounds of questions and answers, allowing users to gradually work toward solutions or receive help with complex, multi-step issues. This capability is especially useful for applications requiring ongoing interaction, such as:
- **Chatbots**
- **Educational tools**
- **Customer support assistants.**

```Pascal
// uses Anthropic, Anthropic.Types, Anthropic.Tutorial.FMX;

  //Streamed Asynchronous example
  Anthropic.Chat.AsynCreateStream(
     procedure (Params: TChatParams)
     begin
       Params.Model('claude-3-5-sonnet-20241022');
       Params.MaxTokens(1024);
       Params.System('You are a funny domestic assistant.');
       Params.Messages([
         FromUser('Hello'),
         FromAssistant('Great to meet you. What would you like to know?'),
         FromUser('I have two dogs in my house. How many paws are in my house?')
       ]);
       Params.Stream;
     end,
     function : TAsynChatStream
     begin
       Result.Sender := TutorialHub;
       Result.OnStart := Start;
       Result.OnProgress := DisplayStream;
       Result.OnSuccess := DisplayUsage;
       Result.OnError := Display;
       Result.OnDoCancel := DoCancellation;
       Result.OnCancellation := Cancellation;
     end);
```

>[!TIP]
> The `FromUser` and `FromAssistant` methods streamline role management while enhancing code readability. They eliminate the need to use the `Payload` alias (e.g., `Payload.User('Hello')`) or the `TChatMessagePayload` type (e.g., `TChatMessagePayload.User('Hello')`).
>

<br/>

### Token counting

Token counting estimates the number of tokens in a message before sending it, helping manage costs and optimize message structure. The tool provides an estimate based on structured inputs (text, tools, PDFs) and supports Claude 3 and 3.5 models.

```Pascal
// uses Anthropic, Anthropic.Types, Anthropic.Tutorial.FMX;

  //Asynchronous example
  Anthropic.Chat.AsynTokenCount(
    procedure (Params: TChatParams)
    begin
      Params.Model('claude-3-5-sonnet-20241022');
       Params.System(
         'You are an expert in art history'
       );
       Params.Messages([
         FromUser('In which artistic movement could we classify the Eiffel Tower?')
       ]);
    end,
    function : TAsynTokenCount
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Anthropic.Chat.TokenCount(
//    procedure (Params: TChatParams)
//    begin
//      Params.Model('claude-3-5-sonnet-20241022');
//       Params.System(
//         'You are an expert in art history'
//       );
//       Params.Messages([
//         FromUser('In which artistic movement could we classify the Eiffel Tower?')
//       ]);
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br/>

## Document processing

`Claude 3.5 Sonnet` can extract text, analyze charts, and interpret content from `PDF documents`. Example use cases include financial report analysis, legal document extraction, translation, and data structuring.

PDF requirements:
- **Size:** up to 32 MB.
- **Pages:** up to 100.
- **Format:** standard, unprotected PDF.

Refer to the [official documentation](https://docs.anthropic.com/en/docs/build-with-claude/pdf-support).

This feature is available via API on `Claude 3.5 Sonnet` models and will soon be supported on additional platforms.

```Pascal
// uses Anthropic, Anthropic.Types, Anthropic.Tutorial.FMX;

  var Pdf := 'https://assets.anthropic.com/m/1cd9d098ac3e6467/original/Claude-3-Model-Card-October-Addendum.pdf';

  //Streamed  asynchronous example
  Anthropic.Chat.AsynCreateStream(
      procedure(Params: TChatParams)
      begin
        Params.Model('claude-3-5-sonnet-20241022');
        Params.MaxTokens(1024);
        Params.Messages([
          FromPdf('Which model has the highest human preference win rates across each use-case?', Pdf)
        ]);
        Params.Stream(True);
      end,
      function: TAsynChatStream
      begin
        Result.Sender := TutorialHub;
        Result.OnStart := Start;
        Result.OnProgress := DisplayStream;
        Result.OnSuccess := DisplayUsage;
        Result.OnError := Display;
        Result.OnDoCancel := DoCancellation;
        Result.OnCancellation := Cancellation;
      end);

  //Streamed synchronous example
//  Anthropic.Chat.CreateStream(
//      procedure(Params: TChatParams)
//      begin
//        Params.Model('claude-3-5-sonnet-20241022');
//        Params.MaxTokens(1024);
//        Params.Messages([
//          FromPdf('Which model has the highest human preference win rates across each use-case?', Pdf)
//        ]);
//        Params.Stream(True);
//      end,
//      procedure (var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
//      begin
//        if not IsDone then
//          DisplayStream(TutorialHub, Chat) else
//          DisplayUsage(TutorialHub, Chat);
//        Application.ProcessMessages;
//      end);
```

>[!TIP]
> The `FromPdf` method can process PDF files from either a URL or local disk storage.
>

<br/>

## Vision

All `Claude version 3` models add vision capabilities, allowing them to analyze both images and text, expanding their potential for applications requiring multimodal understanding. See also the [official documentation](https://docs.anthropic.com/en/docs/build-with-claude/vision/).

To support both synchronous and asynchronous completion methods, we focused on generating the appropriate payload for message parameters. An overloaded version of the `TChatMessagePayload.User` class function was added, allowing users to include a dynamic array of text elements—file paths—alongside the user's text content. 
Internally, this data is processed to ensure the correct operation of the vision system in both synchronous and asynchronous contexts.

<br/>

### Passing a Base64 Encoded Image

Example :
```Pascal
// uses Anthropic, Anthropic.Types, Anthropic.Tutorial.FMX;
  
  var Ref := 'T:\My_Folder\Images\Picture.png';

  //Streamed asynchronous example
  Anthropic.Chat.AsynCreateStream(
     procedure (Params: TChatParams)
     begin
       Params.Model('claude-3-5-sonnet-20241022');
       Params.MaxTokens(1024);
       Params.Messages([
         FromUser('Describe this image.', [Ref])
       ]);
       Params.Stream;
     end,
     function : TAsynChatStream
     begin
       Result.Sender := TutorialHub;
       Result.OnStart := Start;
       Result.OnProgress := DisplayStream;
       Result.OnSuccess := DisplayUsage;
       Result.OnError := Display;
       Result.OnDoCancel := DoCancellation;
       Result.OnCancellation := Cancellation;
     end);

    //Streamed synchronous example
//  Anthropic.Chat.CreateStream(
//     procedure (Params: TChatParams)
//     begin
//       Params.Model('claude-3-5-sonnet-20241022');
//       Params.MaxTokens(1024);
//       Params.Messages([
//         FromUser('Describe this image.', [Ref])
//       ]);
//       Params.Stream;
//     end,
//     procedure (var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
//     begin
//       if not IsDone then
//         DisplayStream(TutorialHub, Chat) else
//         DisplayUsage(TutorialHub, Chat);
//       Application.ProcessMessages;
//     end);
```

<br/>

### Passing an Image URL

Example :
```Pascal
// uses Anthropic, Anthropic.Types, Anthropic.Tutorial.FMX;

  var Ref := 'https://tripfixers.com/wp-content/uploads/2019/11/eiffel-tower-with-snow.jpeg';

  //Streamed asynchronous example
  Anthropic.Chat.AsynCreateStream(
     procedure (Params: TChatParams)
     begin
       Params.Model('claude-3-5-sonnet-20241022');
       Params.MaxTokens(1024);
       Params.Messages([
         FromUser('Describe this image.', [Ref])
       ]);
       Params.Stream;
     end,
     function : TAsynChatStream
     begin
       Result.Sender := TutorialHub;
       Result.OnStart := Start;
       Result.OnProgress := DisplayStream;
       Result.OnSuccess := DisplayUsage;
       Result.OnError := Display;
       Result.OnDoCancel := DoCancellation;
       Result.OnCancellation := Cancellation;
     end);

    //Streamed synchronous example
//  Anthropic.Chat.CreateStream(
//     procedure (Params: TChatParams)
//     begin
//       Params.Model('claude-3-5-sonnet-20241022');
//       Params.MaxTokens(1024);
//       Params.Messages([
//         FromUser('Describe this image.', [Ref])
//       ]);
//       Params.Stream;
//     end,
//     procedure (var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
//     begin
//       if not IsDone then
//         DisplayStream(TutorialHub, Chat) else
//         DisplayUsage(TutorialHub, Chat);
//       Application.ProcessMessages;
//     end);
```

<br/>

## Function calling

Claude can connect with external client-side tools provided by users to perform various tasks more efficiently. 

>[!WARNING]
>Warning: Ensure user confirmation for actions like sending emails or making purchases to avoid unintended consequences.
>

For more details, refer to the Anthropic [website documentation.](https://docs.anthropic.com/en/docs/build-with-claude/tool-use) 

<br/>

### Overview of Tool Use in Claude

`Here's a quick guide on how to implement tool use:` <br/>
- **Provide Tools & User Prompt**: Define tools in your API request with names, descriptions, and input schemas. Add a user prompt, e.g., “What’s the weather in San Francisco?” <br/>
- **Claude Decides to Use a Tool**: If a tool is helpful, Claude sends a tool use request with a tool_use stop_reason. <br/>
- **Run Tool and Return Results**: On your side, extract the tool input, run it, and return the results to Claude via a tool_result content block. <br/>
- **Claude’s Final Response**: Claude analyzes the tool results and crafts its final answer. <br/>

`Forcing Tool Use` : <br/>
- **auto (default)**: Claude decides whether to use a tool. <br/>
- **any**: Claude must use one of the provided tools. <br/>
- **tool**: Forces Claude to use a specific tool. <br/>

`Flexibility and Control`: <br/>
- All tools are user-provided, giving you complete control. You can guide or force tool use for specific tasks or let Claude decide when tools are necessary.

<br/>

### Examples

What’s the weather in Paris?

In the `Anthropic.Functions.Example` unit, there is a class that defines a function which `Claude` can choose to use or not, depending on the options provided. This class inherits from a parent class defined in the `Anthropic.Functions.Core` unit. To create new functions, you can derive from the `TFunctionCore class` and define a new plugin.

In this unit, this schema will be used for function calls.

```Json
{
    "type": "object",
    "properties": {
         "location": {
             "type": "string",
             "description": "The city and department, e.g. Marseille, 13"
         },
         "unit": {
             "type": "string",
             "enum": ["celsius", "fahrenheit"]
         }
     },
     "required": ["location"]
  }
```
<br/>

1. We will use the TWeatherReportFunction plugin defined in the [`Anthropic.Functions.Example`](https://github.com/MaxiDonkey/DelphiAnthropic/blob/main/source/Anthropic.Functions.Example.pas) unit.

```Pascal
  var WeatherFunc := TWeatherReportFunction.CreateInstance;  
  //See step 3
```

<br/>

2. We then define a method to display the **result** of the query using the **Weather tool**.

```Pascal
procedure TMy_Form.WeatherExecuteStream(const Value: string);
begin
  //Asynchronous example
  Anthropic.Chat.AsynCreateStream(
     procedure (Params: TChatParams)
     begin
       Params.Model('claude-3-5-sonnet-20241022');
       Params.MaxTokens(1024);
       Params.Messages([
         FromUser(Value)
       ]);
       Params.System('You are a star weather presenter on a national TV channel.');
       Params.Stream;

     end,
     function : TAsynChatStream
     begin
       Result.Sender := TutorialHub;
       Result.OnProgress := DisplayStream;
       Result.OnSuccess := DisplayUsage;
       Result.OnError := Display;
     end);

    //Synchronous example
//  Anthropic.Chat.CreateStream(
//     procedure (Params: TChatParams)
//     begin
//       Params.Model('claude-3-5-sonnet-20241022');
//       Params.MaxTokens(1024);
//       Params.Messages([
//         FromUser(Value)
//       ]);
//       Params.System('You are a star weather presenter on a national TV channel.');
//       Params.Stream;
//     end,
//     procedure (var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
//     begin
//       if not IsDone then
//         DisplayStream(TutorialHub, Chat) else
//         DisplayUsage(TutorialHub, Chat);
//     end);
end;

```

<br/>

3. Building the query using the Weather tool

```Pascal
// uses Anthropic, Anthropic.Types, Anthropic.Tutorial.FMX, Anthropic.Functions.Example;
  
  var WeatherFunc := TWeatherReportFunction.CreateInstance;
  TutorialHub.ToolCall := WeatherExecute;
  TutorialHub.Tool := WeatherFunc;

  //Asynchronous example
  Anthropic.Chat.AsynCreate(
     procedure (Params: TChatParams)
     begin
       Params.Model('claude-3-5-sonnet-20241022');
       Params.MaxTokens(1024);
       Params.Messages([
         FromUser('What is the weather in Paris ?')
       ]);
       Params.ToolChoice(auto);
       Params.Tools([WeatherFunc]);
     end,
     function : TAsynChat
     begin
       Result.Sender := TutorialHub;
       Result.OnStart := Start;
       Result.OnSuccess := Display;
       Result.OnError := Display;
     end);

    //Synchronous example
//  var Chat := Anthropic.Chat.Create(
//     procedure (Params: TChatParams)
//     begin
//       Params.Model('claude-3-5-sonnet-20241022');
//       Params.MaxTokens(1024);
//       Params.Messages([
//         FromUser('What is the weather in Paris ?')
//       ]);
//       Params.ToolChoice(auto);
//       Params.Tools([WeatherFunc]);
//     end);
//  try
//    Display(TutorialHub, Chat);
//  finally
//    Chat.Free;
//  end;
```

<br/>


## Prompt Caching

`Prompt Caching` optimizes API usage by caching prompt prefixes, reducing processing time and costs for repetitive tasks. If a prompt prefix is cached from a recent query, it's reused; otherwise, the full prompt is processed and cached for future use. The cache lasts **5 minutes** and **is refreshed with each use**, making it ideal for prompts with many examples, background information, or consistent instructions.

For more details, refer to the Anthropic [website documentation.](https://docs.anthropic.com/en/docs/build-with-claude/prompt-caching/) 

<br/>

### Caching initialization

To include the `anthropic-beta: prompt-caching-2024-07-31` header, you must declare :

> [!NOTE]
>```Pascal
>uses Anthropic;
>
>AnthropicCaching := TAnthropicFactory.CreateCachingInstance(API_KEY); 
>```

Refert to [initialization](#initialization)

Prompt Caching is supported on models like `Claude 3.5 Sonnet`, `Claude 3 Haiku`, and `Claude 3 Opus`. Any part of the request can be flagged for caching using cache_control. 

This includes:

- `Tools`: Definitions in the tools array.
- `System Messages`: Content blocks within the system array.
- `Messages`: Content blocks in the messages.content array, for both user and assistant turns.
- `Images`: Content blocks in the messages.content array during user turns.
- `Tool Usage and Results`: Content blocks in the messages.content array, for both user and assistant turns.

Each of these components can be designated for caching by applying cache_control to that specific portion of the request.

>[!WARNING]
>Minimum Cacheable Prompt Length:
>
>- **1024 tokens** for `Claude 3.5 Sonnet` and `Claude 3 Opus`
>- **2048 tokens** for `Claude 3.5 Haiku` and  `Claude 3 Haiku` <br/>
>Prompts shorter than these lengths cannot be cached, even if they include cache_control. Any request to cache a prompt with fewer tokens than the minimum required will be processed without caching. To check if a prompt was cached, refer to the response usage fields.
>
>The cache has a 5-minute time-to-live (TTL). Currently, the only supported cache type is "ephemeral," which corresponds to this 5-minute lifespan.
>

<br/>

### System Caching

In the following example, we have a plain text file `text/plain` whose size exceeds the minimum threshold for caching. We will include this file in the ***system section*** of the prompt. This can be beneficial in a ***multi-turn conversation***.

```Pascal
// uses Anthropic, Anthropic.Types, Anthropic.Tutorial.FMX;

  var LongText := 'T:\my_folder\documents\legal.txt';

  //Asynchronous example
  AnthropicCaching.Chat.AsynCreate(
     procedure (Params: TChatParams)
     begin
       Params.Model('claude-3-5-sonnet-20241022');
       Params.MaxTokens(1024);
       Params.System(
         'You are an AI assistant tasked with analyzing legal documents.' + sLineBreak +
         'Here is the full text of a complex legal agreement:',
         LongText
       );
       Params.Messages([
         FromUser('What are the important key points?', True)
       ]);
     end,
     function : TAsynChat
     begin
       Result.Sender := TutorialHub;
       Result.OnStart := Start;
       Result.OnSuccess := Display;
       Result.OnError := Display;
     end);

    //Synchronous example
//  var Chat := AnthropicCaching.Chat.Create(
//     procedure (Params: TChatParams)
//     begin
//       Params.Model('claude-3-5-sonnet-20241022');
//       Params.MaxTokens(1024);
//       Params.System(
//         'You are an AI assistant tasked with analyzing legal documents.' + sLineBreak +
//         'Here is the full text of a complex legal agreement:',
//         LongText
//       );
//       Params.Messages([
//         FromUser('What are the important key points?', True)
//       ]);
//     end);
//  try
//    Display(TutorialHub, Chat);
//    DisplayUsage(TutorialHub, Chat);
//  finally
//    Chat.Free;
//  end;
```

Not only is the message flagged for caching (`FromUser('What are the important key points?', True)`), but the system parameters are also seamlessly configured, as two elements are defined: a text and a file.

<br/>

### Tools Caching

The `cache_control` parameter is applied to the final tool (get_time), allowing all previous tool definitions, like get_weather, to be cached as a single block. This is useful for reusing a consistent set of tools across multiple requests without reprocessing them each time.

Let's assume we have several tools, each defined in a plugin, as we did with the get_time tool, which we decided to call last. When instantiating each plugin, we'll call the associated factory method to create an instance, for example:

```Pascal
var tool_n := TMy_tool_nFunction.CreateInstance;
```

For the get_time tool, the instantiation will be done like this:

```Pascal
var WeatherFunc := TWeatherReportFunction.CreateInstance(True);

  // True indicates that WeatherFunc is marked for cache control, 
  // along with all the tools preceding it in the list provided to Claude.
```

When making all these tools available, we will simply write:

```Pascal
// uses Anthropic, Anthropic.Types, Anthropic.Tutorial.FMX, Anthropic.Functions.Example;

  var Chat := AnthropicCaching.Chat.Create(
     procedure (Params: TChatParams)
     begin
       Params.Model('claude-3-5-sonnet-20241022');
       Params.MaxTokens(1024);
       Params.Messages([
            FromUser('my request')
       ]);
       Params.ToolChoice(auto);
       Params.Tools([tool_1, ... , tool_n, WeatherFunc]);
         // List of tools provided to Claude
     end);
   ...
```

And so the whole list of tools will be cached.

<br/>

### Images Caching

```pascal
// uses Anthropic, Anthropic.Types, Anthropic.Tutorial.FMX;

  var Ref1 := 'T:\my_folder\Images\My_Image1.png';
  var Ref2 := 'T:\my_folder\Images\My_Image2.png';

  var Chat := AnthropicCaching.Chat.Create(
     procedure (Params: TChatParams)
     begin
       Params.Model(Models[ClaudeHaiku3]);
       Params.MaxTokens(1024);
       Params.Messages([
            FromUser('Describe these images.', [Ref1, Ref2], True)  //True for the caching
       ]);
     end);
  ...
```

<br/>

## Message Batches

The `Message Batches` API enables efficient, asynchronous processing of large volumes of message requests. This method is ideal for tasks that don’t require immediate responses, cutting costs by 50% and boosting throughput.

For more details, refer to the [Anthropic website documentation](https://docs.anthropic.com/en/docs/build-with-claude/message-batches/).

<br/>

### Message Batches initialization

To include the `anthropic-beta: message-batches-2024-09-24` header, you must declare :

> [!NOTE]
>```Pascal
>uses Anthropic;
>
>AnthropicBatche := TAnthropicFactory.CreateBatchingInstance(BaererKey);
>```

Refert to [initialization](#initialization)

The `Message Batches` API supports `Claude 3.5 Sonnet`, `Claude 3.5 Haiku`, `Claude 3 Haiku`, and `Claude 3 Opus`. Any request that can be made through the Messages API can be batched, including : 
 - **Vision** 
 - **Tool use**
 - **System messages** 
 - **Multi-turn conversations**
 - **Beta features** 

Different types of requests can be mixed within a single batch, as each request is processed independently.

>[!WARNING]
>**Batch limitations**
> - A `Message Batch` is limited to **10,000 requests** or **32 MB**, with up to **24 hours** for processing. 
> - Results are available only after the entire batch is processed and can be accessed for **29 days**. 
> - `Batches` are scoped to a Workspace, and rate limits apply to **HTTP requests**, not batch size. 
> - Processing may slow down based on demand, and the Workspace's spend limit may be slightly exceeded.
>

<br/>

### How it works

The `Message Batches` API creates a batch of requests, processed asynchronously with each request handled independently. You can track the batch status and retrieve results once processing is complete. This is ideal for large-scale tasks like evaluations, content moderation, data analysis, or bulk content generation.

<br/>

### Batch create

A Message Batch consists of a collection of requests to generate individual Messages. Each request is structured as follows:

```Pascal
// uses Anthropic, Anthropic.Types, Anthropic.Tutorial.FMX;

  // Create the content of the batche
  var Request := TRequestParams.Create;
  Request.Requests([
    TBatcheParams.Add('my-first-request',
        procedure (Params: TChatParams)
        begin
          Params.Model('claude-3-5-sonnet-20241022');
          Params.MaxTokens(1024);
          Params.Messages([
            FromUser('Hello, world') ]);
        end),
    TBatcheParams.Add('my-second-request',
        procedure (Params: TChatParams)
        begin
          Params.Model('claude-3-5-sonnet-20241022');
          Params.MaxTokens(1024);
          Params.Messages([
            FromUser('Hi again, friend') ]);
        end)
    ]);
  Display(TutorialHub, Request.ToFormat());

  TutorialHub.JSONParam := Request;

  //ASynchronous example
  AnthropicBatche.Batche.AsynCreate(Request.JSON,
    function : TAsynBatche
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  // Synchronous example
//  var Batche := AnthropicBatche.Batche.Create(Request.JSON);
//  try
//    Display(TutorialHub, Batche);
//  finally
//    Batche.Free;
//  end;
```

<br/>

**alternative approach**
 - In this approach, each item in the batch is defined in a JSONL file (`BatchExample.jsonl`). For instance, using the previous example, the JSONL file could be structured as follows:

```Json
{ "custom_id": "my-first-request","params":{"model":"claude-3-5-sonnet-20241022","max_tokens": 1024,"messages":[{"role":"user","content":"Hello, world"}]}}
{"custom_id":"my-second-request",  "params":{"model":"claude-3-5-sonnet-20241022","max_tokens": 1024,"messages":[{"role":"user","content":"Hi again, friend"}]}}
```

<br/>

Therefore, the batch creation would be carried out using the following code:

```Pascal
// uses Anthropic, Anthropic.Types, Anthropic.Tutorial.FMX;

  TutorialHub.FileName := 'BatchExample.jsonl';

  //Asynchronous example
  AnthropicBatche.Batche.AsynCreate(TutorialHub.FileName,
    function : TAsynBatche
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

    //Synchronous example
//  var Batche := AnthropicBatche.Batche.Create(TutorialHub.FileName);
//  try
//    Display(TutorialHub, Batche);
//  finally
//    Batche.Free;
//  end;
``` 

<br/>

### Batch list

Retrieve all message batches within a workspace, with the most recently created batches appearing first.

```Pascal
// uses Anthropic, Anthropic.Types, Anthropic.Tutorial.FMX;

  //Asynchronous example
  AnthropicBatche.Batche.AsynList(
    procedure (Params: TListParams)
    begin
      Params.Limite(20);
    end,
    function : TAsynBatcheList
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Batche := AnthropicBatche.Batche.List(
//    procedure (Params: TListParams)
//    begin
//      Params.Limite(20);
//    end);
//  try
//    Display(TutorialHub, Batche);
//  finally
//    Batche.Free;
//  end;
```

You can use the "list" API with the following query parameters:

- **before_id (string)**: Use this parameter as a cursor for pagination. When specified, it returns the page of results immediately preceding the object identified by this ID.

- **after_id (string)**: Similar to the above, but this cursor returns the page of results immediately following the specified object ID.

- **limit (integer)**: Specifies how many items to return per page. The default is set to 20, with valid values ranging from 1 to 100.

<br/>

### Batch cancel

Batches can be canceled at any point before the processing is fully completed. Once a cancellation is triggered, the batch moves into a canceling state, during which the system may still finish any ongoing, non-interruptible requests before the cancellation is finalized.

The count of canceled requests is listed in the `request_counts`. To identify which specific requests were canceled, review the individual results within the batch. Keep in mind that no requests may actually be canceled if all active requests were non-interruptible.

```Pascal
// uses Anthropic, Anthropic.Types, Anthropic.Tutorial.FMX;

  TutorialHub.BatchId := ID;

  //ASynchonous example
  AnthropicBatche.Batche.AsynCancel(TutorialHub.BatchId,
    function : TAsynBatche
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end)

  //Synchronous example
//  var Batche := AnthropicBatche.Batche.Cancel(TutorialHub.BatchId);
//  try
//    Display(TutorialHub, Batche);
//  finally
//    Batche.Free;
//  end;
```

<br/>

### Batch retrieve message

This endpoint is repeatable and can be used to check the status of a Message Batch completion. To retrieve the results of a Message Batch, make a request to the `results_url` field provided in the response.

```Pascal
// uses Anthropic, Anthropic.Types, Anthropic.Tutorial.FMX;

  TutorialHub.BatchId := ID;

  //Asynchronous example
  AnthropicBatche.Batche.AsynRetrieve(TutorialHub.BatchId,
    function : TAsynBatche
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Batche := AnthropicBatche.Batche.Retrieve(TutorialHub.BatchId);
//  try
//    Display(TutorialHub, Batche);
//  finally
//    Batche.Free;
//  end;
```

<br/>

### Batch retrieve results

Streams the results of a Message Batch in a **JSONL** file format.

Each line in the file represents a **JSON** object containing the outcome of an individual request from the Message Batch. The order of results may not correspond to the original request order, so use the `custom_id` field to align results with their respective requests.

>[!WARNING]
>The path to retrieve Message Batch results should be obtained from the `results_url` of the batch. This path should not be assumed, as it may vary.
>

```Pascal
// uses Anthropic, Anthropic.Types, Anthropic.Tutorial.FMX;

  TutorialHub.BatchId := ID;
  TutorialHub.FileName := 'Result.jsonl';

  //Asynchronous example
  AnthropicBatche.Batche.AsynRetrieve(TutorialHub.BatchId, TutorialHub.FileName,
    function : TAsynStringList
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var JSONL := AnthropicBatche.Batche.Retrieve(TutorialHub.BatchId, TutorialHub.FileName);
//  try
//    Display(TutorialHub, JSONL);
//  finally
//    JSONL.Free;
//  end;  
```

In the `Anthropic.Batches.Support.pas` unit, the object interface `IBatcheResults` allows access to the data returned by Claude by providing the name of the **JSONL** file containing the batch data. All the information can be accessed through the Batches array, as demonstrated in the example below.

```Pascal
// uses Anthropic, Anthropic.Types, Anthropic.Tutorial.FMX;
  
  if not FileExists('Result.jsonl') then
    begin
      Display(TutorialHub, 'Result.jsonl not found');
      Exit;
    end;

  var BatchResults := TBatcheResultsFactory.CreateInstance('Result.jsonl');
  Display(TutorialHub, BatchResults);
```

<br/>

### Batch delete

Message Batches can only be deleted after they have completed processing. To delete a batch that is still in progress, you must cancel it first.

```Pascal
// uses Anthropic, Anthropic.Types, Anthropic.Tutorial.FMX;

  TutorialHub.BatchId := ID;

  //Asynchronous example
  AnthropicBatche.Batche.AsynDelete(TutorialHub.BatchId,
    function : TAsynBatchDelete
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := AnthropicBatche.Batche.Delete(TutorialHub.BatchId);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

>[!CAUTION]
> A 500 error may occur when attempting to delete messages in bulk, particularly for batches created before the release of the dedicated deletion API. This issue is especially concerning as it could result in a permanent inability to delete these batches, particularly if a significant number of them were generated prior to the availability of the deletion API.
>

<br/>

### Console

> [!NOTE]
>You can access all batches through the [Anthropic console](https://console.anthropic.com/settings/workspaces/default/batches). A complete history is maintained, allowing you to view and download the computed results.
>

<br/>

# Contributing

Pull requests are welcome. If you're planning to make a major change, please open an issue first to discuss your proposed changes.

# License

This project is licensed under the [MIT](https://choosealicense.com/licenses/mit/) License.

unit Anthropic.API.Params;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiAnthropic
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.Classes, System.JSON, System.SysUtils, System.Types, System.RTTI,
  REST.JsonReflect, REST.Json.Interceptors, System.Generics.Collections,
  System.Threading;

type
  /// <summary>
  /// Represents a reference to a procedure that takes a single argument of type T and returns no value.
  /// </summary>
  /// <param name="T">
  /// The type of the argument that the referenced procedure will accept.
  /// </param>
  /// <remarks>
  /// This type is useful for defining callbacks or procedures that operate on a variable of type T, allowing for more flexible and reusable code.
  /// </remarks>
  TProcRef<T> = reference to procedure(var Arg: T);

  TJSONInterceptorStringToString = class(TJSONInterceptor)
    constructor Create; reintroduce;
  protected
    RTTI: TRttiContext;
  end;

  TJSONParam = class
  private
    FJSON: TJSONObject;
    procedure SetJSON(const Value: TJSONObject);
    function GetCount: Integer;

  protected
    function ImportJSONL(const FilePath: string): TArray<string>; virtual;

  public
    constructor Create; virtual;
    destructor Destroy; override;
    function Add(const Key: string; const Value: string): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: Integer): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: Extended): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: Boolean): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: TDateTime; Format: string): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: TJSONValue): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: TJSONParam): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<string>): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<Integer>): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<Extended>): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<TJSONValue>): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<TJSONParam>): TJSONParam; overload; virtual;
    function AddJSONL(const Key: string; const FilePath: string): TJSONParam; virtual;
    function GetOrCreateObject(const Name: string): TJSONObject;
    function GetOrCreate<T: TJSONValue, constructor>(const Name: string): T;
    procedure Delete(const Key: string); virtual;
    procedure Clear; virtual;
    property Count: Integer read GetCount;
    function Detach: TJSONObject;
    property JSON: TJSONObject read FJSON write SetJSON;
    function ToJsonString(FreeObject: Boolean = False): string; virtual;
    function ToFormat(FreeObject: Boolean = False): string;
    function ToStringPairs: TArray<TPair<string, string>>;
    function ToStream: TStringStream;
  end;

  TUrlParam = class
  private
    FValue: string;
    procedure Check(const Name: string);
    function GetValue: string;
  public
    function Add(const Name, Value: string): TUrlParam; overload;
    function Add(const Name: string; Value: Integer): TUrlParam; overload;
    function Add(const Name: string; Value: Boolean): TUrlParam; overload;
    function Add(const Name: string; Value: Double): TUrlParam; overload;
    function Add(const Name: string; Value: TArray<string>): TUrlParam; overload;
    property Value: string read GetValue;
    constructor Create; virtual;
  end;

const
  DATE_FORMAT = 'YYYY-MM-DD';
  TIME_FORMAT = 'HH:NN:SS';
  DATE_TIME_FORMAT = DATE_FORMAT + ' ' + TIME_FORMAT;

implementation

uses
  System.DateUtils;

{ TJSONInterceptorStringToString }

constructor TJSONInterceptorStringToString.Create;
begin
  ConverterType := ctString;
  ReverterType := rtString;
end;

{ Fetch }

type
  Fetch<T> = class
    type
      TFetchProc = reference to procedure(const Element: T);
  public
    class procedure All(const Items: TArray<T>; Proc: TFetchProc);
  end;

{ Fetch<T> }

class procedure Fetch<T>.All(const Items: TArray<T>; Proc: TFetchProc);
var
  Item: T;
begin
  for Item in Items do
    Proc(Item);
end;

{ TJSONParam }

function TJSONParam.Add(const Key, Value: string): TJSONParam;
begin
  Delete(Key);
  FJSON.AddPair(Key, Value);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: TJSONValue): TJSONParam;
begin
  Delete(Key);
  FJSON.AddPair(Key, Value);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: TJSONParam): TJSONParam;
begin
  Add(Key, TJSONValue(Value.JSON.Clone));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: TDateTime; Format: string): TJSONParam;
begin
  if Format.IsEmpty then
    Format := DATE_TIME_FORMAT;
  Add(Key, FormatDateTime(Format, System.DateUtils.TTimeZone.local.ToUniversalTime(Value)));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: Boolean): TJSONParam;
begin
  Add(Key, TJSONBool.Create(Value));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: Integer): TJSONParam;
begin
  Add(Key, TJSONNumber.Create(Value));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: Extended): TJSONParam;
begin
  Add(Key, TJSONNumber.Create(Value));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<TJSONValue>): TJSONParam;
var
  JArr: TJSONArray;
begin
  JArr := TJSONArray.Create;
  Fetch<TJSONValue>.All(Value, JArr.AddElement);
  Add(Key, JArr);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<TJSONParam>): TJSONParam;
var
  JArr: TJSONArray;
  Item: TJSONParam;
begin
  JArr := TJSONArray.Create;
  for Item in Value do
  try
    JArr.AddElement(Item.JSON);
    Item.JSON := nil;
  finally
    Item.Free;
  end;
  Add(Key, JArr);
  Result := Self;
end;

function TJSONParam.AddJSONL(const Key, FilePath: string): TJSONParam;
begin
  var JSONL := ImportJSONL(FilePath);
  var JSONArray := TJSONArray.Create;
  for var Item in JSONL do
    JSONArray.Add(TJSONObject.ParseJSONValue(Item) as TJSONObject);
  Add(Key, JSONArray);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<Extended>): TJSONParam;
var
  JArr: TJSONArray;
  Item: Extended;
begin
  JArr := TJSONArray.Create;
  for Item in Value do
    JArr.Add(Item);
  Add(Key, JArr);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<Integer>): TJSONParam;
var
  JArr: TJSONArray;
  Item: Integer;
begin
  JArr := TJSONArray.Create;
  for Item in Value do
    JArr.Add(Item);
  Add(Key, JArr);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<string>): TJSONParam;
var
  JArr: TJSONArray;
  Item: string;
begin
  JArr := TJSONArray.Create;
  for Item in Value do
    JArr.Add(Item);
  Add(Key, JArr);
  Result := Self;
end;

procedure TJSONParam.Clear;
begin
  FJSON.Free;
  FJSON := TJSONObject.Create;
end;

constructor TJSONParam.Create;
begin
  FJSON := TJSONObject.Create;
end;

procedure TJSONParam.Delete(const Key: string);
var
  Item: TJSONPair;
begin
  Item := FJSON.RemovePair(Key);
  if Assigned(Item) then
    Item.Free;
end;

destructor TJSONParam.Destroy;
begin
  if Assigned(FJSON) then
    FJSON.Free;
  inherited;
end;

function TJSONParam.Detach: TJSONObject;
begin
  Result := JSON;
  JSON := nil;
  var Task: ITask := TTask.Create(
    procedure()
    begin
      Sleep(30);
      TThread.Queue(nil,
      procedure
      begin
        Self.Free;
      end);
    end
  );
  Task.Start;
end;

function TJSONParam.GetCount: Integer;
begin
  Result := FJSON.Count;
end;

function TJSONParam.GetOrCreate<T>(const Name: string): T;
begin
  if not FJSON.TryGetValue<T>(Name, Result) then
  begin
    Result := T.Create;
    FJSON.AddPair(Name, Result);
  end;
end;

function TJSONParam.GetOrCreateObject(const Name: string): TJSONObject;
begin
  Result := GetOrCreate<TJSONObject>(Name);
end;

function TJSONParam.ImportJSONL(const FilePath: string): TArray<string>;
begin
  if not FileExists(FilePath) or not ExtractFileExt(FilePath).ToLower.StartsWith('.jsonl') then
    raise Exception.CreateFmt('File %s not found or is not jsonl type.', [FilePath]);

  var StreamReader := TStreamReader.Create(FilePath, TEncoding.UTF8);
  try
    try
      while not StreamReader.EndOfStream do
        begin
          var Line := StreamReader.ReadLine;
          if Line.Trim.IsEmpty then
            Continue;

          var JSONVlue := TJSONObject.ParseJSONValue(Line);
          if not Assigned(JSONVlue) then
            raise Exception.CreateFmt('Error: Malformed JSON data.'#10'%s', [Line]);

          JSONVlue.Free;
          Result := Result + [Line];
        end;
    except
      raise;
    end;
  finally
    StreamReader.Free;
  end;
end;

procedure TJSONParam.SetJSON(const Value: TJSONObject);
begin
  FJSON := Value;
end;

function TJSONParam.ToFormat(FreeObject: Boolean): string;
begin
  Result := FJSON.Format(4);
  if FreeObject then
    Free;
end;

function TJSONParam.ToJsonString(FreeObject: Boolean): string;
begin
  Result := FJSON.ToJSON;
  if FreeObject then
    Free;
end;

function TJSONParam.ToStream: TStringStream;
begin
  Result := TStringStream.Create;
  try
    Result.WriteString(ToJsonString);
    Result.Position := 0;
  except
    Result.Free;
    raise;
  end;
end;

function TJSONParam.ToStringPairs: TArray<TPair<string, string>>;
begin
  for var Pair in FJSON do
    Result := Result + [TPair<string, string>.Create(Pair.JsonString.Value, Pair.JsonValue.AsType<string>)];
end;

{ TUrlParam }

function TUrlParam.Add(const Name, Value: string): TUrlParam;
begin
  Check(Name);
  var S := Format('%s=%s', [Name, Value]);
  if FValue.IsEmpty then
    FValue := S else
    FValue := FValue + '&' + S;
  Result := Self;
end;

function TUrlParam.Add(const Name: string; Value: Integer): TUrlParam;
begin
  Result := Add(Name, Value.ToString);
end;

function TUrlParam.Add(const Name: string; Value: Boolean): TUrlParam;
begin
  Result := Add(Name, BoolToStr(Value, true));
end;

function TUrlParam.Add(const Name: string; Value: Double): TUrlParam;
begin
  Result := Add(Name, Value.ToString);
end;

procedure TUrlParam.Check(const Name: string);
begin
  if FValue.Contains(Name) then
    begin
      var Items := FValue.Split(['&']);
      FValue := EmptyStr;
      for var Item in Items do
        begin
          if not Item.StartsWith(Name) then
            begin
              if FValue.IsEmpty then
                FValue := Item else
                FValue := FValue + '&' + Item;
            end;
        end;
    end;
end;

constructor TUrlParam.Create;
begin
  FValue := EmptyStr;
end;

function TUrlParam.GetValue: string;
begin
  Result := FValue;
  if not Result.IsEmpty then
    Result := '?' + Result;
end;

function TUrlParam.Add(const Name: string; Value: TArray<string>): TUrlParam;
begin
  Result := Add(Name, string.Join(',', Value).Replace(#32, #0));
end;

end.

unit Anthropic.API;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiAnthropic
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Net.HttpClient, System.Net.URLClient,
  System.Net.Mime, System.JSON, Anthropic.API.Params, Anthropic.Errors;

type
  AnthropicException = class(Exception)
  private
    FCode: Int64;
    FMsg: string;
    FType: string;
  public
    constructor Create(const ACode: Int64; const AError: TErrorCore); reintroduce; overload;
    constructor Create(const ACode: Int64; const Value: string); reintroduce; overload;
    property Code: Int64 read FCode write FCode;
    property &Type: string read FType write FType;
    property Msg: string read FMsg write FMsg;
  end;

  /// <summary>
  /// The `AnthropicExceptionAPI` class represents a generic API-related exception.
  /// It is thrown when there is an issue with the API configuration or request process,
  /// such as a missing API token, invalid base URL, or other configuration errors.
  /// This class serves as a base for more specific API exceptions.
  /// </summary>
  AnthropicExceptionAPI = class(Exception);

  /// <summary>
  /// An InvalidRequestError indicates that your request was malformed or
  /// missing some required parameters, such as a token or an input.
  /// This could be due to a typo, a formatting error, or a logic error in your code.
  /// </summary>
  AnthropicExceptionInvalidRequestError = class(AnthropicException);

  /// <summary>
  /// A `RateLimitError` indicates that you have hit your assigned rate limit.
  /// This means that you have sent too many tokens or requests in a given period of time,
  /// and our services have temporarily blocked you from sending more.
  /// </summary>
  AnthropicExceptionRateLimitError = class(AnthropicException);

  /// <summary>
  /// An `AuthenticationError` indicates that your API key or token was invalid,
  /// expired, or revoked. This could be due to a typo, a formatting error, or a security breach.
  /// </summary>
  AnthropicExceptionAuthenticationError = class(AnthropicException);

  /// <summary>
  /// This error message indicates that your account is not part of an organization
  /// </summary>
  AnthropicExceptionPermissionError = class(AnthropicException);

  /// <summary>
  /// An `InvalidResponse` error occurs when the API response is either empty or not in the expected format.
  /// This error indicates that the API did not return a valid response that can be processed, possibly due to a server-side issue,
  /// a malformed request, or unexpected input data.
  /// </summary>
  AnthropicExceptionInvalidResponse = class(AnthropicException);

  /// <summary>
  /// An `InvalidResponse` error occurs when the API response is either empty or not in the expected format.
  /// This error indicates that the API did not return a valid response that can be processed, possibly due to a server-side issue,
  /// a malformed request, or unexpected input data.
  /// </summary>
  AnthropicExceptionNotFoundError = class(AnthropicException);

  /// <summary>
  /// Une erreur `not_found_error` se produit lorsque la ressource demandée n'a pas été trouvée.
  /// Cette erreur indique que l'API n'a pas renvoyé de réponse valide pouvant être traitée, probablement en raison d'un problème côté serveur,
  /// d'une demande mal formulée ou de données d'entrée inattendues.
  /// </summary>
  AnthropicExceptionRequestTooLarge = class(AnthropicException);

  /// <summary>
  /// An `api_error` error occurs when an unexpected error has occurred internal to Anthropic’s systems
  /// </summary>
  AnthropicExceptionAPIError = class(AnthropicException);

  /// <summary>
  /// An `overloaded_error` error occurs when Anthropic’s API is temporarily overloaded.
  /// </summary>
  AnthropicExceptionOverloadedError = class(AnthropicException);

  TAnthropicAPI = class
  public
    const
      URL_BASE = 'https://api.anthropic.com/v1';
  private
    FHTTPClient: THTTPClient;
    FToken: string;
    FBaseUrl: string;
    FOrganization: string;
    FCustomHeaders: TNetHeaders;
    FHeaderOption: Integer;
    procedure SetToken(const Value: string);
    procedure SetBaseUrl(const Value: string);
    procedure SetOrganization(const Value: string);
    procedure RaiseError(Code: Int64; Error: TErrorCore);
    procedure ParseError(const Code: Int64; const ResponseText: string);
    procedure SetCustomHeaders(const Value: TNetHeaders);

  private
    function JSONValueAsString(const Value: string): string; overload;
    function JSONValueAsString(const Value: string; const Field: string): string; overload;
    function JSONValueAsString(const Value: string; const Field: TArray<string>): string; overload;

  protected
    function GetHeaders: TNetHeaders;
    function GetRequestURL(const Path: string): string;
    function Get(const Path: string; Response: TStringStream): Integer; overload;
    function Delete(const Path: string; Response: TStringStream): Integer; overload;
    function Post(const Path: string; Response: TStringStream): Integer; overload;
    function Post(const Path: string; Body: TJSONObject; Response: TStringStream; OnReceiveData: TReceiveDataCallback = nil): Integer; overload;
    function Post(const Path: string; Body: TMultipartFormData; Response: TStringStream): Integer; overload;
    function ParseResponse<T: class, constructor>(const Code: Int64; const ResponseText: string): T;
    procedure CheckAPI;

  public
    function Get<TResult: class, constructor>(const Path: string): TResult; overload;
    function Get<TResult: class, constructor; TParams: TUrlParam>(const Path: string; ParamProc: TProc<TParams>): TResult; overload;
    function Get(const Path: string): string; overload;
    procedure GetFile(const Path: string; Response: TStream); overload;
    function Delete<TResult: class, constructor>(const Path: string): TResult; overload;
    function Post<TParams: TJSONParam>(const Path: string; ParamProc: TProc<TParams>; Response: TStringStream; Event: TReceiveDataCallback): Boolean; overload;
    function Post<TResult: class, constructor; TParams: TJSONParam>(const Path: string; ParamProc: TProc<TParams>): TResult; overload;
    function Post<TResult: class, constructor>(const Path: string; ParamJSON: TJSONObject): TResult; overload;
    function Post<TResult: class, constructor>(const Path: string): TResult; overload;
    function PostForm<TResult: class, constructor; TParams: TMultipartFormData, constructor>(const Path: string; ParamProc: TProc<TParams>): TResult; overload;

  public
    constructor Create(const Option: Integer = 0); overload;
    constructor Create(const AToken: string; const Option: Integer = 0); overload;
    destructor Destroy; override;
    property Token: string read FToken write SetToken;
    property BaseUrl: string read FBaseUrl write SetBaseUrl;
    property Organization: string read FOrganization write SetOrganization;
    property Client: THTTPClient read FHTTPClient;
    property CustomHeaders: TNetHeaders read FCustomHeaders write SetCustomHeaders;
  end;

  TAnthropicAPIRoute = class
  private
    FAPI: TAnthropicAPI;
    procedure SetAPI(const Value: TAnthropicAPI);
  public
    property API: TAnthropicAPI read FAPI write SetAPI;
    constructor CreateRoute(AAPI: TAnthropicAPI); reintroduce;
  end;

implementation

uses
  REST.Json;

const
  JSONFieldsToString : TArray<string> = ['"input":{'];

{ TAnthropicAPI }

constructor TAnthropicAPI.Create(const Option: Integer);
begin
  inherited Create;
  FHTTPClient := THTTPClient.Create;
  FToken := EmptyStr;
  FBaseUrl := URL_BASE;
  FHeaderOption := Option;
end;

constructor TAnthropicAPI.Create(const AToken: string; const Option: Integer);
begin
  Create(Option);
  Token := AToken;
end;

destructor TAnthropicAPI.Destroy;
begin
  FHTTPClient.Free;
  inherited;
end;

function TAnthropicAPI.Post(const Path: string; Body: TJSONObject; Response: TStringStream; OnReceiveData: TReceiveDataCallback): Integer;
var
  Headers: TNetHeaders;
  Stream: TStringStream;
begin
  CheckAPI;
  Headers := GetHeaders;
  Stream := TStringStream.Create;
  FHTTPClient.ReceiveDataCallBack := OnReceiveData;
  try
    Stream.WriteString(Body.ToJSON);
    Stream.Position := 0;
    Result := FHTTPClient.Post(GetRequestURL(Path), Stream, Response, Headers).StatusCode;
  finally
    FHTTPClient.ReceiveDataCallBack := nil;
    Stream.Free;
  end;
end;

function TAnthropicAPI.Get(const Path: string; Response: TStringStream): Integer;
var
  Headers: TNetHeaders;
begin
  CheckAPI;
  Headers := GetHeaders;
  Result := FHTTPClient.Get(GetRequestURL(Path), Response, Headers).StatusCode;
end;

function TAnthropicAPI.Post(const Path: string; Body: TMultipartFormData; Response: TStringStream): Integer;
var
  Headers: TNetHeaders;
begin
  CheckAPI;
  Headers := GetHeaders;
  Result := FHTTPClient.Post(GetRequestURL(Path), Body, Response, Headers).StatusCode;
end;

function TAnthropicAPI.Post(const Path: string; Response: TStringStream): Integer;
var
  Headers: TNetHeaders;
  Stream: TStringStream;
begin
  CheckAPI;
  Headers := GetHeaders;
  Stream := nil;
  try
    Result := FHTTPClient.Post(GetRequestURL(Path), Stream, Response, Headers).StatusCode;
  finally
  end;
end;

function TAnthropicAPI.Post<TResult, TParams>(const Path: string; ParamProc: TProc<TParams>): TResult;
var
  Response: TStringStream;
  Params: TParams;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    Code := Post(Path, Params.JSON, Response);
    Result := ParseResponse<TResult>(Code, JSONValueAsString(Response.DataString));
  finally
    Params.Free;
    Response.Free;
  end;
end;

function TAnthropicAPI.Post<TResult>(const Path: string;
  ParamJSON: TJSONObject): TResult;
var
  Response: TStringStream;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Code := Post(Path, ParamJSON, Response);
    Result := ParseResponse<TResult>(Code, JSONValueAsString(Response.DataString));
  finally
    Response.Free;
  end;
end;

function TAnthropicAPI.Post<TParams>(const Path: string; ParamProc: TProc<TParams>; Response: TStringStream; Event: TReceiveDataCallback): Boolean;
var
  Params: TParams;
  Code: Integer;
begin
  Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    Code := Post(Path, Params.JSON, Response, Event);
    case Code of
      200..299:
        Result := True;
    else
      begin
        Result := False;
        var Recieved := TStringStream.Create;
        try
          Response.Position := 0;
          Recieved.LoadFromStream(Response);
          ParseError(Code, Recieved.DataString);
        finally
          Recieved.Free;
        end;
      end;
    end;
  finally
    Params.Free;
  end;
end;

function TAnthropicAPI.Post<TResult>(const Path: string): TResult;
var
  Response: TStringStream;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Code := Post(Path, Response);
    Result := ParseResponse<TResult>(Code, Response.DataString);
  finally
    Response.Free;
  end;
end;

function TAnthropicAPI.Delete(const Path: string; Response: TStringStream): Integer;
var
  Headers: TNetHeaders;
begin
  CheckAPI;
  Headers := GetHeaders;
  Result := FHTTPClient.Delete(GetRequestURL(Path), Response, Headers).StatusCode;
end;

function TAnthropicAPI.Delete<TResult>(const Path: string): TResult;
var
  Response: TStringStream;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Code := Delete(Path, Response);
    Result := ParseResponse<TResult>(Code, Response.DataString);
  finally
    Response.Free;
  end;
end;

function TAnthropicAPI.PostForm<TResult, TParams>(const Path: string; ParamProc: TProc<TParams>): TResult;
var
  Response: TStringStream;
  Params: TParams;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    Code := Post(Path, Params, Response);
    Result := ParseResponse<TResult>(Code, Response.DataString);
  finally
    Params.Free;
    Response.Free;
  end;
end;

procedure TAnthropicAPI.RaiseError(Code: Int64; Error: TErrorCore);
begin
  case Code of
    400:
      raise AnthropicExceptionInvalidRequestError.Create(Code, Error);
    401:
      raise AnthropicExceptionAuthenticationError.Create(Code, Error);
    403:
      raise AnthropicExceptionPermissionError.Create(Code, Error);
    404:
      raise AnthropicExceptionNotFoundError.Create(Code, Error);
    413:
      raise AnthropicExceptionRequestTooLarge.Create(Code, Error);
    429:
      raise AnthropicExceptionRateLimitError.Create(Code, Error);
    500:
      raise AnthropicExceptionAPIError.Create(Code, Error);
    529:
      raise AnthropicExceptionOverloadedError.Create(Code, Error);
  else
    raise AnthropicException.Create(Code, Error);
  end;
end;

function TAnthropicAPI.Get(const Path: string): string;
var
  Response: TStringStream;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Code := Get(Path, Response);
    case Code of
      200..299: ; //Success
    end;
    Result := Response.DataString;
  finally
    Response.Free;
  end;
end;

function TAnthropicAPI.Get<TResult, TParams>(const Path: string; ParamProc: TProc<TParams>): TResult;
var
  Response: TStringStream;
  Code: Integer;
  Params: TParams;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    Code := Get(Path + Params.Value, Response);
    Result := ParseResponse<TResult>(Code, Response.DataString);
  finally
    Response.Free;
    Params.Free;
  end;
end;

function TAnthropicAPI.Get<TResult>(const Path: string): TResult;
var
  Response: TStringStream;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Code := Get(Path, Response);
    Result := ParseResponse<TResult>(Code, Response.DataString);
  finally
    Response.Free;
  end;
end;

procedure TAnthropicAPI.GetFile(const Path: string; Response: TStream);
var
  Headers: TNetHeaders;
  Code: Integer;
begin
  CheckAPI;
  Headers := GetHeaders;
  Code := FHTTPClient.Get(GetRequestURL(Path), Response, Headers).StatusCode;
  case Code of
    200..299:
      ; {success}
  else
    var Recieved := TStringStream.Create;
    try
      Response.Position := 0;
      Recieved.LoadFromStream(Response);
      ParseError(Code, Recieved.DataString);
    finally
      Recieved.Free;
    end;
  end;
end;

function TAnthropicAPI.GetHeaders: TNetHeaders;
begin
  Result := [TNetHeader.Create('x-api-key', FToken)] + FCustomHeaders;
  Result := Result + [TNetHeader.Create('anthropic-version', '2023-06-01')];
  Result := Result + [TNetHeader.Create('Content-Type', 'application/json')];
  case FHeaderOption of
    1:
      Result := Result + [TNetHeader.Create('anthropic-beta', 'message-batches-2024-09-24')];
    2:
      Result := Result + [TNetHeader.Create('anthropic-beta', 'prompt-caching-2024-07-31')];
  end;
end;

function TAnthropicAPI.GetRequestURL(const Path: string): string;
begin
  Result := FBaseURL + '/';
  Result := Result + Path;
end;

function TAnthropicAPI.JSONValueAsString(const Value: string;
  const Field: TArray<string>): string;
begin
  Result := Value;
  if Length(Field) > 0 then
    begin
      for var Item in Field do
        Result := JSONValueAsString(Result, Item);
    end;
end;

function TAnthropicAPI.JSONValueAsString(const Value, Field: string): string;
begin
  Result := Value;
  var i := Pos(Field, Result);
  while (i > 0) and (i < Result.Length) do
    begin
      i := i + Field.Length - 1;
      Result[i] := '"';
      Inc(i);
      var j := 0;
      while (j > 0) or ((j = 0) and not (Result[i] = '}')) do
        begin
          case Result[i] of
            '{':
              Inc(j);
            '}':
              j := j - 1;
            '"':
              Result[i] := '`';
          end;
          Inc(i);
          if i > Result.Length then
            raise Exception.Create('Invalid JSON string');
        end;
      Result[i] := '"';
      i := Pos(Field, Result);
    end;
end;

function TAnthropicAPI.JSONValueAsString(const Value: string): string;
begin
  Result := JSONValueAsString(Value, JSONFieldsToString);
end;

procedure TAnthropicAPI.CheckAPI;
begin
  if FToken.IsEmpty then
    raise AnthropicExceptionAPI.Create('Token is empty!');
  if FBaseUrl.IsEmpty then
    raise AnthropicExceptionAPI.Create('Base url is empty!');
end;

procedure TAnthropicAPI.ParseError(const Code: Int64; const ResponseText: string);
var
  Error: TErrorCore;
begin
  Error := nil;
  try
    try
      Error := TJson.JsonToObject<TError>(ResponseText);
    except
      Error := nil;
    end;
    if Assigned(Error) then
      RaiseError(Code, Error);
  finally
    if Assigned(Error) then
      Error.Free;
  end;
end;

function TAnthropicAPI.ParseResponse<T>(const Code: Int64; const ResponseText: string): T;
begin
  Result := nil;
  case Code of
    200..299:
      try
        Result := TJson.JsonToObject<T>(ResponseText);
      except
        Result := nil;
      end;
    else
      ParseError(Code, ResponseText);
  end;
  if not Assigned(Result) then
    raise AnthropicExceptionInvalidResponse.Create(Code, 'Empty or invalid response');
end;

procedure TAnthropicAPI.SetBaseUrl(const Value: string);
begin
  FBaseUrl := Value;
end;

procedure TAnthropicAPI.SetCustomHeaders(const Value: TNetHeaders);
begin
  FCustomHeaders := Value;
end;

procedure TAnthropicAPI.SetOrganization(const Value: string);
begin
  FOrganization := Value;
end;

procedure TAnthropicAPI.SetToken(const Value: string);
begin
  FToken := Value;
end;

{ AnthropicException }

constructor AnthropicException.Create(const ACode: Int64; const AError: TErrorCore);
begin
  Code := ACode;
  Msg := (AError as TError).Error.Message;
  &Type := (AError as TError).Error.&Type;

  inherited Create(Format('error (%d) %s: '+ sLineBreak + '     %s', [ACode, &Type, Msg]));
end;

constructor AnthropicException.Create(const ACode: Int64; const Value: string);
begin
  Code := ACode;
  Msg := Value;
  inherited Create(Format('error %d: %s', [ACode, Msg]));
end;

{ TAnthropicAPIRoute }

constructor TAnthropicAPIRoute.CreateRoute(AAPI: TAnthropicAPI);
begin
  inherited Create;
  FAPI := AAPI;
end;

procedure TAnthropicAPIRoute.SetAPI(const Value: TAnthropicAPI);
begin
  FAPI := Value;
end;

end.

unit Anthropic.Async.Params;

{-------------------------------------------------------------------------------

      Unit containing generic interfaces and classes for managing parameters
      across  various  asynchronous  operations.

      The Anthropic.Async.Params unit  provides  a set of tools for creating
      and managing  parameter  instances  using  generic  types. The primary
      components include:

      - IUseParams<T>: A generic interface for managing parameters of type T.
      - TUseParams<T>: A class  implementing  the IUseParams<T>  interface to
        encapsulate  parameter  handling.
      - TUseParamsFactory<T>: A  factory  class  for  creating  instances  of
        IUseParams<T>.

      These abstractions allow for  a flexible and  reusable  way  to  handle
      parameters  across  different  modules  and  contexts,  particularly in
      asynchronous  scenarios  such  as  chat  operations.

      Note  that  This  unit  is  designed   to  work   seamlessly  with  the
      Anthropic.Chat.AsyncEvents unit,  which  relies  on  IUseParams<T> and
      TUseParamsFactory<T>  to  manage   parameters   for  asynchronous  chat
      requests.

        Github repository :  https://github.com/MaxiDonkey/DelphiAnthropic
        Visit the Github repository for the documentation and use examples

-------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes;

type
  /// <summary>
  /// Generic interface for managing parameters of type <c>T</c>.
  /// </summary>
  /// <typeparam name="T">
  /// The type of the parameters.
  /// </typeparam>
  IUseParams<T> = interface
    ['{18566F2C-F2D9-4257-A460-D9AE8F053357}']
    /// <summary>
    /// Sets the parameters.
    /// </summary>
    /// <param name="Value">
    /// The value of the parameters to be set.
    /// </param>
    procedure SetParams(const Value: T);
    /// <summary>
    /// Gets the current parameters.
    /// </summary>
    /// <returns>
    /// The current parameters of type <c>T</c>.
    /// </returns>
    function GetParams: T;
    /// <summary>
    /// Assigns the parameters using a function.
    /// </summary>
    /// <param name="Value">
    /// A function that returns parameters of type <c>T</c>.
    /// </param>
    procedure Assign(Value: TFunc<T>);
    /// <summary>
    /// Returns the current instance as an object of type <c>TObject</c>.
    /// </summary>
    /// <returns>
    /// The instance cast to <c>TObject</c>.
    /// </returns>
    function AsSender: TObject;
    /// <summary>
    /// Provides access to the parameters as a property.
    /// </summary>
    property Param: T read GetParams write SetParams;
  end;

  /// <summary>
  /// A factory class for creating instances of <c>IUseParams</c>.
  /// </summary>
  /// <param name="T">
  /// The type of the parameters for which the instance is created.
  /// </param>
  TUseParamsFactory<T> = class
    /// <summary>
    /// Creates and returns a new instance of <c>IUseParams</c> for the specified type <c>T</c>.
    /// </summary>
    /// <returns>
    /// A new instance of <c>IUseParams&lt;T&gt;</c>.
    /// </returns>
    class function CreateInstance: IUseParams<T>; overload;
    /// <summary>
    /// Creates and returns a new instance of <c>IUseParams</c> for the specified type <c>T</c>, using the provided function.
    /// </summary>
    /// <param name="Value">
    /// A function that provides the parameter values for the instance.
    /// </param>
    /// <returns>
    /// A new instance of <c>IUseParams&lt;T&gt;</c>.
    /// </returns>
    class function CreateInstance(Value: TFunc<T>): IUseParams<T>; overload;
  end;

  /// <summary>
  /// A generic class implementing the <c>IUseParams</c> interface to manage parameters of type <c>T</c>.
  /// </summary>
  /// <param name="T">
  /// The type of the parameters.
  /// </param>
  TUseParams<T> = class(TInterfacedObject, IUseParams<T>)
  private
    FParams: T;
    /// <summary>
    /// Sets the parameters to the provided value.
    /// </summary>
    /// <param name="Value">
    /// The new parameters value.
    /// </param>
    procedure SetParams(const Value: T);
    /// <summary>
    /// Retrieves the current parameters value.
    /// </summary>
    /// <returns>
    /// The current parameters.
    /// </returns>
    function GetParams: T;
  protected
    /// <summary>
    /// Casts the instance as a <c>TObject</c> for use as the sender of events.
    /// </summary>
    /// <returns>
    /// The current instance cast to <c>TObject</c>.
    /// </returns>
    function AsSender: TObject;
    /// <summary>
    /// Assigns the parameters using a function that returns type <c>T</c>.
    /// </summary>
    /// <param name="Value">
    /// A function that sets the parameters.
    /// </param>
    procedure Assign(Value: TFunc<T>);
  public
    /// <summary>
    /// Property to get or set the parameters.
    /// </summary>
    property Params: T read GetParams write SetParams;
  end;

implementation

{ TUseParams<T> }

function TUseParams<T>.AsSender: TObject;
begin
  Result := Self;
end;

procedure TUseParams<T>.Assign(Value: TFunc<T>);
begin
  if Assigned(Value) then
    begin
      Params := Value();
    end;
end;

function TUseParams<T>.GetParams: T;
begin
  Result := FParams;
end;

procedure TUseParams<T>.SetParams(const Value: T);
begin
  FParams := Value;
end;

{ TUseParamsFactory<T> }

class function TUseParamsFactory<T>.CreateInstance: IUseParams<T>;
begin
  Result := TUseParams<T>.Create;
end;

class function TUseParamsFactory<T>.CreateInstance(
  Value: TFunc<T>): IUseParams<T>;
begin
  Result := CreateInstance;
  Result.Assign(Value);
end;

end.

unit Anthropic.Async.Support;

{-------------------------------------------------------------------------------

      Unit containing  records for managing  asynchronous events related to
      chat requests.

      The  Anthropic.Chat.AsyncEvents  unit  provides  definitions for the
      TAsyncParams<T>  and  TAsynStreamParams<T>  records, which  are  used
      to  handle  the lifecycle  of asynchronous chat operations, including
      starting, progressing, succeeding, and handling errors.
      These records enable non-blocking operations for chat functionalities
      and can be reused across multiple modules.

      This unit depends  on Anthropic.Async.Params  for parameter management.
      The IUseParams<T>  and  TUseParamsFactory<T>  interfaces  and  classes
      from  Anthropic.Async.Params  are  utilized  to  create and manage the
      parameter  instances  for  asynchronous  operations.

        Github repository :  https://github.com/MaxiDonkey/DelphiAnthropic
        Visit the Github repository for the documentation and use examples

-------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, system.Classes, System.Threading, Anthropic.Async.Params;

type
  /// <summary>
  /// Record used to handle asynchronous request events.
  /// </summary>
  /// <remarks>
  /// <c>TAsynCallBack</c> manages the lifecycle of an asynchronous request.
  /// It provides callbacks for different stages of the request, such as start, successful completion, or error.
  /// </remarks>
  TAsynCallBack<T> = record
  private
    FSender: TObject;
    FOnStart: TProc<TObject>;
    FOnSuccess: TProc<TObject, T>;
    FOnError: TProc<TObject, string>;
  public
    /// <summary>
    /// Object representing the sender of the asynchronous operation.
    /// </summary>
    /// <remarks>
    /// The <c>Sender</c> property is used to identify or store a reference to the object that initiated the request.
    /// This can be useful for providing context in the callback procedures.
    /// </remarks>
    property Sender: TObject read FSender write FSender;
    /// <summary>
    /// Event triggered at the start of the asynchronous request.
    /// </summary>
    /// <remarks>
    /// The <c>OnStart</c> event is called when the request begins.
    /// It can be used to initialize any required state or display a loading indicator to the user.
    /// <code>
    /// OnStart :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // Code executed at the start of the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnStart: TProc<TObject> read FOnStart write FOnStart;
    /// <summary>
    /// Event triggered at the end of the asynchronous request.
    /// </summary>
    /// <param name="Sender">
    /// Object that initiated the request, generally used for context.
    /// </param>
    /// <param name="Result">
    /// The result of type <c>T</c> returned at the end of the request.
    /// This event is used to process the final result of the asynchronous operation.
    /// </param>
    /// <remarks>
    /// The <c>OnSuccess</c> event is invoked when the process completes successfully.
    /// It can be used to perform final actions based on the received result.
    /// <code>
    /// OnSuccess :=
    ///    procedure (Sender: TObject; Result: T)
    ///    begin
    ///      // Code executed at the end of the request with the obtained result
    ///    end;
    /// </code>
    /// </remarks>
    property OnSuccess: TProc<TObject, T> read FOnSuccess write FOnSuccess;
    /// <summary>
    /// Event triggered when an error occurs during the asynchronous request.
    /// </summary>
    /// <param name="Sender">
    /// Object that initiated the request, generally used for context.
    /// </param>
    /// <param name="ErrorMessage">
    /// The error message received, which can be logged or displayed to the user.
    /// </param>
    /// <remarks>
    /// The <c>OnError</c> event is called when an error occurs during the asynchronous operation.
    /// It can be used to handle failures, display error messages, or perform any necessary cleanup actions.
    /// <code>
    /// OnError :=
    ///    procedure (Sender: TObject; ErrorMessage: string)
    ///    begin
    ///      // Code executed when an error occurs during the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnError: TProc<TObject, string> read FOnError write FOnError;
  end;

  /// <summary>
  /// Class used to manage asynchronous execution with callback events.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynCallBackExec&lt;T, U&gt;</c> class allows you to execute asynchronous operations with specified callbacks for start, completion, and error events.
  /// It encapsulates the asynchronous execution logic, handling thread management and exception handling, providing an easy way to manage the lifecycle of an asynchronous request.
  /// </remarks>
  TAsynCallBackExec<T; U: class> = class
  private
    FUse: IUseParams<T>;
    FSender: TObject;
    FOnStart: TProc<TObject>;
    FOnSuccess: TProc<TObject, U>;
    FOnError: TProc<TObject, string>;
  public
    /// <summary>
    /// Gets the <c>IUseParams&lt;T&gt;</c> interface instance used by this class.
    /// </summary>
    /// <value>
    /// An instance of <c>IUseParams&lt;T&gt;</c> that provides parameter management functionality.
    /// </value>
    property Use: IUseParams<T> read FUse;
    /// <summary>
    /// The object representing the sender of the asynchronous operation.
    /// </summary>
    /// <value>
    /// An instance of <c>TObject</c> identifying the originator of the operation.
    /// </value>
    /// <remarks>
    /// This property can be set to identify the object that initiated the asynchronous operation, which is useful in callback methods.
    /// </remarks>
    property Sender: TObject read FSender write FSender;
    /// <summary>
    /// Event triggered when the asynchronous operation starts.
    /// </summary>
    /// <value>
    /// A procedure of type <c>TProc&lt;TObject&gt;</c> to handle any setup or UI updates when the operation begins.
    /// </value>
    /// <remarks>
    /// Assign a procedure to this event to perform actions at the start of the asynchronous operation.
    /// <code>
    /// OnStart :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // Code executed at the start of the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnStart: TProc<TObject> read FOnStart write FOnStart;
    /// <summary>
    /// Event triggered when the asynchronous operation completes successfully.
    /// </summary>
    /// <value>
    /// A procedure of type <c>TProc&lt;TObject, U&gt;</c> to handle the result of the operation.
    /// </value>
    /// <remarks>
    /// Assign a procedure to this event to process the result returned by the operation.
    /// <code>
    /// OnSuccess :=
    ///    procedure (Sender: TObject; Result: T)
    ///    begin
    ///      // Code executed at the end of the request with the obtained result
    ///    end;
    /// </code>
    /// </remarks>
    property OnSuccess: TProc<TObject, U> read FOnSuccess write FOnSuccess;
    /// <summary>
    /// Event triggered when an error occurs during the asynchronous operation.
    /// </summary>
    /// <value>
    /// A procedure of type <c>TProc&lt;TObject, string&gt;</c> to handle exceptions or errors.
    /// </value>
    /// <remarks>
    /// Assign a procedure to this event to handle any exceptions or errors that occur during execution.
    /// <code>
    /// OnError :=
    ///    procedure (Sender: TObject; ErrorMessage: string)
    ///    begin
    ///      // Code executed when an error occurs during the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnError: TProc<TObject, string> read FOnError write FOnError;
    /// <summary>
    /// Executes the specified function asynchronously.
    /// </summary>
    /// <param name="Value">
    /// A function of type <c>TFunc&lt;U&gt;</c> representing the operation to execute asynchronously.
    /// </param>
    /// <remarks>
    /// This method creates and starts an asynchronous task that executes the provided function.
    /// It invokes the <c>OnStart</c> event before execution, the <c>OnSuccess</c> event upon successful completion, and the <c>OnError</c> event if an exception occurs during execution.
    /// </remarks>
    procedure Run(Value: TFunc<U>);
    /// <summary>
    /// Initializes a new instance of the <c>TAsynCallBackExec&lt;T, U&gt;</c> class with the specified parameter function.
    /// </summary>
    /// <param name="Value">
    /// A function of type <c>TFunc&lt;T&gt;</c> used to create an instance of <c>IUseParams&lt;T&gt;</c>.
    /// </param>
    /// <remarks>
    /// The constructor initializes the internal <c>IUseParams&lt;T&gt;</c> interface using the provided function.
    /// </remarks>
    constructor Create(const Value: TFunc<T>);
  end;

  /// <summary>
  /// Record used to manage asynchronous events for a streaming chat request.
  /// </summary>
  /// <remarks>
  /// <c>TAsynChatStreamParams</c> allows you to handle the lifecycle of a chat request in streaming mode.
  /// It provides callbacks for different stages such as when the request starts, progresses, succeeds, encounters an error, or needs to be canceled.
  /// </remarks>
  TAsynStreamCallBack<T> = record
  private
    FSender: TObject;
    FOnStart: TProc<TObject>;
    FOnSuccess: TProc<TObject, T>;
    FOnProgress: TProc<TObject, T>;
    FOnError: TProc<TObject, string>;
    FOnCancellation: TProc<TObject>;
    FOnDoCancel: TFunc<Boolean>;
  public
    /// <summary>
    /// The object representing the sender of the asynchronous operation.
    /// </summary>
    /// <remarks>
    /// The <c>Sender</c> property is used to identify or store a reference to the object that initiated the chat request,
    /// which can be useful for context within the callback procedures.
    /// </remarks>
    property Sender: TObject read FSender write FSender;
    /// <summary>
    /// Event triggered when the asynchronous chat request starts.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="Chat">
    /// The <c>TChat</c> object representing the current response chunk received from the model.
    /// This event can be used to update the user interface as new tokens are streamed in.
    /// </param>
    /// <remarks>
    /// The <c>OnStart</c> event is called when the chat request begins. It can be used to set up any initial state or display a loading indicator to the user.
    /// <code>
    /// OnStart :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // code when chat request begin
    ///    end;
    /// </code>
    /// </remarks>
    property OnStart: TProc<TObject> read FOnStart write FOnStart;
    /// <summary>
    /// Event triggered when the asynchronous chat request completes successfully.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="Chat">
    /// The <c>TChat</c> object representing the current response chunk received from the model.
    /// This event can be used to update the user interface as new tokens are streamed in.
    /// </param>
    /// <remarks>
    /// The <c>OnSuccess</c> event is invoked when the streaming process finishes successfully.
    /// It does not provide additional data, as the result is expected to have been handled progressively via the <c>OnProgress</c> event.
    /// <code>
    /// OnSuccess :=
    ///    procedure (Sender: TObject; Chat: TChat)
    ///    begin
    ///      // code when the streaming process finishes successfully
    ///    end;
    /// </code>
    /// </remarks>
    property OnSuccess: TProc<TObject, T> read FOnSuccess write FOnSuccess;
    /// <summary>
    /// Event triggered to handle progress during the streaming chat request.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="Chat">
    /// The <c>TChat</c> object representing the current response chunk received from the model.
    /// This event can be used to update the user interface as new tokens are streamed in.
    /// </param>
    /// <remarks>
    /// The <c>OnProgress</c> event is fired every time a new chunk of data is received during the streaming process.
    /// This allows the application to handle the response progressively as it is generated by the model.
    /// <code>
    /// OnProgress :=
    ///    procedure (Sender: TObject; Chat: TChat)
    ///    begin
    ///      // code to handle the response progressively
    ///    end;
    /// </code>
    /// </remarks>
    property OnProgress: TProc<TObject, T> read FOnProgress write FOnProgress;
    /// <summary>
    /// Event triggered when an error occurs during the asynchronous chat request.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="ErrorMessage">
    /// The error message received, which can be logged or displayed to the user.
    /// </param>
    /// <remarks>
    /// The <c>OnError</c> event is called when an error occurs during the streaming process.
    /// This can be used to handle failures, show error messages, or perform any necessary clean-up actions.
    /// <code>
    /// OnError :=
    ///    procedure (Sender: TObject; message: string)
    ///    begin
    ///      // code to handle an error occurs during the streaming process
    ///    end;
    /// </code>
    /// </remarks>
    property OnError: TProc<TObject, string> read FOnError write FOnError;
    /// <summary>
    /// Event triggered when the asynchronous chat request has been canceled.
    /// </summary>
    /// <remarks>
    /// The <c>OnCancellation</c> event is fired when the chat request is canceled by the user or the application.
    /// This can be used to perform clean-up operations or notify the user that the request has been terminated.
    /// <code>
    /// OnCancellation :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // code to handle chat request cancellation
    ///    end;
    /// </code>
    /// </remarks>
    property OnCancellation: TProc<TObject> read FOnCancellation write FOnCancellation;
    /// <summary>
    /// Function called to determine if the asynchronous chat request should be canceled.
    /// </summary>
    /// <returns>
    /// A <c>Boolean</c> value indicating whether the request should be canceled (<c>True</c>) or allowed to continue (<c>False</c>).
    /// </returns>
    /// <remarks>
    /// The <c>OnDoCancel</c> function is periodically invoked to check whether the user or application has requested to cancel the chat request.
    /// If the function returns <c>True</c>, the streaming process will be aborted.
    /// <code>
    /// OnDoCancel :=
    ///    function : Boolean
    ///    begin
    ///      Result := ... // True to stop the streaming process
    ///    end;
    /// </code>
    /// </remarks>
    property OnDoCancel: TFunc<Boolean> read FOnDoCancel write FOnDoCancel;
  end;

implementation

{ TAsynCallBackExec<T, U> }

constructor TAsynCallBackExec<T, U>.Create(const Value: TFunc<T>);
begin
  inherited Create;
  FUse := TUseParamsFactory<T>.CreateInstance(Value);
end;

procedure TAsynCallBackExec<T, U>.Run(Value: TFunc<U>);
begin
  {--- Assign callback values to internal variables for asynchrony to work properly }
  var InternalSender := Sender;
  var InternalOnStart := OnStart;
  var InternalOnSuccess := OnSuccess;
  var InternalOnError := OnError;

  var Task: ITask := TTask.Create(
          procedure()
          begin
            try
              {--- Pass the instance of the current class in case no value was specified. }
              if not Assigned(InternalSender) then
                InternalSender := Self;

              {--- Trigger OnStart callback }
              if Assigned(InternalOnStart) then
                TThread.Queue(nil,
                  procedure
                  begin
                    InternalOnStart(InternalSender);
                  end);

              {--- Processing }
              var Result := Value();

              {--- Trigger OnEnd callback when the process is done }
              TThread.Queue(nil,
                  procedure
                  begin
                    try
                      if Assigned(InternalOnSuccess) then
                        InternalOnSuccess(InternalSender, Result);
                    finally
                      {--- Makes sure to release the instance containing the data obtained
                           following processing}
                      if Assigned(Result) then
                        Result.Free;
                    end;
                  end);

            except
              on E: Exception do
                begin
                  var Error := AcquireExceptionObject;
                  try
                    var ErrorMsg := (Error as Exception).Message;

                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(InternalOnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        InternalOnError(InternalSender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
          end);
  Task.Start;
end;

end.

unit Anthropic.Batches;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiAnthropic
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, System.Threading,
  REST.Json.Types, Anthropic.API.Params, Anthropic.API, Anthropic.Async.Support,
  Anthropic.Chat, Anthropic.Types;

type
  /// <summary>
  /// The <c>TBatcheParams</c> class is used to manage and define parameters for a batch of messages.
  /// It provides methods to customize the batch with specific identifiers and additional parameters.
  /// </summary>
  TBatcheParams = class(TJSONParam)
    /// <summary>
    /// Adds a custom identifier to the batch.
    /// </summary>
    /// <param name="Value">
    /// A string representing the custom ID to be added to the batch.
    /// </param>
    /// <returns>
    /// The updated <c>TBatcheParams</c> instance with the custom ID included.
    /// </returns>
    function CustomId(const Value: string): TBatcheParams;
    /// <summary>
    /// Adds chat parameters to the batch using a provided procedure.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure that defines and customizes the chat parameters for the batch.
    /// </param>
    /// <returns>
    /// The updated <c>TBatcheParams</c> instance with the added parameters.
    /// </returns>
    function Params(const ParamProc: TProc<TChatParams>): TBatcheParams;
    /// <summary>
    /// Creates a new <c>TBatcheParams</c> instance, adds a custom identifier, and defines chat parameters.
    /// </summary>
    /// <param name="Value">
    /// A string representing the custom ID for the batch.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to define the chat parameters for the batch.
    /// </param>
    /// <returns>
    /// A new <c>TBatcheParams</c> instance with the specified custom ID and parameters.
    /// </returns>
    class function Add(const Value: string; ParamProc: TProc<TChatParams>): TBatcheParams; overload;
  end;

  /// <summary>
  /// The <c>TRequestParams</c> class is used to manage and define request parameters for sending message batches.
  /// It allows you to specify multiple batch requests as part of a single request operation.
  /// </summary>
  TRequestParams = class(TJSONParam)
  public
    /// <summary>
    /// Specifies a set of batch requests to be included in the request operation.
    /// </summary>
    /// <param name="Value">
    /// An array of <c>TBatcheParams</c> instances, where each represents the parameters for an individual batch request.
    /// </param>
    /// <returns>
    /// The updated <c>TRequestParams</c> instance containing the specified batch requests.
    /// </returns>
    function Requests(Value: TArray<TBatcheParams>): TRequestParams; overload;
    /// <summary>
    /// Specifies JSONL file to be included in the request operation.
    /// </summary>
    /// <param name="FilePath">
    /// The JSONL filename.
    /// </param>
    /// <returns>
    /// The updated <c>TRequestParams</c> instance containing the specified batch requests.
    /// </returns>
    function Requests(FilePath: string): TRequestParams; overload;
  end;

  /// <summary>
  /// The <c>TRequestCounts</c> class represents the counts of different statuses related to batch processing.
  /// It tracks the number of batches that are currently being processed, successfully completed, errored, canceled, and expired.
  /// </summary>
  /// <remarks>
  /// This class provides an overview of the state of batch processing by categorizing the results into several status types,
  /// helping to monitor the success and failure rates of batch operations.
  /// </remarks>
  TRequestCounts = class
  private
    FProcessing: Int64;
    FSucceeded: Int64;
    FErrored: Int64;
    FCanceled: Int64;
    FExpired: Int64;
  public
    /// <summary>
    /// Number of requests in the Message Batch that are processing.
    /// </summary>
    property Processing: Int64 read FProcessing write FProcessing;
    /// <summary>
    /// Number of requests in the Message Batch that have completed successfully.
    /// <para>
    /// This is zero until processing of the entire Message Batch has ended.
    /// </para>
    /// </summary>
    property Succeeded: Int64 read FSucceeded write FSucceeded;
    /// <summary>
    /// Number of requests in the Message Batch that encountered an error.
    /// <para>
    /// This is zero until processing of the entire Message Batch has ended.
    /// </para>
    /// </summary>
    property Errored: Int64 read FErrored write FErrored;
    /// <summary>
    /// Number of requests in the Message Batch that have been canceled.
    /// <para>
    /// This is zero until processing of the entire Message Batch has ended.
    /// </para>
    /// </summary>
    property Canceled: Int64 read FCanceled write FCanceled;
    /// <summary>
    /// Number of requests in the Message Batch that have expired.
    /// <para>
    /// This is zero until processing of the entire Message Batch has ended.
    /// </para>
    /// </summary>
    property Expired: Int64 read FExpired write FExpired;
  end;

  /// <summary>
  /// The <c>TBatche</c> class represents a batch of messages in the system.
  /// It contains detailed information about the batch, including its processing status, request counts, timestamps, and related URLs.
  /// </summary>
  /// <remarks>
  /// This class provides key details for managing and tracking a batch of messages, such as the batch's unique identifier,
  /// its current state (in progress, canceled, or ended), and related metadata. It is essential for operations that involve handling
  /// message batches in a structured and organized manner.
  /// </remarks>
  TBatche = class
  private
    FId: string;
    FType: string;
    [JsonNameAttribute('processing_status')]
    FProcessingStatus: TProcessingStatusType;
    [JsonNameAttribute('request_counts')]
    FRequestCounts: TRequestCounts;
    [JsonNameAttribute('ended_at')]
    FEndedAt: string;
    [JsonNameAttribute('created_at')]
    FCreatedAt: string;
    [JsonNameAttribute('expires_at')]
    FExpiresAt: string;
    [JsonNameAttribute('cancel_initiated_at')]
    FCancelInitiatedAt: string;
    [JsonNameAttribute('results_url')]
    FResultsUrl: string;
  public
    /// <summary>
    /// Unique object identifier.
    /// </summary>
    /// <remarks>
    /// The format and length of IDs may change over time.
    /// </remarks>
    property Id: string read FId write FId;
    /// <summary>
    /// For Message Batches, this is always "message_batch".
    /// </summary>
    /// <remarks>
    /// Available options: message_batch
    /// </remarks>
    property &Type: string read FType write FType;
    /// <summary>
    /// Processing status of the Message Batch.
    /// </summary>
    /// <remarks>
    /// Available options: in_progress, canceling, ended
    /// </remarks>
    property ProcessingStatus: TProcessingStatusType read FProcessingStatus write FProcessingStatus;
    /// <summary>
    /// Tallies requests within the Message Batch, categorized by their status.
    /// </summary>
    /// <remarks>
    /// Requests start as processing and move to one of the other statuses only once processing of the entire batch ends. The sum of all values always matches the total number of requests in the batch.
    /// </remarks>
    property RequestCounts: TRequestCounts read FRequestCounts write FRequestCounts;
    /// <summary>
    /// RFC 3339 datetime string representing the time at which processing for the Message Batch ended. Specified only once processing ends.
    /// </summary>
    /// <remarks>
    /// Processing ends when every request in a Message Batch has either succeeded, errored, canceled, or expired.
    /// </remarks>
    property EndedAt: string read FEndedAt write FEndedAt;
    /// <summary>
    /// RFC 3339 datetime string representing the time at which the Message Batch was created.
    /// </summary>
    property CreatedAt: string read FCreatedAt write FCreatedAt;
    /// <summary>
    /// RFC 3339 datetime string representing the time at which the Message Batch will expire and end processing, which is 24 hours after creation.
    /// </summary>
    property ExpiresAt: string read FExpiresAt write FExpiresAt;
    /// <summary>
    /// RFC 3339 datetime string representing the time at which cancellation was initiated for the Message Batch. Specified only if cancellation was initiated.
    /// </summary>
    property CancelInitiatedAt: string read FCancelInitiatedAt write FCancelInitiatedAt;
    /// <summary>
    /// URL to a .jsonl file containing the results of the Message Batch requests. Specified only once processing ends.
    /// </summary>
    /// <remarks>
    /// Results in the file are not guaranteed to be in the same order as requests. Use the <b>custom_id</b> field to match results to requests.
    /// </remarks>
    property ResultsUrl: string read FResultsUrl write FResultsUrl;
    /// <summary>
    /// Destructor to clean up resources used by this <c>TBatche</c> instance.
    /// </summary>
    /// <remarks>
    /// The destructor ensures that any allocated resources, such as <b>RequestCounts</>, is properly released when the object is no longer needed.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// The <c>TBatcheList</c> class represents a collection of batch objects, along with metadata about the batch list.
  /// It includes information about whether there are more batches to be fetched and provides identifiers for pagination purposes.
  /// </summary>
  /// <remarks>
  /// This class is used to handle lists of batches returned from the API, enabling pagination through the first and last batch identifiers
  /// and indicating whether additional batches are available beyond the current list.
  /// </remarks>
  TBatcheList = class
  private
    FData: TArray<TBatche>;
    [JsonNameAttribute('has_more')]
    FHasMore: Boolean;
    [JsonNameAttribute('first_id')]
    FFirstId: string;
    [JsonNameAttribute('last_id')]
    FLastId: string;
  public
    /// <summary>
    /// Array of batches of messages
    /// </summary>
    property Data: TArray<TBatche> read FData write FData;
    /// <summary>
    /// Indicates if there are more results in the requested page direction.
    /// </summary>
    property HasMore: Boolean read FHasMore write FHasMore;
    /// <summary>
    /// First ID in the data list. Can be used as the before_id for the previous page.
    /// </summary>
    property FirstId: string read FFirstId write FFirstId;
    /// <summary>
    /// Last ID in the data list. Can be used as the after_id for the next page.
    /// </summary>
    property LastId: string read FLastId write FLastId;
    /// <summary>
    /// Destructor to clean up resources used by this <c>TBatcheList</c> instance.
    /// </summary>
    /// <remarks>
    /// The destructor ensures that any allocated resources, such as the array of <b>TBatche</>, is properly released when the object is no longer needed.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// The <c>TBatchDelete</c> class represents a batch deletion operation.
  /// It provides information about the identifier and type of the batch being deleted.
  /// </summary>
  /// <remarks>
  /// This class is used to manage the deletion of batches, enabling the application
  /// to track which batch is being removed from the system. It encapsulates the batch
  /// identifier and type information necessary for deletion requests.
  /// </remarks>
  TBatchDelete = class
  private
    FId: string;
    FType: string;
  public
    /// <summary>
    /// Gets or sets the unique identifier of the batch to be deleted.
    /// </summary>
    /// <remarks>
    /// This property specifies the unique batch ID that is used to identify
    /// the batch to be removed from the system.
    /// </remarks>
    property Id: string read FId write FId;
    /// <summary>
    /// Gets or sets the type of the batch being deleted.
    /// </summary>
    /// <remarks>
    /// For most cases, this will be set to "message_batch" to indicate
    /// that the batch being deleted is of type message batch.
    /// </remarks>
    property &Type: string read FType write FType;
  end;

  /// <summary>
  /// The <c>TListParams</c> class is used to define parameters for retrieving lists of batches.
  /// It allows for pagination by setting limits, specifying batch IDs to start after, or ending before.
  /// </summary>
  /// <remarks>
  /// This class helps in controlling the number of results returned in list queries and enables efficient data navigation
  /// through the use of pagination parameters such as <c>Limit</c>, <c>AfterId</c>, and <c>BeforeId</c>.
  /// <para>
  /// <b>--- Warning:</b> The parameters <c>AfterId</c> and <c>BeforeId</c> are mutually exclusive, meaning that both cannot be used simultaneously
  /// in a single query. Ensure that only one of these parameters is set at a time to avoid conflicts.
  /// </para>
  /// </remarks>
  TListParams = class(TUrlParam)
  public
    /// <summary>
    /// Sets the limit for the number of batches to be retrieved.
    /// </summary>
    /// <param name="Value">
    /// An integer representing the limit. The valid range is 1 to 100.
    /// </param>
    /// <returns>
    /// The current instance of <c>TListParams</c> with the specified limit.
    /// </returns>
    /// <exception cref="Exception">
    /// Thrown if the value is less than 1 or greater than 100.
    /// </exception>
    /// <remarks>
    /// The default value of limit set to 20.
    /// </remarks>
    function Limite(const Value: Integer): TListParams;
    /// <summary>
    /// Sets the batch ID that will be used as a reference to fetch batches created after it.
    /// </summary>
    /// <param name="Value">
    /// A string representing the batch ID.
    /// </param>
    /// <returns>
    /// The current instance of <c>TListParams</c> with the specified <c>after_id</c> value.
    /// </returns>
    function AfterId(const Value: string): TListParams;
    /// <summary>
    /// Sets the batch ID that will be used as a reference to fetch batches created before it.
    /// </summary>
    /// <param name="Value">
    /// A string representing the batch ID.
    /// </param>
    /// <returns>
    /// The current instance of <c>TListParams</c> with the specified <c>before_id</c> value.
    /// </returns>
    function BeforeId(const Value: string): TListParams;
  end;

  /// <summary>
  /// The <c>TAsynBatche</c> class is a type alias used to handle asynchronous callbacks for batch processing.
  /// It provides support for executing batch operations asynchronously and processing the results upon completion.
  /// </summary>
  /// <remarks>
  /// This class is part of the asynchronous framework that allows non-blocking batch operations.
  /// It uses a callback mechanism to return the result of a batch process once it is completed.
  /// </remarks>
  TAsynBatche = TAsynCallBack<TBatche>;

  /// <summary>
  /// The <c>TAsynBatcheList</c> class represents an asynchronous callback for handling operations that return a list of batch objects (<c>TBatcheList</c>).
  /// It is used to manage asynchronous processes where a list of batches is retrieved, processed, or manipulated.
  /// </summary>
  /// <remarks>
  /// This class is typically employed in scenarios where batch lists need to be fetched or processed asynchronously, allowing for
  /// non-blocking execution and handling of potentially large sets of batch data.
  /// </remarks>
  TAsynBatcheList = TAsynCallBack<TBatcheList>;

  /// <summary>
  /// The <c>TAsynStringList</c> class is a callback handler for asynchronous operations that return a <c>TStringList</c> result.
  /// It is used to process string list data asynchronously, such as retrieving batch results from the API.
  /// </summary>
  /// <remarks>
  /// This class allows for non-blocking operations where a <c>TStringList</c> is returned, enabling efficient handling of large datasets or long-running tasks.
  /// The callback mechanism helps in managing success, error handling, and overall execution flow.
  /// </remarks>
  TAsynStringList = TAsynCallBack<TStringList>;

  /// <summary>
  /// The <c>TAsynBatchDelete</c> class is a callback handler for asynchronous operations that return a <c>TStringList</c> result.
  /// It is used to process string list data asynchronously, such as retrieving batch results from the API.
  /// </summary>
  /// <remarks>
  /// This class allows for non-blocking operations where a <c>TBatchDelete</c> is returned, enabling efficient handling of large datasets or long-running tasks.
  /// The callback mechanism helps in managing success, error handling, and overall execution flow.
  /// </remarks>
  TAsynBatchDelete = TAsynCallBack<TBatchDelete>;

  /// <summary>
  /// The <c>TBatcheRoute</c> class provides methods to interact with and manage message batches via the API.
  /// It allows for creating, retrieving, canceling, and listing batches asynchronously and synchronously.
  /// </summary>
  /// <remarks>
  /// This class serves as the main route for performing batch operations within the API. It supports both asynchronous and synchronous operations,
  /// enabling batch creation, retrieval of batch results, cancellation of batch processing, and fetching lists of batches.
  /// </remarks>
  TBatcheRoute = class(TAnthropicAPIRoute)
  public
    /// <summary>
    /// Creates a batch request asynchronously.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to define the parameters for the batch request, including necessary configurations such as model selection, messages, and additional options.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a <c>TAsynBatche</c> record containing event handlers for managing the asynchronous request, including success and error handling.
    /// </param>
    /// <remarks>
    /// This method initiates an asynchronous batch creation request based on the provided parameters. The result or any errors will be handled by the specified callbacks.
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// var AnthropicBatche := TAnthropicFactory.CreateInstance(BaererKey, batches);
    /// AnthropicBatche.Batche.AsynCreate(
    ///   procedure (Params: TRequestParams)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynBatche
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TBatche)
    ///        begin
    ///          // Handle the value
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsynCreate(ParamProc: TProc<TRequestParams>; CallBacks: TFunc<TAsynBatche>); overload;
    /// <summary>
    /// Creates a batch request asynchronously using a <c>TJSONObject</c>.
    /// </summary>
    /// <param name="FilePath"> The JSON file containing the parameters for the batch request.</param>
    /// <param name="CallBacks">
    /// A function that returns a <c>TAsynBatche</c> record for handling asynchronous events, such as on success or on error.
    /// </param>
    /// <remarks>
    /// This method allows for creating a batch request asynchronously using a <c>TJSONObject</c> to specify the parameters.
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// var AnthropicBatche := TAnthropicFactory.CreateInstance(BaererKey, batches);
    /// AnthropicBatche.Batche.AsynCreate(FilePath,
    ///   function : TAsynBatche
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TBatche)
    ///        begin
    ///          // Handle the value
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsynCreate(const FilePath: string; CallBacks: TFunc<TAsynBatche>); overload;
    /// <summary>
    /// Creates a batch request asynchronously using a <c>TJSONObject</c>.
    /// </summary>
    /// <param name="Value">The JSON object containing the parameters for the batch request.</param>
    /// <param name="CallBacks">
    /// A function that returns a <c>TAsynBatche</c> record for handling asynchronous events, such as on success or on error.
    /// </param>
    /// <remarks>
    /// This method allows for creating a batch request asynchronously using a <c>TJSONObject</c> to specify the parameters.
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// var AnthropicBatche := TAnthropicFactory.CreateInstance(BaererKey, batches);
    /// AnthropicBatche.Batche.AsynCreate(Value,
    ///   function : TAsynBatche
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TBatche)
    ///        begin
    ///          // Handle the value
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsynCreate(Value: TJSONObject; CallBacks: TFunc<TAsynBatche>); overload;
    /// <summary>
    /// Retrieves a batch result asynchronously by its identifier.
    /// </summary>
    /// <param name="Id">The unique identifier of the batch to retrieve.</param>
    /// <param name="CallBacks">
    /// A function that returns a <c>TAsynBatche</c> record, handling success or error during the asynchronous retrieval.
    /// </param>
    /// <remarks>
    /// This method retrieves the result of a batch process asynchronously using its unique ID. Callbacks handle the process results or errors.
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// var AnthropicBatche := TAnthropicFactory.CreateInstance(BaererKey, batches);
    /// AnthropicBatche.Batche.ASynRetrieve(Id,
    ///   function : TAsynBatche
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TBatche)
    ///        begin
    ///          // Handle the value
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsynRetrieve(const Id: string; CallBacks: TFunc<TAsynBatche>); overload;
    /// <summary>
    /// Retrieves a batch result asynchronously and saves it to a file.
    /// </summary>
    /// <param name="Id">The unique identifier of the batch to retrieve.</param>
    /// <param name="FileName">The name of the file where the batch result will be saved.</param>
    /// <param name="CallBacks">
    /// A function that returns a <c>TAsynStringList</c> record for managing success or error events during the asynchronous file saving process.
    /// </param>
    /// <remarks>
    /// This method retrieves the result of a batch process asynchronously by its ID and saves the result to a file. Callbacks manage the process events.
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// var AnthropicBatche := TAnthropicFactory.CreateInstance(BaererKey, batches);
    /// AnthropicBatche.Batche.ASynRetrieve(Id, FileName,
    ///   function : TAsynStringList
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TStringList)
    ///        begin
    ///          // Handle the value
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure ASynRetrieve(const Id: string; FileName: string; CallBacks: TFunc<TAsynStringList>); overload;
    /// <summary>
    /// Lists all batches asynchronously.
    /// </summary>
    /// <param name="CallBacks">
    /// A function that returns a <c>TAsynBatcheList</c> record, managing the event handling for asynchronous listing, including progress, success, and error callbacks.
    /// </param>
    /// <remarks>
    /// This method fetches a list of all available batches asynchronously. Callbacks handle events such as receiving data or errors during the listing process.
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// var AnthropicBatche := TAnthropicFactory.CreateInstance(BaererKey, batches);
    /// AnthropicBatche.Batche.AsynList(
    ///   function : TAsynBatcheList
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TBatcheList)
    ///        begin
    ///          // Handle the value
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsynList(CallBacks: TFunc<TAsynBatcheList>); overload;
    /// <summary>
    /// Lists batches asynchronously using specific parameters.
    /// </summary>
    /// <param name="Params">
    /// A <c>TListParams1</c> object containing filtering and paging options for batch listing.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a <c>TAsynBatcheList</c> record for handling asynchronous batch listing, including success and error events.
    /// </param>
    /// <remarks>
    /// This method allows for retrieving a list of batches asynchronously, with the ability to apply specific filters and paging parameters.
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// var AnthropicBatche := TAnthropicFactory.CreateInstance(BaererKey, batches);
    /// AnthropicBatche.Batche.AsynList(
    ///   procedure (Params: TListParams)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynBatcheList
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TBatcheList)
    ///        begin
    ///          // Handle the value
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsynList(ParamProc: TProc<TListParams>; CallBacks: TFunc<TAsynBatcheList>); overload;
    /// <summary>
    /// Cancels a batch operation asynchronously by its ID.
    /// </summary>
    /// <param name="Id">The unique identifier of the batch to be canceled.</param>
    /// <param name="CallBacks">
    /// A function that returns a <c>TAsynBatche</c> record to handle success or error during the asynchronous cancellation.
    /// </param>
    /// <remarks>
    /// This method cancels a batch process asynchronously using its unique ID. The result or any error is managed by the callbacks provided.
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// var AnthropicBatche := TAnthropicFactory.CreateInstance(BaererKey, batches);
    /// AnthropicBatche.Batche.AsynCancel(Id,
    ///   function : TAsynBatche
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TBatche)
    ///        begin
    ///          // Handle the value
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsynCancel(const Id: string; CallBacks: TFunc<TAsynBatche>);
    /// <summary>
    /// Delete a batch operation asynchronously by its ID.
    /// </summary>
    /// <param name="Id">The unique identifier of the batch to be deleted.</param>
    /// <param name="CallBacks">
    /// A function that returns a <c>TAsynBatchDelete</c> record to handle success or error during the asynchronous cancellation.
    /// </param>
    /// <remarks>
    /// This method delete a batch process asynchronously using its unique ID. The result or any error is managed by the callbacks provided.
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// var AnthropicBatche := TAnthropicFactory.CreateInstance(BaererKey, batches);
    /// AnthropicBatche.Batche.AsynDelete(Id,
    ///   function : TAsynBatchDelete
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TBatchDelete)
    ///        begin
    ///          // Handle the value
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsynDelete(const Id: string; CallBacks: TFunc<TAsynBatchDelete>);
    /// <summary>
    /// Creates a batch request synchronously.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the parameters for the batch request, such as model, messages, token limits, etc.
    /// </param>
    /// <returns>
    /// A <c>TBatche</c> object containing the result of the created batch request.
    /// </returns>
    /// <remarks>
    /// This method sends a batch creation request synchronously and returns the result as a <c>TBatche</c> object.
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// var AnthropicBatche := TAnthropicFactory.CreateInstance(BaererKey, batches);
    /// var Value := AnthropicBatche.Batche.Create(
    ///   procedure (Params: TRequestParams)
    ///   begin
    ///     // Define parameters
    ///   end);
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function Create(ParamProc: TProc<TRequestParams>): TBatche; overload;
    /// <summary>
    /// Creates a batch request synchronously using a <c>TJSONObject</c>.
    /// </summary>
    /// <param name="FilePath"> The JSONL file name containing the parameters for the batch request.</param>
    /// <returns>
    /// A <c>TBatche</c> object containing the result of the created batch request.
    /// </returns>
    /// <remarks>
    /// This method sends a batch creation request synchronously using a <c>TJSONObject</c> to specify parameters and returns the result.
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// var AnthropicBatche := TAnthropicFactory.CreateInstance(BaererKey, batches);
    /// var Value := AnthropicBatche.Batche.Create(FilePath);
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function Create(const FilePath: string): TBatche; overload;
    /// <summary>
    /// Creates a batch request synchronously using a <c>TJSONObject</c>.
    /// </summary>
    /// <param name="Value">The JSON object containing the parameters for the batch request.</param>
    /// <returns>
    /// A <c>TBatche</c> object containing the result of the created batch request.
    /// </returns>
    /// <remarks>
    /// This method sends a batch creation request synchronously using a <c>TJSONObject</c> to specify parameters and returns the result.
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// var AnthropicBatche := TAnthropicFactory.CreateInstance(BaererKey, batches);
    /// var Value := AnthropicBatche.Batche.Create(Value);
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function Create(Value: TJSONObject): TBatche; overload;
    /// <summary>
    /// Retrieves a batch result synchronously by its identifier.
    /// </summary>
    /// <param name="Id">The unique identifier of the batch to retrieve.</param>
    /// <returns>
    /// A <c>TBatche</c> object containing the result of the batch request.
    /// </returns>
    /// <remarks>
    /// This method retrieves a batch result synchronously using its unique ID.
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// var AnthropicBatche := TAnthropicFactory.CreateInstance(BaererKey, batches);
    /// var Value := AnthropicBatche.Batche.Retrieve(BatchId);
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function Retrieve(const Id: string): TBatche; overload;
    /// <summary>
    /// Retrieves a batch result synchronously by its identifier and saves it to a file.
    /// </summary>
    /// <param name="Id">The unique identifier of the batch to retrieve.</param>
    /// <param name="FileName">The name of the file where the batch result will be saved.</param>
    /// <returns>
    /// A <c>TStringList</c> object containing the retrieved batch result saved to the file.
    /// </returns>
    /// <remarks>
    /// This method retrieves a batch result synchronously and saves it to a file.
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// var AnthropicBatche := TAnthropicFactory.CreateInstance(BaererKey, batches);
    /// var JSONL := AnthropicBatche.Batche.Retrieve(BatchId, 'Result.jsonl');
    ///
    ///  with JSONL.GetEnumerator do
    ///    try
    ///      while MoveNext do
    ///        // Handle the "current" data
    ///    finally
    ///      Free;
    ///      JSONL.Free;
    ///    end;
    /// </code>
    /// </remarks>
    function Retrieve(const Id: string; FileName: string): TStringList; overload;
    /// <summary>
    /// Lists all batches synchronously.
    /// </summary>
    /// <returns>
    /// A <c>TBatcheList</c> object containing a list of all batches.
    /// </returns>
    /// <remarks>
    /// This method retrieves a list of all available batches synchronously.
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// var AnthropicBatche := TAnthropicFactory.CreateInstance(BaererKey, batches);
    /// var Value := AnthropicBatche.Batche.List;
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function List: TBatcheList; overload;
    /// <summary>
    /// Lists batches synchronously using specific parameters.
    /// </summary>
    /// <param name="Params">
    /// A <c>TListParams1</c> object containing filtering and paging options for batch listing.
    /// </param>
    /// <returns>
    /// A <c>TBatcheList</c> object containing the filtered list of batches.
    /// </returns>
    /// <remarks>
    /// This method retrieves a list of batches synchronously, with the option to apply specific filters and paging parameters.
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// var AnthropicBatche := TAnthropicFactory.CreateInstance(BaererKey, batches);
    /// var Value := AnthropicBatche.Batche.Delete(
    ///   procedure (Params: TListParams)
    ///   begin
    ///     // Define parameters
    ///   end);
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function List(ParamProc: TProc<TListParams>): TBatcheList; overload;
    /// <summary>
    /// Cancels a batch operation synchronously by its ID.
    /// </summary>
    /// <param name="Id">The unique identifier of the batch to be canceled.</param>
    /// <returns>
    /// A <c>TBatche</c> object containing the result of the cancellation request.
    /// </returns>
    /// <remarks>
    /// This method cancels a batch process synchronously by its unique ID.
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// var AnthropicBatche := TAnthropicFactory.CreateInstance(BaererKey, batches);
    /// var Value := AnthropicBatche.Batche.Cancel(Id);
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function Cancel(const Id: string): TBatche;
    /// <summary>
    /// Delete a batch operation synchronously by its ID.
    /// </summary>
    /// <param name="Id">The unique identifier of the batch to be deleted.</param>
    /// <returns>
    /// A <c>TBatche</c> object containing the result of the deletion request.
    /// </returns>
    /// <remarks>
    /// This method deletes a batch process synchronously by its unique ID.
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// var AnthropicBatche := TAnthropicFactory.CreateInstance(BaererKey, batches);
    /// var Value := AnthropicBatche.Batche.Delete(Id);
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function Delete(const Id: string): TBatchDelete;
  end;

implementation

uses
  System.StrUtils, System.Rtti, Rest.Json;

{ TBatcheParamsParams }

function TBatcheParams.CustomId(const Value: string): TBatcheParams;
begin
  Result := TBatcheParams(Add('custom_id', Value));
end;

class function TBatcheParams.Add(const Value: string;
  ParamProc: TProc<TChatParams>): TBatcheParams;
begin
  Result := TBatcheParams.Create.CustomId(Value).Params(ParamProc);
end;

function TBatcheParams.Params(const ParamProc: TProc<TChatParams>): TBatcheParams;
begin
  var Data := TChatParams.Create;
  try
    if Assigned(ParamProc) then
      begin
        ParamProc(Data);
        Result := TBatcheParams(Add('params', Data as TJSONParam));
      end
    else
      Result := Self;
  finally
    Data.Free;
  end;
end;

{ TRequestParams }

function TRequestParams.Requests(Value: TArray<TBatcheParams>): TRequestParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TRequestParams(Add('requests', JSONArray));
end;

function TRequestParams.Requests(FilePath: string): TRequestParams;
begin
  Result := TRequestParams(AddJSONL('requests', FilePath));
end;

{ TBatcheRoute }

procedure TBatcheRoute.AsynCreate(ParamProc: TProc<TRequestParams>;
  CallBacks: TFunc<TAsynBatche>);
begin
  with TAsynCallBackExec<TAsynBatche, TBatche>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TBatche
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TBatcheRoute.AsynCancel(const Id: string;
  CallBacks: TFunc<TAsynBatche>);
begin
  with TAsynCallBackExec<TAsynBatche, TBatche>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TBatche
      begin
        Result := Self.Cancel(Id);
      end);
  finally
    Free;
  end;
end;

procedure TBatcheRoute.AsynCreate(Value: TJSONObject;
  CallBacks: TFunc<TAsynBatche>);
begin
  with TAsynCallBackExec<TAsynBatche, TBatche>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TBatche
      begin
        Result := Self.Create(Value);
      end);
  finally
    Free;
  end;
end;

procedure TBatcheRoute.AsynCreate(const FilePath: string;
  CallBacks: TFunc<TAsynBatche>);
begin
  with TAsynCallBackExec<TAsynBatche, TBatche>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TBatche
      begin
        Result := Self.Create(FilePath);
      end);
  finally
    Free;
  end;
end;

procedure TBatcheRoute.AsynDelete(const Id: string;
  CallBacks: TFunc<TAsynBatchDelete>);
begin
  with TAsynCallBackExec<TAsynBatchDelete, TBatchDelete>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TBatchDelete
      begin
        Result := Self.Delete(Id);
      end);
  finally
    Free;
  end;
end;

procedure TBatcheRoute.AsynList(ParamProc: TProc<TListParams>;
  CallBacks: TFunc<TAsynBatcheList>);
begin
  with TAsynCallBackExec<TAsynBatcheList, TBatcheList>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TBatcheList
      begin
        Result := Self.List(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TBatcheRoute.AsynRetrieve(const Id: string; FileName: string;
  CallBacks: TFunc<TAsynStringList>);
begin
  with TAsynCallBackExec<TAsynStringList, TStringList>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TStringList
      begin
        Result := Self.Retrieve(Id, FileName);
      end);
  finally
    Free;
  end;
end;

procedure TBatcheRoute.ASynRetrieve(const Id: string;
  CallBacks: TFunc<TAsynBatche>);
begin
  with TAsynCallBackExec<TAsynBatche, TBatche>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TBatche
      begin
        Result := Self.Retrieve(Id);
      end);
  finally
    Free;
  end;
end;

procedure TBatcheRoute.AsynList(CallBacks: TFunc<TAsynBatcheList>);
begin
  with TAsynCallBackExec<TAsynBatcheList, TBatcheList>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TBatcheList
      begin
        Result := Self.List;
      end);
  finally
    Free;
  end;
end;

function TBatcheRoute.Cancel(const Id: string): TBatche;
begin
  Result := API.Post<TBatche>(Format('messages/batches/%s/cancel', [Id]));
end;

function TBatcheRoute.Create(const FilePath: string): TBatche;
begin
  Result := Create(
    procedure (Params: TRequestParams)
    begin
      Params.Requests(FilePath);
    end);
end;

function TBatcheRoute.Create(ParamProc: TProc<TRequestParams>): TBatche;
begin
  Result := API.Post<TBatche, TRequestParams>('messages/batches', ParamProc);
end;

function TBatcheRoute.Create(Value: TJSONObject): TBatche;
begin
  Result := API.Post<TBatche>('messages/batches', Value);
end;

function TBatcheRoute.Delete(const Id: string): TBatchDelete;
begin
  Result := API.Delete<TBatchDelete>('messages/batches/' + Id);
end;

function TBatcheRoute.List: TBatcheList;
begin
  Result := API.Get<TBatcheList>('messages/batches');
end;

function TBatcheRoute.List(ParamProc: TProc<TListParams>): TBatcheList;
begin
  Result := API.Get<TBatcheList, TListParams>('messages/batches', ParamProc);
end;

function TBatcheRoute.Retrieve(const Id: string): TBatche;
begin
  Result := API.Get<TBatche>('messages/batches/' + Id);
end;

function TBatcheRoute.Retrieve(const Id: string; FileName: string): TStringList;
begin
  Result := TStringList.Create;
  with Result do
  begin
    var Response := API.Get(Format('messages/batches/%s/results', [Id]));
    Text := Response;
    SaveToFile(FileName, TEncoding.UTF8);
  end;
end;

{ TBatcheList }

destructor TBatcheList.Destroy;
begin
  for var Item in FData do
    Item.Free;
  inherited;
end;

{ TBatche }

destructor TBatche.Destroy;
begin
  if Assigned(FRequestCounts) then
    FRequestCounts.Free;
  inherited;
end;

{ TListParams }

function TListParams.AfterId(const Value: string): TListParams;
begin
  Result := TListParams(Add('after_id', Value));
end;

function TListParams.BeforeId(const Value: string): TListParams;
begin
  Result := TListParams(Add('before_id', Value));
end;

function TListParams.Limite(const Value: Integer): TListParams;
begin
  Result := TListParams(Add('limit', Value));
end;

end.

unit Anthropic.Batches.Support;

interface

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiAnthropic
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, System.Threading,
  REST.Json.Types, Anthropic.Chat;

type
  TBatcheResultItem = class;

  /// <summary>
  /// Provides an interface for managing batch results and associated file information.
  /// </summary>
  /// <remarks>
  /// The IBatcheResults interface allows for the retrieval of batch result items
  /// and management of the file from which these results are loaded. It ensures
  /// that the specified file exists before loading and provides access to individual
  /// batch results through the Batches property.
  /// </remarks>
  IBatcheResults = interface
    ['{6C5431EA-9862-49A8-8F2C-91D8AD7A45BC}']
    /// <summary>
    /// Retrieves the name of the file associated with the batch results.
    /// </summary>
    /// <value>
    /// A string representing the filename.
    /// </value>
    function GetFileName: string;
    /// <summary>
    /// Sets the name of the file associated with the batch results.
    /// </summary>
    /// <param name="Value">
    /// A string representing the filename to be set.
    /// </param>
    /// <remarks>
    /// This method validates the existence of the specified file before setting the filename.
    /// If the file does not exist, an exception is raised.
    /// </remarks>
    procedure SetFileName(const Value: string);
    /// <summary>
    /// Retrieves the array of batch result items.
    /// </summary>
    /// <value>
    /// An array of <see cref="TBatcheResultItem"/> instances representing individual batch results.
    /// </value>
    function GetBatches: TArray<TBatcheResultItem>;
    /// <summary>
    /// Gets the collection of batch result items.
    /// </summary>
    /// <value>
    /// An array of <see cref="TBatcheResultItem"/> representing the batch results.
    /// </value>
    property Batches: TArray<TBatcheResultItem> read GetBatches;
    /// <summary>
    /// Gets or sets the name of the file associated with the batch results.
    /// </summary>
    /// <value>
    /// A string representing the filename.
    /// </value>
    /// <remarks>
    /// When setting the FileName property, the interface ensures that the specified file exists.
    /// It then loads and parses the batch results from the file.
    /// </remarks>
    property FileName: string read GetFileName write SetFileName;
  end;

  /// <summary>
  /// Factory class responsible for creating instances of <see cref="IBatcheResults"/>.
  /// </summary>
  /// <remarks>
  /// The <c>TBatcheResultsFactory</c> provides a centralized way to instantiate <c>IBatcheResults</c>
  /// objects, optionally initializing them with a specified file. This ensures that all
  /// instances are created consistently throughout the application.
  /// </remarks>
  TBatcheResultsFactory = class
    /// <summary>
    /// Creates a new instance of <see cref="IBatcheResults"/>.
    /// </summary>
    /// <param name="FileName">
    /// An optional parameter specifying the file name to initialize the <c>IBatcheResults</c> instance.
    /// If provided, the factory will load batch results from the specified file.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>IBatcheResults</c>. If <paramref name="FileName"/> is provided and valid,
    /// the returned instance will be initialized with the data from the file.
    /// </returns>
    /// <remarks>
    /// The factory method ensures that the created <c>IBatcheResults</c> instance is properly initialized.
    /// If the <paramref name="FileName"/> does not exist, an exception will be raised.
    /// </remarks>
    class function CreateInstance(const FileName: string = ''): IBatcheResults;
  end;

  /// <summary>
  /// Represents the result of a single batch operation.
  /// </summary>
  /// <remarks>
  /// The <c>TBatcheResult</c> class contains detailed information about the outcome of a batch request,
  /// including the type of result and the associated chat message.
  /// </remarks>
  TBatcheResult = class
  private
    FType: string;
    FMessage: TChat;
  public
    /// <summary>
    /// Gets or sets the type of the batch result.
    /// </summary>
    /// <remarks>
    /// This property typically indicates the nature or category of the result.
    /// </remarks>
    property &type: string read Ftype write Ftype;
    /// <summary>
    /// Gets or sets the chat message associated with the batch result.
    /// </summary>
    /// <remarks>
    /// The <c>Message</c> property holds the <c>TChat</c> object that contains the detailed information
    /// of the chat message resulting from the batch operation.
    /// </remarks>
    property Message: TChat read FMessage write FMessage;
    /// <summary>
    /// Destructor to clean up resources used by this <c>TBatcheResult</c> instance.
    /// </summary>
    /// <remarks>
    /// The destructor ensures that any allocated resources, such as the <c>Message</c> object, are properly released
    /// when the instance is no longer needed.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents an individual item within a batch result.
  /// </summary>
  /// <remarks>
  /// The <c>TBatcheResultItem</c> class encapsulates a single result item from a batch operation,
  /// including a custom identifier and the corresponding batch result.
  /// </remarks>
  TBatcheResultItem = class
  private
    [JsonNameAttribute('custom_id')]
    FCustomId: string;
    FResult: TBatcheResult;
  public
    /// <summary>
    /// Gets or sets the custom identifier associated with the batch result item.
    /// </summary>
    /// <remarks>
    /// The <c>CustomId</c> property allows for matching results to specific requests within a batch
    /// by using a unique custom identifier provided during the batch creation.
    /// </remarks>
    property CustomId: string read FCustomId write FCustomId;
    /// <summary>
    /// Gets or sets the result of the batch operation.
    /// </summary>
    /// <remarks>
    /// The <c>Result</c> property holds the <c>TBatcheResult</c> object that contains the outcome
    /// and details of the specific batch request associated with the <c>CustomId</c>.
    /// </remarks>
    property Result: TBatcheResult read FResult write FResult;
    /// <summary>
    /// Destructor to clean up resources used by this <c>TBatcheResultItem</c> instance.
    /// </summary>
    /// <remarks>
    /// The destructor ensures that any allocated resources, such as the <c>Result</c> object, are properly released
    /// when the instance is no longer needed.
    /// </remarks>
    destructor Destroy; override;
  end;

implementation

uses
  REST.Json;

type
  TBatcheResults = class(TInterfacedObject, IBatcheResults)
  private
    FBatches: TArray<TBatcheResultItem>;
    FFileName: string;
    function GetFileName: string;
    procedure SetFileName(const Value: string);
    procedure Clear;
    procedure Reflexion(const Value: string);
    function GetBatches: TArray<TBatcheResultItem>;
  public
    destructor Destroy; override;
  end;

{ TBatcheResults }

procedure TBatcheResults.Clear;
begin
  for var Item in FBatches do
    Item.Free;
  FBatches := [];
end;

destructor TBatcheResults.Destroy;
begin
  Clear;
  inherited;
end;

function TBatcheResults.GetBatches: TArray<TBatcheResultItem>;
begin
  Result := FBatches;
end;

function TBatcheResults.GetFileName: string;
begin
  Result := FFileName;
end;

procedure TBatcheResults.Reflexion(const Value: string);
begin
  FBatches := FBatches + [TJson.JsonToObject<TBatcheResultItem>(Value)];
end;

procedure TBatcheResults.SetFileName(const Value: string);
begin
  if not FileExists(Value) then
    raise Exception.CreateFmt('File not found' + sLineBreak + '%s', [Value]);
  Clear;
  FFileName := Value;
  with TStringList.Create do
  try
    LoadFromFile(FFileName, TEncoding.UTF8);
    with GetEnumerator do
    try
      while MoveNext do
        Reflexion(Current);
    finally
      Free;
    end;
  finally
    Free;
  end;
end;

{ TBatcheResultsFactory }

class function TBatcheResultsFactory.CreateInstance(const FileName: string): IBatcheResults;
begin
  Result := TBatcheResults.Create;
  if not FileName.IsEmpty then
    Result.FileName := FileName;
end;

{ TBatcheResultItem }

destructor TBatcheResultItem.Destroy;
begin
  if Assigned(FResult) then
    FResult.Free;
  inherited;
end;

{ TBatcheResult }

destructor TBatcheResult.Destroy;
begin
  if Assigned(FMessage) then
    FMessage.Free;
  inherited;
end;

end.

unit Anthropic.Chat;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiAnthropic
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, System.Threading,
  REST.Json.Types, Anthropic.API.Params, Anthropic.API, Anthropic.Functions.Core,
  Anthropic.Async.Support, Anthropic.Async.Params, Anthropic.Types;

type
  /// <summary>
  /// Represents an image source in the content payload.
  /// </summary>
  /// <remarks>
  /// This class is used to construct image-related content in a chat message, including
  /// its type, media type, and data. The data can be encoded in Base64 format for secure
  /// transmission or direct use, depending on the context.
  /// </remarks>
  TContentImageSource = class(TJSONParam)
  public
    /// <summary>
    /// Sets the type of the content.
    /// </summary>
    /// <param name="Value">
    /// The type of the content, typically "image".
    /// </param>
    /// <returns>
    /// The updated <c>TContentImageSource</c> instance.
    /// </returns>
    /// <remarks>
    /// This property is used to specify the general type of the content being added.
    /// </remarks>
    function &Type(const Value: string): TContentImageSource;
    /// <summary>
    /// Sets the media type of the image content.
    /// </summary>
    /// <param name="Value">
    /// The MIME type of the image, such as "image/png" or "image/jpeg".
    /// </param>
    /// <returns>
    /// The updated <c>TContentImageSource</c> instance.
    /// </returns>
    /// <remarks>
    /// The media type defines the format of the image, enabling proper handling during processing.
    /// </remarks>
    function MediaType(const Value: string): TContentImageSource;
    /// <summary>
    /// Sets the image data.
    /// </summary>
    /// <param name="Value">
    /// The Base64-encoded string representing the image data.
    /// </param>
    /// <returns>
    /// The updated <c>TContentImageSource</c> instance.
    /// </returns>
    /// <remarks>
    /// The data property holds the image content in a format suitable for embedding in
    /// JSON-based payloads. Ensure that the input is Base64-encoded if required by the context.
    /// </remarks>
    function Data(const Value: string): TContentImageSource;
    /// <summary>
    /// Creates a new instance of <c>TContentImageSource</c> with the specified image value.
    /// </summary>
    /// <param name="Value">
    /// The string representing the image data or file.
    /// </param>
    /// <param name="Kind">
    /// Enum: 'image' or 'base64'
    /// </param>
    /// <returns>
    /// A new instance of <c>TContentImageSource</c> with its fields initialized.
    /// </returns>
    /// <remarks>
    /// This method validates the MIME type and initializes the instance with the appropriate type,
    /// media type, and data. The input can be a file path or a Base64-encoded string.
    /// </remarks>
    class function New(const Value: string): TContentImageSource;
  end;

  /// <summary>
  /// Represents the content of a chat message.
  /// </summary>
  /// <remarks>
  /// This class is used to construct the content of a chat message, which can include
  /// text or image elements. It allows defining the type of content, the actual text or image
  /// data, and optional caching control for optimized performance.
  /// </remarks>
  TChatMessageContent = class(TJSONParam)
  public
    /// <summary>
    /// Sets the type of the content.
    /// </summary>
    /// <param name="Value">
    /// The type of the content, such as "text", "image" or document.
    /// </param>
    /// <returns>
    /// The updated <c>TChatMessageContent</c> instance.
    /// </returns>
    /// <remarks>
    /// The content type determines how the content will be processed and displayed.
    /// Supported values include "text" for textual content and "image" for image data.
    /// </remarks>
    function &Type(const Value: string): TChatMessageContent;
    /// <summary>
    /// Sets the text content of the message.
    /// </summary>
    /// <param name="Value">
    /// The text to be included in the chat message.
    /// </param>
    /// <returns>
    /// The updated <c>TChatMessageContent</c> instance.
    /// </returns>
    /// <remarks>
    /// This method is used to define the main textual content of the message.
    /// </remarks>
    function Text(const Value: string): TChatMessageContent;
    /// <summary>
    /// Sets the source of the image content.
    /// </summary>
    /// <param name="Value">
    /// The Base64-encoded string or file path of the image.
    /// </param>
    /// <param name="Kind">
    /// Enum: 'image' or 'base64'
    /// </param>
    /// <param name="Caching">
    /// Optional caching type to control the use of cached image data.
    /// </param>
    /// <returns>
    /// The updated <c>TChatMessageContent</c> instance.
    /// </returns>
    /// <remarks>
    /// This method is used to add an image to the message content. The optional caching
    /// parameter allows specifying how the image data should be handled.
    /// </remarks>
    function Source(const Value: string; const Caching: TCachingType = nocaching): TChatMessageContent;
    /// <summary>
    /// Sets the caching control for the content.
    /// </summary>
    /// <param name="Value">
    /// The caching type to be applied, such as "nocaching" or "ephemeral".
    /// </param>
    /// <returns>
    /// The updated <c>TChatMessageContent</c> instance.
    /// </returns>
    /// <remarks>
    /// Caching control is used to optimize content retrieval and reduce latency by defining
    /// how the content is cached on the server.
    /// </remarks>
    function CacheControl(const Value: TCachingType): TChatMessageContent;
    /// <summary>
    /// Creates a new text content instance with optional caching.
    /// </summary>
    /// <param name="Value">
    /// The text to be included in the message.
    /// </param>
    /// <param name="Caching">
    /// Optional caching type to control the use of cached text data.
    /// </param>
    /// <returns>
    /// A new instance of <c>TChatMessageContent</c> configured as text content.
    /// </returns>
    /// <remarks>
    /// This method simplifies the creation of text content with caching options.
    /// </remarks>
    class function AddText(const Value: string; const Caching: TCachingType = nocaching): TChatMessageContent;
    /// <summary>
    /// Creates a new image content instance with optional caching.
    /// </summary>
    /// <param name="Value">
    /// The Base64-encoded string or file path of the image.
    /// </param>
    /// <param name="Caching">
    /// Optional caching type to control the use of cached image data.
    /// </param>
    /// <returns>
    /// A new instance of <c>TChatMessageContent</c> configured as image content.
    /// </returns>
    /// <remarks>
    /// This method simplifies the creation of image content with caching options.
    /// </remarks>
    class function AddImage(const Value: string; const Caching: TCachingType = nocaching): TChatMessageContent;
    /// <summary>
    /// Creates a new PDF content instance with optional caching.
    /// </summary>
    /// <param name="Value">
    /// The Base64-encoded string or file path of the PDF.
    /// </param>
    /// <param name="Caching">
    /// Optional caching type to control the use of cached PDF data.
    /// </param>
    /// <returns>
    /// A new instance of <c>TChatMessageContent</c> configured as PDF content.
    /// </returns>
    /// <remarks>
    /// This method simplifies the creation of PDF content with caching options.
    /// </remarks>
    class function AddPDF(const Value: string; const Caching: TCachingType = nocaching): TChatMessageContent;
  end;

  /// <summary>
  /// Represents the payload for a chat message in a conversational context.
  /// </summary>
  /// <remarks>
  /// The <c>TChatMessagePayload</c> class provides the structure for defining and managing chat messages.
  /// It allows specifying the role of the sender (e.g., user, assistant) and the content of the message.
  /// The class supports multiple formats for message content, including text, images, and documents, and provides
  /// convenient methods for creating instances with predefined roles and content types.
  /// </remarks>
  TChatMessagePayload = class(TJSONParam)
  public
    /// <summary>
    /// Gets or sets the role of the message.
    /// </summary>
    /// <remarks>
    /// The <c>Role</c> property determines who is sending the message. It can be a "user" (representing the end user), an "assistant" (representing an AI or bot).
    /// This property is essential for contextualizing the content of the message within the chat.
    /// </remarks>
    function Role(const Value: TMessageRole): TChatMessagePayload;
    /// <summary>
    /// Gets or sets the content of the message.
    /// </summary>
    /// <remarks>
    /// The <c>Content</c> property contains the actual message text. This is a required field and cannot be empty, as it represents the core information being exchanged
    /// in the chat, whether it's from the user, the assistant.
    /// </remarks>
    function Content(const Value: string): TChatMessagePayload; overload;
    /// <summary>
    /// Gets or sets the content of the message.
    /// </summary>
    /// <remarks>
    /// The <c>Content</c> property contains the actual message text. This is a required field and cannot be empty, as it represents the core information being exchanged
    /// in the chat, whether it's from the user, the assistant.
    /// </remarks>
    function Content(const Value: TJSONArray): TChatMessagePayload; overload;
    /// <summary>
    /// Gets or sets the content of the message.
    /// </summary>
    /// <remarks>
    /// The <c>Content</c> property contains the actual message text. This is a required field and cannot be empty, as it represents the core information being exchanged
    /// in the chat, whether it's from the user, the assistant.
    /// </remarks>
    function Content(const Value: TChatMessageContent): TChatMessagePayload; overload;
    /// <summary>
    /// Creates a new chat message payload with the role of the assistant.
    /// </summary>
    /// <param name="Content">
    /// The content of the message that the assistant is sending.
    /// </param>
    /// <returns>
    /// A <c>TChatMessagePayload</c> instance with the role set to "assistant" and the provided content.
    /// </returns>
    /// <remarks>
    /// This method is a convenience for creating assistant messages. Use this method when the assistant needs to respond to the user or system.
    /// </remarks>
    class function Assistant(const Value: string): TChatMessagePayload;
    /// <summary>
    /// Creates a new chat message payload with the role of the user.
    /// </summary>
    /// <param name="Content">
    /// The content of the message that the user is sending.
    /// </param>
    /// <param name="CacheControl">
    /// Enable/disable the prompt Catching
    /// </param>
    /// <returns>
    /// A <c>TChatMessagePayload</c> instance with the role set to "user" and the provided content.
    /// </returns>
    /// <remarks>
    /// This method is used to create messages from the user's perspective, typically representing inputs or queries in the conversation.
    /// </remarks>
    class function User(const Value: string; CacheControl: Boolean = False): TChatMessagePayload; overload;
    /// <summary>
    /// Creates a new chat message payload with the role of the user and includes associated vision sources.
    /// </summary>
    /// <param name="Content">
    /// The content of the message that the user is sending.
    /// </param>
    /// <param name="Images">
    /// An array of strings representing image file sources.
    /// </param>
    /// <returns>
    /// A <c>TChatMessagePayload</c> instance with the role set to "user", the provided content, and the specified vision sources.
    /// </returns>
    /// <remarks>
    /// This method is used to create messages from the user's perspective that include both text content and optional vision sources.
    /// The vision sources can be only Base64-encoded images, and they are used to enhance the message with visual information.
    /// </remarks>
    class function User(const Value: string; const Images: TArray<string>;
      CacheControl: Boolean = False): TChatMessagePayload; overload;
    /// <summary>
    /// Creates a new chat message payload with the role of the user, including PDF documents.
    /// </summary>
    /// <param name="Value">
    /// The text content of the message being sent by the user.
    /// </param>
    /// <param name="Documents">
    /// An array of strings representing the PDF documents to be included in the message.
    /// Each entry in the array is expected to be a Base64-encoded representation of a PDF file.
    /// </param>
    /// <param name="CacheControl">
    /// A boolean flag indicating whether to enable cache control for the provided content.
    /// If set to <c>True</c>, the PDF documents and the message text will be cached.
    /// The default value is <c>False</c>, meaning no caching is applied.
    /// </param>
    /// <returns>
    /// A <c>TChatMessagePayload</c> instance containing the user role, the provided text content,
    /// and the associated PDF documents in the message payload.
    /// </returns>
    /// <remarks>
    /// This method is particularly useful for scenarios where a user needs to include PDF documents as part of their chat interaction.
    /// The PDFs are embedded in the message payload and can be accompanied by a textual message for additional context.
    /// Example:
    /// <code>
    /// var Payload := TChatMessagePayload.Pdf('Here are the requested documents:', [Base64PDF1, Base64PDF2]);
    /// </code>
    /// This generates a chat message with the specified text and two attached PDF documents.
    /// </remarks>
    class function Pdf(const Value: string; const Documents: TArray<string>;
      CacheControl: Boolean = False): TChatMessagePayload;
  end;

  /// <summary>
  /// Represents the payload for a chat message in a conversational context.
  /// </summary>
  /// <remarks>
  /// The <c>Payload</c> class provides the structure for defining and managing chat messages.
  /// It allows specifying the role of the sender (e.g., user, assistant) and the content of the message.
  /// The class supports multiple formats for message content, including text, images, and documents, and provides
  /// convenient methods for creating instances with predefined roles and content types.
  /// </remarks>
  Payload = TChatMessagePayload;

  /// <summary>
  /// The <c>TSystemPayload</c> record represents the system message payload
  /// This type is used to indicate behavior rules, response format patterns, or general information about the current context.
  /// </summary>
  /// <remarks>
  /// <para>
  /// - The <c>TSystemPayload</c> record is essential for managing conversations in a chat application, allowing to customize the response that will be built by the LLM.
  /// </para>
  /// <para>
  /// - This record provides several helper methods to create messages with predefined roles for easier management of system prompts.
  /// </para>
  /// <para>
  /// - It notably manages server-side caching.
  /// </para>
  /// <para>
  /// - In a system prompt there can be only two <c>TSystemPayload</c> records at most. The second <c>TSystemPayload</c> will be automatically marked to use caching.
  /// </para>
  /// </remarks>
  TSystemPayload = class(TJSONParam)
  public
    /// <summary>
    /// Allways "text" in this context
    /// </summary>
    function &Type(const Value: string): TSystemPayload;
    /// <summary>
    /// Content of the system prompt
    /// </summary>
    function Text(const Value: string): TSystemPayload;
    /// <summary>
    /// Enable/disable the cache contol flag.
    /// </summary>
    function CacheControl(const Value: TCachingType): TSystemPayload;
    /// <summary>
    /// Creates a new system payload containing a textual message with optional caching behavior.
    /// </summary>
    /// <param name="Value">
    /// The text content to include in the system payload. This text typically serves as instructions, rules, or contextual information for the AI model.
    /// </param>
    /// <param name="Caching">
    /// Specifies the caching behavior for the system payload. Options include:
    /// <para>
    /// <c>nocaching</c> (default): Disables caching for this payload.
    /// </para>
    /// <para>
    /// <c>ephemeral</c>: Enables server-side caching to optimize performance for repeated requests.
    /// </para>
    /// </param>
    /// <returns>
    /// A <c>TSystemPayload</c> instance initialized with the provided text and caching behavior.
    /// </returns>
    /// <remarks>
    /// This method simplifies the creation of system payloads by allowing the inclusion of textual instructions or guidelines along with optional caching settings.
    /// Use the <c>ephemeral</c> caching option to reduce latency when the same system payload is used multiple times.
    /// </remarks>
    class function AddText(const Value: string; const Caching: TCachingType = nocaching): TSystemPayload;
  end;

  /// <summary>
  /// The <c>TChatParams</c> class represents the set of parameters used to configure a chat interaction with an AI model.
  /// </summary>
  /// <remarks>
  /// This class allows you to define various settings that control how the model behaves, including which model to use, how many tokens to generate,
  /// what kind of messages to send, and how the model should handle its output. By using this class, you can fine-tune the AI's behavior and response format
  /// based on your application's specific needs.
  /// <para>
  /// It inherits from <c>TJSONParam</c>, which provides methods for handling and serializing the parameters as JSON, allowing seamless integration
  /// with JSON-based APIs.
  /// </para>
  /// <code>
  /// var
  ///   Params: TChatParams;
  /// begin
  ///   Params := TChatParams.Create
  ///     .Model('my_model')
  ///     .MaxTokens(100)
  ///     .Messages([TChatMessagePayload1.User('Hello!')])
  ///     .Temperature(0.7)
  ///     .TopP(1)
  /// end;
  /// </code>
  /// This example shows how to instantiate and configure a <c>TChatParams</c> object for interacting with an AI model.
  /// </remarks>
  TChatParams = class(TJSONParam)
    /// <summary>
    /// Specifies the identifier of the model to use.
    /// Currently compatible with "claude-3-haiku-20240307" , "claude-3-5-sonnet-20240620"...
    /// </summary>
    /// <param name="Value">
    /// The model ID to be used for the completion.
    /// Ensure that the specified model is supported and correctly spelled.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// This parameter is required and determines which model will process the request.
    /// </remarks>
    function Model(const Value: string): TChatParams;
    /// <summary>
    /// Sets the maximum number of tokens to generate in the completion.
    /// The total token count of your prompt plus <c>max_tokens</c> cannot exceed the model's context length.
    /// </summary>
    /// <param name="Value">
    /// The maximum number of tokens to generate.
    /// Choose an appropriate value based on your prompt length to avoid exceeding the model's limit.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function MaxTokens(const Value: Integer): TChatParams;
    /// <summary>
    /// Provides the prompt(s) for the model to generate completions from, structured as a list of messages with roles (user, assistant, system) and content.
    /// </summary>
    /// <param name="Value">An array of <c>TChatMessagePayload1</c> representing the messages in the conversation.</param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// The first message should have a "user" role to initiate the conversation properly.
    /// </remarks>
    function Messages(const Value: TArray<TChatMessagePayload>): TChatParams; overload;
    /// <summary>
    /// An object describing metadata about the request.
    /// </summary>
    /// <param name="Value">
    /// An external identifier for the user who is associated with the request.
    /// This should be a uuid, hash value, or other opaque identifier. Anthropic may use this id to help detect abuse.
    /// Do not include any identifying information such as name, email address, or phone number.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function Metadata(const Value: string): TChatParams;
    /// <summary>
    /// Custom text sequences that will cause the model to stop generating.
    /// </summary>
    /// <param name="paramname">
    /// List of text sequences
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// The models will normally stop when they have naturally completed their turn, which will result in a response stop_reason of "end_turn".
    /// <para>
    /// If you want the model to stop generating when it encounters custom strings of text, you can use the stop_sequences parameter. If the model encounters one of the custom sequences, the response stop_reason value will be "stop_sequence" and the response stop_sequence value will contain the matched stop sequence.
    /// </para>
    /// </remarks>
    function StopSequences(const Value: TArray<string>): TChatParams;
    /// <summary>
    /// Specifies whether to stream back partial progress as server-sent events (SSE).
    /// If <c>true</c>, tokens are sent as they become available.
    /// If <c>false</c>, the server will hold the request open until timeout or completion.
    /// </summary>
    /// <param name="Value">
    /// A boolean value indicating whether to enable streaming. Default is <c>true</c>, meaning streaming is enabled by default.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    function Stream(const Value: Boolean = True): TChatParams;
    /// <summary>
    /// Set the system prompt.
    /// </summary>
    /// <param name="Value">
    /// Gives context and instructions as text.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// A system prompt is a way of providing context and instructions to Claude, such as specifying a particular goal or role. See the guide to system prompts.
    /// </remarks>
    function System(const Value: string): TChatParams; overload;
    /// <summary>
    /// Set the system prompt.
    /// </summary>
    /// <param name="Value">
    /// Array of string: maximum 2 items
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// The array of <c>TSystemPayload</c> can exceded two items. And teh second item will be automatically marked to use caching serveur-side.
    /// <para>
    /// - A system prompt is a way of providing context and instructions to Claude, such as specifying a particular goal or role. See the guide to system prompts.
    /// </para>
    /// </remarks>
    function System(const Value: TArray<string>): TChatParams; overload;
    /// <summary>
    /// Set the system prompt.
    /// </summary>
    /// <param name="Value">
    /// the system prompt first value
    /// </param>
    /// <param name="TextFilePath">
    /// The name of a text file for caching.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// The array of <c>TSystemPayload</c> can exceded two items. And teh second item will be automatically marked to use caching serveur-side.
    /// <para>
    /// - A system prompt is a way of providing context and instructions to Claude, such as specifying a particular goal or role. See the guide to system prompts.
    /// </para>
    /// </remarks>
    function System(const Value: string; TextFilePath: string): TChatParams; overload;
    /// <summary>
    /// Amount of randomness injected into the response.
    /// Sets the sampling temperature to use for the model's output.
    /// Higher values like 0.8 make the output more random, while lower values like 0.2 make it more focused and deterministic.
    /// </summary>
    /// <param name="Value">
    /// The temperature value between 0.0 and 1.0. Default is 1.0.
    /// A temperature of 0 makes the model deterministic, while a temperature of 1 allows for maximum creativity.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// Defaults to 1.0. Ranges from 0.0 to 1.0. Use temperature closer to 0.0 for analytical / multiple choice, and closer to 1.0 for creative and generative tasks.
    /// <para>
    /// Note that even with temperature of 0.0, the results will not be fully deterministic.
    /// </para>
    /// </remarks>
    function Temperature(const Value: Single = 1.0): TChatParams;
    /// <summary>
    /// Only sample from the top K options for each subsequent token.
    /// Top k sampling means sorting by probability and zero-ing out the probabilities for anything below the k’th token.
    /// </summary>
    /// <param name="Value">
    /// TProbability between 0 and 1
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// Used to remove "long tail" low probability responses.
    /// <para>
    /// Recommended for advanced use cases only. You usually only need to use temperature.
    /// It appears to improve quality by removing the tail and making it less likely to go off topic.
    /// </para>
    /// </remarks>
    function TopK(const Value: Single): TChatParams;
    /// <summary>
    /// Sets the nucleus sampling probability mass for the model (Top-p).
    /// For example, 0.1 means only the tokens comprising the top 10% probability mass are considered.
    /// </summary>
    /// <param name="Value">
    /// The <c>top_p</c> value between 0.0 and 1.0. Default is 1.
    /// Lower values limit the model to consider only the most probable options.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// In nucleus sampling, it compute the cumulative distribution over all the options for each subsequent token in decreasing probability order and cut it off once it reaches a particular probability specified by top_p. You should either alter temperature or top_p, but not both.
    /// <para>
    /// Recommended for advanced use cases only. You usually only need to use temperature.
    /// </para>
    /// </remarks>
    function TopP(const Value: Single): TChatParams;
    /// <summary>
    /// How the model should use the provided tools. The model can use a specific tool, any available tool, or decide by itself.
    /// </summary>
    /// <param name="Value">
    /// Expects a value from "auto" or "any" enum
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// tool_choice.disable_parallel_tool_use boolean
    /// Whether to disable parallel tool use.
    /// Defaults to false. If set to true, the model will output at most one tool use.
    /// </remarks>
    function ToolChoice(const Value: TToolChoiceType): TChatParams; overload;
    /// <summary>
    /// The model should use the provided tools.
    /// Toolchoice is tool in this case.
    /// </summary>
    /// <param name="Name">
    /// Name of the tool
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// tool_choice.disable_parallel_tool_use boolean
    /// Whether to disable parallel tool use.
    /// Defaults to false. If set to true, the model will output at most one tool use.
    /// </remarks>
    function ToolChoice(const Name: string): TChatParams; overload;
    /// <summary>
    /// Definitions of tools that the model may use.
    /// </summary>
    /// <param name="Value">
    /// The list of object interface with the JSON input schemas.
    /// </param>
    /// <returns>
    /// The updated <c>TChatParams</c> instance.
    /// </returns>
    /// <remarks>
    /// If you include tools in your API request, the model may return tool_use content blocks that represent the model's use of those tools. You can then run those tools using the tool input generated by the model and then optionally return results back to the model using tool_result content blocks.
    /// Example: JSON input schema
    /// <code>
    /// [
    ///  {
    ///   "name": "get_stock_price",
    ///   "description": "Get the current stock price for a given ticker symbol.",
    ///   "input_schema": {
    ///     "type": "object",
    ///     "properties": {
    ///       "ticker": {
    ///          "type": "string",
    ///          "description": "The stock ticker symbol, e.g. AAPL for Apple Inc."
    ///        }
    ///     },
    ///     "required": ["ticker"]
    ///   }
    ///   }
    ///]
    /// </code>
    /// </remarks>
    function Tools(const Value: TArray<IFunctionCore>): TChatParams;
    /// <summary>
    /// Constructor to initialize the <c>TChatParams</c> object with default values.
    /// </summary>
    /// <remarks>
    /// The default model is <c>claude-3-haiku-20240307</c>
    /// </remarks>
    constructor Create; override;
  end;

  /// <summary>
  /// Represents the token usage statistics for a chat interaction, including the number of tokens
  /// used in the prompt, the completion, and the total number of tokens consumed.
  /// </summary>
  /// <remarks>
  /// The <c>TChatUsage</c> class provides insight into the number of tokens used during a chat interaction.
  /// This information is critical for understanding the cost of a request when using token-based billing systems
  /// or for monitoring the model's behavior in terms of input (prompt) and output (completion) size.
  /// </remarks>
  TChatUsage = class
  private
    [JsonNameAttribute('input_tokens')]
    FInputTokens: Int64;
    [JsonNameAttribute('cache_creation_input_tokens')]
    FCacheCreationInputTokens: Int64;
    [JsonNameAttribute('cache_read_input_tokens')]
    FCacheReadInputTokens: Int64;
    [JsonNameAttribute('output_tokens')]
    FOutputTokens: Int64;
  public
    /// <summary>
    /// The number of input tokens which were used.
    /// </summary>
    property InputTokens: Int64 read FInputTokens write FInputTokens;
    /// <summary>
    /// (prompt caching beta) The number of input tokens used to create the cache entry.
    /// </summary>
    property CacheCreationInputTokens: Int64 read FCacheCreationInputTokens write FCacheCreationInputTokens;
    /// <summary>
    /// (prompt caching beta) The number of input tokens read from the cache.
    /// </summary>
    property CacheReadInputTokens: Int64 read FCacheReadInputTokens write FCacheReadInputTokens;
    /// <summary>
    /// The number of output tokens which were used.
    /// </summary>
    property OutputTokens: Int64 read FOutputTokens write FOutputTokens;
  end;

  /// <summary>
  /// Interceptor class for converting <c>input</c> value into JSON string format in JSON deserialization.
  /// </summary>
  /// <remarks>
  /// This class is used to facilitate the conversion between the <c>input</c> and its string equivalent during JSON processing.
  /// It extends the <c>TJSONInterceptorStringToString</c> class to override the necessary methods for custom conversion logic.
  /// </remarks>
  TInputFixInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// When JSON deserialization, converts <c>input</c> value into JSON string to retrieve arguments made by the tool.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be set.
    /// </param>
    /// <param name="Field">
    /// The field name where the <c>input</c> value will be set.
    /// </param>
    /// <param name="Arg">
    /// The string representation of the <c>input</c> to be converted back.
    /// </param>
    /// <remarks>
    /// This method converts the string argument back to the corresponding <c>input</c> value and assigns it to the specified field in the object.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Interceptor class for converting <c>Text</c> values to formatting for display in JSON deserialization.
  /// </summary>
  /// <remarks>
  /// This class is used to facilitate the conversion between the <c>Text</c> and its string equivalent during JSON processing.
  /// It extends the <c>TJSONInterceptorStringToString</c> class to override the necessary methods for custom conversion logic.
  /// </remarks>
  TContentInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// When JSON deserialization, converts a string back to a <c>Text</c> value to formatting for displaymanaging the returns carriet.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be set.
    /// </param>
    /// <param name="Field">
    /// The field name where the <c>Text</c> value will be set.
    /// </param>
    /// <param name="Arg">
    /// The string representation of the <c>Text</c> to be converted back.
    /// </param>
    /// <remarks>
    /// This method converts the string argument back to the corresponding <c>Text</c> value and assigns it to the specified field in the object.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// The response content made by a tool.
  /// </summary>
  TToolUse = class
  private
    FType: string;
    FId: string;
    FName: string;
    [JsonReflectAttribute(ctString, rtString, TInputFixInterceptor)]
    FInput: string;
  public
    /// <summary>
    /// Available options: tool_use
    /// </summary>
    property &Type: string read FType write FType;
    /// <summary>
    /// Id provided by the LLM
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Name of the tool identified by the LLM
    /// </summary>
    property Name: string read FName write FName;
    /// <summary>
    /// Arguments returned by the LLM, these arguments will have to be used to construct the final answer.
    /// </summary>
    property Input: string read FInput write FInput;
  end;

  /// <summary>
  /// The response content made by the LLM.
  /// </summary>
  /// <remarks>
  /// This class inherits from the <c>TToolUse</c> class because if a tool has been called, then the arguments obtained must be provided, otherwise it gives access to the textual content of a simple response.
  /// </remarks>
  TChatContent = class(TToolUse)
  private
    [JsonReflectAttribute(ctString, rtString, TContentInterceptor)]
    FText: string;
  public
    /// <summary>
    /// Available options: text
    /// </summary>
    property &Type;
    /// <summary>
    /// The textual content of a response.
    /// </summary>
    /// <remarks>
    /// The string is correctly formatted with carriage returns and can be directly displayed without prior processing of its formatting.
    /// </remarks>
    property Text: string read FText write FText;
  end;

  /// <summary>
  /// Represents a data structure used for managing streaming chunks in a conversational system.
  /// </summary>
  /// <remarks>
  /// This class is primarily designed to handle the incremental data (chunks) returned by an LLM (Large Language Model) during streaming responses.
  /// It stores the type of chunk, textual content, and relevant metadata such as an identifier and tool name if applicable.
  /// The 'Input' property can contain partial JSON data, which should be parsed to construct the final response.
  /// </remarks>
  TChatDelta = class
  private
    FType: string;
    FText: string;
    FId: string;
    FName: string;
    [JsonNameAttribute('partial_json')]
    FInput: string;
  public
    /// <summary>
    /// Available options: tool_use
    /// </summary>
    property &Type: string read FType write FType;
    /// <summary>
    /// The textual content of a response.
    /// </summary>
    /// <remarks>
    /// The string is correctly formatted with carriage returns and can be directly displayed without prior processing of its formatting.
    /// </remarks>
    property Text: string read FText write FText;
    /// <summary>
    /// Id provided by the LLM
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Name of the tool identified by the LLM
    /// </summary>
    property Name: string read FName write FName;
    /// <summary>
    /// Arguments returned by the LLM, these arguments will have to be used to construct the final answer.
    /// </summary>
    property Input: string read FInput write FInput;
  end;

  /// <summary>
  /// Represents a chat completion response generated by an AI model, containing the necessary metadata,
  /// the generated choices, and usage statistics.
  /// </summary>
  /// <remarks>
  /// The <c>TChat</c> class encapsulates the results of a chat request made to an AI model.
  /// It contains details such as a unique identifier, the model used, when the completion was created,
  /// the choices generated by the model, and token usage statistics.
  /// This class is crucial for managing the results of AI-driven conversations and understanding the
  /// underlying usage and response characteristics of the AI.
  /// </remarks>
  TChat = class
  private
    FId: string;
    FType: string;
    FRole: string;
    FContent: TArray<TChatContent>;
    FModel: string;
    [JsonReflectAttribute(ctString, rtString, TStopReasonInterceptor)]
    [JsonNameAttribute('stop_reason')]
    FStopReason: TStopReason;
    [JsonNameAttribute('stop_sequence')]
    FStopSequence: string;
    FDelta: TChatDelta;
    FUsage: TChatUsage;
  public
    /// <summary>
    /// Unique object identifier.
    /// </summary>
    /// <remarks>
    /// The format and length of IDs may change over time.
    /// </remarks>
    property Id: string read FId write FId;
    /// <summary>
    /// Object type.
    /// </summary>
    /// <remarks>
    /// For Messages, this is always "message".
    /// Available options: message
    /// </remarks>
    property &Type: string read FType write FType;
    /// <summary>
    /// Conversational role of the generated message.
    /// </summary>
    /// <remarks>
    /// This will always be "assistant".
    /// Available options: assistant
    /// </remarks>
    property Role: string read FRole write FRole;
    /// <summary>
    /// Content generated by the model.
    /// </summary>
    /// <remarks>
    /// This is an array of content blocks, each of which has a type that determines its shape.
    /// Exemples:
    /// <code>
    /// [{"type": "text", "text": "Hi, I'm Claude."}]
    /// </code>
    /// If the request input messages ended with an assistant turn, then the response content will continue directly from that last turn. You can use this to constrain the model's output.
    /// For example, if the input messages were:
    /// <code>
    /// [
    ///   {"role": "user", "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"},
    ///   {"role": "assistant", "content": "The best answer is ("}
    /// ]
    /// </code>
    /// Then the response content might be:
    /// <code>
    /// [{"type": "text", "text": "B)"}]
    /// </code>
    /// </remarks>
    property Content: TArray<TChatContent> read FContent write FContent;
    /// <summary>
    /// The model that handled the request.
    /// </summary>
    property Model: string read FModel write FModel;
    /// <summary>
    /// The reason that we stopped.
    /// </summary>
    /// <remarks>
    /// This may be one the following values:
    /// <para>
    ///  - "end_turn": the model reached a natural stopping point
    /// </para>
    /// <para>
    ///  - "max_tokens": we exceeded the requested max_tokens or the model's maximum
    /// </para>
    /// <para>
    ///  - "stop_sequence": one of your provided custom stop_sequences was generated
    /// </para>
    /// <para>
    ///  - "tool_use": the model invoked one or more tools
    /// </para>
    /// In non-streaming mode this value is always non-null. In streaming mode, it is null in the message_start event and non-null otherwise.
    /// Available options: end_turn, max_tokens, stop_sequence, tool_use
    /// </remarks>
    property StopReason: TStopReason read FStopReason write FStopReason;
    /// <summary>
    /// Which custom stop sequence was generated, if any.
    /// </summary>
    /// <remarks>
    /// This value will be a non-null string if one of your custom stop sequences was generated.
    /// </remarks>
    property StopSequence: string read FStopSequence write FStopSequence;
    /// <summary>
    /// Billing and rate-limit usage.
    /// </summary>
    /// <remarks>
    /// Anthropic's API bills and rate-limits by token counts, as tokens represent the underlying cost to our systems.
    /// <para>
    ///  - Under the hood, the API transforms requests into a format suitable for the model. The model's output then goes through a parsing stage before becoming an API response. As a result, the token counts in usage will not match one-to-one with the exact visible content of an API request or response.
    /// </para>
    /// <para>
    ///  - For example, output_tokens will be non-zero, even for an empty string response from Claude.
    /// </para>
    /// </remarks>
    property Usage: TChatUsage read FUsage write FUsage;
    /// <summary>
    /// Represents the incremental updates (delta) for streaming responses during a conversation.
    /// </summary>
    /// <remarks>
    /// In the context of streaming, this property holds the partial data returned by the model in real-time.
    /// It allows the system to manage ongoing or incomplete responses by updating the chat content progressively as the model generates it.
    /// This is especially useful for handling large responses that are broken into chunks.
    /// </remarks>
    property Delta: TChatDelta read FDelta write FDelta;
    /// <summary>
    /// Destructor to clean up resources used by this <c>TChat</c> instance.
    /// </summary>
    /// <remarks>
    /// The destructor ensures that any allocated resources, such as the memory for the array of choices or usage statistics, are
    /// properly released when the object is no longer needed.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Count the number of tokens in a Message.
  /// The Token Count API can be used to count the number of tokens in a Message, including tools,
  /// images, and documents, without creating it.
  /// </summary>
  TTokenCount = class
  private
    [JsonNameAttribute('input_tokens')]
    FInputTokens: Int64;
  public
    /// <summary>
    /// The total number of tokens across the provided list of messages, system prompt, and tools.
    /// </summary>
    property InputTokens: Int64 read FInputTokens write FInputTokens;
  end;

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TTokenCount</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynTokenCount</c> type extends the <c>TAsynParams&lt;TTokenCount&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynTokenCount = TAsynCallBack<TTokenCount>;

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TChat</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynChat</c> type extends the <c>TAsynParams&lt;TChat&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynChat = TAsynCallBack<TChat>;

  /// <summary>
  /// Manages asynchronous streaming chat callBacks for a chat request using <c>TChat</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynChatStream</c> type extends the <c>TAsynStreamParams&lt;TChat&gt;</c> record to support the lifecycle of an asynchronous streaming chat operation.
  /// It provides callbacks for different stages, including when the operation starts, progresses with new data chunks, completes successfully, or encounters an error.
  /// This structure is ideal for handling scenarios where the chat response is streamed incrementally, providing real-time updates to the user interface.
  /// </remarks>
  TAsynChatStream = TAsynStreamCallBack<TChat>;

  /// <summary>
  /// Represents a callback procedure used during the reception of responses from a chat request in streaming mode.
  /// </summary>
  /// <param name="Chat">
  /// The <c>TChat</c> object containing the current information about the response generated by the model.
  /// If this value is <c>nil</c>, it indicates that the data stream is complete.
  /// </param>
  /// <param name="IsDone">
  /// A boolean flag indicating whether the streaming process is complete.
  /// If <c>True</c>, it means the model has finished sending all response data.
  /// </param>
  /// <param name="Cancel">
  /// A boolean flag that can be set to <c>True</c> within the callback to cancel the streaming process.
  /// If set to <c>True</c>, the streaming will be terminated immediately.
  /// </param>
  /// <remarks>
  /// This callback is invoked multiple times during the reception of the response data from the model.
  /// It allows for real-time processing of received messages and interaction with the user interface or other systems
  /// based on the state of the data stream.
  /// When the <c>IsDone</c> parameter is <c>True</c>, it indicates that the model has finished responding,
  /// and the <c>Chat</c> parameter will be <c>nil</c>.
  /// </remarks>
  TChatEvent = reference to procedure(var Chat: TChat; IsDone: Boolean; var Cancel: Boolean);

  /// <summary>
  /// The <c>TChatRoute</c> class inherits from <c>TAnthropicAPIRoute</c> and provides an interface for managing various interactions with the chat API.
  /// It supports creating chat completion requests in synchronous, asynchronous, and streaming modes, offering mechanisms to handle responses generated by the model.
  /// </summary>
  /// <remarks>
  /// This class facilitates sending messages to a chat model, receiving responses, and managing them, whether synchronously or asynchronously.
  /// The primary methods in the class are:
  /// <para>
  /// - <c>Create</c> : Sends a chat request and waits for a full response.
  /// </para>
  /// <para>
  /// - <c>AsynCreate</c> : Performs an asynchronous chat completion request with event handling.
  /// </para>
  /// <para>
  /// - <c>CreateStream</c> : Initiates a chat completion request in streaming mode, receiving tokens progressively.
  /// </para>
  /// <para>
  /// - <c>ASynCreateStream</c> : Performs an asynchronous request in streaming mode with event handling.
  /// </para>
  /// Each method allows configuring model parameters, setting input messages, managing token limits, and including callbacks for processing responses or errors.
  /// </remarks>
  TChatRoute = class(TAnthropicAPIRoute)
  public
    /// <summary>
    /// Create an asynchronous completion for chat message
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the parameters for the chat request, such as model selection, messages, and other parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for the asynchronous chat completion, such as on success and on error.
    /// </param>
    /// <remarks>
    /// This procedure initiates an asynchronous request to generate a chat completion based on the provided parameters. The response or error is handled by the provided callBacks.
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var Anthropic := TAnthropicFactory.CreateInstance(BaererKey);
    /// Anthropic.Chat.AsynCreate(
    ///   procedure (Params: TChatParams)
    ///   begin
    ///     // Define chat parameters
    ///   end,
    ///   function: TAsynChat
    ///   begin
    ///     Result.Sender := my_display_component;
    ///
    ///     Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Value: TChat)
    ///     begin
    ///       // Handle success operation
    ///     end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Value: string)
    ///     begin
    ///       // Handle error message
    ///     end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsynCreate(ParamProc: TProc<TChatParams>; CallBacks: TFunc<TAsynChat>);
    /// <summary>
    /// Creates an asynchronous streaming chat completion request.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the chat request, including the model, messages, and additional options such as max tokens and streaming mode.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a <c>TAsynChatStream</c> record which contains event handlers for managing different stages of the streaming process: progress updates, success, errors, and cancellation.
    /// </param>
    /// <remarks>
    /// This procedure initiates an asynchronous chat operation in streaming mode, where tokens are progressively received and processed.
    /// The provided event handlers allow for handling progress (i.e., receiving tokens in real time), detecting success, managing errors, and enabling cancellation logic.
    /// <code>
    /// CheckBox1.Checked := False;  //Click to stop the streaming
    /// // WARNING - Move the following line into the main OnCreate
    /// //var Anthropic := TAnthropicFactory.CreateInstance(BaererKey);
    /// Anthropic.Chat.AsynCreateStream(
    ///   procedure(Params: TChatParams)
    ///   begin
    ///     // Define chat parameters
    ///     Params.Stream(True);
    ///   end,
    ///
    ///   function: TAsynChatStream
    ///   begin
    ///     Result.Sender := my_display_component;
    ///     Result.OnProgress :=
    ///         procedure (Sender: TObject; Chat: TChat)
    ///         begin
    ///           // Handle progressive updates to the chat response
    ///         end;
    ///     Result.OnSuccess :=
    ///         procedure (Sender: TObject; Chat: TChat)
    ///         begin
    ///           // Handle success when the operation completes
    ///         end;
    ///     Result.OnError :=
    ///         procedure (Sender: TObject; Value: string)
    ///         begin
    ///           // Handle error message
    ///         end;
    ///     Result.OnDoCancel :=
    ///         function: Boolean
    ///         begin
    ///           Result := CheckBox1.Checked; // Click on checkbox to cancel
    ///         end;
    ///     Result.OnCancellation :=
    ///         procedure (Sender: TObject)
    ///         begin
    ///           // Processing when process has been canceled
    ///         end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsynCreateStream(ParamProc: TProc<TChatParams>;
      CallBacks: TFunc<TAsynChatStream>);
    /// <summary>
    /// Count the number of tokens in a Message.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters to evaluate.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for the asynchronous chat completion, such as on success and on error.
    /// </param>
    /// <remarks>
    /// The Token Count API can be used to count the number of tokens in a Message, including tools, images, and documents, without creating it.
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var Anthropic := TAnthropicFactory.CreateInstance(BaererKey);
    /// Anthropic.Chat.AsynTokenCount(
    ///   procedure (Params: TChatParams)
    ///   begin
    ///     // Define chat parameters
    ///   end,
    ///   function: TAsynTokenCount
    ///   begin
    ///     Result.Sender := my_display_component;
    ///
    ///     Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Value: TTokenCount)
    ///     begin
    ///       // Handle success operation
    ///     end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Value: string)
    ///     begin
    ///       // Handle error message
    ///     end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsynTokenCount(ParamProc: TProc<TChatParams>; CallBacks: TFunc<TAsynTokenCount>);
    /// <summary>
    /// Creates a completion for the chat message using the provided parameters.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the chat request, such as selecting the model, providing messages, setting token limits, etc.
    /// </param>
    /// <returns>
    /// Returns a <c>TChat</c> object that contains the chat response, including the choices generated by the model.
    /// </returns>
    /// <exception cref="AnthropicExceptionAPI">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="AnthropicExceptionInvalidRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// The <c>Create</c> method sends a chat completion request and waits for the full response. The returned <c>TChat</c> object contains the model's generated response, including multiple choices if available.
    /// <code>
    ///   var Anthropic := TAnthropicFactory.CreateInstance(BaererKey);
    ///   var Value := Anthropic.Chat.Create(
    ///     procedure (Params: TChatParams)
    ///     begin
    ///       // Define chat parameters
    ///     end);
    ///   try
    ///     // Handle the value
    ///   finally
    ///     Value.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Create(ParamProc: TProc<TChatParams>): TChat;
    /// <summary>
    /// Creates a chat message completion with a streamed response.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the chat request, such as selecting the model, providing messages, and adjusting other settings like token limits or temperature.
    /// </param>
    /// <param name="Event">
    /// A callback of type <c>TChatEvent</c> that is triggered with each chunk of data received during the streaming process. It includes the current state of the <c>TChat</c> object, a flag indicating if the stream is done, and a boolean to handle cancellation.
    /// </param>
    /// <returns>
    /// Returns <c>True</c> if the streaming process started successfully, <c>False</c> otherwise.
    /// </returns>
    /// <remarks>
    /// This method initiates a chat request in streaming mode, where the response is delivered incrementally in real-time.
    /// The <c>Event</c> callback will be invoked multiple times as tokens are received.
    /// When the response is complete, the <c>IsDone</c> flag will be set to <c>True</c>, and the <c>Chat</c> object will be <c>nil</c>.
    /// The streaming process can be interrupted by setting the <c>Cancel</c> flag to <c>True</c> within the event.
    ///
    /// Example usage:
    /// <code>
    ///   var Anthropic := TAnthropicFactory.CreateInstance(BaererKey);
    ///   Anthropic.Chat.CreateStream(
    ///     procedure (Params: TChatParams)
    ///     begin
    ///       // Define chat parameters
    ///       Params.Stream(True);
    ///     end,
    ///
    ///     procedure(var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
    ///     begin
    ///       // Handle the "Chat" value
    ///     end);
    /// </code>
    /// </remarks>
    function CreateStream(ParamProc: TProc<TChatParams>; Event: TChatEvent): Boolean;
    /// <summary>
    /// Count the number of tokens in a Message.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters to evaluate.
    /// </param>
    /// <returns>
    /// Returns a <c>TTokenCount</c> object that contains the tokencount response.
    /// </returns>
    /// <exception cref="AnthropicExceptionAPI">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="AnthropicExceptionInvalidRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// The Token Count API can be used to count the number of tokens in a Message, including tools, images, and documents, without creating it.
    /// <code>
    ///   var Anthropic := TAnthropicFactory.CreateInstance(BaererKey);
    ///   var Value := Anthropic.Chat.TokenCount(
    ///     procedure (Params: TChatParams)
    ///     begin
    ///       // Define chat parameters
    ///     end);
    ///   try
    ///     // Handle the value
    ///   finally
    ///     Value.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function TokenCount(ParamProc: TProc<TChatParams>): TTokenCount;
  end;

implementation

uses
  System.StrUtils, System.Rtti, Rest.Json, Anthropic.NetEncoding.Base64,
  Anthropic.Stream.API, System.IOUtils, Anthropic.Httpx;

{ TChatParams }

constructor TChatParams.Create;
begin
  inherited;
  Model('claude-3-haiku-20240307');
end;

function TChatParams.MaxTokens(const Value: Integer): TChatParams;
begin
  Result := TChatParams(Add('max_tokens', Value));
end;

function TChatParams.Messages(
  const Value: TArray<TChatMessagePayload>): TChatParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TChatParams(Add('messages', JSONArray));
end;

{Messages}

function TChatParams.Metadata(const Value: string): TChatParams;
begin
  var JSON := TJSONObject.Create;
  JSON.AddPair('user_id', Value);
  Result := TChatParams(Add('metadata', JSON));
end;

function TChatParams.Model(const Value: string): TChatParams;
begin
  Result := TChatParams(Add('model', Value));
end;

function TChatParams.StopSequences(const Value: TArray<string>): TChatParams;
begin
  Result := TChatParams(Add('stop_sequences', Value));
end;

function TChatParams.Stream(const Value: Boolean): TChatParams;
begin
  Result := TChatParams(Add('stream', Value));
end;

function TChatParams.System(const Value: string): TChatParams;
begin
  Result := TChatParams(Add('system', Value));
end;

function TChatParams.System(
  const Value: TArray<string>): TChatParams;
begin
  if Length(Value) > 2 then
    raise Exception.Create('"TSystemPayload" with more than two items is not supported');

  if Length(Value) = 1 then
    Exit(System(Value[0]));

  var JSONArray := TJSONArray.Create
    .Add(TSystemPayload.AddText(Value[0]).Detach)
    .Add(TSystemPayload.AddText(Value[1], ephemeral).Detach);

  Result := TChatParams(Add('system', JSONArray));
end;

function TChatParams.System(const Value: string; TextFilePath: string): TChatParams;
begin
  if not FileExists(TextFilePath) or not ExtractFileExt(TextFilePath).ToLower.StartsWith('.txt') then
    raise Exception.Create('"System" parameter error: File not found or file is not of type .txt');

  var JSONArray := TJSONArray.Create
    .Add(TSystemPayload.AddText(Value).Detach)
    .Add(TSystemPayload.AddText(TFile.ReadAllText(TextFilePath, TEncoding.UTF8), ephemeral).Detach);

  Result := TChatParams(Add('system', JSONArray));
end;

function TChatParams.Temperature(const Value: Single): TChatParams;
begin
  Result := TChatParams(Add('temperature', Value));
end;

function TChatParams.ToolChoice(const Value: TToolChoiceType): TChatParams;
begin
  var JSON := TJSONObject.Create;
  JSON.AddPair('type', Value.ToString);
  Result := TChatParams(Add('tool_choice', JSON));
end;

function TChatParams.ToolChoice(const Name: string): TChatParams;
begin
  var JSON := TJSONObject.Create;
  JSON.AddPair('type', tool.ToString);
  JSON.AddPair('name', Name);
  Result := TChatParams(Add('tool_choice', JSON));
end;

function TChatParams.Tools(const Value: TArray<IFunctionCore>): TChatParams;
begin
  var Items := TJSONArray.Create;
  try
    for var Item in Value do
      begin
        Items.Add(Item.ToJson);
      end;
  except
    Items.Free;
    raise;
  end;
  Result := TChatParams(Add('tools', Items));
end;

function TChatParams.TopK(const Value: Single): TChatParams;
begin
  Result := TChatParams(Add('top_k', Value));
end;

function TChatParams.TopP(const Value: Single): TChatParams;
begin
  Result := TChatParams(Add('top_p', Value));
end;

{ TChat }

destructor TChat.Destroy;
begin
  if Assigned(FDelta) then
    FDelta.Free;
  if Assigned(FUsage) then
    FUsage.Free;
  for var Item in FContent do
    Item.Free;
  inherited;
end;

{ TChatRoute }

procedure TChatRoute.AsynCreate(ParamProc: TProc<TChatParams>;
  CallBacks: TFunc<TAsynChat>);
begin
  with TAsynCallBackExec<TAsynChat, TChat>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TChat
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TChatRoute.AsynCreateStream(ParamProc: TProc<TChatParams>;
  CallBacks: TFunc<TAsynChatStream>);
begin
  var CallBackParams := TUseParamsFactory<TAsynChatStream>.CreateInstance(CallBacks);

  var Sender := CallBackParams.Param.Sender;
  var OnStart := CallBackParams.Param.OnStart;
  var OnSuccess := CallBackParams.Param.OnSuccess;
  var OnProgress := CallBackParams.Param.OnProgress;
  var OnError := CallBackParams.Param.OnError;
  var OnCancellation := CallBackParams.Param.OnCancellation;
  var OnDoCancel := CallBackParams.Param.OnDoCancel;

  var Task: ITask := TTask.Create(
          procedure()
          begin
            {--- Pass the instance of the current class in case no value was specified. }
            if not Assigned(Sender) then
              Sender := Self;

            {--- Trigger OnStart callback }
            if Assigned(OnStart) then
              TThread.Queue(nil,
                procedure
                begin
                  OnStart(Sender);
                end);
            try
              var Stop := False;

              {--- Processing }
              CreateStream(ParamProc,
                procedure (var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
                begin
                  {--- Check that the process has not been canceled }
                  if Assigned(OnDoCancel) then
                    TThread.Queue(nil,
                        procedure
                        begin
                          Stop := OnDoCancel();
                        end);
                  if Stop then
                    begin
                      {--- Trigger when processus was stopped }
                      if Assigned(OnCancellation) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnCancellation(Sender)
                        end);
                      Cancel := True;
                      Exit;
                    end;
                  var LocalChat := Chat;
                  Chat := nil;
                  if not IsDone then
                    begin
                      {--- Triggered when processus is progressing }
                      if Assigned(OnProgress) then
                        TThread.Synchronize(TThread.Current,
                        procedure
                        begin
                          try
                            OnProgress(Sender, LocalChat);
                          finally
                            {--- Makes sure to release the instance containing the data obtained
                                 following processing}
                            LocalChat.Free;
                          end;
                        end)
                      else
                        LocalChat.Free;
                    end
                  else
                    begin
                      {--- Trigger OnEnd callback when the process is done }
                      if Assigned(OnSuccess) then
                        TThread.Synchronize(TThread.Current,
                        procedure
                        begin
                          try
                            OnSuccess(Sender, LocalChat);
                          finally
                             {--- Makes sure to release the instance containing the data obtained
                                 following processing}
                            LocalChat.Free;
                          end;
                        end)
                      else
                        LocalChat.Free;
                    end;
                end);
            except
              on E: Exception do
                begin
                  var Error := AcquireExceptionObject;
                  try
                    var ErrorMsg := (Error as Exception).Message;

                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(OnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        OnError(Sender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
          end);
  Task.Start;
end;

procedure TChatRoute.AsynTokenCount(ParamProc: TProc<TChatParams>;
  CallBacks: TFunc<TAsynTokenCount>);
begin
  with TAsynCallBackExec<TAsynTokenCount, TTokenCount>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TTokenCount
      begin
        Result := Self.TokenCount(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TChatRoute.Create(ParamProc: TProc<TChatParams>): TChat;
begin
  Result := API.Post<TChat, TChatParams>('messages', ParamProc);
end;

function TChatRoute.CreateStream(ParamProc: TProc<TChatParams>;
  Event: TChatEvent): Boolean;
var
  Response: TStringStream;
  LFPos: Integer;
  Delta: TDelta;
  Prev: string;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    LFPos := 0;
    Result := API.Post<TChatParams>('messages', ParamProc, Response,
      procedure(const Sender: TObject; AContentLength: Int64; AReadCount: Int64; var AAbort: Boolean)
      var
        IsDone: Boolean;
        Data: string;
        Chat: TChat;
        TextBuffer: string;
        Line: string;
        LF: Integer;
        BlockType: TBlockType;
      begin
        try
          TextBuffer := Response.DataString;
        except
          on E: EEncodingError do
            Exit;
        end;

        repeat
          LF := TextBuffer.IndexOf(#10, LFPos);
          if LF < 0 then
            Continue;
          Line := TextBuffer.Substring(LFPos, LF - LFPos);
          LFPos := LF + 1;

          if Line.IsEmpty or Line.StartsWith(#10) or Line.StartsWith('event') then
            Continue;

          BlockType := TDelta.BlockType(Line);
          if BlockType = btNone then
            Continue;

          IsDone := BlockType = btdone;

          Data := Line.Replace('data: ', '').Trim([' ', #13, #10]);
          Chat := nil;
          try
            if not IsDone then
              begin
                Prev := Data;
                case BlockType of
                  btBlockDelta:
                    Chat := TJson.JsonToObject<TChat>(Delta.BlockDelta(Data).ToString);
                  btMessageStart:
                    Chat := TJson.JsonToObject<TChat>(Delta.MessageStart(Data).ToString);
                  btMessageDelta:
                    Chat := TJson.JsonToObject<TChat>(Delta.MessageDelta(Data).ToString(False));
                  btBlockStart:
                    begin
                      Delta.BlockStart(Data);
                      Continue;
                    end;
                end;
              end
            else
              begin
                Chat := TJson.JsonToObject<TChat>(Delta.MessageDelta(Prev).ToString(False));
              end;
          except
            Chat := nil;
          end;

          try
            Event(Chat, IsDone, AAbort);
          finally
            Chat.Free;
          end;
        until LF < 0;

      end);
  finally
    Response.Free;
  end;
end;

function TChatRoute.TokenCount(ParamProc: TProc<TChatParams>): TTokenCount;
begin
  Result := API.Post<TTokenCount, TChatParams>('messages/count_tokens', ParamProc);
end;

{ TInputFixInterceptor }

procedure TInputFixInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  Arg := Format('{%s}', [Trim(Arg.Replace('`', '"').Replace(#10, ''))]);
  while Arg.Contains(', ') do Arg := Arg.Replace(', ', ',');
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, Arg.Replace(',', ', '));
end;

{ TContentInterceptor }

procedure TContentInterceptor.StringReverter(Data: TObject; Field, Arg: string);
begin
  with TStringList.Create do
  try
    Text := Arg;
    RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, Text);
  finally
    Free;
  end;
end;

{ TChatMessagePayload }

function TChatMessagePayload.Content(const Value: string): TChatMessagePayload;
begin
  Result := TChatMessagePayload(Add('content', Value));
end;

class function TChatMessagePayload.Assistant(
  const Value: string): TChatMessagePayload;
begin
  Result := TChatMessagePayload.Create.Role(TMessageRole.assistant).Content(Value);
end;

function TChatMessagePayload.Content(
  const Value: TChatMessageContent): TChatMessagePayload;
begin
  Result := TChatMessagePayload(Add('content', TJSONArray.Create.Add(Value.Detach)));
end;

function TChatMessagePayload.Content(
  const Value: TJSONArray): TChatMessagePayload;
begin
  Result := TChatMessagePayload(Add('content', Value));
end;

function TChatMessagePayload.Role(
  const Value: TMessageRole): TChatMessagePayload;
begin
  Result := TChatMessagePayload(Add('role', Value.ToString));
end;

class function TChatMessagePayload.Pdf(const Value: string;
  const Documents: TArray<string>; CacheControl: Boolean): TChatMessagePayload;
begin
  var JSONArray := TJSONArray.Create;
  var index := 1;
  for var Item in Documents do
    begin
      if CacheControl and (index = Length(Documents)) then
        JSONArray.Add(TChatMessageContent.AddPDF(Item, ephemeral).Detach) else
        JSONArray.Add(TChatMessageContent.AddPDF(Item).Detach);
      Inc(index);
    end;
  if CacheControl then
    JSONArray.Add(TChatMessageContent.AddText(Value, ephemeral).Detach) else
    JSONArray.Add(TChatMessageContent.AddText(Value).Detach);
  Result := TChatMessagePayload.Create.Role(TMessageRole.user).Content(JSONArray);
end;

class function TChatMessagePayload.User(const Value: string;
  const Images: TArray<string>; CacheControl: Boolean): TChatMessagePayload;
begin
  var JSONArray := TJSONArray.Create;
  var index := 1;
  for var Item in Images do
    begin
      if CacheControl and (index = Length(Images)) then
        JSONArray.Add(TChatMessageContent.AddImage(Item, ephemeral).Detach) else
        JSONArray.Add(TChatMessageContent.AddImage(Item).Detach);
      Inc(index);
    end;
  if CacheControl then
    JSONArray.Add(TChatMessageContent.AddText(Value, ephemeral).Detach) else
    JSONArray.Add(TChatMessageContent.AddText(Value).Detach);
  Result := TChatMessagePayload.Create.Role(TMessageRole.user).Content(JSONArray);
end;

class function TChatMessagePayload.User(const Value: string;
  CacheControl: Boolean): TChatMessagePayload;
begin
  case CacheControl of
    True :
      Result := TChatMessagePayload.Create.Role(TMessageRole.user).Content(TChatMessageContent.AddText(Value, ephemeral));
    else
      Result := TChatMessagePayload.Create.Role(TMessageRole.user).Content(Value);
  end;
end;

{ TChatMessageContent }

class function TChatMessageContent.AddImage(const Value: string;
  const Caching: TCachingType): TChatMessageContent;
begin
  Result := TChatMessageContent.Create.&Type('image').Source(Value);
  case Caching of
    ephemeral:
      Result := Result.CacheControl(Caching);
  end;
end;

class function TChatMessageContent.AddPDF(const Value: string;
  const Caching: TCachingType): TChatMessageContent;
begin
  Result := TChatMessageContent.Create.&Type('document').Source(Value);
  case Caching of
    ephemeral:
      Result := Result.CacheControl(Caching);
  end;
end;

class function TChatMessageContent.AddText(const Value: string;
  const Caching: TCachingType): TChatMessageContent;
begin
  Result := TChatMessageContent.Create.&Type('text').Text(Value);
  case Caching of
    ephemeral:
      Result := Result.CacheControl(Caching);
  end;
end;

function TChatMessageContent.CacheControl(const Value: TCachingType): TChatMessageContent;
begin
  Result := TChatMessageContent(Add('cache_control', TJSONObject.Create.AddPair('type', Value.ToString)));
end;

function TChatMessageContent.Source(const Value: string;
  const Caching: TCachingType): TChatMessageContent;
begin
  Result := TChatMessageContent(Add('source', TContentImageSource.New(Value).Detach));
end;

function TChatMessageContent.Text(const Value: string): TChatMessageContent;
begin
  Result := TChatMessageContent(Add('text', Value));
end;

function TChatMessageContent.&Type(const Value: string): TChatMessageContent;
begin
  Result := TChatMessageContent(Add('type', Value));
end;

{ TContentImageSource }

function TContentImageSource.Data(const Value: string): TContentImageSource;
begin
  Result := TContentImageSource(Add('data', Value));
end;

function TContentImageSource.MediaType(
  const Value: string): TContentImageSource;
begin
  Result := TContentImageSource(Add('media_type', Value));
end;

class function TContentImageSource.New(
  const Value: string): TContentImageSource;
var
  MimeType: string;
  Base64: string;
begin
  if Value.ToLower.StartsWith('http') then
    Base64 := THttpx.LoadDataToBase64(Value, MimeType) else
    base64 := FileToBase64(Value, MimeType);
  Result := TContentImageSource.Create.&Type('base64').MediaType(MimeType).Data(Base64);
end;

function TContentImageSource.&Type(const Value: string): TContentImageSource;
begin
  Result := TContentImageSource(Add('type', Value));
end;

{ TSystemPayload }

class function TSystemPayload.AddText(const Value: string;
  const Caching: TCachingType): TSystemPayload;
begin
  Result := TSystemPayload.Create.&Type('text').Text(Value);
  if Caching <> nocaching then
  case Caching of
    ephemeral:
      Result := Result.CacheControl(Caching);
  end;
end;

function TSystemPayload.CacheControl(const Value: TCachingType): TSystemPayload;
begin
  Result := TSystemPayload(Add('cache_control', TJSONObject.Create.AddPair('type', Value.ToString)));
end;

function TSystemPayload.Text(const Value: string): TSystemPayload;
begin
  Result := TSystemPayload(Add('text', Value));
end;

function TSystemPayload.&Type(const Value: string): TSystemPayload;
begin
  Result := TSystemPayload(Add('type', Value));
end;

end.

unit Anthropic.Errors;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiAnthropic
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  REST.Json.Types;

type
  TErrorCore = class abstract
  end;

  TErrorObject = class
  private
    [JsonNameAttribute('type')]
    FType: string;
    [JsonNameAttribute('message')]
    FMessage: string;
  public
    property &Type: string read FType write FType;
    property Message: string read FMessage write FMessage;
  end;

  TError = class(TErrorCore)
  private
    [JsonNameAttribute('type')]
    FType: string;
    [JsonNameAttribute('error')]
    FError: TErrorObject;
  public
    property &Type: string read FType write FType;
    property Error: TErrorObject read FError write FError;
    destructor Destroy; override;
  end;

implementation

{ TError }

destructor TError.Destroy;
begin
  if Assigned(FError) then
    FError.Free;
  inherited;
end;

end.

unit Anthropic.Functions.Core;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiAnthropic
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.JSON;

type
  /// <summary>
  /// Interface defining the core structure and functionality of a function in the system.
  /// </summary>
  /// <remarks>
  /// This interface outlines the basic properties and methods that any function implementation must include.
  /// </remarks>
  IFunctionCore = interface
    ['{D318078A-BA04-4131-A0E9-C95F0330C984}']
    /// <summary>
    ///  Retrieves Cache control flag.
    /// </summary>
    function GetCacheControl: Boolean;
    /// <summary>
    /// Set value to Cache control flag.
    /// </summary>
    procedure SetCacheControl(const Value: Boolean);
    /// <summary>
    /// Retrieves the description of the function.
    /// </summary>
    function GetDescription: string;
    /// <summary>
    /// Retrieves the name of the function.
    /// </summary>
    function GetName: string;
    /// <summary>
    /// Retrieves the InputSchema required by the function, represented as a JSON schema.
    /// </summary>
    function GetInputSchema: string;
    /// <summary>
    /// Executes the function with the provided arguments and returns the result as a string.
    /// </summary>
    /// <param name="Arguments">The arguments passed to the function in JSON format.</param>
    /// <returns>The result of the function execution as a string.</returns>
    function Execute(const Arguments: string): string;
     /// <summary>
    /// Converts the TFunctionCore instance to a JSON object that contains its type and representation.
    /// </summary>
    /// <returns>A JSON object representing the function instance.</returns>
    function ToJson: TJSONObject;
    /// <summary>
    /// Creates a string representation of the TFunctionCore instance in JSON format, including its description, name, and InputSchema.
    /// </summary>
    /// <returns>A string representation of the function in JSON format.</returns>
    function ToString: string;
    /// <summary>
    /// A brief description of the function's purpose, used by the model to determine when and how to call the function.
    /// </summary>
    property Description: string read GetDescription;
    /// <summary>
    /// The unique identifier of the function that will be called. It must only contain characters from a-z, A-Z, 0-9, underscores, or dashes, and should not exceed 64 characters in length.
    /// </summary>
    property Name: string read GetName;
    //// <summary>
    /// The InputSchema required by the function, specified as a JSON schema. If no InputSchema are required, use the schema: {"type": "object", "properties": {}}.
    /// </summary>
    property InputSchema: string read GetInputSchema;
    /// <summary>
    /// Caching tool option
    /// </summary>
    property CacheControl: Boolean read GetCacheControl write SetCacheControl;
  end;

  /// <summary>
  /// Abstract base class for implementing core function behavior.
  /// </summary>
  /// <remarks>
  /// This class provides basic implementations for some methods and defines the structure that derived classes must follow.
  /// </remarks>
  TFunctionCore = class abstract(TinterfacedObject, IFunctionCore)
  private
    /// <summary>
    ///  Retrieves Cache control flag.
    /// </summary>
    function GetCacheControl: Boolean;
    /// <summary>
    /// Set value to Cache control flag.
    /// </summary>
    procedure SetCacheControl(const Value: Boolean);
  protected
    FCacheControl: Boolean;
    /// <summary>
    /// Retrieves the description of the function. Derived classes must implement this method.
    /// </summary>
    function GetDescription: string; virtual; abstract;
     /// <summary>
    /// Retrieves the name of the function. Derived classes must implement this method.
    /// </summary>
    function GetName: string; virtual; abstract;
    /// <summary>
    /// Retrieves the InputSchema required by the function, represented as a JSON schema. Derived classes must implement this method.
    /// </summary>
    function GetInputSchema: string; virtual; abstract;
  public
    /// <summary>
    /// Executes the function with the provided arguments and returns the result as a string. Derived classes must implement this method.
    /// </summary>
    /// <param name="Arguments">The arguments passed to the function in JSON format.</param>
    /// <returns>The result of the function execution as a string.</returns>
    function Execute(const Arguments: string): string; virtual; abstract;
    /// <summary>
    /// Converts the TFunctionCore instance to a JSON object that contains its type and representation.
    /// </summary>
    /// <returns>A JSON object representing the function instance.</returns>
    function ToJson: TJSONObject;
    /// <summary>
    /// Creates a string representation of the TFunctionCore instance in JSON format, including its description, name, and InputSchema.
    /// </summary>
    /// <returns>A string representation of the function in JSON format.</returns>
    function ToString: string; override;
    /// <summary>
    /// A brief description of the function's purpose, used by the model to determine when and how to call the function.
    /// </summary>
    property Description: string read GetDescription;
    /// <summary>
    /// The unique identifier of the function that will be called. It must only contain characters from a-z, A-Z, 0-9, underscores, or dashes, and should not exceed 64 characters in length.
    /// </summary>
    property Name: string read GetName;
    /// <summary>
    /// The InputSchema required by the function, specified as a JSON schema. If no InputSchema are required, use the schema: {"type": "object", "properties": {}}.
    /// </summary>
    property InputSchema: string read GetInputSchema;
    /// <summary>
    /// Caching tool option
    /// </summary>
    property CacheControl: Boolean read GetCacheControl write SetCacheControl;
  end;

implementation

{ TFunctionCore }

function TFunctionCore.GetCacheControl: Boolean;
begin
  Result := FCacheControl;
end;

procedure TFunctionCore.SetCacheControl(const Value: Boolean);
begin
  FCacheControl := Value;
end;

function TFunctionCore.ToJson: TJSONObject;
begin
  Result := TJSONObject.Create;
  try
    Result.AddPair('name', Name);
    Result.AddPair('description', Description);
    Result.AddPair('input_schema', TJSONObject.ParseJSONValue(InputSchema));
    if FCacheControl then
      begin
        {--- Add cache_control object }
        var JSONCacheValue := TJSONObject.Create(TJSONPair.Create('type', 'ephemeral'));
        Result.AddPair('cache_control', JSONCacheValue);
      end;
  except
    on E: Exception do
      begin
        Result.Free;
        raise;
      end;
  end;
end;

function TFunctionCore.ToString: string;
begin
  with TStringWriter.Create do
    try
      Write('"name": "%s"', [Name]);
      Write(',"description": "%s"', [Description]);
      Write(',"input_schema": %s', [InputSchema]);
      if FCacheControl then
        Write(',"cache_control": {"type": "ephemeral"}');
      Result := Format('{%s}', [ToString]);
    finally
      Free;
    end;

  {--- Format output }
  var JSON := TJSONObject.ParseJSONValue(Result);
  try
    Result := JSON.Format();
  finally
    JSON.Free;
  end;
end;

end.

unit Anthropic.Functions.Example;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiAnthropic
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, Anthropic.Functions.Core, MistralAI.Schema, MistralAI.Types;

type
  TWeatherReportFunction = class(TFunctionCore)
  protected
    function GetDescription: string; override;
    function GetName: string; override;
    function GetInputSchema: string; override;
  public
    function Execute(const Arguments: string): string; override;
    class function CreateInstance(const CacheControl: Boolean = False): IFunctionCore;
  end;

implementation

uses
  System.StrUtils, System.JSON;

{ TWeatherReportFunction }

class function TWeatherReportFunction.CreateInstance(
  const CacheControl: Boolean): IFunctionCore;
begin
  Result := TWeatherReportFunction.create;
  Result.CacheControl := CacheControl;
end;

function TWeatherReportFunction.Execute(const Arguments: string): string;

  procedure AddToReport(const Value: TJSONObject;
    Temperature: Integer; Forecast: TArray<string>);
  begin
    Value.AddPair('temperature', TJSONNumber.Create(Temperature));
    Value.AddPair('forecast', TJSONArray.Create(Forecast[0], Forecast[1]));
  end;

begin
  Result := EmptyStr;
  var Location := EmptyStr;

  {--- Parse arguments to retrieve parameters }
  var JSON := TJSONObject.ParseJSONValue(Arguments) as TJSONObject;
  try
    if Assigned(JSON) then
    try
      Location := JSON.GetValue('location', '');
    finally
      JSON.Free;
    end;
  except
    Location := EmptyStr;
  end;

  {--- Stop the treatment if location is empty }
  if Location.IsEmpty then
    Exit;

  {--- Build the response }
  JSON := TJSONObject.Create;
  try
    JSON.AddPair('location', Location);
    case IndexStr(AnsiLowerCase(Location), [
      'san francisco', 'san francisco, ca',
      'paris', 'paris, fr', 'paris, france']) of
      0,1 :
        AddToReport(JSON, 64, [
          'sunny',
          'windy']);

      2,3,4 :
        AddToReport(JSON, 55, [
          'rainy',
          'low visibility but sunny in the late afternoon or early evening']);
    end;
    Result := JSON.ToJSON;
  finally
    JSON.Free;
  end;
end; {Execute}


function TWeatherReportFunction.GetDescription: string;
begin
  Result := 'Get the current weather in a given location';
end;

function TWeatherReportFunction.GetName: string;
begin
  Result := 'get_weather';
end;

function TWeatherReportFunction.GetInputSchema: string;
begin
//  Result :=
//    '{'+
//    '"type": "object",'+
//    '"properties": {'+
//         '"location": {'+
//             '"type": "string",'+
//             '"description": "The city and department, e.g. Marseille, 13"'+
//         '},'+
//         '"unit": {'+
//             '"type": "string",'+
//             '"enum": ["celsius", "fahrenheit"]'+
//         '}'+
//     '},'+
//     '"required": ["location"]'+
//  '}';

  {--- If we use the TSchemaParams class defined in the MistralAI.Schema.pas unit }
  var Schema := TSchemaParams.New(
    procedure (var Params: TSchemaParams)
    begin
      Params.&Type(stOBJECT);
      Params.Properties('properties',
        procedure (var Params: TSchemaParams)
        begin
          Params.Properties('location',
            procedure (var Params: TSchemaParams)
            begin
              Params.&Type(stSTRING);
              Params.Description('The city and state, e.g. San Francisco, CA');
            end);
          Params.Properties('unit',
            procedure (var Params: TSchemaParams)
            begin
              Params.&Type(stSTRING);
              Params.Enum(['celsius', 'fahrenheit']);
            end);
        end);
      Params.Required(['location', 'unit']);
    end);
  Result := Schema.ToJsonString(True);
end;

end.

unit Anthropic.Httpx;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiAnthropic
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Net.URLClient, System.Net.HttpClient,
  System.Net.HttpClientComponent, System.NetEncoding;

type
  /// <summary>
  /// THttpx provides utility methods for handling HTTP-related tasks such as
  /// downloading data, encoding it in Base64, and retrieving MIME types.
  /// </summary>
  THttpx = class
    /// <summary>
    /// Converts the content of a stream into a byte array.
    /// </summary>
    /// <param name="AStream">
    /// The input stream to convert.
    /// </param>
    /// <returns>
    /// A byte array containing the data from the input stream.
    /// </returns>
    /// <exception cref="Exception">
    /// Raises an exception if the input stream is null.
    /// </exception>
    class function StreamToBytes(AStream: TStream): TBytes;
    /// <summary>
    /// Loads data from the specified URL, encodes it in Base64, and retrieves its MIME type.
    /// </summary>
    /// <param name="Url">
    /// The URL to fetch the data from.
    /// </param>
    /// <param name="MimeType">
    /// Outputs the MIME type of the data retrieved from the URL.
    /// </param>
    /// <returns>
    /// A Base64-encoded string representing the data fetched from the URL.
    /// </returns>
    class function LoadDataToBase64(const Url: string; var MimeType: string): string; overload;
    /// <summary>
    /// Loads data from the specified URL, encodes it in Base64.
    /// </summary>
    /// <param name="Url">
    /// The URL to fetch the data from.
    /// </param>
    /// <returns>
    /// A Base64-encoded string representing the data fetched from the URL.
    /// </returns>
    class function LoadDataToBase64(const Url: string): string; overload;
    /// <summary>
    /// Retrieves the MIME type of the content at the specified URL.
    /// </summary>
    /// <param name="Url">
    /// The URL of the content to inspect.
    /// </param>
    /// <returns>
    /// A string representing the MIME type of the content at the URL.
    /// </returns>
    class function GetMimeType(const Url: string): string;
    /// <summary>
    /// Validates the accessibility of a specified URL by performing an HTTP HEAD request.
    /// </summary>
    /// <param name="Url">
    /// The URL to validate.
    /// </param>
    /// <exception cref="Exception">
    /// Raises an exception if the URL is not accessible or the server responds with a non-success status code.
    /// </exception>
    /// <remarks>
    /// This method checks the HTTP status code returned by the server for the given URL.
    /// If the status code indicates an error (e.g., 4xx or 5xx), an exception is raised.
    /// If the status code indicates success (e.g., 200-299), no exception is thrown.
    /// </remarks>
    class procedure UrlCheck(const Url: string);
  end;

implementation

{ THttpx }

class function THttpx.GetMimeType(const Url: string): string;
begin
  var HttpClient := THTTPClient.Create;
  try
    Result := (HttpClient.Head(Url) as IHTTPResponse).MimeType;
  finally
    HttpClient.Free;
  end;
end;

class function THttpx.LoadDataToBase64(const Url: string; var MimeType: string): string;
begin
  MimeType := GetMimeType(Url);
  Result := LoadDataToBase64(Url);
end;

class function THttpx.LoadDataToBase64(const Url: string): string;
begin
  var HttpClient := THTTPClient.Create;
  try
    var Response: IHTTPResponse := HttpClient.Get(Url);
    var DataBytes := StreamToBytes(Response.ContentStream);
    {$IF RTLVersion >= 35.0}
    Result := TNetEncoding.Base64String.EncodeBytesToString(DataBytes);
    {$ELSE}
    Result := TNetEncoding.Base64.EncodeBytesToString(ImageBytes);
    {$ENDIF}
  finally
    HttpClient.Free;
  end;
end;

class function THttpx.StreamToBytes(AStream: TStream): TBytes;
var
  LBytesStream: TBytesStream;
begin
  if not Assigned(AStream) then
    raise Exception.Create('StreamToBytes error: stream is null');

  LBytesStream := TBytesStream.Create;
  try
    AStream.Position := 0;
    LBytesStream.CopyFrom(AStream, AStream.Size);
    Result := LBytesStream.Bytes;
    SetLength(Result, LBytesStream.Size);
  finally
    LBytesStream.Free;
  end;
end;

class procedure THttpx.UrlCheck(const Url: string);
begin
  var HttpClient := THTTPClient.Create;
  try
    case (HttpClient.Head(Url) as IHTTPResponse).StatusCode of
      200..299: ;
      else
        raise Exception.CreateFmt('Address not found or inaccessible : %s', [Url]);
    end;
  finally
    HttpClient.Free;
  end;
end;

end.

unit Anthropic.Models;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiAnthropic
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, System.Threading,
  REST.Json.Types, Anthropic.API.Params, Anthropic.API, Anthropic.Async.Support;

type
  /// <summary>
  /// The <c>TListModelsParams</c> class is used to define parameters for retrieving lists of models.
  /// It allows for pagination by setting limits, specifying model IDs to start after, or ending before.
  /// </summary>
  /// <remarks>
  /// This class helps in controlling the number of results returned in list queries and enables efficient data navigation
  /// through the use of pagination parameters such as <c>Limit</c>, <c>AfterId</c>, and <c>BeforeId</c>.
  /// <para>
  /// <b>--- Warning:</b> The parameters <c>AfterId</c> and <c>BeforeId</c> are mutually exclusive, meaning that both cannot be used simultaneously
  /// in a single query. Ensure that only one of these parameters is set at a time to avoid conflicts.
  /// </para>
  /// </remarks>
  TListModelsParams = class(TUrlParam)
  public
    /// <summary>
    /// Number of items to return per page.
    /// </summary>
    /// <param name="Value">
    /// Defaults to 20. Ranges from 1 to 1000.
    /// </param>
    /// <returns>
    /// The current instance of <c>TListModelsParams</c> with the specified limit.
    /// </returns>
    /// <exception cref="Exception">
    /// Thrown if the value is less than 1 or greater than 100.
    /// </exception>
    /// <remarks>
    /// The default value of limit set to 20.
    /// </remarks>
    function Limite(const Value: Integer): TListModelsParams;
    /// <summary>
    /// ID of the object to use as a cursor for pagination. When provided, returns the page of results immediately after this object.
    /// </summary>
    /// <param name="Value">
    /// A string representing the model ID.
    /// </param>
    /// <returns>
    /// The current instance of <c>TListModelsParams</c> with the specified <c>after_id</c> value.
    /// </returns>
    function AfterId(const Value: string): TListModelsParams;
    /// <summary>
    /// ID of the object to use as a cursor for pagination. When provided, returns the page of results immediately before this object.
    /// </summary>
    /// <param name="Value">
    /// A string representing the model ID.
    /// </param>
    /// <returns>
    /// The current instance of <c>TListModelsParams</c> with the specified <c>before_id</c> value.
    /// </returns>
    function BeforeId(const Value: string): TListModelsParams;
  end;

  /// <summary>
  /// The <c>TModel</c> class represents a single model entity within the Anthropic API.
  /// It provides access to details about the model, including its unique identifier,
  /// type, human-readable name, and creation timestamp.
  /// </summary>
  /// <remarks>
  /// This class is used to encapsulate the metadata associated with a model.
  /// It is designed to be serialized and deserialized from JSON format
  /// when interacting with the Anthropic API endpoints.
  /// <para>
  /// The <c>Type</c> property will always return the value "model" for instances
  /// of this class. The <c>Id</c> property uniquely identifies the model, while
  /// the <c>DisplayName</c> property provides a human-readable description of the model.
  /// The <c>CreatedAt</c> property indicates when the model was released or first made available.
  /// </para>
  /// </remarks>
  TModel = class
  private
    FType: string;
    FId: string;
    [JsonNameAttribute('display_name')]
    FDisplayName: string;
    [JsonNameAttribute('created_at')]
    FCreatedAt: string;
  public
    /// <summary>
    /// For Models, this is always "model".
    /// </summary>
    property &Type: string read FType write FType;
    /// <summary>
    /// Unique model identifier.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// A human-readable name for the model.
    /// </summary>
    property DisplayName: string read FDisplayName write FDisplayName;
    /// <summary>
    /// RFC 3339 datetime string representing the time at which the model was released.
    /// May be set to an epoch value if the release date is unknown.
    /// </summary>
    property CreatedAt: string read FCreatedAt write FCreatedAt;
  end;

  /// <summary>
  /// The <c>TModels</c> class represents a collection of model entities retrieved from the Anthropic API.
  /// It encapsulates the list of models and additional metadata for pagination purposes.
  /// </summary>
  /// <remarks>
  /// This class is designed to manage and store a list of <c>TModel</c> objects, along with
  /// information to facilitate navigation through paginated results.
  /// <para>
  /// The <c>Data</c> property contains the array of models retrieved in the current query.
  /// The <c>HasMore</c> property indicates whether there are additional results beyond the current page.
  /// The <c>FirstId</c> and <c>LastId</c> properties provide cursors for navigating to the previous
  /// and next pages of results, respectively.
  /// </para>
  /// <para>
  /// When an instance of this class is destroyed, it ensures proper memory cleanup
  /// by freeing the individual <c>TModel</c> objects in the <c>Data</c> array.
  /// </para>
  /// </remarks>
  TModels = class
  private
    FData: TArray<TModel>;
    [JsonNameAttribute('has_more')]
    FHasMore: Boolean;
    [JsonNameAttribute('first_id')]
    FFirstId: string;
    [JsonNameAttribute('last_id')]
    FLastId: string;
  public
    /// <summary>
    /// The array of models retrieved in the current query.
    /// </summary>
    property Data: TArray<TModel> read FData write FData;
    /// <summary>
    /// Indicates if there are more results in the requested page direction.
    /// </summary>
    property HasMore: Boolean read FHasMore write FHasMore;
    /// <summary>
    /// First ID in the data list. Can be used as the before_id for the previous page.
    /// </summary>
    property FirstId: string read FFirstId write FFirstId;
    /// <summary>
    /// Last ID in the data list. Can be used as the after_id for the next page.
    /// </summary>
    property LastId: string read FLastId write FLastId;
    destructor Destroy; override;
  end;

  /// <summary>
  /// The <c>TAsynModel</c> class is a type alias used to handle asynchronous callbacks for batch processing.
  /// It provides support for executing batch operations asynchronously and processing the results upon completion.
  /// </summary>
  /// <remarks>
  /// This class is part of the asynchronous framework that allows non-blocking batch operations.
  /// It uses a callback mechanism to return the result of a batch process once it is completed.
  /// </remarks>
  TAsynModel = TAsynCallBack<TModel>;

  /// <summary>
  /// The <c>TAsynModels</c> class is a type alias used to handle asynchronous callbacks for batch processing.
  /// It provides support for executing batch operations asynchronously and processing the results upon completion.
  /// </summary>
  /// <remarks>
  /// This class is part of the asynchronous framework that allows non-blocking batch operations.
  /// It uses a callback mechanism to return the result of a batch process once it is completed.
  /// </remarks>
  TAsynModels = TAsynCallBack<TModels>;

  /// <summary>
  /// The <c>TModelsRoute</c> class provides methods for interacting with the Anthropic API
  /// to retrieve and manage models. It offers both synchronous and asynchronous operations
  /// for listing and retrieving individual models.
  /// </summary>
  /// <remarks>
  /// This class serves as a high-level interface for accessing model-related API endpoints.
  /// It extends the <c>TAnthropicAPIRoute</c> class, inheriting base functionalities
  /// while adding methods specific to model operations.
  /// <para>
  /// Key functionalities include:
  /// <list type="bullet">
  /// <item><description>Listing all available models using <c>List</c> and <c>AsynList</c> methods.</description></item>
  /// <item><description>Retrieving details of a specific model by its ID using <c>Retrieve</c> and <c>AsynRetrieve</c> methods.</description></item>
  /// </list>
  /// </para>
  /// <para>
  /// Asynchronous methods (<c>AsynList</c> and <c>AsynRetrieve</c>) allow the application
  /// to handle API responses in a non-blocking manner, suitable for UI-intensive scenarios.
  /// Synchronous methods (<c>List</c> and <c>Retrieve</c>) block execution until the API response is received.
  /// </para>
  /// </remarks>
  TModelsRoute = class(TAnthropicAPIRoute)
    /// <summary>
    /// List available models.
    /// The Models API response can be used to determine which models are available for use in the API.
    /// More recently released models are listed first.
    /// </summary>
    /// <param name="CallBacks">
    /// A function that returns <c>TAsynModels</c> to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// <para>
    /// The <c>CallBacks</c> function is invoked when the operation completes, either successfully or
    /// with an error.
    /// </para>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var Anthropic := TAnthropicFactory.CreateInstance(BaererKey);
    /// Anthropic.Models.AsynList(
    ///   function : TAsynModels
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TModels)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsynList(CallBacks: TFunc<TAsynModels>); overload;
    /// <summary>
    /// List available models.
    /// The Models API response can be used to determine which models are available for use in the API.
    /// More recently released models are listed first.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TListModelsParams</c> parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns <c>TAsynModels</c> to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// <para>
    /// The <c>CallBacks</c> function is invoked when the operation completes, either successfully or
    /// with an error.
    /// </para>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var Anthropic := TAnthropicFactory.CreateInstance(BaererKey);
    /// Anthropic.Models.AsynList(
    ///   procedure (Params: TListModelsParams)
    ///   begin
    ///     // Define parameters
    ///   end,
    ///
    ///   function : TAsynModels
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TModels)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsynList(ParamProc: TProc<TListModelsParams>; CallBacks: TFunc<TAsynModels>); overload;
    /// <summary>
    /// Get a specific model.
    /// The Models API response can be used to determine information about a specific model or
    /// resolve a model alias to a model ID.
    /// </summary>
    /// <param name="ModelId">
    /// Model identifier or alias.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns <c>TAsynModel</c> to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// <para>
    /// The <c>CallBacks</c> function is invoked when the operation completes, either successfully or
    /// with an error.
    /// </para>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var Anthropic := TAnthropicFactory.CreateInstance(BaererKey);
    /// Anthropic.Models.AsynRetrieve(ModelId,
    ///   function : TAsynModels
    ///   begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Value: TModel)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsynRetrieve(const ModelId: string; CallBacks: TFunc<TAsynModel>);
    /// <summary>
    /// List available models.
    /// The Models API response can be used to determine which models are available for use in the API.
    /// More recently released models are listed first.
    /// </summary>
    /// <returns>
    /// A <c>TModels</c> object containing the list of models.
    /// </returns>
    /// <remarks>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var Anthropic := TAnthropicFactory.CreateInstance(BaererKey);
    /// var Value := Anthropic.Models.List;
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function List: TModels; overload;
    /// <summary>
    /// List available models.
    /// The Models API response can be used to determine which models are available for use in the API.
    /// More recently released models are listed first.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the <c>TListModelsParams</c> parameters.
    /// </param>
    /// <returns>
    /// A <c>TModels</c> object containing the list of models.
    /// </returns>
    /// <remarks>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var Anthropic := TAnthropicFactory.CreateInstance(BaererKey);
    /// var Value := Anthropic.Models.List(
    ///     procedure (Params: TListModelsParams)
    ///     begin
    ///       // Define parameters
    ///     end;
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function List(ParamProc: TProc<TListModelsParams>): TModels; overload;
    /// <summary>
    /// Get a specific model.
    /// The Models API response can be used to determine information about a specific model or
    /// resolve a model alias to a model ID.
    /// </summary>
    /// <param name="ModelId">
    /// Model identifier or alias.
    /// </param>
    /// <returns>
    /// A <c>TModel</c> object containing the model data.
    /// </returns>
    /// <remarks>
    /// <code>
    /// //WARNING - Move the following line into the main OnCreate
    /// //var Anthropic := TAnthropicFactory.CreateInstance(BaererKey);
    /// var Value := Anthropic.Models.Retrieve(ModelId);
    /// try
    ///   // Handle the Value
    /// finally
    ///   Value.Free;
    /// end;
    /// </code>
    /// </remarks>
    function Retrieve(const ModelId: string): TModel;
  end;

implementation

{ TModels }

destructor TModels.Destroy;
begin
  for var Item in FData do
    Item.Free;
  inherited;
end;

{ TListModelsParams }

function TListModelsParams.AfterId(const Value: string): TListModelsParams;
begin
  Result := TListModelsParams(Add('after_id', Value));
end;

function TListModelsParams.BeforeId(const Value: string): TListModelsParams;
begin
  Result := TListModelsParams(Add('before_id', Value));
end;

function TListModelsParams.Limite(const Value: Integer): TListModelsParams;
begin
  Result := TListModelsParams(Add('limit', Value));
end;

{ TModelsRoute }

function TModelsRoute.List: TModels;
begin
  Result := API.Get<TModels>('models');
end;

procedure TModelsRoute.AsynList(CallBacks: TFunc<TAsynModels>);
begin
  with TAsynCallBackExec<TAsynModels, TModels>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TModels
      begin
        Result := Self.List;
      end);
  finally
    Free;
  end;
end;

procedure TModelsRoute.AsynList(ParamProc: TProc<TListModelsParams>;
  CallBacks: TFunc<TAsynModels>);
begin
  with TAsynCallBackExec<TAsynModels, TModels>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TModels
      begin
        Result := Self.List(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TModelsRoute.AsynRetrieve(const ModelId: string;
  CallBacks: TFunc<TAsynModel>);
begin
  with TAsynCallBackExec<TAsynModel, TModel>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TModel
      begin
        Result := Self.Retrieve(ModelId);
      end);
  finally
    Free;
  end;
end;

function TModelsRoute.List(ParamProc: TProc<TListModelsParams>): TModels;
begin
  Result := API.Get<TModels, TListModelsParams>('models', ParamProc);
end;

function TModelsRoute.Retrieve(const ModelId: string): TModel;
begin
  Result := API.Get<TModel>('models/' + ModelId);
end;

end.

unit Anthropic.NetEncoding.Base64;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiAnthropic
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.NetEncoding, System.Net.Mime;

  /// <summary>
  /// Encodes the content of a file into a Base64-encoded string.
  /// </summary>
  /// <param name="FileLocation">The full path to the file that will be encoded.</param>
  /// <returns>A Base64-encoded string representing the content of the file.</returns>
  /// <exception cref="Exception">Thrown if the specified file does not exist at the provided location.</exception>
  /// <remarks>
  /// This method reads the file from the specified location and converts it to a Base64 string.
  /// It uses different encoding methods depending on the version of the RTL.
  /// For RTL version 35.0 and later, it uses <c>TNetEncoding.Base64String.Encode</c>,
  /// and for earlier versions, it uses <c>TNetEncoding.Base64.Encode</c>.
  /// </remarks>
  function EncodeBase64(FileLocation : string) : string;

  /// <summary>
  /// Retrieves the MIME type of the specified file based on its location.
  /// </summary>
  /// <param name="FileLocation">The full path to the file whose MIME type is to be resolved.</param>
  /// <returns>
  /// A string representing the MIME type of the file.
  /// If the file does not exist, an exception will be raised.
  /// </returns>
  /// <exception cref="Exception">
  /// Thrown if the specified file cannot be found at the provided location.
  /// </exception>
  /// <remarks>
  /// This method checks if the specified file exists and retrieves its MIME type
  /// using the <c>TMimeTypes.Default.GetFileInfo</c> method.
  /// Ensure the provided path is valid before calling this function.
  /// </remarks>
  function ResolveMimeType(const FileLocation: string): string;

  /// <summary>
  /// Retrieves the MIME type of the specified file and returns its content as a Base64-encoded string.
  /// </summary>
  /// <param name="FileLocation">
  /// The full path to the file that will be encoded.
  /// </param>
  /// <param name="MimeType">
  /// On successful return, this parameter contains the MIME type of the file.
  /// </param>
  /// <returns>
  /// A Base64-encoded string representing the content of the file.
  /// </returns>
  /// <exception cref="Exception">
  /// Thrown if the file does not exist or if its MIME type cannot be determined.
  /// </exception>
  /// <remarks>
  function FileToBase64(FileLocation : string; var MimeType: string): string;

implementation

uses
  System.StrUtils;

function EncodeBase64(FileLocation : string): string;
begin
  if not FileExists(FileLocation) then
    raise Exception.CreateFmt('File not found : %s', [FileLocation]);

  var Stream := TMemoryStream.Create;
  var StreamOutput := TStringStream.Create('', TEncoding.UTF8);
  try
    Stream.LoadFromFile(FileLocation);
    Stream.Position := 0;
    {$IF RTLVersion >= 35.0}
    TNetEncoding.Base64String.Encode(Stream, StreamOutput);
    {$ELSE}
    TNetEncoding.Base64.Encode(Stream, StreamOutput);
    {$ENDIF}
    Result := StreamOutput.DataString;
  finally
    Stream.Free;
    StreamOutput.Free;
  end;
end;

function ResolveMimeType(const FileLocation: string): string;
begin
  if not FileExists(FileLocation) then
    raise Exception.CreateFmt('File not found: %s', [FileLocation]);

  var LKind: TMimeTypes.TKind;
  TMimeTypes.Default.GetFileInfo(FileLocation, Result, LKind);
end;

//procedure CheckMimeType(const MimeType: string);
//begin
////  if IndexStr(MimeType.ToLower, ['image/png', 'image/jpeg', 'image/gif', 'image/webp', 'application/pdf']) = -1 then
////    raise Exception.Create('Unsupported document format');
//end;

function FileToBase64(FileLocation : string; var MimeType: string): string;
begin
  MimeType := ResolveMimeType(FileLocation);
  Result := EncodeBase64(FileLocation);
end;

end.

unit Anthropic;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiAnthropic
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Net.URLClient,
  Anthropic.API, Anthropic.Chat, Anthropic.Batches, Anthropic.Models,
  Anthropic.Batches.Support, Anthropic.Functions.Core, Anthropic.Schema;

type
  /// <summary>
  /// The <c>IAnthropic</c> interface provides access to the various features and routes of the Anthropic AI API.
  /// This interface allows interaction with different services such as agents, chat, code completion,
  /// embeddings, file management, fine-tuning, and model information.
  /// </summary>
  /// <remarks>
  /// This interface should be implemented by any class that wants to provide a structured way of accessing
  /// the Anthropic AI services. It includes methods and properties for authenticating with an API key,
  /// configuring the base URL, and accessing different API routes.
  ///
  /// To use this interface, instantiate a class that implements it, set the required properties such as
  /// <see cref="Token"/> and <see cref="BaseURL"/>, and call the relevant methods for the desired operations.
  /// <code>
  ///   var Anthropic: IAnthropic := TAnthropic.Create(API_TOKEN);
  /// </code>
  /// <seealso cref="TAnthropic"/>
  /// </remarks>
  IAnthropic = interface
    ['{7E69221E-3C24-4B38-9AE9-894714CA9A47}']
    function GetAPI: TAnthropicAPI;
    procedure SetToken(const Value: string);
    function GetToken: string;
    function GetBaseUrl: string;
    procedure SetBaseUrl(const Value: string);
    function GetChatRoute: TChatRoute;
    function GetBatcheRoute: TBatcheRoute;
    function GetModelsRoute : TModelsRoute;

    /// <summary>
    /// Provides access to the chat completion API.
    /// </summary>
    /// <returns>
    /// An instance of TChatRoute for chat-related operations.
    /// </returns>
    property Chat: TChatRoute read GetChatRoute;
    /// <summary>
    /// Provides access to the batches API.
    /// </summary>
    /// <returns>
    /// An instance of TChatRoute for batches-related operations.
    /// </returns>
    property Batche: TBatcheRoute read GetBatcheRoute;
    /// <summary>
    /// Provides access to the models API.
    /// </summary>
    /// <returns>
    /// An instance of TModelsRoute for models-related operations.
    /// </returns>
    property Models: TModelsRoute read GetModelsRoute;
    /// <summary>
    /// the main API object used for making requests.
    /// </summary>
    /// <returns>
    /// An instance of TAnthropicAPI for making API calls.
    /// </returns>
    property API: TAnthropicAPI read GetAPI;
    /// Sets or retrieves the API token for authentication.
    /// </summary>
    /// <param name="Value">
    /// The API token as a string.
    /// </param>
    /// <returns>
    /// The current API token.
    /// </returns>
    property Token: string read GetToken write SetToken;
    /// <summary>
    /// Sets or retrieves the base URL for API requests.
    /// Default is https://api.anthropic.com/v1
    /// </summary>
    /// <param name="Value">
    /// The base URL as a string.
    /// </param>
    /// <returns>
    /// The current base URL.
    /// </returns>
    property BaseURL: string read GetBaseUrl write SetBaseUrl;

  end;

  /// <summary>
  /// The <c>TAnthropicFactory</c> class is responsible for creating instances of
  /// the <see cref="IAnthropic"/> interface. It provides a factory method to instantiate
  /// the interface with a provided API token and optional header configuration.
  /// </summary>
  /// <remarks>
  /// This class provides a convenient way to initialize the <see cref="IAnthropic"/> interface
  /// by encapsulating the necessary configuration details, such as the API token and header options.
  /// By using the factory method, users can quickly create instances of <see cref="IAnthropic"/> without
  /// manually setting up the implementation details.
  /// </remarks>
  TAnthropicFactory = class
    /// <summary>
    /// Creates an instance of the <see cref="IAnthropic"/> interface with the specified API token
    /// and optional header configuration.
    /// </summary>
    /// <param name="AToken">
    /// The API token as a string, required for authenticating with Anthropic API services.
    /// </param>
    /// <param name="Option">
    /// An optional header configuration of type <see cref="THeaderOption"/> to customize the request headers.
    /// The default value is <c>THeaderOption.none</c>.
    /// </param>
    /// <returns>
    /// An instance of <see cref="IAnthropic"/> initialized with the provided API token and header option.
    /// </returns>
    class function CreateInstance(const AToken: string;
      const Option: Integer = 0): IAnthropic;
    /// <summary>
    /// Creates an instance of the <see cref="IAnthropic"/> interface with the specified API token
    /// with header managing caching configuration.
    /// </summary>
    /// <param name="AToken">
    /// The API token as a string, required for authenticating with Anthropic API services.
    /// </param>
    /// <returns>
    /// An instance of <see cref="IAnthropic"/> initialized with the provided API token and header option.
    /// </returns>
    class function CreateCachingInstance(const AToken: string): IAnthropic;
    /// <summary>
    /// Creates an instance of the <see cref="IAnthropic"/> interface with the specified API token
    /// with header managing batch configuration.
    /// </summary>
    /// <param name="AToken">
    /// The API token as a string, required for authenticating with Anthropic API services.
    /// </param>
    /// <returns>
    /// An instance of <see cref="IAnthropic"/> initialized with the provided API token and header option.
    /// </returns>
    class function CreateBatchingInstance(const AToken: string): IAnthropic;
  end;

  /// <summary>
  /// The TAnthropic class provides access to the various features and routes of the Anthropic AI API.
  /// This class allows interaction with different services such as agents, chat, code completion,
  /// embeddings, file management, fine-tuning, and model information.
  /// </summary>
  /// <remarks>
  /// This class should be implemented by any class that wants to provide a structured way of accessing
  /// the Anthropic AI services. It includes methods and properties for authenticating with an API key,
  /// configuring the base URL, and accessing different API routes.
  /// <seealso cref="TAnthropic"/>
  /// </remarks>
  TAnthropic = class(TInterfacedObject, IAnthropic)
  strict private

  private
    FAPI: TAnthropicAPI;

    FChatRoute: TChatRoute;
    FBatcheRoute: TBatcheRoute;
    FModelsRoute: TModelsRoute;

    function GetAPI: TAnthropicAPI;
    function GetToken: string;
    procedure SetToken(const Value: string);
    function GetBaseUrl: string;
    procedure SetBaseUrl(const Value: string);

    function GetChatRoute: TChatRoute;
    function GetBatcheRoute: TBatcheRoute;
    function GetModelsRoute : TModelsRoute;

  public
    /// <summary>
    /// Provides access to the chat completion API.
    /// </summary>
    /// <returns>
    /// An instance of TChatRoute for chat-related operations.
    /// </returns>
    property Chat: TChatRoute read GetChatRoute;
    /// <summary>
    /// Provides access to the batches API.
    /// </summary>
    /// <returns>
    /// An instance of TChatRoute for batches-related operations.
    /// </returns>
    property Batche: TBatcheRoute read GetBatcheRoute;
    /// <summary>
    /// Provides access to the models API.
    /// </summary>
    /// <returns>
    /// An instance of TModelsRoute for models-related operations.
    /// </returns>
    property Models: TModelsRoute read GetModelsRoute;

  public
    /// <summary>
    /// the main API object used for making requests.
    /// </summary>
    /// <returns>
    /// An instance of TAnthropicAPI for making API calls.
    /// </returns>
    property API: TAnthropicAPI read GetAPI;
    /// <summary>
    /// Sets or retrieves the API token for authentication.
    /// </summary>
    /// <param name="Value">
    /// The API token as a string.
    /// </param>
    /// <returns>
    /// The current API token.
    /// </returns>
    property Token: string read GetToken write SetToken;
    /// <summary>
    /// Sets or retrieves the base URL for API requests.
    /// Default is https://api.anthropic.com/v1.
    /// </summary>
    /// <param name="Value">
    /// The base URL as a string.
    /// </param>
    /// <returns>
    /// The current base URL.
    /// </returns>
    property BaseURL: string read GetBaseUrl write SetBaseUrl;

  public
    /// <summary>
    /// Initializes a new instance of the <see cref="TAnthropic"/> class with optional header configuration.
    /// </summary>
    /// <param name="Option">
    /// An optional parameter of type <see cref="THeaderOption"/> to configure the request headers.
    /// The default value is <c>THeaderOption.none</c>.
    /// </param>
    /// <remarks>
    /// This constructor is typically used when no API token is provided initially.
    /// The token can be set later via the <see cref="Token"/> property.
    /// </remarks>
    constructor Create(const Option: Integer = 0); overload;
    /// <summary>
    /// Initializes a new instance of the <see cref="TAnthropic"/> class with the provided API token and optional header configuration.
    /// </summary>
    /// <param name="AToken">
    /// The API token as a string, required for authenticating with the Anthropic AI API.
    /// </param>
    /// <param name="Option">
    /// An optional parameter of type <see cref="THeaderOption"/> to configure the request headers.
    /// The default value is <c>THeaderOption.none</c>.
    /// </param>
    /// <remarks>
    /// This constructor allows the user to specify an API token at the time of initialization.
    /// </remarks>
    constructor Create(const AToken: string; const Option: Integer = 0); overload;
    /// <summary>
    /// Releases all resources used by the current instance of the <see cref="TAnthropic"/> class.
    /// </summary>
    /// <remarks>
    /// This method is called to clean up any resources before the object is destroyed.
    /// It overrides the base <see cref="TInterfacedObject.Destroy"/> method.
    /// </remarks>
    destructor Destroy; override;
  end;

{$REGION 'Anthropic.Chat'}

  /// <summary>
  /// Represents an image source in the content payload.
  /// </summary>
  /// <remarks>
  /// This class is used to construct image-related content in a chat message, including
  /// its type, media type, and data. The data can be encoded in Base64 format for secure
  /// transmission or direct use, depending on the context.
  /// </remarks>
  TContentImageSource = Anthropic.Chat.TContentImageSource;

  /// <summary>
  /// Represents the content of a chat message.
  /// </summary>
  /// <remarks>
  /// This class is used to construct the content of a chat message, which can include
  /// text or image elements. It allows defining the type of content, the actual text or image
  /// data, and optional caching control for optimized performance.
  /// </remarks>
  TChatMessageContent = Anthropic.Chat.TChatMessageContent;

  /// <summary>
  /// Represents the payload for a chat message in a conversational context.
  /// </summary>
  /// <remarks>
  /// The <c>TChatMessagePayload</c> class provides the structure for defining and managing chat messages.
  /// It allows specifying the role of the sender (e.g., user, assistant) and the content of the message.
  /// The class supports multiple formats for message content, including text, images, and documents, and provides
  /// convenient methods for creating instances with predefined roles and content types.
  /// </remarks>
  TChatMessagePayload = Anthropic.Chat.TChatMessagePayload;

  /// <summary>
  /// Represents the payload for a chat message in a conversational context.
  /// </summary>
  /// <remarks>
  /// The <c>Payload</c> class provides the structure for defining and managing chat messages.
  /// It allows specifying the role of the sender (e.g., user, assistant) and the content of the message.
  /// The class supports multiple formats for message content, including text, images, and documents, and provides
  /// convenient methods for creating instances with predefined roles and content types.
  /// </remarks>
  Payload = Anthropic.Chat.Payload;

  /// <summary>
  /// The <c>TSystemPayload</c> record represents the system message payload
  /// This type is used to indicate behavior rules, response format patterns, or general information about the current context.
  /// </summary>
  /// <remarks>
  /// <para>
  /// - The <c>TSystemPayload</c> record is essential for managing conversations in a chat application, allowing to customize the response that will be built by the LLM.
  /// </para>
  /// <para>
  /// - This record provides several helper methods to create messages with predefined roles for easier management of system prompts.
  /// </para>
  /// <para>
  /// - It notably manages server-side caching.
  /// </para>
  /// <para>
  /// - In a system prompt there can be only two <c>TSystemPayload</c> records at most. The second <c>TSystemPayload</c> will be automatically marked to use caching.
  /// </para>
  /// </remarks>
  TSystemPayload = Anthropic.Chat.TSystemPayload;

  /// <summary>
  /// The <c>TChatParams</c> class represents the set of parameters used to configure a chat interaction with an AI model.
  /// </summary>
  /// <remarks>
  /// This class allows you to define various settings that control how the model behaves, including which model to use, how many tokens to generate,
  /// what kind of messages to send, and how the model should handle its output. By using this class, you can fine-tune the AI's behavior and response format
  /// based on your application's specific needs.
  /// <para>
  /// It inherits from <c>TJSONParam</c>, which provides methods for handling and serializing the parameters as JSON, allowing seamless integration
  /// with JSON-based APIs.
  /// </para>
  /// <code>
  /// var
  ///   Params: TChatParams;
  /// begin
  ///   Params := TChatParams.Create
  ///     .Model('my_model')
  ///     .MaxTokens(100)
  ///     .Messages([TChatMessagePayload1.User('Hello!')])
  ///     .Temperature(0.7)
  ///     .TopP(1)
  /// end;
  /// </code>
  /// This example shows how to instantiate and configure a <c>TChatParams</c> object for interacting with an AI model.
  /// </remarks>
  TChatParams = Anthropic.Chat.TChatParams;

  /// <summary>
  /// Represents the token usage statistics for a chat interaction, including the number of tokens
  /// used in the prompt, the completion, and the total number of tokens consumed.
  /// </summary>
  /// <remarks>
  /// The <c>TChatUsage</c> class provides insight into the number of tokens used during a chat interaction.
  /// This information is critical for understanding the cost of a request when using token-based billing systems
  /// or for monitoring the model's behavior in terms of input (prompt) and output (completion) size.
  /// </remarks>
  TChatUsage = Anthropic.Chat.TChatUsage;

  /// <summary>
  /// The response content made by a tool.
  /// </summary>
  TToolUse = Anthropic.Chat.TToolUse;

  /// <summary>
  /// The response content made by the LLM.
  /// </summary>
  /// <remarks>
  /// This class inherits from the <c>TToolUse</c> class because if a tool has been called, then the arguments obtained must be provided, otherwise it gives access to the textual content of a simple response.
  /// </remarks>
  TChatContent = Anthropic.Chat.TChatContent;

  /// <summary>
  /// Represents a data structure used for managing streaming chunks in a conversational system.
  /// </summary>
  /// <remarks>
  /// This class is primarily designed to handle the incremental data (chunks) returned by an LLM (Large Language Model) during streaming responses.
  /// It stores the type of chunk, textual content, and relevant metadata such as an identifier and tool name if applicable.
  /// The 'Input' property can contain partial JSON data, which should be parsed to construct the final response.
  /// </remarks>
  TChatDelta = Anthropic.Chat.TChatDelta;

  /// <summary>
  /// Represents a chat completion response generated by an AI model, containing the necessary metadata,
  /// the generated choices, and usage statistics.
  /// </summary>
  /// <remarks>
  /// The <c>TChat</c> class encapsulates the results of a chat request made to an AI model.
  /// It contains details such as a unique identifier, the model used, when the completion was created,
  /// the choices generated by the model, and token usage statistics.
  /// This class is crucial for managing the results of AI-driven conversations and understanding the
  /// underlying usage and response characteristics of the AI.
  /// </remarks>
  TChat = Anthropic.Chat.TChat;

  /// <summary>
  /// Count the number of tokens in a Message.
  /// The Token Count API can be used to count the number of tokens in a Message, including tools,
  /// images, and documents, without creating it.
  /// </summary>
  TTokenCount = Anthropic.Chat.TTokenCount;

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TTokenCount</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynTokenCount</c> type extends the <c>TAsynParams&lt;TTokenCount&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynTokenCount = Anthropic.Chat.TAsynTokenCount;

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TChat</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynChat</c> type extends the <c>TAsynParams&lt;TChat&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynChat = Anthropic.Chat.TAsynChat;

  /// <summary>
  /// Manages asynchronous streaming chat callBacks for a chat request using <c>TChat</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynChatStream</c> type extends the <c>TAsynStreamParams&lt;TChat&gt;</c> record to support the lifecycle of an asynchronous streaming chat operation.
  /// It provides callbacks for different stages, including when the operation starts, progresses with new data chunks, completes successfully, or encounters an error.
  /// This structure is ideal for handling scenarios where the chat response is streamed incrementally, providing real-time updates to the user interface.
  /// </remarks>
  TAsynChatStream = Anthropic.Chat.TAsynChatStream;

  /// <summary>
  /// Represents a callback procedure used during the reception of responses from a chat request in streaming mode.
  /// </summary>
  /// <param name="Chat">
  /// The <c>TChat</c> object containing the current information about the response generated by the model.
  /// If this value is <c>nil</c>, it indicates that the data stream is complete.
  /// </param>
  /// <param name="IsDone">
  /// A boolean flag indicating whether the streaming process is complete.
  /// If <c>True</c>, it means the model has finished sending all response data.
  /// </param>
  /// <param name="Cancel">
  /// A boolean flag that can be set to <c>True</c> within the callback to cancel the streaming process.
  /// If set to <c>True</c>, the streaming will be terminated immediately.
  /// </param>
  /// <remarks>
  /// This callback is invoked multiple times during the reception of the response data from the model.
  /// It allows for real-time processing of received messages and interaction with the user interface or other systems
  /// based on the state of the data stream.
  /// When the <c>IsDone</c> parameter is <c>True</c>, it indicates that the model has finished responding,
  /// and the <c>Chat</c> parameter will be <c>nil</c>.
  /// </remarks>
  TChatEvent = Anthropic.Chat.TChatEvent;

{$ENDREGION}

{$REGION 'Anthropic.Batches'}

  /// <summary>
  /// The <c>TBatcheParams</c> class is used to manage and define parameters for a batch of messages.
  /// It provides methods to customize the batch with specific identifiers and additional parameters.
  /// </summary>
  TBatcheParams = Anthropic.Batches.TBatcheParams;

  /// <summary>
  /// The <c>TRequestParams</c> class is used to manage and define request parameters for sending message batches.
  /// It allows you to specify multiple batch requests as part of a single request operation.
  /// </summary>
  TRequestParams = Anthropic.Batches.TRequestParams;

  /// <summary>
  /// The <c>TRequestCounts</c> class represents the counts of different statuses related to batch processing.
  /// It tracks the number of batches that are currently being processed, successfully completed, errored, canceled, and expired.
  /// </summary>
  /// <remarks>
  /// This class provides an overview of the state of batch processing by categorizing the results into several status types,
  /// helping to monitor the success and failure rates of batch operations.
  /// </remarks>
  TRequestCounts = Anthropic.Batches.TRequestCounts;

  /// <summary>
  /// The <c>TBatche</c> class represents a batch of messages in the system.
  /// It contains detailed information about the batch, including its processing status, request counts, timestamps, and related URLs.
  /// </summary>
  /// <remarks>
  /// This class provides key details for managing and tracking a batch of messages, such as the batch's unique identifier,
  /// its current state (in progress, canceled, or ended), and related metadata. It is essential for operations that involve handling
  /// message batches in a structured and organized manner.
  /// </remarks>
  TBatche = Anthropic.Batches.TBatche;

  /// <summary>
  /// The <c>TBatcheList</c> class represents a collection of batch objects, along with metadata about the batch list.
  /// It includes information about whether there are more batches to be fetched and provides identifiers for pagination purposes.
  /// </summary>
  /// <remarks>
  /// This class is used to handle lists of batches returned from the API, enabling pagination through the first and last batch identifiers
  /// and indicating whether additional batches are available beyond the current list.
  /// </remarks>
  TBatcheList = Anthropic.Batches.TBatcheList;

  /// <summary>
  /// The <c>TBatchDelete</c> class represents a batch deletion operation.
  /// It provides information about the identifier and type of the batch being deleted.
  /// </summary>
  /// <remarks>
  /// This class is used to manage the deletion of batches, enabling the application
  /// to track which batch is being removed from the system. It encapsulates the batch
  /// identifier and type information necessary for deletion requests.
  /// </remarks>
  TBatchDelete = Anthropic.Batches.TBatchDelete;

  /// <summary>
  /// The <c>TListParams</c> class is used to define parameters for retrieving lists of batches.
  /// It allows for pagination by setting limits, specifying batch IDs to start after, or ending before.
  /// </summary>
  /// <remarks>
  /// This class helps in controlling the number of results returned in list queries and enables efficient data navigation
  /// through the use of pagination parameters such as <c>Limit</c>, <c>AfterId</c>, and <c>BeforeId</c>.
  /// <para>
  /// <b>--- Warning:</b> The parameters <c>AfterId</c> and <c>BeforeId</c> are mutually exclusive, meaning that both cannot be used simultaneously
  /// in a single query. Ensure that only one of these parameters is set at a time to avoid conflicts.
  /// </para>
  /// </remarks>
  TListParams = Anthropic.Batches.TListParams;

  /// <summary>
  /// The <c>TAsynBatche</c> class is a type alias used to handle asynchronous callbacks for batch processing.
  /// It provides support for executing batch operations asynchronously and processing the results upon completion.
  /// </summary>
  /// <remarks>
  /// This class is part of the asynchronous framework that allows non-blocking batch operations.
  /// It uses a callback mechanism to return the result of a batch process once it is completed.
  /// </remarks>
  TAsynBatche = Anthropic.Batches.TAsynBatche;

  /// <summary>
  /// The <c>TAsynBatcheList</c> class represents an asynchronous callback for handling operations that return a list of batch objects (<c>TBatcheList</c>).
  /// It is used to manage asynchronous processes where a list of batches is retrieved, processed, or manipulated.
  /// </summary>
  /// <remarks>
  /// This class is typically employed in scenarios where batch lists need to be fetched or processed asynchronously, allowing for
  /// non-blocking execution and handling of potentially large sets of batch data.
  /// </remarks>
  TAsynBatcheList = Anthropic.Batches.TAsynBatcheList;

  /// <summary>
  /// The <c>TAsynStringList</c> class is a callback handler for asynchronous operations that return a <c>TStringList</c> result.
  /// It is used to process string list data asynchronously, such as retrieving batch results from the API.
  /// </summary>
  /// <remarks>
  /// This class allows for non-blocking operations where a <c>TStringList</c> is returned, enabling efficient handling of large datasets or long-running tasks.
  /// The callback mechanism helps in managing success, error handling, and overall execution flow.
  /// </remarks>
  TAsynStringList = Anthropic.Batches.TAsynStringList;

  /// <summary>
  /// The <c>TAsynBatchDelete</c> class is a callback handler for asynchronous operations that return a <c>TStringList</c> result.
  /// It is used to process string list data asynchronously, such as retrieving batch results from the API.
  /// </summary>
  /// <remarks>
  /// This class allows for non-blocking operations where a <c>TBatchDelete</c> is returned, enabling efficient handling of large datasets or long-running tasks.
  /// The callback mechanism helps in managing success, error handling, and overall execution flow.
  /// </remarks>
  TAsynBatchDelete = Anthropic.Batches.TAsynBatchDelete;

{$ENDREGION}

{$REGION 'Anthropic.Batches.Support'}

  /// <summary>
  /// Provides an interface for managing batch results and associated file information.
  /// </summary>
  /// <remarks>
  /// The IBatcheResults interface allows for the retrieval of batch result items
  /// and management of the file from which these results are loaded. It ensures
  /// that the specified file exists before loading and provides access to individual
  /// batch results through the Batches property.
  /// </remarks>
  IBatcheResults = Anthropic.Batches.Support.IBatcheResults;

  /// <summary>
  /// Factory class responsible for creating instances of <see cref="IBatcheResults"/>.
  /// </summary>
  /// <remarks>
  /// The <c>TBatcheResultsFactory</c> provides a centralized way to instantiate <c>IBatcheResults</c>
  /// objects, optionally initializing them with a specified file. This ensures that all
  /// instances are created consistently throughout the application.
  /// </remarks>
  TBatcheResultsFactory = Anthropic.Batches.Support.TBatcheResultsFactory;

  /// <summary>
  /// Represents an individual item within a batch result.
  /// </summary>
  /// <remarks>
  /// The <c>TBatcheResultItem</c> class encapsulates a single result item from a batch operation,
  /// including a custom identifier and the corresponding batch result.
  /// </remarks>
  TBatcheResultItem = Anthropic.Batches.Support.TBatcheResultItem;

  /// <summary>
  /// Represents the result of a single batch operation.
  /// </summary>
  /// <remarks>
  /// The <c>TBatcheResult</c> class contains detailed information about the outcome of a batch request,
  /// including the type of result and the associated chat message.
  /// </remarks>
  TBatcheResult = Anthropic.Batches.Support.TBatcheResult;

{$ENDREGION}

{$REGION 'Anthropic.Models'}

  /// <summary>
  /// The <c>TListModelsParams</c> class is used to define parameters for retrieving lists of models.
  /// It allows for pagination by setting limits, specifying model IDs to start after, or ending before.
  /// </summary>
  /// <remarks>
  /// This class helps in controlling the number of results returned in list queries and enables efficient data navigation
  /// through the use of pagination parameters such as <c>Limit</c>, <c>AfterId</c>, and <c>BeforeId</c>.
  /// <para>
  /// <b>--- Warning:</b> The parameters <c>AfterId</c> and <c>BeforeId</c> are mutually exclusive, meaning that both cannot be used simultaneously
  /// in a single query. Ensure that only one of these parameters is set at a time to avoid conflicts.
  /// </para>
  /// </remarks>
  TListModelsParams = Anthropic.Models.TListModelsParams;

  /// <summary>
  /// The <c>TModel</c> class represents a single model entity within the Anthropic API.
  /// It provides access to details about the model, including its unique identifier,
  /// type, human-readable name, and creation timestamp.
  /// </summary>
  /// <remarks>
  /// This class is used to encapsulate the metadata associated with a model.
  /// It is designed to be serialized and deserialized from JSON format
  /// when interacting with the Anthropic API endpoints.
  /// <para>
  /// The <c>Type</c> property will always return the value "model" for instances
  /// of this class. The <c>Id</c> property uniquely identifies the model, while
  /// the <c>DisplayName</c> property provides a human-readable description of the model.
  /// The <c>CreatedAt</c> property indicates when the model was released or first made available.
  /// </para>
  /// </remarks>
  TModel = Anthropic.Models.TModel;

  /// <summary>
  /// The <c>TModels</c> class represents a collection of model entities retrieved from the Anthropic API.
  /// It encapsulates the list of models and additional metadata for pagination purposes.
  /// </summary>
  /// <remarks>
  /// This class is designed to manage and store a list of <c>TModel</c> objects, along with
  /// information to facilitate navigation through paginated results.
  /// <para>
  /// The <c>Data</c> property contains the array of models retrieved in the current query.
  /// The <c>HasMore</c> property indicates whether there are additional results beyond the current page.
  /// The <c>FirstId</c> and <c>LastId</c> properties provide cursors for navigating to the previous
  /// and next pages of results, respectively.
  /// </para>
  /// <para>
  /// When an instance of this class is destroyed, it ensures proper memory cleanup
  /// by freeing the individual <c>TModel</c> objects in the <c>Data</c> array.
  /// </para>
  /// </remarks>
  TModels = Anthropic.Models.TModels;

  /// <summary>
  /// The <c>TAsynModel</c> class is a type alias used to handle asynchronous callbacks for batch processing.
  /// It provides support for executing batch operations asynchronously and processing the results upon completion.
  /// </summary>
  /// <remarks>
  /// This class is part of the asynchronous framework that allows non-blocking batch operations.
  /// It uses a callback mechanism to return the result of a batch process once it is completed.
  /// </remarks>
  TAsynModel = Anthropic.Models.TAsynModel;

  /// <summary>
  /// The <c>TAsynModels</c> class is a type alias used to handle asynchronous callbacks for batch processing.
  /// It provides support for executing batch operations asynchronously and processing the results upon completion.
  /// </summary>
  /// <remarks>
  /// This class is part of the asynchronous framework that allows non-blocking batch operations.
  /// It uses a callback mechanism to return the result of a batch process once it is completed.
  /// </remarks>
  TAsynModels = Anthropic.Models.TAsynModels;

{$ENDREGION}

{$REGION 'Anthropic.Functions.Core'}

  /// <summary>
  /// Interface defining the core structure and functionality of a function in the system.
  /// </summary>
  /// <remarks>
  /// This interface outlines the basic properties and methods that any function implementation must include.
  /// </remarks>
  IFunctionCore = Anthropic.Functions.Core.IFunctionCore;

  /// <summary>
  /// Abstract base class for implementing core function behavior.
  /// </summary>
  /// <remarks>
  /// This class provides basic implementations for some methods and defines the structure that derived classes must follow.
  /// </remarks>
  TFunctionCore = Anthropic.Functions.Core.TFunctionCore;

{$ENDREGION}

{$REGION 'Anthropic.Schema'}

  /// <summary>
  /// Provides helper methods for creating property items in OpenAPI schema definitions.
  /// </summary>
  /// <remarks>
  /// This record simplifies the creation of property entries when building schema objects,
  /// particularly for object properties in OpenAPI specifications.
  /// </remarks>
  TPropertyItem = Anthropic.Schema.TPropertyItem;

  /// <summary>
  /// Represents the Schema Object in OpenAPI, enabling the definition of input and output data types.
  /// These types can be objects, primitives, or arrays. This class provides methods to build and
  /// configure schema definitions as per the OpenAPI 3.0 Specification.
  /// </summary>
  /// <remarks>
  /// The Schema Object allows the definition of input and output data types in the OpenAPI Specification.
  /// This class provides a fluent interface to construct schema definitions programmatically.
  /// </remarks>
  TSchemaParams = Anthropic.Schema.TSchemaParams;

{$ENDREGION}

function fromAssistant(const Value: string): Payload;
function FromPdf(const Value: string; const Documents: TArray<string>;
  CacheControl: Boolean = False): Payload; overload;
function FromPdf(const Value: string; const Documents: string;
  CacheControl: Boolean = False): Payload; overload;
function fromUser(const Value: string; CacheControl: Boolean = False): Payload; overload;
function fromUser(const Value: string; const Images: TArray<string>;
  CacheControl: Boolean = False): Payload; overload;
function fromUser(const Value: string; const Image: string;
  CacheControl: Boolean = False): Payload; overload;

implementation

const
  batches = 1;
  caching = 2;

function fromAssistant(const Value: string): Payload;
begin
  Result := TChatMessagePayload.Assistant(Value);
end;

function FromPdf(const Value: string; const Documents: TArray<string>;
  CacheControl: Boolean = False): Payload;
begin
  Result := TChatMessagePayload.Pdf(Value, Documents, CacheControl);
end;

function FromPdf(const Value: string; const Documents: string;
  CacheControl: Boolean = False): Payload; overload;
begin
  Result := TChatMessagePayload.Pdf(Value, [Documents], CacheControl);
end;

function fromUser(const Value: string; CacheControl: Boolean = False): Payload;
begin
  Result := TChatMessagePayload.User(Value, CacheControl);
end;

function fromUser(const Value: string; const Images: TArray<string>;
  CacheControl: Boolean = False): Payload;
begin
  Result := TChatMessagePayload.User(Value, Images, CacheControl);
end;

function fromUser(const Value: string; const Image: string;
  CacheControl: Boolean = False): Payload; overload;
begin
  Result := TChatMessagePayload.User(Value, [Image], CacheControl);
end;

{ TAnthropic }

constructor TAnthropic.Create(const Option: Integer);
begin
  inherited Create;
  FAPI := TAnthropicAPI.Create(Option);
end;

constructor TAnthropic.Create(const AToken: string; const Option: Integer);
begin
  Create(Option);
  Token := AToken;
end;

destructor TAnthropic.Destroy;
begin
  FChatRoute.Free;
  FBatcheRoute.Free;
  FModelsRoute.Free;
  FAPI.Free;
  inherited;
end;

function TAnthropic.GetAPI: TAnthropicAPI;
begin
  Result := FAPI;
end;

function TAnthropic.GetBaseUrl: string;
begin
  Result := FAPI.BaseURL;
end;

function TAnthropic.GetBatcheRoute: TBatcheRoute;
begin
  if not Assigned(FBatcheRoute) then
    FBatcheRoute := TBatcheRoute.CreateRoute(API);
  Result := FBatcheRoute;
end;

function TAnthropic.GetChatRoute: TChatRoute;
begin
  if not Assigned(FChatRoute) then
    FChatRoute := TChatRoute.CreateRoute(API);
  Result := FChatRoute;
end;

function TAnthropic.GetModelsRoute: TModelsRoute;
begin
  if not Assigned(FModelsRoute) then
    FModelsRoute := TModelsRoute.CreateRoute(API);
  Result := FModelsRoute;
end;

function TAnthropic.GetToken: string;
begin
  Result := FAPI.Token;
end;

procedure TAnthropic.SetBaseUrl(const Value: string);
begin
  FAPI.BaseURL := Value;
end;

procedure TAnthropic.SetToken(const Value: string);
begin
  FAPI.Token := Value;
end;

{ TAnthropicFactory }

class function TAnthropicFactory.CreateBatchingInstance(
  const AToken: string): IAnthropic;
begin
  Result := CreateInstance(AToken, batches);
end;

class function TAnthropicFactory.CreateCachingInstance(
  const AToken: string): IAnthropic;
begin
  Result := CreateInstance(AToken, caching);
end;

class function TAnthropicFactory.CreateInstance(const AToken: string;
  const Option: Integer): IAnthropic;
begin
  Result := TAnthropic.Create(AToken, Option);
end;

end.

unit Anthropic.Schema;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiAnthropic
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, REST.Json.Types,
  Anthropic.API.Params, Anthropic.Types;

type
  TSchemaParams = class;

  /// <summary>
  /// Provides helper methods for creating property items in OpenAPI schema definitions.
  /// </summary>
  /// <remarks>
  /// This record simplifies the creation of property entries when building schema objects,
  /// particularly for object properties in OpenAPI specifications.
  /// </remarks>
  TPropertyItem = record
  public
    /// <summary>
    /// Creates a JSON pair representing a property in a schema object.
    /// </summary>
    /// <param name="Key">The name of the property.</param>
    /// <param name="Value">The data type of the property as a <c>TSchemaType</c>.</param>
    /// <returns>A <c>TJSONPair</c> representing the property key-value pair.</returns>
    /// <remarks>
    /// This method facilitates the addition of properties to schema objects by creating
    /// a JSON pair with the specified key and data type.
    /// </remarks>
    class function Add(Key: string; Value: TSchemaType): TJSONPair; static;
  end;

  /// <summary>
  /// Represents the Schema Object in OpenAPI, enabling the definition of input and output data types.
  /// These types can be objects, primitives, or arrays. This class provides methods to build and
  /// configure schema definitions as per the OpenAPI 3.0 Specification.
  /// </summary>
  /// <remarks>
  /// The Schema Object allows the definition of input and output data types in the OpenAPI Specification.
  /// This class provides a fluent interface to construct schema definitions programmatically.
  /// </remarks>
  TSchemaParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the data type of the schema.
    /// </summary>
    /// <param name="Value">The data type to assign to the schema, specified as a <c>TSchemaType</c> value.</param>
    /// <returns>The current <c>TSchemaParams</c> instance to allow for method chaining.</returns>
    /// <remarks>
    /// The <c>type</c> keyword is required in the Schema Object to define the data type.
    /// Valid types include <c>string</c>, <c>number</c>, <c>integer</c>, <c>boolean</c>, <c>array</c>, and <c>object</c>.
    /// </remarks>
    function &Type(const Value: TSchemaType): TSchemaParams;
    /// <summary>
    /// Specifies the format of the data type.
    /// </summary>
    /// <param name="Value">The format of the data type, as a string.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>format</c> keyword is an optional modifier to provide more fine-grained data type information.
    /// Common formats include <c>int32</c>, <c>int64</c> for <c>integer</c> types; <c>float</c>, <c>double</c>
    /// for <c>number</c> types; and <c>byte</c>, <c>binary</c>, <c>date</c>, <c>date-time</c>, <c>password</c> for <c>string</c> types.
    /// </remarks>
    function Format(const Value: string): TSchemaParams;
    /// <summary>
    /// Adds a description to the schema.
    /// </summary>
    /// <param name="Value">A brief description of the schema. Supports Markdown for formatting.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>description</c> keyword provides a description of the schema and can include examples of use.
    /// This field supports Markdown syntax for rich text representation.
    /// </remarks>
    function Description(const Value: string): TSchemaParams;
    /// <summary>
    /// Specifies whether the schema's value can be null.
    /// </summary>
    /// <param name="Value">A boolean indicating if the schema allows null values.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>nullable</c> keyword is a boolean property that indicates if the value of the schema can be null.
    /// By default, this is false.
    /// </remarks>
    function Nullable(const Value: Boolean): TSchemaParams;
    /// <summary>
    /// Specifies an enumeration of possible values.
    /// </summary>
    /// <param name="Value">An array of string values that the schema can take.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>enum</c> keyword restricts the value of the schema to a fixed set of values.
    /// The schema's type must be <c>string</c> when using enum.
    /// </remarks>
    function Enum(const Value: TArray<string>): TSchemaParams;
    /// <summary>
    /// Specifies the maximum number of items allowed in an array schema.
    /// </summary>
    /// <param name="Value">The maximum number of items as a string.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>maxItems</c> keyword applies to schemas of type <c>array</c> and restricts the maximum number
    /// of items the array can contain.
    /// </remarks>
    function MaxItems(const Value: string): TSchemaParams;
    /// <summary>
    /// Specifies the minimum number of items required in an array schema.
    /// </summary>
    /// <param name="Value">The minimum number of items as a string.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>minItems</c> keyword applies to schemas of type <c>array</c> and defines the minimum number
    /// of items the array must contain.
    /// </remarks>
    function MinItems(const Value: string): TSchemaParams;
    /// <summary>
    /// Adds a property to an object schema.
    /// </summary>
    /// <param name="Key">The name of the property.</param>
    /// <param name="Value">A <c>TSchemaParams</c> instance defining the property's schema.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>properties</c> keyword is used to define the properties of an object schema.
    /// Each property is a key-value pair where the key is the property name and the value is a schema defining the property.
    /// </remarks>
    function Properties(const Key: string; const Value: TSchemaParams): TSchemaParams; overload;
    /// <summary>
    /// Adds a property to an object schema using a parameterized procedure to configure the property's schema.
    /// </summary>
    /// <param name="Key">The name of the property.</param>
    /// <param name="ParamProc">A procedure that takes a <c>TSchemaParams</c> instance to configure the property's schema.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// This overload allows you to define the property's schema inline using a procedural configuration.
    /// </remarks>
    function Properties(const Key: string; const ParamProc: TProcRef<TSchemaParams>): TSchemaParams; overload;
    /// <summary>
    /// Adds multiple properties to an object schema.
    /// </summary>
    /// <param name="Value">An array of <c>TJSONPair</c> instances representing the properties.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// This overload allows adding multiple properties at once to the object schema.
    /// </remarks>
    function Properties(const Value: TArray<TJSONPair>): TSchemaParams; overload;
    /// <summary>
    /// Specifies which properties are required in an object schema.
    /// </summary>
    /// <param name="Value">An array of property names that are required.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>required</c> keyword lists the property names that must be included when an object instance
    /// is validated against the schema.
    /// </remarks>
    function Required(const Value: TArray<string>): TSchemaParams;
    /// <summary>
    /// Specifies the schema of the items in an array schema.
    /// </summary>
    /// <param name="Value">A <c>TSchemaParams</c> instance defining the schema of the array items.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>items</c> keyword is used in array schemas to define the schema of each item in the array.
    /// </remarks>
    function Items(const Value: TSchemaParams): TSchemaParams; overload;
    /// <summary>
    /// Specifies the schema of the items in an array schema using a parameterized procedure.
    /// </summary>
    /// <param name="ParamProc">A procedure that configures a <c>TSchemaParams</c> instance to define the array items' schema.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// This overload allows you to define the items' schema inline using a procedural configuration.
    /// </remarks>
    function Items(const ParamProc: TProcRef<TSchemaParams>): TSchemaParams; overload;
    /// <summary>
    /// Creates a new instance of <c>TSchemaParams</c>.
    /// </summary>
    /// <returns>A new <c>TSchemaParams</c> instance.</returns>
    class function New: TSchemaParams; overload;
    /// <summary>
    /// Creates and configures a new instance of <c>TSchemaParams</c> using a parameterized procedure.
    /// </summary>
    /// <param name="ParamProc">A procedure that configures the new <c>TSchemaParams</c> instance.</param>
    /// <returns>A new <c>TSchemaParams</c> instance.</returns>
    /// <remarks>
    /// This overload allows you to create and configure the instance inline.
    /// </remarks>
    class function New(const ParamProc: TProcRef<TSchemaParams>): TSchemaParams; overload;
  end;

implementation

uses
  System.StrUtils, System.Rtti, Rest.Json;

{ TSchemaParams }

function TSchemaParams.Description(const Value: string): TSchemaParams;
begin
  Result := TSchemaParams(Add('description', Value));
end;

function TSchemaParams.Enum(const Value: TArray<string>): TSchemaParams;
begin
  Result := TSchemaParams(Add('enum', Value));
end;

function TSchemaParams.Format(const Value: string): TSchemaParams;
begin
  Result := TSchemaParams(Add('format', Value));
end;

function TSchemaParams.Items(
  const ParamProc: TProcRef<TSchemaParams>): TSchemaParams;
begin
  if Assigned(ParamProc) then
    begin
      var Value := TSchemaParams.Create;
      ParamProc(Value);
      Result := Items(Value);
    end
  else Result := Self;
end;

function TSchemaParams.Items(const Value: TSchemaParams): TSchemaParams;
begin
  Result := TSchemaParams(Add('items', Value.Detach));
end;

function TSchemaParams.MaxItems(const Value: string): TSchemaParams;
begin
  Result := TSchemaParams(Add('maxItems', Value));
end;

function TSchemaParams.MinItems(const Value: string): TSchemaParams;
begin
  Result := TSchemaParams(Add('minItems', Value));
end;

class function TSchemaParams.New: TSchemaParams;
begin
  Result := TSchemaParams.Create;
end;

class function TSchemaParams.New(
  const ParamProc: TProcRef<TSchemaParams>): TSchemaParams;
begin
  Result := TSchemaParams.Create;
  if Assigned(ParamProc) then
    begin
      ParamProc(Result);
    end;
end;

function TSchemaParams.Nullable(const Value: Boolean): TSchemaParams;
begin
  Result := TSchemaParams(Add('nullable', Value.ToString));
end;

function TSchemaParams.Properties(
  const Value: TArray<TJSONPair>): TSchemaParams;
begin
  var JSONValue := TJSONObject.Create;
  for var Item in Value do
    begin
      JSONValue.AddPair(Item);
    end;
  Result := TSchemaParams(Add('properties', JSONValue));
end;

function TSchemaParams.Properties(const Key: string;
  const ParamProc: TProcRef<TSchemaParams>): TSchemaParams;
begin
  if Assigned(ParamProc) then
    begin
      var Value := TSchemaParams.Create;
      ParamProc(Value);
      Result := Properties(Key, Value);
    end
  else Result := Self;
end;

function TSchemaParams.Properties(const Key: string;
  const Value: TSchemaParams): TSchemaParams;
begin
  Result := TSchemaParams(Add(Key, Value.Detach));
end;

function TSchemaParams.Required(const Value: TArray<string>): TSchemaParams;
begin
  Result := TSchemaParams(Add('required', Value));
end;

function TSchemaParams.&Type(const Value: TSchemaType): TSchemaParams;
begin
  Result := TSchemaParams(Add('type', Value.ToString));
end;

{ TPropertyItem }

class function TPropertyItem.Add(Key: string; Value: TSchemaType): TJSONPair;
begin
  Result := TJSONPair.Create(Key, Value.ToString);
end;

end.

unit Anthropic.Stream.API;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiAnthropic
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, Rest.Json, REST.JsonReflect, System.JSON, REST.Json.Types;

type
  /// <summary>
  /// Enumerates the possible categories for received messages in a chunked process.
  /// </summary>
  /// <remarks>
  /// This type categorizes incoming messages that are part of a chunked process, where messages and content blocks are sent in multiple parts (chunks).
  /// It helps identify the different stages or types of chunks, such as the start of a message, a delta update, or the end of a message.
  /// </remarks>
  TBlockType = (
    /// <summary>
    /// Indicates that the chunk does not match any expected patterns or models in the chunked process.
    /// </summary>
    btNone,
    /// <summary>
    /// Represents that the chunked message or event has finished, signaling the end of the chunked process.
    /// </summary>
    btDone,
    /// <summary>
    /// Represents a chunk that updates or modifies an existing content block, typically a partial or incremental update.
    /// </summary>
    btBlockDelta,
    /// <summary>
    /// Marks the beginning of a new chunked message in the process.
    /// </summary>
    btMessageStart,
    /// <summary>
    /// Represents an incremental update (delta) to a chunked message in progress.
    /// </summary>
    btMessageDelta,
    /// <summary>
    /// Marks the beginning of a new content block in the chunked process, where content is split into smaller chunks.
    /// </summary>
    btBlockStart);

  /// <summary>
  /// The response content made by a tool.
  /// </summary>
  TTool = record
  private
    FId: string;
    FName: string;
    FInput: string;
  public
    /// <summary>
    /// Id provided by the LLM
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Arguments returned by the LLM, these arguments will have to be used to construct the final answer.
    /// </summary>
    property Input: string read FInput write FInput;
    /// <summary>
    /// Name of the tool identified by the LLM
    /// </summary>
    property Name: string read FName write FName;
  end;

  /// <summary>
  /// Represents the token usage statistics for a chat interaction, including the number of tokens
  /// used in the prompt, the completion, and the total number of tokens consumed.
  /// </summary>
  /// <remarks>
  /// The <c>TMessageUsage</c> class provides insight into the number of tokens used during a chat interaction.
  /// This information is critical for understanding the cost of a request when using token-based billing systems
  /// or for monitoring the model's behavior in terms of input (prompt) and output (completion) size.
  /// </remarks>
  TUsage = record
  private
    FInputTokens: Int64;
    FCacheCreationInputTokens: Int64;
    FCacheReadInputTokens: Int64;
    FOutputTokens: Int64;
  public
    /// <summary>
    /// The number of input tokens which were used.
    /// </summary>
    property InputTokens: Int64 read FInputTokens write FInputTokens;
    /// <summary>
    /// (prompt caching beta) The number of input tokens used to create the cache entry.
    /// </summary>
    property CacheCreationInputTokens: Int64 read FCacheCreationInputTokens write FCacheCreationInputTokens;
    /// <summary>
    /// (prompt caching beta) The number of input tokens read from the cache.
    /// </summary>
    property CacheReadInputTokens: Int64 read FCacheReadInputTokens write FCacheReadInputTokens;
    /// <summary>
    /// The number of output tokens which were used.
    /// </summary>
    property OutputTokens: Int64 read FOutputTokens write FOutputTokens;
  end;

  /// <summary>
  /// Record that provides tools for processing received message blocks in a chunked process.
  /// </summary>
  /// <remarks>
  /// The TDelta record encapsulates methods and properties to handle different types of blocks (chunks) such as message starts, deltas, and block starts.
  /// It also includes utility functions for determining the type of block and converting the block data to a string.
  /// </remarks>
  TDelta = record
  private
    /// <summary>
    /// Stores the template or structure of the message being processed.
    /// </summary>
    /// <remarks>
    /// The value is retrieved during a "messageStart", then this value is kept throughout the chunked process
    /// </remarks>
    FMessagePattern: string;
    /// <summary>
    /// Obtained value that can be formatted with FMessagePattern if necessary.
    /// </summary>
    /// <remarks>
    /// This value is used by the ToString function to return a result.
    /// </remarks>
    FValue: string;
    /// <summary>
    /// Record including tool data if tool_use was detected.
    /// </summary>
    FTool: TTool;
    /// <summary>
    /// Contains usage statistics or metadata related to the message block.
    /// </summary>
    FUsage: TUsage;
  public
    /// <summary>
    /// Processes a block delta, which is an update or modification to an existing block of data.
    /// </summary>
    /// <param name="Data">The raw data representing the block delta.</param>
    /// <returns>A new instance of TDelta with the processed block delta.</returns>
    function BlockDelta(const Data: string): TDelta;
    /// <summary>
    /// Processes the start of a new message block in the chunked process.
    /// </summary>
    /// <param name="Data">The raw data representing the start of a message.</param>
    /// <returns>A new instance of TDelta for the message start.</returns>
    function MessageStart(Data: string): TDelta;
    /// <summary>
    /// Processes an incremental update (delta) to an ongoing message.
    /// </summary>
    /// <param name="Data">The raw data representing the message delta.</param>
    /// <returns>A new instance of TDelta with the processed message delta.</returns>
    function MessageDelta(const Data: string): TDelta;
    /// <summary>
    /// Processes the start of a new content block in the chunked process.
    /// </summary>
    /// <param name="Data">The raw data representing the start of the content block.</param>
    /// <returns>A new instance of TDelta with the processed block start.</returns>
    function BlockStart(const Data: string): TDelta;
    /// <summary>
    /// Determines the type of block based on the provided line of data.
    /// </summary>
    /// <param name="Line">The raw line of data to analyze.</param>
    /// <returns>A TBlockType value representing the type of block.</returns>
    class function BlockType(const Line: string): TBlockType; static;
    /// <summary>
    /// Converts the message block to a formatted or unformatted string representation.
    /// </summary>
    /// <param name="IsFormated">Specifies whether the string should be formatted (True) or unformatted (False).</param>
    /// <returns>A string representation of the message block.</returns>
    function ToString(IsFormated: Boolean = True): string;
  end;

  /// <summary>
  /// Represents the token usage statistics for a chat interaction, including the number of tokens
  /// used in the prompt, the completion, and the total number of tokens consumed.
  /// </summary>
  /// <remarks>
  /// The <c>TMessageUsage</c> class provides insight into the number of tokens used during a chat interaction.
  /// This information is critical for understanding the cost of a request when using token-based billing systems
  /// or for monitoring the model's behavior in terms of input (prompt) and output (completion) size.
  /// </remarks>
  TMessageUsage = class
  private
    [JsonNameAttribute('input_tokens')]
    FInputTokens: Int64;
    [JsonNameAttribute('cache_creation_input_tokens')]
    FCacheCreationInputTokens: Int64;
    [JsonNameAttribute('cache_read_input_tokens')]
    FCacheReadInputTokens: Int64;
    [JsonNameAttribute('output_tokens')]
    FOutputTokens: Int64;
  public
    /// <summary>
    /// The number of input tokens which were used.
    /// </summary>
    property InputTokens: Int64 read FInputTokens write FInputTokens;
    /// <summary>
    /// (prompt caching beta) The number of input tokens used to create the cache entry.
    /// </summary>
    property CacheCreationInputTokens: Int64 read FCacheCreationInputTokens write FCacheCreationInputTokens;
    /// <summary>
    /// (prompt caching beta) The number of input tokens read from the cache.
    /// </summary>
    property CacheReadInputTokens: Int64 read FCacheReadInputTokens write FCacheReadInputTokens;
    /// <summary>
    /// The number of output tokens which were used.
    /// </summary>
    property OutputTokens: Int64 read FOutputTokens write FOutputTokens;
  end;

  TMessageContent = class
  private
    FId: string;
    FType: string;
    FRole: string;
    FModel: string;
    [JsonNameAttribute('stop_sequence')]
    FStopSequence: string;
    [JsonNameAttribute('stop_reason')]
    FStopReason: string;
    FContent: TArray<string>;
    FUsage: TMessageUsage;
  public
    property Id: string read FId write FId;
    property &Type: string read FType write FType;
    property Role: string read FRole write FRole;
    property Model: string read FModel write FModel;
    property StopSequence: string read FStopSequence write FStopSequence;
    property StopReason: string read FStopReason write FStopReason;
    property Content: TArray<string> read FContent write FContent;
    property Usage: TMessageUsage read FUsage write FUsage;
    destructor Destroy; override;
  end;

  TMessageStart = class
  private
    FType: string;
    FMessage: TMessageContent;
  public
    property &Type: string read FType write FType;
    property Message: TMessageContent read FMessage write FMessage;
    destructor Destroy; override;
  end;

  TDeltaContent = class
  private
    FType: string;
    FText: string;
    [JsonNameAttribute('partial_json')]
    FArgument: string;
  public
    property &Type: string read FType write FType;
    property Text: string read FText write FText;
    property Argument: string read FArgument write FArgument;
  end;

  TDeltaMessage = class
  private
    FType: string;
    FIndex: int64;
    FDelta: TDeltaContent;
  public
    property &Type: string read FType write FType;
    property &Index: int64 read FIndex write FIndex;
    property Delta: TDeltaContent read FDelta write FDelta;
    destructor Destroy; override;
  end;

  TContentBlock = class
  private
    FType: string;
    FId: string;
    FName: string;
    FInput: string;
  public
    property &Type: string read FType write FType;
    property Id: string read FId write FId;
    property Name: string read FName write FName;
    property Input: string read FInput write FInput;
  end;

  TBlockStart = class
  private
    FType: string;
    FIndex: int64;
    [JsonNameAttribute('content_block')]
    FContentBlock: TContentBlock;
  public
    property &Type: string read FType write FType;
    property &Index: int64 read FIndex write FIndex;
    property ContentBlock: TContentBlock read FContentBlock write FContentBlock;
    destructor Destroy; override;
  end;

implementation

const
  EMPTY_DELTA =
    '"delta":{"type":"text_delta","text":""}';
  DELTA_PARTIAL_FMT =
    '"delta":{"type":"%s","partial_json":"%s","id":"%s","name":"%s"}';
  DELTA_FMT =
    '"delta":{"type":"%s","text":"%s"}';
  USAGE_FMT =
    '"usage":{"input_tokens":%d,"cache_creation_input_tokens":%d,"cache_read_input_tokens":%d,"output_tokens":%d}';

type
  TDataHelper = class
    class function KeyToStr(const Key: string): string;
    class function ToolUsed: string;
  end;

resourcestring
  StringStartException = 'The string must start with the character ''{'' without exception.';
  InvalidJSONException = 'The JSON string is not valid.';

function ToEnd(const Value: string): Integer;
begin
  if Value[1] <> '{' then
    raise Exception.Create(StringStartException);
  Result := 2;
  var K := 1;
  while K > 0 do
    begin
      case Value[Result] of
        '{':
          Inc(k);
        '}':
          begin
            Dec(K);
            if k = 0 then
              Exit(Result);
          end;
      end;
      Inc(Result);
      if (Result > Value.Length) and (k > 0) then
        raise Exception.Create(InvalidJSONException);
    end;
end;

function ExtractJSONPair(Value: string; Key: string; ToObject: Boolean): string;
begin
  Key := Format('"%s":', [Key]);
  var Start := Value.IndexOf(Key) + Key.Length;
  Result :=  Value.Substring(Start).Trim;
  Result := Result.Trim.Substring(0, ToEnd(Result.Trim));
  if not ToObject then
    Result := Result.Substring(1, Result.Length - 2);
end;

function ToKeyStop(const Value: string): Integer;
begin
  if Value[1] <> '{' then
    begin
      var ComaPos :=  Value.IndexOf(',');
      if ComaPos > 0 then
        Exit( ComaPos + 1 ) else
        Exit( ComaPos );
    end;
  Result := ToEnd(Value);
  if Value[Result + 1] = ',' then
    Result := Result + 1;
end;

function DeleteJSONPair(Value: string; Key: string): string;
begin
  Key := Format('"%s":', [Key]);
  var StartPos := Value.IndexOf(Key);
  var Buffer := Value.Substring(StartPos + Key.Length);
  var L := StartPos + Key.Length + ToKeyStop(Buffer);
  Result := Value.Substring(0, StartPos) + Value.Substring(L);
end;

{ TDeltaMessage }

destructor TDeltaMessage.Destroy;
begin
  if Assigned(FDelta) then
    FDelta.Free;
  inherited;
end;

{ TDelta }

function TDelta.BlockDelta(const Data: string): TDelta;
begin
  {--- Retrieving the values of DeltaMessage from 'data' through the reflection process }
  var Block := TJson.JsonToObject<TDeltaMessage>(Data);
  try
    if Block.Delta.&Type.Equals('input_json_delta') then
      begin
        FValue := Format(DELTA_PARTIAL_FMT,
          [Block.&Type,
           Block.Delta.Argument.Replace('"', '\"'),
           FTool.Id,
           FTool.Name]);
        FTool.Input := FTool.Input + Block.Delta.Argument;
      end
    else
      FValue :=
        Format(DELTA_FMT, [Block.&Type, Block.Delta.Text.Replace('"', '\"')]);
  finally
    Result := Self;
    Block.Free;
  end;
end;

function TDelta.BlockStart(const Data: string): TDelta;
begin
  {--- Retrieving the values of BlockStart from 'data' through the reflection process }
  var Block := TJson.JsonToObject<TBlockStart>(Data);
  try
    FTool.Id := Block.ContentBlock.Id;
    FTool.Name := Block.ContentBlock.Name;
    FTool.Input := EmptyStr;
  finally
    Result := Self;
    Block.Free;
  end;
end;

class function TDelta.BlockType(const Line: string): TBlockType;
begin
  if Line.Contains(TDataHelper.KeyToStr('message_stop')) then
    Exit(btDone);
  if Line.StartsWith(TDataHelper.KeyToStr('content_block_delta')) then
    Exit(btBlockDelta);
  if Line.StartsWith(TDataHelper.KeyToStr('message_start')) then
    Exit(btMessageStart);
  if Line.StartsWith(TDataHelper.KeyToStr('message_delta')) then
    Exit(btMessageDelta);
  if Line.StartsWith(TDataHelper.KeyToStr('content_block_start')) and
     Line.Contains(TDataHelper.ToolUsed) then
    Exit(btBlockStart);
  Result := btNone;
end;

function TDelta.MessageDelta(const Data: string): TDelta;
begin
  {--- Retrieving from the 'delta' and 'usage' fields and their values from Data }
  var DeltaStr := ExtractJSONPair(Data, 'delta', False);
  var UsageStr := ExtractJSONPair(Data, 'usage', True);

  {--- Prepare a new pattern from FMessagePattern string }
  FValue := DeleteJSONPair(FMessagePattern, 'usage');
  FValue := DeleteJSONPair(FValue, 'stop_reason');
  FValue := DeleteJSONPair(FValue, 'stop_sequence');

  {--- Retrieving 'usage' values from UsageStr through the reflection process }
  var BlockUsage := TJson.JsonToObject<TMessageUsage>(UsageStr);
  try
    var Usage := Format(USAGE_FMT,
          [FUsage.FInputTokens,
           BlockUsage.FCacheCreationInputTokens,
           FUsage.CacheReadInputTokens,
           BlockUsage.OutputTokens]);

    {--- Build the parameter of the pattern from collected datas }
    var SubStr := EmptyStr;
    if not FTool.Input.IsEmpty then
      begin
        SubStr := Format(DELTA_PARTIAL_FMT,
          ['tool_use', FTool.Input.Replace('"', '\"'), FTool.Id, FTool.Name]);

        SubStr := Format('%s,%s, %s',
          [DeltaStr, Usage, SubStr]);
      end
    else
      SubStr := Format('%s,%s, %s', [DeltaStr, Usage, EMPTY_DELTA]);

    {--- Finalizing the result value in the FValue field using the pattern and the parameter }
    FValue := FValue.Format(FValue, [SubStr]);
    Result := Self;
  finally
    BlockUsage.Free;
  end;
end;

function TDelta.MessageStart(Data: string): TDelta;
begin
  {--- Retrieving 'message' values from 'data' through the reflection process and saving 'usage' values }
  var Start := TJson.JsonToObject<TMessageStart>(Data);
  try
    Self.FUsage.InputTokens := Start.Message.Usage.InputTokens;
    Self.FUsage.CacheCreationInputTokens := Start.Message.Usage.CacheCreationInputTokens;
    Self.FUsage.CacheReadInputTokens := Start.Message.Usage.CacheReadInputTokens;
    Self.FUsage.OutputTokens := Start.Message.Usage.OutputTokens;
  finally
    Start.Free;
  end;

  {--- Creating the pattern and saving it into FMessagePattern }
  Data := ExtractJSONPair(Data, 'message', True);
  Data := Data.Substring(0, Data.Trim.Length - 1);
  Data.Insert(Data.Length, ',%s}');
  Self.FMessagePattern := Data;

  {--- Finalizing the result value in the FValue field }
  Self.FValue := EMPTY_DELTA;
  Result := Self;
end;

function TDelta.ToString(IsFormated: Boolean): string;
begin
  if IsFormated then
    Result := Format(FMessagePattern, [FValue]) else
    Result := FValue;
end;

{ TBlockStart }

destructor TBlockStart.Destroy;
begin
  if Assigned(FContentBlock) then
    FContentBlock.Free;
  inherited;
end;

{ TMessageContent }

destructor TMessageContent.Destroy;
begin
  if Assigned(FUsage) then
    FUsage.Free;
  inherited;
end;

{ TMessageStart }

destructor TMessageStart.Destroy;
begin
  if Assigned(FMessage) then
    FMessage.Free;
  inherited;
end;

{ TDataHelper }

class function TDataHelper.KeyToStr(const Key: string): string;
begin
  Result := Format('data: {"type":"%s"', [Key]);
end;

class function TDataHelper.ToolUsed: string;
begin
  Result := '"content_block":{"type":"tool_use"';
end;

end.

unit Anthropic.Tutorial.FMX;

{ Tutorial Support Unit

   WARNING:
     This module is intended solely to illustrate the examples provided in the
     README.md file of the repository :
          https://github.com/MaxiDonkey/DelphiAnthropic
     Under no circumstances should the methods described below be used outside
     of the examples presented on the repository's page.
}

interface

uses
  System.SysUtils, System.Classes, Winapi.Messages, FMX.Types, FMX.StdCtrls, FMX.ExtCtrls,
  FMX.Controls, FMX.Forms, Winapi.Windows, FMX.Graphics, FMX.Dialogs, FMX.Memo.Types,
  FMX.Media, FMX.Objects, FMX.Controls.Presentation, FMX.ScrollBox, FMX.Memo, System.UITypes,
  System.Types,
  Anthropic, Anthropic.Types, Anthropic.API.Params;

type
  TToolProc = procedure (const Value: string) of object;

  /// <summary>
  /// Represents a tutorial hub for handling visual components in a Delphi application,
  /// including text display, button interactions, and navigation through pages.
  /// </summary>
  TFMXTutorialHub = class
  private
    FMemo1: TMemo;
    FButton: TButton;
    FBatchId: string;
    FFileName: string;
    FTool: IFunctionCore;
    FToolCall: TToolProc;
    FCancel: Boolean;
    FJSONParam: TJSONParam;
    procedure OnButtonClick(Sender: TObject);
    procedure SetButton(const Value: TButton);
    procedure SetMemo1(const Value: TMemo);
  public
    /// <summary>
    /// Gets or sets the first memo component for displaying messages or data.
    /// </summary>
    property Memo1: TMemo read FMemo1 write SetMemo1;
    /// <summary>
    /// Gets or sets the button component used to trigger actions or handle cancellation.
    /// </summary>
    property Button: TButton read FButton write SetButton;
    /// <summary>
    /// Gets or sets a value indicating whether the operation has been canceled.
    /// </summary>
    property Cancel: Boolean read FCancel write FCancel;
    /// <summary>
    /// Gets or sets the TJSONParam object associated with the tutorial hub.
    /// </summary>
    property JSONParam: TJSONParam read FJSONParam write FJSONParam;
    /// <summary>
    /// Gets or sets the batch identifier associated with the tutorial hub.
    /// </summary>
    property BatchId: string read FBatchId write FBatchId;
    /// <summary>
    /// Gets or sets the name of the file associated with the tutorial hub.
    /// </summary>
    property FileName: string read FFileName write FFileName;
    /// <summary>
    /// Gets or sets the core function tool used for processing.
    /// </summary>
    property Tool: IFunctionCore read FTool write FTool;
    /// <summary>
    /// Gets or sets the procedure for handling tool-specific calls.
    /// </summary>
    property ToolCall: TToolProc read FToolCall write FToolCall;
    /// <summary>
    /// Gets or sets a value indicating whether file overrides are allowed.
    /// </summary>
    constructor Create(const AMemo1: TMemo; const AButton: TButton);
  end;

  procedure Cancellation(Sender: TObject);
  function DoCancellation: Boolean;
  procedure Start(Sender: TObject);

  procedure Display(Sender: TObject); overload;
  procedure Display(Sender: TObject; Value: string); overload;
  procedure Display(Sender: TObject; Value: TArray<string>); overload;
  procedure Display(Sender: TObject; Value: TChat); overload;
  procedure Display(Sender: TObject; Value: TModel); overload;
  procedure Display(Sender: TObject; Value: TModels); overload;
  procedure Display(Sender: TObject; Value: TChatUsage); overload;
  procedure Display(Sender: TObject; Value: TBatcheList); overload;
  procedure Display(Sender: TObject; Value: TBatche); overload;
  procedure Display(Sender: TObject; Value: TBatchDelete); overload;
  procedure Display(Sender: TObject; Value: TStringList); overload;
  procedure Display(Sender: TObject; Value: IBatcheResults); overload;
  procedure Display(Sender: TObject; Value: TTokenCount); overload;

  procedure DisplayStream(Sender: TObject; Value: string); overload;
  procedure DisplayStream(Sender: TObject; Value: TChat); overload;

  procedure DisplayUsage(Sender: TObject; Value: TChat);

  function F(const Name, Value: string): string; overload;
  function F(const Name: string; const Value: TArray<string>): string; overload;
  function F(const Name: string; const Value: boolean): string; overload;
  function F(const Name: string; const State: Boolean; const Value: Double): string; overload;

var
  /// <summary>
  /// A global instance of the <see cref="TVCLTutorialHub"/> class used as the main tutorial hub.
  /// </summary>
  /// <remarks>
  /// This variable serves as the central hub for managing tutorial components, such as memos, buttons, and pages.
  /// It is initialized dynamically during the application's runtime, and its memory is automatically released during
  /// the application's finalization phase.
  /// </remarks>
  TutorialHub: TFMXTutorialHub = nil;

implementation

uses
  System.DateUtils;

function UnixIntToDateTime(const Value: Int64): TDateTime;
begin
  Result := TTimeZone.Local.ToLocalTime(UnixToDateTime(Value));
end;

function UnixDateTimeToString(const Value: Int64): string;
begin
  Result := DateTimeToStr(UnixIntToDateTime(Value))
end;

procedure Cancellation(Sender: TObject);
begin
  Display(Sender, 'The operation was cancelled' + sLineBreak);
  TutorialHub.Cancel := False;
end;

function DoCancellation: Boolean;
begin
  Result := TutorialHub.Cancel;
end;

procedure Start(Sender: TObject);
begin
  Display(Sender, 'Please wait...');
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: string);
var
  M: TMemo;
begin
  if Sender is TMemo then
    M := Sender as TMemo else
    M := (Sender as TFMXTutorialHub).Memo1;
  M.Lines.Add(Value);
  M.ViewportPosition := PointF(M.ViewportPosition.X, M.Content.Height - M.Height);
end;

procedure Display(Sender: TObject; Value: TArray<string>);
begin
  var index := 0;
  for var Item in Value do
    begin
      if not Item.IsEmpty then
        begin
          if index = 0 then
            Display(Sender, Item) else
            Display(Sender, '    ' + Item);
        end;
      Inc(index);
    end;
end;

procedure Display(Sender: TObject);
begin
  Display(Sender, sLineBreak);
end;

procedure Display(Sender: TObject; Value: TChat);
begin
  for var Item in Value.Content do
    begin
      if Item.&Type = 'text' then
          begin
            Display(Sender, Item.Text);
            DisplayUsage(Sender, Value);
          end
        else
        if Item.&Type = 'tool_use' then
          begin
            if Assigned(TutorialHub.ToolCall) then
              TutorialHub.ToolCall(TutorialHub.Tool.Execute(Item.Input));
          end;
    end;
end;

procedure Display(Sender: TObject; Value: TModel);
begin
  Display(Sender, [
    Value.Id,
    F('Type', Value.&Type),
    F('DisplayName', Value.DisplayName),
    F('CreatedAt', Value.CreatedAt)
  ]);
  Display(Sender, EmptyStr);
end;

procedure Display(Sender: TObject; Value: TModels);
begin
  if Length(Value.Data) = 0 then
    begin
      Display(Sender, 'No model found');
      Exit;
    end;
  for var Item in Value.Data do
    begin
      Display(Sender, Item);
      Application.ProcessMessages;
    end;
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TChatUsage);
begin
  Display(Sender, [F('input_tokens', [Value.InputTokens.ToString,
      F('output_tokens', Value.OutputTokens.ToString),
      F('cache_creation_input_tokens', Value.CacheCreationInputTokens.ToString),
      F('cache_read_input_tokens', Value.CacheReadInputTokens.ToString)
   ])]);
  Display(Sender)
end;

procedure Display(Sender: TObject; Value: TBatche);
begin
  Display(Sender, [EmptyStr,
    Value.Id,
    F('Type', Value.&Type),
    F('Processing_status', Value.ProcessingStatus.ToString),
    F('CreatedAt', Value.CreatedAt),
    F('ExpiresAt', Value.ExpiresAt),
    F('CancelInitiatedAt', Value.CancelInitiatedAt),
    F('ResultsUrl', Value.ResultsUrl),
    F('Processing', Value.RequestCounts.Processing.ToString),
    F('Succeeded', Value.RequestCounts.Succeeded.ToString),
    F('Errored', Value.RequestCounts.Errored.ToString),
    F('Canceled', Value.RequestCounts.Canceled.ToString),
    F('Expired', Value.RequestCounts.Expired.ToString)
  ]);
  Display(Sender, EmptyStr);
  if Assigned(TutorialHub.JSONParam) then
    FreeAndNil(TutorialHub.JSONParam);
end;

procedure Display(Sender: TObject; Value: TBatchDelete);
begin
  Display(Sender, F('Id', [
     Value.Id,
     F('Type', Value.&Type)
  ]));
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TBatcheList);
begin
  Display(Sender, F('HasMore', BoolToStr(Value.HasMore, True)));
  Display(Sender, F('FirstId', Value.FirstId));
  Display(Sender, F('LastId', Value.LastId));
  Display(Sender, EmptyStr);

  for var Item in Value.Data do
    begin
      Display(Sender, [EmptyStr,
        F('Id', [
          Item.Id,
          Item.ProcessingStatus.ToString
        ])
      ]);
    end;
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TStringList);
begin
  with Value.GetEnumerator do
  try
    while MoveNext do
      Display(Sender, Current);
  finally
    Free;
    Display(Sender);
  end;
end;

procedure Display(Sender: TObject; Value: IBatcheResults);
begin
  for var Item in Value.Batches do
    Display(Sender, F(Item.CustomId, Item.Result.Message.Content[0].Text));
  Display(Sender, EmptyStr);
end;

procedure Display(Sender: TObject; Value: TTokenCount);
begin
  Display(Sender, F('Input_tokens', Value.InputTokens.ToString));
end;

procedure DisplayStream(Sender: TObject; Value: string);
var
  M: TMemo;
  CurrentLine: string;
begin
  if Sender is TMemo then
    M := Sender as TMemo
  else
    M := (Sender as TFMXTutorialHub).Memo1;
  var ShouldScroll := M.ViewportPosition.Y >= (M.Content.Height - M.Height - 16);
  M.Lines.BeginUpdate;
  try
    var Lines := Value.Replace(#13, '').Split([#10]);
    if System.Length(Lines) > 0 then
    begin
      if M.Lines.Count > 0 then
        CurrentLine := M.Lines[M.Lines.Count - 1]
      else
        CurrentLine := EmptyStr;
      CurrentLine := CurrentLine + Lines[0];
      if M.Lines.Count > 0 then
        M.Lines[M.Lines.Count - 1] := CurrentLine
      else
        M.Lines.Add(CurrentLine);
      for var i := 1 to High(Lines) do
        M.Lines.Add(Lines[i]);
    end;
  finally
    M.Lines.EndUpdate;
  end;
  if ShouldScroll then
    M.ViewportPosition := PointF(M.ViewportPosition.X, M.Content.Height - M.Height + 1);
end;

procedure DisplayStream(Sender: TObject; Value: TChat);
begin
  if Assigned(Value) then
    begin
      if Value.Delta.&Type = 'tool_use' then
        begin
          if Assigned(TutorialHub.ToolCall) then
            TutorialHub.ToolCall(TutorialHub.Tool.Execute(Value.Delta.Input));
        end
      else
        begin
          DisplayStream(Sender, Value.Delta.Text);
        end;
    end;
end;

procedure DisplayUsage(Sender: TObject; Value: TChat);
begin
  Display(Sender, Value.Usage);
end;

function F(const Name, Value: string): string;
begin
  if not Value.IsEmpty then
    Result := Format('%s: %s', [Name, Value])
end;

function F(const Name: string; const Value: TArray<string>): string;
begin
  var index := 0;
  for var Item in Value do
    begin
      if index = 0 then
        Result := Format('%s: %s', [Name, Item]) else
        Result := Result + '    ' + Item;
      Inc(index);
    end;
end;

function F(const Name: string; const Value: boolean): string;
begin
  Result := Format('%s: %s', [Name, BoolToStr(Value, True)])
end;

function F(const Name: string; const State: Boolean; const Value: Double): string;
begin
  Result := Format('%s (%s): %s%%', [Name, BoolToStr(State, True), (Value * 100).ToString(ffNumber, 3, 3)])
end;

function CodeBefore: string;
begin
  with TStringWriter.Create do
  try
    WriteLine('def is_odd(n):');
    WriteLine('  return n % 2 == 1');
    WriteLine('def test_is_odd():');
    Result := ToString;
  finally
    Free;
  end;
end;

function CodeAfter: string;
begin
  with TStringWriter.Create do
  try
    WriteLine('n = int(input(''Enter a number: ''))');
    WriteLine('print(fibonacci(n))');
    Result := ToString;
  finally
    Free;
  end;
end;

{ TFMXTutorialHub }

constructor TFMXTutorialHub.Create(const AMemo1: TMemo; const AButton: TButton);
begin
  inherited Create;
  Memo1 := AMemo1;
  Button := AButton;
  JSONParam := nil;
end;

procedure TFMXTutorialHub.OnButtonClick(Sender: TObject);
begin
  Cancel := True;
end;

procedure TFMXTutorialHub.SetButton(const Value: TButton);
begin
  FButton := Value;
  FButton.OnClick := OnButtonClick;
  FButton.Text := 'Cancel';
end;

procedure TFMXTutorialHub.SetMemo1(const Value: TMemo);
begin
  FMemo1 := Value;
  FMemo1.TextSettings.WordWrap := True;
end;

initialization
finalization
  if Assigned(TutorialHub) then
    TutorialHub.Free;
end.

unit Anthropic.Tutorial.VCL;

{ Tutorial Support Unit

   WARNING:
     This module is intended solely to illustrate the examples provided in the
     README.md file of the repository :
          https://github.com/MaxiDonkey/DelphiAnthropic
     Under no circumstances should the methods described below be used outside
     of the examples presented on the repository's page.
}

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes,
  Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.ExtCtrls,
  System.UITypes,
  Anthropic, Anthropic.Types, Anthropic.API.Params;

type
  TToolProc = procedure (const Value: string) of object;

  /// <summary>
  /// Represents a tutorial hub for handling visual components in a Delphi application,
  /// including text display, button interactions, and navigation through pages.
  /// </summary>
  TVCLTutorialHub = class
  private
    FMemo1: TMemo;
    FButton: TButton;
    FBatchId: string;
    FFileName: string;
    FTool: IFunctionCore;
    FToolCall: TToolProc;
    FCancel: Boolean;
    FJSONParam: TJSONParam;
    procedure OnButtonClick(Sender: TObject);
    procedure SetButton(const Value: TButton);
    procedure SetMemo1(const Value: TMemo);
  public
    /// <summary>
    /// Gets or sets the first memo component for displaying messages or data.
    /// </summary>
    property Memo1: TMemo read FMemo1 write SetMemo1;
    /// <summary>
    /// Gets or sets the button component used to trigger actions or handle cancellation.
    /// </summary>
    property Button: TButton read FButton write SetButton;
    /// <summary>
    /// Gets or sets a value indicating whether the operation has been canceled.
    /// </summary>
    property Cancel: Boolean read FCancel write FCancel;
    /// <summary>
    /// Gets or sets the TJSONParam object associated with the tutorial hub.
    /// </summary>
    property JSONParam: TJSONParam read FJSONParam write FJSONParam;
    /// <summary>
    /// Gets or sets the batch identifier associated with the tutorial hub.
    /// </summary>
    property BatchId: string read FBatchId write FBatchId;
    /// <summary>
    /// Gets or sets the name of the file associated with the tutorial hub.
    /// </summary>
    property FileName: string read FFileName write FFileName;
    /// <summary>
    /// Gets or sets the core function tool used for processing.
    /// </summary>
    property Tool: IFunctionCore read FTool write FTool;
    /// <summary>
    /// Gets or sets the procedure for handling tool-specific calls.
    /// </summary>
    property ToolCall: TToolProc read FToolCall write FToolCall;
    constructor Create(const AMemo1: TMemo; const AButton: TButton);
  end;

  procedure Cancellation(Sender: TObject);
  function DoCancellation: Boolean;
  procedure Start(Sender: TObject);

  procedure Display(Sender: TObject); overload;
  procedure Display(Sender: TObject; Value: string); overload;
  procedure Display(Sender: TObject; Value: TArray<string>); overload;
  procedure Display(Sender: TObject; Value: TChat); overload;
  procedure Display(Sender: TObject; Value: TModel); overload;
  procedure Display(Sender: TObject; Value: TModels); overload;
  procedure Display(Sender: TObject; Value: TChatUsage); overload;
  procedure Display(Sender: TObject; Value: TBatcheList); overload;
  procedure Display(Sender: TObject; Value: TBatche); overload;
  procedure Display(Sender: TObject; Value: TBatchDelete); overload;
  procedure Display(Sender: TObject; Value: TStringList); overload;
  procedure Display(Sender: TObject; Value: IBatcheResults); overload;
  procedure Display(Sender: TObject; Value: TTokenCount); overload;

  procedure DisplayStream(Sender: TObject; Value: string); overload;
  procedure DisplayStream(Sender: TObject; Value: TChat); overload;

  procedure DisplayUsage(Sender: TObject; Value: TChat);

  function F(const Name, Value: string): string; overload;
  function F(const Name: string; const Value: TArray<string>): string; overload;
  function F(const Name: string; const Value: boolean): string; overload;
  function F(const Name: string; const State: Boolean; const Value: Double): string; overload;

var
  /// <summary>
  /// A global instance of the <see cref="TVCLTutorialHub"/> class used as the main tutorial hub.
  /// </summary>
  /// <remarks>
  /// This variable serves as the central hub for managing tutorial components, such as memos, buttons, and pages.
  /// It is initialized dynamically during the application's runtime, and its memory is automatically released during
  /// the application's finalization phase.
  /// </remarks>
  TutorialHub: TVCLTutorialHub = nil;

implementation

uses
  System.DateUtils;

function UnixIntToDateTime(const Value: Int64): TDateTime;
begin
  Result := TTimeZone.Local.ToLocalTime(UnixToDateTime(Value));
end;

function UnixDateTimeToString(const Value: Int64): string;
begin
  Result := DateTimeToStr(UnixIntToDateTime(Value))
end;

procedure Cancellation(Sender: TObject);
begin
  Display(Sender, 'The operation was cancelled');
  Display(Sender);
  TutorialHub.Cancel := False;
end;

function DoCancellation: Boolean;
begin
  Result := TutorialHub.Cancel;
end;

procedure Start(Sender: TObject);
begin
  Display(Sender, 'Please wait...');
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: string);
var
  M: TMemo;
begin
  if Sender is TMemo then
    M := TMemo(Sender) else
    M := (Sender as TVCLTutorialHub).Memo1;

  var S := Value.Split([#10]);
  if Length(S) = 0 then
    begin
      M.Lines.Add(Value)
    end
  else
    begin
      for var Item in S do
        M.Lines.Add(Item);
    end;

  M.Perform(WM_VSCROLL, SB_BOTTOM, 0);
end;

procedure Display(Sender: TObject; Value: TArray<string>);
begin
  var index := 0;
  for var Item in Value do
    begin
      if not Item.IsEmpty then
        begin
          if index = 0 then
            Display(Sender, Item) else
            Display(Sender, '    ' + Item);
        end;
      Inc(index);
    end;
end;

procedure Display(Sender: TObject);
begin
  Display(Sender, sLineBreak);
end;

procedure Display(Sender: TObject; Value: TChat);
begin
  for var Item in Value.Content do
    begin
      if Item.&Type = 'text' then
          begin
            Display(Sender, Item.Text);
            DisplayUsage(Sender, Value);
          end
        else
        if Item.&Type = 'tool_use' then
          begin
            if Assigned(TutorialHub.ToolCall) then
              TutorialHub.ToolCall(TutorialHub.Tool.Execute(Item.Input));
          end;
    end;
end;

procedure Display(Sender: TObject; Value: TModel);
begin
  Display(Sender, [
    Value.Id,
    F('Type', Value.&Type),
    F('DisplayName', Value.DisplayName),
    F('CreatedAt', Value.CreatedAt)
  ]);
  Display(Sender, EmptyStr);
end;

procedure Display(Sender: TObject; Value: TModels);
begin
  if Length(Value.Data) = 0 then
    begin
      Display(Sender, 'No model found');
      Exit;
    end;
  for var Item in Value.Data do
    begin
      Display(Sender, Item);
      Application.ProcessMessages;
    end;
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TChatUsage);
begin
  Display(Sender, [F('input_tokens', [Value.InputTokens.ToString,
      F('output_tokens', Value.OutputTokens.ToString),
      F('cache_creation_input_tokens', Value.CacheCreationInputTokens.ToString),
      F('cache_read_input_tokens', Value.CacheReadInputTokens.ToString)
   ])]);
  Display(Sender)
end;

procedure Display(Sender: TObject; Value: TBatche);
begin
  Display(Sender, [EmptyStr,
    Value.Id,
    F('Type', Value.&Type),
    F('Processing_status', Value.ProcessingStatus.ToString),
    F('CreatedAt', Value.CreatedAt),
    F('ExpiresAt', Value.ExpiresAt),
    F('CancelInitiatedAt', Value.CancelInitiatedAt),
    F('ResultsUrl', Value.ResultsUrl),
    F('Processing', Value.RequestCounts.Processing.ToString),
    F('Succeeded', Value.RequestCounts.Succeeded.ToString),
    F('Errored', Value.RequestCounts.Errored.ToString),
    F('Canceled', Value.RequestCounts.Canceled.ToString),
    F('Expired', Value.RequestCounts.Expired.ToString)
  ]);
  Display(Sender, EmptyStr);
  if Assigned(TutorialHub.JSONParam) then
    FreeAndNil(TutorialHub.JSONParam);
end;

procedure Display(Sender: TObject; Value: TBatchDelete);
begin
  Display(Sender, F('Id', [
     Value.Id,
     F('Type', Value.&Type)
  ]));
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TBatcheList);
begin
  Display(Sender, F('HasMore', BoolToStr(Value.HasMore, True)));
  Display(Sender, F('FirstId', Value.FirstId));
  Display(Sender, F('LastId', Value.LastId));
  Display(Sender, EmptyStr);

  for var Item in Value.Data do
    begin
      Display(Sender, [EmptyStr,
        F('Id', [
          Item.Id,
          Item.ProcessingStatus.ToString
        ])
      ]);
    end;
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TStringList);
begin
  with Value.GetEnumerator do
  try
    while MoveNext do
      Display(Sender, Current);
  finally
    Free;
    Display(Sender);
  end;
end;

procedure Display(Sender: TObject; Value: IBatcheResults);
begin
  for var Item in Value.Batches do
    Display(Sender, F(Item.CustomId, Item.Result.Message.Content[0].Text));
  Display(Sender, EmptyStr);
end;

procedure Display(Sender: TObject; Value: TTokenCount);
begin
  Display(Sender, F('Input_tokens', Value.InputTokens.ToString));
end;

procedure DisplayStream(Sender: TObject; Value: string);
var
  M: TMemo;
  CurrentLine: string;
  Lines: TArray<string>;
begin
  if Sender is TMemo then
    M := TMemo(Sender) else
    M := (Sender as TVCLTutorialHub).Memo1;
  var OldSelStart := M.SelStart;
  var ShouldScroll := (OldSelStart = M.GetTextLen);
  M.Lines.BeginUpdate;
  try
    Lines := Value.Split([#10]);
    if Length(Lines) > 0 then
    begin
      if M.Lines.Count > 0 then
        CurrentLine := M.Lines[M.Lines.Count - 1]
      else
        CurrentLine := '';
      CurrentLine := CurrentLine + Lines[0];
      if M.Lines.Count > 0 then
        M.Lines[M.Lines.Count - 1] := CurrentLine
      else
        M.Lines.Add(CurrentLine);
      for var i := 1 to High(Lines) do
        M.Lines.Add(Lines[i]);
    end;
  finally
    M.Lines.EndUpdate;
  end;
  if ShouldScroll then
  begin
    M.SelStart := M.GetTextLen;
    M.SelLength := 0;
    M.Perform(EM_SCROLLCARET, 0, 0);
  end;
end;

procedure DisplayStream(Sender: TObject; Value: TChat);
begin
  if Assigned(Value) then
    begin
      if Value.Delta.&Type = 'tool_use' then
        begin
          if Assigned(TutorialHub.ToolCall) then
            TutorialHub.ToolCall(TutorialHub.Tool.Execute(Value.Delta.Input));
        end
      else
        begin
          DisplayStream(Sender, Value.Delta.Text);
        end;
    end;
end;

procedure DisplayUsage(Sender: TObject; Value: TChat);
begin
  Display(Sender, Value.Usage);
end;

function F(const Name, Value: string): string;
begin
  if not Value.IsEmpty then
    Result := Format('%s: %s', [Name, Value])
end;

function F(const Name: string; const Value: TArray<string>): string;
begin
  var index := 0;
  for var Item in Value do
    begin
      if index = 0 then
        Result := Format('%s: %s', [Name, Item]) else
        Result := Result + '    ' + Item;
      Inc(index);
    end;
end;

function F(const Name: string; const Value: boolean): string;
begin
  Result := Format('%s: %s', [Name, BoolToStr(Value, True)])
end;

function F(const Name: string; const State: Boolean; const Value: Double): string;
begin
  Result := Format('%s (%s): %s%%', [Name, BoolToStr(State, True), (Value * 100).ToString(ffNumber, 3, 2)])
end;

{ TVCLTutorialHub }

constructor TVCLTutorialHub.Create(const AMemo1: TMemo; const AButton: TButton);
begin
  inherited Create;
  Memo1 := AMemo1;
  Button := AButton;
  JSONParam := nil;
end;

procedure TVCLTutorialHub.OnButtonClick(Sender: TObject);
begin
  Cancel := True;
end;

procedure TVCLTutorialHub.SetButton(const Value: TButton);
begin
  FButton := Value;
  FButton.OnClick := OnButtonClick;
  FButton.Caption := 'Cancel';
end;

procedure TVCLTutorialHub.SetMemo1(const Value: TMemo);
begin
  FMemo1 := Value;
  FMemo1.ScrollBars := TScrollStyle.ssVertical;
end;

initialization
finalization
  if Assigned(TutorialHub) then
    TutorialHub.Free;
end.

unit Anthropic.Types;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiAnthropic
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, Anthropic.API.Params;

type

{$REGION 'Anthropic.Chat'}

/// <summary>
  /// Type of message role
  /// </summary>
  TMessageRole = (
    /// <summary>
    /// User message
    /// </summary>
    user,
    /// <summary>
    /// Assistant message
    /// </summary>
    assistant);

  /// <summary>
  /// Helper record for the <c>TMessageRole</c> enumeration, providing utility methods for converting
  /// between <c>TMessageRole</c> values and their string representations.
  /// </summary>
  TMessageRoleHelper = record helper for TMessageRole
    /// <summary>
    /// Converts the current <c>TMessageRole</c> value to its corresponding string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>TMessageRole</c> value.
    /// </returns>
    function ToString: string;
    /// <summary>
    /// Converts a string representation of a <c>TMessageRole</c> into its corresponding enumeration value.
    /// </summary>
    /// <param name="Value">
    /// The string representing a <c>TMessageRole</c>.
    /// </param>
    /// <returns>
    /// The <c>TMessageRole</c> enumeration value that corresponds to the provided string.
    /// </returns>
    class function FromString(const Value: string): TMessageRole; static;
  end;


  /// <summary>
  /// Represents the different reasons why the processing of a request can terminate.
  /// </summary>
  TStopReason = (
    /// <summary>
    /// The model reached a natural stopping point
    /// </summary>
    end_turn,
    /// <summary>
    /// We exceeded the requested max_tokens or the model's maximum
    /// </summary>
    max_tokens,
    /// <summary>
    /// One of your provided custom stop_sequences was generated
    /// </summary>
    stop_sequence,
    /// <summary>
    /// The model invoked one or more tools
    /// </summary>
    tool_use);

  /// <summary>
  /// Helper record for the <c>TStopReason</c> enumeration, providing utility methods for conversion between string representations and <c>TStopReason</c> values.
  /// </summary>
  TStopReasonHelper = record helper for TStopReason
    /// <summary>
    /// Converts the current <c>TStopReason</c> value to its string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>TStopReason</c> value.
    /// </returns>
    function ToString: string;
    /// <summary>
    /// Creates a <c>TStopReason</c> value from its corresponding string representation.
    /// </summary>
    /// <param name="Value">
    /// The string value representing a <c>TStopReason</c>.
    /// </param>
    /// <returns>
    /// The corresponding <c>TStopReason</c> enumeration value for the provided string.
    /// </returns>
    /// <remarks>
    /// This method throws an exception if the input string does not match any valid <c>TStopReason</c> values.
    /// </remarks>
    class function Create(const Value: string): TStopReason; static;
  end;

  /// <summary>
  /// Interceptor class for converting <c>TStopReason</c> values to and from their string representations in JSON serialization and deserialization.
  /// </summary>
  /// <remarks>
  /// This class is used to facilitate the conversion between the <c>TStopReason</c> enum and its string equivalents during JSON processing.
  /// It extends the <c>TJSONInterceptorStringToString</c> class to override the necessary methods for custom conversion logic.
  /// </remarks>
  TStopReasonInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// Converts the <c>TStopReason</c> value of the specified field to a string during JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be converted.
    /// </param>
    /// <param name="Field">
    /// The field name representing the <c>TStopReason</c> value.
    /// </param>
    /// <returns>
    /// The string representation of the <c>TStopReason</c> value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string back to a <c>TStopReason</c> value for the specified field during JSON deserialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be set.
    /// </param>
    /// <param name="Field">
    /// The field name where the <c>TStopReason</c> value will be set.
    /// </param>
    /// <param name="Arg">
    /// The string representation of the <c>TStopReason</c> to be converted back.
    /// </param>
    /// <remarks>
    /// This method converts the string argument back to the corresponding <c>TStopReason</c> value and assigns it to the specified field in the object.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Indicator to specify how to use tools.
  /// </summary>
  TToolChoiceType = (
    /// <summary>
    /// Allows Claude to decide whether to call any provided tools or not. This is the default value.
    /// </summary>
    auto,
    /// <summary>
    /// Tells Claude that it must use one of the provided tools, but doesn’t force a particular tool.
    /// </summary>
    any,
    /// <summary>
    ///  Allows us to force Claude to always use a particular tool.
    /// </summary>
    tool
  );

  /// <summary>
  /// Helper record for the <c>TToolChoiceType</c> enumeration, providing utility methods for converting
  /// between <c>TToolChoiceType</c> values and their string representations.
  /// </summary>
  TToolChoiceTypeHelper = record helper for TToolChoiceType
    /// <summary>
    /// Converts the current <c>TToolChoiceType</c> value to its corresponding string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>TToolChoiceType</c> value.
    /// </returns>
    function ToString: string;
  end;

  /// <summary>
  /// Indicator to specify how to use caching.
  /// </summary>
  TCachingType = (
    /// <summary>
    /// Cache is not used.
    /// </summary>
    nocaching,
    /// <summary>
    /// This is the only type currently defined by Anthropic.
    /// </summary>
    ephemeral
  );

  /// <summary>
  /// Helper record for the <c>TCachingType</c> enumeration, providing utility methods for converting
  /// between <c>TCachingType</c> values and their string representations.
  /// </summary>
  TCachingTypeHelper = record Helper for TCachingType
    /// <summary>
    /// Converts the current <c>TCachingType</c> value to its string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>TCachingType</c> value.
    /// </returns>
    function ToString: string;
  end;

{$ENDREGION}

{$REGION 'Anthropic.Batches'}

  /// <summary>
  /// Processing status of the Message Batch.
  /// </summary>
  TProcessingStatusType = (
    /// <summary>
    /// Batch of messages pending or being processed
    /// </summary>
    in_progress,
    /// <summary>
    /// Message batch processing canceled
    /// </summary>
    canceling,
    /// <summary>
    /// Batch processing is complete
    /// </summary>
    ended
  );

  /// <summary>
  /// Helper record for the <c>TProcessingStatusType</c> enumeration, providing utility methods for converting
  /// between <c>TProcessingStatusType</c> values and their string representations.
  /// </summary>
  TProcessingStatusTypeHelper = record helper for TProcessingStatusType
    /// <summary>
    /// Converts the current <c>TProcessingStatusType</c> value to its corresponding string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>TProcessingStatusType</c> value.
    /// </returns>
    function ToString: string;
    /// <summary>
    /// Converts a string representation of a <c>TProcessingStatusType</c> into its corresponding enumeration value.
    /// </summary>
    /// <param name="Value">
    /// The string representing a <c>TTProcessingStatusType</c>.
    /// </param>
    /// <returns>
    /// The <c>TProcessingStatusType</c> enumeration value that corresponds to the provided string.
    /// </returns>
    class function Create(const Value: string): TProcessingStatusType; static;
  end;

  /// <summary>
  /// Interceptor class for converting <c>TTProcessingStatusType</c> values to and from their string representations in JSON serialization and deserialization.
  /// </summary>
  /// <remarks>
  /// This class is used to facilitate the conversion between the <c>TTProcessingStatusType</c> enum and its string equivalents during JSON processing.
  /// It extends the <c>TJSONInterceptorStringToString</c> class to override the necessary methods for custom conversion logic.
  /// </remarks>
  TProcessingStatusInterceptor = class(TJSONInterceptorStringToString)
    /// <summary>
    /// Converts the <c>TJSONInterceptorStringToString</c> value of the specified field to a string during JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be converted.
    /// </param>
    /// <param name="Field">
    /// The field name representing the <c>TJSONInterceptorStringToString</c> value.
    /// </param>
    /// <returns>
    /// The string representation of the <c>TJSONInterceptorStringToString</c> value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string back to a <c>TJSONInterceptorStringToString</c> value for the specified field during JSON deserialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be set.
    /// </param>
    /// <param name="Field">
    /// The field name where the <c>TJSONInterceptorStringToString</c> value will be set.
    /// </param>
    /// <param name="Arg">
    /// The string representation of the <c>TJSONInterceptorStringToString</c> to be converted back.
    /// </param>
    /// <remarks>
    /// This method converts the string argument back to the corresponding <c>TJSONInterceptorStringToString</c> value and assigns it to the specified field in the object.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

{$ENDREGION}

{$REGION 'Anthropic.Schema'}

  /// <summary>
  /// Type contains the list of OpenAPI data types as defined by https://spec.openapis.org/oas/v3.0.3#data-types
  /// </summary>
  TSchemaType = (
    /// <summary>
    /// Not specified, should not be used.
    /// </summary>
    TYPE_UNSPECIFIED,
    /// <summary>
    /// String type.
    /// </summary>
    stSTRING,
    /// <summary>
    /// Number type.
    /// </summary>
    stNUMBER,
    /// <summary>
    /// Integer type.
    /// </summary>
    stINTEGER,
    /// <summary>
    /// Boolean type.
    /// </summary>
    stBOOLEAN,
    /// <summary>
    /// Array type.
    /// </summary>
    stARRAY,
    /// <summary>
    /// Object type.
    /// </summary>
    stOBJECT
  );

  /// <summary>
  /// Helper record for the <c>TSchemaType</c> enumeration, providing utility methods for converting
  /// between <c>TSchemaType</c> values and their string representations.
  /// </summary>
  TSchemaTypeHelper = record helper for TSchemaType
    /// <summary>
    /// Converts the current <c>TSchemaType</c> value to its corresponding string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>TSchemaType</c> value.
    /// </returns>
    function ToString: string;
  end;

{$ENDREGION}

implementation

uses
  System.StrUtils, System.Rtti, Rest.Json;

{ TMessageRoleHelper }

class function TMessageRoleHelper.FromString(const Value: string): TMessageRole;
begin
  case IndexStr(Value.ToLower, ['user', 'assistant']) of
    0 :
      Exit(user);
    1 :
      Exit(assistant);
  end;
  Result := user;
end;

function TMessageRoleHelper.ToString: string;
begin
  case Self of
    user:
      Exit('user');
    assistant:
      Exit('assistant');
  end;
end;

{ TStopReasonHelper }

class function TStopReasonHelper.Create(const Value: string): TStopReason;
begin
  case IndexStr(AnsiLowerCase(Value), ['end_turn', 'max_tokens', 'stop_sequence', 'tool_use']) of
    0 :
      Exit(end_turn);
    1 :
      Exit(max_tokens);
    2 :
      Exit(stop_sequence);
    3 :
      Exit(tool_use);
  end;
  Result := end_turn;
end;

function TStopReasonHelper.ToString: string;
begin
  case Self of
    end_turn:
      Exit('end_turn');
    max_tokens:
      Exit('max_tokens');
    stop_sequence:
      Exit('stop_sequence');
    tool_use:
      Exit('tool_use');
  end;
end;

{ TStopReasonInterceptor }

function TStopReasonInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TStopReason>.ToString;
end;

procedure TStopReasonInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TStopReason.Create(Arg)));
end;

{ TToolChoiceTypeHelper }

function TToolChoiceTypeHelper.ToString: string;
begin
  case Self of
    auto:
      Exit('auto');
    any:
      Exit('any');
    tool:
      Exit('tool');
  end;
end;

{ TCachingTypeHelper }

function TCachingTypeHelper.ToString: string;
begin
  case Self of
    nocaching:
      Exit('nocaching');
    ephemeral:
      Exit('ephemeral');
  end;
end;

{ TProcessingStatusTypeHelper }

class function TProcessingStatusTypeHelper.Create(
  const Value: string): TProcessingStatusType;
begin
  var index := IndexStr(AnsiLowerCase(Value), ['in_progress', 'canceling', 'ended']);
  if index = -1 then
    raise Exception.Create('Invalid processing status value.');
  Result := TProcessingStatusType(index);
end;

function TProcessingStatusTypeHelper.ToString: string;
begin
  case Self of
    in_progress:
      Exit('in_progress');
    canceling:
      Exit('canceling');
    ended:
      Exit('ended');
  end;
end;

{ TProcessingStatusInterceptor }

function TProcessingStatusInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TProcessingStatusType>.ToString;
end;

procedure TProcessingStatusInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TProcessingStatusType.Create(Arg)));
end;

{ TSchemaTypeHelper }

function TSchemaTypeHelper.ToString: string;
begin
  case Self of
    TYPE_UNSPECIFIED:
      Exit('type_unspecified');
    stSTRING:
      Exit('string');
    stNUMBER:
      Exit('number');
    stINTEGER:
      Exit('integer');
    stBOOLEAN:
      Exit('boolean');
    stARRAY:
      Exit('array');
    stOBJECT:
      Exit('object');
  end;
end;

end.













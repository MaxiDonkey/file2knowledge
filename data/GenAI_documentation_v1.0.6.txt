Code source du projet GenAI : wrapper d'API de OpenAI conçu par Maxidonkey (https://github.com/MaxiDonkey)

Unité rangées par ordre alphabétique de la version de développement 1.0.5 de mai 2025

unit GenAI.API.Deletion;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  GenAI.API.Params, GenAI.Async.Support;

type
  /// <summary>
  /// Represents a deletion response, providing details about the identifier, object type,
  /// and whether the deletion was successful.
  /// </summary>
  /// <remarks>
  /// This class is primarily used to store the result of a deletion request, including
  /// the unique ID of the deleted object, the type of the object, and a status indicating
  /// whether the deletion was completed successfully.
  /// </remarks>
  TDeletion = class(TJSONFingerprint)
  private
    FId: string;
    FObject: string;
    FDeleted: Boolean;
  public
    /// <summary>
    /// The unique identifier.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// The object type.
    /// </summary>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// Indicates whether the operation was successfully deleted.
    /// </summary>
    /// <remarks>
    /// This property is set to <c>true</c> if the deletion was successful, and <c>false</c>
    /// otherwise.
    /// </remarks>
    property Deleted: Boolean read FDeleted write FDeleted;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TDeletion</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynDeletion</c> type extends the <c>TAsynParams&lt;TDeletion&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynDeletion = TAsynCallBack<TDeletion>;

implementation

end.

unit GenAI.API.Lists;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  GenAI.API.Params, REST.Json.Types;

type
  /// <summary>
  /// Represents a generic advanced list structure for handling API responses.
  /// </summary>
  /// <remarks>
  /// This class is a generic container for handling paginated API responses. It provides
  /// properties to store the retrieved data, pagination information, and object metadata.
  /// The generic type parameter <c>T</c> must be a class with a parameterless constructor.
  /// </remarks>
  /// <typeparam name="T">
  /// The class type of objects contained in the list. The type must have a parameterless
  /// constructor.
  /// </typeparam>
  TAdvancedList<T: class, constructor> = class(TJSONFingerprint)
    FObject: string;
    FData: TArray<T>;
    [JsonNameAttribute('has_more')]
    FHasMore: Boolean;
    [JsonNameAttribute('first_id')]
    FFirstId: string;
    [JsonNameAttribute('last_id')]
    FLastId: string;
  public
    /// <summary>
    /// Represents the type of object contained in the list.
    /// </summary>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// Stores the list of retrieved objects.
    /// </summary>
    property Data: TArray<T> read FData write FData;
    /// <summary>
    /// Indicates whether there are more results available in the API pagination.
    /// </summary>
    property HasMore: Boolean read FHasMore write FHasMore;
    /// <summary>
    /// The ID of the first object in the current result set.
    /// </summary>
    property FirstId: string read FFirstId write FFirstId;
    /// <summary>
    /// The ID of the last object in the current result set.
    /// </summary>
    property LastId: string read FLastId write FLastId;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a paginated list of objects.
  /// This generic class can store a list of objects of type <c>T</c> and
  /// provides metadata about pagination, such as whether more results are available.
  /// </summary>
  /// <typeparam name="T">
  /// The type of objects stored in the list. It must be a class and have a default constructor.
  /// </typeparam>
  TPaginatedList<T: class, constructor> = class(TJSONFingerprint)
    FObject: string;
    FData: TArray<T>;
    [JsonNameAttribute('has_more')]
    FHasMore: Boolean;
  public
    /// <summary>
    /// Gets or sets the object type. This usually describes the nature of the list (e.g., "fine_tuning.jobs").
    /// </summary>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// Gets or sets the array of objects stored in the list.
    /// Each element is of type <c>T</c>.
    /// </summary>
    property Data: TArray<T> read FData write FData;
    /// <summary>
    /// Gets or sets a boolean value indicating whether there are more results to fetch.
    /// </summary>
    property HasMore: Boolean read FHasMore write FHasMore;
    /// <summary>
    /// Destructor for the <c>TPaginatedList</c> class.
    /// Frees all objects stored in the <c>Data</c> property to release memory.
    /// </summary>
    destructor Destroy; override;
  end;

implementation

{ TAdvancedList<T> }

destructor TAdvancedList<T>.Destroy;
begin
  for var Item in FData do
    Item.Free;
  inherited;
end;

{ TPaginatedList<T> }

destructor TPaginatedList<T>.Destroy;
begin
  for var Item in FData do
    Item.Free;
  inherited;
end;

end.

unit GenAI.API.Params;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.Classes, System.JSON, System.SysUtils, System.RTTI, REST.Json.Interceptors,
  REST.JsonReflect, System.Generics.Collections, System.Threading, System.TypInfo,
  GenAI.Consts;

type
  /// <summary>
  /// Represents a reference to a procedure that takes a single argument of type T and returns no value.
  /// </summary>
  /// <param name="T">
  /// The type of the argument that the referenced procedure will accept.
  /// </param>
  /// <remarks>
  /// This type is useful for defining callbacks or procedures that operate on a variable of type T,
  /// allowing for more flexible and reusable code.
  /// </remarks>
  TProcRef<T> = reference to procedure(var Arg: T);

  /// <summary>
  /// Represents a utility class for managing URL parameters and constructing query strings.
  /// </summary>
  /// <remarks>
  /// This class allows the addition of key-value pairs to construct a query string,
  /// which can be appended to a URL for HTTP requests. It provides overloads for adding
  /// various types of values, including strings, integers, booleans, doubles, and arrays.
  /// </remarks>
  TUrlParam = class
  private
    FValue: string;
    procedure Check(const Name: string);
    function GetValue: string;
  public
    /// <summary>
    /// Adds a string parameter to the query string.
    /// </summary>
    /// <param name="Name">
    /// The name of the parameter.
    /// </param>
    /// <param name="Value">
    /// The value of the parameter.
    /// </param>
    /// <returns>
    /// The current instance of <c>TUrlParam</c>, allowing for method chaining.
    /// </returns>
    function Add(const Name, Value: string): TUrlParam; overload; virtual;
    /// <summary>
    /// Adds an integer parameter to the query string.
    /// </summary>
    /// <param name="Name">
    /// The name of the parameter.
    /// </param>
    /// <param name="Value">
    /// The integer value of the parameter.
    /// </param>
    /// <returns>
    /// The current instance of <c>TUrlParam</c>, allowing for method chaining.
    /// </returns>
    function Add(const Name: string; Value: Integer): TUrlParam; overload; virtual;
    /// <summary>
    /// Adds an integer 64 parameter to the query string.
    /// </summary>
    /// <param name="Name">
    /// The name of the parameter.
    /// </param>
    /// <param name="Value">
    /// The integer 64 value of the parameter.
    /// </param>
    /// <returns>
    /// The current instance of <c>TUrlParam</c>, allowing for method chaining.
    /// </returns>
    function Add(const Name: string; Value: Int64): TUrlParam; overload; virtual;
    /// <summary>
    /// Adds a boolean parameter to the query string.
    /// </summary>
    /// <param name="Name">
    /// The name of the parameter.
    /// </param>
    /// <param name="Value">
    /// The boolean value of the parameter. It will be converted to "true" or "false".
    /// </param>
    /// <returns>
    /// The current instance of <c>TUrlParam</c>, allowing for method chaining.
    /// </returns>
    function Add(const Name: string; Value: Boolean): TUrlParam; overload; virtual;
    /// <summary>
    /// Adds a double parameter to the query string.
    /// </summary>
    /// <param name="Name">
    /// The name of the parameter.
    /// </param>
    /// <param name="Value">
    /// The double value of the parameter.
    /// </param>
    /// <returns>
    /// The current instance of <c>TUrlParam</c>, allowing for method chaining.
    /// </returns>
    function Add(const Name: string; Value: Double): TUrlParam; overload; virtual;
    /// <summary>
    /// Adds an array of string values to the query string as a single parameter.
    /// </summary>
    /// <param name="Name">
    /// The name of the parameter.
    /// </param>
    /// <param name="Value">
    /// The array of string values to be added, joined by commas.
    /// </param>
    /// <returns>
    /// The current instance of <c>TUrlParam</c>, allowing for method chaining.
    /// </returns>
    function Add(const Name: string; Value: TArray<string>): TUrlParam; overload; virtual;
    /// <summary>
    /// Gets the constructed query string with all parameters.
    /// </summary>
    /// <returns>
    /// The query string, prefixed with a question mark ("?") if parameters are present.
    /// </returns>
    property Value: string read GetValue;
    constructor Create; virtual;
  end;

  /// <summary>
  /// Represents the parameters for listing.
  /// This class provides the functionality to control pagination and set limits on the number of objects retrieved.
  /// It is useful for efficiently managing and navigating through large sets of objects.
  /// </summary>
  TUrlPaginationParams = class(TUrlParam)
  public
    /// <summary>
    /// A limit on the number of objects to be returned. Limit can range between 1 and 100,
    /// and the default is 20.
    /// </summary>
    /// <param name="Value">The limit on the number of objects, ranging from 1 to 100.</param>
    /// <returns>The instance of TUrlPaginationParams for method chaining.</returns>
    function Limit(const Value: Integer): TUrlPaginationParams;
    /// <summary>
    /// A cursor for use in pagination. after is an object ID that defines your place in the list.
    /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
    /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
    /// </summary>
    /// <param name="Value">The object ID that defines the starting point for pagination.</param>
    /// <returns>The instance of TUrlPaginationParams for method chaining.</returns>
    function After(const Value: string): TUrlPaginationParams;
  end;

  /// <summary>
  /// Represents the advanced parameters for listing and filtering data.
  /// This class extends <see cref="TUrlPaginationParams"/> to provide additional functionality for
  /// sorting and navigating through paginated data.
  /// It is designed to manage more complex scenarios where both pagination and sorting are required.
  /// </summary>
  TUrlAdvancedParams = class(TUrlPaginationParams)
  public
    /// <summary>
    /// Specifies the sort order of the retrieved objects based on their creation timestamp.
    /// This allows you to customize the order in which objects are returned, either in ascending
    /// or descending order.
    /// </summary>
    /// <param name="Value">"Asc" for ascending order or "Desc" for descending order.</param>
    /// <returns>The instance of TUrlAdvancedParams for method chaining.</returns>
    function Order(const Value: string): TUrlAdvancedParams;
    /// <summary>
    /// A cursor for use in pagination. This parameter allows you to specify an object ID that defines
    /// your place in the list when navigating to the previous set of results.
    /// For instance, if you receive a list of objects starting with obj_foo, a subsequent call can
    /// include before=obj_foo to fetch the previous page of results.
    /// </summary>
    /// <param name="Value">The object ID that defines the ending point for pagination.</param>
    /// <returns>The instance of TUrlAdvancedParams for method chaining.</returns>
    function Before(const Value: string): TUrlAdvancedParams;
  end;

  /// <summary>
  /// Represents a utility class for managing JSON objects and constructing JSON structures dynamically.
  /// </summary>
  /// <remarks>
  /// This class provides methods to add, remove, and manipulate key-value pairs in a JSON object.
  /// It supports various data types, including strings, integers, booleans, dates, arrays, and nested JSON objects.
  /// </remarks>
  TJSONParam = class
  private
    FJSON: TJSONObject;
    FIsDetached: Boolean;
    procedure SetJSON(const Value: TJSONObject);
    function GetCount: Integer;
  public
    constructor Create; virtual;
    destructor Destroy; override;
    /// <summary>
    /// Adds a key-value pair to the JSON object, where the value is a string.
    /// </summary>
    /// <param name="Key">
    /// The key of the pair to add.
    /// </param>
    /// <param name="Value">
    /// The string value to associate with the key.
    /// </param>
    /// <returns>
    /// The current instance of <c>TJSONParam</c>, allowing for method chaining.
    /// </returns>
    function Add(const Key: string; const Value: string): TJSONParam; overload; virtual;
    /// <summary>
    /// Adds a key-value pair to the JSON object, where the value is an integer.
    /// </summary>
    /// <param name="Key">
    /// The key of the pair to add.
    /// </param>
    /// <param name="Value">
    /// The integer value to associate with the key.
    /// </param>
    /// <returns>
    /// The current instance of <c>TJSONParam</c>, allowing for method chaining.
    /// </returns>
    function Add(const Key: string; const Value: Integer): TJSONParam; overload; virtual;
    /// <summary>
    /// Adds a key-value pair to the JSON object, where the value is an integer 64.
    /// </summary>
    /// <param name="Key">
    /// The key of the pair to add.
    /// </param>
    /// <param name="Value">
    /// The integer value to associate with the key.
    /// </param>
    /// <returns>
    /// The current instance of <c>TJSONParam</c>, allowing for method chaining.
    /// </returns>
    function Add(const Key: string; const Value: Int64): TJSONParam; overload; virtual;
    /// <summary>
    /// Adds a key-value pair to the JSON object, where the value is an extended (floating-point number).
    /// </summary>
    /// <param name="Key">
    /// The key of the pair to add.
    /// </param>
    /// <param name="Value">
    /// The extended value to associate with the key.
    /// </param>
    /// <returns>
    /// The current instance of <c>TJSONParam</c>, allowing for method chaining.
    /// </returns>
    function Add(const Key: string; const Value: Extended): TJSONParam; overload; virtual;
    /// <summary>
    /// Adds a key-value pair to the JSON object, where the value is a boolean.
    /// </summary>
    /// <param name="Key">
    /// The key of the pair to add.
    /// </param>
    /// <param name="Value">
    /// The boolean value to associate with the key.
    /// </param>
    /// <returns>
    /// The current instance of <c>TJSONParam</c>, allowing for method chaining.
    /// </returns>
    function Add(const Key: string; const Value: Boolean): TJSONParam; overload; virtual;
    /// <summary>
    /// Adds a key-value pair to the JSON object, where the value is a date-time object.
    /// </summary>
    /// <param name="Key">
    /// The key of the pair to add.
    /// </param>
    /// <param name="Value">
    /// The date-time value to associate with the key.
    /// </param>
    /// <param name="Format">
    /// The format in which to serialize the date-time value. If not specified, a default format is used.
    /// </param>
    /// <returns>
    /// The current instance of <c>TJSONParam</c>, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// Converting local DateTime to universal time (UTC) and then formatting it.
    /// </remarks>
    function Add(const Key: string; const Value: TDateTime; Format: string): TJSONParam; overload; virtual;
    /// <summary>
    /// Adds a key-value pair to the JSON object, where the value is another JSON object.
    /// </summary>
    /// <param name="Key">
    /// The key of the pair to add.
    /// </param>
    /// <param name="Value">
    /// The JSON object to associate with the key.
    /// </param>
    /// <returns>
    /// The current instance of <c>TJSONParam</c>, allowing for method chaining.
    /// </returns>
    function Add(const Key: string; const Value: TJSONValue): TJSONParam; overload; virtual;
    /// <summary>
    /// Adds a key-value pair to the JSON object, where the value is a TJSONParam object.
    /// </summary>
    /// <param name="Key">
    /// The key of the pair to add.
    /// </param>
    /// <param name="Value">
    /// The JSON object to associate with the key.
    /// </param>
    /// <returns>
    /// The current instance of <c>TJSONParam</c>, allowing for method chaining.
    /// </returns>
    function Add(const Key: string; const Value: TJSONParam): TJSONParam; overload; virtual;
    /// <summary>
    /// Adds a key-value pair to the JSON object, where the value is an array of string.
    /// </summary>
    /// <param name="Key">
    /// The key of the pair to add.
    /// </param>
    /// <param name="Value">
    /// The string value to associate with the key.
    /// </param>
    /// <returns>
    /// The current instance of <c>TJSONParam</c>, allowing for method chaining.
    /// </returns>
    function Add(const Key: string; Value: TArray<string>): TJSONParam; overload; virtual;
    /// <summary>
    /// Adds a key-value pair to the JSON object, where the value is an array of integer.
    /// </summary>
    /// <param name="Key">
    /// The key of the pair to add.
    /// </param>
    /// <param name="Value">
    /// An array of string to associate with the key.
    /// </param>
    /// <returns>
    /// The current instance of <c>TJSONParam</c>, allowing for method chaining.
    /// </returns>
    function Add(const Key: string; Value: TArray<Integer>): TJSONParam; overload; virtual;
    /// <summary>
    /// Adds a key-value pair to the JSON object, where the value is an array of integer 64.
    /// </summary>
    /// <param name="Key">
    /// The key of the pair to add.
    /// </param>
    /// <param name="Value">
    /// An array of string to associate with the key.
    /// </param>
    /// <returns>
    /// The current instance of <c>TJSONParam</c>, allowing for method chaining.
    /// </returns>
    function Add(const Key: string; Value: TArray<Int64>): TJSONParam; overload; virtual;
    /// <summary>
    /// Adds a key-value pair to the JSON object, where the value is an array of extended.
    /// </summary>
    /// <param name="Key">
    /// The key of the pair to add.
    /// </param>
    /// <param name="Value">
    /// An array of integer to associate with the key.
    /// </param>
    /// <returns>
    /// The current instance of <c>TJSONParam</c>, allowing for method chaining.
    /// </returns>
    function Add(const Key: string; Value: TArray<Extended>): TJSONParam; overload; virtual;
    /// <summary>
    /// Adds a key-value pair to the JSON object, where the value is an array of JSON object.
    /// </summary>
    /// <param name="Key">
    /// The key of the pair to add.
    /// </param>
    /// <param name="Value">
    /// An array of TJSONValue to associate with the key.
    /// </param>
    /// <returns>
    /// The current instance of <c>TJSONParam</c>, allowing for method chaining.
    /// </returns>
    function Add(const Key: string; Value: TArray<TJSONValue>): TJSONParam; overload; virtual;
    /// <summary>
    /// Clears all key-value pairs from the JSON object.
    /// </summary>
    procedure Clear; virtual;
    /// <summary>
    /// Removes a key-value pair from the JSON object by its key.
    /// </summary>
    /// <param name="Key">
    /// The key of the pair to remove.
    /// </param>
    procedure Delete(const Key: string); virtual;
    /// <summary>
    /// Detaches the internal JSON object from the <c>TJSONParam</c> instance.
    /// </summary>
    /// <remarks>
    /// After detaching, the internal JSON object is no longer managed by the <c>TJSONParam</c> instance.
    /// It becomes the caller's responsibility to free the detached object.
    /// </remarks>
    /// <remarks>
    /// Used during the creation of transient instances that must be deallocated immediately after their
    /// JSON representation is finalized.
    /// <para>
    /// These instances are exclusively maintained and are not shared among multiple clients.
    /// </para>
    /// </remarks>
    function Detach: TJSONObject;
    /// <summary>
    /// Gets or creates a JSON object associated with the specified key.
    /// </summary>
    /// <param name="Name">
    /// The key to look for or create.
    /// </param>
    /// <returns>
    /// A JSON object associated with the specified key.
    /// </returns>
    function GetOrCreateObject(const Name: string): TJSONObject;
    /// <summary>
    /// Gets or creates a JSON value of a specified type associated with the given key.
    /// </summary>
    /// <typeparam name="T">
    /// The type of the JSON value to retrieve or create. It must derive from <c>TJSONValue</c>
    /// and have a parameterless constructor.
    /// </typeparam>
    /// <param name="Name">
    /// The key to look for or create in the JSON object.
    /// </param>
    /// <returns>
    /// The JSON value associated with the specified key, creating a new one if it does not exist.
    /// </returns>
    function GetOrCreate<T: TJSONValue, constructor>(const Name: string): T;
    /// <summary>
    /// Converts the JSON object into a compact JSON string.
    /// </summary>
    /// <param name="FreeObject">
    /// Specifies whether the JSON object should be freed after conversion.
    /// </param>
    /// <returns>
    /// A compact JSON string.
    /// </returns>
    function ToJsonString(FreeObject: Boolean = False): string; virtual;
    /// <summary>
    /// Converts the JSON object into a formatted string.
    /// </summary>
    /// <param name="FreeObject">
    /// Specifies whether the JSON object should be freed after conversion.
    /// </param>
    /// <returns>
    /// A formatted JSON string.
    /// </returns>
    function ToFormat(FreeObject: Boolean = False): string;
    /// <summary>
    /// Converts the JSON object into an array of key-value string pairs.
    /// </summary>
    /// <returns>
    /// An array of <c>TPair</c>, where each pair contains the key as a string
    /// and the associated value converted to a string.
    /// </returns>
    function ToStringPairs: TArray<TPair<string, string>>;
    /// <summary>
    /// Converts the JSON object into a string stream for use with file or network operations.
    /// </summary>
    /// <returns>
    /// A <c>TStringStream</c> containing the JSON object as a string.
    /// The stream must be freed by the caller after use.
    /// </returns>
    function ToStream: TStringStream;
    /// <summary>
    /// Gets the number of key-value pairs in the JSON object.
    /// </summary>
    property Count: Integer read GetCount;
    /// <summary>
    /// Gets or sets the internal JSON object.
    /// </summary>
    property JSON: TJSONObject read FJSON write SetJSON;
  end;

  /// <summary>
  /// Represents a base class for all classes obtained after deserialization.
  /// </summary>
  /// <remarks>
  /// This class is designed to store the raw JSON string returned by the API,
  /// allowing applications to access the original JSON response if needed.
  /// </remarks>
  TJSONFingerprint = class
  private
    FJSONResponse: string;
  public
    /// <summary>
    /// Gets or sets the raw JSON string returned by the API.
    /// </summary>
    /// <remarks>
    /// Typically, the API returns a single JSON string, which is stored in this property.
    /// </remarks>
    property JSONResponse: string read FJSONResponse write FJSONResponse;
  end;

  /// <summary>
  /// A custom JSON interceptor for handling string-to-string conversions in JSON serialization and deserialization.
  /// </summary>
  /// <remarks>
  /// This interceptor is designed to override the default behavior of JSON serialization
  /// and deserialization for string values, ensuring compatibility with specific formats
  /// or custom requirements.
  /// </remarks>
  TJSONInterceptorStringToString = class(TJSONInterceptor)
  protected
    /// <summary>
    /// Provides runtime type information (RTTI) for enhanced handling of string values.
    /// </summary>
    RTTI: TRttiContext;
  public
    constructor Create; reintroduce;
  end;

  /// <summary>
  /// Represents a generic key-value parameter manager.
  /// </summary>
  /// <remarks>
  /// This class allows storing and retrieving various types of parameters as key-value pairs.
  /// It supports basic types (integers, strings, booleans, floating-point numbers), objects,
  /// as well as arrays of these types.
  /// </remarks>
  /// <example>
  ///   <code>
  ///     var Params: TParameters;
  ///     begin
  ///       Params := TParameters.Create;
  ///       Params.Add('Limit', 100)
  ///             .Add('Order', 'Asc')
  ///             .Add('IsEnabled', True);
  ///       if Params.Exists('Limit') then
  ///         ShowMessage(IntToStr(Params.GetInteger('Limit')));
  ///       Params.Free;
  ///     end;
  ///   </code>
  /// </example>
  TParameters = class
  private
    FParams: TDictionary<string, TValue>;
  public
    constructor Create;
    destructor Destroy; override;
    function Add(const AKey: string; const AValue: Integer): TParameters; overload;
    function Add(const AKey: string; const AValue: Int64): TParameters; overload;
    function Add(const AKey: string; const AValue: string): TParameters; overload;
    function Add(const AKey: string; const AValue: Single): TParameters; overload;
    function Add(const AKey: string; const AValue: Double): TParameters; overload;
    function Add(const AKey: string; const AValue: Boolean): TParameters; overload;
    function Add(const AKey: string; const AValue: TObject): TParameters; overload;
    function Add(const AKey: string; const AValue: TJSONObject): TParameters; overload;
    function Add(const AKey: string; const AValue: TArray<string>): TParameters; overload;
    function Add(const AKey: string; const AValue: TArray<Integer>): TParameters; overload;
    function Add(const AKey: string; const AValue: TArray<Int64>): TParameters; overload;
    function Add(const AKey: string; const AValue: TArray<Single>): TParameters; overload;
    function Add(const AKey: string; const AValue: TArray<Double>): TParameters; overload;
    function Add(const AKey: string; const AValue: TArray<Boolean>): TParameters; overload;
    function Add(const AKey: string; const AValue: TArray<TObject>): TParameters; overload;
    function Add(const AKey: string; const AValue: TArray<TJSONObject>): TParameters; overload;

    function GetInteger(const AKey: string; const ADefault: Integer = 0): Integer;
    function GetInt64(const AKey: string; const ADefault: Integer = 0): Integer;
    function GetString(const AKey: string; const ADefault: string = ''): string;
    function GetSingle(const AKey: string; const ADefault: Single = 0.0): Double;
    function GetDouble(const AKey: string; const ADefault: Double = 0.0): Double;
    function GetBoolean(const AKey: string; const ADefault: Boolean = False): Boolean;
    function GetObject(const AKey: string; const ADefault: TObject = nil): TObject;
    function GetJSONObject(const AKey: string): TJSONObject;

    function GetArrayString(const AKey: string): TArray<string>;
    function GetArrayInteger(const AKey: string): TArray<Integer>;
    function GetArrayInt64(const AKey: string): TArray<Int64>;
    function GetArraySingle(const AKey: string): TArray<Single>;
    function GetArrayDouble(const AKey: string): TArray<Double>;
    function GetArrayBoolean(const AKey: string): TArray<Boolean>;
    function GetArrayObject(const AKey: string): TArray<TObject>;
    function GetArrayJSONObject(const AKey: string): TArray<TJSONObject>;
    function GetJSONArray(const AKey: string): TJSONArray;

    function Exists(const AKey: string): Boolean;
    procedure ProcessParam(const AKey: string; ACallback: TProc<TValue>);
  end;

implementation

uses
  System.DateUtils, System.NetEncoding;

{ TJSONInterceptorStringToString }

constructor TJSONInterceptorStringToString.Create;
begin
  inherited Create;
  ConverterType := ctString;
  ReverterType := rtString;
end;

{ Fetch }

type
  Fetch<T> = class
    type
      TFetchProc = reference to procedure(const Element: T);
  public
    class procedure All(const Items: TArray<T>; Proc: TFetchProc);
  end;

{ Fetch<T> }

class procedure Fetch<T>.All(const Items: TArray<T>; Proc: TFetchProc);
var
  Item: T;
begin
  for Item in Items do
    Proc(Item);
end;

{ TUrlParam }

function TUrlParam.Add(const Name, Value: string): TUrlParam;
begin
  Check(Name);
//  var S := Format('%s=%s', [Name, Value]);
  var S := Format('%s=%s', [Name, TNetEncoding.URL.Encode(Value).Replace('+', '%20')]);
  if FValue.IsEmpty then
    FValue := S else
    FValue := FValue + '&' + S;
  Result := Self;
end;

function TUrlParam.Add(const Name: string; Value: Integer): TUrlParam;
begin
  Result := Add(Name, Value.ToString);
end;

function TUrlParam.Add(const Name: string; Value: Int64): TUrlParam;
begin
  Result := Add(Name, Value.ToString);
end;

function TUrlParam.Add(const Name: string; Value: Boolean): TUrlParam;
begin
  Result := Add(Name, BoolToStr(Value, true));
end;

function TUrlParam.Add(const Name: string; Value: Double): TUrlParam;
begin
  Result := Add(Name, Value.ToString);
end;

procedure TUrlParam.Check(const Name: string);
var
  Params: TArray<string>;
begin
  var Items := FValue.Split(['&']);
  FValue := EmptyStr;
  for var Item in Items do
    begin
      if not Item.StartsWith(Name + '=') then
        Params := Params + [Item];
    end;
  FValue := string.Join('&', Params);
end;

constructor TUrlParam.Create;
begin
  FValue := EmptyStr;
end;

function TUrlParam.GetValue: string;
var
  Params: TArray<string>;
begin
  var Items := FValue.Split(['&']);
  for var Item in Items do
    begin
      var SubStr := Item.Split(['=']);
      if Length(SubStr) <> 2 then
        raise Exception.CreateFmt('%s: Ivalid URL parameter.', [SubStr]);
      Params := Params + [
        TNetEncoding.URL.Encode(SubStr[0]).Replace('+', '%20') + '=' + SubStr[1] ];
    end;
  Result := string.Join('&', Params);
  if not Result.IsEmpty then
    Result := '?' + Result;
end;

function TUrlParam.Add(const Name: string; Value: TArray<string>): TUrlParam;
begin
  Result := Add(Name, string.Join(',', Value).Trim);
end;

{ TJSONParam }

function TJSONParam.Add(const Key, Value: string): TJSONParam;
begin
  Delete(Key);
  FJSON.AddPair(Key, Value);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: TJSONValue): TJSONParam;
begin
  Delete(Key);
  FJSON.AddPair(Key, Value);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: TJSONParam): TJSONParam;
begin
  {--- Note
     This line performs a deep clone of Value.JSON into the local JSON, which is
     generally suitable if you don't want the two TJSONParams to share the same
     references.
     - However, keep in mind that this operation can be costly for large
     objects and is not always necessary if you're certain not to modify or retain
     the same JSON instance in multiple places.
  }
  Add(Key, TJSONValue(Value.JSON.Clone));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: TDateTime; Format: string): TJSONParam;
begin
  if Format.IsEmpty then
    Format := DATE_TIME_FORMAT;
  {--- Converting local DateTime to universal time (UTC)  }
  Add(Key, FormatDateTime(Format, System.DateUtils.TTimeZone.local.ToUniversalTime(Value)));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: Boolean): TJSONParam;
begin
  Add(Key, TJSONBool.Create(Value));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: Integer): TJSONParam;
begin
  Add(Key, TJSONNumber.Create(Value));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: Extended): TJSONParam;
begin
  Add(Key, TJSONNumber.Create(Value));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<TJSONValue>): TJSONParam;
begin
  var JSONArray := TJSONArray.Create;
  Fetch<TJSONValue>.All(Value, JSONArray.AddElement);
  Add(Key, JSONArray);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<Int64>): TJSONParam;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item);
  Add(Key, JSONArray);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: Int64): TJSONParam;
begin
  Add(Key, TJSONNumber.Create(Value));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<Extended>): TJSONParam;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item);
  Add(Key, JSONArray);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<Integer>): TJSONParam;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item);
  Add(Key, JSONArray);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<string>): TJSONParam;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item);
  Add(Key, JSONArray);
  Result := Self;
end;

procedure TJSONParam.Clear;
begin
  if Assigned(FJSON) then
    FreeAndNil(FJSON);
  FJSON := TJSONObject.Create;
end;

constructor TJSONParam.Create;
begin
  FJSON := TJSONObject.Create;
  FIsDetached := False;
end;

procedure TJSONParam.Delete(const Key: string);
begin
  var Item := FJSON.RemovePair(Key);
  if Assigned(Item) then
    Item.Free;
end;

destructor TJSONParam.Destroy;
begin
  if Assigned(FJSON) then
    FJSON.Free;
  inherited;
end;

function TJSONParam.Detach: TJSONObject;
begin
  Assert(not FIsDetached, 'Detach has already been called on this instance of TJSONParam.');
  Result := JSON;
  JSON := nil;
  FIsDetached := True;

  {--- NOTE
     Creating an asynchronous task to release the TJSONParam instance after a short delay.
     This ensures that all current references to the object are completed before its release.
     The 30-millisecond delay provides sufficient time for the caller to retrieve the detached JSON.
     Using TThread.Queue to ensure the release occurs in the main thread context, thereby avoiding
     potential issues related to memory management in secondary threads.
  }

  var Task: ITask := TTask.Create(
    procedure()
    begin
      Sleep(30);
      TThread.Queue(nil,
      procedure
      begin
        Self.Free;
      end);
    end
  );
  Task.Start;
end;

function TJSONParam.GetCount: Integer;
begin
  Result := FJSON.Count;
end;

function TJSONParam.GetOrCreate<T>(const Name: string): T;
begin
  var ExistingValue := FJSON.GetValue(Name);
  if Assigned(ExistingValue) then
    begin
      if ExistingValue is T then
        Result := T(ExistingValue)
      else
        raise Exception.CreateFmt(
          'Incorrect JSON value type for key "%s". Expected: %s, Found: %s.',
          [Name, T.ClassName, ExistingValue.ClassName]);
    end
  else
    begin
      Result := T.Create;
      FJSON.AddPair(Name, Result);
    end;
end;

function TJSONParam.GetOrCreateObject(const Name: string): TJSONObject;
begin
  Result := GetOrCreate<TJSONObject>(Name);
end;

procedure TJSONParam.SetJSON(const Value: TJSONObject);
begin
  FJSON := Value;
end;

function TJSONParam.ToFormat(FreeObject: Boolean): string;
begin
  Result := FJSON.Format(4);
  if FreeObject then
    Free;
end;

function TJSONParam.ToJsonString(FreeObject: Boolean): string;
begin
  Result := FJSON.ToJSON;
  if FreeObject then
    Free;
end;

function TJSONParam.ToStream: TStringStream;
begin
  Result := TStringStream.Create;
  try
    Result.WriteString(ToJsonString);
    Result.Position := 0;
  except
    Result.Free;
    raise;
  end;
end;

function TJSONParam.ToStringPairs: TArray<TPair<string, string>>;
begin
  for var Pair in FJSON do
    Result := Result + [TPair<string, string>.Create(Pair.JsonString.Value, Pair.JsonValue.ToString)];
end;

{ TUrlAdvancedParams  }

function TUrlAdvancedParams.Before(const Value: string): TUrlAdvancedParams;
begin
  Result := TUrlAdvancedParams (Add('before', Value));
end;

function TUrlAdvancedParams.Order(const Value: string): TUrlAdvancedParams;
begin
  Result := TUrlAdvancedParams (Add('order', Value));
end;

{ TUrlPaginationParams }

function TUrlPaginationParams.After(const Value: string): TUrlPaginationParams;
begin
  Result := TUrlPaginationParams(Add('after', Value));
end;

function TUrlPaginationParams.Limit(const Value: Integer): TUrlPaginationParams;
begin
  Result := TUrlPaginationParams(Add('limit', Value));
end;

{ TParameters }

function TParameters.Add(const AKey: string;
  const AValue: Boolean): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, AValue);
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: Double): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, AValue);
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: Integer): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, AValue);
  Result := Self;
end;

function TParameters.Add(const AKey, AValue: string): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, AValue);
  Result := Self;
end;

constructor TParameters.Create;
begin
  inherited Create;
  FParams := TDictionary<string, TValue>.Create;
end;

destructor TParameters.Destroy;
begin
  FParams.Free;
  inherited;
end;

function TParameters.Exists(const AKey: string): Boolean;
begin
  Result := FParams.ContainsKey(AKey.ToLower)
end;

function TParameters.GetArrayBoolean(const AKey: string): TArray<Boolean>;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<TArray<Boolean>> then
    Result := LValue.AsType<TArray<Boolean>>
  else
    Result := [];
end;

function TParameters.GetArrayDouble(const AKey: string): TArray<Double>;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<TArray<Double>> then
    Result := LValue.AsType<TArray<Double>>
  else
    Result := [];
end;

function TParameters.GetArrayInt64(const AKey: string): TArray<Int64>;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<TArray<Int64>> then
    Result := LValue.AsType<TArray<Int64>>
  else
    Result := [];
end;

function TParameters.GetArrayInteger(const AKey: string): TArray<Integer>;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<TArray<Integer>> then
    Result := LValue.AsType<TArray<Integer>>
  else
    Result := [];
end;

function TParameters.GetArrayJSONObject(
  const AKey: string): TArray<TJSONObject>;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<TArray<TJSONObject>> then
    Result := LValue.AsType<TArray<TJSONObject>>
  else
    Result := nil;
end;

function TParameters.GetArrayObject(const AKey: string): TArray<TObject>;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<TArray<TObject>> then
    Result := LValue.AsType<TArray<TObject>>
  else
    Result := [];
end;

function TParameters.GetArraySingle(const AKey: string): TArray<Single>;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<TArray<Single>> then
    Result := LValue.AsType<TArray<Single>>
  else
    Result := [];
end;

function TParameters.GetArrayString(const AKey: string): TArray<string>;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<TArray<string>> then
    Result := LValue.AsType<TArray<string>>
  else
    Result := [];
end;

function TParameters.GetBoolean(const AKey: string;
  const ADefault: Boolean): Boolean;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<Boolean> then
    Result := LValue.AsBoolean
  else
    Result := ADefault;
end;

function TParameters.GetDouble(const AKey: string;
  const ADefault: Double): Double;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<Double> then
    Result := LValue.AsType<Double>
  else
    Result := ADefault;
end;

function TParameters.GetInt64(const AKey: string;
  const ADefault: Integer): Integer;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<Int64> then
    Result := LValue.AsInt64
  else
    Result := ADefault;
end;

function TParameters.GetInteger(const AKey: string;
  const ADefault: Integer): Integer;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<Integer> then
    Result := LValue.AsInteger
  else
    Result := ADefault;
end;

function TParameters.GetJSONArray(const AKey: string): TJSONArray;
begin
  Result := TJSONArray.Create;
  for var Item in GetArrayJSONObject(AKey) do
    Result.Add(Item);
end;

function TParameters.GetJSONObject(const AKey: string): TJSONObject;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<TJSONObject> then
    Result := LValue.AsType<TJSONObject>
  else
    Result := nil;
end;

function TParameters.GetObject(const AKey: string;
  const ADefault: TObject): TObject;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsObject then
    Result := LValue.AsObject
  else
    Result := ADefault;
end;

function TParameters.GetSingle(const AKey: string;
  const ADefault: Single): Double;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<Single> then
    Result := LValue.AsType<Single>
  else
    Result := ADefault;
end;

function TParameters.GetString(const AKey, ADefault: string): string;
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) and LValue.IsType<string> then
    Result := LValue.AsString
  else
    Result := ADefault;
end;

procedure TParameters.ProcessParam(const AKey: string;
  ACallback: TProc<TValue>);
var
  LValue: TValue;
begin
  if FParams.TryGetValue(AKey.ToLower, LValue) then
    ACallback(LValue);
end;

function TParameters.Add(const AKey: string;
  const AValue: TArray<string>): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, TValue.From<TArray<string>>(AValue));
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: TArray<Integer>): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, TValue.From<TArray<Integer>>(AValue));
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: TArray<Double>): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, TValue.From<TArray<Double>>(AValue));
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: TArray<Boolean>): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, TValue.From<TArray<Boolean>>(AValue));
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: TObject): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, AValue);
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: TArray<Single>): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, TValue.From<TArray<Single>>(AValue));
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: Single): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, AValue);
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: TArray<Int64>): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, TValue.From<TArray<Int64>>(AValue));
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: Int64): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, AValue);
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: TArray<TObject>): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, TValue.From<TArray<TObject>>(AValue));
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: TJSONObject): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, AValue);
  Result := Self;
end;

function TParameters.Add(const AKey: string;
  const AValue: TArray<TJSONObject>): TParameters;
begin
  FParams.AddOrSetValue(AKey.ToLower, TValue.From<TArray<TJSONObject>>(AValue));
  Result := Self;
end;

end.

unit GenAI.API;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

(*
  --- NOTE ---
  The  GenAI.HttpClientInterface  unit  defines  an  IHttpClientAPI  interface, which
  allows  for decoupling  the specific implementation  of  the HTTP  client used  for
  web requests. This introduces  an abstraction  that  enhances flexibility, improves
  testability, and simplifies code maintenance.

  The IHttpClientAPI interface  ensures that  client code can interact  with  the web
  without  being  dependent  on a specific class, thus  facilitating  the replacement
  or modification  of the  underlying  HTTP implementation  details without impacting
  the rest  of  the application. It also  enables  easy mocking  during unit testing,
  offering the ability to test  HTTP request behaviors in an isolated  and controlled
  manner.

  This approach adheres to the SOLID principles of dependency inversion, contributing
  to a robust, modular, and adaptable software architecture.
*)

interface

uses
  System.SysUtils, System.Classes, System.Net.HttpClient, System.Net.URLClient,
  System.Net.Mime, System.JSON, GenAI.API.Params, GenAI.API.Utils, GenAI.Errors,
  GenAI.Exceptions, GenAI.HttpClientInterface, GenAI.HttpClientAPI, GenAI.Monitoring;

type
  /// <summary>
  /// Represents a delegate function for parsing a response string into a strongly-typed object.
  /// </summary>
  /// <typeparam name="T">
  /// The type of the object to be returned by the parser function.
  /// This type must be a class with a parameterless constructor.
  /// </typeparam>
  /// <param name="ResponseText">
  /// A string containing the API response data to be parsed.
  /// </param>
  /// <returns>
  /// An instance of type <c>T</c> created from the parsed <c>ResponseText</c>.
  /// </returns>
  /// <remarks>
  /// The delegate provides a flexible mechanism for converting API response strings
  /// (usually in JSON format) into strongly-typed objects. It is commonly used for
  /// deserialization processes in HTTP client operations.
  /// </remarks>
  TParserMethod<T: class, constructor> = reference to function(const ResponseText: string): T;

  /// <summary>
  /// Represents the configuration settings for the GenAI API.
  /// </summary>
  /// <remarks>
  /// This class provides properties and methods to manage the API key, base URL,
  /// organization identifier, and custom headers for communicating with the GenAI API.
  /// It also includes utility methods for building headers and endpoint URLs.
  /// </remarks>
  TGenAIConfiguration = class
  const
    /// <summary>
    /// The default base URL for the GenAI API.
    /// </summary>
    URL_BASE = 'https://api.openai.com/v1';
  private
    FAPIKey: string;
    FBaseUrl: string;
    FOrganization: string;
    FCustomHeaders: TNetHeaders;
    procedure SetBaseUrl(const Value: string);
    procedure SetOrganization(const Value: string);
    procedure SetCustomHeaders(const Value: TNetHeaders);
    procedure SetAPIKey(const Value: string);
    procedure VerifyApiSettings;
    procedure ResetCustomHeader;
  protected
    /// <summary>
    /// Retrieves the headers required for API requests.
    /// </summary>
    /// <returns>
    /// A list of headers including authorization and optional organization information.
    /// </returns>
    function BuildHeaders: TNetHeaders; virtual;
    /// <summary>
    /// Builds headers specific to JSON-based API requests.
    /// </summary>
    /// <returns>
    /// A list of headers including JSON content-type and authorization details.
    /// </returns>
    function BuildJsonHeaders: TNetHeaders; virtual;
    /// <summary>
    /// Constructs the full URL for a specific API endpoint.
    /// </summary>
    /// <param name="Endpoint">
    /// The relative endpoint path (e.g. "models").
    /// </param>
    /// <returns>
    /// The full URL including the base URL and endpoint.
    /// </returns>
    function BuildUrl(const Endpoint: string): string; overload; virtual;
    /// <summary>
    /// Constructs the full URL for a specific API endpoint.
    /// </summary>
    /// <param name="Endpoint">
    /// The relative endpoint path (e.g. "models").
    /// </param>
    /// <param name="Parameters">
    /// e.g. "?param1=val1&param2=val2...."
    /// </param>
    /// <returns>
    /// The full URL including the base URL and endpoint.
    /// </returns>
    function BuildUrl(const Endpoint, Parameters: string): string; overload; virtual;
  public
    constructor Create; overload;
    /// <summary>
    /// The API key used for authentication.
    /// </summary>
    property APIKey: string read FAPIKey write SetAPIKey;
    /// <summary>
    /// The base URL for API requests.
    /// </summary>
    property BaseUrl: string read FBaseUrl write SetBaseUrl;
    /// <summary>
    /// The organization identifier used for the API.
    /// </summary>
    property Organization: string read FOrganization write SetOrganization;
    /// <summary>
    /// Custom headers to include in API requests.
    /// </summary>
    property CustomHeaders: TNetHeaders read FCustomHeaders write SetCustomHeaders;
  end;

  /// <summary>
  /// Handles HTTP requests and responses for the GenAI API.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TGenAIConfiguration</c> and provides a mechanism to
  /// manage HTTP client interactions for the API, including configuration and request execution.
  /// </remarks>
  TApiHttpHandler = class(TGenAIConfiguration)
  private
    /// <summary>
    /// The HTTP client interface used for making API calls.
    /// </summary>
    FHttpClient: IHttpClientAPI;
  public
    constructor Create;
    /// <summary>
    /// The HTTP client used to send requests to the API.
    /// </summary>
    /// <value>
    /// An instance of a class implementing <c>IHttpClientAPI</c>.
    /// </value>
    property HttpClient: IHttpClientAPI read FHttpClient write FHttpClient;
  end;

  /// <summary>
  /// Manages and processes errors from the GenAI API responses.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TApiHttpHandler</c> and provides error-handling capabilities
  /// by parsing error data and raising appropriate exceptions.
  /// </remarks>
  TApiDeserializer = class(TApiHttpHandler)
  class var Metadata: ICustomFieldsPrepare;
  protected
    /// <summary>
    /// Parses the error data from the API response.
    /// </summary>
    /// <param name="Code">
    /// The HTTP status code returned by the API.
    /// </param>
    /// <param name="ResponseText">
    /// The response body containing error details.
    /// </param>
    /// <exception cref="GenAIAPIException">
    /// Raised if the error response cannot be parsed or contains invalid data.
    /// </exception>
    procedure DeserializeErrorData(const Code: Int64; const ResponseText: string); virtual;
    /// <summary>
    /// Raises an exception corresponding to the API error code.
    /// </summary>
    /// <param name="Code">
    /// The HTTP status code returned by the API.
    /// </param>
    /// <param name="Error">
    /// The deserialized error object containing error details.
    /// </param>
    procedure RaiseError(Code: Int64; Error: TErrorCore); virtual;
    /// <summary>
    /// Deserializes the API response into a strongly typed object.
    /// </summary>
    /// <param name="T">
    /// The type of the object to deserialize into. It must be a class with a parameterless constructor.
    /// </param>
    /// <param name="Code">
    /// The HTTP status code of the API response.
    /// </param>
    /// <param name="ResponseText">
    /// The response body as a JSON string.
    /// </param>
    /// <returns>
    /// A deserialized object of type <c>T</c>.
    /// </returns>
    /// <exception cref="GenAIInvalidResponseError">
    /// Raised if the response is non-compliant or deserialization fails.
    /// </exception>
    function Deserialize<T: class, constructor>(const Code: Int64; const ResponseText: string): T;
  public
    class constructor Create;
    /// <summary>
    /// Deserializes the API response into a strongly typed object.
    /// </summary>
    /// <param name="T">
    /// The type of the object to deserialize into. It must be a class with a parameterless constructor.
    /// </param>
    /// <param name="ResponseText">
    /// The response body as a JSON string.
    /// </param>
    /// <returns>
    /// A deserialized object of type <c>T</c>.
    /// </returns>
    /// <exception cref="GenAIInvalidResponseError">
    /// Raised if the response is non-compliant or deserialization fails.
    /// </exception>
    class function Parse<T: class, constructor>(const Value: string): T;
  end;

  /// <summary>
  /// Provides a high-level interface for interacting with the GenAI API.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TApiDeserializer</c> and includes methods for making HTTP requests to
  /// the GenAI API. It supports various HTTP methods, including GET, POST, PATCH, and DELETE,
  /// as well as handling file uploads and downloads. The API key and other configuration settings
  /// are inherited from the <c>TGenAIConfiguration</c> class.
  /// </remarks>
  TGenAIAPI = class(TApiDeserializer)
  private
    function MockJsonResponse(const FieldName: string; Response: TStringStream): string;
    function MockJsonFile(const FieldName: string; Response: TStringStream): string;
  public
    /// <summary>
    /// Initializes a new instance of the <c>TGenAIAPI</c> class with an API key.
    /// </summary>
    /// <param name="AAPIKey">
    /// The API key used for authenticating requests to the GenAI API.
    /// </param>
    constructor Create(const AAPIKey: string); overload;
    /// <summary>
    /// Sends a GET request to the specified API endpoint and returns a strongly typed object.
    /// </summary>
    /// <typeparam name="TResult">
    /// The type of the response object to deserialize into.
    /// </typeparam>
    /// <param name="Endpoint">
    /// The relative endpoint to send the GET request to (e.g., "models").
    /// </param>
    /// <returns>
    /// A deserialized object of type <c>TResult</c> containing the API response.
    /// </returns>
    /// <exception cref="GenAIInvalidResponseError">
    /// Raised if the response cannot be deserialized or is non-compliant.
    /// </exception>
    function Get<TResult: class, constructor>(const Endpoint: string): TResult; overload;
    /// <summary>
    /// Sends a GET request with parameters and returns a strongly typed object.
    /// </summary>
    /// <typeparam name="TResult">
    /// The type of the response object to deserialize into.
    /// </typeparam>
    /// <typeparam name="TParams">
    /// The type of the parameters object for the request.
    /// </typeparam>
    /// <param name="Endpoint">
    /// The relative endpoint to send the GET request to.
    /// </param>
    /// <param name="ParamProc">
    /// A callback procedure to configure the request parameters.
    /// </param>
    /// <returns>
    /// A deserialized object of type <c>TResult</c> containing the API response.
    /// </returns>
    /// <exception cref="GenAIInvalidResponseError">
    /// Raised if the response cannot be deserialized or is non-compliant.
    /// </exception>
    function Get<TResult: class, constructor; TParams: TUrlParam>(const Endpoint: string; ParamProc: TProc<TParams>): TResult; overload;
    /// <summary>
    /// Sends a GET request to retrieve a file from the specified API endpoint.
    /// </summary>
    /// <param name="Endpoint">
    /// The relative endpoint to send the GET request to.
    /// </param>
    /// <param name="Response">
    /// A stream where the file data will be written.
    /// </param>
    /// <returns>
    /// The HTTP status code of the API response.
    /// </returns>
    function GetFile(const Endpoint: string; Response: TStream): Integer; overload;
    /// <summary>
    /// Sends a GET request to retrieve a file and deserializes it into a strongly typed object.
    /// <para>
    /// - The result data is encoded in Base64 format.
    /// </para>
    /// </summary>
    /// <typeparam name="TResult">
    /// The type of the object to deserialize into.
    /// </typeparam>
    /// <param name="Endpoint">
    /// The relative endpoint to send the GET request to.
    /// </param>
    /// <param name="JSONFieldName">
    /// The name of the JSON field containing the file data.
    /// </param>
    /// <returns>
    /// A deserialized object of type <c>TResult</c> containing the file data.
    /// </returns>
    function GetFile<TResult: class, constructor>(const Endpoint: string; const JSONFieldName: string = 'data'): TResult; overload;
    /// <summary>
    /// Sends a DELETE request to the specified API endpoint and returns a strongly typed object.
    /// </summary>
    /// <typeparam name="TResult">
    /// The type of the response object to deserialize into.
    /// </typeparam>
    /// <param name="Endpoint">
    /// The relative endpoint to send the DELETE request to.
    /// </param>
    /// <returns>
    /// A deserialized object of type <c>TResult</c> containing the API response.
    /// </returns>
    function Delete<TResult: class, constructor>(const Endpoint: string): TResult; overload;
    /// <summary>
    /// Sends a POST request with parameters and streams the response.
    /// </summary>
    /// <typeparam name="TParams">
    /// The type of the parameters object for the request.
    /// </typeparam>
    /// <param name="Endpoint">
    /// The relative endpoint to send the POST request to.
    /// </param>
    /// <param name="ParamProc">
    /// A callback procedure to configure the request parameters.
    /// </param>
    /// <param name="Response">
    /// A string stream where the response will be written.
    /// </param>
    /// <param name="Event">
    /// A callback procedure for handling the received data during streaming.
    /// </param>
    /// <returns>
    /// A boolean value indicating whether the request was successful.
    /// </returns>
    /// <exception cref="GenAIInvalidResponseError">
    /// Raised if the response cannot be deserialized or is non-compliant.
    /// </exception>
    function Post<TParams: TJSONParam>(const Endpoint: string; ParamProc: TProc<TParams>; Response: TStringStream; Event: TReceiveDataCallback): Boolean; overload;
    /// <summary>
    /// Sends a POST request with parameters and returns a strongly typed object.
    /// </summary>
    /// <typeparam name="TResult">
    /// The type of the response object to deserialize into.
    /// </typeparam>
    /// <typeparam name="TParams">
    /// The type of the parameters object for the request.
    /// </typeparam>
    /// <param name="Endpoint">
    /// The relative endpoint to send the POST request to.
    /// </param>
    /// <param name="ParamProc">
    /// A callback procedure to configure the request parameters.
    /// </param>
    /// <param name="RawByteFieldName">
    /// An optional field name to encode raw byte data into.
    /// </param>
    /// <returns>
    /// A deserialized object of type <c>TResult</c> containing the API response.
    /// </returns>
    /// <exception cref="GenAIInvalidResponseError">
    /// Raised if the response cannot be deserialized or is non-compliant.
    /// </exception>
    function Post<TResult: class, constructor; TParams: TJSONParam>(const Endpoint: string; ParamProc: TProc<TParams>; const RawByteFieldName: string = ''): TResult; overload;
    /// <summary>
    /// Sends a POST request to the specified API endpoint.
    /// </summary>
    /// <typeparam name="TResult">
    /// The type of the response object to deserialize into.
    /// </typeparam>
    /// <param name="Endpoint">
    /// The relative endpoint to send the POST request to.
    /// </param>
    /// <returns>
    /// A deserialized object of type <c>TResult</c> containing the API response.
    /// </returns>
    function Post<TResult: class, constructor>(const Endpoint: string): TResult; overload;
    /// <summary>
    /// Sends a PATCH request with parameters and returns a strongly typed object.
    /// </summary>
    /// <typeparam name="TResult">
    /// The type of the response object to deserialize into.
    /// </typeparam>
    /// <typeparam name="TParams">
    /// The type of the parameters object for the request.
    /// </typeparam>
    /// <param name="Endpoint">
    /// The relative endpoint to send the PATCH request to.
    /// </param>
    /// <param name="ParamProc">
    /// A callback procedure to configure the request parameters.
    /// </param>
    /// <returns>
    /// A deserialized object of type <c>TResult</c> containing the API response.
    /// </returns>
    function Patch<TResult: class, constructor; TParams: TJSONParam>(const Endpoint: string; ParamProc: TProc<TParams>): TResult; overload;
    /// <summary>
    /// Sends a POST request with multipart form data and returns a strongly typed object.
    /// </summary>
    /// <typeparam name="TResult">
    /// The type of the response object to deserialize into.
    /// </typeparam>
    /// <typeparam name="TParams">
    /// The type of the multipart form data parameters object.
    /// </typeparam>
    /// <param name="Endpoint">
    /// The relative endpoint to send the POST request to.
    /// </param>
    /// <param name="ParamProc">
    /// A callback procedure to configure the multipart form data parameters.
    /// </param>
    /// <returns>
    /// A deserialized object of type <c>TResult</c> containing the API response.
    /// </returns>
    /// <exception cref="GenAIInvalidResponseError">
    /// Raised if the response cannot be deserialized or is non-compliant.
    /// </exception>
    function PostForm<TResult: class, constructor; TParams: TMultipartFormData, constructor>(const Endpoint: string; ParamProc: TProc<TParams>): TResult; overload;
  end;

  /// <summary>
  /// Represents a specific route or logical grouping for the GenAI API.
  /// </summary>
  /// <remarks>
  /// This class allows associating a <c>TGenAIAPI</c> instance with specific routes or
  /// endpoints, providing an organized way to manage API functionality.
  /// </remarks>
  TGenAIRoute = class
  private
    /// <summary>
    /// The GenAI API instance associated with this route.
    /// </summary>
    FAPI: TGenAIAPI;
    procedure SetAPI(const Value: TGenAIAPI);
  protected
    procedure HeaderCustomize; virtual;
  public
    /// <summary>
    /// Initializes a new instance of the <c>TGenAIRoute</c> class with the given API instance.
    /// </summary>
    /// <param name="AAPI">
    /// The <c>TGenAIAPI</c> instance to associate with the route.
    /// </param>
    property API: TGenAIAPI read FAPI write SetAPI;
    /// <summary>
    /// The GenAI API instance associated with this route.
    /// </summary>
    constructor CreateRoute(AAPI: TGenAIAPI); reintroduce;
  end;

var
  MetadataAsObject: Boolean = False;

implementation

uses
  System.StrUtils, REST.Json, GenAI.NetEncoding.Base64, System.DateUtils;

{TGenAIAPI}

constructor TGenAIAPI.Create(const AAPIKey: string);
begin
  Create;
  APIKey := AAPIKey;
end;

function TGenAIAPI.Post<TResult, TParams>(const Endpoint: string; ParamProc: TProc<TParams>;
  const RawByteFieldName: string): TResult;
begin
  Monitoring.Inc;
  var Response := TStringStream.Create('', TEncoding.UTF8);
  var Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    var Code := HttpClient.Post(BuildUrl(Endpoint), Params.JSON, Response, BuildJsonHeaders, nil);
    case Code of
      200..299:
        begin
          if RawByteFieldName.IsEmpty then
            Result := Deserialize<TResult>(Code, Response.DataString) else
            {--- When a raw byte file is sent as the sole response }
            Result := Deserialize<TResult>(Code, MockJsonResponse(RawByteFieldName, Response));
        end;
      else
        Result := Deserialize<TResult>(Code, Response.DataString)
    end;
  finally
    Params.Free;
    Response.Free;
    ResetCustomHeader;
    Monitoring.Dec;
  end;
end;

function TGenAIAPI.Post<TParams>(const Endpoint: string; ParamProc: TProc<TParams>; Response: TStringStream; Event: TReceiveDataCallback): Boolean;
begin
  Monitoring.Inc;
  var Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    var Code := HttpClient.Post(BuildUrl(Endpoint), Params.JSON, Response, BuildJsonHeaders, Event);
    case Code of
      200..299:
        Result := True;
    else
      begin
        Result := False;
        var Recieved := TStringStream.Create;
        try
          Response.Position := 0;
          Recieved.LoadFromStream(Response);
          DeserializeErrorData(Code, Recieved.DataString);
        finally
          Recieved.Free;
        end;
      end;
    end;
  finally
    Params.Free;
    ResetCustomHeader;
    Monitoring.Dec;
  end;
end;

function TGenAIAPI.Post<TResult>(const Endpoint: string): TResult;
begin
  Monitoring.Inc;
  var Response := TStringStream.Create('', TEncoding.UTF8);
  try
    var Code := HttpClient.Post(BuildUrl(Endpoint), Response, BuildHeaders);
    Result := Deserialize<TResult>(Code, Response.DataString);
  finally
    Response.Free;
    ResetCustomHeader;
    Monitoring.Dec;
  end;
end;

function TGenAIAPI.Delete<TResult>(const Endpoint: string): TResult;
begin
  Monitoring.Inc;
  var Response := TStringStream.Create('', TEncoding.UTF8);
  try
    var Code := HttpClient.Delete(BuildUrl(Endpoint), Response, BuildHeaders);
    Result := Deserialize<TResult>(Code, Response.DataString);
  finally
    Response.Free;
    ResetCustomHeader;
    Monitoring.Dec;
  end;
end;

function TGenAIAPI.PostForm<TResult, TParams>(const Endpoint: string; ParamProc: TProc<TParams>): TResult;
begin
  Monitoring.Inc;
  var Response := TStringStream.Create('', TEncoding.UTF8);
  var Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    var Code := HttpClient.Post(BuildUrl(Endpoint), Params, Response, BuildHeaders);
    Result := Deserialize<TResult>(Code, Response.DataString);
  finally
    Params.Free;
    Response.Free;
    ResetCustomHeader;
    Monitoring.Dec;
  end;
end;

function TGenAIAPI.Get<TResult, TParams>(const Endpoint: string;
  ParamProc: TProc<TParams>): TResult;
begin
  Monitoring.Inc;
  var Response := TStringStream.Create('', TEncoding.UTF8);
  var Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    var Code := HttpClient.Get(BuildUrl(Endpoint, Params.Value), Response, BuildHeaders);
    Result := Deserialize<TResult>(Code, Response.DataString);
  finally
    Response.Free;
    Params.Free;
    ResetCustomHeader;
    Monitoring.Dec;
  end;
end;

function TGenAIAPI.Get<TResult>(const Endpoint: string): TResult;
begin
  Monitoring.Inc;
  var Response := TStringStream.Create('', TEncoding.UTF8);
  try
    var Code := HttpClient.Get(BuildUrl(Endpoint), Response, BuildHeaders);
    Result := Deserialize<TResult>(Code, Response.DataString);
  finally
    Response.Free;
    ResetCustomHeader;
    Monitoring.Dec;
  end;
end;

function TGenAIAPI.GetFile<TResult>(const Endpoint: string; const JSONFieldName: string):TResult;
begin
  Monitoring.Inc;
  var Stream := TStringStream.Create;
  try
    var Code := GetFile(Endpoint, Stream);
    Result := Deserialize<TResult>(Code, MockJsonFile(JSONFieldName, Stream));
  finally
    Stream.Free;
    ResetCustomHeader;
    Monitoring.Dec;
  end;
end;

function TGenAIAPI.GetFile(const Endpoint: string; Response: TStream): Integer;
begin
  var Headers := BuildHeaders;
  try
    Result := HttpClient.Get(BuildUrl(Endpoint), Response, Headers);
    case Result of
      200..299:
         {success};
      else
        begin
          var Recieved := TStringStream.Create;
          try
            Response.Position := 0;
            Recieved.LoadFromStream(Response);
            DeserializeErrorData(Result, Recieved.DataString);
          finally
            Recieved.Free;
          end;
        end;
    end;
  finally
    ResetCustomHeader;
  end;
end;

function TGenAIAPI.MockJsonFile(const FieldName: string;
  Response: TStringStream): string;
begin
  Response.Position := 0;
  var Data := TStringStream.Create(BytesToString(Response.Bytes).TrimRight([#0]));
  try
    Result := Format('{"%s":"%s"}', [FieldName, EncodeBase64(Data)]);
  finally
    Data.Free;
  end;
end;

function TGenAIAPI.MockJsonResponse(const FieldName: string;
  Response: TStringStream): string;
begin
  Result := Format('{"%s":"%s"}', [FieldName, BytesToBase64(Response.Bytes)]);
end;

function TGenAIAPI.Patch<TResult, TParams>(const Endpoint: string;
  ParamProc: TProc<TParams>): TResult;
begin
  Monitoring.Inc;
  var Response := TStringStream.Create('', TEncoding.UTF8);
  var Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    var Code := HttpClient.Patch(BuildUrl(Endpoint), Params.JSON, Response, BuildJsonHeaders);
    Result := Deserialize<TResult>(Code, Response.DataString);
  finally
    Params.Free;
    Response.Free;
    ResetCustomHeader;
    Monitoring.Dec;
  end;
end;

{ TGenAIRoute }

constructor TGenAIRoute.CreateRoute(AAPI: TGenAIAPI);
begin
  inherited Create;
  FAPI := AAPI;
end;

procedure TGenAIRoute.HeaderCustomize;
begin

end;

procedure TGenAIRoute.SetAPI(const Value: TGenAIAPI);
begin
  FAPI := Value;
end;

{ TGenAIConfiguration }

procedure TGenAIConfiguration.VerifyApiSettings;
begin
  if FAPIKey.IsEmpty or FBaseUrl.IsEmpty then
    raise TGenAIAPIException.Create('Invalid API key or base URL.');
end;

function TGenAIConfiguration.BuildUrl(const Endpoint: string): string;
begin
  Result := FBaseUrl.TrimRight(['/']) + '/' + Endpoint.TrimLeft(['/']);
end;

function TGenAIConfiguration.BuildUrl(const Endpoint,
  Parameters: string): string;
begin
  Result := BuildUrl(EndPoint) + Parameters;
end;

constructor TGenAIConfiguration.Create;
begin
  inherited;
  FAPIKey := EmptyStr;
  FBaseUrl := URL_BASE;
end;

procedure TGenAIConfiguration.ResetCustomHeader;
begin
  CustomHeaders := [];
end;

function TGenAIConfiguration.BuildHeaders: TNetHeaders;
begin
  Result := [TNetHeader.Create('Authorization', 'Bearer ' + FAPIKey)];
  if not FOrganization.IsEmpty then
    Result := Result + [TNetHeader.Create('OpenAI-Organization', FOrganization)];
  Result := Result + FCustomHeaders;
end;

function TGenAIConfiguration.BuildJsonHeaders: TNetHeaders;
begin
  Result := BuildHeaders +
    [TNetHeader.Create('Content-Type', 'application/json')] +
    [TNetHeader.Create('Accept', 'application/json')];
end;

procedure TGenAIConfiguration.SetAPIKey(const Value: string);
begin
  FAPIKey := Value;
end;

procedure TGenAIConfiguration.SetBaseUrl(const Value: string);
begin
  FBaseUrl := Value;
end;

procedure TGenAIConfiguration.SetCustomHeaders(const Value: TNetHeaders);
begin
  FCustomHeaders := Value;
end;

procedure TGenAIConfiguration.SetOrganization(const Value: string);
begin
  FOrganization := Value;
end;

{ TApiDeserializer }

class constructor TApiDeserializer.Create;
begin
  Metadata := TDeserializationPrepare.CreateInstance;
end;

function TApiDeserializer.Deserialize<T>(const Code: Int64;
  const ResponseText: string): T;
begin
  Result := nil;
  case Code of
    200..299:
      try
        Result := Parse<T>(ResponseText);
      except
        Result := nil;
      end;
    else
      DeserializeErrorData(Code, ResponseText);
  end;
  if not Assigned(Result) then
    raise TGenAIInvalidResponseError.Create(Code, 'Non-compliant response');
end;

procedure TApiDeserializer.DeserializeErrorData(const Code: Int64;
  const ResponseText: string);
var
  Error: TError;
begin
  Error := nil;
  try
    try
      Error := TJson.JsonToObject<TError>(ResponseText);
    except
      Error := nil;
    end;
    if Assigned(Error) then
      RaiseError(Code, Error)
    else
      raise TGenAIAPIException.CreateFmt(
        'Server returned error code %d but response was not parseable: %s', [Code, ResponseText]);
  finally
    if Assigned(Error) then
      Error.Free;
  end;
end;

class function TApiDeserializer.Parse<T>(const Value: string): T;
begin
  {--- NOTE
    - If Metadata are to be treated  as objects, a dedicated  TMetadata class is required, containing
    all the properties corresponding to the specified JSON fields.

    - However, if Metadata are  not treated  as objects, they will be temporarily handled as a string
    and subsequently converted back into a valid JSON string during the deserialization process using
    the Revert method of the interceptor.

    By default, Metadata are  treated as strings rather  than objects to handle  cases where multiple
    classes to be deserialized may contain variable data structures.
    Refer to the global variable MetadataAsObject. }
  case MetadataAsObject of
    True:
      Result := TJson.JsonToObject<T>(Value);
    else
      Result := TJson.JsonToObject<T>(Metadata.Convert(Value));
  end;

  {--- Add JSON response if class inherits from TJSONFingerprint class. }
  if Assigned(Result) and T.InheritsFrom(TJSONFingerprint) then
    begin
      var JSONValue := TJSONObject.ParseJSONValue(Value);
      try
        (Result as TJSONFingerprint).JSONResponse := JSONValue.Format();
      finally
        JSONValue.Free;
      end;
    end;
end;

procedure TApiDeserializer.RaiseError(Code: Int64; Error: TErrorCore);
begin
  case Code of
    401:
      raise TGenAIAuthError.Create(Code, Error);
    403:
      raise TGenAICountryNotSupportedError.Create(Code, Error);
    429:
      raise TGenAIRateLimitError.Create(Code, Error);
    500:
      raise TGenAIServerError.Create(Code, Error);
    503:
      raise TGenAIEngineOverloadedError.Create(Code, Error);
  else
    raise TGenAIException.Create(Code, Error);
  end;
end;

{ TApiHttpHandler }

constructor TApiHttpHandler.Create;
begin
  inherited Create;
  FHttpClient := THttpClientAPI.CreateInstance(VerifyApiSettings);
end;

end.

unit GenAI.API.Tests;

(*
  To execute unit tests proceed as follows :

  Declare
  -------
      uses
        DUnitX.TestFramework,
        DUnitX.Loggers.Console,
        DUnitX.TestRunner,
        GenAI.API.Tests, ... ;

  Process
  -------
      procedure TForm1.Button1Click(Sender: TObject);
      var
        Runner: ITestRunner;
        Results: IRunResults;
      begin
        TDUnitX.RegisterTestFixture(TGenAIAPITests);
        Runner := TDUnitX.CreateRunner;
        Results := Runner.Execute;
        if Results.AllPassed then
          Memo1.Lines.Add('All tests passed.')
        else
          Memo1.Lines.Add('Some tests failed.');
      end;
*)

interface

{$M+}

uses
  DUnitX.TestFramework, System.SysUtils, System.Classes, REST.JsonReflect,
  GenAI.API, GenAI.API.Params, GenAI.Types, GenAI.Exceptions;

type
  [TestFixture]
  TGenAIAPITests = class
  public
    [Test] procedure Test_TUrlParam_AddParameters;
    [Test] procedure Test_TUrlPaginationParams;
    [Test] procedure Test_TJSONParam_Serialization;
    [Test] procedure Test_TApiDeserializer_Deserialize;
    [Test] procedure Test_TApiDeserializer_Deserialize_MetadataAsstring;
    [Test] procedure Test_TApiDeserializer_RaiseErrors;
    [Test] procedure Test_TApiDeserializer_EmptyResponse;
    [Test] procedure Test_TGenAIAPI_GetFileWithError;
    [Test] procedure Test_TGenAIConfiguration_BuildHeaders;
  end;

  TTestModel = class(TObject)
  private
    FId: string;
    FName: string;
    FKind: string;
  public
    property Id: string read FId write FId;
    property Name: string read FName write FName;
    property Kind: string read FKind write FKind;
  end;

  TTestMetadata = class(TObject)
  private
    FId: string;
    FName: string;
    [JsonReflectAttribute(ctString, rtString, TMetadataInterceptor)]
    FMetadata: string;
  public
    property Id: string read FId write FId;
    property Name: string read FName write FName;
    property Metadata: string read FMetadata write FMetadata;
  end;

implementation

uses
  System.Net.URLClient;

type
  TTestGenAIConfiguration = class(TGenAIConfiguration);

  TTestTApiDeserializer = class(TApiDeserializer);

{ TGenAIAPITests }

procedure TGenAIAPITests.Test_TApiDeserializer_Deserialize;
{--- This ensures that data received from the API is correctly transformed into
     usable Delphi objects. }
begin
  var DeserializedObj: TTestModel := nil;
  var Deserializer := TTestTApiDeserializer.Create;
  var JsonInput := '{"name":"test_model","id":"123","kind":"object"}';
  try
    DeserializedObj := Deserializer.Deserialize<TTestModel>(200, JsonInput);
    Assert.IsNotNull(DeserializedObj, 'The deserialized object is null.');
    Assert.AreEqual('test_model', DeserializedObj.Name, 'The Name field is incorrect.');
    Assert.AreEqual('123', DeserializedObj.Id, 'The Id field is incorrect.');
    Assert.AreEqual('object', DeserializedObj.kind, 'The Kind field is incorrect.');
  finally
    DeserializedObj.Free;
    Deserializer.Free;
  end;
end;

procedure TGenAIAPITests.Test_TApiDeserializer_Deserialize_MetadataAsstring;
{--- This guarantees that the data retrieved from the API is properly transformed into objects,
     ensuring that metadata is correctly deserialized as strings and not in object form. }
begin
  var DeserializedObj: TTestMetadata := nil;
  var Deserializer := TTestTApiDeserializer.Create;
  var JsonInput := '{"name":"test_model","id":"123","metadata":{"key":"value"}}';
  try
    DeserializedObj := Deserializer.Deserialize<TTestMetadata>(200, JsonInput);
    Assert.IsNotNull(DeserializedObj, 'The deserialized object is null.');
    Assert.AreEqual('test_model', DeserializedObj.Name, 'The Name field is incorrect.');
    Assert.AreEqual('123', DeserializedObj.Id, 'The Id field is incorrect.');
    Assert.AreEqual('{"key":"value"}', DeserializedObj.Metadata, 'The Kind field is incorrect.');
  finally
    DeserializedObj.Free;
    Deserializer.Free;
  end;
end;

procedure TGenAIAPITests.Test_TApiDeserializer_EmptyResponse;
{--- Checking for an empty or non-JSON response throws the TGenAIInvalidResponseError exception. }
begin
  var Deserializer := TTestTApiDeserializer.Create;
  try
    Assert.WillRaise(
      procedure begin
        Deserializer.Deserialize<TTestModel>(200, '');
      end,
      TGenAIInvalidResponseError,
      'No exception thrown for empty response.'
    );
  finally
    Deserializer.Free;
  end;
end;

procedure TGenAIAPITests.Test_TApiDeserializer_RaiseErrors;
{--- This ensures that every type of API error is handled correctly by the exception system. }
begin
  var Deserializer := TTestTApiDeserializer.Create;
  try
    Assert.WillRaise(
      procedure begin
        Deserializer.DeserializeErrorData(401, '{"error": {"message": "Invalid API key", "code": 401}}');
      end,
      TGenAIAuthError,
      'TGenAIAuthError exception was not thrown for error 401.');
    Assert.WillRaise(
      procedure begin
        Deserializer.DeserializeErrorData(403, '{"error": {"message": "Invalid API key", "code": 403}}');
      end,
      TGenAICountryNotSupportedError,
      'TGenAICountryNotSupportedError exception was not thrown for error 403.');
    Assert.WillRaise(
      procedure begin
        Deserializer.DeserializeErrorData(429, '{"error": {"message": "Invalid API key", "code": 429}}');
      end,
      TGenAIRateLimitError,
      'TGenAIRateLimitError exception was not thrown for error 429.');
    Assert.WillRaise(
      procedure begin
        Deserializer.DeserializeErrorData(500, '{"error": {"message": "Invalid API key", "code": 500}}');
      end,
      TGenAIServerError,
      'TGenAIServerError exception was not thrown for error 500.');
    Assert.WillRaise(
      procedure begin
        Deserializer.DeserializeErrorData(503, '{"error": {"message": "Invalid API key", "code": 503}}');
      end,
      TGenAIEngineOverloadedError,
      'TGenAIEngineOverloadedError exception was not thrown for error 503.');
  finally
    Deserializer.Free;
  end;
end;

procedure TGenAIAPITests.Test_TGenAIAPI_GetFileWithError;
{--- Ensure that an appropriate exception is thrown when a file download fails. }
begin
  var API := TGenAIAPI.Create('dummy_api_key');
  var Stream := TMemoryStream.Create;
  try
    Assert.WillRaise(
      procedure
      begin
        API.GetFile('invalid/endpoint', Stream);
      end,
      TGenAIAPIException,
      'No exception thrown when downloading an invalid file.'
    );
  finally
    Stream.Free;
    API.Free;
  end;
end;

procedure TGenAIAPITests.Test_TGenAIConfiguration_BuildHeaders;
{--- This ensures that every request sent to the API is properly authenticated. }
begin
  var Config := TTestGenAIConfiguration.Create;
  try
    Config.APIKey := 'my_api_key';
    Config.Organization := 'my_organization';

    var Headers := Config.BuildHeaders;

    Assert.AreEqual('Bearer my_api_key', Headers[0].Value, 'The Authorization header is incorrect.');
    Assert.AreEqual('my_organization', Headers[1].Value, 'The OpenAI-Organization header is incorrect.');
  finally
    Config.Free;
  end;
end;

procedure TGenAIAPITests.Test_TJSONParam_Serialization;
{--- Verify that HTTP POST/GET requests correctly serialize JSON parameters. }
begin
  var JSONParam := TJSONParam.Create;
  try
    JSONParam.Add('param1', 'value1');
    JSONParam.Add('param2', 42);
    JSONParam.Add('param3', True);
    var JsonString := JSONParam.ToJsonString;
    Assert.IsTrue(JsonString.Contains('"param1":"value1"'), 'Parameter param1 missing or incorrect.');
    Assert.IsTrue(JsonString.Contains('"param2":42'), 'Incorrect parameter param2.');
    Assert.IsTrue(JsonString.Contains('"param3":true'), 'Incorrect parameter param3.');
  finally
    JSONParam.Free;
  end;
end;

procedure TGenAIAPITests.Test_TUrlPaginationParams;
{--- Verify that the TUrlPaginationParams class correctly handles pagination parameters. }
begin
  var PaginationParams := TUrlPaginationParams.Create;
  try
    PaginationParams.Limit(50).After('item_12345');
    Assert.AreEqual('?limit=50&after=item_12345', PaginationParams.Value,
      'The pagination settings are not correct.');
  finally
    PaginationParams.Free;
  end;
end;

procedure TGenAIAPITests.Test_TUrlParam_AddParameters;
{--- This ensures that all API requests use properly formatted URLs, avoiding HTTP
     errors due to mis-encoded parameters.}
begin
  var UrlParams := TUrlParam.Create;
  try
    UrlParams.Add('key1', 'value1');
    UrlParams.Add('key2', 'value 2');
    var ResultingUrl := UrlParams.Value;
    Assert.AreEqual('?key1=value1&key2=value%202', ResultingUrl,
      'URL parameters are not encoded correctly.');
  finally
    UrlParams.Free;
  end;

  {--- Verify that URL parameters containing special characters are correctly encoded. }
  UrlParams := TUrlParam.Create;
  try
    UrlParams.Add('param1', 'value with spaces');
    UrlParams.Add('param2', 'value&with=special%chars');
    var ResultingUrl := UrlParams.Value;
    Assert.AreEqual('?param1=value%20with%20spaces&param2=value%26with%3Dspecial%25chars', ResultingUrl,
      'URL parameters are not encoded correctly.');
  finally
    UrlParams.Free;
  end;
end;

end.

unit GenAI.API.Utils;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils;

const
  FIELDSASSTRING : TArray<string> = [
    '"metadata": {', '"metadata":{',
    '"response_format": {', '"response_format":{', //GenAI.Runs, GenAI.Assistants
    '"parameters": {', '"parameters":{',           //GenAI.Assistants
    '"tool_choice": {', '"tool_choice":{',         //GenAI.Runs
    '"attributes": {', '"attributes":{',           //GenAI.Responses
    '"schema": {', '"schema":{'                    //GenAI.Responses
  ];

(*
   --- NOTE ---
    Each entry in this array corresponds to a  JSON field that is temporarily
    treated as  a string  during  parsing. In order  for these  fields  to be
    correctly restored as JSON objects upon re-marshalling, each unique field
    listed here must have a dedicated interceptor  that transforms the string
    back into a well-formed JSON object.

    Example: TMetadataInterceptor

      procedure TMetadataInterceptor.StringReverter(Data: TObject; Field,
        Arg: string);
      begin
        Arg := Format('{%s}', [Trim(Arg.Replace('`', '"').Replace(#10, ''))]);
        while Arg.Contains(', ') do Arg := Arg.Replace(', ', ',');
        RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, Arg.Replace(',', ', '));
      end;
*)

type
  /// <summary>
  /// Provides a mechanism for converting or transforming specific JSON fields in a string
  /// before deserialization. Typically used to handle scenarios where certain fields
  /// contain complex or nested structures that need to be converted into valid JSON.
  /// </summary>
  /// <remarks>
  /// <para>
  /// Implementations of this interface can adjust the JSON string prior to the deserialization
  /// process to address inconsistencies, remove or replace invalid characters, or convert
  /// problematic JSON fields into formats that a JSON deserializer can handle properly.
  /// </para>
  /// <para>
  /// For example, the implementation may detect fields named "metadata" and convert their
  /// content from a raw, non-standard structure into a valid JSON string by replacing certain
  /// delimiters or escape characters.
  /// </para>
  /// </remarks>
  ICustomFieldsPrepare = interface
    ['{60B0EAB1-3C74-4ACE-8B33-6DA2B40485F9}']
    /// <summary>
    /// Converts or transforms specified fields in the provided JSON string to ensure
    /// deserialization compatibility.
    /// </summary>
    /// <param name="Value">
    /// The raw JSON string containing fields that may require transformation.
    /// </param>
    /// <returns>
    /// A revised JSON string after applying the necessary field conversions or
    /// transformations.
    /// </returns>
    function Convert(const Value: string): string; overload;
  end;

  /// <summary>
  /// Implements the <c>ICustomFieldsPrepare</c> interface to transform specific JSON fields
  /// before deserialization. The class applies rules for handling particular fields that may
  /// contain nested objects or invalid characters, ensuring the resulting JSON is valid and
  /// ready for further processing.
  /// </summary>
  /// <remarks>
  /// <para>
  /// This class is most commonly used to modify JSON fields such as "metadata" that might
  /// otherwise cause errors during deserialization. It replaces problematic delimiters and
  /// characters (like quotation marks or braces) within specified field blocks, enabling
  /// compliant JSON output.
  /// </para>
  /// <para>
  /// <c>TDeserializationPrepare</c> scans the JSON string for patterns and adjusts the content
  /// accordingly, preventing typical parsing exceptions arising from malformed or unexpected
  /// inline structures.
  /// </para>
  /// </remarks>
  TDeserializationPrepare = class(TInterfacedObject, ICustomFieldsPrepare)
  private
    /// <summary>
    /// Searches for a single specified field in the JSON string and updates its content
    /// to ensure valid JSON syntax. Replaces certain delimiters and characters inside
    /// the field's scope with safe alternatives.
    /// </summary>
    /// <param name="Value">
    /// The entire JSON string being scanned.
    /// </param>
    /// <param name="Field">
    /// The name of the field whose content needs to be transformed.
    /// </param>
    /// <returns>
    /// A modified JSON string with the specified field's content replaced as necessary.
    /// </returns>
    /// <remarks>
    /// <para>
    /// This overload specifically handles updating a single <c>Field</c>. If multiple fields
    /// need to be processed, consider using the array overload of this method.
    /// </para>
    /// </remarks>
    function UpdateFieldValue(const Value, Field: string): string; overload;
    /// <summary>
    /// Scans the JSON string for multiple specified fields and updates each of their
    /// contents to ensure valid JSON syntax. Replaces certain delimiters and characters
    /// inside the scope of these fields with safe alternatives.
    /// </summary>
    /// <param name="Value">
    /// The entire JSON string being scanned.
    /// </param>
    /// <param name="Field">
    /// An array of field names whose content must be transformed.
    /// </param>
    /// <returns>
    /// A modified JSON string with each listed field’s content replaced as necessary.
    /// </returns>
    /// <remarks>
    /// <para>
    /// This overload iterates through each field name in <c>Field</c> and applies the
    /// transformations one by one. If you need to handle only a single field, use the
    /// other <c>UpdateFieldValue</c> method.
    /// </para>
    /// </remarks>
    function UpdateFieldValue(const Value: string; const Field: TArray<string>): string; overload;
  public
    /// <summary>
    /// Scans and modifies the input JSON string to replace fields that contain nested
    /// objects or invalid characters, ensuring the JSON is suitable for deserialization.
    /// </summary>
    /// <param name="Value">
    /// The original JSON string needing transformation.
    /// </param>
    /// <returns>
    /// A revised JSON string after applying all necessary field modifications.
    /// </returns>
    /// <remarks>
    /// <para>
    /// The conversion logic is determined by which fields or patterns are defined
    /// within the implementation. Currently, the class targets fields labeled
    /// <c>"metadata"</c>, converting them from non-standard structures into proper
    /// JSON-friendly strings.
    /// </para>
    /// </remarks>
    function Convert(const Value: string): string;
    /// <summary>
    /// Factory method for creating an instance of the <c>TDeserializationPrepare</c> class.
    /// Returns an interface reference to <c>ICustomFieldsPrepare</c>.
    /// </summary>
    /// <returns>
    /// A newly constructed <c>TDeserializationPrepare</c> object as <c>ICustomFieldsPrepare</c>.
    /// </returns>
    /// <remarks>
    /// This method hides the constructor, enforcing interface-based usage.
    /// </remarks>
    class function CreateInstance: ICustomFieldsPrepare;
  end;

implementation

{ TDeserializationPrepare }

function TDeserializationPrepare.UpdateFieldValue(const Value,
  Field: string): string;
begin
  Result := Value;
  var i := Pos(Field, Result);
  while (i > 0) and (i < Result.Length) do
    begin
      i := i + Field.Length - 1;
      Result[i] := '"';
      Inc(i);
      var j := 0;
      while (j > 0) or ((j = 0) and not (Result[i] = '}')) do
        begin
          case Result[i] of
            '{':
              Inc(j);
            '}':
              j := j - 1;
            '"':
              Result[i] := '`';
          end;
          Inc(i);
          if i > Result.Length then
            raise Exception.Create('Invalid JSON string');
        end;
      Result[i] := '"';
      i := Pos(Field, Result);
    end;
end;

class function TDeserializationPrepare.CreateInstance: ICustomFieldsPrepare;
begin
  Result := TDeserializationPrepare.Create;
end;

function TDeserializationPrepare.Convert(const Value: string): string;
begin
  Result := UpdateFieldValue(Value, FIELDSASSTRING);
end;

function TDeserializationPrepare.UpdateFieldValue(const Value: string;
  const Field: TArray<string>): string;
begin
  Result := Value;
  if Length(Field) > 0 then
    begin
      for var Item in Field do
        Result := UpdateFieldValue(Result, Item);
    end;
end;

end.

unit GenAI.Assistants;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

 (*

  GenAI.Assistants - OpenAI Assistants API Integration
  -----------------------------------------------------

  This unit provides a  complete interface for managing  OpenAI assistants, allowing you
  to create, retrieve, update, list, and delete assistants,   as well as configure their
  tools and response settings.

  Key Features:
  -------------
  - Assistant Management: Create, modify,  and delete  assistants  via TAssistantsRoute.
  - Tool Integration: Enable tools such as File Search, Code Interpreter, and Functions.
  - Custom Instructions: Define assistant behavior using Instructions.
  - Response Formatting: Control output format (JSON, Text, Structured Outputs).
  - Parameter Tuning: Adjust Temperature and TopP for response precision.
  - Synchronous & Asynchronous Methods: Use AsynCreate, AsynList, etc., for non-blocking
    operations.
  - Error Handling: Manage API errors with OnError callbacks in async operations.

  Best Practices:
  ---------------
  - Choose the right model (gpt-4o, gpt-3.5-turbo) for optimal performance.
  - Use only necessary tools to improve efficiency.
  - Leverage asynchronous methods to avoid UI freezing.
  - Fine-tune assistant responses using Temperature and TopP.
  - Implement proper error handling to ensure robust API interactions.

  Example Usage:
  --------------
  var
    Assistant: TAssistant;
  begin
    Assistant := TAssistantsRoute.Create(
      procedure(Params: TAssistantsParams)
      begin
        Params.Model('gpt-4o')
              .Name('My Assistant')
              .Instructions('Respond concisely and professionally.')
              .Temperature(0.7);
      end
    );
  end;

  Utilisation des Méthodes Asynchrones
  ------------------------------------
  TAssistantsRoute.AsynCreate(
    procedure(Params: TAssistantsParams)
    begin
      Params.Model('gpt-4o').Name('Assistant Async');
    end,
    function: TAsynAssistant
    begin
      Result.OnSuccess := procedure(A: TAssistant)
        begin
          ShowMessage('Assistant créé : ' + A.Name);
        end;
      Result.OnError := procedure(E: Exception)
        begin
          ShowMessage('Erreur : ' + E.Message);
        end;
    end);

*)

interface

uses
  System.SysUtils, System.Classes, System.Threading, System.JSON, REST.Json.Types,
  REST.JsonReflect, System.Net.URLClient,
  GenAI.API.Params, GenAI.API, GenAI.Consts, GenAI.Types, GenAI.Async.Support,
  GenAI.Schema, GenAI.API.Lists, GenAI.API.Deletion;

type
  /// <summary>
  /// Represents the parameters used to configure ranking options in a file search operation.
  /// </summary>
  /// <remarks>
  /// This class provides methods to set the ranker and score threshold, which define
  /// how search results are ranked and filtered. It extends <c>TJSONParam</c> to support
  /// serialization to JSON format.
  /// </remarks>
  TRankingOptionsParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the ranker to be used for the file search operation.
    /// </summary>
    /// <param name="Value">
    /// A string representing the ranker. Possible values depend on the implementation of
    /// the file search tool.
    /// </param>
    /// <returns>
    /// The <c>TRankingOptionsParams</c> instance, allowing for method chaining.
    /// </returns>
    function Ranker(const Value: string): TRankingOptionsParams;
    /// <summary>
    /// Sets the score threshold for filtering search results.
    /// </summary>
    /// <param name="Value">
    /// A floating-point value between 0 and 1, representing the minimum score that a search
    /// result must have to be included in the output. Higher values filter out lower-quality
    /// results.
    /// </param>
    /// <returns>
    /// The <c>TRankingOptionsParams</c> instance, allowing for method chaining.
    /// </returns>
    function ScoreThreshold(const Value: Double): TRankingOptionsParams;
  end;

  /// <summary>
  /// Represents the parameters used to configure the file search tool in an assistant.
  /// </summary>
  /// <remarks>
  /// This class provides methods to set the maximum number of results and ranking options
  /// for the file search operation. It extends <c>TJSONParam</c> to enable JSON serialization.
  /// </remarks>
  TFileSearchToolParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the maximum number of results to return from the file search operation.
    /// </summary>
    /// <param name="Value">
    /// An integer representing the maximum number of results to include. The value must be
    /// between 1 and 50, inclusive.
    /// </param>
    /// <returns>
    /// The <c>TFileSearchToolParams</c> instance, allowing for method chaining.
    /// </returns>
    function MaxNumResults(const Value: Integer): TFileSearchToolParams;
    /// <summary>
    /// Sets the ranking options for the file search operation.
    /// </summary>
    /// <param name="Value">
    /// A <c>TRankingOptionsParams</c> instance that specifies the ranker and score threshold
    /// for ranking and filtering search results.
    /// </param>
    /// <returns>
    /// The <c>TFileSearchToolParams</c> instance, allowing for method chaining.
    /// </returns>
    function RankingOptions(const Value: TRankingOptionsParams): TFileSearchToolParams;
  end;

  /// <summary>
  /// Represents the parameters used to define a custom function for an assistant.
  /// </summary>
  /// <remarks>
  /// This class provides methods to set the function's name, description, parameters,
  /// and strict mode. It extends <c>TJSONParam</c> to enable JSON serialization.
  /// </remarks>
  TAssistantsFunctionParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the description of the function.
    /// </summary>
    /// <param name="Value">
    /// A string describing the function's purpose. This helps the assistant determine
    /// when and how to call the function.
    /// </param>
    /// <returns>
    /// The <c>TAssistantsFunctionParams</c> instance, allowing for method chaining.
    /// </returns>
    function Description(const Value: string): TAssistantsFunctionParams;
    /// <summary>
    /// Sets the name of the function.
    /// </summary>
    /// <param name="Value">
    /// A string representing the function's name. The name must be alphanumeric or contain
    /// underscores and dashes, with a maximum length of 64 characters.
    /// </param>
    /// <returns>
    /// The <c>TAssistantsFunctionParams</c> instance, allowing for method chaining.
    /// </returns>
    function Name(const Value: string): TAssistantsFunctionParams;
    /// <summary>
    /// Sets the parameters schema for the function.
    /// </summary>
    /// <param name="Value">
    /// A <c>TSchemaParams</c> instance defining the expected parameters for the function,
    /// following the JSON Schema format.
    /// </param>
    /// <returns>
    /// The <c>TAssistantsFunctionParams</c> instance, allowing for method chaining.
    /// </returns>
    function Parameters(const Value: TSchemaParams): TAssistantsFunctionParams; overload;
    /// <summary>
    /// Sets the parameters schema for the function using a JSON object.
    /// </summary>
    /// <param name="Value">
    /// A <c>TJSONObject</c> instance specifying the function parameters in JSON format.
    /// </param>
    /// <returns>
    /// The <c>TAssistantsFunctionParams</c> instance, allowing for method chaining.
    /// </returns>
    function Parameters(const Value: TJSONObject): TAssistantsFunctionParams; overload;
    /// <summary>
    /// Enables or disables strict mode for function parameters.
    /// </summary>
    /// <param name="Value">
    /// A boolean value indicating whether strict mode is enabled. If <c>true</c>,
    /// the assistant strictly follows the defined schema when generating function calls.
    /// </param>
    /// <returns>
    /// The <c>TAssistantsFunctionParams</c> instance, allowing for method chaining.
    /// </returns>
    function &Strict(const Value: Boolean): TAssistantsFunctionParams;
  end;

  /// <summary>
  /// Represents the parameters used to configure tools for an assistant.
  /// </summary>
  /// <remarks>
  /// This class provides methods to define different types of tools, including
  /// file search and custom functions. It extends <c>TJSONParam</c> to support
  /// JSON serialization.
  /// </remarks>
  TAssistantsToolsParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the type of tool to be used by the assistant.
    /// </summary>
    /// <param name="Value">
    /// A string representing the tool type. Valid values include "file_search"
    /// and "function".
    /// </param>
    /// <returns>
    /// The <c>TAssistantsToolsParams</c> instance, allowing for method chaining.
    /// </returns>
    function &Type(const Value: string): TAssistantsToolsParams; overload;
    /// <summary>
    /// Sets the type of tool using the <c>TAssistantsToolsType</c> enumeration.
    /// </summary>
    /// <param name="Value">
    /// A <c>TAssistantsToolsType</c> value representing the tool type.
    /// </param>
    /// <returns>
    /// The <c>TAssistantsToolsParams</c> instance, allowing for method chaining.
    /// </returns>
    function &Type(const Value: TAssistantsToolsType): TAssistantsToolsParams; overload;
    /// <summary>
    /// Configures the file search tool parameters.
    /// </summary>
    /// <param name="Value">
    /// A <c>TFileSearchToolParams</c> instance specifying the file search settings,
    /// including ranking options and result limits.
    /// </param>
    /// <returns>
    /// The <c>TAssistantsToolsParams</c> instance, allowing for method chaining.
    /// </returns>
    function FileSearch(const Value: TFileSearchToolParams): TAssistantsToolsParams;
    /// <summary>
    /// Configures a custom function tool.
    /// </summary>
    /// <param name="Value">
    /// A <c>TAssistantsFunctionParams</c> instance defining the function's properties, including
    /// its name, description, and parameter schema.
    /// </param>
    /// <returns>
    /// The <c>TAssistantsToolsParams</c> instance, allowing for method chaining.
    /// </returns>
    function &Function(const Value: TAssistantsFunctionParams): TAssistantsToolsParams;
  end;

  /// <summary>
  /// Represents the parameters used to configure the code interpreter tool for an assistant.
  /// </summary>
  /// <remarks>
  /// This class provides methods to specify the file IDs that the code interpreter tool
  /// can access. It extends <c>TJSONParam</c> to enable JSON serialization.
  /// </remarks>
  TCodeInterpreterParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the list of file IDs accessible by the code interpreter tool.
    /// </summary>
    /// <param name="Value">
    /// An array of strings representing the file IDs. The maximum number of files allowed
    /// is 20.
    /// </param>
    /// <returns>
    /// The <c>TCodeInterpreterParams</c> instance, allowing for method chaining.
    /// </returns>
    function FileIds(const Value: TArray<string>): TCodeInterpreterParams;
  end;

  /// <summary>
  /// Represents the parameters used to configure static chunking for file processing.
  /// </summary>
  /// <remarks>
  /// This class provides methods to set the maximum chunk size and overlap between chunks.
  /// It is used to control how large text or data is divided into manageable parts for
  /// processing. The class extends <c>TJSONParam</c> to enable JSON serialization.
  /// </remarks>
  TChunkStaticParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the maximum size of each chunk in tokens.
    /// </summary>
    /// <param name="Value">
    /// An integer representing the maximum number of tokens allowed per chunk.
    /// Larger values allow bigger chunks, but may impact performance.
    /// </param>
    /// <returns>
    /// The <c>TChunkStaticParams</c> instance, allowing for method chaining.
    /// </returns>
    function MaxChunkSizeTokens(const Value: Integer): TChunkStaticParams;
    /// <summary>
    /// Sets the overlap size between consecutive chunks in tokens.
    /// </summary>
    /// <param name="Value">
    /// An integer representing the number of tokens that should overlap between
    /// consecutive chunks. This ensures continuity between chunks.
    /// </param>
    /// <returns>
    /// The <c>TChunkStaticParams</c> instance, allowing for method chaining.
    /// </returns>
    function ChunkOverlapTokens(const Value: Integer): TChunkStaticParams;
  end;

  /// <summary>
  /// Represents the parameters used to configure the chunking strategy for file processing.
  /// </summary>
  /// <remarks>
  /// This class provides methods to define the type of chunking strategy and configure
  /// specific parameters, such as static chunking options. It extends <c>TJSONParam</c>
  /// to enable JSON serialization.
  /// </remarks>
  TChunkingStrategyParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the type of chunking strategy to use.
    /// </summary>
    /// <param name="Value">
    /// A string representing the type of chunking strategy. This could include strategies
    /// like "static" or others depending on the use case.
    /// </param>
    /// <returns>
    /// The <c>TChunkingStrategyParams</c> instance, allowing for method chaining.
    /// </returns>
    function &Type(const Value: string): TChunkingStrategyParams; overload;
    /// <summary>
    /// Sets the type of chunking strategy using the <c>TChunkingStrategyType</c> enumeration.
    /// </summary>
    /// <param name="Value">
    /// A <c>TChunkingStrategyType</c> enumeration value representing the chunking strategy.
    /// </param>
    /// <returns>
    /// The <c>TChunkingStrategyParams</c> instance, allowing for method chaining.
    /// </returns>
    function &Type(const Value: TChunkingStrategyType): TChunkingStrategyParams; overload;
    /// <summary>
    /// Configures the static chunking parameters for the chunking strategy.
    /// </summary>
    /// <param name="Value">
    /// A <c>TChunkStaticParams</c> instance that defines the static chunking parameters,
    /// such as maximum chunk size and overlap size.
    /// </param>
    /// <returns>
    /// The <c>TChunkingStrategyParams</c> instance, allowing for method chaining.
    /// </returns>
    function Static(const Value: TChunkStaticParams): TChunkingStrategyParams;
  end;


  /// <summary>
  /// Represents the parameters used to configure vector stores for file search operations.
  /// </summary>
  /// <remarks>
  /// This class provides methods to specify file IDs, chunking strategies, and metadata
  /// associated with vector stores. It extends <c>TJSONParam</c> to enable JSON serialization.
  /// </remarks>
  TVectorStoresParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the list of file IDs to be included in the vector store.
    /// </summary>
    /// <param name="Value">
    /// An array of strings representing the file IDs to include in the vector store.
    /// </param>
    /// <returns>
    /// The <c>TVectorStoresParams</c> instance, allowing for method chaining.
    /// </returns>
    function FileIds(const Value: TArray<string>): TVectorStoresParams;
    /// <summary>
    /// Configures the chunking strategy for processing files in the vector store.
    /// </summary>
    /// <param name="Value">
    /// A <c>TChunkingStrategyParams</c> instance specifying the chunking strategy to use,
    /// such as static chunking with overlap and size settings.
    /// </param>
    /// <returns>
    /// The <c>TVectorStoresParams</c> instance, allowing for method chaining.
    /// </returns>
    function ChunkingStrategy(const Value: TChunkingStrategyParams): TVectorStoresParams;
    /// <summary>
    /// Sets the metadata for the vector store.
    /// </summary>
    /// <param name="Value">
    /// A <c>TJSONObject</c> instance containing key-value pairs that represent additional
    /// metadata about the vector store. Keys can be up to 64 characters, and values up
    /// to 512 characters.
    /// </param>
    /// <returns>
    /// The <c>TVectorStoresParams</c> instance, allowing for method chaining.
    /// </returns>
    function Metadata(const Value: TJSONObject): TVectorStoresParams;
  end;

  /// <summary>
  /// Represents the parameters used to configure file search operations in an assistant.
  /// </summary>
  /// <remarks>
  /// This class provides methods to specify vector store IDs and configure vector stores
  /// for efficient file searching. It extends <c>TJSONParam</c> to enable JSON serialization.
  /// </remarks>
  TFileSearchParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the list of vector store IDs used for the file search.
    /// </summary>
    /// <param name="Value">
    /// An array of strings representing the IDs of the vector stores to use during
    /// the file search.
    /// </param>
    /// <returns>
    /// The <c>TFileSearchParams</c> instance, allowing for method chaining.
    /// </returns>
    function VectorStoreIds(const Value: TArray<string>): TFileSearchParams;
    /// <summary>
    /// Configures the vector stores for the file search operation.
    /// </summary>
    /// <param name="Value">
    /// An array of <c>TVectorStoresParams</c> instances that define the properties of
    /// the vector stores, including file IDs, chunking strategy, and metadata.
    /// </param>
    /// <returns>
    /// The <c>TFileSearchParams</c> instance, allowing for method chaining.
    /// </returns>
    function VectorStores(const Value: TArray<TVectorStoresParams>): TFileSearchParams;
  end;

  /// <summary>
  /// Represents the parameters used to configure tool resources for an assistant.
  /// </summary>
  /// <remarks>
  /// This class provides methods to specify resources for the code interpreter and
  /// file search tools. It extends <c>TJSONParam</c> to enable JSON serialization.
  /// </remarks>
  TToolResourcesParams = class(TJSONParam)
  public
    /// <summary>
    /// Configures the code interpreter tool with the specified parameters.
    /// </summary>
    /// <param name="Value">
    /// A <c>TCodeInterpreterParams</c> instance that defines the files available
    /// to the code interpreter.
    /// </param>
    /// <returns>
    /// The <c>TToolResourcesParams</c> instance, allowing for method chaining.
    /// </returns>
    function CodeInterpreter(const Value: TCodeInterpreterParams): TToolResourcesParams; overload;
    /// <summary>
    /// Configures the code interpreter tool with a list of file IDs.
    /// </summary>
    /// <param name="FileIds">
    /// An array of strings representing the file IDs available to the code interpreter.
    /// </param>
    /// <returns>
    /// The <c>TToolResourcesParams</c> instance, allowing for method chaining.
    /// </returns>
    function CodeInterpreter(const FileIds: TArray<string>): TToolResourcesParams; overload;
    /// <summary>
    /// Configures the file search tool with the specified parameters.
    /// </summary>
    /// <param name="Value">
    /// A <c>TFileSearchParams</c> instance that defines the vector stores used
    /// for file searching.
    /// </param>
    /// <returns>
    /// The <c>TToolResourcesParams</c> instance, allowing for method chaining.
    /// </returns>
    function FileSearch(const Value: TFileSearchParams): TToolResourcesParams;
  end;

  /// <summary>
  /// Represents the parameters used to define a JSON schema for structured responses.
  /// </summary>
  /// <remarks>
  /// This class provides methods to specify the schema name, description, and structure.
  /// It allows strict schema adherence for function calls and output validation.
  /// Extends <c>TJSONParam</c> to enable JSON serialization.
  /// </remarks>
  TJsonSchemaParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the description of the JSON schema.
    /// </summary>
    /// <param name="Value">
    /// A string describing the purpose and structure of the JSON schema. This helps
    /// the assistant understand the format of expected outputs.
    /// </param>
    /// <returns>
    /// The <c>TJsonSchemaParams</c> instance, allowing for method chaining.
    /// </returns>
    function Description(const Value: string): TJsonSchemaParams;
    /// <summary>
    /// Sets the name of the JSON schema.
    /// </summary>
    /// <param name="Value">
    /// A string representing the name of the schema. The name must be alphanumeric or
    /// contain underscores and dashes, with a maximum length of 64 characters.
    /// </param>
    /// <returns>
    /// The <c>TJsonSchemaParams</c> instance, allowing for method chaining.
    /// </returns>
    function Name(const Value: string): TJsonSchemaParams;
    /// <summary>
    /// Sets the schema definition using a <c>TSchemaParams</c> instance.
    /// </summary>
    /// <param name="Value">
    /// A <c>TSchemaParams</c> instance defining the structure and expected properties
    /// of the JSON schema.
    /// </param>
    /// <returns>
    /// The <c>TJsonSchemaParams</c> instance, allowing for method chaining.
    /// </returns>
    function Schema(const Value: TSchemaParams): TJsonSchemaParams; overload;
    /// <summary>
    /// Sets the schema definition using a JSON object.
    /// </summary>
    /// <param name="Value">
    /// A <c>TJSONObject</c> instance representing the JSON schema definition.
    /// </param>
    /// <returns>
    /// The <c>TJsonSchemaParams</c> instance, allowing for method chaining.
    /// </returns>
    function Schema(const Value: TJSONObject): TJsonSchemaParams; overload;
    /// <summary>
    /// Enables or disables strict schema adherence.
    /// </summary>
    /// <param name="Value">
    /// A boolean value indicating whether strict mode is enabled. If <c>true</c>,
    /// the model follows the exact schema definition when generating responses.
    /// </param>
    /// <returns>
    /// The <c>TJsonSchemaParams</c> instance, allowing for method chaining.
    /// </returns>
    function &Strict(const Value: Boolean): TJsonSchemaParams;
  end;

  /// <summary>
  /// Represents the parameters used to configure the response format for an assistant.
  /// </summary>
  /// <remarks>
  /// This class provides methods to define the type of response format, including JSON
  /// schema and structured outputs. It extends <c>TJSONParam</c> to enable JSON serialization.
  /// </remarks>
  TResponseFormatParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the type of response format to use.
    /// </summary>
    /// <param name="Value">
    /// A string representing the response format type. Common values include "text",
    /// "json_object", and "json_schema".
    /// </param>
    /// <returns>
    /// The <c>TResponseFormatParams</c> instance, allowing for method chaining.
    /// </returns>
    function &Type(const Value: string): TResponseFormatParams; overload;
    /// <summary>
    /// Sets the type of response format using the <c>TResponseFormatType</c> enumeration.
    /// </summary>
    /// <param name="Value">
    /// A <c>TResponseFormatType</c> enumeration value specifying the response format type.
    /// </param>
    /// <returns>
    /// The <c>TResponseFormatParams</c> instance, allowing for method chaining.
    /// </returns>
    function &Type(const Value: TResponseFormatType): TResponseFormatParams; overload;
    /// <summary>
    /// Configures a JSON schema for the response format.
    /// </summary>
    /// <param name="Value">
    /// A <c>TJsonSchemaParams</c> instance that defines the structure and properties
    /// of the JSON schema for the response.
    /// </param>
    /// <returns>
    /// The <c>TResponseFormatParams</c> instance, allowing for method chaining.
    /// </returns>
    function JsonSchema(const Value: TJsonSchemaParams): TResponseFormatParams; overload;
    /// <summary>
    /// Configures a JSON schema for the response format.
    /// </summary>
    /// <param name="Value">
    /// A <c>TJsonObject</c> instance that defines the structure and properties
    /// of the JSON schema for the response.
    /// </param>
    /// <returns>
    /// The <c>TResponseFormatParams</c> instance, allowing for method chaining.
    /// </returns>
    function JsonSchema(const Value: TJsonObject): TResponseFormatParams; overload;
  end;

  /// <summary>
  /// Represents the parameters used to configure an assistant.
  /// </summary>
  /// <remarks>
  /// This class provides methods to specify the assistant's model, name, description,
  /// instructions, tools, and response format. It extends <c>TJSONParam</c> to enable
  /// JSON serialization.
  /// </remarks>
  TAssistantsParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the model ID to be used by the assistant.
    /// </summary>
    /// <param name="Value">
    /// A string representing the model ID. Available models can be retrieved using the
    /// OpenAI API.
    /// </param>
    /// <returns>
    /// The <c>TAssistantsParams</c> instance, allowing for method chaining.
    /// </returns>
    function Model(const Value: string): TAssistantsParams;
    /// <summary>
    /// Sets the name of the assistant.
    /// </summary>
    /// <param name="Value">
    /// A string representing the assistant's name. The maximum length is 256 characters.
    /// </param>
    /// <returns>
    /// The <c>TAssistantsParams</c> instance, allowing for method chaining.
    /// </returns>
    function Name(const Value: string): TAssistantsParams;
    /// <summary>
    /// Sets the description of the assistant.
    /// </summary>
    /// <param name="Value">
    /// A string describing the assistant's purpose. The maximum length is 512 characters.
    /// </param>
    /// <returns>
    /// The <c>TAssistantsParams</c> instance, allowing for method chaining.
    /// </returns>
    function Description(const Value: string): TAssistantsParams;
    /// <summary>
    /// Sets the system instructions for the assistant.
    /// </summary>
    /// <param name="Value">
    /// A string containing instructions that guide the assistant's behavior. The maximum
    /// length is 256,000 characters.
    /// </param>
    /// <returns>
    /// The <c>TAssistantsParams</c> instance, allowing for method chaining.
    /// </returns>
    function Instructions(const Value: string): TAssistantsParams;
    /// <summary>
    /// Specifies the effort level for reasoning when generating responses.
    /// </summary>
    /// <param name="Value">
    /// A string representing the desired effort level ('low', 'medium', or 'high').
    /// </param>
    /// <returns>
    /// Returns an instance of TAssistantsParams with the reasoning effort set.
    /// </returns>
    function ReasoningEffort(const Value: TReasoningEffort): TAssistantsParams; overload;
    /// <summary>
    /// Specifies the effort level for reasoning when generating responses.
    /// </summary>
    /// <param name="Value">
    /// A string representing the desired effort level ('low', 'medium', or 'high').
    /// </param>
    /// <returns>
    /// Returns an instance of TAssistantsParams with the reasoning effort set.
    /// </returns>
    function ReasoningEffort(const Value: string): TAssistantsParams; overload;
    /// <summary>
    /// Configures the tools that the assistant can use.
    /// </summary>
    /// <param name="Value">
    /// An array of <c>TAssistantsToolsParams</c> instances defining the tools, such as
    /// code interpreter, file search, or function calls.
    /// </param>
    /// <returns>
    /// The <c>TAssistantsParams</c> instance, allowing for method chaining.
    /// </returns>
    function Tools(const Value: TArray<TAssistantsToolsParams>): TAssistantsParams;
    /// <summary>
    /// Configures the tool resources for the assistant.
    /// </summary>
    /// <param name="Value">
    /// A <c>TToolResourcesParams</c> instance specifying the resources available to the
    /// assistant's tools.
    /// </param>
    /// <returns>
    /// The <c>TAssistantsParams</c> instance, allowing for method chaining.
    /// </returns>
    function ToolResources(const Value: TToolResourcesParams): TAssistantsParams;
    /// <summary>
    /// Sets metadata for the assistant.
    /// </summary>
    /// <param name="Value">
    /// A <c>TJSONObject</c> instance containing metadata as key-value pairs. Keys can be
    /// up to 64 characters, and values up to 512 characters.
    /// </param>
    /// <returns>
    /// The <c>TAssistantsParams</c> instance, allowing for method chaining.
    /// </returns>
    function Metadata(const Value: TJSONObject): TAssistantsParams;
    /// <summary>
    /// Sets the temperature parameter for response randomness.
    /// </summary>
    /// <param name="Value">
    /// A floating-point number between 0 and 2. Higher values (e.g., 0.8) make the
    /// output more random, while lower values (e.g., 0.2) make it more deterministic.
    /// </param>
    /// <returns>
    /// The <c>TAssistantsParams</c> instance, allowing for method chaining.
    /// </returns>
    function Temperature(const Value: Double): TAssistantsParams;
    /// <summary>
    /// Sets the top-p parameter for nucleus sampling.
    /// </summary>
    /// <param name="Value">
    /// A floating-point number between 0 and 1. Lower values limit token selection to
    /// the most probable choices (e.g., 0.1 means only the top 10% probability mass is
    /// considered).
    /// </param>
    /// <returns>
    /// The <c>TAssistantsParams</c> instance, allowing for method chaining.
    /// </returns>
    function TopP(const Value: Double): TAssistantsParams;
    /// <summary>
    /// Sets the response format type.
    /// </summary>
    /// <param name="Value">
    /// A string representing the response format type. The default is "auto". Other values
    /// include "json_object" and "json_schema" for structured outputs.
    /// </param>
    /// <returns>
    /// The <c>TAssistantsParams</c> instance, allowing for method chaining.
    /// </returns>
    function ResponseFormat(const Value: string = 'auto'): TAssistantsParams; overload;
    /// <summary>
    /// Configures the response format using a <c>TResponseFormatParams</c> instance.
    /// </summary>
    /// <param name="Value">
    /// A <c>TResponseFormatParams</c> instance defining the response format properties.
    /// </param>
    /// <returns>
    /// The <c>TAssistantsParams</c> instance, allowing for method chaining.
    /// </returns>
    function ResponseFormat(const Value: TResponseFormatParams): TAssistantsParams; overload;
    /// <summary>
    /// Configures the response format using a <c>TJSONObject</c> instance.
    /// </summary>
    /// <param name="Value">
    /// A <c>TJSONObject</c> instance defining the response format properties.
    /// </param>
    /// <returns>
    /// The <c>TAssistantsParams</c> instance, allowing for method chaining.
    /// </returns>
    function ResponseFormat(const Value: TJSONObject): TAssistantsParams; overload;
  end;

  /// <summary>
  /// Represents the ranking options for a file search operation.
  /// </summary>
  /// <remarks>
  /// This class provides properties to configure the ranking mechanism of a file search,
  /// including the ranker type and score threshold for filtering results.
  /// </remarks>
  TRankingOptions = class
  private
    FRanker: string;
    [JsonNameAttribute('score_threshold')]
    FScoreThreshold: Double;
  public
    /// <summary>
    /// Specifies the ranking algorithm used for the file search.
    /// </summary>
    property Ranker: string read FRanker write FRanker;
    /// <summary>
    /// Defines the minimum score threshold for search results.
    /// </summary>
    /// <remarks>
    /// Only results with a score greater than or equal to this threshold will be included
    /// in the output. The value must be a floating-point number between 0 and 1.
    /// </remarks>
    property ScoreThreshold: Double read FScoreThreshold write FScoreThreshold;
  end;

  /// <summary>
  /// Represents the file search configuration for an assistant.
  /// </summary>
  /// <remarks>
  /// This class provides properties to define the file search behavior, including the
  /// maximum number of search results and ranking options for filtering results.
  /// </remarks>
  TAssistantsFileSearch = class
  private
    [JsonNameAttribute('max_num_results')]
    FMaxNumResults: Int64;
    [JsonNameAttribute('ranking_options')]
    FRankingOptions: TRankingOptions;
  public
    /// <summary>
    /// Specifies the maximum number of results to return from the file search.
    /// </summary>
    /// <remarks>
    /// The value must be an integer between 1 and 50. The default is 20 for GPT-4 models
    /// and 5 for GPT-3.5-turbo.
    /// </remarks>
    property MaxNumResults: Int64 read FMaxNumResults write FMaxNumResults;
    /// <summary>
    /// Defines the ranking options used for filtering and ordering search results.
    /// </summary>
    /// <remarks>
    /// The ranking options allow customization of the ranking algorithm and the minimum
    /// score threshold required for results to be included.
    /// </remarks>
    property RankingOptions: TRankingOptions read FRankingOptions write FRankingOptions;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a custom function definition for an assistant.
  /// </summary>
  /// <remarks>
  /// This class provides properties to define a function's name, description, parameters,
  /// and strict mode. Functions allow the assistant to execute predefined operations.
  /// </remarks>
  TAssistantsFunction = class
  private
    FDescription: string;
    FName: string;
    FParameters: string;
    FStrict: Boolean;
  public
    /// <summary>
    /// A brief description of what the function does.
    /// </summary>
    /// <remarks>
    /// This description helps the assistant determine when and how to call the function.
    /// </remarks>
    property Description: string read FDescription write FDescription;
    /// <summary>
    /// The name of the function.
    /// </summary>
    /// <remarks>
    /// The function name must be alphanumeric and can contain underscores and dashes.
    /// The maximum length is 64 characters.
    /// </remarks>
    property Name: string read FName write FName;
    /// <summary>
    /// Defines the parameters the function accepts.
    /// </summary>
    /// <remarks>
    /// This property specifies the expected input format using a JSON schema. It ensures
    /// that function calls follow a structured parameter format.
    /// </remarks>
    property Parameters: string read FParameters write FParameters;
    /// <summary>
    /// Determines whether the function follows strict schema adherence.
    /// </summary>
    /// <remarks>
    /// If set to <c>true</c>, the function strictly adheres to the defined parameter schema.
    /// This ensures structured outputs and prevents deviations from the expected format.
    /// </remarks>
    property Strict: Boolean read FStrict write FStrict;
  end;

  /// <summary>
  /// Represents a tool configuration for an assistant.
  /// </summary>
  /// <remarks>
  /// This class provides properties to define different types of tools that an assistant
  /// can use, such as file search or custom functions. Each tool configuration includes
  /// specific settings based on its type.
  /// </remarks>
  TAssistantsTools = class
  private
    [JsonReflectAttribute(ctString, rtString, TAssistantsToolsTypeInterceptor)]
    FType: TAssistantsToolsType;
    [JsonNameAttribute('file_search')]
    FFileSearch: TAssistantsFileSearch;
    FFunction: TAssistantsFunction;
  public
    /// <summary>
    /// Specifies the type of tool.
    /// </summary>
    /// <remarks>
    /// The type can be "file_search", "code_interpreter", or "function", depending on the
    /// tool's purpose. This determines which configuration properties are applicable.
    /// </remarks>
    property &Type: TAssistantsToolsType read FType write FType;
    /// <summary>
    /// Configuration settings for the file search tool.
    /// </summary>
    /// <remarks>
    /// This property is applicable only if the tool type is "file_search". It allows
    /// customization of file search behavior, including maximum results and ranking options.
    /// </remarks>
    property FileSearch: TAssistantsFileSearch read FFileSearch write FFileSearch;
    /// <summary>
    /// Configuration settings for a custom function tool.
    /// </summary>
    /// <remarks>
    /// This property is applicable only if the tool type is "function". It defines the
    /// function's name, description, parameters, and strict mode.
    /// </remarks>
    property &Function: TAssistantsFunction read FFunction write FFunction;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents the configuration for the code interpreter tool.
  /// </summary>
  /// <remarks>
  /// This class provides properties to specify the files accessible to the code interpreter.
  /// It enables the assistant to process and analyze code-related files.
  /// </remarks>
  TCodeInterpreter = class
  private
    [JsonNameAttribute('file_ids')]
    FFileIds: TArray<string>;
  public
    /// <summary>
    /// Specifies the list of file IDs accessible to the code interpreter.
    /// </summary>
    /// <remarks>
    /// This property allows defining which files the code interpreter can process.
    /// A maximum of 20 file IDs can be specified.
    /// </remarks>
    property FileIds: TArray<string> read FFileIds write FFileIds;
  end;

  /// <summary>
  /// Represents the configuration for the file search tool.
  /// </summary>
  /// <remarks>
  /// This class provides properties to specify the vector stores used for file searching.
  /// It enables the assistant to perform efficient and accurate file searches.
  /// </remarks>
  TFileSearch = class
  private
    [JsonNameAttribute('vector_store_ids')]
    FVectorStoreIds: TArray<string>;
  public
    /// <summary>
    /// Specifies the list of vector store IDs used for the file search.
    /// </summary>
    /// <remarks>
    /// This property allows defining the vector stores that the file search tool will query.
    /// The vector stores contain pre-processed data to optimize search operations.
    /// </remarks>
    property VectorStoreIds: TArray<string> read FVectorStoreIds write FVectorStoreIds;
  end;

  /// <summary>
  /// Represents the resources used by the tools configured for an assistant.
  /// </summary>
  /// <remarks>
  /// This class provides properties to define the resources available to tools such as
  /// the code interpreter and file search. These resources ensure that tools can perform
  /// their operations efficiently.
  /// </remarks>
  TToolResources = class
  private
    [JsonNameAttribute('code_interpreter')]
    FCodeInterpreter: TCodeInterpreter;
    [JsonNameAttribute('file_search')]
    FFileSearch: TFileSearch;
  public
    /// <summary>
    /// Specifies the configuration for the code interpreter tool.
    /// </summary>
    /// <remarks>
    /// This property allows defining the files accessible to the code interpreter tool,
    /// enabling it to process and analyze code-related files.
    /// </remarks>
    property CodeInterpreter: TCodeInterpreter read FCodeInterpreter write FCodeInterpreter;
    /// <summary>
    /// Specifies the configuration for the file search tool.
    /// </summary>
    /// <remarks>
    /// This property allows defining the vector stores that the file search tool will use
    /// for querying and retrieving relevant results.
    /// </remarks>
    property FileSearch: TFileSearch read FFileSearch write FFileSearch;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents an assistant configuration and its associated properties.
  /// </summary>
  /// <remarks>
  /// This class provides properties to define the assistant's settings, including its
  /// name, model, instructions, tools, and metadata. It extends <c>TJSONFingerprint</c>
  /// to support JSON serialization.
  /// </remarks>
  TAssistant = class(TJSONFingerprint)
  private
    FId: string;
    [JsonNameAttribute('created_at')]
    FCreatedAt: Int64;
    FObject: string;
    FName: string;
    FDescription: string;
    FModel: string;
    FInstructions: string;
    FTools: TArray<TAssistantsTools>;
    [JsonNameAttribute('tool_resources')]
    FToolResources: TToolResources;
    [JsonReflectAttribute(ctString, rtString, TMetadataInterceptor)]
    FMetadata: string;
    FTemperature: Double;
    [JsonNameAttribute('top_p')]
    FTopP: Double;
    [JsonNameAttribute('response_format')]
    FResponseFormat: string;
  public
    /// <summary>
    /// The unique identifier of the assistant.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// The creation timestamp of the assistant.
    /// </summary>
    /// <remarks>
    /// This property stores the Unix timestamp (in seconds) indicating when the assistant
    /// was created.
    /// </remarks>
    property CreatedAt: Int64 read FCreatedAt write FCreatedAt;
    /// <summary>
    /// The object type, which is always "assistant".
    /// </summary>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// The name of the assistant.
    /// </summary>
    /// <remarks>
    /// The assistant's name is a descriptive identifier with a maximum length of 256 characters.
    /// </remarks>
    property Name: string read FName write FName;
    /// <summary>
    /// A brief description of the assistant.
    /// </summary>
    /// <remarks>
    /// The description provides an overview of the assistant's purpose, with a maximum
    /// length of 512 characters.
    property Description: string read FDescription write FDescription;
    /// <summary>
    /// The model used by the assistant.
    /// </summary>
    /// <remarks>
    /// The model defines the assistant's capabilities. Available models can be retrieved
    /// using the OpenAI API.
    /// </remarks>
    property Model: string read FModel write FModel;
    /// <summary>
    /// The system instructions that guide the assistant's behavior.
    /// </summary>
    /// <remarks>
    /// Instructions define how the assistant should respond and interact. The maximum
    /// length is 256,000 characters.
    /// </remarks>
    property Instructions: string read FInstructions write FInstructions;
    /// <summary>
    /// The list of tools enabled for the assistant.
    /// </summary>
    /// <remarks>
    /// This property specifies the tools the assistant can use, such as file search,
    /// code interpreter, or custom functions.
    /// </remarks>
    property Tools: TArray<TAssistantsTools> read FTools write FTools;
    /// <summary>
    /// The resources available to the assistant's tools.
    /// </summary>
    property ToolResources: TToolResources read FToolResources write FToolResources;
    /// <summary>
    /// Metadata associated with the assistant.
    /// </summary>
    /// <remarks>
    /// This property stores additional information about the assistant as key-value pairs.
    /// Each key can have a maximum length of 64 characters, and each value up to 512 characters.
    /// </remarks>
    property Metadata: string read FMetadata write FMetadata;
    /// <summary>
    /// The temperature setting for response randomness.
    /// </summary>
    /// <remarks>
    /// A value between 0 and 2, where higher values (e.g., 0.8) make responses more random,
    /// while lower values (e.g., 0.2) make them more focused and deterministic.
    /// </remarks>
    property Temperature: Double read FTemperature write FTemperature;
    /// <summary>
    /// The top-p parameter for nucleus sampling.
    /// </summary>
    /// <remarks>
    /// A value between 0 and 1. Lower values limit token selection to the most probable
    /// choices (e.g., 0.1 means only the top 10% probability mass is considered).
    /// </remarks>
    property TopP: Double read FTopP write FTopP;
    /// <summary>
    /// The format in which the assistant should generate responses.
    /// </summary>
    /// <remarks>
    /// Possible values include "auto", "json_object", or "json_schema". Structured
    /// response formats ensure that outputs match a predefined schema.
    /// </remarks>
    property ResponseFormat: string read FResponseFormat write FResponseFormat;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a list of assistant objects.
  /// </summary>
  /// <remarks>
  /// This type is a specialization of <c>TAdvancedList</c> for handling a collection of
  /// <c>TAssistant</c> objects. It includes pagination metadata and provides access to
  /// multiple assistant configurations in a structured format.
  /// </remarks>
  TAssistants = TAdvancedList<TAssistant>;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TAssistant</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynAssistant</c> type extends the <c>TAsynParams&lt;TAssistant&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynAssistant = TAsynCallBack<TAssistant>;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TAssistants</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynAssistants</c> type extends the <c>TAsynParams&lt;TAssistants&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynAssistants = TAsynCallBack<TAssistants>;

  /// <summary>
  /// Represents the API route handler for managing assistants.
  /// </summary>
  /// <remarks>
  /// This class provides methods to create, retrieve, update, list, and delete assistants
  /// using the OpenAI API. It extends <c>TGenAIRoute</c> to handle API interactions and
  /// custom headers.
  /// </remarks>
  TAssistantsRoute = class(TGenAIRoute)
  protected
    /// <summary>
    /// Customizes headers for the assistants API requests.
    /// </summary>
    /// <remarks>
    /// This method ensures that specific headers required by the OpenAI Assistants API
    /// are included in every request.
    /// </remarks>
    procedure HeaderCustomize; override;
  public
    /// <summary>
    /// Asynchronously creates a new assistant.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure that defines the parameters for creating the assistant, using
    /// <c>TAssistantsParams</c>.
    /// </param>
    /// <param name="CallBacks">
    /// A callback function to handle the asynchronous response.
    /// </param>
    procedure AsynCreate(const ParamProc: TProc<TAssistantsParams>; const CallBacks: TFunc<TAsynAssistant>);
    /// <summary>
    /// Asynchronously retrieves a list of assistants.
    /// </summary>
    /// <param name="CallBacks">
    /// A callback function to handle the asynchronous response.
    /// </param>
    procedure AsynList(const CallBacks: TFunc<TAsynAssistants>); overload;
    /// <summary>
    /// Asynchronously retrieves a list of assistants with additional parameters.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to define advanced parameters for listing assistants, using
    /// <c>TUrlAdvancedParams</c>.
    /// </param>
    /// <param name="CallBacks">
    /// A callback function to handle the asynchronous response.
    /// </param>
    procedure AsynList(const ParamProc: TProc<TUrlAdvancedParams>; const CallBacks: TFunc<TAsynAssistants>); overload;
    /// <summary>
    /// Asynchronously retrieves a specific assistant by ID.
    /// </summary>
    /// <param name="AssistantId">
    /// The unique identifier of the assistant to retrieve.
    /// </param>
    /// <param name="CallBacks">
    /// A callback function to handle the asynchronous response.
    /// </param>
    procedure AsynRetrieve(const AssistantId: string; const CallBacks: TFunc<TAsynAssistant>);
    /// <summary>
    /// Asynchronously updates an existing assistant by ID.
    /// </summary>
    /// <param name="AssistantId">
    /// The unique identifier of the assistant to update.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure that defines the parameters for updating the assistant, using
    /// <c>TAssistantsParams</c>.
    /// </param>
    /// <param name="CallBacks">
    /// A callback function to handle the asynchronous response.
    /// </param>
    procedure AsynUpdate(const AssistantId: string; const ParamProc: TProc<TAssistantsParams>;
      const CallBacks: TFunc<TAsynAssistant>);
    /// <summary>
    /// Asynchronously deletes an assistant by ID.
    /// </summary>
    /// <param name="AssistantId">
    /// The unique identifier of the assistant to delete.
    /// </param>
    /// <param name="CallBacks">
    /// A callback function to handle the asynchronous response.
    /// </param>
    procedure AsynDelete(const AssistantId: string; const CallBacks: TFunc<TAsynDeletion>);
    /// <summary>
    /// Creates a new assistant synchronously.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure that defines the parameters for creating the assistant, using
    /// <c>TAssistantsParams</c>.
    /// </param>
    /// <returns>
    /// A <c>TAssistant</c> object representing the created assistant.
    /// </returns>
    function Create(const ParamProc: TProc<TAssistantsParams>): TAssistant;
    /// <summary>
    /// Retrieves a list of assistants synchronously.
    /// </summary>
    /// <returns>
    /// A <c>TAssistants</c> object containing a list of assistant configurations.
    /// </returns>
    function List: TAssistants; overload;
    /// <summary>
    /// Retrieves a list of assistants synchronously with additional parameters.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to define advanced parameters for listing assistants, using
    /// <c>TUrlAdvancedParams</c>.
    /// </param>
    /// <returns>
    /// A <c>TAssistants</c> object containing a list of assistant configurations.
    /// </returns>
    function List(const ParamProc: TProc<TUrlAdvancedParams>): TAssistants; overload;
    /// <summary>
    /// Retrieves a specific assistant synchronously by ID.
    /// </summary>
    /// <param name="AssistantId">
    /// The unique identifier of the assistant to retrieve.
    /// </param>
    /// <returns>
    /// A <c>TAssistant</c> object representing the retrieved assistant.
    /// </returns>
    function Retrieve(const AssistantId: string): TAssistant;
    /// <summary>
    /// Updates an existing assistant synchronously by ID.
    /// </summary>
    /// <param name="AssistantId">
    /// The unique identifier of the assistant to update.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure that defines the parameters for updating the assistant, using
    /// <c>TAssistantsParams</c>.
    /// </param>
    /// <returns>
    /// A <c>TAssistant</c> object representing the updated assistant.
    /// </returns>
    function Update(const AssistantId: string; const ParamProc: TProc<TAssistantsParams>): TAssistant;
    /// <summary>
    /// Deletes an assistant synchronously by ID.
    /// </summary>
    /// <param name="AssistantId">
    /// The unique identifier of the assistant to delete.
    /// </param>
    /// <returns>
    /// A <c>TAssistantDeletion</c> object containing the deletion status.
    /// </returns>
    function Delete(const AssistantId: string): TDeletion;
  end;

implementation

{ TAssistantsParams }

function TAssistantsParams.Description(const Value: string): TAssistantsParams;
begin
  Result := TAssistantsParams(Add('description', Value));
end;

function TAssistantsParams.Instructions(const Value: string): TAssistantsParams;
begin
  Result := TAssistantsParams(Add('instructions', Value));
end;

function TAssistantsParams.Metadata(
  const Value: TJSONObject): TAssistantsParams;
begin
  Result := TAssistantsParams(Add('metadata', Value));
end;

function TAssistantsParams.Model(const Value: string): TAssistantsParams;
begin
  Result := TAssistantsParams(Add('model', Value));
end;

function TAssistantsParams.Name(const Value: string): TAssistantsParams;
begin
  Result := TAssistantsParams(Add('name', Value));
end;

function TAssistantsParams.ReasoningEffort(
  const Value: TReasoningEffort): TAssistantsParams;
begin
  Result := TAssistantsParams(Add('reasoning_effort', Value.ToString));
end;

function TAssistantsParams.ReasoningEffort(
  const Value: string): TAssistantsParams;
begin
  Result := TAssistantsParams(Add('reasoning_effort', TReasoningEffort.Create(Value).ToString));
end;

function TAssistantsParams.ResponseFormat(
  const Value: TJSONObject): TAssistantsParams;
begin
  Result := TAssistantsParams(Add('response_format', Value));
end;

function TAssistantsParams.ResponseFormat(
  const Value: TResponseFormatParams): TAssistantsParams;
begin
  Result := TAssistantsParams(Add('response_format', Value.Detach));
end;

function TAssistantsParams.ResponseFormat(
  const Value: string): TAssistantsParams;
begin
  Result := TAssistantsParams(Add('response_format', Value));
end;

function TAssistantsParams.Temperature(const Value: Double): TAssistantsParams;
begin
  Result := TAssistantsParams(Add('temperature', Value));
end;

function TAssistantsParams.ToolResources(
  const Value: TToolResourcesParams): TAssistantsParams;
begin
  Result := TAssistantsParams(Add('tool_resources', Value.Detach));
end;

function TAssistantsParams.Tools(
  const Value: TArray<TAssistantsToolsParams>): TAssistantsParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TAssistantsParams(Add('tools', JSONArray));
end;

function TAssistantsParams.TopP(const Value: Double): TAssistantsParams;
begin
  Result := TAssistantsParams(Add('top_p', Value));
end;

{ TAssistantsToolsParams }

function TAssistantsToolsParams.&Type(const Value: string): TAssistantsToolsParams;
begin
  Result := TAssistantsToolsParams(Add('type', TAssistantsToolsType.Create(Value).ToString));
end;

function TAssistantsToolsParams.&Function(
  const Value: TAssistantsFunctionParams): TAssistantsToolsParams;
begin
  Result := TAssistantsToolsParams(Add('function', Value));
end;

function TAssistantsToolsParams.FileSearch(
  const Value: TFileSearchToolParams): TAssistantsToolsParams;
begin
  Result := TAssistantsToolsParams(Add('file_search', Value.Detach));
end;

function TAssistantsToolsParams.&Type(
  const Value: TAssistantsToolsType): TAssistantsToolsParams;
begin
  Result := TAssistantsToolsParams(Add('type', Value.ToString));
end;

{ TFileSearchToolParams }

function TFileSearchToolParams.MaxNumResults(
  const Value: Integer): TFileSearchToolParams;
begin
  Result := TFileSearchToolParams(Add('max_num_results', Value));
end;

function TFileSearchToolParams.RankingOptions(
  const Value: TRankingOptionsParams): TFileSearchToolParams;
begin
  Result := TFileSearchToolParams(Add('ranking_options', Value.Detach));
end;

{ TRankingOptionsParams }

function TRankingOptionsParams.Ranker(
  const Value: string): TRankingOptionsParams;
begin
  Result := TRankingOptionsParams(Add('ranker', Value));
end;

function TRankingOptionsParams.ScoreThreshold(
  const Value: Double): TRankingOptionsParams;
begin
  Result := TRankingOptionsParams(Add('score_threshold', Value));
end;

{ TAssistantsFunctionParams }

function TAssistantsFunctionParams.Description(const Value: string): TAssistantsFunctionParams;
begin
  Result := TAssistantsFunctionParams(Add('description', Value));
end;

function TAssistantsFunctionParams.Name(const Value: string): TAssistantsFunctionParams;
begin
  Result := TAssistantsFunctionParams(Add('name', Value));
end;

function TAssistantsFunctionParams.Parameters(const Value: TJSONObject): TAssistantsFunctionParams;
begin
  Result := TAssistantsFunctionParams(Add('parameters', Value));
end;

function TAssistantsFunctionParams.&Strict(const Value: Boolean): TAssistantsFunctionParams;
begin
  Result := TAssistantsFunctionParams(Add('strict', Value));
end;

function TAssistantsFunctionParams.Parameters(
  const Value: TSchemaParams): TAssistantsFunctionParams;
begin
  Result := TAssistantsFunctionParams(Add('parameters', Value.Detach));
end;

{ TToolResourcesParams }

function TToolResourcesParams.CodeInterpreter(
  const Value: TCodeInterpreterParams): TToolResourcesParams;
begin
  Result := TToolResourcesParams(Add('code_interpreter', Value.Detach));
end;

function TToolResourcesParams.CodeInterpreter(
  const FileIds: TArray<string>): TToolResourcesParams;
begin
  Result := TToolResourcesParams(Add('code_interpreter', TCodeInterpreterParams.Create.FileIds(FileIds)));
end;

function TToolResourcesParams.FileSearch(
  const Value: TFileSearchParams): TToolResourcesParams;
begin
  Result := TToolResourcesParams(Add('file_search', Value.Detach));
end;

{ TCodeInterpreterParams }

function TCodeInterpreterParams.FileIds(
  const Value: TArray<string>): TCodeInterpreterParams;
begin
  Result := TCodeInterpreterParams(Add('file_ids', Value));
end;

{ TFileSearchParams }

function TFileSearchParams.VectorStoreIds(
  const Value: TArray<string>): TFileSearchParams;
begin
  Result := TFileSearchParams(Add('vector_store_ids', Value));
end;

function TFileSearchParams.VectorStores(
  const Value: TArray<TVectorStoresParams>): TFileSearchParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TFileSearchParams(Add('vector_stores', JSONArray));
end;

{ TVectorStoresParams }

function TVectorStoresParams.ChunkingStrategy(
  const Value: TChunkingStrategyParams): TVectorStoresParams;
begin
  Result := TVectorStoresParams(Add('chunking_strategy', Value.Detach));
end;

function TVectorStoresParams.FileIds(
  const Value: TArray<string>): TVectorStoresParams;
begin
  Result := TVectorStoresParams(Add('file_ids', Value));
end;

function TVectorStoresParams.Metadata(
  const Value: TJSONObject): TVectorStoresParams;
begin
  Result := TVectorStoresParams(Add('metadata', Value));
end;

{ TChunkingStrategyParams }

function TChunkingStrategyParams.Static(
  const Value: TChunkStaticParams): TChunkingStrategyParams;
begin
  Result := TChunkingStrategyParams(Add('static', Value.Detach));
end;

function TChunkingStrategyParams.&Type(
  const Value: string): TChunkingStrategyParams;
begin
  Result := TChunkingStrategyParams(Add('type', TChunkingStrategyType.Create(Value).ToString));
end;

function TChunkingStrategyParams.&Type(
  const Value: TChunkingStrategyType): TChunkingStrategyParams;
begin
  Result := TChunkingStrategyParams(Add('type', Value.ToString));
end;

{ TChunkStaticParams }

function TChunkStaticParams.ChunkOverlapTokens(
  const Value: Integer): TChunkStaticParams;
begin
  Result := TChunkStaticParams(Add('chunk_overlap_tokens', Value));
end;

function TChunkStaticParams.MaxChunkSizeTokens(
  const Value: Integer): TChunkStaticParams;
begin
  Result := TChunkStaticParams(Add('max_chunk_size_tokens', Value));
end;

{ TResponseFormatParams }

function TResponseFormatParams.&Type(
  const Value: string): TResponseFormatParams;
begin
  Result := TResponseFormatParams(Add('type', TResponseFormatType.Create(Value).ToString));
end;

function TResponseFormatParams.&Type(
  const Value: TResponseFormatType): TResponseFormatParams;
begin
  Result := TResponseFormatParams(Add('type', Value.ToString));
end;

function TResponseFormatParams.JsonSchema(
  const Value: TJsonSchemaParams): TResponseFormatParams;
begin
  Result := TResponseFormatParams(Add('json_schema', Value.Detach));
end;

function TResponseFormatParams.JsonSchema(
  const Value: TJsonObject): TResponseFormatParams;
begin
  Result := TResponseFormatParams(Add('json_schema', Value));
end;

{ TJsonSchemaParams }

function TJsonSchemaParams.Description(const Value: string): TJsonSchemaParams;
begin
  Result := TJsonSchemaParams(Add('description', Value));
end;

function TJsonSchemaParams.Name(const Value: string): TJsonSchemaParams;
begin
  Result := TJsonSchemaParams(Add('name', Value));
end;

function TJsonSchemaParams.Schema(const Value: TJSONObject): TJsonSchemaParams;
begin
  Result := TJsonSchemaParams(Add('schema', Value));
end;

function TJsonSchemaParams.&Strict(const Value: Boolean): TJsonSchemaParams;
begin
  Result := TJsonSchemaParams(Add('strict', Value));
end;

function TJsonSchemaParams.Schema(
  const Value: TSchemaParams): TJsonSchemaParams;
begin
  Result := TJsonSchemaParams(Add('schema', Value.Detach));
end;

{ TAssistant }

destructor TAssistant.Destroy;
begin
  for var Item in FTools do
    Item.Free;
  if Assigned(FToolResources) then
    FToolResources.Free;
  inherited;
end;

{ TAssistantsFileSearch }

destructor TAssistantsFileSearch.Destroy;
begin
  if Assigned(FRankingOptions) then
    FRankingOptions.Free;
  inherited;
end;

{ TAssistantsTools }

destructor TAssistantsTools.Destroy;
begin
  if Assigned(FFileSearch) then
    FFileSearch.Free;
  if Assigned(FFunction) then
    FFunction.Free;
  inherited;
end;

{ TToolResources }

destructor TToolResources.Destroy;
begin
  if Assigned(FCodeInterpreter) then
    FCodeInterpreter.Free;
  if Assigned(FFileSearch) then
    FFileSearch.Free;
  inherited;
end;

{ TAssistantsRoute }

procedure TAssistantsRoute.AsynCreate(const ParamProc: TProc<TAssistantsParams>;
  const CallBacks: TFunc<TAsynAssistant>);
begin
  with TAsynCallBackExec<TAsynAssistant, TAssistant>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TAssistant
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TAssistantsRoute.AsynList(const CallBacks: TFunc<TAsynAssistants>);
begin
  with TAsynCallBackExec<TAsynAssistants, TAssistants>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TAssistants
      begin
        Result := Self.List;
      end);
  finally
    Free;
  end;
end;

procedure TAssistantsRoute.AsynDelete(const AssistantId: string;
  const CallBacks: TFunc<TAsynDeletion>);
begin
  with TAsynCallBackExec<TAsynDeletion, TDeletion>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TDeletion
      begin
        Result := Self.Delete(AssistantId);
      end);
  finally
    Free;
  end;
end;

procedure TAssistantsRoute.AsynList(const ParamProc: TProc<TUrlAdvancedParams>;
  const CallBacks: TFunc<TAsynAssistants>);
begin
  with TAsynCallBackExec<TAsynAssistants, TAssistants>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TAssistants
      begin
        Result := Self.List(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TAssistantsRoute.AsynRetrieve(const AssistantId: string;
  const CallBacks: TFunc<TAsynAssistant>);
begin
  with TAsynCallBackExec<TAsynAssistant, TAssistant>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TAssistant
      begin
        Result := Self.Retrieve(AssistantId);
      end);
  finally
    Free;
  end;
end;

procedure TAssistantsRoute.AsynUpdate(const AssistantId: string;
  const ParamProc: TProc<TAssistantsParams>;
  const CallBacks: TFunc<TAsynAssistant>);
begin
  with TAsynCallBackExec<TAsynAssistant, TAssistant>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TAssistant
      begin
        Result := Self.Update(AssistantId, ParamProc);
      end);
  finally
    Free;
  end;
end;

function TAssistantsRoute.Create(
  const ParamProc: TProc<TAssistantsParams>): TAssistant;
begin
  HeaderCustomize;
  Result := API.Post<TAssistant, TAssistantsParams>('assistants', ParamProc);
end;

function TAssistantsRoute.Delete(const AssistantId: string): TDeletion;
begin
  HeaderCustomize;
  Result := API.Delete<TDeletion>('assistants/' + AssistantId);
end;

procedure TAssistantsRoute.HeaderCustomize;
begin
  inherited;
  API.CustomHeaders := [TNetHeader.Create('OpenAI-Beta', 'assistants=v2')];
end;

function TAssistantsRoute.List(
  const ParamProc: TProc<TUrlAdvancedParams>): TAssistants;
begin
  HeaderCustomize;
  Result := API.Get<TAssistants, TUrlAdvancedParams>('assistants', ParamProc);
end;

function TAssistantsRoute.List: TAssistants;
begin
  HeaderCustomize;
  Result := API.Get<TAssistants>('assistants');
end;

function TAssistantsRoute.Retrieve(const AssistantId: string): TAssistant;
begin
  HeaderCustomize;
  Result := API.Get<TAssistant>('assistants/' + AssistantId );
end;

function TAssistantsRoute.Update(const AssistantId: string;
  const ParamProc: TProc<TAssistantsParams>): TAssistant;
begin
  HeaderCustomize;
  Result := API.Post<TAssistant, TAssistantsParams>('assistants/' + AssistantId, ParamProc);
end;

end.

unit GenAI.Async.Params;

{-------------------------------------------------------------------------------

      Unit containing generic interfaces and classes for managing parameters
      across  various  asynchronous  operations.

      The GenAI.Async.Params  unit  provides  a set of tools for creating
      and managing  parameter  instances  using  generic  types. The primary
      components include:

      - IUseParams<T>: A generic interface for managing parameters of type T.
      - TUseParams<T>: A class  implementing  the IUseParams<T>  interface to
        encapsulate  parameter  handling.
      - TUseParamsFactory<T>: A  factory  class  for  creating  instances  of
        IUseParams<T>.

      These abstractions allow for  a flexible and  reusable  way  to  handle
      parameters  across  different  modules  and  contexts,  particularly in
      asynchronous  scenarios  such  as  chat  operations.

      Note  that  This  unit  is  designed   to  work   seamlessly  with  the
      GenAI.Chat.AsyncEvents unit,  which  relies  on  IUseParams<T> and
      TUseParamsFactory<T>  to  manage   parameters   for  asynchronous  chat
      requests.

        Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
        Visit the Github repository for the documentation and use examples

-------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes;

type
  /// <summary>
  /// Generic interface for managing parameters of type <c>T</c>.
  /// </summary>
  /// <typeparam name="T">
  /// The type of the parameters.
  /// </typeparam>
  IUseParams<T> = interface
    ['{D7C1F3AC-CA7C-49E5-9250-8E898B28EC97}']
    /// <summary>
    /// Sets the parameters.
    /// </summary>
    /// <param name="Value">
    /// The value of the parameters to be set.
    /// </param>
    procedure SetParams(const Value: T);
    /// <summary>
    /// Gets the current parameters.
    /// </summary>
    /// <returns>
    /// The current parameters of type <c>T</c>.
    /// </returns>
    function GetParams: T;
    /// <summary>
    /// Assigns the parameters using a function.
    /// </summary>
    /// <param name="Value">
    /// A function that returns parameters of type <c>T</c>.
    /// </param>
    procedure Assign(Value: TFunc<T>);
    /// <summary>
    /// Returns the current instance as an object of type <c>TObject</c>.
    /// </summary>
    /// <returns>
    /// The instance cast to <c>TObject</c>.
    /// </returns>
    function AsSender: TObject;
    /// <summary>
    /// Provides access to the parameters as a property.
    /// </summary>
    property Param: T read GetParams write SetParams;
  end;

  /// <summary>
  /// A factory class for creating instances of <c>IUseParams</c>.
  /// </summary>
  /// <param name="T">
  /// The type of the parameters for which the instance is created.
  /// </param>
  TUseParamsFactory<T> = class
    /// <summary>
    /// Creates and returns a new instance of <c>IUseParams</c> for the specified type <c>T</c>.
    /// </summary>
    /// <returns>
    /// A new instance of <c>IUseParams&lt;T&gt;</c>.
    /// </returns>
    class function CreateInstance: IUseParams<T>; overload;
    /// <summary>
    /// Creates and returns a new instance of <c>IUseParams</c> for the specified type <c>T</c>, using the provided function.
    /// </summary>
    /// <param name="Value">
    /// A function that provides the parameter values for the instance.
    /// </param>
    /// <returns>
    /// A new instance of <c>IUseParams&lt;T&gt;</c>.
    /// </returns>
    class function CreateInstance(Value: TFunc<T>): IUseParams<T>; overload;
  end;

  /// <summary>
  /// A generic class implementing the <c>IUseParams</c> interface to manage parameters of type <c>T</c>.
  /// </summary>
  /// <param name="T">
  /// The type of the parameters.
  /// </param>
  TUseParams<T> = class(TInterfacedObject, IUseParams<T>)
  private
    FParams: T;
    /// <summary>
    /// Sets the parameters to the provided value.
    /// </summary>
    /// <param name="Value">
    /// The new parameters value.
    /// </param>
    procedure SetParams(const Value: T);
    /// <summary>
    /// Retrieves the current parameters value.
    /// </summary>
    /// <returns>
    /// The current parameters.
    /// </returns>
    function GetParams: T;
  protected
    /// <summary>
    /// Casts the instance as a <c>TObject</c> for use as the sender of events.
    /// </summary>
    /// <returns>
    /// The current instance cast to <c>TObject</c>.
    /// </returns>
    function AsSender: TObject;
    /// <summary>
    /// Assigns the parameters using a function that returns type <c>T</c>.
    /// </summary>
    /// <param name="Value">
    /// A function that sets the parameters.
    /// </param>
    procedure Assign(Value: TFunc<T>);
  public
    /// <summary>
    /// Property to get or set the parameters.
    /// </summary>
    property Params: T read GetParams write SetParams;
  end;

implementation

{ TUseParams<T> }

function TUseParams<T>.AsSender: TObject;
begin
  Result := Self;
end;

procedure TUseParams<T>.Assign(Value: TFunc<T>);
begin
  if Assigned(Value) then
    begin
      Params := Value();
    end;
end;

function TUseParams<T>.GetParams: T;
begin
  Result := FParams;
end;

procedure TUseParams<T>.SetParams(const Value: T);
begin
  FParams := Value;
end;

{ TUseParamsFactory<T> }

class function TUseParamsFactory<T>.CreateInstance: IUseParams<T>;
begin
  Result := TUseParams<T>.Create;
end;

class function TUseParamsFactory<T>.CreateInstance(
  Value: TFunc<T>): IUseParams<T>;
begin
  Result := CreateInstance;
  Result.Assign(Value);
end;

end.

unit GenAI.Async.Support;

{-------------------------------------------------------------------------------

      Unit containing  records for managing  asynchronous events related to
      chat requests.

      The  GenAI.Chat.AsyncEvents  unit  provides  definitions for the
      TAsyncParams<T>  and  TAsynStreamParams<T>  records, which  are  used
      to  handle  the lifecycle  of asynchronous chat operations, including
      starting, progressing, succeeding, and handling errors.
      These records enable non-blocking operations for chat functionalities
      and can be reused across multiple modules.

      This  unit  depends  on GenAI.Async.Params  for parameter  management.
      The IUseParams<T>  and  TUseParamsFactory<T>  interfaces  and  classes
      from  GenAI.Params.Core  are  utilized  to  create and manage the
      parameter  instances  for  asynchronous  operations.

        Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
        Visit the Github repository for the documentation and use examples

-------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, system.Classes, System.Threading, GenAI.Async.Params;

type
  /// <summary>
  /// Record used to handle asynchronous request events.
  /// </summary>
  /// <remarks>
  /// <c>TAsynCallBack</c> manages the lifecycle of an asynchronous request.
  /// It provides callbacks for different stages of the request, such as start, successful completion, or error.
  /// </remarks>
  TAsynCallBack<T> = record
  private
    FSender: TObject;
    FOnStart: TProc<TObject>;
    FOnSuccess: TProc<TObject, T>;
    FOnError: TProc<TObject, string>;
  public
    /// <summary>
    /// Object representing the sender of the asynchronous operation.
    /// </summary>
    /// <remarks>
    /// The <c>Sender</c> property is used to identify or store a reference to the object that initiated the request.
    /// This can be useful for providing context in the callback procedures.
    /// </remarks>
    property Sender: TObject read FSender write FSender;
    /// <summary>
    /// Event triggered at the start of the asynchronous request.
    /// </summary>
    /// <remarks>
    /// The <c>OnStart</c> event is called when the request begins.
    /// It can be used to initialize any required state or display a loading indicator to the user.
    /// <code>
    /// OnStart :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // Code executed at the start of the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnStart: TProc<TObject> read FOnStart write FOnStart;
    /// <summary>
    /// Event triggered at the end of the asynchronous request.
    /// </summary>
    /// <param name="Sender">
    /// Object that initiated the request, generally used for context.
    /// </param>
    /// <param name="Result">
    /// The result of type <c>T</c> returned at the end of the request.
    /// This event is used to process the final result of the asynchronous operation.
    /// </param>
    /// <remarks>
    /// The <c>OnSuccess</c> event is invoked when the process completes successfully.
    /// It can be used to perform final actions based on the received result.
    /// <code>
    /// OnSuccess :=
    ///    procedure (Sender: TObject; Result: T)
    ///    begin
    ///      // Code executed at the end of the request with the obtained result
    ///    end;
    /// </code>
    /// </remarks>
    property OnSuccess: TProc<TObject, T> read FOnSuccess write FOnSuccess;
    /// <summary>
    /// Event triggered when an error occurs during the asynchronous request.
    /// </summary>
    /// <param name="Sender">
    /// Object that initiated the request, generally used for context.
    /// </param>
    /// <param name="ErrorMessage">
    /// The error message received, which can be logged or displayed to the user.
    /// </param>
    /// <remarks>
    /// The <c>OnError</c> event is called when an error occurs during the asynchronous operation.
    /// It can be used to handle failures, display error messages, or perform any necessary cleanup actions.
    /// <code>
    /// OnError :=
    ///    procedure (Sender: TObject; ErrorMessage: string)
    ///    begin
    ///      // Code executed when an error occurs during the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnError: TProc<TObject, string> read FOnError write FOnError;
  end;

  /// <summary>
  /// Class used to manage asynchronous execution with callback events.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynCallBackExec&lt;T, U&gt;</c> class allows you to execute asynchronous operations with specified callbacks for start, completion, and error events.
  /// It encapsulates the asynchronous execution logic, handling thread management and exception handling, providing an easy way to manage the lifecycle of an asynchronous request.
  /// </remarks>
  TAsynCallBackExec<T; U: class> = class
  private
    FUse: IUseParams<T>;
    FSender: TObject;
    FOnStart: TProc<TObject>;
    FOnSuccess: TProc<TObject, U>;
    FOnError: TProc<TObject, string>;
  public
    /// <summary>
    /// Gets the <c>IUseParams&lt;T&gt;</c> interface instance used by this class.
    /// </summary>
    /// <value>
    /// An instance of <c>IUseParams&lt;T&gt;</c> that provides parameter management functionality.
    /// </value>
    property Use: IUseParams<T> read FUse;
    /// <summary>
    /// The object representing the sender of the asynchronous operation.
    /// </summary>
    /// <value>
    /// An instance of <c>TObject</c> identifying the originator of the operation.
    /// </value>
    /// <remarks>
    /// This property can be set to identify the object that initiated the asynchronous operation, which is useful in callback methods.
    /// </remarks>
    property Sender: TObject read FSender write FSender;
    /// <summary>
    /// Event triggered when the asynchronous operation starts.
    /// </summary>
    /// <value>
    /// A procedure of type <c>TProc&lt;TObject&gt;</c> to handle any setup or UI updates when the operation begins.
    /// </value>
    /// <remarks>
    /// Assign a procedure to this event to perform actions at the start of the asynchronous operation.
    /// <code>
    /// OnStart :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // Code executed at the start of the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnStart: TProc<TObject> read FOnStart write FOnStart;
    /// <summary>
    /// Event triggered when the asynchronous operation completes successfully.
    /// </summary>
    /// <value>
    /// A procedure of type <c>TProc&lt;TObject, U&gt;</c> to handle the result of the operation.
    /// </value>
    /// <remarks>
    /// Assign a procedure to this event to process the result returned by the operation.
    /// <code>
    /// OnSuccess :=
    ///    procedure (Sender: TObject; Result: T)
    ///    begin
    ///      // Code executed at the end of the request with the obtained result
    ///    end;
    /// </code>
    /// </remarks>
    property OnSuccess: TProc<TObject, U> read FOnSuccess write FOnSuccess;
    /// <summary>
    /// Event triggered when an error occurs during the asynchronous operation.
    /// </summary>
    /// <value>
    /// A procedure of type <c>TProc&lt;TObject, string&gt;</c> to handle exceptions or errors.
    /// </value>
    /// <remarks>
    /// Assign a procedure to this event to handle any exceptions or errors that occur during execution.
    /// <code>
    /// OnError :=
    ///    procedure (Sender: TObject; ErrorMessage: string)
    ///    begin
    ///      // Code executed when an error occurs during the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnError: TProc<TObject, string> read FOnError write FOnError;
    /// <summary>
    /// Executes the specified function asynchronously.
    /// </summary>
    /// <param name="Value">
    /// A function of type <c>TFunc&lt;U&gt;</c> representing the operation to execute asynchronously.
    /// </param>
    /// <remarks>
    /// This method creates and starts an asynchronous task that executes the provided function.
    /// It invokes the <c>OnStart</c> event before execution, the <c>OnSuccess</c> event upon successful completion, and the <c>OnError</c> event if an exception occurs during execution.
    /// </remarks>
    procedure Run(Value: TFunc<U>);
    /// <summary>
    /// Initializes a new instance of the <c>TAsynCallBackExec&lt;T, U&gt;</c> class with the specified parameter function.
    /// </summary>
    /// <param name="Value">
    /// A function of type <c>TFunc&lt;T&gt;</c> used to create an instance of <c>IUseParams&lt;T&gt;</c>.
    /// </param>
    /// <remarks>
    /// The constructor initializes the internal <c>IUseParams&lt;T&gt;</c> interface using the provided function.
    /// </remarks>
    constructor Create(const Value: TFunc<T>);
  end;

  /// <summary>
  /// Record used to manage asynchronous events for a streaming chat request.
  /// </summary>
  /// <remarks>
  /// <c>TAsynChatStreamParams</c> allows you to handle the lifecycle of a chat request in streaming mode.
  /// It provides callbacks for different stages such as when the request starts, progresses, succeeds, encounters an error, or needs to be canceled.
  /// </remarks>
  TAsynStreamCallBack<T> = record
  private
    FSender: TObject;
    FOnStart: TProc<TObject>;
    FOnSuccess: TProc<TObject>;
    FOnProgress: TProc<TObject, T>;
    FOnError: TProc<TObject, string>;
    FOnCancellation: TProc<TObject>;
    FOnDoCancel: TFunc<Boolean>;
  public
    /// <summary>
    /// The object representing the sender of the asynchronous operation.
    /// </summary>
    /// <remarks>
    /// The <c>Sender</c> property is used to identify or store a reference to the object that initiated the chat request,
    /// which can be useful for context within the callback procedures.
    /// </remarks>
    property Sender: TObject read FSender write FSender;
    /// <summary>
    /// Event triggered when the asynchronous chat request starts.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="Chat">
    /// The <c>TChat</c> object representing the current response chunk received from the model.
    /// This event can be used to update the user interface as new tokens are streamed in.
    /// </param>
    /// <remarks>
    /// The <c>OnStart</c> event is called when the chat request begins. It can be used to set up any initial state or display a loading indicator to the user.
    /// <code>
    /// OnStart :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // code when chat request begin
    ///    end;
    /// </code>
    /// </remarks>
    property OnStart: TProc<TObject> read FOnStart write FOnStart;
    /// <summary>
    /// Event triggered when the asynchronous chat request completes successfully.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="Chat">
    /// The <c>TChat</c> object representing the current response chunk received from the model.
    /// This event can be used to update the user interface as new tokens are streamed in.
    /// </param>
    /// <remarks>
    /// The <c>OnSuccess</c> event is invoked when the streaming process finishes successfully.
    /// It does not provide additional data, as the result is expected to have been handled progressively via the <c>OnProgress</c> event.
    /// <code>
    /// OnSuccess :=
    ///    procedure (Sender: TObject; Chat: TChat)
    ///    begin
    ///      // code when the streaming process finishes successfully
    ///    end;
    /// </code>
    /// </remarks>
    property OnSuccess: TProc<TObject> read FOnSuccess write FOnSuccess;
    /// <summary>
    /// Event triggered to handle progress during the streaming chat request.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="Chat">
    /// The <c>TChat</c> object representing the current response chunk received from the model.
    /// This event can be used to update the user interface as new tokens are streamed in.
    /// </param>
    /// <remarks>
    /// The <c>OnProgress</c> event is fired every time a new chunk of data is received during the streaming process.
    /// This allows the application to handle the response progressively as it is generated by the model.
    /// <code>
    /// OnProgress :=
    ///    procedure (Sender: TObject; Chat: TChat)
    ///    begin
    ///      // code to handle the response progressively
    ///    end;
    /// </code>
    /// </remarks>
    property OnProgress: TProc<TObject, T> read FOnProgress write FOnProgress;
    /// <summary>
    /// Event triggered when an error occurs during the asynchronous chat request.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="ErrorMessage">
    /// The error message received, which can be logged or displayed to the user.
    /// </param>
    /// <remarks>
    /// The <c>OnError</c> event is called when an error occurs during the streaming process.
    /// This can be used to handle failures, show error messages, or perform any necessary clean-up actions.
    /// <code>
    /// OnError :=
    ///    procedure (Sender: TObject; message: string)
    ///    begin
    ///      // code to handle an error occurs during the streaming process
    ///    end;
    /// </code>
    /// </remarks>
    property OnError: TProc<TObject, string> read FOnError write FOnError;
    /// <summary>
    /// Event triggered when the asynchronous chat request has been canceled.
    /// </summary>
    /// <remarks>
    /// The <c>OnCancellation</c> event is fired when the chat request is canceled by the user or the application.
    /// This can be used to perform clean-up operations or notify the user that the request has been terminated.
    /// <code>
    /// OnCancellation :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // code to handle chat request cancellation
    ///    end;
    /// </code>
    /// </remarks>
    property OnCancellation: TProc<TObject> read FOnCancellation write FOnCancellation;
    /// <summary>
    /// Function called to determine if the asynchronous chat request should be canceled.
    /// </summary>
    /// <returns>
    /// A <c>Boolean</c> value indicating whether the request should be canceled (<c>True</c>) or allowed to continue (<c>False</c>).
    /// </returns>
    /// <remarks>
    /// The <c>OnDoCancel</c> function is periodically invoked to check whether the user or application has requested to cancel the chat request.
    /// If the function returns <c>True</c>, the streaming process will be aborted.
    /// <code>
    /// OnDoCancel :=
    ///    function : Boolean
    ///    begin
    ///      Result := ... // True to stop the streaming process
    ///    end;
    /// </code>
    /// </remarks>
    property OnDoCancel: TFunc<Boolean> read FOnDoCancel write FOnDoCancel;
  end;

implementation

{ TAsynCallBackExec<T, U> }

constructor TAsynCallBackExec<T, U>.Create(const Value: TFunc<T>);
begin
  inherited Create;
  FUse := TUseParamsFactory<T>.CreateInstance(Value);
end;

procedure TAsynCallBackExec<T, U>.Run(Value: TFunc<U>);
begin
  {--- Assign callback values to internal variables for asynchrony to work properly }
  var InternalSender := Sender;
  var InternalOnStart := OnStart;
  var InternalOnSuccess := OnSuccess;
  var InternalOnError := OnError;

  var Task: ITask := TTask.Create(
          procedure()
          begin
            try
              {--- Pass the instance of the current class in case no value was specified. }
              if not Assigned(InternalSender) then
                InternalSender := Self;

              {--- Trigger OnStart callback }
              if Assigned(InternalOnStart) then
                TThread.Queue(nil,
                  procedure
                  begin
                    InternalOnStart(InternalSender);
                  end);

              {--- Processing }
              var Result := Value();

              {--- Trigger OnEnd callback when the process is done }
              TThread.Queue(nil,
                  procedure
                  begin
                    try
                      if Assigned(InternalOnSuccess) then
                        InternalOnSuccess(InternalSender, Result);
                    finally
                      {--- Makes sure to release the instance containing the data obtained
                           following processing}
                      if Assigned(Result) then
                        Result.Free;
                    end;
                  end);

            except
              on E: Exception do
                begin
                  var Error := AcquireExceptionObject;
                  try
                    var ErrorMsg := (Error as Exception).Message;

                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(InternalOnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        InternalOnError(InternalSender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
          end);
  Task.Start;
end;

end.

unit GenAI.Audio;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Threading, REST.Json.Types, System.Net.Mime,
  GenAI.API.Params, GenAI.API, GenAI.Types, GenAI.Async.Support;

type
  /// <summary>
  /// Represents the parameters required to generate speech from text using the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class encapsulates the settings that can be configured for the speech synthesis request,
  /// including the model to use, the text input, the voice type, the response format, and the speed of speech.
  /// </remarks>
  TSpeechParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the model to be used for speech generation.
    /// </summary>
    /// <param name="Value">The model identifier, such as 'tts-1' or 'tts-1-hd'.</param>
    /// <returns>Returns an instance of <see cref="TSpeechParams"/> configured with the specified model.</returns>
    function Model(const Value: string): TSpeechParams;
    /// <summary>
    /// Sets the text to be converted into speech.
    /// </summary>
    /// <param name="Value">The text string, maximum length of 4096 characters.</param>
    /// <returns>Returns an instance of <see cref="TSpeechParams"/> configured with the specified input text.</returns>
    function Input(const Value: string): TSpeechParams;
    /// <summary>
    /// Sets the voice to be used for speech synthesis.
    /// </summary>
    /// <param name="Value">The name of the voice to use, e.g., 'alloy', 'ash', etc.</param>
    /// <returns>Returns an instance of <see cref="TSpeechParams"/> configured with the specified voice.</returns>
    function Voice(const Value: TAudioVoice): TSpeechParams; overload;
    /// <summary>
    /// Sets the voice to be used for speech synthesis.
    /// </summary>
    /// <param name="Value">A value of <see cref="TAudioVoice"/> representing the voice to use.</param>
    /// <returns>Returns an instance of <see cref="TSpeechParams"/> configured with the specified voice.</returns>
    function Voice(const Value: string): TSpeechParams; overload;
    /// <summary>
    /// Sets the response format of the audio output.
    /// </summary>
    /// <param name="Value">The desired audio format, such as 'mp3', 'wav', etc.</param>
    /// <returns>Returns an instance of <see cref="TSpeechParams"/> configured with the specified response format.</returns>
    function ResponseFormat(const Value: TSpeechFormat): TSpeechParams; overload;
    /// <summary>
    /// Sets the response format of the audio output.
    /// </summary>
    /// <param name="Value">A value of <see cref="TSpeechFormat"/> specifying the desired audio format.</param>
    /// <returns>Returns an instance of <see cref="TSpeechParams"/> configured with the specified response format.</returns>
    function ResponseFormat(const Value: string): TSpeechParams; overload;
    /// <summary>
    /// Sets the speed of the generated speech.
    /// </summary>
    /// <param name="Value">The speed multiplier for the speech, ranging from 0.25 to 4.0.</param>
    /// <returns>Returns an instance of <see cref="TSpeechParams"/> configured with the specified speed.</returns>
    function Speed(const Value: Double): TSpeechParams;
  end;

  /// <summary>
  /// Represents the result of a speech synthesis request.
  /// </summary>
  /// <remarks>
  /// This class handles the response from the OpenAI API after a speech generation request,
  /// providing methods to access the generated audio content either as a stream or by saving it to a file.
  /// </remarks>
  TSpeechResult = class(TJSONFingerprint)
  private
    FFileName: string;
    FData: string;
  public
    /// <summary>
    /// Retrieves the generated audio content as a stream.
    /// </summary>
    /// <returns>A <see cref="TStream"/> that contains the generated audio data.</returns>
    /// <exception cref="Exception">Raises an exception if the data conversion fails.</exception>
    function GetStream: TStream;
    /// <summary>
    /// Saves the generated image to the specified file path.
    /// </summary>
    /// <param name="FileName">
    /// A string specifying the file path where the image will be saved.
    /// </param>
    /// <param name="RaiseError">
    /// A boolean value indicating whether to raise an exception if the <c>FileName</c> is empty.
    /// <para>
    /// - If set to <c>True</c>, an exception will be raised for an empty file path.
    /// </para>
    /// <para>
    /// - If set to <c>False</c>, the method will exit silently without saving.
    /// </para>
    /// </param>
    /// <remarks>
    /// This method saves the base64-encoded image content to the specified file. Ensure that
    /// the <c>FileName</c> parameter is valid if <c>RaiseError</c> is set to <c>True</c>.
    /// If the <c>FileName</c> is empty and <c>RaiseError</c> is <c>False</c>, the method
    /// will terminate without performing any operation.
    /// </remarks>
    procedure SaveToFile(const FileName: string; const RaiseError: Boolean = True);
    /// <summary>
    /// Contains the base64-encoded string of the audio data.
    /// </summary>
    /// <remarks>
    /// Direct access to the raw audio data in base64 format, allowing further manipulation or processing if required.
    /// </remarks>
    property Data: string read FData write FData;
    /// <summary>
    /// The name of the file where the audio is saved if the SaveToFile method is used.
    /// </summary>
    /// <remarks>
    /// This property can be used to retrieve or set the filename used in the SaveToFile operation.
    /// </remarks>
    property FileName: string read FFileName write FFileName;
  end;

  /// <summary>
  /// Represents the parameters required for transcribing audio into text using the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class encapsulates the settings that can be configured for the audio transcription request,
  /// such as the audio file, model to use, language of the audio, optional prompt, response format, and transcription temperature.
  /// </remarks>
  TTranscriptionParams = class(TMultipartFormData)
  public
    constructor Create; reintroduce;
    /// <summary>
    /// Adds an audio file from the specified file path to the transcription request.
    /// </summary>
    /// <param name="FileName">The path to the audio file to be transcribed.</param>
    /// <returns>Returns an instance of <see cref="TTranscriptionParams"/> with the specified file included.</returns>
    function &File(const FileName: string): TTranscriptionParams; overload;
    /// <summary>
    /// Adds an audio file from a stream to the transcription request.
    /// </summary>
    /// <param name="Stream">The stream containing the audio file data.</param>
    /// <param name="FileName">The name of the file represented by the stream.</param>
    /// <returns>Returns an instance of <see cref="TTranscriptionParams"/> with the specified file stream included.</returns>
    function &File(const Stream: TStream; const FileName: string): TTranscriptionParams; overload;
    /// <summary>
    /// Sets the model to be used for transcription.
    /// </summary>
    /// <param name="Value">The model identifier, such as 'whisper-1'.</param>
    /// <returns>Returns an instance of <see cref="TTranscriptionParams"/> configured with the specified model.</returns>
    function Model(const Value: string): TTranscriptionParams;
    /// <summary>
    /// Optionally sets the language of the input audio.
    /// </summary>
    /// <param name="Value">The ISO-639-1 language code, such as 'en' for English.</param>
    /// <returns>Returns an instance of <see cref="TTranscriptionParams"/> configured with the specified language.</returns>
    function Language(const Value: string): TTranscriptionParams;
    /// <summary>
    /// Optionally sets a guiding prompt for the transcription.
    /// </summary>
    /// <param name="Value">The text to guide the model's style or to continue a previous audio segment.</param>
    /// <returns>Returns an instance of <see cref="TTranscriptionParams"/> configured with the specified prompt.</returns>
    function Prompt(const Value: string): TTranscriptionParams;
    /// <summary>
    /// Sets the format of the transcription output.
    /// </summary>
    /// <param name="Value">The desired output format, such as 'json', 'text', or 'srt'.</param>
    /// <returns>Returns an instance of <see cref="TTranscriptionParams"/> configured with the specified response format.</returns>
    function ResponseFormat(const Value: TTranscriptionResponseFormat): TTranscriptionParams; overload;
    /// <summary>
    /// Sets the format of the transcription output.
    /// </summary>
    /// <param name="Value">A value of <see cref="TTranscriptionResponseFormat"/> specifying the desired output format.</param>
    /// <returns>Returns an instance of <see cref="TTranscriptionParams"/> configured with the specified response format.</returns>
    function ResponseFormat(const Value: string): TTranscriptionParams; overload;
    /// <summary>
    /// Optionally sets the transcription temperature to control the randomness of the output.
    /// </summary>
    /// <param name="Value">A value between 0 and 1, where higher values result in more randomness.</param>
    /// <returns>Returns an instance of <see cref="TTranscriptionParams"/> configured with the specified temperature.</returns>
    function Temperature(const Value: Double): TTranscriptionParams;
  end;

  /// <summary>
  /// Represents a single word from the transcription result with its corresponding timestamps.
  /// </summary>
  /// <remarks>
  /// This class provides detailed information about the timing of each word in the transcribed text,
  /// including the start and end times, which are useful for applications requiring precise synchronization
  /// between the audio and its transcription.
  /// </remarks>
  TTranscriptionWord = class
  private
    FWord: string;
    FStart: Double;
    FEnd: Double;
  public
    /// <summary>
    /// The transcribed word.
    /// </summary>
    /// <remarks>
    /// This property holds the text of the word as it was recognized in the audio.
    /// </remarks>
    property Word: string read FWord write FWord;
    /// <summary>
    /// The start time of the word in the audio stream, measured in seconds.
    /// </summary>
    /// <remarks>
    /// This property indicates when the word starts in the audio.
    /// </remarks>
    property Start: Double read FStart write FStart;
    /// <summary>
    /// The end time of the word in the audio stream, measured in seconds.
    /// </summary>
    /// <remarks>
    /// This property indicates when the word ends in the audio.
    /// </remarks>
    property &End: Double read FEnd write FEnd;
  end;

  /// <summary>
  /// Represents a segment of the transcription, providing details such as segment text and its corresponding timing.
  /// </summary>
  /// <remarks>
  /// This class details each segment of the transcribed audio, offering a deeper level of granularity for applications
  /// that need to break down the transcription into smaller pieces for analysis or display.
  /// </remarks>
  TTranscriptionSegment = class
  private
    FId: Int64;
    FSeek: Int64;
    FStart: Double;
    FEnd: Double;
    FText: string;
    FTokens: TArray<Int64>;
    FTemperature: Double;
    [JsonNameAttribute('avg_logprob')]
    FAvgLogprob: Double;
    [JsonNameAttribute('compression_ratio')]
    FCompressionRatio: Double;
    [JsonNameAttribute('no_speech_prob')]
    FNoSpeechProb: Double;
  public
    /// <summary>
    /// Unique identifier for the segment.
    /// </summary>
    property Id: Int64 read FId write FId;
    /// <summary>
    /// Seek position in the original audio data.
    /// </summary>
    /// <remarks>
    /// This property could be used to directly access the specific part of the audio corresponding to this segment.
    /// </remarks>
    property Seek: Int64 read FSeek write FSeek;
    /// <summary>
    /// The start time of the segment in the audio stream, measured in seconds.
    /// </summary>
    property Start: Double read FStart write FStart;
    /// <summary>
    /// The end time of the segment in the audio stream, measured in seconds.
    /// </summary>
    property &End: Double read FEnd write FEnd;
    /// <summary>
    /// The text of the transcribed segment.
    /// </summary>
    property Text: string read FText write FText;
    /// <summary>
    /// An array of token identifiers associated with the segment.
    /// </summary>
    property Tokens: TArray<Int64> read FTokens write FTokens;
    /// <summary>
    /// The transcription model's confidence measure for this segment.
    /// </summary>
    property Temperature: Double read FTemperature write FTemperature;
    /// <summary>
    /// The average log probability of the segment, indicating model confidence.
    /// </summary>
    property AvgLogprob: Double read FAvgLogprob write FAvgLogprob;
    /// <summary>
    /// The ratio indicating how much the segment has been compressed from the original audio.
    /// </summary>
    property CompressionRatio: Double read FCompressionRatio write FCompressionRatio;
    /// <summary>
    /// Probability that the segment does not contain speech.
    /// </summary>
    property NoSpeechProb: Double read FNoSpeechProb write FNoSpeechProb;
  end;

  /// <summary>
  /// Represents the full transcription result returned by the OpenAI audio transcription API.
  /// </summary>
  /// <remarks>
  /// This class encapsulates the complete transcription of an audio file, including the language,
  /// duration, and detailed segments and words with their corresponding timestamps.
  /// It serves as a comprehensive container for all the transcription details necessary for further processing
  /// or analysis in applications.
  /// </remarks>
  TTranscription = class(TJSONFingerprint)
  private
    FLanguage: string;
    FDuration: string;
    FText: string;
    FWords: TArray<TTranscriptionWord>;
    FSegments: TArray<TTranscriptionSegment>;
  public
    /// <summary>
    /// The language of the audio that was transcribed.
    /// </summary>
    /// <remarks>
    /// This property indicates the ISO-639-1 language code of the transcribed audio,
    /// such as 'en' for English.
    /// </remarks>
    property Language: string read FLanguage write FLanguage;
    /// <summary>
    /// The duration of the audio that was transcribed, typically expressed in seconds or a time format.
    /// </summary>
    /// <remarks>
    /// This property provides the length of the audio clip that was processed,
    /// which is useful for synchronizing the transcription with the audio playback.
    /// </remarks>
    property Duration: string read FDuration write FDuration;
    /// <summary>
    /// The complete transcribed text of the audio file.
    /// </summary>
    /// <remarks>
    /// This property contains the entire textual output generated from the audio transcription,
    /// providing a comprehensive view of the spoken content.
    /// </remarks>
    property Text: string read FText write FText;
    /// <summary>
    /// A collection of words extracted from the transcription, each associated with specific timestamps.
    /// </summary>
    /// <remarks>
    /// This array of <see cref="TTranscriptionWord"/> objects offers detailed timing for each word in the transcription,
    /// allowing for fine-grained analysis and synchronization with the audio.
    /// </remarks>
    property Words: TArray<TTranscriptionWord> read FWords write FWords;
    /// <summary>
    /// A collection of segments from the transcription, each providing detailed information about a portion of the text.
    /// </summary>
    /// <remarks>
    /// This array of <see cref="TTranscriptionSegment"/> objects details various segments of the transcription,
    /// including their timing, text, and model confidence metrics. It is particularly useful for segmenting the transcription
    /// into logical units for easier processing and analysis.
    /// </remarks>
    property Segments: TArray<TTranscriptionSegment> read FSegments write FSegments;
    /// <summary>
    /// Destructor for TTranscription, ensures proper cleanup of resources.
    /// </summary>
    /// <remarks>
    /// This destructor is overridden to ensure that any resources, particularly the dynamically allocated
    /// word and segment objects, are properly freed when an instance of TTranscription is destroyed.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents the parameters required for translating audio into English using the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class encapsulates settings for audio translation requests, including the audio file,
  /// the translation model, optional guiding prompt, response format, and translation temperature.
  /// </remarks>
  TTranslationParams = class(TMultipartFormData)
  public
    constructor Create; reintroduce;
    /// <summary>
    /// Adds an audio file from the specified file path to the translation request.
    /// </summary>
    /// <param name="FileName">The path to the audio file to be translated.</param>
    /// <returns>Returns an instance of <see cref="TTranslationParams"/> with the specified file included.</returns>
    function &File(const FileName: string): TTranslationParams; overload;
    /// <summary>
    /// Adds an audio file from a stream to the translation request.
    /// </summary>
    /// <param name="Stream">The stream containing the audio file data.</param>
    /// <param name="FileName">The name of the file represented by the stream.</param>
    /// <returns>Returns an instance of <see cref="TTranslationParams"/> with the specified file stream included.</returns>
    function &File(const Stream: TStream; const FileName: string): TTranslationParams; overload;
    /// <summary>
    /// Sets the model to be used for translation.
    /// </summary>
    /// <param name="Value">The model identifier, such as 'whisper-1'.</param>
    /// <returns>Returns an instance of <see cref="TTranslationParams"/> configured with the specified model.</returns>
    function Model(const Value: string): TTranslationParams;
    /// <summary>
    /// Optionally sets a guiding prompt for the translation.
    /// </summary>
    /// <param name="Value">The text to guide the model's style or to continue a previous audio segment in English.</param>
    /// <returns>Returns an instance of <see cref="TTranslationParams"/> configured with the specified prompt.</returns>
    function Prompt(const Value: string): TTranslationParams;
    /// <summary>
    /// Sets the format of the translation output.
    /// </summary>
    /// <param name="Value">The desired output format, such as 'json', 'text', or 'srt'.</param>
    /// <returns>Returns an instance of <see cref="TTranslationParams"/> configured with the specified response format.</returns>
    function ResponseFormat(const Value: TTranscriptionResponseFormat): TTranslationParams;
    /// <summary>
    /// Optionally sets the translation temperature to control the randomness of the output.
    /// </summary>
    /// <param name="Value">A value between 0 and 1, where higher values result in more randomness.</param>
    /// <returns>Returns an instance of <see cref="TTranslationParams"/> configured with the specified temperature.</returns>
    function Temperature(const Value: Double): TTranslationParams;
  end;

  /// <summary>
  /// Represents the translation result returned by the OpenAI audio translation API.
  /// </summary>
  /// <remarks>
  /// This class encapsulates the result of translating audio into English, containing the translated text.
  /// It is used to provide a straightforward interface to access the textual translation of spoken content.
  /// </remarks>
  TTranslation = class(TJSONFingerprint)
  private
    FText: string;
  public
    /// <summary>
    /// The translated text from the audio file.
    /// </summary>
    /// <remarks>
    /// This property contains the textual output generated from the audio translation,
    /// providing the English translation of the spoken content.
    /// </remarks>
    property Text: string read FText write FText;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TSpeechResult</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynSpeechResult</c> type extends the <c>TAsynParams&lt;TSpeechResult&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynSpeechResult = TAsynCallBack<TSpeechResult>;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TTranscription</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynTranscription</c> type extends the <c>TAsynParams&lt;TTranscription&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynTranscription = TAsynCallBack<TTranscription>;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TTranslation</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynTranslation</c> type extends the <c>TAsynParams&lt;TTranslation&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynTranslation = TAsynCallBack<TTranslation>;

  /// <summary>
  /// Provides routes to handle audio-related requests including speech generation, transcription, and translation.
  /// </summary>
  /// <remarks>
  /// This class offers a set of methods to interact with OpenAI's API for generating speech from text,
  /// transcribing audio into text, and translating audio into English. It supports both synchronous and asynchronous
  /// operations to accommodate different application needs.
  /// </remarks>
  TAudioRoute = class(TGenAIRoute)
    /// <summary>
    /// Asynchronously generates speech from text using the specified parameters.
    /// </summary>
    /// <param name="ParamProc">A procedure that accepts a TSpeechParams instance to set the parameters for the speech request.</param>
    /// <param name="CallBacks">A function that returns a callback mechanism for handling the result.</param>
    /// <remarks>
    /// This method provides asynchronous handling of speech synthesis, allowing the application to remain responsive
    /// while processing large or multiple speech synthesis requests.
    /// </remarks>
    procedure AsynSpeech(const ParamProc: TProc<TSpeechParams>; const CallBacks: TFunc<TAsynSpeechResult>);
    /// <summary>
    /// Asynchronously transcribes audio into text using the specified parameters.
    /// </summary>
    /// <param name="ParamProc">A procedure that accepts a TTranscriptionParams instance to set the parameters for the transcription request.</param>
    /// <param name="CallBacks">A function that returns a callback mechanism for handling the transcription result.</param>
    /// <remarks>
    /// This method provides asynchronous handling of audio transcription, which is useful for applications that need
    /// to process audio files or streams without blocking the main application thread.
    /// </remarks>
    procedure AsynTranscription(const ParamProc: TProc<TTranscriptionParams>; const CallBacks: TFunc<TAsynTranscription>);
    /// <summary>
    /// Asynchronously translates audio into English using the specified parameters.
    /// </summary>
    /// <param name="ParamProc">A procedure that accepts a TTranslationParams instance to set the parameters for the translation request.</param>
    /// <param name="CallBacks">A function that returns a callback mechanism for handling the translation result.</param>
    /// <remarks>
    /// This method provides asynchronous handling of audio translation, facilitating the processing of non-English audio
    /// into English text without interrupting the user interface.
    /// </remarks>
    procedure AsynTranslatingIntoEnglish(const ParamProc: TProc<TTranslationParams>; const CallBacks: TFunc<TAsynTranslation>);
    /// <summary>
    /// Synchronously generates speech from text using the specified parameters.
    /// </summary>
    /// <param name="ParamProc">A procedure that accepts a TSpeechParams instance to set the parameters for the speech request.</param>
    /// <returns>Returns an instance of TSpeechResult containing the generated speech.</returns>
    /// <remarks>
    /// This method allows for synchronous speech synthesis, suitable for situations where immediate response from the API is required.
    /// </remarks>
    function Speech(const ParamProc: TProc<TSpeechParams>): TSpeechResult;
    /// <summary>
    /// Synchronously transcribes audio into text using the specified parameters.
    /// </summary>
    /// <param name="ParamProc">A procedure that accepts a TTranscriptionParams instance to set the parameters for the transcription request.</param>
    /// <returns>Returns an instance of TTranscription containing the transcription details.</returns>
    /// <remarks>
    /// This method allows for synchronous audio transcription, appropriate for applications requiring immediate text output from audio.
    /// </remarks>
    function Transcription(const ParamProc: TProc<TTranscriptionParams>): TTranscription;
    /// <summary>
    /// Synchronously translates audio into English using the specified parameters.
    /// </summary>
    /// <param name="ParamProc">A procedure that accepts a TTranslationParams instance to set the parameters for the translation request.</param>
    /// <returns>Returns an instance of TTranslation containing the translated text.</returns>
    /// <remarks>
    /// This method allows for synchronous audio translation, ideal for scenarios where an immediate textual translation is needed.
    /// </remarks>
    function TranslatingIntoEnglish(const ParamProc: TProc<TTranslationParams>): TTranslation;
  end;

implementation

uses
  GenAI.NetEncoding.Base64;

{ TSpeechParams }

function TSpeechParams.Input(const Value: string): TSpeechParams;
begin
  Result := TSpeechParams(Add('input', Value));
end;

function TSpeechParams.Model(const Value: string): TSpeechParams;
begin
  Result := TSpeechParams(Add('model', Value));
end;

function TSpeechParams.ResponseFormat(const Value: string): TSpeechParams;
begin
  Result := TSpeechParams(Add('response_format', TSpeechFormat.Create(Value).ToString));
end;

function TSpeechParams.ResponseFormat(
  const Value: TSpeechFormat): TSpeechParams;
begin
  Result := TSpeechParams(Add('response_format', Value.ToString));
end;

function TSpeechParams.Speed(const Value: Double): TSpeechParams;
begin
  Result := TSpeechParams(Add('speed', Value));
end;

function TSpeechParams.Voice(const Value: string): TSpeechParams;
begin
  Result := TSpeechParams(Add('voice', TAudioVoice.Create(Value).ToString));
end;

function TSpeechParams.Voice(const Value: TAudioVoice): TSpeechParams;
begin
  Result := TSpeechParams(Add('voice', Value.ToString));
end;

{ TAudioRoute }

procedure TAudioRoute.AsynSpeech(const ParamProc: TProc<TSpeechParams>;
  const CallBacks: TFunc<TAsynSpeechResult>);
begin
  with TAsynCallBackExec<TAsynSpeechResult, TSpeechResult>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TSpeechResult
      begin
        Result := Self.Speech(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TAudioRoute.AsynTranscription(const ParamProc: TProc<TTranscriptionParams>;
  const CallBacks: TFunc<TAsynTranscription>);
begin
  with TAsynCallBackExec<TAsynTranscription, TTranscription>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TTranscription
      begin
        Result := Self.Transcription(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TAudioRoute.AsynTranslatingIntoEnglish(
  const ParamProc: TProc<TTranslationParams>;
  const CallBacks: TFunc<TAsynTranslation>);
begin
  with TAsynCallBackExec<TAsynTranslation, TTranslation>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TTranslation
      begin
        Result := Self.TranslatingIntoEnglish(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TAudioRoute.Speech(
  const ParamProc: TProc<TSpeechParams>): TSpeechResult;
begin
  Result := API.Post<TSpeechResult, TSpeechParams>('audio/speech', ParamProc, 'Data');
end;

function TAudioRoute.Transcription(
  const ParamProc: TProc<TTranscriptionParams>): TTranscription;
begin
  Result := API.PostForm<TTranscription, TTranscriptionParams>('audio/transcriptions', ParamProc);
end;

function TAudioRoute.TranslatingIntoEnglish(
  const ParamProc: TProc<TTranslationParams>): TTranslation;
begin
  Result := API.PostForm<TTranslation, TTranslationParams>('audio/translations', ParamProc);
end;

{ TSpeechResult }

function TSpeechResult.GetStream: TStream;
begin
  {--- Create a memory stream to write the decoded content. }
  Result := TMemoryStream.Create;
  try
    {--- Convert the base-64 string directly into the memory stream. }
    DecodeBase64ToStream(Data, Result)
  except
    Result.Free;
    raise;
  end;
end;

procedure TSpeechResult.SaveToFile(const FileName: string; const RaiseError: Boolean);
begin
  case RaiseError of
    True :
      if FileName.Trim.IsEmpty then
        raise Exception.Create('File record aborted. SaveToFile requires a filename.');
    else
      if FileName.Trim.IsEmpty then
        Exit;
  end;

  try
    Self.FFileName := FileName;
    {--- Perform the decoding operation and save it into the file specified by the FileName parameter. }
    DecodeBase64ToFile(Data, FileName)
  except
    raise;
  end;
end;

{ TTranscriptionParams }

function TTranscriptionParams.&File(
  const FileName: string): TTranscriptionParams;
begin
  AddFile('file', FileName);
  Result := Self;
end;

function TTranscriptionParams.Model(const Value: string): TTranscriptionParams;
begin
  AddField('model', Value);
  Result := Self;
end;

function TTranscriptionParams.Prompt(const Value: string): TTranscriptionParams;
begin
  AddField('prompt', Value);
  Result := Self;
end;

function TTranscriptionParams.ResponseFormat(
  const Value: string): TTranscriptionParams;
begin
  AddField('response_format', TTranscriptionResponseFormat.Create(Value).ToString);
  Result := Self;
end;

function TTranscriptionParams.ResponseFormat(
  const Value: TTranscriptionResponseFormat): TTranscriptionParams;
begin
  AddField('response_format', Value.ToString);
  Result := Self;
end;

function TTranscriptionParams.Temperature(
  const Value: Double): TTranscriptionParams;
begin
  AddField('temperature', Value.ToString);
  Result := Self;
end;

constructor TTranscriptionParams.Create;
begin
  inherited Create(True);
end;

function TTranscriptionParams.&File(const Stream: TStream;
  const FileName: string): TTranscriptionParams;
begin
  {$IF RTLVersion > 35.0}
    AddStream('file', Stream, True, FileName);
  {$ELSE}
    AddStream('file', Stream, FileName);
  {$ENDIF}
  Result := Self;
end;

function TTranscriptionParams.Language(
  const Value: string): TTranscriptionParams;
begin
  AddField('language', Value);
  Result := Self;
end;

{ TTranscription }

destructor TTranscription.Destroy;
begin
  for var Item in FWords do
    Item.Free;
  for var Item in FSegments do
    Item.Free;
  inherited;
end;

{ TTranslationParams }

function TTranslationParams.&File(const FileName: string): TTranslationParams;
begin
  AddFile('file', FileName);
  Result := Self;
end;

constructor TTranslationParams.Create;
begin
  inherited Create(True);
end;

function TTranslationParams.&File(const Stream: TStream;
  const FileName: string): TTranslationParams;
begin
  {$IF RTLVersion > 35.0}
    AddStream('file', Stream, True, FileName);
  {$ELSE}
    AddStream('file', Stream, FileName);
  {$ENDIF}
  Result := Self;
end;

function TTranslationParams.Model(const Value: string): TTranslationParams;
begin
  AddField('model', Value);
  Result := Self;
end;

function TTranslationParams.Prompt(const Value: string): TTranslationParams;
begin
  AddField('prompt', Value);
  Result := Self;
end;

function TTranslationParams.ResponseFormat(
  const Value: TTranscriptionResponseFormat): TTranslationParams;
begin
  AddField('response_format', Value.ToString);
  Result := Self;
end;

function TTranslationParams.Temperature(
  const Value: Double): TTranslationParams;
begin
  AddField('temperature', Value.ToString);
  Result := Self;
end;

end.

unit GenAI.Batch.Builder;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

--------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.IOUtils, GenAI.Types, GenAI.Batch.Interfaces;

type
  /// <summary>
  ///  The <c>TBatchJSONBuilder</c> class provides mechanisms to generate JSON-formatted
  ///  batch requests from either a single value, an array of values, or the contents
  ///  of a file. It also allows saving these batch requests to a specified file.
  /// </summary>
  /// <remarks>
  ///  <para>
  ///   This class implements <see cref="IBatchJSONBuilder"/> to offer various methods
  ///   for creating and writing JSON batch content. It is designed to streamline
  ///   batch request creation, especially in scenarios involving multiple requests
  ///   to the same endpoint.
  ///  </para>
  ///  <para>
  ///   Typical usage involves calling one of the <c>GenerateBatchString</c> methods
  ///   to produce a JSON string or one of the <c>WriteBatchToFile</c> methods to
  ///   save the resulting JSON directly to a file.
  ///  </para>
  /// </remarks>
  TBatchJSONBuilder = class(TInterfacedObject, IBatchJSONBuilder)
  private
    /// <summary>
    ///  Formats a single line of batch content, converting the specified parameters
    ///  into a JSON object with the fields <c>custom_id</c>, <c>method</c>,
    ///  <c>url</c>, and <c>body</c>.
    /// </summary>
    /// <param name="Index">
    ///  A sequential number indicating the request order.
    /// </param>
    /// <param name="AMethod">
    ///  The HTTP method to be used for the request (e.g., POST or GET).
    /// </param>
    /// <param name="AUrl">
    ///  The target endpoint URL for the request.
    /// </param>
    /// <param name="ABody">
    ///  The JSON content or payload for the request body.
    /// </param>
    /// <returns>
    ///  A string containing a single JSON object for a batch request.
    /// </returns>
    function FormatBatchLine(Index: Integer; const AMethod, AUrl, ABody: string): string;
    /// <summary>
    ///  Builds the complete JSON batch content by splitting a single multi-line string
    ///  into individual lines and converting each line into a batch request.
    /// </summary>
    /// <param name="AMethod">
    ///  The HTTP method to be used in the batch requests (e.g., POST).
    /// </param>
    /// <param name="AUrl">
    ///  The target endpoint URL for the requests.
    /// </param>
    /// <param name="Value">
    ///  A multi-line string where each line is treated as a separate request body.
    /// </param>
    /// <returns>
    ///  A JSON-formatted string containing one request entry per line.
    /// </returns>
    function BuildBatchContent(const AMethod, AUrl, Value: string): string; overload;
    /// <summary>
    ///  Builds the complete JSON batch content by iterating over an array of string values
    ///  and converting each element into a batch request.
    /// </summary>
    /// <param name="AMethod">
    ///  The HTTP method to be used in the batch requests (e.g., POST).
    /// </param>
    /// <param name="AUrl">
    ///  The target endpoint URL for the requests.
    /// </param>
    /// <param name="Value">
    ///  An array of strings, each of which will be treated as a separate request body.
    /// </param>
    /// <returns>
    ///  A JSON-formatted string containing one request entry per string in the array.
    /// </returns>
    function BuildBatchContent(const AMethod, AUrl: string; const Value: TArray<string>): string; overload;
    /// <summary>
    ///  Loads and returns the raw content of a text file in UTF-8 format.
    /// </summary>
    /// <param name="FileName">
    ///  The file path of the text file to be read.
    /// </param>
    /// <returns>
    ///  The UTF-8 content of the file as a string.
    /// </returns>
    /// <exception cref="Exception">
    ///  Raised if the specified file does not exist.
    /// </exception>
    function LoadRawContent(const FileName: string): string;
    /// <summary>
    ///  Saves a given string to a file in UTF-8 format, without including a BOM.
    /// </summary>
    /// <param name="Content">
    ///  The string data to be saved.
    /// </param>
    /// <param name="Destination">
    ///  The file path where the data will be written.
    /// </param>
    /// <returns>
    ///  The same file path specified by <c>Destination</c>.
    /// </returns>
    function SaveToFile(const Content, Destination: string): string;
  public
    /// <summary>
    ///  Generates a JSON batch string by taking a single string value and converting
    ///  it into a batch request to the specified <see cref="TBatchUrl"/>.
    /// </summary>
    /// <param name="Value">
    ///  The string content to be converted into a JSON request body.
    /// </param>
    /// <param name="Url">
    ///  The <see cref="TBatchUrl"/> object representing the destination URL where
    ///  the batch request will be sent.
    /// </param>
    /// <returns>
    ///  A JSON string that includes the request method ("POST"), the provided URL, and the content.
    /// </returns>
    function GenerateBatchString(const Value: string; const Url: TBatchUrl): string; overload;
    /// <summary>
    ///  Generates a JSON batch string by taking a single string value and converting
    ///  it into a batch request to the specified URL string.
    /// </summary>
    /// <param name="Value">
    ///  The string content to be converted into a JSON request body.
    /// </param>
    /// <param name="Url">
    ///  The string containing the destination URL where the batch request will be sent.
    /// </param>
    /// <returns>
    ///  A JSON string that includes the request method ("POST"), the provided URL, and the content.
    /// </returns>
    function GenerateBatchString(const Value: string; const Url: string): string; overload;
    /// <summary>
    ///  Generates a JSON batch string by taking an array of string values and converting
    ///  them into individual batch requests to the specified <see cref="TBatchUrl"/>.
    /// </summary>
    /// <param name="Value">
    ///  An array of string values, each to be included as a separate item in the JSON batch.
    /// </param>
    /// <param name="Url">
    ///  The <see cref="TBatchUrl"/> object representing the destination URL where
    ///  the batch requests will be sent.
    /// </param>
    /// <returns>
    ///  A JSON string containing multiple request objects, each mapped to a single item in the array.
    /// </returns>
    function GenerateBatchString(const Value: TArray<string>; const Url: TBatchUrl): string; overload;
    /// <summary>
    ///  Generates a JSON batch string by taking an array of string values and converting
    ///  them into individual batch requests to the specified URL string.
    /// </summary>
    /// <param name="Value">
    ///  An array of string values, each to be included as a separate item in the JSON batch.
    /// </param>
    /// <param name="Url">
    ///  The string containing the destination URL where the batch requests will be sent.
    /// </param>
    /// <returns>
    ///  A JSON string containing multiple request objects, each mapped to a single item in the array.
    /// </returns>
    function GenerateBatchString(const Value: TArray<string>; const Url: string): string; overload;
    /// <summary>
    ///  Reads the content from a specified source file, generates a JSON batch string,
    ///  and writes the output to a destination file. Each line in the source file
    ///  is treated as a separate request body.
    /// </summary>
    /// <param name="Source">
    ///  The file path of the source file that contains the input content.
    /// </param>
    /// <param name="Destination">
    ///  The file path where the generated JSON batch string will be saved.
    /// </param>
    /// <param name="Url">
    ///  The <see cref="TBatchUrl"/> object representing the destination URL where
    ///  the batch requests will be sent.
    /// </param>
    /// <returns>
    ///  The file path of the newly created batch file (identical to the <c>Destination</c>).
    /// </returns>
    function WriteBatchToFile(const Source, Destination: string; const Url: TBatchUrl): string; overload;
    /// <summary>
    ///  Reads the content from a specified source file, generates a JSON batch string,
    ///  and writes the output to a destination file. Each line in the source file
    ///  is treated as a separate request body.
    /// </summary>
    /// <param name="Source">
    ///  The file path of the source file that contains the input content.
    /// </param>
    /// <param name="Destination">
    ///  The file path where the generated JSON batch string will be saved.
    /// </param>
    /// <param name="Url">
    ///  The string containing the destination URL where the batch requests will be sent.
    /// </param>
    /// <returns>
    ///  The file path of the newly created batch file (identical to the <c>Destination</c>).
    /// </returns>
    function WriteBatchToFile(const Source, Destination: string; const Url: string): string; overload;
    /// <summary>
    ///  Takes an array of string values, generates a JSON batch string by treating each
    ///  string as a separate request body, and saves the result to the specified
    ///  destination file.
    /// </summary>
    /// <param name="Value">
    ///  An array of string values, each to be included as a separate item in the JSON batch.
    /// </param>
    /// <param name="Destination">
    ///  The file path where the generated JSON batch string will be saved.
    /// </param>
    /// <param name="Url">
    ///  The <see cref="TBatchUrl"/> object representing the destination URL where
    ///  the batch requests will be sent.
    /// </param>
    /// <returns>
    ///  The file path of the newly created batch file (identical to the <c>Destination</c>).
    /// </returns>
    function WriteBatchToFile(const Value: TArray<string>; const Destination: string; const Url: TBatchUrl): string; overload;
    /// <summary>
    ///  Takes an array of string values, generates a JSON batch string by treating each
    ///  string as a separate request body, and saves the result to the specified
    ///  destination file.
    /// </summary>
    /// <param name="Value">
    ///  An array of string values, each to be included as a separate item in the JSON batch.
    /// </param>
    /// <param name="Destination">
    ///  The file path where the generated JSON batch string will be saved.
    /// </param>
    /// <param name="Url">
    ///  The string containing the destination URL where the batch requests will be sent.
    /// </param>
    /// <returns>
    ///  The file path of the newly created batch file (identical to the <c>Destination</c>).
    /// </returns>
    function WriteBatchToFile(const Value: TArray<string>; const Destination: string; const Url: string): string; overload;
  end;

implementation

{ TBatchJSONBuilder }

function TBatchJSONBuilder.BuildBatchContent(const AMethod, AUrl, Value: string): string;
var
  Line: string;
begin
  var StringReader := TStringReader.Create(Value);
  var BatchBuilder := TStringBuilder.Create;
  try
    var index := 1;
    Line := StringReader.ReadLine;
    while not Line.Trim.IsEmpty do
      begin
        BatchBuilder.AppendLine(FormatBatchLine(index, AMethod, AUrl, Line));
        Inc(index);
        Line := StringReader.ReadLine;
      end;
    Result := BatchBuilder.ToString;
  finally
    StringReader.Free;
    BatchBuilder.Free;
  end;
end;

function TBatchJSONBuilder.BuildBatchContent(const AMethod, AUrl: string;
  const Value: TArray<string>): string;
begin
  Result := EmptyStr;
  var index := 1;
  var BatchBuilder := TStringBuilder.Create;
  try
    for var Line in Value do
      begin
        BatchBuilder.AppendLine(FormatBatchLine(Index, AMethod, AUrl, Line));
        Inc(Index);
      end;
    Result := BatchBuilder.ToString;
  finally
    BatchBuilder.Free;
  end;
end;

function TBatchJSONBuilder.FormatBatchLine(Index: Integer; const AMethod, AUrl,
  ABody: string): string;
begin
  Result := Format('{"custom_id": "request-%d", "method": "%s", "url": "%s", "body": %s}', [Index, AMethod, AUrl, ABody]);
end;

function TBatchJSONBuilder.WriteBatchToFile(const Source, Destination: string; const Url: TBatchUrl): string;
begin
  Result := GenerateBatchString(LoadRawContent(Source), Url );
  SaveToFile(Result, Destination);
end;

function TBatchJSONBuilder.GenerateBatchString(const Value: string;
  const Url: TBatchUrl): string;
begin
  Result := BuildBatchContent('POST', Url.ToString, Value);
end;

function TBatchJSONBuilder.GenerateBatchString(const Value,
  Url: string): string;
begin
  Result := GenerateBatchString(Value, TBatchUrl.Create(Url));
end;

function TBatchJSONBuilder.LoadRawContent(const FileName: string): string;
begin
  if not TFile.Exists(FileName) then
    raise Exception.CreateFmt('%s: File not found', [FileName]);

  var FileStream := TFileStream.Create(FileName, fmOpenRead or fmShareDenyNone);
  try
    var StringStream := TStringStream.Create('', TEncoding.UTF8);
    try
      StringStream.LoadFromStream(FileStream);
      Result := StringStream.DataString;
    finally
      StringStream.Free;
    end;
  finally
    FileStream.Free;
  end;
end;

function TBatchJSONBuilder.SaveToFile(const Content,
  Destination: string): string;
begin
  {--- Generating a UTF-8 file without a BOM (Byte Order Mark) }
  var FileStream := TFileStream.Create(Destination, fmCreate);
  try
    var StringStream := TStringStream.Create(Content, TEncoding.UTF8);
    try
      StringStream.SaveToStream(FileStream);
    finally
      StringStream.Free;
    end;
  finally
    FileStream.Free;
  end;
  Result := Destination;
end;

function TBatchJSONBuilder.WriteBatchToFile(const Value: TArray<string>;
  const Destination, Url: string): string;
begin
  Result := WriteBatchToFile(Value, Destination, TBatchUrl.Create(Url));
end;

function TBatchJSONBuilder.WriteBatchToFile(const Value: TArray<string>;
  const Destination: string; const Url: TBatchUrl): string;
begin
  Result := GenerateBatchString(Value, Url);
  SaveToFile(Result, Destination);
end;

function TBatchJSONBuilder.WriteBatchToFile(const Source, Destination,
  Url: string): string;
begin
  Result := WriteBatchToFile(Source, Destination, TBatchUrl.Create(Url));
end;

function TBatchJSONBuilder.GenerateBatchString(const Value: TArray<string>;
  const Url: TBatchUrl): string;
begin
  Result := BuildBatchContent('POST', Url.ToString, Value);
end;

function TBatchJSONBuilder.GenerateBatchString(const Value: TArray<string>;
  const Url: string): string;
begin
  Result := GenerateBatchString(Value, TBatchUrl.Create(Url));
end;

end.

unit GenAI.Batch.Interfaces;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

--------------------------------------------------------------------------------}

(*
  --- NOTE ---
   This unit provides the  <c>IBatchJSONBuilder</c>  interface, designed to construct a batch
   body for submission to OpenAI's batch processing API. The interface methods enable you to:

    - Generate  a JSONL file  from a text file  containing JSON strings (one per line), where
      each line is used as the <c>Body</c> parameter in a batch request.
    - Build the JSONL from an array of JSON objects, assigning each object to the <c>Body</c>
      parameter of a request.


   Depending  on  the  specified  URL, <c>IBatchJSONBuilder</c>  produces  the JSONL lines as
   follows:

    - For /v1/chat/completions:
       {
        "custom_id": "request-n",
        "method": "POST",
        "url": "/v1/chat/completions",
        "body":
         {"model": "gpt-4o-mini",
          "messages": [
              {"role": "system",
               "content": "You are a helpful assistant."
              }
              {"role": "user", "content": "What is 2+2?"
              }
           ]}
       }

    - For /v1/embeddings:
        {
         "custom_id": "request-p",
         "method": "POST",
         "url": "/v1/embeddings",
         "body": {
           "input": "I hate computers....",
           "model": "text-embedding-3-large",
           "encoding_format": "float"
          }
         }
*)

interface

uses
  System.SysUtils, REST.Json.Types, REST.JsonReflect, GenAI.Types;

type
  /// <summary>
  /// Represents a generic response object for batch processing, capable of holding a status code,
  /// request ID, and a response body of a specified type.
  /// </summary>
  /// <typeparam name="T">
  /// The type of the response body object. Must be a class with a parameterless constructor.
  /// </typeparam>
  TBatchResponse<T: class, constructor> = class
  private
    [JsonNameAttribute('status_code')]
    FStatusCode: Int64;
    [JsonNameAttribute('request_id')]
    FRequestId: string;
    FBody: T;
  public
    /// <summary>
    /// Gets or sets the status code of the response.
    /// </summary>
    property StatusCode: Int64 read FStatusCode write FStatusCode;
    /// <summary>
    /// Gets or sets the unique identifier for the API request.
    /// </summary>
    property RequestId: string read FRequestId write FRequestId;
    /// <summary>
    /// Gets or sets the body of the response. The type of the body is specified by the generic type parameter <typeparamref name="T"/>.
    /// </summary>
    property Body: T read FBody write FBody;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents an error object for batch responses, providing detailed information
  /// about the error, including a machine-readable code and a human-readable message.
  /// </summary>
  TBatchResponseError = class
  private
    FCode: string;
    FMessage: string;
  public
    /// <summary>
    /// Gets or sets the machine-readable error code that identifies the type of error.
    /// </summary>
    property Code: string read FCode write FCode;
    /// <summary>
    /// Gets or sets the human-readable error message that describes the error in detail.
    /// </summary>
    property Message: string read FMessage write FMessage;
  end;

  /// <summary>
  /// Represents the output of a single batch request, including an identifier,
  /// an optional custom identifier, the response, and any associated errors.
  /// </summary>
  /// <typeparam name="T">
  /// The type of the response body object. Must be a class with a parameterless constructor.
  /// </typeparam>
  TBatchOutput<T: class, constructor> = class
  private
    FId: string;
    [JsonNameAttribute('custom_id')]
    FCustomId: string;
    FResponse: TBatchResponse<T>;
    FError: TBatchResponseError;
  public
    /// <summary>
    /// Gets or sets the unique identifier for the batch output.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Gets or sets a developer-provided custom identifier to match outputs to inputs.
    /// </summary>
    property CustomId: string read FCustomId write FCustomId;
    /// <summary>
    /// Gets or sets the response object of the batch request.
    /// This contains the status, request ID, and response body.
    /// </summary>
    property Response: TBatchResponse<T> read FResponse write FResponse;
    /// <summary>
    /// Gets or sets the error object containing details of any error that occurred during the batch request.
    /// </summary>
    property Error: TBatchResponseError read FError write FError;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents an interface for reading and deserializing JSONL (JSON Lines) input into
  /// a strongly typed array of batch output objects.
  /// </summary>
  /// <typeparam name="T">
  /// The type of the response body object to be deserialized. Must be a class with a parameterless constructor.
  /// </typeparam>
  IJSONLReader<T: class, constructor> = interface
    ['{A156F579-606F-4B01-B6CA-B11CA6770AC6}']
    /// <summary>
    /// Deserializes a JSONL-formatted string into an array of <typeparamref name="TBatchOutput{T}"/> objects.
    /// </summary>
    /// <param name="Value">
    /// The JSONL-formatted input string to be deserialized.
    /// </param>
    /// <returns>
    /// An array of deserialized <typeparamref name="TBatchOutput{T}"/> objects.
    /// </returns>
    function Deserialize(const Value: string): TArray<TBatchOutput<T>>;
  end;

  /// <summary>
  ///  The <c>IBatchJSONBuilder</c> interface defines the methods to create and manage
  ///  JSON batch requests. It can generate a batch string from single or multiple input
  ///  values, as well as write the generated batch data directly to a file.
  /// </summary>
  IBatchJSONBuilder = interface
    ['{35CDFC80-3BC4-4D3F-9908-6489493425B8}']
    /// <summary>
    ///  Generates a JSON batch string by taking a single string value and converting
    ///  it into a batch request to the specified <see cref="TBatchUrl"/>.
    /// </summary>
    /// <param name="Value">
    ///  The string content to be converted into a JSON request body.
    /// </param>
    /// <param name="Url">
    ///  The <see cref="TBatchUrl"/> object representing the destination URL where
    ///  the batch request will be sent.
    /// </param>
    /// <returns>
    ///  A JSON string that includes the request method ("POST"), the provided URL, and the content.
    /// </returns>
    function GenerateBatchString(const Value: string; const Url: TBatchUrl): string; overload;
    /// <summary>
    ///  Generates a JSON batch string by taking a single string value and converting
    ///  it into a batch request to the specified URL string.
    /// </summary>
    /// <param name="Value">
    ///  The string content to be converted into a JSON request body.
    /// </param>
    /// <param name="Url">
    ///  The string containing the destination URL where the batch request will be sent.
    /// </param>
    /// <returns>
    ///  A JSON string that includes the request method ("POST"), the provided URL, and the content.
    /// </returns>
    function GenerateBatchString(const Value: string; const Url: string): string; overload;
    /// <summary>
    ///  Generates a JSON batch string by taking an array of string values and converting
    ///  them into individual batch requests to the specified <see cref="TBatchUrl"/>.
    /// </summary>
    /// <param name="Value">
    ///  An array of string values, each to be included as a separate item in the JSON batch.
    /// </param>
    /// <param name="Url">
    ///  The <see cref="TBatchUrl"/> object representing the destination URL where
    ///  the batch requests will be sent.
    /// </param>
    /// <returns>
    ///  A JSON string containing multiple request objects, each mapped to a single item in the array.
    /// </returns>
    function GenerateBatchString(const Value: TArray<string>; const Url: TBatchUrl): string; overload;
    /// <summary>
    ///  Generates a JSON batch string by taking an array of string values and converting
    ///  them into individual batch requests to the specified URL string.
    /// </summary>
    /// <param name="Value">
    ///  An array of string values, each to be included as a separate item in the JSON batch.
    /// </param>
    /// <param name="Url">
    ///  The string containing the destination URL where the batch requests will be sent.
    /// </param>
    /// <returns>
    ///  A JSON string containing multiple request objects, each mapped to a single item in the array.
    /// </returns>
    function GenerateBatchString(const Value: TArray<string>; const Url: string): string; overload;
    /// <summary>
    ///  Reads the content from a specified source file, generates a JSON batch string,
    ///  and writes the output to a destination file. Each line in the source file
    ///  is treated as a separate request body.
    /// </summary>
    /// <param name="Source">
    ///  The file path of the source file that contains the input content.
    /// </param>
    /// <param name="Destination">
    ///  The file path where the generated JSON batch string will be saved.
    /// </param>
    /// <param name="Url">
    ///  The <see cref="TBatchUrl"/> object representing the destination URL where
    ///  the batch requests will be sent.
    /// </param>
    /// <returns>
    ///  The file path of the newly created batch file (identical to the <c>Destination</c>).
    /// </returns>
    function WriteBatchToFile(const Source, Destination: string; const Url: TBatchUrl): string; overload;
    /// <summary>
    ///  Reads the content from a specified source file, generates a JSON batch string,
    ///  and writes the output to a destination file. Each line in the source file
    ///  is treated as a separate request body.
    /// </summary>
    /// <param name="Source">
    ///  The file path of the source file that contains the input content.
    /// </param>
    /// <param name="Destination">
    ///  The file path where the generated JSON batch string will be saved.
    /// </param>
    /// <param name="Url">
    ///  The string containing the destination URL where the batch requests will be sent.
    /// </param>
    /// <returns>
    ///  The file path of the newly created batch file (identical to the <c>Destination</c>).
    /// </returns>
    function WriteBatchToFile(const Source, Destination: string; const Url: string): string; overload;
    /// <summary>
    ///  Takes an array of string values, generates a JSON batch string by treating each
    ///  string as a separate request body, and saves the result to the specified
    ///  destination file.
    /// </summary>
    /// <param name="Value">
    ///  An array of string values, each to be included as a separate item in the JSON batch.
    /// </param>
    /// <param name="Destination">
    ///  The file path where the generated JSON batch string will be saved.
    /// </param>
    /// <param name="Url">
    ///  The <see cref="TBatchUrl"/> object representing the destination URL where
    ///  the batch requests will be sent.
    /// </param>
    /// <returns>
    ///  The file path of the newly created batch file (identical to the <c>Destination</c>).
    /// </returns>
    function WriteBatchToFile(const Value: TArray<string>; const Destination: string; const Url: TBatchUrl): string; overload;
    /// <summary>
    ///  Takes an array of string values, generates a JSON batch string by treating each
    ///  string as a separate request body, and saves the result to the specified
    ///  destination file.
    /// </summary>
    /// <param name="Value">
    ///  An array of string values, each to be included as a separate item in the JSON batch.
    /// </param>
    /// <param name="Destination">
    ///  The file path where the generated JSON batch string will be saved.
    /// </param>
    /// <param name="Url">
    ///  The string containing the destination URL where the batch requests will be sent.
    /// </param>
    /// <returns>
    ///  The file path of the newly created batch file (identical to the <c>Destination</c>).
    /// </returns>
    function WriteBatchToFile(const Value: TArray<string>; const Destination: string; const Url: string): string; overload;
  end;

implementation

{ TBatchResponse }

destructor TBatchResponse<T>.Destroy;
begin
  if Assigned(FBody) then
    FBody.Free;
  inherited;
end;

{ TBatchOutput }

destructor TBatchOutput<T>.Destroy;
begin
  if Assigned(FResponse) then
    FResponse.Free;
  if Assigned(FError) then
    FError.Free;
  inherited;
end;

end.

unit GenAI.Batch;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

-------------------------------------------------------------------------------}

(*
  -- WARNING --
    The documentation references the capability to execute a batch through the /v1/completions endpoint.
    However, it  is  important to  clarify  that batch  processing is  not feasible  with this endpoint.
    This limitation arises because not all models available  for the completion mechanism support batch
    operations.
*)

interface

uses
  System.SysUtils, System.Classes, System.Threading, System.JSON, REST.Json.Types,
  REST.JsonReflect,
  GenAI.API.Params, GenAI.API, GenAI.Consts, GenAI.Types, GenAI.Async.Support,
  GenAI.API.Lists;

type
  /// <summary>
  /// Represents the parameters required to create a batch operation within the OpenAI API.
  /// This class encapsulates the settings and metadata necessary to initiate a batch process, including the
  /// input file, endpoint specification, completion window, and any optional metadata associated with the
  /// batch.
  /// </summary>
  TBatchCreateParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the ID of the uploaded file that contains the batch requests.
    /// This is a required parameter and must reference a valid file ID that has been prepared and uploaded beforehand.
    /// </summary>
    /// <param name="Value">The ID of the uploaded file.</param>
    /// <returns>The instance of TBatchCreateParams for method chaining.</returns>
    function InputFileId(const Value: string): TBatchCreateParams;
    /// <summary>
    /// Specifies the API endpoint to be used for all requests within the batch.
    /// This is a required parameter and must be one of the supported endpoints such as :
    /// <para>
    /// - <c>/v1/chat/completions</c>
    /// </para>
    /// <para>
    /// - <c>/v1/embeddings</c>
    /// </para>
    /// </summary>
    /// <param name="Value">The API endpoint as a string.</param>
    /// <returns>The instance of TBatchCreateParams for method chaining.</returns>
    function Endpoint(const Value: string): TBatchCreateParams;
    /// <summary>
    /// Sets the completion window for the batch. This defines the time frame within which the batch should be processed.
    /// Currently, only "24h" is supported, which indicates that the batch should be completed within 24 hours.
    /// </summary>
    /// <param name="Value">The completion window string, typically "24h".</param>
    /// <returns>The instance of TBatchCreateParams for method chaining.</returns>
    function CompletionWindow(const Value: string): TBatchCreateParams;
    /// <summary>
    /// Attaches optional custom metadata to the batch. This can be used to store additional structured information about the batch operation.
    /// The metadata is a JSON object and can contain up to 16 key-value pairs, with keys up to 64 characters and values up to 512 characters.
    /// </summary>
    /// <param name="Value">The JSON object containing the metadata.</param>
    /// <returns>The instance of TBatchCreateParams for method chaining.</returns>
    function Metadata(const Value: TJSONObject): TBatchCreateParams;
  end;

  /// <summary>
  /// Represents the error details associated with a specific request within a batch operation.
  /// This class holds detailed information about an error, including a machine-readable code, a human-readable message,
  /// and the specific parameter or line that caused the error. This facilitates debugging and error handling in batch processing.
  /// </summary>
  TBatchErrorsData = class
  private
    FCode: string;
    FMessage: string;
    FParam: string;
    FLine: Int64;
  public
    /// <summary>
    /// Gets or sets the machine-readable error code. This code can be used to programmatically identify the type of error that occurred.
    /// </summary>
    /// <returns>The error code as a string.</returns>
    property Code: string read FCode write FCode;
    /// <summary>
    /// Gets or sets the human-readable error message that describes the error. This message is designed to be easily understood
    /// and can be used for logging or displaying error information to users.
    /// </summary>
    /// <returns>The error message as a string.</returns>
    property Message: string read FMessage write FMessage;
    /// <summary>
    /// Gets or sets the parameter name related to the error, providing context for the error within the scope of the request.
    /// This is particularly useful when the error is associated with a specific parameter in the request data.
    /// </summary>
    /// <returns>The parameter name as a string.</returns>
    property Param: string read FParam write FParam;
    /// <summary>
    /// Gets or sets the line number from the input file that triggered the error, if applicable. This helps in pinpointing the exact
    /// location in the batch input file that needs attention, improving the efficiency of error resolution.
    /// </summary>
    /// <returns>The line number as an Int64.</returns>
    property Line: Int64 read FLine write FLine;
  end;

  /// <summary>
  /// Represents a collection of errors associated with a batch operation.
  /// This class aggregates all errors that occurred during the execution of a batch, facilitating centralized error management
  /// and analysis. Each error is detailed by an instance of TBatchErrorsData, which provides specific error information.
  /// </summary>
  TBatchErrors = class
  private
    FObject: string;
    FData: TArray<TBatchErrorsData>;
  public
    /// <summary>
    /// Gets or sets the type of the object. This property typically contains the value 'error', identifying the nature of the data stored in this class.
    /// </summary>
    /// <returns>The object type as a string.</returns>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// Gets or sets an array of TBatchErrorsData instances that detail each error occurred during the batch operation.
    /// This array facilitates access to specific error details, allowing for individual error handling and reporting.
    /// </summary>
    /// <returns>An array of TBatchErrorsData instances.</returns>
    property Data: TArray<TBatchErrorsData> read FData write FData;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Provides a base class for handling timestamps associated with various stages of a batch's lifecycle.
  /// This class is designed to abstract the common functionality needed to convert timestamp data from Unix time format to human-readable strings.
  /// These timestamps reflect key events in the batch processing timeline, such as creation, processing, and expiration.
  /// </summary>
  TBatchTimeStamp = class abstract(TJSONFingerprint)
  protected
    function GetCreatedAtAsString: string; virtual; abstract;
    function GetInProgressAtAsString: string; virtual; abstract;
    function GetExpiresAtAsString: string; virtual; abstract;
    function GetFinalizingAtAsString: string; virtual; abstract;
    function GetCompletedAtAsString: string; virtual; abstract;
    function GetFailedAtAsString: string; virtual; abstract;
    function GetExpiredAtAsString: string; virtual; abstract;
    function GetCancellingAtAsString: string; virtual; abstract;
    function GetCancelledAtAsString: string; virtual; abstract;
  public
    /// <summary>
    /// Retrieves the creation timestamp as a formatted string. This timestamp represents when the batch was initially created.
    /// </summary>
    /// <returns>A string representation of the Unix timestamp for the batch's creation time.</returns>
    property CreatedAtasString: string read GetCreatedAtAsString;
    /// <summary>
    /// Retrieves the in-progress timestamp as a formatted string. This timestamp indicates when the batch started processing.
    /// </summary>
    /// <returns>A string representation of the Unix timestamp for when the batch processing began.</returns>
    property InProgressAtAsString: string read GetInProgressAtAsString;
    /// <summary>
    /// Retrieves the expiration timestamp as a formatted string. This timestamp denotes when the batch is set to expire.
    /// </summary>
    /// <returns>A string representation of the Unix timestamp for when the batch will expire.</returns>
    property ExpiresAtAsString: string read GetExpiresAtAsString;
    /// <summary>
    /// Retrieves the finalizing timestamp as a formatted string. This timestamp reflects when the batch entered the finalizing stage,
    /// which typically involves concluding processing and preparing results.
    /// </summary>
    /// <returns>A string representation of the Unix timestamp for when the batch began its finalization process.</returns>
    property FinalizingAtAsString: string read GetFinalizingAtAsString;
    /// <summary>
    /// Retrieves the completed timestamp as a formatted string. This timestamp indicates when the batch processing was fully completed.
    /// </summary>
    /// <returns>A string representation of the Unix timestamp for when the batch processing was completed.</returns>
    property CompletedAtAsString: string read GetCompletedAtAsString;
    /// <summary>
    /// Retrieves the failed timestamp as a formatted string. This timestamp is recorded if the batch fails at any point during its lifecycle.
    /// </summary>
    /// <returns>A string representation of the Unix timestamp for when the batch failed.</returns>
    property FailedAtAsString: string read GetFailedAtAsString;
    /// <summary>
    /// Retrieves the expired timestamp as a formatted string. This timestamp is used when the batch has passed its expiration time without completion.
    /// </summary>
    /// <returns>A string representation of the Unix timestamp for when the batch expired.</returns>
    property ExpiredAtAsString: string read GetExpiredAtAsString;
    /// <summary>
    /// Retrieves the cancelling timestamp as a formatted string. This timestamp denotes when the cancellation process for the batch was initiated.
    /// </summary>
    /// <returns>A string representation of the Unix timestamp for when the batch cancellation process started.</returns>
    property CancellingAtAsString: string read GetCancellingAtAsString;
    /// <summary>
    /// Retrieves the cancelled timestamp as a formatted string. This timestamp indicates when the batch was fully cancelled.
    /// </summary>
    /// <returns>A string representation of the Unix timestamp for when the batch was officially cancelled.</returns>
    property CancelledAtAsString: string read GetCancelledAtAsString;
  end;

  /// <summary>
  /// Provides a count of requests at various stages of processing within a batch operation.
  /// This class includes properties for tracking the total number of requests, the number of requests that have been completed successfully,
  /// and the number of requests that have failed. This information is crucial for monitoring and managing the progress of batch operations.
  /// </summary>
  TBatchRequestCounts = class
  private
    FTotal: Int64;
    FCompleted: Int64;
    FFailed: Int64;
  public
    /// <summary>
    /// Gets or sets the total number of requests included in the batch. This count provides an overview of the batch size and scope.
    /// </summary>
    /// <returns>The total number of requests as an Int64.</returns>
    property Total: Int64 read FTotal write FTotal;
    /// <summary>
    /// Gets or sets the number of requests that have been completed successfully. This count helps in assessing the effectiveness
    /// and efficiency of the batch processing.
    /// </summary>
    /// <returns>The number of completed requests as an Int64.</returns>
    property Completed: Int64 read FCompleted write FCompleted;
    /// <summary>
    /// Gets or sets the number of requests that have failed during the batch processing. This count is essential for error analysis
    /// and understanding the robustness of the batch operation.
    /// </summary>
    /// <returns>The number of failed requests as an Int64.</returns>
    property Failed: Int64 read FFailed write FFailed;
  end;

  /// <summary>
  /// Represents a batch operation as managed by the OpenAI API, encapsulating comprehensive details
  /// necessary for managing batch processing tasks. This class includes functionalities such as tracking
  /// the batch's progress, its inputs and outputs, handling errors, and managing lifecycle timestamps.
  /// </summary>
  TBatch = class(TBatchTimeStamp)
  private
    FId: string;
    FObject: string;
    FEndpoint: string;
    FErrors: TBatchErrors;
    [JsonNameAttribute('input_file_id')]
    FInputFileId: string;
    [JsonNameAttribute('completion_window')]
    FCompletionWindow: string;
    [JsonReflectAttribute(ctString, rtString, TBatchStatusInterceptor)]
    FStatus: TBatchStatus;
    [JsonNameAttribute('output_file_id')]
    FOutputFileId: string;
    [JsonNameAttribute('error_file_id')]
    FErrorFileId: string;
    [JsonNameAttribute('created_at')]
    FCreatedAt: TInt64OrNull;
    [JsonNameAttribute('in_progress_at')]
    FInProgressAt: TInt64OrNull;
    [JsonNameAttribute('expires_at')]
    FExpiresAt: TInt64OrNull;
    [JsonNameAttribute('finalizing_at')]
    FFinalizingAt: TInt64OrNull;
    [JsonNameAttribute('completed_at')]
    FCompletedAt: TInt64OrNull;
    [JsonNameAttribute('failed_at')]
    FFailedAt: TInt64OrNull;
    [JsonNameAttribute('expired_at')]
    FExpiredAt: TInt64OrNull;
    [JsonNameAttribute('cancelling_at')]
    FCancellingAt: TInt64OrNull;
    [JsonNameAttribute('cancelled_at')]
    FCancelledAt: TInt64OrNull;
    [JsonNameAttribute('request_counts')]
    FRequestCounts: TBatchRequestCounts;
    [JsonReflectAttribute(ctString, rtString, TMetadataInterceptor)]
    FMetadata: string;
    function GetCancelledAt: Int64;
    function GetCancellingAt: Int64;
    function GetCompletedAt: Int64;
    function GetCreatedAt: Int64;
    function GetExpiredAt: Int64;
    function GetExpiresAt: Int64;
    function GetFailedAt: Int64;
    function GetFinalizingAt: Int64;
    function GetInProgressAt: Int64;
  protected
    function GetCreatedAtAsString: string; override;
    function GetInProgressAtAsString: string; override;
    function GetExpiresAtAsString: string; override;
    function GetFinalizingAtAsString: string; override;
    function GetCompletedAtAsString: string; override;
    function GetFailedAtAsString: string; override;
    function GetExpiredAtAsString: string; override;
    function GetCancellingAtAsString: string; override;
    function GetCancelledAtAsString: string; override;
  public
    /// <summary>
    /// The unique identifier for the batch. This ID is used to track and manage the batch throughout its lifecycle.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Specifies the object type, which remains constant as 'batch' for instances of this class,
    /// aligning with OpenAI's API structure.
    /// </summary>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// Defines the API endpoint that the batch uses, indicating whether the batch is for completions, embeddings,
    /// or another supported API function. This setup helps direct the batch processing accordingly.
    /// </summary>
    property Endpoint: string read FEndpoint write FEndpoint;
    /// <summary>
    /// Manages the collection of errors that might occur during the processing of the batch, providing
    /// detailed error diagnostics that are critical for troubleshooting and error resolution.
    /// </summary>
    property Errors: TBatchErrors read FErrors write FErrors;
    /// <summary>
    /// Identifies the input file by its ID, linking the batch to its specific input data which contains
    /// the requests or data set the batch operation is expected to process.
    /// </summary>
    property InputFileId: string read FInputFileId write FInputFileId;
    /// <summary>
    /// Specifies the time window within which the batch is expected to complete, ensuring timely processing.
    /// This property supports the current system constraint of a 24-hour processing window.
    /// </summary>
    property CompletionWindow: string read FCompletionWindow write FCompletionWindow;
    /// <summary>
    /// Reflects the current status of the batch, such as 'in progress', 'completed', or 'failed',
    /// providing real-time status updates necessary for monitoring the progress of batch operations.
    /// </summary>
    property Status: TBatchStatus read FStatus write FStatus;
    /// <summary>
    /// Holds the ID of the output file that contains the results of the batch's processed requests,
    /// facilitating access to the outcomes of the batch operation.
    /// </summary>
    property OutputFileId: string read FOutputFileId write FOutputFileId;
    /// <summary>
    /// If errors occur, this holds the ID of the error file which logs detailed error information,
    /// assisting in the analysis and rectification of issues that occurred during batch processing.
    /// </summary>
    property ErrorFileId: string read FErrorFileId write FErrorFileId;
    /// <summary>
    /// Records the timestamp of when the batch was initially created. This is the starting point in the
    /// lifecycle of a batch operation.
    /// </summary>
    property CreatedAt: Int64 read GetCreatedAt;
    /// <summary>
    /// Marks the timestamp of when the batch started processing. It's crucial for monitoring when the
    /// batch transitions from a queued or pending state to an active processing state.
    /// </summary>
    property InProgressAt: Int64 read GetInProgressAt;
    /// <summary>
    /// Indicates the timestamp of when the batch is set to expire. This property is essential for managing
    /// the lifecycle of the batch, ensuring that operations are completed within the expected timeframe or
    /// handling tasks that exceed their completion window.
    /// </summary>
    property ExpiresAt: Int64 read GetExpiresAt;
    /// <summary>
    /// Captures the timestamp of when the batch entered the finalizing stage. This stage marks the transition
    /// from active processing to concluding the operations, where final checks or cleanup might occur.
    /// </summary>
    property FinalizingAt: Int64 read GetFinalizingAt;
    /// <summary>
    /// Represents the timestamp of when the batch processing was completed successfully. This timestamp is
    /// crucial for tracking the end of the processing phase and the readiness of the output data.
    /// </summary>
    property CompletedAt: Int64 read GetCompletedAt;
    /// <summary>
    /// Logs the timestamp of when the batch encountered a failure that prevented it from completing
    /// successfully. This property is critical for error handling and for initiating potential retries or
    /// investigations.
    /// </summary>
    property FailedAt: Int64 read GetFailedAt;
    /// <summary>
    /// Denotes the timestamp of when the batch expired. If a batch does not complete within the designated
    /// time (as noted in ExpiresAt), it may be marked as expired, indicating that it did not conclude in the
    /// expected period.
    /// </summary>
    property ExpiredAt: Int64 read GetExpiredAt;
    /// <summary>
    /// Records the timestamp of when the cancellation process for the batch started. This property is
    /// important for managing batches that need to be stopped before completion due to errors, changes in
    /// requirements, or other operational reasons.
    /// </summary>
    property CancellingAt: Int64 read GetCancellingAt;
    /// <summary>
    /// Indicates the timestamp of when the batch was officially cancelled. This final timestamp in the
    /// cancellation process confirms that no further processing will occur and the batch has been terminated.
    /// </summary>
    property CancelledAt: Int64 read GetCancelledAt;
    /// <summary>
    /// Provides a structured breakdown of request counts within the batch, including total requests,
    /// successfully completed requests, and failed requests, enabling effective management and analysis
    /// of batch performance.
    /// </summary>
    property RequestCounts: TBatchRequestCounts read FRequestCounts write FRequestCounts;
    /// <summary>
    /// Optional metadata that can be attached to a batch. This metadata can store additional information
    /// about the batch in a structured format, aiding in further customization and utility.
    /// </summary>
    property Metadata: string read FMetadata write FMetadata;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a collection of batch objects from the OpenAI API.
  /// This class provides an aggregated view of multiple batch entries, enabling effective navigation and management
  /// of batch operations. It includes functionality for pagination to handle large sets of data efficiently.
  /// </summary>
  TBatches = TAdvancedList<TBatch>;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TBatch</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynBatch</c> type extends the <c>TAsynParams&lt;TBatch&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynBatch = TAsynCallBack<TBatch>;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TBatches</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynBatches</c> type extends the <c>TAsynParams&lt;TBatches&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynBatches = TAsynCallBack<TBatches>;

  /// <summary>
  /// Provides routes for managing batches within the OpenAI API.
  /// This class offers methods to create, retrieve, cancel, and list batches, facilitating the orchestration of batch operations.
  /// It is designed to support both synchronous and asynchronous execution of these operations, enhancing flexibility and efficiency
  /// in application workflows.
  /// </summary>
  TBatchRoute = class(TGenAIRoute)
    /// <summary>
    /// Asynchronously creates a batch with the specified parameters.
    /// This method uses a callback mechanism to manage the lifecycle of the batch creation operation,
    /// allowing for non-blocking operations within applications.
    /// </summary>
    /// <param name="ParamProc">A procedure that configures the parameters for the batch creation.</param>
    /// <param name="CallBacks">A function that returns an instance of TAsynBatch for handling callback events.</param>
    procedure AsynCreate(const ParamProc: TProc<TBatchCreateParams>; const CallBacks: TFunc<TAsynBatch>);
    /// <summary>
    /// Asynchronously retrieves a batch by its ID.
    /// This method uses a callback mechanism to handle the lifecycle of the batch retrieval operation,
    /// facilitating non-blocking retrieval within applications.
    /// </summary>
    /// <param name="BatchId">The unique identifier of the batch to retrieve.</param>
    /// <param name="CallBacks">A function that returns an instance of TAsynBatch for handling callback events.</param>
    procedure AsynRetrieve(const BatchId: string; const CallBacks: TFunc<TAsynBatch>);
    /// <summary>
    /// Asynchronously cancels an in-progress batch.
    /// This method provides a non-blocking way to send a cancellation request for a batch,
    /// using callbacks to manage the operation's lifecycle.
    /// </summary>
    /// <param name="BatchId">The unique identifier of the batch to cancel.</param>
    /// <param name="CallBacks">A function that returns an instance of TAsynBatch for handling callback events.</param>
    procedure AsynCancel(const BatchId: string; const CallBacks: TFunc<TAsynBatch>);
    /// <summary>
    /// Asynchronously lists all batches.
    /// This method uses a callback mechanism to enable non-blocking operations for listing batches,
    /// facilitating efficient data management and retrieval.
    /// </summary>
    /// <param name="CallBacks">A function that returns an instance of TAsynBatches for handling callback events.</param>
    procedure AsynList(const CallBacks: TFunc<TAsynBatches>); overload;
    /// <summary>
    /// Asynchronously lists batches with optional parameters for pagination.
    /// This method allows for non-blocking batch listing operations, using callbacks to handle the lifecycle of the listing request.
    /// </summary>
    /// <param name="ParamProc">An optional procedure to configure listing parameters such as pagination.</param>
    /// <param name="CallBacks">A function that returns an instance of TAsynBatches for handling callback events.</param>
    procedure AsynList(const ParamProc: TProc<TUrlPaginationParams>; const CallBacks: TFunc<TAsynBatches>); overload;
    /// <summary>
    /// Synchronously creates a batch with the specified parameters.
    /// This method provides a direct way to create a batch, blocking until the operation is complete.
    /// </summary>
    /// <param name="ParamProc">A procedure that configures the parameters for the batch creation.</param>
    /// <returns>An instance of TBatch representing the newly created batch.</returns>
    function Create(const ParamProc: TProc<TBatchCreateParams>): TBatch;
    /// <summary>
    /// Synchronously retrieves a batch by its ID.
    /// This method provides a direct way to retrieve a batch, blocking until the operation is complete.
    /// </summary>
    /// <param name="BatchId">The unique identifier of the batch to retrieve.</param>
    /// <returns>An instance of TBatch representing the retrieved batch.</returns>
    function Retrieve(const BatchId: string): TBatch;
    /// <summary>
    /// Synchronously cancels an in-progress batch.
    /// This method provides a direct way to send a cancellation request for a batch,
    /// blocking until the operation is confirmed.
    /// </summary>
    /// <param name="BatchId">The unique identifier of the batch to cancel.</param>
    /// <returns>An instance of TBatch representing the cancelled batch.</returns>
    function Cancel(const BatchId: string): TBatch;
    /// <summary>
    /// Synchronously lists all batches.
    /// This method provides a direct way to list batches, blocking until the operation is complete.
    /// </summary>
    /// <returns>An instance of TBatches containing the list of batches.</returns>
    function List: TBatches; overload;
    /// <summary>
    /// Synchronously lists batches with specified parameters for pagination.
    /// This method provides a direct way to list batches with additional control over the retrieval scope,
    /// blocking until the operation is complete.
    /// </summary>
    /// <param name="ParamProc">A procedure to configure listing parameters such as pagination.</param>
    /// <returns>An instance of TBatches containing the list of batches.</returns>
    function List(const ParamProc: TProc<TUrlPaginationParams>): TBatches; overload;
  end;

implementation

{ TBatchCreateParams }

function TBatchCreateParams.CompletionWindow(
  const Value: string): TBatchCreateParams;
begin
  Result := TBatchCreateParams(Add('completion_window', Value));
end;

function TBatchCreateParams.Endpoint(const Value: string): TBatchCreateParams;
begin
  Result := TBatchCreateParams(Add('endpoint', Value));
end;

function TBatchCreateParams.InputFileId(
  const Value: string): TBatchCreateParams;
begin
  Result := TBatchCreateParams(Add('input_file_id', Value));
end;

function TBatchCreateParams.Metadata(
  const Value: TJSONObject): TBatchCreateParams;
begin
  Result := TBatchCreateParams(Add('metadata', Value));
end;

{ TBatchErrors }

destructor TBatchErrors.Destroy;
begin
  for var Item in FData do
    Item.Free;
  inherited;
end;

{ TBatch }

destructor TBatch.Destroy;
begin
  if Assigned(FErrors) then
    FErrors.Free;
  if Assigned(FRequestCounts) then
    FRequestCounts.Free;
  inherited;
end;

function TBatch.GetCancelledAt: Int64;
begin
  Result := TInt64OrNull(FCancelledAt).ToInteger;
end;

function TBatch.GetCancelledAtAsString: string;
begin
  Result := TInt64OrNull(FCancelledAt).ToUtcDateString;
end;

function TBatch.GetCancellingAt: Int64;
begin
  Result := TInt64OrNull(FCancellingAt).ToInteger;
end;

function TBatch.GetCancellingAtAsString: string;
begin
  Result := TInt64OrNull(FCancellingAt).ToUtcDateString;
end;

function TBatch.GetCompletedAt: Int64;
begin
  Result := TInt64OrNull(FCompletedAt).ToInteger;
end;

function TBatch.GetCompletedAtAsString: string;
begin
  Result := TInt64OrNull(FCompletedAt).ToUtcDateString;
end;

function TBatch.GetCreatedAt: Int64;
begin
  Result := TInt64OrNull(FCreatedAt).ToInteger;
end;

function TBatch.GetCreatedAtAsString: string;
begin
  Result := TInt64OrNull(FCreatedAt).ToUtcDateString;
end;

function TBatch.GetExpiredAt: Int64;
begin
  Result := TInt64OrNull(FExpiredAt).ToInteger;
end;

function TBatch.GetExpiredAtAsString: string;
begin
  Result := TInt64OrNull(FExpiredAt).ToUtcDateString;
end;

function TBatch.GetExpiresAt: Int64;
begin
  Result := TInt64OrNull(FExpiresAt).ToInteger;
end;

function TBatch.GetExpiresAtAsString: string;
begin
  Result := TInt64OrNull(FExpiresAt).ToUtcDateString;
end;

function TBatch.GetFailedAt: Int64;
begin
  Result := TInt64OrNull(FFailedAt).ToInteger;
end;

function TBatch.GetFailedAtAsString: string;
begin
  Result := TInt64OrNull(FFailedAt).ToUtcDateString;
end;

function TBatch.GetFinalizingAt: Int64;
begin
  Result := TInt64OrNull(FFinalizingAt).ToInteger;
end;

function TBatch.GetFinalizingAtAsString: string;
begin
  Result := TInt64OrNull(FFinalizingAt).ToUtcDateString;
end;

function TBatch.GetInProgressAt: Int64;
begin
  Result := TInt64OrNull(FInProgressAt).ToInteger;
end;

function TBatch.GetInProgressAtAsString: string;
begin
  Result := TInt64OrNull(FInProgressAt).ToUtcDateString;
end;

{ TBatchRoute }

procedure TBatchRoute.AsynCancel(const BatchId: string;
  const CallBacks: TFunc<TAsynBatch>);
begin
  with TAsynCallBackExec<TAsynBatch, TBatch>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TBatch
      begin
        Result := Self.Cancel(BatchId);
      end);
  finally
    Free;
  end;
end;

procedure TBatchRoute.AsynCreate(const ParamProc: TProc<TBatchCreateParams>;
  const CallBacks: TFunc<TAsynBatch>);
begin
  with TAsynCallBackExec<TAsynBatch, TBatch>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TBatch
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TBatchRoute.AsynList(const ParamProc: TProc<TUrlPaginationParams>;
  const CallBacks: TFunc<TAsynBatches>);
begin
  with TAsynCallBackExec<TAsynBatches, TBatches>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TBatches
      begin
        Result := Self.List(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TBatchRoute.AsynList(const CallBacks: TFunc<TAsynBatches>);
begin
  with TAsynCallBackExec<TAsynBatches, TBatches>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TBatches
      begin
        Result := Self.List;
      end);
  finally
    Free;
  end;
end;

procedure TBatchRoute.AsynRetrieve(const BatchId: string;
  const CallBacks: TFunc<TAsynBatch>);
begin
  with TAsynCallBackExec<TAsynBatch, TBatch>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TBatch
      begin
        Result := Self.Retrieve(BatchId);
      end);
  finally
    Free;
  end;
end;

function TBatchRoute.Cancel(const BatchId: string): TBatch;
begin
  Result := API.Post<TBatch>('batches/' + BatchId + '/cancel');
end;

function TBatchRoute.Create(const ParamProc: TProc<TBatchCreateParams>): TBatch;
begin
  Result := API.Post<TBatch, TBatchCreateParams>('batches', ParamProc);
end;

function TBatchRoute.List: TBatches;
begin
  Result := API.Get<TBatches>('batches');
end;

function TBatchRoute.List(const ParamProc: TProc<TUrlPaginationParams>): TBatches;
begin
  Result := API.Get<TBatches, TUrlPaginationParams>('batches', ParamProc);
end;

function TBatchRoute.Retrieve(const BatchId: string): TBatch;
begin
  Result := API.Get<TBatch>('batches/' + BatchId);
end;

end.


unit GenAI.Batch.Reader;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Threading, System.JSON, REST.Json.Types,
  REST.JsonReflect, GenAI.API, GenAI.Batch.Interfaces;

type
  /// <summary>
  /// Implements the <see cref="IJSONLReader{T}"/> interface for reading and deserializing
  /// JSONL (JSON Lines) input into a strongly typed array of batch output objects.
  /// </summary>
  /// <typeparam name="T">
  /// The type of the response body object to be deserialized. Must be a class with a parameterless constructor.
  /// </typeparam>
  TJSONLReader<T: class, constructor> = class(TInterfacedObject, IJSONLReader<T>)
  private
    FInput: string;
    function Input(const Value: string): TJSONLReader<T>;
    function Output: TArray<TBatchOutput<T>>;
  public
    /// <summary>
    /// Deserializes a JSONL-formatted string into an array of <typeparamref name="TBatchOutput{T}"/> objects.
    /// </summary>
    /// <param name="Value">
    /// The JSONL-formatted input string to be deserialized.
    /// </param>
    /// <returns>
    /// An array of deserialized <typeparamref name="TBatchOutput{T}"/> objects.
    /// </returns>
    function Deserialize(const Value: string): TArray<TBatchOutput<T>>;
    /// <summary>
    /// Creates an instance of the <see cref="TJSONLReader{T}"/> class.
    /// </summary>
    /// <returns>
    /// An instance of <see cref="IJSONLReader{T}"/> for processing JSONL input.
    /// </returns>
    class function CreateInstance: IJSONLReader<T>;
  end;

implementation

{ TJSONLReader }

class function TJSONLReader<T>.CreateInstance: IJSONLReader<T>;
begin
  Result := TJSONLReader<T>.Create;
end;

function TJSONLReader<T>.Deserialize(const Value: string): TArray<TBatchOutput<T>>;
begin
  Result := Input(Value).Output;
end;

function TJSONLReader<T>.Input(const Value: string): TJSONLReader<T>;
begin
  FInput := Value;
  Result := Self;
end;

function TJSONLReader<T>.Output: TArray<TBatchOutput<T>>;
begin
  var StringReader := TStringReader.Create(FInput);
  try
    var Line := StringReader.ReadLine;
    while not Line.Trim.IsEmpty do
      begin
        Result := Result + [TApiDeserializer.Parse<TBatchOutput<T>>(Line)];
        Line := StringReader.ReadLine;
      end;
  finally
    StringReader.Free;
  end;
end;

end.

unit GenAI.Chat.Parallel;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Generics.Collections, System.SyncObjs, System.Threading,
  GenAI.Types, GenAI.Async.Support, GenAI.API.Params;

type
  /// <summary>
  /// Represents an item in a bundle of chat prompts and responses.
  /// </summary>
  /// <remarks>
  /// This class stores information about a single chat request, including its index,
  /// associated prompt, generated response, and related chat object.
  /// It is used within a <c>TBundleList</c> to manage multiple asynchronous chat requests.
  /// </remarks>
  TBundleItem = class
  private
    FIndex: Integer;
    FFinishIndex: Integer;
    FPrompt: string;
    FResponse: string;
    FChat: TObject;
  public
    /// <summary>
    /// Gets or sets the index of the item in the bundle.
    /// </summary>
    property Index: Integer read FIndex write FIndex;
    /// <summary>
    /// Gets or sets the finishing index of the item after processing.
    /// </summary>
    property FinishIndex: Integer read FFinishIndex write FFinishIndex;
    /// <summary>
    /// Gets or sets the prompt associated with this bundle item.
    /// </summary>
    property Prompt: string read FPrompt write FPrompt;
    /// <summary>
    /// Gets or sets the response generated for the given prompt.
    /// </summary>
    property Response: string read FResponse write FResponse;
    /// <summary>
    /// Gets or sets the chat object associated with this item.
    /// </summary>
    /// <remarks>
    /// This object contains additional information about the chat session,
    /// including metadata related to the AI-generated response.
    /// </remarks>
    property Chat: TObject read FChat write FChat;
    /// <summary>
    /// Destroys the <c>TBundleItem</c> instance and releases associated resources.
    /// </summary>
    /// <remarks>
    /// If a chat object (<c>FChat</c>) is assigned, it is freed upon destruction.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages a collection of <c>TBundleItem</c> objects.
  /// </summary>
  /// <remarks>
  /// This class provides methods to add, retrieve, and count items in a bundle.
  /// It is designed to store multiple chat request items processed in parallel.
  /// The internal storage uses a <c>TObjectList&lt;TBundleItem&gt;</c> with automatic memory management.
  /// </remarks>
  TBundleList = class
  private
    FItems: TObjectList<TBundleItem>;
  public
    /// <summary>
    /// Initializes a new instance of <c>TBundleList</c>.
    /// </summary>
    /// <remarks>
    /// This constructor creates an internal list of <c>TBundleItem</c> objects,
    /// ensuring that items are automatically freed when the list is destroyed.
    /// </remarks>
    constructor Create;
    /// <summary>
    /// Destroys the <c>TBundleList</c> instance and releases all associated resources.
    /// </summary>
    /// <remarks>
    /// This destructor frees all <c>TBundleItem</c> objects stored in the list.
    /// </remarks>
    destructor Destroy; override;
    /// <summary>
    /// Adds a new item to the bundle.
    /// </summary>
    /// <param name="AIndex">
    /// The index of the new item in the bundle.
    /// </param>
    /// <returns>
    /// The newly created <c>TBundleItem</c> instance.
    /// </returns>
    /// <remarks>
    /// This method creates a new <c>TBundleItem</c>, assigns it the specified index,
    /// and adds it to the internal list.
    /// </remarks>
    function Add(const AIndex: Integer): TBundleItem;
    /// <summary>
    /// Retrieves an item from the bundle by its index.
    /// </summary>
    /// <param name="AIndex">
    /// The zero-based index of the item to retrieve.
    /// </param>
    /// <returns>
    /// The <c>TBundleItem</c> instance at the specified index.
    /// </returns>
    /// <exception cref="Exception">
    /// Raised if the specified index is out of bounds.
    /// </exception>
    function Item(const AIndex: Integer): TBundleItem;
    /// <summary>
    /// Gets the total number of items in the bundle.
    /// </summary>
    /// <returns>
    /// The number of items stored in the bundle.
    /// </returns>
    function Count: Integer;
    /// <summary>
    /// Provides direct access to the internal list of <c>TBundleItem</c> objects.
    /// </summary>
    property Items: TObjectList<TBundleItem> read FItems write FItems;
  end;

  /// <summary>
  /// Represents an asynchronous callback buffer for handling chat responses.
  /// </summary>
  /// <remarks>
  /// This class is a specialized type used to manage asynchronous operations
  /// related to chat request processing. It inherits from <c>TAsynCallBack&lt;TBundleList&gt;</c>,
  /// enabling structured handling of callback events.
  /// </remarks>
  TAsynBundleList = TAsynCallBack<TBundleList>;

  /// <summary>
  /// Provides helper methods for managing asynchronous tasks.
  /// </summary>
  /// <remarks>
  /// This class contains utility methods for handling task execution flow,
  /// including a method to execute a follow-up action once a task completes.
  /// <para>
  /// - In order to replace TTask.WaitForAll due to a memory leak in TLightweightEvent/TCompleteEventsWrapper.
  /// See report RSP-12462 and RSP-25999.
  /// </para>
  /// </remarks>
  TTaskHelper = class
  public
    /// <summary>
    /// Executes a specified action after a given task is completed.
    /// </summary>
    /// <param name="Task">
    /// The task to wait for before executing the next action.
    /// </param>
    /// <param name="NextAction">
    /// The procedure to execute once the task is completed.
    /// </param>
    /// <param name="TimeOut">
    /// The maximum time (in milliseconds) to wait for the task to complete.
    /// The default value is 120,000 ms (2 minutes).
    /// </param>
    /// <remarks>
    /// This method waits for the specified task to finish within the provided timeout period.
    /// Once completed, the follow-up action is executed in the main thread using <c>TThread.Queue</c>,
    /// ensuring thread safety.
    /// <para>
    /// - In order to replace TTask.WaitForAll due to a memory leak in TLightweightEvent/TCompleteEventsWrapper.
    /// See report RSP-12462 and RSP-25999.
    /// </para>
    /// </remarks>
    class procedure ContinueWith(const Task: ITask; const NextAction: TProc; const TimeOut: Cardinal = 120000);
  end;

  /// <summary>
  /// Represents the parameters used for configuring a chat request bundle.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TParameters</c> and provides specific methods for setting chat-related
  /// parameters, such as prompts, model selection, and reasoning effort.
  /// It is used to structure and pass multiple requests efficiently in parallel processing.
  /// </remarks>
  TBundleParams = class(TParameters)
  const
    S_PROMPT = 'prompts';
    S_SYSTEM = 'system';
    S_MODEL = 'model';
    S_REASONING_EFFORT = 'reasoningEffort';
    S_SEARCH_SIZE = 'searchSize';
    S_CITY = 'city';
    S_COUNTRY = 'country';
  public
    /// <summary>
    /// Sets the prompts for the chat request bundle.
    /// </summary>
    /// <param name="Value">
    /// An array of strings containing the prompts to be processed.
    /// </param>
    /// <returns>
    /// The current instance of <c>TBundleParams</c> for method chaining.
    /// </returns>
    function Prompts(const Value: TArray<string>): TBundleParams;
    /// <summary>
    /// Sets the AI model to be used for processing the chat requests.
    /// </summary>
    /// <param name="Value">
    /// A string representing the model name.
    /// </param>
    /// <returns>
    /// The current instance of <c>TBundleParams</c> for method chaining.
    /// </returns>
    function Model(const Value: string): TBundleParams;
    /// <summary>
    /// Sets the reasoning effort level for the chat requests.
    /// </summary>
    /// <param name="Value">
    /// A value of type <c>TReasoningEffort</c>, representing the level of reasoning required.
    /// </param>
    /// <returns>
    /// The current instance of <c>TBundleParams</c> for method chaining.
    /// </returns>
    function ReasoningEffort(const Value: TReasoningEffort): TBundleParams; overload;
    /// <summary>
    /// Sets the reasoning effort level for the chat requests.
    /// </summary>
    /// <param name="Value">
    /// A string value. One of low, medium or high
    /// </param>
    /// <returns>
    /// The current instance of <c>TBundleParams</c> for method chaining.
    /// </returns>
    function ReasoningEffort(const Value: string): TBundleParams; overload;
    /// <summary>
    /// Sets the search size parameter for the chat request bundle.
    /// </summary>
    /// <param name="Value">
    /// A string specifying the desired search size. One of low, medium or high.
    /// </param>
    /// <returns>
    /// The current instance of <c>TBundleParams</c>, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// The search size parameter is used to control web search.
    /// </remarks>
    function SearchSize(const Value: string): TBundleParams;
    /// <summary>
    /// Sets the city parameter to influence web-based search results based on location.
    /// </summary>
    /// <param name="Value">
    /// A string representing the name of the city to be used for location-aware search context.
    /// </param>
    /// <returns>
    /// The current instance of <c>TBundleParams</c>, enabling method chaining.
    /// </returns>
    /// <remarks>
    /// This parameter helps refine the AI's response by providing geographical context, allowing it
    /// to tailor answers or search results to the specified city. It is particularly useful when
    /// generating location-relevant information.
    /// </remarks>
    function City(const Value: string): TBundleParams;
    /// <summary>
    /// Sets the country parameter to influence web-based search results based on geographic location.
    /// </summary>
    /// <param name="Value">
    /// A string representing the name of the country to be used for location-aware search context.
    /// </param>
    /// <returns>
    /// The current instance of <c>TBundleParams</c>, enabling method chaining.
    /// </returns>
    /// <remarks>
    /// This parameter allows the AI to adjust its responses based on the specified country, enabling
    /// more accurate and relevant information retrieval for location-sensitive queries. It works in
    /// conjunction with the city parameter to provide regional context.
    /// </remarks>
    function Country(const Value: string): TBundleParams;
    /// <summary>
    /// Sets the system message for the chat request bundle.
    /// </summary>
    /// <param name="Value">
    /// A string containing the system message, which provides context or behavioral instructions
    /// to guide the AI model's responses across all prompts in the bundle.
    /// </param>
    /// <returns>
    /// The current instance of <c>TBundleParams</c> to allow method chaining.
    /// </returns>
    /// <remarks>
    /// The system message is typically used to influence the tone, format, or perspective
    /// of the AI responses, acting as a global directive for the conversation context.
    /// </remarks>
    function System(const Value: string): TBundleParams;
    /// <summary>
    /// Returns prompt array
    /// </summary>
    function GetPrompt: TArray<string>;
    /// <summary>
    /// Returns system or developer instructions
    /// </summary>
    function GetSystem: string;
    /// <summary>
    /// Returns the model name
    /// </summary>
    function GetModel: string;
    /// <summary>
    /// Returns reasoning effort for reasoning model
    /// </summary>
    function GetReasoningEffort: string;
    /// <summary>
    /// Retrieves the value of the search size parameter used in the chat request bundle.
    /// </summary>
    /// <returns>
    /// A string representing the configured search size. Expected values are typically "low", "medium", or "high".
    /// </returns>
    /// <remarks>
    /// This parameter influences the breadth of the AI's web search during response generation.
    /// It can be used to adjust the scope of information retrieval, with higher values allowing broader searches.
    /// </remarks>
    function GetSearchSize: string;
    /// <summary>
    /// Retrieves the value of the city parameter configured for the chat request bundle.
    /// </summary>
    /// <returns>
    /// A string representing the name of the city set to provide location-based context.
    /// </returns>
    /// <remarks>
    /// This parameter helps the AI tailor responses based on geographical context,
    /// allowing for more accurate and localized results when location relevance is important.
    /// </remarks>
    function GetCity: string;
    /// <summary>
    /// Retrieves the configured city parameter used to influence AI responses.
    /// </summary>
    /// <returns>
    /// A string containing the name of the city that provides geographic context for the request.
    /// </returns>
    /// <remarks>
    /// The city parameter is used to enhance the relevance of AI-generated content by tailoring responses
    /// based on the specified location. It is especially useful when handling queries with a regional focus.
    /// </remarks>
    function GetCountry: string;
    /// <summary>
    /// Initializes a new instance of <c>TBundleParams</c> with default values.
    /// </summary>
    /// <remarks>
    /// The default model is set to <c>gpt-4o-mini</c>, and the reasoning effort is set to <c>medium</c>.
    /// </remarks>
    constructor Create;
  end;

implementation

{ TBundleList }

function TBundleList.Add(const AIndex: Integer): TBundleItem;
begin
  Result := TBundleItem.Create;
  Result.Index := AIndex;
  FItems.Add(Result);
end;

function TBundleList.Count: Integer;
begin
  Result := FItems.Count;
end;

constructor TBundleList.Create;
begin
  inherited Create;
  FItems := TObjectList<TBundleItem>.Create(True);
end;

destructor TBundleList.Destroy;
begin
  FItems.Free;
  inherited;
end;

function TBundleList.Item(const AIndex: Integer): TBundleItem;
begin
  if (AIndex < 0) or (AIndex > Pred(Count)) then
    raise Exception.Create('Index out of bounds');
  Result := FItems.Items[AIndex];
end;

{ TTaskHelper }

class procedure TTaskHelper.ContinueWith(const Task: ITask;
  const NextAction: TProc; const TimeOut: Cardinal);
begin
  TTask.Run(
    procedure
    begin
      {--- Wait for the task to complete within TimeOut ms }
      Task.Wait(TimeOut);

      {--- Execute the sequence in the main thread }
      TThread.Queue(nil,
        procedure
        begin
          NextAction();
        end);
    end);
end;

{ TBundleParams }

function TBundleParams.City(const Value: string): TBundleParams;
begin
  Result := TBundleParams(Add(S_CITY, Value));
end;

function TBundleParams.Country(const Value: string): TBundleParams;
begin
  Result := TBundleParams(Add(S_COUNTRY, Value));
end;

constructor TBundleParams.Create;
begin
  inherited Create;
  Model('gpt-4o-mini');
  ReasoningEffort(TReasoningEffort.medium);
end;

function TBundleParams.GetCity: string;
begin
  Result := GetString(S_CITY);
end;

function TBundleParams.GetCountry: string;
begin
  Result := GetString(S_COUNTRY);
end;

function TBundleParams.GetModel: string;
begin
  Result := GetString(S_MODEL);
end;

function TBundleParams.GetPrompt: TArray<string>;
begin
  Result := GetArrayString(S_PROMPT);
end;

function TBundleParams.GetReasoningEffort: string;
begin
  Result := GetString(S_REASONING_EFFORT);
end;

function TBundleParams.GetSearchSize: string;
begin
  Result := GetString(S_SEARCH_SIZE);
end;

function TBundleParams.GetSystem: string;
begin
  Result := GetString(S_SYSTEM);
end;

function TBundleParams.Model(const Value: string): TBundleParams;
begin
  Result := TBundleParams(Add(S_MODEL, Value));
end;

function TBundleParams.Prompts(const Value: TArray<string>): TBundleParams;
begin
  Result := TBundleParams(Add(S_PROMPT, Value));
end;

function TBundleParams.ReasoningEffort(const Value: string): TBundleParams;
begin
  Result := TBundleParams(Add(S_REASONING_EFFORT, TReasoningEffort.Create(Value).ToString));
end;

function TBundleParams.ReasoningEffort(
  const Value: TReasoningEffort): TBundleParams;
begin
  Result := TBundleParams(Add(S_REASONING_EFFORT, Value.ToString));
end;

function TBundleParams.SearchSize(const Value: string): TBundleParams;
begin
  Result := TBundleParams(Add(S_SEARCH_SIZE, Value));
end;

function TBundleParams.System(const Value: string): TBundleParams;
begin
  Result := TBundleParams(Add(S_SYSTEM, Value));
end;

{ TBundleItem }

destructor TBundleItem.Destroy;
begin
  if Assigned(FChat) then
    FChat.Free;
  inherited;
end;

end.

unit GenAI.Chat;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

(*
  --- NOTE ---
    Regarding the management of streamed messages.

    This unit provides  an abstraction  for managing streaming  data from APIs such
    as OpenAI  or Anthropic. The "GenAI.Chat.StreamingInterface" defines a flexible
    interface for handling real-time data chunks, enabling the application to react
    to incoming data dynamically and efficiently.

    Key Features:
      - Streaming Management: Processes  data  in real-time  by  handling chunks as
        they arrive.

      - Event-driven Design: Utilizes  callback mechanisms  to provide flexible and
        dynamic responses to streaming events.

      - Adaptable Architecture: Supports experimentation  with  different streaming
        techniques, such as OpenAI's sequential streaming or Anthropic's contextual
        approaches, allowing easy integration of various streaming models.

      - Control and Flexibility: Enables custom chunk processing, flow control, and
        integration with  user-defined logic, improving  user experience and system
        responsiveness.

    This interface lays the groundwork  for implementing and  comparing alternative
    streaming techniques while maintaining a clean, modular, and extensible
    architecture.
*)

interface

uses
  System.SysUtils, System.Classes, System.Threading, System.JSON, REST.Json.Types,
  REST.JsonReflect,
  GenAI.API.Params, GenAI.API, GenAI.Consts, GenAI.Schema, GenAI.Chat.StreamingOpenAI,
  GenAI.Types, GenAI.Chat.StreamingInterface, GenAI.Functions.Tools, GenAI.Functions.Core,
  GenAI.Async.Params, GenAI.Async.Support, GenAI.Chat.Parallel;

type
  /// <summary>
  /// Represents an image URL parameter for a JSON object, allowing the configuration
  /// of URLs or base64 encoded images with optional detail settings.
  /// </summary>
  /// <remarks>
  /// This class provides methods to set the URL and detail level for images that
  /// are to be included as part of JSON requests. It can handle both direct URLs
  /// and base64-encoded image data. The detail level can specify how much information
  /// the image should convey, which can influence processing or display in APIs
  /// consuming these URLs.
  /// </remarks>
  TImageUrl = class(TJSONParam)
  public
    /// <summary>
    /// Sets the URL of the image. This can be a direct web link or a base64-encoded
    /// string representing the image data.
    /// </summary>
    /// <param name="Value">
    /// The URL as a string or base64-encoded image data.
    /// </param>
    /// <returns>
    /// Returns an instance of TImageUrl.
    /// </returns>
    function Url(const Value: string): TImageUrl;
    /// <summary>
    /// Sets the detail level of the image, influencing how the image is processed
    /// or displayed by the consuming API. The default is set to 'auto', which
    /// lets the API decide the optimal level of detail.
    /// </summary>
    /// <param name="Value">
    /// A value from the TImageDetail enumeration specifying the level of detail.
    /// </param>
    /// <returns>
    /// Returns an instance of TImageUrl.
    /// </returns>
    function Detail(const Value: TImageDetail): TImageUrl;
    /// <summary>
    /// Creates a new instance of TImageUrl with a specified URL and optional detail.
    /// </summary>
    /// <param name="PathLocation">
    /// The path to the image, either as a URL or a file path for base64 encoding.
    /// </param>
    /// <param name="Detail">
    /// Optional. The detail level for the image. The default is 'auto'.
    /// </param>
    /// <returns>
    /// Returns a newly instantiated object of TImageUrl.
    /// </returns>
    class function New(const PathLocation: string; const Detail: TImageDetail = TImageDetail.auto): TImageUrl;
  end;

  /// <summary>
  /// Represents an audio input parameter for a JSON object, allowing the configuration
  /// of audio data and format.
  /// </summary>
  /// <remarks>
  /// This class provides methods to set the base64-encoded audio data and its format
  /// for use in JSON requests. The format specifies how the audio data is encoded,
  /// such as 'mp3' or 'wav', which is crucial for correct processing by APIs consuming
  /// this data.
  /// </remarks>
  TInputAudio = class(TJSONParam)
  public
    /// <summary>
    /// Sets the base64-encoded data of the audio.
    /// </summary>
    /// <param name="Value">
    /// The base64-encoded audio data.
    /// </param>
    /// <returns>
    /// Returns an instance of TInputAudio.
    /// </returns>
    function Data(const Value: string): TInputAudio;
    /// <summary>
    /// Sets the format of the audio data.
    /// </summary>
    /// <param name="Value">
    /// The format of the audio, specified as a string.
    /// </param>
    /// <returns>
    /// Returns an instance of TInputAudio.
    /// </returns>
    function Format(const Value: string): TInputAudio; overload;
    /// <summary>
    /// Sets the format of the audio data using a predefined audio format type.
    /// </summary>
    /// <param name="Value">
    /// The audio format type.
    /// </param>
    /// <returns>
    /// Returns an instance of TInputAudio.
    /// </returns>
    function Format(const Value: TAudioFormat): TInputAudio; overload;
    /// <summary>
    /// Creates a new instance of TInputAudio with specified audio data path.
    /// </summary>
    /// <param name="PathLocation">
    /// The file path or URL from which to load and encode the audio data.
    /// </param>
    /// <returns>
    /// Returns a newly instantiated object of TInputAudio.
    /// </returns>
    class function New(const PathLocation: string): TInputAudio; overload;
  end;

  /// <summary>
  /// Manages content parameters for different types of inputs like text, images,
  /// and audio within a JSON structure.
  /// </summary>
  /// <remarks>
  /// This class serves as a utility to add various types of content to JSON requests.
  /// It supports handling text content, URLs for images, and base64-encoded audio data.
  /// Each method facilitates the inclusion of these content types into JSON objects
  /// with appropriate formatting and structure.
  /// </remarks>
  TContentParams = class(TJSONParam)
  private
    class function Extract(const Value: string; var Detail: TImageDetail): string;
  public
    /// <summary>
    /// Sets the type of the content, such as 'text', 'image_url', or 'input_audio'.
    /// </summary>
    /// <param name="Value">
    /// The type of the content.
    /// </param>
    /// <returns>
    /// Returns an instance of TContentParams.
    /// </returns>
    function &Type(const Value: string): TContentParams;
    /// <summary>
    /// Sets the text content.
    /// </summary>
    /// <param name="Value">
    /// The text content.
    /// </param>
    /// <returns>
    /// Returns an instance of TContentParams.
    /// </returns>
    function Text(const Value: string): TContentParams;
    /// <summary>
    /// Configures the URL for an image.
    /// </summary>
    /// <param name="Value">
    /// An instance of TImageUrl containing the image URL and detail settings.
    /// </param>
    /// <returns>
    /// Returns an instance of TContentParams.
    /// </returns>
    function ImageUrl(const Value: TImageUrl): TContentParams;
    /// <summary>
    /// Configures the audio input with its base64-encoded data and format.
    /// </summary>
    /// <param name="Value">
    /// An instance of TInputAudio containing the audio data and format.
    /// </param>
    /// <returns>
    /// Returns an instance of TContentParams.
    /// </returns>
    function InputAudio(const Value: TInputAudio): TContentParams;
    /// <summary>
    /// Adds a file's content to the parameters, automatically determining the type
    /// based on the file's MIME type and handling it accordingly.
    /// </summary>
    /// <param name="FileLocation">
    /// The location of the file to be added.
    /// </param>
    /// <returns>
    /// Returns an instance of TContentParams.
    /// </returns>
    class function AddFile(const FileLocation: string): TContentParams;
  end;

  /// <summary>
  /// Manages function parameters for API requests, allowing the setting of a function's
  /// name and its JSON-formatted arguments.
  /// </summary>
  /// <remarks>
  /// This class facilitates the construction of parameter objects for functions within
  /// JSON requests. It supports specifying the function name and its arguments in a
  /// structured format, ensuring that the function can be called correctly with the
  /// provided parameters.
  /// </remarks>
  TFunctionParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the name of the function.
    /// </summary>
    /// <param name="Value">
    /// The name of the function.
    /// </param>
    /// <returns>
    /// Returns an instance of TFunctionParams.
    /// </returns>
    function Name(const Value: string): TFunctionParams;
    /// <summary>
    /// Sets the arguments for the function in a JSON-formatted string.
    /// </summary>
    /// <param name="Value">
    /// The JSON-formatted arguments string.
    /// </param>
    /// <returns>
    /// Returns an instance of TFunctionParams.
    /// </returns>
    function Arguments(const Value: string): TFunctionParams;
  end;

  /// <summary>
  /// Manages the parameters for tool calls within a JSON structure, facilitating the integration
  /// of tool functionality such as functions or specific actions within an API request.
  /// </summary>
  /// <remarks>
  /// This class allows for specifying the ID, type, and function details for tools that are to be
  /// called within an API request. It ensures that tool interactions are well-defined and correctly
  /// structured to perform expected operations.
  /// </remarks>
  TToolCallsParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the unique identifier for the tool call.
    /// </summary>
    /// <param name="Value">
    /// The identifier for the tool call.
    /// </param>
    /// <returns>
    /// Returns an instance of TToolCallsParams.
    /// </returns>
    function Id(const Value: string): TToolCallsParams;
    /// <summary>
    /// Sets the type of the tool, such as a function or other executable action.
    /// </summary>
    /// <param name="Value">
    /// The type of the tool.
    /// </param>
    /// <returns>
    /// Returns an instance of TToolCallsParams.
    /// </returns>
    function &Type(const Value: string): TToolCallsParams; overload;
    /// <summary>
    /// Sets the type of the tool, such as a function or other executable action.
    /// </summary>
    /// <param name="Value">
    /// The type of the tool.
    /// </param>
    /// <returns>
    /// Returns an instance of TToolCallsParams.
    /// </returns>
    function &Type(const Value: TToolCalls): TToolCallsParams; overload;
    /// <summary>
    /// Configures the function details for a tool call, specifying the function name
    /// and its arguments.
    /// </summary>
    /// <param name="Name">
    /// The name of the function to be called.
    /// </param>
    /// <param name="Arguments">
    /// The JSON-formatted arguments for the function.
    /// </param>
    /// <returns>
    /// Returns an instance of TToolCallsParams.
    /// </returns>
    function &Function(const Name: string; const Arguments: string): TToolCallsParams;
    /// <summary>
    /// Creates a new instance of TToolCallsParams with specified tool call details.
    /// </summary>
    /// <param name="Id">
    /// The unique identifier for the tool call.
    /// </param>
    /// <param name="Name">
    /// The name of the function to call.
    /// </param>
    /// <param name="Arguments">
    /// The JSON-formatted arguments for the function.
    /// </param>
    /// <returns>
    /// Returns a newly instantiated object of TToolCallsParams.
    /// </returns>
    class function New(const Id: string; const Name: string; const Arguments: string): TToolCallsParams;
  end;

  /// <summary>
  /// Manages the content parameters for assistant messages, facilitating the integration
  /// of text or refusal content within a JSON structure for virtual assistants.
  /// </summary>
  /// <remarks>
  /// This class provides methods to set text content or a refusal message in responses
  /// generated by an assistant. It allows for precise control over the content delivered
  /// by the assistant, ensuring that responses are appropriate and well-structured.
  /// </remarks>
  TAssistantContentParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the type of content, such as text or a refusal message.
    /// </summary>
    /// <param name="Value">
    /// The type of the content.
    /// </param>
    /// <returns>
    /// Returns an instance of TAssistantContentParams.
    /// </returns>
    function &Type(const Value: string): TAssistantContentParams;
    /// <summary>
    /// Sets the text content for the assistant message.
    /// </summary>
    /// <param name="Value">
    /// The text content.
    /// </param>
    /// <returns>
    /// Returns an instance of TAssistantContentParams.
    /// </returns>
    function Text(const Value: string): TAssistantContentParams;
    /// <summary>
    /// Sets a refusal message for the assistant to use if it cannot comply with a request.
    /// </summary>
    /// <param name="Value">
    /// The refusal message.
    /// </param>
    /// <returns>
    /// Returns an instance of TAssistantContentParams.
    /// </returns>
    function Refusal(const Value: string): TAssistantContentParams;
    /// <summary>
    /// Creates an instance of TAssistantContentParams with text content specified.
    /// </summary>
    /// <param name="AType">
    /// The type of the content, typically 'text'.
    /// </param>
    /// <param name="Value">
    /// The text content.
    /// </param>
    /// <returns>
    /// Returns a newly instantiated object of TAssistantContentParams with text content.
    /// </returns>
    class function AddText(const AType: string; const Value: string): TAssistantContentParams;
    /// <summary>
    /// Creates an instance of TAssistantContentParams with a refusal message specified.
    /// </summary>
    /// <param name="AType">
    /// The type of the content, typically 'refusal'.
    /// </param>
    /// <param name="Value">
    /// The refusal message.
    /// </param>
    /// <returns>
    /// Returns a newly instantiated object of TAssistantContentParams with a refusal message.
    /// </returns>
    class function AddRefusal(const AType: string; const Value: string): TAssistantContentParams;
  end;

  /// <summary>
  /// Represents a message payload within a JSON-based messaging API, facilitating
  /// the structuring of communication between different roles such as user, assistant,
  /// and system.
  /// </summary>
  /// <remarks>
  /// This class provides a flexible framework for constructing message payloads with
  /// various content types and metadata, supporting diverse interactions within a
  /// chat or command-based environment.
  /// </remarks>
  TMessagePayload = class(TJSONParam)
  public
    /// <summary>
    /// Assigns a role to the message author, which can be 'user', 'assistant', 'system',
    /// or 'tool' to reflect the message's origin within the interaction context.
    /// </summary>
    /// <param name="Value">
    /// A string representation of the role.
    /// </param>
    /// <returns>
    /// Returns an instance of TMessagePayload configured with the specified role.
    /// </returns>
    function Role(const Value: TRole): TMessagePayload; overload;
    /// <summary>
    /// Assigns a role to the message author, which can be 'user', 'assistant', 'system',
    /// or 'tool' to reflect the message's origin within the interaction context.
    /// </summary>
    /// <param name="Value">
    /// A string representation of the role.
    /// </param>
    /// <returns>
    /// Returns an instance of TMessagePayload configured with the specified role.
    /// </returns>
    function Role(const Value: string): TMessagePayload; overload;
    /// <summary>
    /// Adds content to the message payload, which can be text, an array of content parts,
    /// or structured JSON data, depending on the message's intended purpose.
    /// </summary>
    /// <param name="Value">
    /// The content to add, specified as a string or JSON structure.
    /// </param>
    /// <returns>
    /// Returns an updated instance of TMessagePayload with the new content added.
    /// </returns>
    function Content(const Value: string): TMessagePayload; overload;
    /// <summary>
    /// Adds content to the message payload, which can be text, an array of content parts,
    /// or structured JSON data, depending on the message's intended purpose.
    /// </summary>
    /// <param name="Value">
    /// The content to add, specified as a string or JSON structure.
    /// </param>
    /// <returns>
    /// Returns an updated instance of TMessagePayload with the new content added.
    /// </returns>
    function Content(const Value: TJSONArray): TMessagePayload; overload;
    /// <summary>
    /// Adds content to the message payload, which can be text, an array of content parts,
    /// or structured JSON data, depending on the message's intended purpose.
    /// </summary>
    /// <param name="Value">
    /// The content to add, specified as a string or JSON structure.
    /// </param>
    /// <returns>
    /// Returns an updated instance of TMessagePayload with the new content added.
    /// </returns>
    function Content(const Value: TArray<TAssistantContentParams>): TMessagePayload; overload;
    /// <summary>
    /// Adds content to the message payload, which can be text, an array of content parts,
    /// or structured JSON data, depending on the message's intended purpose.
    /// </summary>
    /// <param name="Value">
    /// The content to add, specified as a string or JSON structure.
    /// </param>
    /// <returns>
    /// Returns an updated instance of TMessagePayload with the new content added.
    /// </returns>
    function Content(const Value: TJSONObject): TMessagePayload; overload;
    /// <summary>
    /// Specifies the name of the participant, which can be used to personalize responses
    /// or distinguish between participants in a multi-user environment.
    /// </summary>
    /// <param name="Value">
    /// The name of the participant.
    /// </param>
    /// <returns>
    /// Returns an updated instance of TMessagePayload with the participant's name set.
    /// </returns>
    function Name(const Value: string): TMessagePayload;
    /// <summary>
    /// Adds a refusal reason to the message, used primarily by the assistant to
    /// indicate why it cannot comply with a user's request.
    /// </summary>
    /// <param name="Value">
    /// The text specifying the refusal reason.
    /// </param>
    /// <returns>
    /// Returns an updated instance of TMessagePayload including the refusal reason.
    /// </returns>
    function Refusal(const Value: string): TMessagePayload;
    /// <summary>
    /// Attaches audio data to the message payload, primarily for responses that
    /// involve spoken content or commands.
    /// </summary>
    /// <param name="Value">
    /// The identifier for the audio data.
    /// </param>
    /// <returns>
    /// Returns an updated instance of TMessagePayload with the audio data attached.
    /// </returns>
    function Audio(const Value: string): TMessagePayload;
    /// <summary>
    /// Adds tool calls to the message payload, linking it to specific tool functions
    /// that the message may trigger or be associated with.
    /// </summary>
    /// <param name="Value">
    /// An array of TToolCallsParams representing the tool calls to be added to the message.
    /// </param>
    /// <returns>
    /// Returns an updated instance of TMessagePayload with the tool calls included.
    /// </returns>
    function ToolCalls(const Value: TArray<TToolCallsParams>): TMessagePayload;
    /// <summary>
    /// Sets the tool call identifier for the message payload, linking it to a specific
    /// tool interaction or process.
    /// </summary>
    /// <param name="Value">
    /// The string identifier of the tool call to associate with this message.
    /// </param>
    /// <returns>
    /// Returns an updated instance of TMessagePayload with the tool call ID set.
    /// </returns>
    function ToolCallId(const Value: string): TMessagePayload;
    /// <summary>
    /// Constructs a new message payload for a specific role with specified content.
    /// </summary>
    /// <param name="Role">
    /// The role of the message's author.
    /// </param>
    /// <param name="Content">
    /// The content of the message.
    /// </param>
    /// <param name="Name">
    /// Optional. The name of the participant.
    /// </param>
    /// <returns>
    /// Returns a newly created TMessagePayload with the defined role and content.
    /// </returns>
    class function New(const Role: TRole; const Content: string; const Name: string = ''):TMessagePayload; overload;
    /// <summary>
    /// Factory method to create a developer role message payload.
    /// </summary>
    /// <param name="Content">
    /// The content of the developer message.
    /// </param>
    /// <param name="Name">
    /// Optional. The name of the developer.
    /// </param>
    /// <returns>
    /// Returns a TMessagePayload instance representing a developer message.
    /// </returns>
    class function Developer(const Content: string; const Name: string = ''):TMessagePayload;
    /// <summary>
    /// Factory method to create a system role message payload.
    /// </summary>
    /// <param name="Content">
    /// The content of the system message.
    /// </param>
    /// <param name="Name">
    /// Optional. The name of the system or module sending the message.
    /// </param>
    /// <returns>
    /// Returns a TMessagePayload instance representing a system message.
    /// </returns>
    class function System(const Content: string; const Name: string = ''):TMessagePayload;
    /// <summary>
    /// Factory method to create a user role message payload.
    /// </summary>
    /// <param name="Content">
    /// The content of the user message.
    /// </param>
    /// <param name="Name">
    /// Optional. The name of the user.
    /// </param>
    /// <returns>
    /// Returns a TMessagePayload instance representing a user message.
    /// </returns>
    class function User(const Content: string; const Name: string = ''):TMessagePayload; overload;
    /// <summary>
    /// Factory method to create a user role message payload with multiple document references.
    /// </summary>
    /// <param name="Content">
    /// The main content of the user message.
    /// </param>
    /// <param name="Docs">
    /// An array of document paths to include.
    /// </param>
    /// <param name="Name">
    /// Optional. The name of the user.
    /// </param>
    /// <returns>
    /// Returns a TMessagePayload instance representing a user message with additional documents.
    /// </returns>
    class function User(const Content: string; const Docs: TArray<string>; const Name: string = ''):TMessagePayload; overload;
    /// <summary>
    /// Factory method to create a user role message payload with an array of document references.
    /// </summary>
    /// <param name="Docs">
    /// An array of document paths to include as part of the message content.
    /// </param>
    /// <param name="Name">
    /// Optional. The name of the user.
    /// </param>
    /// <returns>
    /// Returns a TMessagePayload instance representing a user message including multiple documents.
    /// </returns>
    class function User(const Docs: TArray<string>; const Name: string = ''):TMessagePayload; overload;
    /// <summary>
    /// Constructs an assistant message payload by executing a passed delegate that configures the payload.
    /// </summary>
    /// <param name="ParamProc">
    /// A delegate to configure the payload.
    /// </param>
    /// <returns>
    /// Returns a TMessagePayload instance configured by the delegate.
    /// </returns>
    class function Assistant(const ParamProc: TProcRef<TMessagePayload>): TMessagePayload; overload;
    /// <summary>
    /// Constructs an assistant message payload from another message payload instance.
    /// </summary>
    /// <param name="Value">
    /// An existing message payload instance.
    /// </param>
    /// <returns>
    /// Returns the passed TMessagePayload instance.
    /// </returns>
    class function Assistant(const Value: TMessagePayload): TMessagePayload; overload;
    /// <summary>
    /// Constructs an assistant message payload from a string.
    /// </summary>
    /// <param name="Value">
    /// A string value
    /// </param>
    /// <returns>
    /// Returns the passed TMessagePayload instance.
    /// </returns>
    class function Assistant(const Value: string): TMessagePayload; overload;
    /// <summary>
    /// Constructs a tool message payload to associate it with a specific tool call ID.
    /// </summary>
    /// <param name="Content">
    /// The content of the tool message.
    /// </param>
    /// <param name="ToolCallId">
    /// The identifier of the tool call associated with this message.
    /// </param>
    /// <returns>
    /// Returns a TMessagePayload instance configured for a specific tool.
    /// </returns>
    class function Tool(const Content: string; const ToolCallId: string): TMessagePayload;
    /// <summary>
    /// Constructs an assistant message payload whitn an audio id.
    /// </summary>
    /// <param name="Value">
    /// A string value
    /// </param>
    /// <returns>
    /// Returns the passed TMessagePayload instance.
    /// </returns>
    class function AssistantAudioId(const Value: string): TMessagePayload; overload;
  end;

  /// <summary>
  /// Manages the configuration of predicted content parts in JSON parameters, useful for
  /// specifying predefined outputs to optimize response generation.
  /// </summary>
  /// <remarks>
  /// This class enables the detailed specification of static or predictable content
  /// that can be used to facilitate more efficient processing when parts of the
  /// response are known in advance. This is especially beneficial in scenarios
  /// where response times are critical and part of the output is predetermined.
  /// </remarks>
  TPredictionPartParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the type of the prediction part, which defines the nature of the content
    /// being predicted.
    /// </summary>
    /// <param name="Value">
    /// The type as a string, typically identifying the content format or structure.
    /// </param>
    /// <returns>
    /// Returns an instance of TPredictionPartParams.
    /// </returns>
    function &Type(const Value: string): TPredictionPartParams;
    /// <summary>
    /// Sets the text of the predicted content part. This is used to define specific
    /// content that should be matched or anticipated by the processing system.
    /// </summary>
    /// <param name="Value">
    /// The text content to be predicted.
    /// </param>
    /// <returns>
    /// Returns an instance of TPredictionPartParams.
    /// </returns>
    function Text(const Value: string): TPredictionPartParams;
    /// <summary>
    /// Creates a new instance of TPredictionPartParams with specified type and text,
    /// facilitating the inclusion of predicted content in a structured manner.
    /// </summary>
    /// <param name="AType">
    /// The type of the prediction part, detailing the format or expected structure.
    /// </param>
    /// <param name="Text">
    /// The specific text content that is predicted, enabling pre-emptive matching.
    /// </param>
    /// <returns>
    /// Returns a newly instantiated object of TPredictionPartParams.
    /// </returns>
    class function New(const AType: string; const Text: string): TPredictionPartParams;
  end;

  /// <summary>
  /// Manages the configuration of prediction parameters for JSON requests, specifically
  /// designed to optimize model response generation by including expected content.
  /// </summary>
  /// <remarks>
  /// This class facilitates the integration of predictable or static content within
  /// JSON structured requests to optimize processing efficiencies and response accuracies
  /// in scenarios where certain outputs are known beforehand.
  /// </remarks>
  TPredictionParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the type of the prediction content, typically specifying the overarching
    /// structure or format expected in the response.
    /// </summary>
    /// <param name="Value">
    /// A string identifying the type of prediction, such as 'text' or 'structured'.
    /// </param>
    /// <returns>
    /// Returns an instance of TPredictionParams.
    /// </returns>
    function &Type(const Value: string): TPredictionParams;
    /// <summary>
    /// Configures the content for prediction, which could include specific text or
    /// structured data expected in the response.
    /// </summary>
    /// <param name="Value">
    /// The content expected, which could be text or a JSON object.
    /// </param>
    /// <returns>
    /// Returns an instance of TPredictionParams.
    /// </returns>
    function Content(const Value: string): TPredictionParams; overload;
    /// <summary>
    /// Configures the content for prediction, which could include specific text or
    /// structured data expected in the response.
    /// </summary>
    /// <param name="Value">
    /// The content expected, which could be text or a JSON object.
    /// </param>
    /// <returns>
    /// Returns an instance of TPredictionParams.
    /// </returns>
    function Content(const Value: TArray<TPredictionPartParams>): TPredictionParams; overload;
    /// <summary>
    /// Creates a new instance of TPredictionParams with predefined types and content,
    /// enabling optimized response generation.
    /// </summary>
    /// <param name="Value">
    /// An array of TPredictionPartParams detailing the predictable content.
    /// </param>
    /// <returns>
    /// Returns a newly instantiated object of TPredictionParams.
    /// </returns>
    class function New(const Value: string): TPredictionParams; overload;
    /// <summary>
    /// Creates a new instance of TPredictionParams with predefined types and content,
    /// enabling optimized response generation.
    /// </summary>
    /// <param name="Value">
    /// An array of TPredictionPartParams detailing the predictable content.
    /// </param>
    /// <returns>
    /// Returns a newly instantiated object of TPredictionParams.
    /// </returns>
    class function New(const Value: TArray<TPredictionPartParams>): TPredictionParams; overload;
  end;

  /// <summary>
  /// Configures audio parameters within JSON requests to manage voice and format
  /// specifications for audio generation.
  /// </summary>
  /// <remarks>
  /// This class is designed to detail the audio output settings, such as voice type
  /// and audio format, to tailor the audio responses generated by models or APIs.
  /// </remarks>
  TAudioParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the voice to be used for the audio output, specifying the tone and style
    /// of the generated audio.
    /// </summary>
    /// <param name="Value">
    /// A TChatVoice enumeration value representing the selected voice.
    /// </param>
    /// <returns>
    /// Returns an instance of TAudioParams.
    /// </returns>
    function Voice(const Value: TChatVoice): TAudioParams;
    /// <summary>
    /// Sets the audio format for the output, such as MP3 or WAV, determining how
    /// the audio is encoded.
    /// </summary>
    /// <param name="Value">
    /// A TAudioFormat value indicating the format of the audio output.
    /// </param>
    /// <returns>
    /// Returns an instance of TAudioParams.
    /// </returns>
    function Format(const Value: TAudioFormat): TAudioParams;
  end;

  /// <summary>
  /// Provides a means to specify a particular function that should be called by
  /// the tool choice mechanism within JSON requests.
  /// </summary>
  /// <remarks>
  /// This class is crucial for specifying which specific function should be executed,
  /// particularly in scenarios involving dynamic or automated decision-making processes
  /// where a specific operational function is needed.
  /// </remarks>
  TToolChoiceFunctionParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the name of the function that the tool choice should execute, linking
    /// to predefined functions within the system.
    /// </summary>
    /// <param name="Value">
    /// The name of the function to be executed.
    /// </param>
    /// <returns>
    /// Returns an instance of TToolChoiceFunctionParams.
    /// </returns>
    function Name(const Value: string): TToolChoiceFunctionParams;
  end;

  /// <summary>
  /// Handles the configuration for tool choice parameters, enabling specific function
  /// calls within JSON structured requests.
  /// </summary>
  /// <remarks>
  /// This class is designed to specify which tools or functions the system should use
  /// during the execution of an API call. It facilitates the dynamic selection of
  /// tools based on the requirements of the application, ensuring targeted and
  /// efficient processing.
  /// </remarks>
  TToolChoiceParams = class(TJSONParam)
  public
    /// <summary>
    /// Specifies the type of tool to be used, typically defining whether a function
    /// or other tool type is to be called.
    /// </summary>
    /// <param name="Value">
    /// The type as a string, such as 'function' to indicate a function call.
    /// </param>
    /// <returns>
    /// Returns an instance of TToolChoiceParams.
    /// </returns>
    function &Type(const Value: string): TToolChoiceParams;
    /// <summary>
    /// Configures a specific function to be called as part of the tool choice.
    /// This method allows for the specification of the function name to be executed.
    /// </summary>
    /// <param name="Name">
    /// The name of the function to be called.
    /// </param>
    /// <returns>
    /// Returns an instance of TToolChoiceParams configured to call the specified function.
    /// </returns>
    function &Function(const Name: string): TToolChoiceParams;
    /// <summary>
    /// Creates a new instance of TToolChoiceParams configured to call a specified function.
    /// This constructor facilitates easy setup of tool choice parameters for API requests.
    /// </summary>
    /// <param name="Name">
    /// The name of the function to be called, defining the specific tool or function.
    /// </param>
    /// <returns>
    /// Returns a newly instantiated object of TToolChoiceParams.
    /// </returns>
    class function New(const Name: string): TToolChoiceParams;
  end;

  /// <summary>
  /// Approximate location parameters for the search.
  /// </summary>
  TUserLocationApproximate = class(TJSONParam)
  public
    /// <summary>
    /// Free text input for the city of the user, e.g. San Francisco.
    /// </summary>
    /// <param name="Value">
    /// The name of the city.
    /// </param>
    /// <returns>
    /// Returns an instance of TUserLocationApproximate.
    /// </returns>
    function City(const Value: string): TUserLocationApproximate;
    /// <summary>
    /// The two-letter ISO country code of the user, e.g. US.
    /// </summary>
    /// <param name="Value">
    /// The name of the country e.g. FR (for France) or JP (for Japan)
    /// </param>
    /// <returns>
    /// Returns an instance of TUserLocationApproximate.
    /// </returns>
    /// <remarks>
    /// Refer to https://en.wikipedia.org/wiki/ISO_3166-1
    /// </remarks>
    function Country(const Value: string): TUserLocationApproximate;
    /// <summary>
    /// Free text input for the region of the user, e.g. California.
    /// </summary>
    /// <param name="Value">
    /// The name of the region.
    /// </param>
    /// <returns>
    /// Returns an instance of TUserLocationApproximate.
    /// </returns>
    function Region(const Value: string): TUserLocationApproximate;
    /// <summary>
    /// The IANA timezone of the user, e.g. America/Los_Angeles.
    /// </summary>
    /// <param name="Value">
    /// The timezone e.g. Europe/Paris or Asia/Tokyo
    /// </param>
    /// <returns>
    /// Returns an instance of TUserLocationApproximate.
    /// </returns>
    /// <remarks>
    /// Refer to https://timeapi.io/documentation/iana-timezones
    /// </remarks>
    function Timezone(const Value: string): TUserLocationApproximate;
  end;

  /// <summary>
  /// Approximate location parameters for the search.
  /// </summary>
  TUserLocation = class(TJSONParam)
  public
    /// <summary>
    /// The type of location approximation. Always approximate.
    /// </summary>
    /// <param name="Value">
    /// Allways : approximate
    /// </param>
    /// <returns>
    /// Returns an instance of TUserLocation.
    /// </returns>
    function &Type(const Value: string = 'approximate'): TUserLocation;
    /// <summary>
    /// Approximate location parameters for the search.
    /// </summary>
    /// <param name="Value">
    /// e.g. TUserLocationApproximate.Create.Country('fr').Timezone('+01:00')
    /// </param>
    /// <returns>
    /// Returns an instance of TUserLocation.
    /// </returns>
    function Approximate(const Value: TUserLocationApproximate): TUserLocation; overload;
    /// <summary>
    /// Approximate location parameters for the search.
    /// </summary>
    /// <param name="Value">
    /// e.g. TUserLocationApproximate.Create.Country('fr').Detach
    /// </param>
    /// <returns>
    /// Returns an instance of TUserLocation.
    /// </returns>
    function Approximate(const Value: TJSONObject): TUserLocation; overload;
    /// <summary>
    /// Creates a new instance of TUserLocation
    /// </summary>
    /// <param name="Value">
    /// e.g. TUserLocationApproximate.Create.Country('fr').Timezone('+01:00')
    /// </param>
    /// <returns>
    /// Returns an instance of TUserLocation.
    /// </returns>
    class function New(const Value: TUserLocationApproximate): TUserLocation; overload;
    /// <summary>
    /// Creates a new instance of TUserLocation
    /// </summary>
    /// <param name="Value">
    /// e.g. TUserLocationApproximate.Create.Country('fr').Detach
    /// </param>
    /// <returns>
    /// Returns an instance of TUserLocation.
    /// </returns>
    class function New(const Value: TJSONObject): TUserLocation; overload;
  end;

  /// <summary>
  /// Manages parameters for chat request configurations in JSON format, supporting a wide
  /// range of attributes to customize the chat completion process.
  /// </summary>
  /// <remarks>
  /// This class facilitates the comprehensive configuration of chat-related parameters,
  /// allowing the control over model selection, token limitations, response modalities,
  /// and various other settings to optimize interaction dynamics and computational efficiency.
  /// </remarks>
  TChatParams = class(TJSONParam)
  public
    /// <summary>
    /// Adds messages to the chat configuration, accepting an array of message payloads.
    /// </summary>
    /// <param name="Value">
    /// An array of TMessagePayload instances representing the chat messages.
    /// </param>
    /// <returns>
    /// Returns an instance of TChatParams with the messages added.
    /// </returns>
    function Messages(const Value: TArray<TMessagePayload>): TChatParams; overload;
    /// <summary>
    /// Adds messages to the chat configuration, accepting an array of message payloads.
    /// </summary>
    /// <param name="Value">
    /// An array of TMessagePayload instances representing the chat messages.
    /// </param>
    /// <returns>
    /// Returns an instance of TChatParams with the messages added.
    /// </returns>
    function Messages(const Value: TJSONObject): TChatParams; overload;
    /// <summary>
    /// Adds messages to the chat configuration, accepting an array of message payloads.
    /// </summary>
    /// <param name="Value">
    /// An array of TMessagePayload instances representing the chat messages.
    /// </param>
    /// <returns>
    /// Returns an instance of TChatParams with the messages added.
    /// </returns>
    function Messages(const Value: TJSONArray): TChatParams; overload;
    /// <summary>
    /// Specifies the model to use for generating chat completions.
    /// </summary>
    /// <param name="Value">
    /// A string identifier for the model.
    /// </param>
    /// <returns>
    /// Returns an instance of TChatParams with the model set.
    /// </returns>
    function Model(const Value: string): TChatParams;
    /// <summary>
    /// Enables or disables the storing of output from chat completion requests.
    /// </summary>
    /// <param name="Value">
    /// Boolean value indicating whether to store the output.
    /// </param>
    /// <returns>
    /// Returns an instance of TChatParams with the storage option configured.
    /// </returns>
    function Store(const Value: Boolean = True): TChatParams;
    /// <summary>
    /// Specifies the effort level for reasoning when generating responses.
    /// </summary>
    /// <param name="Value">
    /// A string representing the desired effort level ('low', 'medium', or 'high').
    /// </param>
    /// <returns>
    /// Returns an instance of TChatParams with the reasoning effort set.
    /// </returns>
    function ReasoningEffort(const Value: TReasoningEffort): TChatParams; overload;
    /// <summary>
    /// Specifies the effort level for reasoning when generating responses.
    /// </summary>
    /// <param name="Value">
    /// A string representing the desired effort level ('low', 'medium', or 'high').
    /// </param>
    /// <returns>
    /// Returns an instance of TChatParams with the reasoning effort set.
    /// </returns>
    function ReasoningEffort(const Value: string): TChatParams; overload;
    /// <summary>
    /// Sets user-defined metadata for filtering or identifying completions in the dashboard.
    /// </summary>
    /// <param name="Value">
    /// A JSON object containing key-value pairs of metadata.
    /// </param>
    /// <returns>
    /// Returns an instance of TChatParams with metadata configured.
    /// </returns>
    function Metadata(const Value: TJSONObject): TChatParams;
    /// <summary>
    /// Configures how often and in what circumstances the model will refer to its previous outputs.
    /// </summary>
    /// <param name="Value">
    /// The frequency penalty as a double.
    /// </param>
    /// <returns>
    /// Returns an instance of TChatParams with the frequency penalty set.
    /// </returns>
    function FrequencyPenalty(const Value: Double): TChatParams;
    /// <summary>
    /// Specifies the likelihood of specified tokens appearing in the completion.
    /// </summary>
    /// <param name="Value">
    /// A JSON object mapping token IDs to bias values.
    /// </param>
    /// <returns>
    /// Returns an instance of TChatParams with the logit bias configured.
    /// </returns>
    function LogitBias(const Value: TJSONObject): TChatParams;
    /// <summary>
    /// Enables the return of log probabilities for the generated tokens.
    /// </summary>
    /// <param name="Value">
    /// Set to true to enable log probabilities.
    /// </param>
    /// <returns>
    /// An instance of TChatParams with log probability setting applied.
    /// </returns>
    function Logprobs(const Value: Boolean): TChatParams;
    /// <summary>
    /// Specifies the number of the most likely tokens to return at each token position.
    /// </summary>
    /// <param name="Value">
    /// The number of top log probabilities to return.
    /// </param>
    /// <returns>
    /// An instance of TChatParams with top log probabilities configured.
    /// </returns>
    function TopLogprobs(const Value: Integer): TChatParams;
    /// <summary>
    /// Sets the maximum number of tokens that can be generated for a completion.
    /// </summary>
    /// <param name="Value">
    /// The maximum number of tokens allowed.
    /// </param>
    /// <returns>
    /// Returns an instance of TChatParams with the maximum token limit set.
    /// </returns>
    function MaxCompletionTokens(const Value: Integer): TChatParams;
    /// <summary>
    /// Sets how many chat completion choices to generate for each input message.
    /// </summary>
    /// <param name="Value">
    /// The number of completions to generate.
    /// </param>
    /// <returns>
    /// An instance of TChatParams configured with the specified number of completions.
    /// </returns>
    function N(const Value: Integer): TChatParams;
    /// <summary>
    /// Specifies the modalities (text, audio) that the model should generate responses for.
    /// </summary>
    /// <param name="Value">
    /// An array of strings representing the desired output modalities.
    /// </param>
    /// <returns>
    /// Returns an instance of TChatParams with the modalities set.
    /// </returns>
    function Modalities(const Value: TArray<string>): TChatParams; overload;
    /// <summary>
    /// Specifies the modalities (text, audio) that the model should generate responses for.
    /// </summary>
    /// <param name="Value">
    /// An array of strings representing the desired output modalities.
    /// </param>
    /// <returns>
    /// Returns an instance of TChatParams with the modalities set.
    /// </returns>
    function Modalities(const Value: TArray<TModalities>): TChatParams; overload;
    /// <summary>
    /// Configures predictions for the chat completion, aiming to optimize response generation.
    /// </summary>
    /// <param name="Value">
    /// Predicted content or a configuration for handling predicted outputs.
    /// </param>
    /// <returns>
    /// An instance of TChatParams with prediction settings applied.
    /// </returns>
    function Prediction(const Value: string): TChatParams; overload;
     /// <summary>
    /// Configures predictions for the chat completion, aiming to optimize response generation.
    /// </summary>
    /// <param name="Value">
    /// Predicted content or a configuration for handling predicted outputs.
    /// </param>
    /// <returns>
    /// An instance of TChatParams with prediction settings applied.
    /// </returns>
    function Prediction(const Value: TArray<TPredictionPartParams>): TChatParams; overload;
    /// <summary>
    /// Specifies the audio parameters for responses, including voice type and format.
    /// </summary>
    /// <param name="Voice">
    /// The voice setting for the audio output.
    /// </param>
    /// <param name="Format">
    /// The audio format (e.g., mp3, wav).
    /// </param>
    /// <returns>
    /// An instance of TChatParams configured with specified audio settings.
    /// </returns>
    function Audio(const Voice: TChatVoice; const Format: TAudioFormat): TChatParams; overload;
    /// <summary>
    /// Specifies the audio parameters for responses, including voice type and format.
    /// </summary>
    /// <param name="Voice">
    /// The voice setting for the audio output.
    /// </param>
    /// <param name="Format">
    /// The audio format (e.g., mp3, wav).
    /// </param>
    /// <returns>
    /// An instance of TChatParams configured with specified audio settings.
    /// </returns>
    function Audio(const Voice, Format: string): TChatParams; overload;
    /// <summary>
    /// Sets a penalty on generating tokens that introduce new topics, encouraging focus on the current topics.
    /// </summary>
    /// <param name="Value">
    /// The penalty value, where higher values encourage more focus on existing topics.
    /// </param>
    /// <returns>
    /// An instance of TChatParams with the presence penalty configured.
    /// </returns>
    function PresencePenalty(const Value: Double): TChatParams;
    /// <summary>
    /// Specifies the format that the model must output, supporting structured and JSON outputs.
    /// </summary>
    /// <param name="Value">
    /// The format configuration for the model output.
    /// </param>
    /// <returns>
    /// An instance of TChatParams with response format settings applied.
    /// </returns>
    function ResponseFormat(const Value: TSchemaParams): TChatParams; overload;
    /// <summary>
    /// Specifies the format that the model must output, supporting structured and JSON outputs.
    /// </summary>
    /// <param name="Value">
    /// The format configuration for the model output.
    /// </param>
    /// <returns>
    /// An instance of TChatParams with response format settings applied.
    /// </returns>
    function ResponseFormat(const ParamProc: TProcRef<TSchemaParams>): TChatParams; overload;
    /// <summary>
    /// Specifies the format that the model must output, supporting structured and JSON outputs.
    /// </summary>
    /// <param name="Value">
    /// The format configuration for the model output.
    /// </param>
    /// <returns>
    /// An instance of TChatParams with response format settings applied.
    /// </returns>
    function ResponseFormat(const Value: TJSONObject): TChatParams; overload;
    /// <summary>
    /// Sets the seed for deterministic generation, ensuring repeatable results across sessions.
    /// </summary>
    /// <param name="Value">
    /// The seed as an integer.
    /// </param>
    /// <returns>
    /// Returns an instance of TChatParams with the seed set for deterministic responses.
    /// </returns>
    function Seed(const Value: Integer): TChatParams;
    /// <summary>
    /// Sets the service tier to use for processing the chat request, affecting latency and availability.
    /// </summary>
    /// <param name="Value">
    /// The service tier as a string ('auto' or 'default').
    /// </param>
    /// <returns>
    /// Returns an instance of TChatParams with the service tier configured.
    /// </returns>
    function ServiceTier(const Value: string): TChatParams;
    /// <summary>
    /// Determines when the API should stop generating further tokens.
    /// </summary>
    /// <param name="Value">
    /// A string or array of strings indicating stop sequences.
    /// </param>
    /// <returns>
    /// Returns an instance of TChatParams with the stop conditions set.
    /// </returns>
    function Stop(const Value: string): TChatParams; overload;
    /// <summary>
    /// Determines when the API should stop generating further tokens.
    /// </summary>
    /// <param name="Value">
    /// A string or array of strings indicating stop sequences.
    /// </param>
    /// <returns>
    /// Returns an instance of TChatParams with the stop conditions set.
    /// </returns>
    function Stop(const Value: TArray<string>): TChatParams; overload;
   /// <summary>
    /// Enables streaming of chat completions, allowing partial responses to be processed as they are generated.
    /// </summary>
    /// <param name="Value">
    /// A boolean indicating whether to enable streaming.
    /// </param>
    /// <returns>
    /// Returns an instance of TChatParams with streaming enabled.
    /// </returns>
    function Stream(const Value: Boolean = True): TChatParams;
    /// <summary>
    /// Configures options for streaming responses, such as inclusion of usage data.
    /// </summary>
    /// <param name="Value">
    /// A JSON object specifying streaming options.
    /// </param>
    /// <returns>
    /// Returns an instance of TChatParams with streaming options set.
    /// </returns>
    function StreamOptions(const Value: TJSONObject): TChatParams; overload;
    /// <summary>
    /// Configures options for streaming responses, such as inclusion of usage data.
    /// </summary>
    /// <param name="Value">
    /// A JSON object specifying streaming options.
    /// </param>
    /// <returns>
    /// Returns an instance of TChatParams with streaming options set.
    /// </returns>
    function StreamOptions(const IncludeUsage: Boolean): TChatParams; overload;
    /// <summary>
    /// Sets the temperature for generating responses, influencing the randomness and variety.
    /// </summary>
    /// <param name="Value">
    /// The temperature as a double.
    /// </param>
    /// <returns>
    /// Returns an instance of TChatParams with the temperature set.
    /// </returns>
    function Temperature(const Value: Double): TChatParams;
    /// <summary>
    /// Specifies the nucleus sampling threshold, determining how focused or broad the responses should be.
    /// </summary>
    /// <param name="Value">
    /// The top-p as a double, representing the probability mass threshold.
    /// </param>
    /// <returns>
    /// Returns an instance of TChatParams with the top-p configured.
    /// </returns>
    function TopP(const Value: Double): TChatParams;
    /// <summary>
    /// Configures which tools the model may call during the session.
    /// </summary>
    /// <param name="Value">
    /// An array of tools or functions the model can use.
    /// </param>
    /// <returns>
    /// An instance of TChatParams with tools configured.
    /// </returns>
    function Tools(const Value: TArray<TChatMessageTool>): TChatParams; overload;
    /// <summary>
    /// Configures which tools the model may call during the session.
    /// </summary>
    /// <param name="Value">
    /// An array of tools or functions the model can use.
    /// </param>
    /// <returns>
    /// An instance of TChatParams with tools configured.
    /// </returns>
    function Tools(const Value: TArray<IFunctionCore>): TChatParams; overload;
    /// <summary>
    /// Configures which tools the model may call during the session.
    /// </summary>
    /// <param name="Value">
    /// An array of tools or functions the model can use.
    /// </param>
    /// <returns>
    /// An instance of TChatParams with tools configured.
    /// </returns>
    function Tools(const Value: TJSONObject): TChatParams; overload;
    /// <summary>
    /// Sets the tool choice for the chat session, specifying how tools should be used.
    /// </summary>
    /// <param name="Value">
    /// The tool choice settings, including none, auto, or required.
    /// </param>
    /// <returns>
    /// An instance of TChatParams configured with tool choice settings.
    /// </returns>
    function ToolChoice(const Value: string): TChatParams; overload;
    /// <summary>
    /// Sets the tool choice for the chat session, specifying how tools should be used.
    /// </summary>
    /// <param name="Value">
    /// The tool choice settings, including none, auto, or required.
    /// </param>
    /// <returns>
    /// An instance of TChatParams configured with tool choice settings.
    /// </returns>
    function ToolChoice(const Value: TToolChoice): TChatParams; overload;
    /// <summary>
    /// Sets the tool choice for the chat session, specifying how tools should be used.
    /// </summary>
    /// <param name="Value">
    /// The tool choice settings, including none, auto, or required.
    /// </param>
    /// <returns>
    /// An instance of TChatParams configured with tool choice settings.
    /// </returns>
    function ToolChoice(const Value: TJSONObject): TChatParams; overload;
    /// <summary>
    /// Sets the tool choice for the chat session, specifying how tools should be used.
    /// </summary>
    /// <param name="Value">
    /// The tool choice settings, including none, auto, or required.
    /// </param>
    /// <returns>
    /// An instance of TChatParams configured with tool choice settings.
    /// </returns>
    function ToolChoice(const Value: TToolChoiceParams): TChatParams; overload;
    /// <summary>
    /// Enables or disables parallel tool calls during tool use.
    /// </summary>
    /// <param name="Value">
    /// True to enable parallel calls, false to disable.
    /// </param>
    /// <returns>
    /// An instance of TChatParams configured for parallel tool calling.
    /// </returns>
    function ParallelToolCalls(const Value: Boolean): TChatParams;
    /// <summary>
    /// Specifies a unique identifier for the end-user, helping monitor and prevent abuse.
    /// </summary>
    /// <param name="Value">
    /// The user identifier.
    /// </param>
    /// <returns>
    /// An instance of TChatParams configured with the user identifier.
    /// </returns>
    function User(const Value: string): TChatParams;
    /// <summary>
    /// Configures web search options for chat completion requests, allowing
    /// integration of contextual search results.
    /// </summary>
    /// <remarks>
    /// This method sets the search context size and user location settings to
    /// refine the results retrieved during a chat session. The options determine
    /// how much contextual information should be retrieved from the web and how
    /// the search should be influenced by the user's approximate location.
    /// </remarks>
    /// <param name="Value">
    /// The <c>TSearchWebOptions</c> instance specifying search-related parameters,
    /// such as the size of the search context.
    /// </param>
    /// <param name="UserLocation">
    /// Optional. A <c>TUserLocation</c> instance representing the approximate
    /// geographical location of the user. This information helps refine search results.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TChatParams</c> with the web search options configured.
    /// </returns>
    function WebSearchOptions(const Value: TSearchWebOptions; const UserLocation: TUserLocation = nil): TChatParams; overload;
    /// <summary>
    /// Configures web search options for chat completion requests, allowing
    /// integration of contextual search results while considering an approximate user location.
    /// </summary>
    /// <remarks>
    /// This method allows defining search-related parameters such as the size of the search context
    /// and refining the search results using an approximate geographical location.
    /// </remarks>
    /// <param name="Value">
    /// An instance of <c>TSearchWebOptions</c> that specifies search-related parameters,
    /// such as the context size for web search.
    /// </param>
    /// <param name="Approximation">
    /// Optional. An instance of <c>TUserLocationApproximate</c> that provides an approximate
    /// user location to refine search results.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TChatParams</c> with the web search options configured.
    /// </returns>
    function WebSearchOptions(const Value: TSearchWebOptions; const Approximation: TUserLocationApproximate = nil): TChatParams; overload;
    /// <summary>
    /// Configures web search options using a string representation of the search
    /// context size and an optional user location.
    /// </summary>
    /// <remarks>
    /// This method allows specifying the size of the search context as a string value.
    /// It also provides an optional parameter for user location to refine search results.
    /// </remarks>
    /// <param name="Value">
    /// A string representing the search context size, which determines how much
    /// information should be retrieved from the web during a chat completion request.
    /// </param>
    /// <param name="UserLocation">
    /// Optional. A <c>TUserLocation</c> instance representing the approximate
    /// geographical location of the user, helping to refine search results.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TChatParams</c> with the configured web search options.
    /// </returns>
    function WebSearchOptions(const Value: string; const UserLocation: TUserLocation): TChatParams; overload;
    /// <summary>
    /// Configures web search options using a string representation of the search
    /// context size while incorporating an approximate user location.
    /// </summary>
    /// <remarks>
    /// This method allows specifying the size of the search context as a string value.
    /// It also provides an optional parameter for the approximate user location
    /// to refine search results.
    /// </remarks>
    /// <param name="Value">
    /// A string representing the search context size, which determines how much
    /// information should be retrieved from the web during a chat completion request.
    /// </param>
    /// <param name="Approximation">
    /// Optional. An instance of <c>TUserLocationApproximate</c> that provides an
    /// approximate user location to enhance the relevance of search results.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TChatParams</c> with the configured web search options.
    /// </returns>
    function WebSearchOptions(const Value: string; const Approximation: TUserLocationApproximate): TChatParams; overload;
    /// <summary>
    /// Configures web search options using the user's approximate location.
    /// </summary>
    /// <remarks>
    /// This method allows integrating the user's geographical location into the
    /// chat completion request, refining search results based on the provided location.
    /// </remarks>
    /// <param name="UserLocation">
    /// A <c>TUserLocation</c> instance representing the approximate geographical
    /// location of the user.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TChatParams</c> with the user location-based
    /// web search options configured.
    /// </returns>
    function WebSearchOptions(const UserLocation: TUserLocation): TChatParams; overload;
    /// <summary>
    /// Configures web search options using only an approximate user location.
    /// </summary>
    /// <remarks>
    /// This method integrates the user's geographical location into the chat completion
    /// request, refining search results based on the provided location without explicitly
    /// specifying search parameters.
    /// </remarks>
    /// <param name="Approximation">
    /// An instance of <c>TUserLocationApproximate</c> that specifies the approximate
    /// geographical location of the user.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TChatParams</c> with the user location-based web search options configured.
    /// </returns>
    function WebSearchOptions(const Approximation: TUserLocationApproximate): TChatParams; overload;
    /// <summary>
    /// Configures web search options using a string representation of the search
    /// context size and an optional user location.
    /// </summary>
    /// <remarks>
    /// This method allows specifying the size of the search context as a string value.
    /// It also provides an optional parameter for user location to refine search results.
    /// </remarks>
    /// <param name="Value">
    /// A string representing the search context size, which determines how much
    /// information should be retrieved from the web during a chat completion request.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TChatParams</c> with the configured web search options.
    /// </returns>
    function WebSearchOptions(const Value: string): TChatParams; overload;
  end;

  /// <summary>
  /// Provides URL parameter helpers for retrieving chat messages by completion ID,
  /// supporting pagination and sort ordering.
  /// </summary>
  TUrlChatParams = class(TUrlParam)
  public
    /// <summary>
    /// Sets the cursor for pagination by specifying the ID of the last message
    /// returned in a previous request. Subsequent calls will retrieve messages
    /// appearing after this ID.
    /// </summary>
    /// <param name="Value">
    /// The identifier of the last message from the previous page.
    /// </param>
    /// <returns>
    /// A reference to the updated TUrlChatParams instance for method chaining.
    /// </returns>
    function After(const Value: string): TUrlChatParams;
    /// <summary>
    /// Specifies the maximum number of chat messages to retrieve in the response.
    /// </summary>
    /// <param name="Value">
    /// The limit on the number of messages to return.
    /// </param>
    /// <returns>
    /// A reference to the updated TUrlChatParams instance for method chaining.
    /// </returns>
    function Limit(const Value: Integer): TUrlChatParams;
    /// <summary>
    /// Determines the sort order for the returned messages based on their timestamp.
    /// </summary>
    /// <param name="Value">
    /// The sort direction: 'asc' for ascending or 'desc' for descending. Defaults to 'asc'.
    /// </param>
    /// <returns>
    /// A reference to the updated TUrlChatParams instance for method chaining.
    /// </returns>
    function Order(const Value: string): TUrlChatParams;
  end;

  /// <summary>
  /// Provides URL parameter helpers for listing chat completions,
  /// supporting pagination, metadata filtering, model filtering, and sort ordering.
  /// </summary>
  TUrlChatListParams = class(TUrlParam)
  public
    /// <summary>
    /// Sets the cursor for pagination by specifying the ID of the last chat completion
    /// returned in a previous request. Subsequent calls will retrieve completions
    /// occurring after this ID.
    /// </summary>
    /// <param name="Value">
    /// The identifier of the last chat completion from the previous page.
    /// </param>
    /// <returns>
    /// A reference to the updated TUrlChatListParams instance for method chaining.
    /// </returns>
    function After(const Value: string): TUrlChatListParams;
    /// <summary>
    /// Specifies the maximum number of chat completions to retrieve in the response.
    /// </summary>
    /// <param name="Value">
    /// The limit on the number of completions to return.
    /// </param>
    /// <returns>
    /// A reference to the updated TUrlChatListParams instance for method chaining.
    /// </returns>
    function Limit(const Value: Integer): TUrlChatListParams;
    /// <summary>
    /// Filters the list of chat completions by metadata key‑value pairs.
    /// </summary>
    /// <param name="Value">
    /// A JSON object where each pair represents a metadata key and its required value.
    /// Example: metadata['environment']='production'.
    /// </param>
    /// <returns>
    /// A reference to the updated TUrlChatListParams instance for method chaining.
    /// </returns>
    function Metadata(const Value: TJSONObject): TUrlChatListParams;
    /// <summary>
    /// Filters the list of chat completions by the model identifier used to generate them.
    /// </summary>
    /// <param name="Value">
    /// The model name or identifier (e.g., 'gpt-4', 'claude-v1').
    /// </param>
    /// <returns>
    /// A reference to the updated TUrlChatListParams instance for method chaining.
    /// </returns>
    function Model(const Value: string): TUrlChatListParams;
    /// <summary>
    /// Determines the sort order for the returned completions based on their timestamp.
    /// </summary>
    /// <param name="Value">
    /// The sort direction: 'asc' for ascending or 'desc' for descending. Defaults to 'asc'.
    /// </param>
    /// <returns>
    /// A reference to the updated TUrlChatListParams instance for method chaining.
    /// </returns>
    function Order(const Value: string): TUrlChatListParams;
  end;

  /// <summary>
  /// Represents the parameters for updating an existing chat completion.
  /// </summary>
  /// <remarks>
  /// Use this class to configure one or more metadata fields on a chat completion
  /// before sending an update request to the API.
  /// </remarks>
  TChatUpdateParams = class(TJSONParam)
  public
    /// <summary>
    /// Adds or replaces metadata for the chat completion update request.
    /// </summary>
    /// <param name="Value">
    /// A <c>TJSONObject</c> containing key-value pairs that describe the metadata
    /// to apply. Each pair represents a metadata field name and its new value.
    /// </param>
    /// <returns>
    /// Returns the current <c>TChatUpdateParams</c> instance to allow method chaining.
    /// </returns>
    function Metadata(const Value: TJSONObject): TChatUpdateParams;
  end;

  /// <summary>
  /// Represents a single token's top log probability details.
  /// </summary>
  TTopLogprobs = class
  private
    FToken: string;
    FLogprob: Double;
    FBytes: TArray<Int64>;
  public
    /// <summary>
    /// The token analyzed for log probability.
    /// </summary>
    property Token: string read FToken write FToken;
    /// <summary>
    /// The log probability of the token.
    /// </summary>
    property Logprob: Double read FLogprob write FLogprob;
    /// <summary>
    /// The UTF-8 byte representation of the token.
    /// </summary>
    property Bytes: TArray<Int64> read FBytes write FBytes;
  end;

  /// <summary>
  /// Details about the log probabilities for a specific token, including its top probable alternatives.
  /// </summary>
  TLogprobsDetail = class
  private
    FToken: string;
    FLogprob: Double;
    FBytes: TArray<Int64>;
    [JsonNameAttribute('top_logprobs')]
    FTopLogprobs: TArray<TTopLogprobs>;
  public
    /// <summary>
    /// The token analyzed for log probability.
    /// </summary>
    property Token: string read FToken write FToken;
    /// <summary>
    /// The log probability of the token.
    /// </summary>
    property Logprob: Double read FLogprob write FLogprob;
    /// <summary>
    /// The UTF-8 byte representation of the token.
    /// </summary>
    property Bytes: TArray<Int64> read FBytes write FBytes;
    /// <summary>
    /// A list of the most likely alternatives and their respective log probabilities.
    /// </summary>
    property TopLogprobs: TArray<TTopLogprobs> read FTopLogprobs write FTopLogprobs;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages the collection of log probability details for both content and refusal message tokens.
  /// </summary>
  TLogprobs = class
  private
    FContent: TArray<TLogprobsDetail>;
    FRefusal: TArray<TLogprobsDetail>;
  public
    /// <summary>
    /// Contains log probability details for content message tokens.
    /// </summary>
    property Content: TArray<TLogprobsDetail> read FContent write FContent;
    /// <summary>
    /// Contains log probability details for refusal message tokens.
    /// </summary>
    property Refusal: TArray<TLogprobsDetail> read FRefusal write FRefusal;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a function parameter in a tool call, specifying the function name
  /// and its arguments.
  /// </summary>
  /// <remarks>
  /// This class is used within the context of an API that supports remote function
  /// calls, enabling the specification of the function's name and the corresponding
  /// arguments in JSON format.
  /// </remarks>
  TFunction = class
  private
    FName: string;
    FArguments: string;
  public
    /// <summary>
    /// Gets or sets the name of the function to be called.
    /// </summary>
    property Name: string read FName write FName;
    /// <summary>
    /// Gets or sets the arguments for the function call in JSON formatted string.
    /// </summary>
    property Arguments: string read FArguments write FArguments;
  end;

  /// <summary>
  /// Encapsulates a tool call within a chat or API interaction, linking the call
  /// to a specific function with its parameters.
  /// </summary>
  /// <remarks>
  /// TToolcall is used to manage the execution of backend functions as part of
  /// an interactive session or a workflow, associating each tool call with a unique
  /// identifier and the necessary function parameters.
  /// </remarks>
  TToolcall = class
  private
    FId: string;
    [JsonReflectAttribute(ctString, rtString, TToolCallsInterceptor)]
    FType: TToolCalls;
    FFunction: TFunction;
  public
    /// <summary>
    /// Gets or sets the unique identifier for the tool call.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Gets or sets the type of the tool call, typically linked to the nature
    /// of the function being called.
    /// </summary>
    property &Type: TToolCalls read FType write FType;
    /// <summary>
    /// Gets or sets the function to be executed as part of this tool call.
    /// </summary>
    property &Function: TFunction read FFunction write FFunction;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents audio data that can be streamed or stored during a chat or API session,
  /// including its identifier and expiration metadata.
  /// </summary>
  /// <remarks>
  /// TAudioData is used in contexts where audio responses are managed, providing
  /// support for both temporary and persistent storage of audio files with associated
  /// metadata about expiration and format.
  /// </remarks>
  TAudioData = class
  private
    FId: string;
    [JsonNameAttribute('expires_at')]
    FExpiresAt: TInt64OrNull;
    FData: string;
    FTranscript: string;
  private
    function GetExpiresAtAsString: string;
    function GetExpiresAt: Int64;
  public
    /// <summary>
    /// Gets or sets the unique identifier for the audio data, used for tracking
    /// and retrieval purposes.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Gets the expiration timestamp for the audio data, after which the
    /// data may no longer be available.
    /// </summary>
    property ExpiresAt: Int64 read GetExpiresAt;
    /// <summary>
    /// Gets the expiration timestamp for the audio data as string
    /// </summary>
    property ExpiresAtAsString: string read GetExpiresAtAsString;
    /// <summary>
    /// Gets or sets the base64-encoded audio data.
    /// </summary>
    property Data: string read FData write FData;
    /// <summary>
    /// Gets or sets the transcript of the audio content, providing a text
    /// representation of the audio.
    /// </summary>
    property Transcript: string read FTranscript write FTranscript;
  end;

  /// <summary>
  /// Represents audio data for use within a JSON structure, facilitating the management
  /// of audio file information including IDs, expiration, data, and transcripts.
  /// </summary>
  /// <remarks>
  /// This class allows for detailed control and retrieval of audio data properties, useful
  /// for audio processing applications that require handling of both metadata and streamable
  /// content. It extends TAudioData to provide additional functionalities like saving to files
  /// or retrieving the stream directly.
  /// </remarks>
  TAudio = class(TAudioData)
  private
    FFileName: string;
  public
    /// <summary>
    /// Retrieves the audio content as a stream, allowing for playback or processing
    /// in real-time applications.
    /// </summary>
    /// <returns>
    /// A TStream object containing the audio data ready for use.
    /// </returns>
    function GetStream: TStream;
    /// <summary>
    /// Saves the generated image to the specified file path.
    /// </summary>
    /// <param name="FileName">
    /// A string specifying the file path where the image will be saved.
    /// </param>
    /// <param name="RaiseError">
    /// A boolean value indicating whether to raise an exception if the <c>FileName</c> is empty.
    /// <para>
    /// - If set to <c>True</c>, an exception will be raised for an empty file path.
    /// </para>
    /// <para>
    /// - If set to <c>False</c>, the method will exit silently without saving.
    /// </para>
    /// </param>
    /// <remarks>
    /// This method saves the base64-encoded image content to the specified file. Ensure that
    /// the <c>FileName</c> parameter is valid if <c>RaiseError</c> is set to <c>True</c>.
    /// If the <c>FileName</c> is empty and <c>RaiseError</c> is <c>False</c>, the method
    /// will terminate without performing any operation.
    /// </remarks>
    procedure SaveToFile(const FileName: string; const RaiseError: Boolean = True);
    /// <summary>
    /// Property to get or set the file name associated with the audio data.
    /// </summary>
    /// <remarks>
    /// This property can be used to manage file naming for saved audio data,
    /// facilitating easier storage and retrieval operations.
    /// </remarks>
    property FileName: string read FFileName write FFileName;
  end;

  /// <summary>
  /// Represents a URL citation within a message, providing details about
  /// the referenced web resource, including its title, URL, and position in the text.
  /// </summary>
  /// <remarks>
  /// This class is used to store metadata about a URL citation found in a chat message.
  /// It includes the start and end indices of the citation within the message text,
  /// the URL itself, and the title of the referenced resource.
  /// </remarks>
  TUrlCitation = class
  private
    [JsonNameAttribute('end_index')]
    FEndindex: Int64;
    [JsonNameAttribute('start_index')]
    FStartindex: Int64;
    FTitle: string;
    FUrl: string;
  public
    /// <summary>
    /// The index of the last character of the URL citation in the message.
    /// </summary>
    property Endindex: Int64 read FEndindex write FEndindex;
    /// <summary>
    /// The index of the first character of the URL citation in the message.
    /// </summary>
    property Startindex: Int64 read FStartindex write FStartindex;
    /// <summary>
    /// The title of the web resource.
    /// </summary>
    property Title: string read FTitle write FTitle;
    /// <summary>
    /// The URL of the web resource.
    /// </summary>
    property Url: string read FUrl write FUrl;
  end;

  /// <summary>
  /// Represents an annotation within a message, providing additional metadata
  /// related to web citations, such as referenced URLs.
  /// </summary>
  /// <remarks>
  /// This class is used to store information about web citations that appear in a chat message.
  /// It includes the type of annotation (which is always "url_citation") and a reference
  /// to a <c>TUrlCitation</c> instance containing details about the cited web resource.
  /// </remarks>
  TAnnotation = class
  private
    FType: string;
    [JsonNameAttribute('url_citation')]
    FUrlCitation: TUrlCitation;
  public
    /// <summary>
    /// The type of the URL citation. Always url_citation.
    /// </summary>
    property &Type: string read FType write FType;
    /// <summary>
    /// A URL citation when using web search.
    /// </summary>
    property UrlCitation: TUrlCitation read FUrlCitation write FUrlCitation;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a delta update for chat completions, encapsulating modifications
  /// made during streaming or batch updates of chat messages.
  /// </summary>
  /// <remarks>
  /// TDelta class is crucial for real-time updates in chat interfaces, allowing
  /// dynamic response and modification tracking. It includes properties for managing
  /// content changes, associated tool calls, and the role and refusal messages within
  /// the chat structure.
  /// </remarks>
  TDelta = class
  private
    FContent: string;
    [JsonNameAttribute('tool_calls')]
    FToolCalls: TArray<TToolcall>;
    [JsonReflectAttribute(ctString, rtString, TRoleInterceptor)]
    FRole: TRole;
    FRefusal: string;
    {--- No annotations provided for the streaming }
  public
    /// <summary>
    /// Provides access to the content of the delta, which includes any text or structured
    /// data that has been added or modified in the chat message.
    /// </summary>
    /// <returns>
    /// A string containing the updated content.
    /// </returns>
    property Content: string read FContent write FContent;
    /// <summary>
    /// Lists tool calls associated with the delta, allowing for interaction with
    /// external functions or processes triggered by the chat updates.
    /// </summary>
    /// <returns>
    /// An array of TToolcall objects, each representing a specific call to an external tool.
    /// </returns>
    property ToolCalls: TArray<Ttoolcall> read FToolCalls write FToolCalls;
    /// <summary>
    /// Represents the role of the message author, helping to differentiate between
    /// user, system, and assistant messages within the chat structure.
    /// </summary>
    /// <returns>
    /// A TRole value indicating the role of the message author.
    /// </returns>
    property Role: TRole read FRole write FRole;
    /// <summary>
    /// Contains any refusal message that might be sent if the delta cannot be applied,
    /// providing feedback on errors or constraints within the chat process.
    /// </summary>
    /// <returns>
    /// A string detailing the refusal reason, if applicable.
    /// </returns>
    property Refusal: string read FRefusal write FRefusal;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a message within a chat conversation, encapsulating the content, role,
  /// and additional interactive elements like tool calls and audio data.
  /// </summary>
  /// <remarks>
  /// TChatMessage class is designed to facilitate detailed interaction within chat systems,
  /// supporting rich content types including text, tools, and audio. It handles the roles
  /// of participants, ensuring appropriate responses based on user or system activity, and
  /// integrates external tool functions as part of the conversation flow.
  /// </remarks>
  TChatMessage = class
  private
    FContent: string;
    FRefusal: string;
    [JsonNameAttribute('tool_calls')]
    FToolCalls: TArray<TToolcall>;
    [JsonReflectAttribute(ctString, rtString, TRoleInterceptor)]
    FRole: TRole;
    FAnnotations: TArray<TAnnotation>;
    FAudio: TAudio;
  public
    /// <summary>
    /// Accesses the main content of the message, which could be text or structured data.
    /// </summary>
    /// <returns>
    /// A string representing the content of the message.
    /// </returns>
    property Content: string read FContent write FContent;
    /// <summary>
    /// If applicable, provides a refusal message indicating why a particular response
    /// or action was not taken.
    /// </summary>
    /// <returns>
    /// A string containing the refusal message.
    /// </returns>
    property Refusal: string read FRefusal write FRefusal;
    /// <summary>
    /// Details any tool calls that have been initiated as part of the message interaction,
    /// allowing for external processes or functions to be executed.
    /// </summary>
    /// <returns>
    /// An array of TToolcall objects, each representing a tool interaction.
    /// </returns>
    property ToolCalls: TArray<Ttoolcall> read FToolCalls write FToolCalls;
    /// <summary>
    /// Defines the role of the message's author, distinguishing between different types
    /// of participants such as user, assistant, or system.
    /// </summary>
    /// <returns>
    /// A TRole value indicating the author's role in the conversation.
    /// </returns>
    property Role: TRole read FRole write FRole;
    /// <summary>
    /// Annotations for the message, when applicable, as when using the web search tool.
    /// </summary>
    property Annotations: TArray<TAnnotation> read FAnnotations write FAnnotations;
    /// <summary>
    /// Contains any audio response data linked with the message, suitable for playback
    /// or further processing.
    /// </summary>
    /// <returns>
    /// A TAudio object encapsulating the audio data associated with the message.
    /// </returns>
    property Audio: TAudio read FAudio write FAudio;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a choice or option generated during a chat interaction, encapsulating
  /// specific responses and associated data like logs and deltas.
  /// </summary>
  /// <remarks>
  /// TChoice is integral to managing multiple potential responses in interactive systems
  /// like chatbots, where each choice can represent a different continuation of the conversation.
  /// This class includes detailed information about the response, reasoning, and any associated
  /// changes or tool calls made during the interaction.
  /// </remarks>
  TChoice = class
  private
    [JsonReflectAttribute(ctString, rtString, TFinishReasonInterceptor)]
    [JsonNameAttribute('finish_reason')]
    FFinishReason: TFinishReason;
    FIndex: Int64;
    FMessage: TChatMessage;
    FLogprobs: TLogprobs;
    FDelta: TDelta;
  public
    /// <summary>
    /// Describes the reason why the message generation was stopped, such as reaching
    /// a stop condition or fulfilling all required tokens.
    /// </summary>
    /// <returns>
    /// A TFinishReason enumeration value describing the stop condition.
    /// </returns>
    property FinishReason: TFinishReason read FFinishReason write FFinishReason;
    /// <summary>
    /// Indicates the position or index of this choice relative to other possible
    /// choices generated in the same request.
    /// </summary>
    /// <returns>
    /// An integer representing the order or sequence of the choice.
    /// </returns>
    property Index: Int64 read FIndex write FIndex;
    /// <summary>
    /// Provides access to the message associated with this choice, including any
    /// text, audio, or structured responses.
    /// </summary>
    /// <returns>
    /// A TChatMessage object containing the response and any associated metadata.
    /// </returns>
    property Message: TChatMessage read FMessage write FMessage;
    /// <summary>
    /// Contains log probability details for the tokens used in the choice's message,
    /// useful for analyzing model behavior and decisions.
    /// </summary>
    /// <returns>
    /// A TLogprobs obje
    property Logprobs: TLogprobs read FLogprobs write FLogprobs;
    /// <summary>
    /// Represents a delta update for chat completions, encapsulating modifications
    /// made during streaming or batch updates of chat messages.
    /// </summary>
    /// <returns>
    /// A TDelta object detailing modifications made to the chat interaction.
    /// </returns>
    property Delta: TDelta read FDelta write FDelta;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents detailed token usage statistics for a specific chat completion, providing insights into
  /// how tokens are allocated across different categories such as audio, reasoning, and predictions.
  /// </summary>
  /// <remarks>
  /// TCompletionDetail is essential for monitoring and analyzing the computational resources used during
  /// chat interactions. This class helps in understanding the efficiency and distribution of token usage
  /// within the completion process, aiding in optimization and resource management.
  /// </remarks>
  TCompletionDetail = class
  private
    [JsonNameAttribute('accepted_prediction_tokens')]
    FAcceptedPredictionTokens: Int64;
    [JsonNameAttribute('audio_tokens')]
    FAudioTokens: Int64;
    [JsonNameAttribute('reasoning_tokens')]
    FReasoningTokens: Int64;
    [JsonNameAttribute('rejected_prediction_tokens')]
    FRejectedPredictionTokens: Int64;
  public
    /// <summary>
    /// The number of tokens that were accepted during the prediction phase of the chat completion.
    /// </summary>
    /// <returns>
    /// An integer representing the count of tokens accepted for predictions.
    /// </returns>
    property AcceptedPredictionTokens: Int64 read FAcceptedPredictionTokens write FAcceptedPredictionTokens;
    /// <summary>
    /// The number of tokens used for processing audio components within the chat completion.
    /// </summary>
    /// <returns>
    /// An integer indicating the total tokens used for audio-related activities.
    /// </returns>
    property AudioTokens: Int64 read FAudioTokens write FAudioTokens;
    /// <summary>
    /// The number of tokens dedicated to reasoning processes, helping to understand the depth of
    /// analysis performed by the chat model.
    /// </summary>
    /// <returns>
    /// An integer showing the amount of tokens used for reasoning.
    /// </returns>
    property ReasoningTokens: Int64 read FReasoningTokens write FReasoningTokens;
    /// <summary>
    /// The number of tokens that were rejected or not used in the final output during the prediction
    /// phase, reflecting efficiency and decision-making within the model.
    /// </summary>
    /// <returns>
    /// An integer detailing the tokens that were rejected during the prediction process.
    /// </returns>
    property RejectedPredictionTokens: Int64 read FRejectedPredictionTokens write FRejectedPredictionTokens;
  end;

  /// <summary>
  /// Provides detailed statistics about the tokens used in the prompt of a chat session,
  /// highlighting the resource utilization during the initial stages of chat interactions.
  /// </summary>
  /// <remarks>
  /// TPromptDetail is crucial for evaluating the computational cost of initiating chat interactions,
  /// specifically in terms of the number of tokens used for audio and cached content. This class aids
  /// in optimizing token usage, ensuring efficient management of resources in chat applications.
  /// </remarks>
  TPromptDetail = class
  private
    [JsonNameAttribute('audio_tokens')]
    FAudioTokens: Int64;
    [JsonNameAttribute('cached_tokens')]
    FCachedTokens: Int64;
  public
    /// <summary>
    /// The number of tokens used for processing audio elements in the prompt, reflecting
    /// the computational resources allocated to handle audio inputs.
    /// </summary>
    /// <returns>
    /// An integer representing the count of audio tokens used.
    /// </returns>
    property AudioTokens: Int64 read FAudioTokens write FAudioTokens;
    /// <summary>
    /// The number of tokens used from cached responses or content, indicating the reuse of
    /// previously computed data to optimize response times and resource consumption.
    /// </summary>
    /// <returns>
    /// An integer showing the amount of cached tokens utilized in the prompt.
    /// </returns>
    property CachedTokens: Int64 read FCachedTokens write FCachedTokens;
  end;

  /// <summary>
  /// Provides a comprehensive overview of token usage statistics for a chat completion request,
  /// facilitating detailed analysis of computational resource allocation.
  /// </summary>
  /// <remarks>
  /// TUsage is instrumental in tracking and managing the resource usage in chat applications,
  /// offering insights into how tokens are distributed between the prompt and completion phases.
  /// This class allows developers to assess and optimize the efficiency of the token utilization process.
  /// </remarks>
  TUsage = class
  private
    [JsonNameAttribute('completion_tokens')]
    FCompletionTokens: Int64;
    [JsonNameAttribute('prompt_tokens')]
    FPromptTokens: Int64;
    [JsonNameAttribute('total_tokens')]
    FTotalTokens: Int64;
    [JsonNameAttribute('completion_tokens_details')]
    FCompletionTokensDetails: TCompletionDetail;
    [JsonNameAttribute('prompt_tokens_details')]
    FPromptTokensDetails: TPromptDetail;
  public
    /// <summary>
    /// Represents the total number of tokens used during the completion phase of the chat interaction.
    /// </summary>
    /// <returns>
    /// An integer representing the total number of completion tokens used.
    /// </returns>
    property CompletionTokens: Int64 read FCompletionTokens write FCompletionTokens;
    /// <summary>
    /// Represents the total number of tokens used during the prompt phase of the chat interaction.
    /// </summary>
    /// <returns>
    /// An integer representing the total number of prompt tokens used.
    /// </returns>
    property PromptTokens: Int64 read FPromptTokens write FPromptTokens;
    /// <summary>
    /// Represents the total number of tokens used in both the prompt and completion phases combined.
    /// </summary>
    /// <returns>
    /// An integer representing the total number of tokens used in the entire chat interaction.
    /// </returns>
    property TotalTokens: Int64 read FTotalTokens write FTotalTokens;
    /// <summary>
    /// Provides detailed insights into token usage specifically within the completion phase,
    /// aiding in understanding and optimizing resource allocation.
    /// </summary>
    /// <returns>
    /// A TCompletionDetail object that contains detailed statistics on token usage during the completion phase.
    /// </returns>
    property CompletionTokensDetails: TCompletionDetail read FCompletionTokensDetails write FCompletionTokensDetails;
    /// <summary>
    /// Provides detailed insights into token usage specifically within the prompt phase,
    /// aiding in understanding and optimizing resource allocation.
    /// </summary>
    /// <returns>
    /// A TPromptDetail object that contains detailed statistics on token usage during the prompt phase.
    /// </returns>
    property PromptTokensDetails: TPromptDetail read FPromptTokensDetails write FPromptTokensDetails;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a chat completion response returned by the model, including all relevant
  /// interaction details, choices, and usage statistics.
  /// </summary>
  /// <remarks>
  /// TChat is crucial for handling the outputs of chat models, providing developers with
  /// structured data on the interactions, including the chosen responses, reasons for
  /// completion, and detailed token usage. This class facilitates the integration and
  /// management of AI-powered chat functionalities within applications.
  /// </remarks>
  TChat = class(TJSONFingerprint)
  private
    FId: string;
    FChoices: TArray<TChoice>;
    FCreated: TInt64OrNull;
    FModel: string;
    [JsonNameAttribute('service_tier')]
    FServiceTier: string;
    [JsonNameAttribute('system_fingerprint')]
    FSystemFingerprint: string;
    FObject: string;
    FUsage: TUsage;
  private
    function GetCreatedAsString: string;
    function GetCreated: Int64;
  public
    /// <summary>
    /// The unique identifier for the chat completion.
    /// </summary>
    /// <returns>
    /// A string representing the ID of the chat completion.
    /// </returns>
    property Id: string read FId write FId;
    /// <summary>
    /// A collection of choice objects that represent the possible responses generated by the model.
    /// </summary>
    /// <returns>
    /// An array of TChoice objects, each detailing a potential response within the chat interaction.
    /// </returns>
    property Choices: TArray<TChoice> read FChoices write FChoices;
    /// <summary>
    /// The Unix timestamp indicating when the chat completion was created.
    /// </summary>
    /// <returns>
    /// An Int64 value representing the creation time of the chat completion.
    /// </returns>
    property Created: Int64 read GetCreated;
    /// <summary>
    /// A string representation of the Unix timestamp indicating when the chat completion was created.
    /// </summary>
    /// <remarks>
    /// This property converts the Unix timestamp from the <c>Created</c> property into a human-readable string format using UTC.
    /// </remarks>
    /// <returns>
    /// A <c>string</c> representing the creation time of the chat completion in a readable format.
    /// </returns>
    property CreatedAsString: string read GetCreatedAsString;
    /// <summary>
    /// The model identifier used to generate the chat completion.
    /// </summary>
    /// <returns>
    /// A string representing the model used for generating the chat response.
    /// </returns>
    property Model: string read FModel write FModel;
    /// <summary>
    /// The service tier under which the chat completion request was processed.
    /// </summary>
    /// <returns>
    /// A string representing the service tier, influencing the processing priorities and resources allocated.
    /// </returns>
    property ServiceTier: string read FServiceTier write FServiceTier;
    /// <summary>
    /// A fingerprint that represents the backend configuration under which the model runs.
    /// </summary>
    /// <returns>
    /// A string representing the system fingerprint, useful for debugging and ensuring consistency across sessions.
    /// </returns>
    property SystemFingerprint: string read FSystemFingerprint write FSystemFingerprint;
    /// <summary>
    /// The type of object, always set to 'chat.completion' to identify the nature of this JSON object.
    /// </summary>
    /// <returns>
    /// A string that confirms the object type as 'chat.completion'.
    /// </returns>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// Provides detailed statistics on token usage for the entire chat completion request.
    /// </summary>
    /// <returns>
    /// A TUsage object that includes detailed token usage data for assessing computational resource allocation.
    /// </returns>
    property Usage: TUsage read FUsage write FUsage;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a single message returned in a chat completion response,
  /// including its content, author role, optional audio payload, and any
  /// associated annotations or tool call details.
  /// </summary>
  TChatCompletionMessage = class(TJSONFingerprint)
  private
    FContent: string;
    FId: string;
    FRefusal: string;
    [JsonReflectAttribute(ctString, rtString, TRoleInterceptor)]
    FRole: TRole;
    FAnnotations: TArray<TAnnotation>;
    FAudio: TAudio;
    [JsonNameAttribute('tool_calls')]
    FToolCalls: TArray<TToolcall>;
  public
    /// <summary>
    /// Gets or sets the main textual content of the message.
    /// </summary>
    property Content: string read FContent write FContent;
    /// <summary>
    /// Gets or sets the unique identifier for this chat message.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Gets or sets the refusal message, if the model was unable to comply with the request.
    /// </summary>
    property Refusal: string read FRefusal write FRefusal;
    /// <summary>
    /// Gets or sets the role of the message author (e.g., user, assistant, system, or tool).
    /// </summary>
    property Role: TRole read FRole write FRole;
    /// <summary>
    /// Gets or sets any annotations attached to the message, such as URL citations.
    /// </summary>
    property Annotations: TArray<TAnnotation> read FAnnotations write FAnnotations;
    /// <summary>
    /// Gets or sets the audio data associated with this message, if present.
    /// </summary>
    property Audio: TAudio read FAudio write FAudio;
    /// <summary>
    /// Gets or sets the array of tool calls invoked by this message.
    /// </summary>
    property ToolCalls: TArray<TToolcall> read FToolCalls write FToolCalls;
    /// <summary>
    /// Frees all owned resources, including annotations, audio data, and tool call objects.
    /// </summary>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a paginated list of chat completion messages, including
  /// navigation cursors and flags for additional pages.
  /// </summary>
  TChatMessages = class(TJSONFingerprint)
  private
    FData: TArray<TChatCompletionMessage>;
    [JsonNameAttribute('first_id')]
    FFirstId: string;
    [JsonNameAttribute('has_more')]
    FHasMore: Boolean;
    [JsonNameAttribute('last_id')]
    FLastId: string;
    FObject: string;
  public
    /// <summary>
    /// The array of chat messages in the current page of results.
    /// </summary>
    property Data: TArray<TChatCompletionMessage> read FData write FData;
    /// <summary>
    /// The ID of the first message in this page, useful for paging backwards.
    /// </summary>
    property FirstId: string read FFirstId write FFirstId;
    /// <summary>
    /// Indicates whether more messages are available after this page.
    /// </summary>
    property HasMore: Boolean read FHasMore write FHasMore;
    /// <summary>
    /// The ID of the last message in this page, useful for paging forwards.
    /// </summary>
    property LastId: string read FLastId write FLastId;
    /// <summary>
    /// The object type, typically 'list'.
    /// </summary>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// Cleans up and frees all owned message instances and resources.
    /// </summary>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a paginated list of chat completion responses returned by the API.
  /// </summary>
  /// <remarks>
  /// Contains an array of <c>TChat</c> objects along with pagination cursors and a flag
  /// indicating whether additional pages are available.
  /// </remarks>
  TChatCompletion = class(TJSONFingerprint)
    FData: TArray<TChat>;
    [JsonNameAttribute('first_id')]
    FFirstId: string;
    [JsonNameAttribute('has_more')]
    FHasMore: Boolean;
    [JsonNameAttribute('last_id')]
    FLastId: string;
    FObject: string;
  public
    /// <summary>
    /// The array of chat messages in the current page of results.
    /// </summary>
    property  Data: TArray<TChat> read FData write FData;
    /// <summary>
    /// The ID of the first message in this page, useful for paging backwards.
    /// </summary>
    property FirstId: string read FFirstId write FFirstId;
    /// <summary>
    /// Indicates whether more messages are available after this page.
    /// </summary>
    property HasMore: Boolean read FHasMore write FHasMore;
    /// <summary>
    /// The ID of the last message in this page, useful for paging forwards.
    /// </summary>
    property LastId: string read FLastId write FLastId;
    /// <summary>
    /// The object type, typically 'list'.
    /// </summary>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// Frees all owned <c>TChat</c> instances and associated resources.
    /// </summary>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents the result of a chat completion deletion request.
  /// </summary>
  /// <remarks>
  /// This class is used to deserialize the API response when a chat completion
  /// is deleted. It includes the identifier of the deleted completion, the
  /// object type returned by the service, and a flag indicating whether the
  /// deletion was successful.
  TChatDelete = class(TJSONFingerprint)
  private
    FId: string;
    FObject: string;
    FDeleted: Boolean;
  public
    /// <summary>
    /// The ID of the response to delete.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Allways reponse.deleted
    /// </summary>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// True if the response has been deleted
    /// </summary>
    property Deleted: Boolean read FDeleted write FDeleted;
  end;

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TChat</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynChat</c> type extends the <c>TAsynParams&lt;TChat&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynChat = TAsynCallBack<TChat>;

  /// <summary>
  /// Manages asynchronous streaming chat callBacks for a chat request using <c>TChat</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynChatStream</c> type extends the <c>TAsynStreamParams&lt;TChat&gt;</c> record to support the lifecycle of an asynchronous streaming chat operation.
  /// It provides callbacks for different stages, including when the operation starts, progresses with new data chunks, completes successfully, or encounters an error.
  /// This structure is ideal for handling scenarios where the chat response is streamed incrementally, providing real-time updates to the user interface.
  /// </remarks>
  TAsynChatStream = TAsynStreamCallBack<TChat>;

  /// <summary>
  /// Represents an asynchronous callback structure for retrieving chat messages.
  /// </summary>
  /// <remarks>
  /// Use this callback type to handle the lifecycle events (start, success, error, and cancellation)
  /// when fetching <see cref="TChatMessages"/> instances asynchronously.
  /// </remarks>
  TAsynChatMessages = TAsynCallBack<TChatMessages>;

  /// <summary>
  /// Represents an asynchronous callback structure for retrieving chat completion results.
  /// </summary>
  /// <remarks>
  /// Use this callback type to handle the lifecycle events (start, success, error, and cancellation)
  /// when fetching <see cref="TChatCompletion"/> instances asynchronously.
  /// </remarks>
  TAsynChatCompletion = TAsynCallBack<TChatCompletion>;

  /// <summary>
  /// Represents an asynchronous callback structure for deleting a chat completion.
  /// </summary>
  /// <remarks>
  /// Use this callback type to handle the lifecycle events (start, success, error, and cancellation)
  /// when performing an asynchronous delete operation for a <see cref="TChatDelete"/> instance.
  /// </remarks>
  TAsynChatDelete = TAsynCallBack<TChatDelete>;

  /// <summary>
  /// Handles the routing and execution of chat-related API requests within the application,
  /// facilitating interaction with AI models for generating chat completions.
  /// </summary>
  /// <remarks>
  /// TChatRoute is designed to manage chat interaction requests and responses, providing
  /// methods for both synchronous and asynchronous operations. This class plays a pivotal
  /// role in integrating and managing the AI-driven chat functionalities within diverse
  /// software architectures.
  /// </remarks>
  TChatRoute = class(TGenAIRoute)
    /// <summary>
    /// Asynchronously creates a chat completion, invoking the specified callbacks
    /// to handle the response data and events.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure that allows setting parameters for the chat completion request.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns an instance of TAsynChat, providing callbacks for different
    /// stages of the request lifecycle such as start, success, and error handling.
    /// </param>
    procedure AsynCreate(ParamProc: TProc<TChatParams>; CallBacks: TFunc<TAsynChat>);
    /// <summary>
    /// Asynchronously creates a chat completion and supports streaming the responses,
    /// suitable for real-time interaction applications.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure that allows setting parameters for the chat completion request.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns an instance of TAsynChatStream, providing an interface for
    /// managing streamed chat responses.
    /// </param>
    procedure AsynCreateStream(ParamProc: TProc<TChatParams>; CallBacks: TFunc<TAsynChatStream>);
    /// <summary>
    /// Asynchronously retrieves a stored chat completion by its unique identifier.
    /// </summary>
    /// <param name="CompletionID">
    /// The identifier of the chat completion to fetch. This must correspond to a completion
    /// that was created with storage enabled.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a <c>TAsynChat</c> record. The record’s callbacks
    /// (<c>OnStart</c>, <c>OnSuccess</c>, <c>OnError</c>, etc.) are invoked at each stage
    /// of the asynchronous operation.
    /// </param>
    /// <remarks>
    /// Use this method to perform a non blocking fetch of a previously stored chat.
    /// <c>OnStart</c> is called before the request is issued.
    /// <c>OnSuccess</c> is called when the chat is successfully retrieved, passing the <c>TChat</c> instance.
    /// <c>OnError</c> is called if an exception or network error occurs.
    /// </remarks>
    procedure AsynGetCompletion(const CompletionID: string; CallBacks: TFunc<TAsynChat>);
    /// <summary>
    /// Asynchronously retrieves the messages of a stored chat completion by its unique identifier.
    /// </summary>
    /// <param name="CompletionID">
    /// The identifier of the chat completion whose messages to retrieve. This must correspond
    /// to a completion created with storage enabled.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a <c>TAsynChatMessages</c> record. The record’s callbacks
    /// (<c>OnStart</c>, <c>OnSuccess</c>, <c>OnError</c>, etc.) are invoked at each stage
    /// of the asynchronous retrieval.
    /// </param>
    /// <remarks>
    /// Use this method to perform a non blocking fetch of messages from a stored chat.
    /// <c>OnStart</c> is called before the request is issued.
    /// <c>OnSuccess</c> is called when the messages are successfully retrieved, passing the
    /// <c>TChatMessages</c> instance.
    /// <c>OnError</c> is called if an exception or network error occurs.
    /// </remarks>
    procedure AsynGetMessages(const CompletionID: string; CallBacks: TFunc<TAsynChatMessages>); overload;
    /// <summary>
    /// Asynchronously retrieves the messages of a stored chat completion using custom query parameters.
    /// </summary>
    /// <param name="CompletionID">
    /// The identifier of the chat completion whose messages to retrieve. This must correspond
    /// to a completion created with storage enabled.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure <c>TUrlChatParams</c> for pagination, filtering, and ordering of the messages.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a <c>TAsynChatMessages</c> record. The record’s callbacks
    /// (<c>OnStart</c>, <c>OnSuccess</c>, <c>OnError</c>, etc.) are invoked at each stage
    /// of the asynchronous retrieval.
    /// </param>
    /// <remarks>
    /// Use this method to perform a non blocking fetch of messages from a stored chat with custom query options.
    /// <c>OnStart</c> is called before the request is issued.
    /// <c>OnSuccess</c> is called when the messages are successfully retrieved, passing the <c>TChatMessages</c> instance.
    /// <c>OnError</c> is called if an exception or network error occurs.
    /// </remarks>
    procedure AsynGetMessages(const CompletionID: string; ParamProc: TProc<TUrlChatParams>;
      CallBacks: TFunc<TAsynChatMessages>); overload;
    /// <summary>
    /// Asynchronously retrieves a paginated list of stored chat completions.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure <c>TUrlChatListParams</c> for pagination, metadata filtering,
    /// model filtering, and sort order of the chat completions.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a <c>TAsynChatCompletion</c> record. The record’s callbacks
    /// (<c>OnStart</c>, <c>OnSuccess</c>, <c>OnError</c>, etc.) are invoked at each stage
    /// of the asynchronous list retrieval.
    /// </param>
    /// <remarks>
    /// Use this method to perform a non blocking fetch of stored chat completions.
    /// <c>OnStart</c> is called before the request is issued.
    /// <c>OnSuccess</c> is called when the list is successfully retrieved, passing the
    /// <c>TChatCompletion</c> instance. <c>OnError</c> is called if an exception or network
    /// error occurs.
    /// </remarks>
    procedure AsynList(ParamProc: TProc<TUrlChatListParams>; CallBacks: TFunc<TAsynChatCompletion>);
    /// <summary>
    /// Asynchronously updates metadata of a stored chat completion.
    /// </summary>
    /// <param name="CompletionID">
    /// The identifier of the chat completion to update. Must correspond to a completion
    /// that was created with storage enabled.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure <c>TChatUpdateParams</c> with the metadata modifications
    /// to apply to the chat completion.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a <c>TAsynChat</c> record. The record’s callbacks
    /// (<c>OnStart</c>, <c>OnSuccess</c>, <c>OnError</c>, etc.) are invoked at each
    /// stage of the asynchronous update operation.
    /// </param>
    /// <remarks>
    /// Use this method to perform a non blocking update of a stored chat’s metadata.
    /// <c>OnStart</c> is called before the request is issued.
    /// <c>OnSuccess</c> is called when the update completes successfully, passing the
    /// updated <c>TChat</c> instance. <c>OnError</c> is called if an exception
    /// or network error occurs.
    /// </remarks>
    procedure AsynUpdate(const CompletionID: string; ParamProc: TProc<TChatUpdateParams>;
      CallBacks: TFunc<TAsynChat>);
    /// <summary>
    /// Asynchronously deletes a stored chat completion.
    /// </summary>
    /// <param name="CompletionID">
    /// The identifier of the chat completion to delete. Must correspond to a completion
    /// that was created with storage enabled.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a <c>TAsynChatDelete</c> record. The record’s callbacks
    /// (<c>OnStart</c>, <c>OnSuccess</c>, <c>OnError</c>, etc.) are invoked at each
    /// stage of the asynchronous deletion operation.
    /// </param>
    /// <remarks>
    /// Use this method to perform a non blocking deletion of a stored chat completion.
    /// <c>OnStart</c> is called before the delete request is issued.
    /// <c>OnSuccess</c> is called when the deletion is confirmed, passing the
    /// <c>TChatDelete</c> instance.
    /// <c>OnError</c> is called if an exception or network error occurs.
    /// </remarks>
    procedure AsynDelete(const CompletionID: string; CallBacks: TFunc<TAsynChatDelete>);
    /// <summary>
    /// Synchronously creates a chat completion, directly returning the chat completion
    /// object upon completion.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure that allows setting parameters for the chat completion request.
    /// </param>
    /// <returns>
    /// A TChat object containing the completion response from the model.
    /// </returns>
    function Create(ParamProc: TProc<TChatParams>): TChat;
    /// <summary>
    /// Initiates a synchronous stream of chat completions, allowing for real-time interaction
    /// and updates via a provided event handler.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure that allows setting parameters for the chat completion request.
    /// </param>
    /// <param name="Event">
    /// An event handler that processes the streamed chat completion data.
    /// </param>
    /// <returns>
    /// Returns True if the streaming session is initiated successfully, otherwise False.
    /// </returns>
    function CreateStream(ParamProc: TProc<TChatParams>; Event: TStreamCallbackEvent<TChat>): Boolean;
    /// <summary>
    /// Retrieves a stored chat completion by its unique identifier.
    /// </summary>
    /// <param name="CompletionID">
    /// The identifier of the chat completion to retrieve.
    /// </param>
    /// <returns>
    /// A <see cref="TChat"/> instance containing the retrieved completion data.
    /// </returns>
    /// <remarks>
    /// Only completions that were created with storage enabled (Store = True) can be fetched.
    /// An exception is raised if the specified CompletionID does not exist or access is denied.
    /// </remarks>
    function GetCompletion(const CompletionID: string): TChat;
    /// <summary>
    /// Retrieves the messages of a stored chat completion.
    /// </summary>
    /// <param name="CompletionID">
    /// The identifier of the chat completion whose messages to retrieve.
    /// </param>
    /// <returns>
    /// A <see cref="TChatMessages"/> instance containing the list of messages.
    /// </returns>
    /// <remarks>
    /// Only messages from completions created with storage enabled (Store = True) will be returned.
    /// An exception is raised if the CompletionID does not exist or access is denied.
    /// </remarks>
    function GetMessages(const CompletionID: string): TChatMessages; overload;
    /// <summary>
    /// Retrieves the messages of a stored chat completion with custom query parameters.
    /// </summary>
    /// <param name="CompletionID">
    /// The identifier of the chat completion whose messages to retrieve.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure <see cref="TUrlChatParams"/> for pagination, filtering, and ordering.
    /// </param>
    /// <returns>
    /// A <see cref="TChatMessages"/> instance containing the list of messages.
    /// </returns>
    /// <remarks>
    /// Only messages from completions created with storage enabled (Store = True) will be returned.
    /// Use <c>ParamProc</c> to set parameters such as <c>After</c>, <c>Limit</c>, and <c>Order</c>.
    /// An exception is raised if the specified CompletionID does not exist or access is denied.
    /// </remarks>
    function GetMessages(const CompletionID: string; ParamProc: TProc<TUrlChatParams>): TChatMessages; overload;
    /// <summary>
    /// Retrieves a paginated list of stored chat completions.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure <see cref="TUrlChatListParams"/> for pagination, metadata filtering, model filtering, and sort order.
    /// </param>
    /// <returns>
    /// A <see cref="TChatCompletion"/> instance containing the list of chat completions and pagination cursors.
    /// </returns>
    /// <remarks>
    /// Only completions that were created with storage enabled (Store = True) will be included.
    /// Use <c>ParamProc</c> to set options such as <c>After</c>, <c>Limit</c>, <c>Metadata</c>, <c>Model</c>, and <c>Order</c>.
    /// An exception is raised if access is denied.
    /// </remarks>
    function List(ParamProc: TProc<TUrlChatListParams>): TChatCompletion;
    /// <summary>
    /// Updates metadata of a stored chat completion.
    /// </summary>
    /// <param name="CompletionID">
    /// The identifier of the chat completion to update.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure <see cref="TChatUpdateParams"/> for metadata modifications.
    /// </param>
    /// <returns>
    /// A <see cref="TChat"/> instance containing the updated chat completion.
    /// </returns>
    /// <remarks>
    /// Only completions created with storage enabled (Store = True) can be modified.
    /// Currently, only metadata updates are supported. An exception is raised if the
    /// specified CompletionID does not exist or access is denied.
    /// </remarks>
    function Update(const CompletionID: string; ParamProc: TProc<TChatUpdateParams>): TChat;
    /// <summary>
    /// Deletes a stored chat completion.
    /// </summary>
    /// <param name="CompletionID">
    /// The identifier of the chat completion to delete.
    /// </param>
    /// <returns>
    /// A <see cref="TChatDelete"/> instance indicating whether the deletion was successful.
    /// </returns>
    /// <remarks>
    /// Only completions created with storage enabled (<c>Store = True</c>) can be deleted.
    /// An exception is raised if the specified <paramref name="CompletionID"/> does not exist or access is denied.
    /// </remarks>
    function Delete(const CompletionID: string): TChatDelete;
    /// <summary>
    /// Initiates parallel processing of chat prompts by creating multiple chat completions
    /// asynchronously, with results stored in a bundle and provided back to the callback function.
    /// This method allows for parallel processing of multiple prompts in an efficient manner,
    /// handling errors and successes for each chat completion.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure delegate that configures the parameters for the bundle. It is responsible
    /// for providing the necessary settings (such as model and reasoning effort) for the chat completions.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns an instance of TAsynBuffer, which manages the lifecycle of the
    /// asynchronous operation. The callbacks include handlers for start, error, and success events.
    /// </param>
    /// <remarks>
    /// The method allows for efficient parallel processing of multiple prompts by delegating
    /// individual tasks to separate threads. It handles the reasoning effort for specific models
    /// and ensures each task's result is properly bundled and communicated back to the caller.
    /// If an error occurs, the error handling callback will be triggered, and the rest of the tasks
    /// will continue processing. The success callback is triggered once all tasks are completed.
    /// </remarks>
    procedure CreateParallel(ParamProc: TProc<TBundleParams>; CallBacks: TFunc<TAsynBundleList>);
  end;

implementation

uses
  System.StrUtils, GenAI.Httpx, GenAI.NetEncoding.Base64, REST.Json;

{ TMessagePayload }

function TMessagePayload.Content(const Value: string): TMessagePayload;
begin
  Result := TMessagePayload(Add('content', Value));
end;

class function TMessagePayload.Assistant(
  const ParamProc: TProcRef<TMessagePayload>): TMessagePayload;
begin
  Result := TMessagePayload.Create.Role(TRole.assistant);
  if Assigned(ParamProc) then
    begin
      ParamProc(Result);
    end;
end;

class function TMessagePayload.Assistant(
  const Value: TMessagePayload): TMessagePayload;
begin
  Result := Value;
end;

class function TMessagePayload.Assistant(const Value: string): TMessagePayload;
begin
  Result := TMessagePayload.Create.Role(TRole.assistant).Content(Value);
end;

class function TMessagePayload.AssistantAudioId(
  const Value: string): TMessagePayload;
begin
  Result := TMessagePayload.Create.Role(TRole.assistant).Audio(Value);
end;

function TMessagePayload.Audio(const Value: string): TMessagePayload;
begin
  Result := TMessagePayload(Add('audio', TJSONObject.Create.AddPair('id', Value)));
end;

function TMessagePayload.Content(
  const Value: TArray<TAssistantContentParams>): TMessagePayload;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TMessagePayload(Add('content', JSONArray));
end;

function TMessagePayload.Content(const Value: TJSONArray): TMessagePayload;
begin
  Result := TMessagePayload(Add('content', Value));
end;

function TMessagePayload.Content(const Value: TJSONObject): TMessagePayload;
begin
  Result := TMessagePayload(Add('content', Value));
end;

class function TMessagePayload.Developer(const Content,
  Name: string): TMessagePayload;
begin
  Result := New(TRole.developer, Content, Name);
end;

function TMessagePayload.Name(const Value: string): TMessagePayload;
begin
  Result := TMessagePayload(Add('name', Value));
end;

class function TMessagePayload.New(const Role: TRole; const Content,
  Name: string): TMessagePayload;
begin
  Result := TMessagePayload.Create.Role(Role).Content(Content);
  if not Name.IsEmpty then
    Result := Result.Name(Name);
end;

function TMessagePayload.Refusal(const Value: string): TMessagePayload;
begin
  Result := TMessagePayload(Add('refusal', Value));
end;

function TMessagePayload.Role(const Value: string): TMessagePayload;
begin
  Result := TMessagePayload(Add('role', TRole.Create(Value).ToString));
end;

function TMessagePayload.Role(const Value: TRole): TMessagePayload;
begin
  Result := TMessagePayload(Add('role', Value.ToString));
end;

class function TMessagePayload.System(const Content,
  Name: string): TMessagePayload;
begin
  Result := New(TRole.system, Content, Name);
end;

class function TMessagePayload.Tool(const Content,
  ToolCallId: string): TMessagePayload;
begin
  Result := New(TRole.tool, Content).ToolCallId(ToolCallId);
end;

function TMessagePayload.ToolCallId(const Value: string): TMessagePayload;
begin
  Result := TMessagePayload(Add('tool_call_id', Value));
end;

function TMessagePayload.ToolCalls(
  const Value: TArray<TToolCallsParams>): TMessagePayload;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TMessagePayload(Add('tool_calls', JSONArray));
end;

class function TMessagePayload.User(const Content,
  Name: string): TMessagePayload;
begin
  Result := New(TRole.User, Content, Name);
end;

class function TMessagePayload.User(const Content: string;
  const Docs: TArray<string>; const Name: string): TMessagePayload;
begin
  var JSONArray := TJSONArray.Create;
  JSONArray.Add(TContentParams.Create.&Type('text').Text(Content).Detach);

  for var Item in Docs do
    JSONArray.Add(TContentParams.AddFile(Item).Detach);

  Result := TMessagePayload.Create.Role(TRole.user).Content(JSONArray);
  if not Name.IsEmpty then
    Result := Result.Name(Name);
end;

class function TMessagePayload.User(const Docs: TArray<string>;
  const Name: string): TMessagePayload;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Docs do
    JSONArray.Add(TContentParams.AddFile(Item).Detach);

  Result := TMessagePayload.Create.Role(TRole.user).Content(JSONArray);
  if not Name.IsEmpty then
    Result := Result.Name(Name);
end;

{ TChatParams }

function TChatParams.Audio(const Voice: TChatVoice;
  const Format: TAudioFormat): TChatParams;
begin
  var Value := TAudioParams.Create.Voice(Voice).Format(Format);
  Result := TChatParams(Add('audio', Value.Detach));
end;

function TChatParams.Audio(const Voice, Format: string): TChatParams;
begin
  Result := Audio(TChatVoice.Create(Voice), TAudioFormat.Create(Format));
end;

function TChatParams.FrequencyPenalty(const Value: Double): TChatParams;
begin
  Result := TChatParams(Add('frequency_penalty', Value));
end;

function TChatParams.LogitBias(const Value: TJSONObject): TChatParams;
begin
  Result := TChatParams(Add('logit_bias', Value));
end;

function TChatParams.Logprobs(const Value: Boolean): TChatParams;
begin
  Result := TChatParams(Add('logprobs', Value));
end;

function TChatParams.MaxCompletionTokens(const Value: Integer): TChatParams;
begin
  Result := TChatParams(Add('max_completion_tokens', Value));
end;

function TChatParams.Messages(
  const Value: TArray<TMessagePayload>): TChatParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TChatParams(Add('messages', JSONArray));
end;

function TChatParams.Messages(const Value: TJSONObject): TChatParams;
begin
  Result := TChatParams(Add('messages', Value));
end;

function TChatParams.Messages(const Value: TJSONArray): TChatParams;
begin
  Result := TChatParams(Add('messages', Value));
end;

function TChatParams.Metadata(const Value: TJSONObject): TChatParams;
begin
  Result := TChatParams(Add('metadata', Value));
end;

function TChatParams.Modalities(const Value: TArray<string>): TChatParams;
var
  Checks: TArray<string>;
begin
  {--- Check string values }
  for var Item in Value do
    Checks := Checks + [TModalities.Create(Item).ToString];
  Result := TChatParams(Add('modalities', Checks));
end;

function TChatParams.Modalities(const Value: TArray<TModalities>): TChatParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.ToString);
  Result := TChatParams(Add('modalities', JSONArray));
end;

function TChatParams.Model(const Value: string): TChatParams;
begin
  Result := TChatParams(Add('model', Value));
end;

function TChatParams.N(const Value: Integer): TChatParams;
begin
  Result := TChatParams(Add('n', Value));
end;

function TChatParams.ParallelToolCalls(const Value: Boolean): TChatParams;
begin
  Result := TChatParams(Add('parallel_tool_calls', Value));
end;

function TChatParams.Prediction(
  const Value: TArray<TPredictionPartParams>): TChatParams;
begin
  Result := TChatParams(Add('prediction', TPredictionParams.New(Value).Detach));
end;

function TChatParams.PresencePenalty(const Value: Double): TChatParams;
begin
  Result := TChatParams(Add('presence_penalty', Value));
end;

function TChatParams.Prediction(const Value: string): TChatParams;
begin
  Result := TChatParams(Add('prediction', TPredictionParams.New(Value).Detach));
end;

function TChatParams.ReasoningEffort(
  const Value: TReasoningEffort): TChatParams;
begin
  Result := TChatParams(Add('reasoning_effort', Value.ToString));
end;

function TChatParams.ReasoningEffort(const Value: string): TChatParams;
begin
  Result := TChatParams(Add('reasoning_effort', TReasoningEffort.Create(Value).ToString));
end;

function TChatParams.ResponseFormat(
  const ParamProc: TProcRef<TSchemaParams>): TChatParams;
begin
  if Assigned(ParamProc) then
    begin
      var Value := TSchemaParams.Create;
      ParamProc(Value);
      Result := TChatParams(Add('response_format', Value.Detach));
    end
  else Result := Self;
end;

function TChatParams.ResponseFormat(const Value: TSchemaParams): TChatParams;
begin
  Result := TChatParams(Add('response_format', Value.Detach));
end;

function TChatParams.ResponseFormat(const Value: TJSONObject): TChatParams;
begin
  Result := TChatParams(Add('response_format', Value));
end;

function TChatParams.Seed(const Value: Integer): TChatParams;
begin
  Result := TChatParams(Add('seed', Value));
end;

function TChatParams.ServiceTier(const Value: string): TChatParams;
begin
  Result := TChatParams(Add('service_tier', Value));
end;

function TChatParams.Stop(const Value: string): TChatParams;
begin
  Result := TChatParams(Add('stop', Value));
end;

function TChatParams.Stop(const Value: TArray<string>): TChatParams;
begin
  Result := TChatParams(Add('stop', Value));
end;

function TChatParams.Store(const Value: Boolean): TChatParams;
begin
  Result := TChatParams(Add('store', Value));
end;

function TChatParams.Stream(const Value: Boolean): TChatParams;
begin
  Result := TChatParams(Add('stream', Value));
end;

function TChatParams.StreamOptions(const IncludeUsage: Boolean): TChatParams;
begin
  Result := StreamOptions(TJSONObject.Create.AddPair('stream_options', IncludeUsage));
end;

function TChatParams.StreamOptions(const Value: TJSONObject): TChatParams;
begin
  Result := TChatParams(Add('stream_options', Value));
end;

function TChatParams.Temperature(const Value: Double): TChatParams;
begin
  Result := TChatParams(Add('temperature', Value));
end;

function TChatParams.ToolChoice(const Value: string): TChatParams;
begin
  var index := IndexStr(Value.ToLower, ['none', 'auto', 'required']);
  if index > -1 then
    Result := TChatParams(Add('tool_choice', Value)) else
    Result := ToolChoice(TToolChoiceParams.New(Value));
end;

function TChatParams.ToolChoice(const Value: TToolChoice): TChatParams;
begin
  Result := ToolChoice(Value.ToString);
end;

function TChatParams.ToolChoice(const Value: TJSONObject): TChatParams;
begin
  Result := TChatParams(Add('tool_choice', Value));
end;

function TChatParams.ToolChoice(const Value: TToolChoiceParams): TChatParams;
begin
  Result := TChatParams(Add('tool_choice', Value.Detach));
end;

function TChatParams.Tools(const Value: TJSONObject): TChatParams;
begin
  Result := TChatParams(Add('tools', Value));
end;

function TChatParams.Tools(const Value: TArray<IFunctionCore>): TChatParams;
var
  Funcs: TArray<TChatMessageTool>;
begin
  for var Item in Value do
    Funcs := Funcs + [TChatMessageTool.Add(Item)];
  Result := Tools(Funcs);
end;

function TChatParams.Tools(const Value: TArray<TChatMessageTool>): TChatParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.ToJson);
  Result := TChatParams(Add('tools', JSONArray));
end;

function TChatParams.TopLogprobs(const Value: Integer): TChatParams;
begin
  Result := TChatParams(Add('top_logprobs', Value));
end;

function TChatParams.TopP(const Value: Double): TChatParams;
begin
  Result := TChatParams(Add('top_p', Value));
end;

function TChatParams.User(const Value: string): TChatParams;
begin
  Result := TChatParams(Add('user', Value));
end;

function TChatParams.WebSearchOptions(
  const Approximation: TUserLocationApproximate): TChatParams;
begin
  var Context := TJSONObject.Create.AddPair('user_location', TUserLocation.New(Approximation).Detach);
  Result := TChatParams(Add('web_search_options', Context));
end;

function TChatParams.WebSearchOptions(
  const UserLocation: TUserLocation): TChatParams;
begin
  var Context := TJSONObject.Create.AddPair('user_location', UserLocation.Detach);
  Result := TChatParams(Add('web_search_options', Context));
end;

function TChatParams.WebSearchOptions(
  const Value: string; const UserLocation: TUserLocation): TChatParams;
begin
  var Context := TJSONObject.Create.AddPair('search_context_size', TSearchWebOptions.Create(Value).ToString);
  if Assigned(UserLocation) then
    Context := Context.AddPair('user_location', UserLocation.Detach);
  Result := TChatParams(Add('web_search_options', Context));
end;

function TChatParams.WebSearchOptions(const Value: string;
  const Approximation: TUserLocationApproximate): TChatParams;
begin
  var Context := TJSONObject.Create.AddPair('search_context_size', TSearchWebOptions.Create(Value).ToString);
  if Assigned(Approximation) then
    Context := Context.AddPair('user_location', TUserLocation.New(Approximation).Detach);
  Result := TChatParams(Add('web_search_options', Context));
end;

function TChatParams.WebSearchOptions(
  const Value: TSearchWebOptions; const UserLocation: TUserLocation): TChatParams;
begin
  var Context := TJSONObject.Create.AddPair('search_context_size', Value.ToString);
  if Assigned(UserLocation) then
    Context := Context.AddPair('user_location', UserLocation.Detach);
  Result := TChatParams(Add('web_search_options', Context));
end;

function TChatParams.WebSearchOptions(const Value: TSearchWebOptions;
  const Approximation: TUserLocationApproximate): TChatParams;
begin
  var Context := TJSONObject.Create.AddPair('search_context_size', Value.ToString);
  if Assigned(Approximation) then
    Context := Context.AddPair('user_location', TUserLocation.New(Approximation).Detach);
  Result := TChatParams(Add('web_search_options', Context));
end;

function TChatParams.WebSearchOptions(const Value: string): TChatParams;
begin
  var Context := TJSONObject.Create.AddPair('search_context_size', TSearchWebOptions.Create(Value).ToString);
  Result := TChatParams(Add('web_search_options', Context));
end;

{ TContentParams }

class function TContentParams.AddFile(
  const FileLocation: string): TContentParams;
var
  MimeType: string;
  Detail: TImageDetail;
begin
  {--- Param detail extraction }
  var Location := Extract(FileLocation, Detail);

  {--- Retrieve mimetype }
  if Location.ToLower.StartsWith('http') then
    MimeType := THttpx.GetMimeType(Location) else
    MimeType := GetMimeType(Location);

  {--- Audio file managment }
  var index := IndexStr(MimeType, AudioTypeAccepted);
  if index <> -1 then
    Exit(TContentParams.Create.&Type('input_audio').InputAudio(TInputAudio.New(Location)));

  {--- Image file managment }
  index := IndexStr(MimeType, ImageTypeAccepted);
  if index <> -1 then
    Exit(TContentParams.Create.&Type('image_url').ImageUrl(TImageUrl.New(Location, Detail)));

  raise Exception.CreateFmt('%s : File not managed', [Location]);
end;

class function TContentParams.Extract(const Value: string;
  var Detail: TImageDetail): string;
begin
  Detail := TImageDetail.auto;
  var index := Value.Trim.Tolower.IndexOf('detail');
  if index > -1 then
    begin
      Result := Value.Substring(0, index-1);
      var Details := Value.Substring(index, Value.Length).Replace(' ', '').Split(['=']);
      if Length(Details) = 2 then
        Detail := TImageDetail.Create(Details[1]);
    end
  else
    begin
      Result := Value.Trim;
    end;
end;

function TContentParams.ImageUrl(const Value: TImageUrl): TContentParams;
begin
  Result := TContentParams(Add('image_url', Value.Detach));
end;

function TContentParams.InputAudio(const Value: TInputAudio): TContentParams;
begin
  Result := TContentParams(Add('input_audio', Value.Detach));
end;

function TContentParams.Text(const Value: string): TContentParams;
begin
  Result := TContentParams(Add('text', Value));
end;

function TContentParams.&Type(const Value: string): TContentParams;
begin
  Result := TContentParams(Add('type', Value));
end;

{ TImageUrl }

function TImageUrl.Detail(const Value: TImageDetail): TImageUrl;
begin
  Result := TImageUrl(Add('detail', Value.ToString));
end;

class function TImageUrl.New(const PathLocation: string; const Detail: TImageDetail): TImageUrl;
begin
  Result := TImageUrl.Create.Url( GetUrlOrEncodeBase64(PathLocation) );
  if Detail <> TImageDetail.auto then
    Result := Result.Detail(Detail);
end;

function TImageUrl.Url(const Value: string): TImageUrl;
begin
  Result := TImageUrl(Add('url', Value));
end;

{ TInputAudio }

function TInputAudio.Data(const Value: string): TInputAudio;
begin
  Result := TInputAudio(Add('data', Value));
end;

function TInputAudio.Format(const Value: string): TInputAudio;
begin
  Result := TInputAudio(Add('format', Value));
end;

function TInputAudio.Format(const Value: TAudioFormat): TInputAudio;
begin
  Result := Format(Value.ToString);
end;

class function TInputAudio.New(const PathLocation: string): TInputAudio;
var
  MimeType: string;
begin
  if PathLocation.ToLower.StartsWith('http') then
    Result := TInputAudio.Create.Data(THttpx.LoadDataToBase64(PathLocation, MimeType)) else
    Result := TInputAudio.Create.Data(EncodeBase64(PathLocation, MimeType));
  Result := Result.Format(TAudioFormat.MimeTypeInput(MimeType));
end;

{ TToolCallsParams }

function TToolCallsParams.&Type(const Value: string): TToolCallsParams;
begin
  Result := TToolCallsParams(Add('type', TToolCalls.Create(Value).ToString));
end;

function TToolCallsParams.&Type(const Value: TToolCalls): TToolCallsParams;
begin
  Result := TToolCallsParams(Add('type', Value.ToString));
end;

function TToolCallsParams.&Function(const Name,
  Arguments: string): TToolCallsParams;
begin
  var Func := TFunctionParams.Create.Name(Name).Arguments(Arguments);
  Result := TToolCallsParams(Add('function', Func.Detach));
end;

function TToolCallsParams.Id(const Value: string): TToolCallsParams;
begin
  Result := TToolCallsParams(Add('id', Value));
end;

class function TToolCallsParams.New(const Id, Name,
  Arguments: string): TToolCallsParams;
begin
  Result := TToolCallsParams.Create.Id(Id).&Type(TToolCalls.tfunction).&Function(Name, Arguments);
end;

{ TFunctionParams }

function TFunctionParams.Arguments(const Value: string): TFunctionParams;
begin
  Result := TFunctionParams(Add('arguments', Value));
end;

function TFunctionParams.Name(const Value: string): TFunctionParams;
begin
  Result := TFunctionParams(Add('name', Value));
end;

{ TAssistantContentParams }

class function TAssistantContentParams.AddRefusal(const AType,
  Value: string): TAssistantContentParams;
begin
  Result := TAssistantContentParams.Create.&Type(AType).Refusal(Value);
end;

class function TAssistantContentParams.AddText(const AType,
  Value: string): TAssistantContentParams;
begin
  Result := TAssistantContentParams.Create.&Type(AType).Text(Value);
end;

function TAssistantContentParams.Refusal(
  const Value: string): TAssistantContentParams;
begin
  Result := TAssistantContentParams(Add('refusal', Value));
end;

function TAssistantContentParams.Text(
  const Value: string): TAssistantContentParams;
begin
  Result := TAssistantContentParams(Add('text', Value));
end;

function TAssistantContentParams.&Type(
  const Value: string): TAssistantContentParams;
begin
  Result := TAssistantContentParams(Add('type', Value));
end;

{ TPredictionParams }

function TPredictionParams.Content(
  const Value: string): TPredictionParams;
begin
  Result := TPredictionParams(Add('content', Value));
end;

function TPredictionParams.Content(
  const Value: TArray<TPredictionPartParams>): TPredictionParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TPredictionParams(Add('content', JSONArray));
end;

class function TPredictionParams.New(
  const Value: TArray<TPredictionPartParams>): TPredictionParams;
begin
  Result := TPredictionParams.Create.&Type('content').Content(Value);
end;

class function TPredictionParams.New(const Value: string): TPredictionParams;
begin
  Result := TPredictionParams.Create.&Type('content').Content(Value);
end;

function TPredictionParams.&Type(const Value: string): TPredictionParams;
begin
  Result := TPredictionParams(Add('type', Value));
end;

{ TPredictionPartParams }

class function TPredictionPartParams.New(const AType,
  Text: string): TPredictionPartParams;
begin
  Result := TPredictionPartParams.Create.&Type(AType).Text(Text);
end;

function TPredictionPartParams.Text(
  const Value: string): TPredictionPartParams;
begin
  Result := TPredictionPartParams(Add('text', Value));
end;

function TPredictionPartParams.&Type(
  const Value: string): TPredictionPartParams;
begin
  Result := TPredictionPartParams(Add('type', Value));
end;

{ TAudioParams }

function TAudioParams.Format(const Value: TAudioFormat): TAudioParams;
begin
  Result := TAudioParams(Add('format', Value.ToString));
end;

function TAudioParams.Voice(const Value: TChatVoice): TAudioParams;
begin
  Result := TAudioParams(Add('voice', Value.ToString));
end;

{ TToolChoiceParams }

function TToolChoiceParams.&Function(const Name: string): TToolChoiceParams;
begin
  Result := TToolChoiceParams(Add('function', TToolChoiceFunctionParams.Create.Name(Name).Detach));
end;

class function TToolChoiceParams.New(const Name: string): TToolChoiceParams;
begin
  Result := TToolChoiceParams.Create.&Type('function').&Function(Name);
end;

function TToolChoiceParams.&Type(const Value: string): TToolChoiceParams;
begin
  Result := TToolChoiceParams(Add('type', Value));
end;

{ TToolChoiceFunctionParams }

function TToolChoiceFunctionParams.Name(
  const Value: string): TToolChoiceFunctionParams;
begin
  Result := TToolChoiceFunctionParams(Add('name', Value));
end;

{ TChat }

destructor TChat.Destroy;
begin
  for var Item in FChoices do
    Item.Free;
  if Assigned(FUsage) then
    FUsage.Free;
  inherited;
end;

function TChat.GetCreated: Int64;
begin
  Result := TInt64OrNull(FCreated).ToInteger;
end;

function TChat.GetCreatedAsString: string;
begin
  Result := TInt64OrNull(FCreated).ToUtcDateString;
end;

{ TUsage }

destructor TUsage.Destroy;
begin
  if Assigned(FCompletionTokensDetails) then
    FCompletionTokensDetails.Free;
  if Assigned(FPromptTokensDetails) then
    FPromptTokensDetails.Free;
  inherited;
end;

{ TChoice }

destructor TChoice.Destroy;
begin
  if Assigned(FMessage) then
    FMessage.Free;
  if Assigned(FLogprobs) then
    FLogprobs.Free;
  if Assigned(FDelta) then
    FDelta.Free;
  inherited;
end;

{ Ttoolcall }

destructor Ttoolcall.Destroy;
begin
  if Assigned(FFunction) then
    FFunction.Free;
  inherited;
end;

{ TChatMessage }

destructor TChatMessage.Destroy;
begin
  for var Item in FToolCalls do
    Item.Free;
  for var Item in FAnnotations do
    Item.Free;
  if Assigned(FAudio) then
    FAudio.Free;
  inherited;
end;

{ TLogprobs }

destructor TLogprobs.Destroy;
begin
  for var Item in FContent do
    Item.Free;
  for var Item in FRefusal do
    Item.Free;
  inherited;
end;

{ TLogprobsDetail }

destructor TLogprobsDetail.Destroy;
begin
  for var Item in FTopLogprobs do
    Item.Free;
  inherited;
end;

{ TDelta }

destructor TDelta.Destroy;
begin
  for var Item in FToolCalls do
    Item.Free;
  inherited;
end;

{ TChatRoute }

procedure TChatRoute.AsynCreateStream(ParamProc: TProc<TChatParams>;
  CallBacks: TFunc<TAsynChatStream>);
begin
  var CallBackParams := TUseParamsFactory<TAsynChatStream>.CreateInstance(CallBacks);

  var Sender := CallBackParams.Param.Sender;
  var OnStart := CallBackParams.Param.OnStart;
  var OnSuccess := CallBackParams.Param.OnSuccess;
  var OnProgress := CallBackParams.Param.OnProgress;
  var OnError := CallBackParams.Param.OnError;
  var OnCancellation := CallBackParams.Param.OnCancellation;
  var OnDoCancel := CallBackParams.Param.OnDoCancel;
  var CancelTag := 0;

  var Task: ITask := TTask.Create(
          procedure()
          begin
            {--- Pass the instance of the current class in case no value was specified. }
            if not Assigned(Sender) then
              Sender := Self;

            {--- Trigger OnStart callback }
            if Assigned(OnStart) then
              TThread.Queue(nil,
                procedure
                begin
                  OnStart(Sender);
                end);
            try
              var Stop := False;

              {--- Processing }
              CreateStream(ParamProc,
                procedure (var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
                begin
                  {--- Check that the process has not been canceled }
                  if Assigned(OnDoCancel) and (CancelTag = 0) then
                    TThread.Queue(nil,
                        procedure
                        begin
                          Stop := OnDoCancel();
                          if Stop then
                            Inc(CancelTag);
                        end);
                  if Stop then
                    begin
                      {--- Trigger when processus was stopped }
                      if (CancelTag = 1) and Assigned(OnCancellation) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnCancellation(Sender);
                        end);
                      Inc(CancelTag);
                      Cancel := True;
                      Exit;
                    end;
                  if not IsDone and Assigned(Chat) then
                    begin
                      var LocalChat := Chat;
                      Chat := nil;

                      {--- Triggered when processus is progressing }
                      if Assigned(OnProgress) then
                        TThread.Synchronize(TThread.Current,
                        procedure
                        begin
                          try
                            OnProgress(Sender, LocalChat);
                          finally
                            {--- Makes sure to release the instance containing the data obtained
                                 following processing}
                            LocalChat.Free;
                          end;
                        end)
                     else
                       LocalChat.Free;
                    end
                  else
                  if IsDone then
                    begin
                      {--- Trigger OnEnd callback when the process is done }
                      if Assigned(OnSuccess) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnSuccess(Sender);
                        end);
                    end;
                end);
            except
              on E: Exception do
                begin
                  var Error := AcquireExceptionObject;
                  try
                    var ErrorMsg := (Error as Exception).Message;

                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(OnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        OnError(Sender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
          end);
  Task.Start;
end;

procedure TChatRoute.AsynDelete(const CompletionID: string;
  CallBacks: TFunc<TAsynChatDelete>);
begin
  with TAsynCallBackExec<TAsynChatDelete, TChatDelete>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TChatDelete
      begin
        Result := Self.Delete(CompletionID);
      end);
  finally
    Free;
  end;
end;

procedure TChatRoute.AsynGetCompletion(const CompletionID: string;
  CallBacks: TFunc<TAsynChat>);
begin
  with TAsynCallBackExec<TAsynChat, TChat>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TChat
      begin
        Result := Self.GetCompletion(CompletionID);
      end);
  finally
    Free;
  end;
end;

procedure TChatRoute.AsynGetMessages(const CompletionID: string;
  ParamProc: TProc<TUrlChatParams>; CallBacks: TFunc<TAsynChatMessages>);
begin
  with TAsynCallBackExec<TAsynChatMessages, TChatMessages>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TChatMessages
      begin
        Result := Self.GetMessages(CompletionID, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TChatRoute.AsynList(ParamProc: TProc<TUrlChatListParams>;
  CallBacks: TFunc<TAsynChatCompletion>);
begin
  with TAsynCallBackExec<TAsynChatCompletion, TChatCompletion>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TChatCompletion
      begin
        Result := Self.List(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TChatRoute.AsynUpdate(const CompletionID: string;
  ParamProc: TProc<TChatUpdateParams>; CallBacks: TFunc<TAsynChat>);
begin
   with TAsynCallBackExec<TAsynChat, TChat>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TChat
      begin
        Result := Self.Update(CompletionID, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TChatRoute.AsynGetMessages(const CompletionID: string;
  CallBacks: TFunc<TAsynChatMessages>);
begin
  with TAsynCallBackExec<TAsynChatMessages, TChatMessages>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TChatMessages
      begin
        Result := Self.GetMessages(CompletionID);
      end);
  finally
    Free;
  end;
end;

procedure TChatRoute.AsynCreate(ParamProc: TProc<TChatParams>;
  CallBacks: TFunc<TAsynChat>);
begin
  with TAsynCallBackExec<TAsynChat, TChat>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TChat
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TChatRoute.Create(ParamProc: TProc<TChatParams>): TChat;
begin
  Result := API.Post<TChat, TChatParams>('chat/completions', ParamProc);
end;

procedure TChatRoute.CreateParallel(ParamProc: TProc<TBundleParams>;
  CallBacks: TFunc<TAsynBundleList>);
var
  Tasks: TArray<ITask>;
  BundleParams: TBundleParams;
  ReasoningEffort: string;
begin
  BundleParams := TBundleParams.Create;
  try
    if not Assigned(ParamProc) then
      raise Exception.Create('The lambda can''t be null');

    ParamProc(BundleParams);
    var Bundle := TBundleList.Create;
    var Ranking := 0;
    var ErrorExists := False;
    var Prompts := BundleParams.GetPrompt;
    var Counter := Length(Prompts);

    {--- Set the reasoning effort if necessary }
    if IsReasoningModel(BundleParams.GetModel) then
      ReasoningEffort := BundleParams.GetReasoningEffort
    else
      ReasoningEffort := EmptyStr;

    if Assigned(CallBacks.OnStart) then
      CallBacks.OnStart(CallBacks.Sender);

    SetLength(Tasks, Length(Prompts));
    for var index := 0 to Pred(Length(Prompts)) do
      begin
        Tasks[index] := TTask.Run(
          procedure
          begin
            var Buffer := Bundle.Add(index + 1);
            Buffer.Prompt := Prompts[index];
            try
              var Chat := Create(
                procedure (Params: TChatParams)
                begin
                  {--- Set the model for the process }
                  Params.Model(BundleParams.GetModel);

                  {--- If reasoning model then set de reasoning parameters }
                  if not ReasoningEffort.IsEmpty then
                    Params.ReasoningEffort(ReasoningEffort);

                  {--- Set the current prompt and developer message }
                  Params.Messages([
                    TMessagePayload.Developer(BundleParams.GetSystem),
                    TMessagePayload.User(Buffer.Prompt)
                  ]);

                  {--- Set the web search parameters if necessary }
                  if not BundleParams.GetSearchSize.IsEmpty then
                    begin
                      {---- Set the location if necessary }
                      if not BundleParams.GetCity.IsEmpty or
                         not BundleParams.GetCountry.IsEmpty then
                        begin
                          var Locate := TUserLocationApproximate.Create;

                          {--- Process for the city location }
                          if not BundleParams.GetCity.IsEmpty then
                            Locate.City(BundleParams.GetCity);

                            {--- Process for the country location }
                          if not BundleParams.GetCountry.IsEmpty then
                            Locate.Country(BundleParams.GetCountry);

                          {--- Set the web search options }
                          Params.WebSearchOptions(BundleParams.GetSearchSize, Locate);
                        end
                      else
                        begin
                          {--- Set the web search options }
                          Params.WebSearchOptions(BundleParams.GetSearchSize);
                        end;
                    end;
                end);
              Inc(Ranking);
              Buffer.FinishIndex := Ranking;
              Buffer.Response := Chat.Choices[0].Message.Content;
              Buffer.Chat := Chat;
            except
              on E: Exception do
                begin
                  {--- Catch the exception }
                  var Error := AcquireExceptionObject;
                  ErrorExists := True;
                  try
                    var ErrorMsg := (Error as Exception).Message;
                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(CallBacks.OnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        CallBacks.OnError(CallBacks.Sender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
          end);

        if ErrorExists then
          Continue;

        {--- TTask.WaitForAll is not used due to a memory leak in TLightweightEvent/TCompleteEventsWrapper.
             See report RSP-12462 and RSP-25999. }
        TTaskHelper.ContinueWith(Tasks[Index],
          procedure
          begin
            Dec(Counter);
            if Counter = 0 then
              begin
                try
                  if not ErrorExists and Assigned(CallBacks.OnSuccess) then
                    CallBacks.OnSuccess(CallBacks.Sender, Bundle);
                finally
                  Bundle.Free;
                end;
              end;
          end);
        {--- Need a delay, otherwise the process runs only with the first task. }
        Sleep(30);
      end;
  finally
    BundleParams.Free;
  end;
end;

function TChatRoute.CreateStream(ParamProc: TProc<TChatParams>;
  Event: TStreamCallbackEvent<TChat>): Boolean;
begin
  var Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Result := API.Post<TChatParams>('chat/completions', ParamProc, Response,
      {--- Please refer to the header note for detailed information on the processing of streamed messages. }
      TOpenAIStream<TChat>.CreateInstance(Response, Event, TApiDeserializer.Parse<TChat>).OnStream);
  finally
    Response.Free;
  end;
end;

function TChatRoute.Delete(const CompletionID: string): TChatDelete;
begin
  Result := API.Delete<TChatDelete>('chat/completions/' + CompletionID);
end;

function TChatRoute.List(ParamProc: TProc<TUrlChatListParams>): TChatCompletion;
begin
  Result := API.Get<TChatCompletion, TUrlChatListParams>('chat/completions', ParamProc);
end;

function TChatRoute.Update(const CompletionID: string;
  ParamProc: TProc<TChatUpdateParams>): TChat;
begin
  Result := API.Post<TChat, TChatUpdateParams>('chat/completions/' + CompletionID, ParamProc);
end;

function TChatRoute.GetCompletion(const CompletionID: string): TChat;
begin
  Result := API.Get<TChat>('chat/completions/' + CompletionID);
end;

function TChatRoute.GetMessages(const CompletionID: string;
  ParamProc: TProc<TUrlChatParams>): TChatMessages;
begin
  Result := API.Get<TChatMessages, TUrlChatParams>('chat/completions/' + CompletionID + '/messages', ParamProc);
end;

function TChatRoute.GetMessages(const CompletionID: string): TChatMessages;
begin
  Result := API.Get<TChatMessages>('chat/completions/' + CompletionID + '/messages');
end;

{ TAudio }

function TAudio.GetStream: TStream;
begin
  {--- Create a memory stream to write the decoded content. }
  Result := TMemoryStream.Create;
  try
    {--- Convert the base-64 string directly into the memory stream. }
    DecodeBase64ToStream(Data, Result)
  except
    Result.Free;
    raise;
  end;
end;

procedure TAudio.SaveToFile(const FileName: string; const RaiseError: Boolean);
begin
  case RaiseError of
    True :
      if FileName.Trim.IsEmpty then
        raise Exception.Create('File record aborted. SaveToFile requires a filename.');
    else
      if FileName.Trim.IsEmpty then
        Exit;
  end;

  try
    Self.FFileName := FileName;
    {--- Perform the decoding operation and save it into the file specified by the FileName parameter. }
    DecodeBase64ToFile(Data, FileName)
  except
    raise;
  end;
end;

{ TAudioData }

function TAudioData.GetExpiresAt: Int64;
begin
  Result := TInt64OrNull(FExpiresAt).ToInteger;
end;

function TAudioData.GetExpiresAtAsString: string;
begin
  Result := TInt64OrNull(FExpiresAt).ToUtcDateString;
end;

{ TUserLocation }

function TUserLocation.Approximate(
  const Value: TUserLocationApproximate): TUserLocation;
begin
  Result := TUserLocation(Add('approximate', Value.Detach));
end;

function TUserLocation.Approximate(const Value: TJSONObject): TUserLocation;
begin
  Result := TUserLocation(Add('approximate', Value));
end;

class function TUserLocation.New(const Value: TJSONObject): TUserLocation;
begin
  Result := TUserLocation.Create.&Type('approximate').Approximate(Value);
end;

class function TUserLocation.New(const Value: TUserLocationApproximate): TUserLocation;
begin
  Result := TUserLocation.Create.&Type('approximate').Approximate(Value);
end;

function TUserLocation.&Type(const Value: string): TUserLocation;
begin
  if Value.Trim.ToLower <> 'approximate' then
    raise Exception.Create('User_location type : always approximate');
  Result := TUserLocation(Add('type', Value));
end;

{ TUserLocationApproximate }

function TUserLocationApproximate.City(
  const Value: string): TUserLocationApproximate;
begin
  Result := TUserLocationApproximate(Add('city', Value));
end;

function TUserLocationApproximate.Country(
  const Value: string): TUserLocationApproximate;
begin
  Result := TUserLocationApproximate(Add('country', Value));
end;

function TUserLocationApproximate.Region(
  const Value: string): TUserLocationApproximate;
begin
  Result := TUserLocationApproximate(Add('region', Value));
end;

function TUserLocationApproximate.Timezone(
  const Value: string): TUserLocationApproximate;
begin
  Result := TUserLocationApproximate(Add('timezone', Value));
end;

{ TAnnotation }

destructor TAnnotation.Destroy;
begin
  if Assigned(FUrlCitation) then
    FUrlCitation.Free;
  inherited;
end;

{ TChatCompletionMessage }

destructor TChatCompletionMessage.Destroy;
begin
  for var Item in FAnnotations do
    Item.Free;
  if Assigned(FAudio) then
    FAudio.Free;
  for var Item in FToolCalls do
    Item.Free;
  inherited;
end;

{ TChatMessages }

destructor TChatMessages.Destroy;
begin
  for var Item in FData do
    Item.Free;
  inherited;
end;

{ TUrlChatParams }

function TUrlChatParams.After(const Value: string): TUrlChatParams;
begin
  Result := TUrlChatParams(Add('after', Value));
end;

function TUrlChatParams.Limit(const Value: Integer): TUrlChatParams;
begin
  Result := TUrlChatParams(Add('limit', Value));
end;

function TUrlChatParams.Order(const Value: string): TUrlChatParams;
begin
  Result := TUrlChatParams(Add('order', Value));
end;

{ TUrlChatListParams }

function TUrlChatListParams.After(const Value: string): TUrlChatListParams;
begin
  Result := TUrlChatListParams(Add('after', Value));
end;

function TUrlChatListParams.Limit(const Value: Integer): TUrlChatListParams;
begin
  Result := TUrlChatListParams(Add('limit', Value));
end;

function TUrlChatListParams.Metadata(
  const Value: TJSONObject): TUrlChatListParams;
begin
  if not Assigned(Value) then
    Exit(Self);
  Result := TUrlChatListParams(Add('metadata', Format('{"metadata": %s}', [Value.ToJSON])));
  Value.Free;
end;

function TUrlChatListParams.Model(const Value: string): TUrlChatListParams;
begin
  Result := TUrlChatListParams(Add('model', Value));
end;

function TUrlChatListParams.Order(const Value: string): TUrlChatListParams;
begin
  Result := TUrlChatListParams(Add('order', Value));
end;

{ TChatCompletion }

destructor TChatCompletion.Destroy;
begin
  for var Item in FData do
    Item.Free;
  inherited;
end;

{ TChatUpdateParams }

function TChatUpdateParams.Metadata(
  const Value: TJSONObject): TChatUpdateParams;
begin
  Result := TChatUpdateParams(Add('metadata', Value));
end;

end.

unit GenAI.Chat.StreamingInterface;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.Net.HttpClient;

type
  /// <summary>
  /// Defines a reference to a procedure that handles streaming callback events.
  /// </summary>
  /// <typeparam name="T">
  /// The type of the class that represents a chunk of streaming data.
  /// Must be a class with a parameterless constructor.
  /// </typeparam>
  TStreamCallbackEvent<T: class, constructor> = reference to procedure(var Chunk: T; IsDone: Boolean; var Cancel: Boolean);

  /// <summary>
  /// Represents a callback interface for handling streaming data from the OpenAI API.
  /// </summary>
  IStreamCallback = interface
    ['{4F5F8B0D-0A08-4C47-8675-48F8D055F504}']
    /// <summary>
    /// Retrieves the callback method that is invoked when streaming data is received.
    /// </summary>
    /// <returns>
    /// A <see cref="TReceiveDataCallback"/> delegate that processes the streaming data.
    /// </returns>
    function GetOnStream: TReceiveDataCallback;
    /// <summary>
    /// Gets the callback method that is invoked when streaming data is received.
    /// </summary>
    /// <value>
    /// A <see cref="TReceiveDataCallback"/> delegate that processes the streaming data.
    /// </value>
    property OnStream: TReceiveDataCallback read GetOnStream;
  end;

implementation

end.

unit GenAI.Chat.StreamingOpenAI;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.Json, System.Net.HttpClient, GenAI.Chat.StreamingInterface,
  GenAI.API;

type
  /// <summary>
  /// Represents a streaming callback handler for OpenAI chat completions.
  /// </summary>
  /// <typeparam name="T">
  /// The type of the class that will be used to parse the streaming data.
  /// Must be a class with a parameterless constructor.
  /// </typeparam>
  TOpenAIStream<T: class, constructor> = class(TInterfacedObject, IStreamCallback)
  private
    FResponse: TStringStream;
    FLineFeedPosition: Integer;
    FEvent: TStreamCallbackEvent<T>;
    Parse: TParserMethod<T>;
    /// <summary>
    /// Gets the callback method that processes received streaming data.
    /// </summary>
    /// <returns>
    /// A <see cref="TReceiveDataCallback"/> delegate that handles the streaming data.
    /// </returns>
    function GetOnStream: TReceiveDataCallback;
  public
    /// <summary>
    /// Initializes a new instance of the <see cref="TOpenAIStream{T}"/> class.
    /// </summary>
    /// <param name="AResponse">
    /// A <see cref="TStringStream"/> that contains the streaming response data.
    /// </param>
    /// <param name="AEvent">
    /// A callback event that is triggered when a new chunk of data is received.
    /// </param>
    /// <param name="AParser">
    /// A method used to parse the incoming JSON data into an instance of type <typeparamref name="T"/>.
    /// </param>
    /// <exception cref="Exception">
    /// Thrown if the <paramref name="AParser"/> parameter is not assigned.
    /// </exception>
    constructor Create(AResponse: TStringStream; AEvent: TStreamCallbackEvent<T>; AParser: TParserMethod<T>);
    /// <summary>
    /// Creates a new instance of <see cref="TOpenAIStream{T}"/> and returns it as an <see cref="IStreamCallback"/>.
    /// </summary>
    /// <param name="AResponse">
    /// A <see cref="TStringStream"/> that contains the streaming response data.
    /// </param>
    /// <param name="AEvent">
    /// A callback event that is triggered when a new chunk of data is received.
    /// </param>
    /// <param name="AParser">
    /// A method used to parse the incoming JSON data into an instance of type <typeparamref name="T"/>.
    /// </param>
    /// <returns>
    /// An instance of <see cref="IStreamCallback"/> that handles the streaming data.
    /// </returns>
    /// <exception cref="Exception">
    /// Thrown if the <paramref name="AParser"/> parameter is not assigned.
    /// </exception>
    class function CreateInstance(AResponse: TStringStream; AEvent: TStreamCallbackEvent<T>; AParser: TParserMethod<T>): IStreamCallback;
  end;

implementation

{ TOpenAIStream<T> }

constructor TOpenAIStream<T>.Create(AResponse: TStringStream; AEvent: TStreamCallbackEvent<T>;
  AParser: TParserMethod<T>);
begin
  inherited Create;
  FResponse := AResponse;
  FLineFeedPosition := 0;
  FEvent := AEvent;
  Parse := AParser;
end;

class function TOpenAIStream<T>.CreateInstance(AResponse: TStringStream;
  AEvent: TStreamCallbackEvent<T>; AParser: TParserMethod<T>): IStreamCallback;
begin
  if not Assigned(AParser) then
    raise Exception.Create('Streaming failed. A deserialization method is required.');
  Result := TOpenAIStream<T>.Create(AResponse, AEvent, AParser);
end;

function TOpenAIStream<T>.GetOnStream: TReceiveDataCallback;

{--- Refer to https://platform.openai.com/docs/api-reference/chat/streaming }

// The chat completion chunk object
// data: {"id":"chatcmpl-123","object":"chat.completion.chunk","created":1694268190,"model":"gpt-4o-mini", "system_fingerprint": "fp_44709d6fcb", "choices":[{"index":0,"delta":{"role":"assistant","content":""},"logprobs":null,"finish_reason":null}]}
// data: {"id":"chatcmpl-123","object":"chat.completion.chunk","created":1694268190,"model":"gpt-4o-mini", "system_fingerprint": "fp_44709d6fcb", "choices":[{"index":0,"delta":{"content":"Hello"},"logprobs":null,"finish_reason":null}]}
// ...
// data: [DONE]

begin
  Result :=
    procedure(const Sender: TObject; AContentLength, AReadCount: Int64; var AAbort: Boolean)
    var
      ResponseBuffer: string;
      CurrentLine: string;
      IsDone: Boolean;
      Data: string;
      Chunk: T;
      LineFeed: Integer;
      NewBuffer: string;
    begin
      try
        {--- Retrieving the current contents of the buffer }
        ResponseBuffer := FResponse.DataString;
      except
        on E: EEncodingError do
          Exit;
      end;

      {--- Find the position of the first line break from the stored position }
      LineFeed := ResponseBuffer.IndexOf(#10, FLineFeedPosition);
      while LineFeed >= 0 do
        begin
          {--- Extraction and cleaning of the current line }
          CurrentLine := ResponseBuffer.Substring(FLineFeedPosition, LineFeed - FLineFeedPosition).Trim([' ', #13, #10]);
          {--- Update position in buffer }
          FLineFeedPosition := LineFeed + 1;

          {--- If the line is empty, go to the next one }
          if CurrentLine.IsEmpty then
            begin
              LineFeed := ResponseBuffer.IndexOf(#10, FLineFeedPosition);
              Continue;
            end;

          {--- Data processing: removal of the 'data:' prefix if present }
          if CurrentLine.StartsWith('data: ') then
            Data := CurrentLine.Substring(6).Trim
          else
            Data := CurrentLine;

          {--- Checking the end of the stream }
          IsDone := Data.ToUpper = '[DONE]';

          Chunk := nil;
          if not IsDone then
            begin
              try
                Chunk := Parse(Data);
              except
                on E: Exception do
                  Chunk := nil;
              end;
            end;

          {--- Call the callback event with the processed chunk and the completion flag }
          if Assigned(FEvent) then
            begin
              try
                FEvent(Chunk, IsDone, AAbort);
              finally
                {--- Clean up the chunk object }
                if Assigned(Chunk) then
                  Chunk.Free;
              end;
            end;

          if IsDone then
            Break;

          {--- Finding the next line break }
          LineFeed := ResponseBuffer.IndexOf(#10, FLineFeedPosition);
        end;

      {--- Buffer cleaning
           Only the unprocessed fragment is kept in the stream }
      if FLineFeedPosition > 0 then
        begin
          NewBuffer := ResponseBuffer.Substring(FLineFeedPosition);
          {--- Resetting stream content }
          FResponse.Size := 0;
          if NewBuffer <> '' then
            FResponse.WriteString(NewBuffer);
          {--- Reset playback position for next pass }
          FLineFeedPosition := 0;
        end;
    end;
end;


end.

unit GenAI.Completions;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

(*
  --- NOTE ---
    Regarding the management of streamed messages.

    This unit provides  an abstraction  for managing streaming  data from APIs such
    as OpenAI  or Anthropic. The "GenAI.Chat.StreamingInterface" defines a flexible
    interface for handling real-time data chunks, enabling the application to react
    to incoming data dynamically and efficiently.

    Key Features:
      - Streaming Management: Processes  data  in real-time  by  handling chunks as
        they arrive.

      - Event-driven Design: Utilizes  callback mechanisms  to provide flexible and
        dynamic responses to streaming events.

      - Adaptable Architecture: Supports experimentation  with  different streaming
        techniques, such as OpenAI's sequential streaming or Anthropic's contextual
        approaches, allowing easy integration of various streaming models.

      - Control and Flexibility: Enables custom chunk processing, flow control, and
        integration with  user-defined logic, improving  user experience and system
        responsiveness.

    This interface lays the groundwork  for implementing and  comparing alternative
    streaming techniques while maintaining a clean, modular, and extensible
    architecture.
*)


interface

uses
  System.SysUtils, System.Classes, System.Threading, System.JSON, REST.Json.Types,
  REST.JsonReflect,
  GenAI.API.Params, GenAI.API, GenAI.Consts, GenAI.Types, GenAI.Async.Params,
  GenAI.Async.Support, GenAI.Chat.StreamingInterface, GenAI.Chat.StreamingOpenAI,
  GenAI.Chat;

type
  /// <summary>
  /// Represents parameters for generating text completions using a specified model.
  /// This class provides a fluent interface to set various parameters like model,
  /// prompt, maximum tokens, and more that influence the behavior of the completion
  /// generation process.
  /// </summary>
  /// <remarks>
  /// Instances of this class can be customized using its methods to set values for
  /// different parameters like echo, stop sequences, penalties, etc. Each method
  /// modifies the instance and returns the same modified instance, allowing for
  /// method chaining.
  /// </remarks>
  TCompletionParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the model identifier used for generating completions.
    /// </summary>
    /// <param name="Value">The identifier of the model to use.</param>
    /// <returns>The instance of <c>TCompletionParams</c> for chaining.</returns>
    function Model(const Value: string): TCompletionParams;
    /// <summary>
    /// Sets the initial input prompt for the model to generate text from.
    /// </summary>
    /// <param name="Value">The text prompt to use as input for the model.</param>
    /// <returns>The instance of <c>TCompletionParams</c> for chaining.</returns>
    function Prompt(const Value: string): TCompletionParams; overload;
    /// <summary>
    /// Sets multiple initial input prompts for the model to generate text from.
    /// </summary>
    /// <param name="Value">An array of text prompts to use as input for the model.</param>
    /// <returns>The instance of <c>TCompletionParams</c> for chaining.</returns>
    function Prompt(const Value: TArray<string>): TCompletionParams; overload;
    /// <summary>
    /// Sets the number of best completions to generate before choosing the final output.
    /// </summary>
    /// <param name="Value">The number of completions to generate.</param>
    /// <returns>The instance of <c>TCompletionParams</c> for chaining.</returns>
    function BestOf(const Value: Integer): TCompletionParams;
    /// <summary>
    /// Configures whether to include the original prompt in the response along with the completion.
    /// </summary>
    /// <param name="Value">True to include the prompt in the output, false otherwise.</param>
    /// <returns>The instance of <c>TCompletionParams</c> for chaining.</returns>
    function Echo(const Value: Boolean): TCompletionParams;
    /// <summary>
    /// Sets a penalty to discourage repetition of tokens based on their frequency in the generated text.
    /// </summary>
    /// <param name="Value">The penalty value; must be between -2.0 and 2.0.</param>
    /// <returns>The instance of <c>TCompletionParams</c> for chaining.</returns>
    function FrequencyPenalty(const Value: Double): TCompletionParams;
    /// <summary>
    /// Modifies the likelihood of specific tokens appearing in the completion.
    /// </summary>
    /// <param name="Value">A JSON object mapping token IDs to bias values.</param>
    /// <returns>The instance of <c>TCompletionParams</c> for chaining.</returns>
    function LogitBias(const Value: TJSONObject): TCompletionParams;
    /// <summary>
    /// Includes log probabilities of the most likely tokens in the response.
    /// </summary>
    /// <param name="Value">The number of top tokens to include probabilities for, up to 5.</param>
    /// <returns>The instance of <c>TCompletionParams</c> for chaining.</returns>
    function Logprobs(const Value: Integer): TCompletionParams;
    /// <summary>
    /// Sets the maximum number of tokens that the model can generate in the completion.
    /// </summary>
    /// <param name="Value">The maximum number of tokens to generate.</param>
    /// <returns>The instance of <c>TCompletionParams</c> for chaining.</returns>
    function MaxTokens(const Value: Integer): TCompletionParams;
    /// <summary>
    /// Sets how many completions to generate for each prompt.
    /// </summary>
    /// <param name="Value">The number of completions to generate.</param>
    /// <returns>The instance of <c>TCompletionParams</c> for chaining.</returns>
    function N(const Value: Integer): TCompletionParams;
    /// <summary>
    /// Sets a penalty to encourage the model to introduce new topics based on whether they appear in the text so far.
    /// </summary>
    /// <param name="Value">The penalty value; must be between -2.0 and 2.0.</param>
    /// <returns>The instance of <c>TCompletionParams</c> for chaining.</returns>
    function PresencePenalty(const Value: Double): TCompletionParams;
    /// <summary>
    /// Specifies a seed for deterministic generation. Repeated requests with the same seed and parameters should return the same result.
    /// </summary>
    /// <param name="Value">The seed value for deterministic generation.</param>
    /// <returns>The instance of <c>TCompletionParams</c> for chaining.</returns>
    function Seed(const Value: Integer): TCompletionParams;
    /// <summary>
    /// Sets the sequences where the model will stop generating further tokens.
    /// </summary>
    /// <param name="Value">The stop sequence or sequences to use.</param>
    /// <returns>The instance of <c>TCompletionParams</c> for chaining.</returns>
    function Stop(const Value: string): TCompletionParams; overload;
    /// <summary>
    /// Sets the sequences where the model will stop generating further tokens.
    /// </summary>
    /// <param name="Value">The stop sequence or sequences to use.</param>
    /// <returns>The instance of <c>TCompletionParams</c> for chaining.</returns>
    function Stop(const Value: TArray<string>): TCompletionParams; overload;
    /// <summary>
    /// Enables streaming of the completion generation process.
    /// </summary>
    /// <param name="Value">Set to true to stream back partial progress of completion generation.</param>
    /// <returns>The instance of <c>TCompletionParams</c> for chaining.</returns>
    function Stream(const Value: Boolean = True): TCompletionParams;
    /// <summary>
    /// Sets options for streaming responses, applicable only when streaming is enabled.
    /// </summary>
    /// <param name="Value">Boolean to determine if usage statistics should be included in the stream.</param>
    /// <returns>The instance of <c>TCompletionParams</c> for chaining.</returns>
    function StreamOptions(const Value: Boolean): TCompletionParams;
    /// <summary>
    /// Sets the suffix that comes after the completion of inserted text.
    /// </summary>
    /// <param name="Value">The suffix text to append to the completion.</param>
    /// <returns>The instance of <c>TCompletionParams</c> for chaining.</returns>
    function Suffix(const Value: string): TCompletionParams;
    /// <summary>
    /// Sets the sampling temperature for generating completions, influencing randomness.
    /// </summary>
    /// <param name="Value">The temperature value; must be between 0 and 2.</param>
    /// <returns>The instance of <c>TCompletionParams</c> for chaining.</returns>
    function Temperature(const Value: Double): TCompletionParams;
    /// <summary>
    /// Sets the nucleus sampling value, an alternative to sampling with temperature, to narrow down the token choices based on probability mass.
    /// </summary>
    /// <param name="Value">The top probability mass percentage to consider for token choices.</param>
    /// <returns>The instance of <c>TCompletionParams</c> for chaining.</returns>
    function TopP(const Value: Double): TCompletionParams;
    /// <summary>
    /// Identifies the user making the request, useful for monitoring and abuse prevention.
    /// </summary>
    /// <param name="Value">A unique identifier representing the end-user.</param>
    /// <returns>The instance of <c>TCompletionParams</c> for chaining.</returns>
    function User(const Value: string): TCompletionParams;
  end;

  /// <summary>
  /// Represents the log probabilities and associated metadata for tokens generated in a text completion.
  /// This class is part of the detailed response structure providing insights into the model's token generation process.
  /// </summary>
  TChoicesLogprobs = class
  private
    [JsonNameAttribute('text_offset')]
    FTextOffset: TArray<Int64>;
    [JsonNameAttribute('token_logprobs')]
    FTokenLogprobs: TArray<Double>;
    FTokens: TArray<string>;
  public
    /// <summary>
    /// Gets or sets the text offsets of tokens. Each offset corresponds to the position of the token in the original input text.
    /// </summary>
    property TextOffset: TArray<Int64> read FTextOffset write FTextOffset;
    /// <summary>
    /// Gets or sets the log probabilities of each token, providing a measure of how likely each token was to be generated next.
    /// </summary>
    property TokenLogprobs: TArray<Double> read FTokenLogprobs write FTokenLogprobs;
    /// <summary>
    /// Gets or sets the tokens that were generated by the model during the completion process.
    /// </summary>
    property Tokens: TArray<string> read FTokens write FTokens;
  end;

  /// <summary>
  /// Represents a single choice from the set of completions generated by the model.
  /// This class includes details about the text generated, the reasons for stopping,
  /// and probabilities associated with the tokens.
  /// </summary>
  TCompletionChoice = class
  private
    [JsonNameAttribute('finish_reason')]
    FFinishReason: string;
    FIndex: Int64;
    FLlogprobs: TChoicesLogprobs;
    FText: string;
  public
    /// <summary>
    /// Gets or sets the reason why the token generation was stopped, e.g., 'length', 'stop', or 'content_filter'.
    /// </summary>
    property FinishReason: string read FFinishReason write FFinishReason;
    /// <summary>
    /// Gets or sets the index of this choice among the other choices generated during the request.
    /// </summary>
    property Index: Int64 read FIndex write FIndex;
    /// <summary>
    /// Gets or sets the log probabilities of the tokens that make up this completion choice.
    /// </summary>
    property Llogprobs: TChoicesLogprobs read FLlogprobs write FLlogprobs;
    /// <summary>
    /// Gets or sets the text of the completion generated by the model.
    /// </summary>
    property Text: string read FText write FText;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents the response from the completion API containing all generated choices,
  /// their details, and associated system information.
  /// This class extends TJSONFingerprint to include metadata about the API interaction.
  /// </summary>
  TCompletion = class(TJSONFingerprint)
  private
    FId: string;
    FChoices: TArray<TCompletionChoice>;
    FCreated: TInt64OrNull;
    FModel: string;
    [JsonNameAttribute('system_fingerprint')]
    FSystemFingerprint: string;
    FObject: string;
    FUsage: TUsage;
  private
    function GetCreatedAsString: string;
    function GetCreated: Int64;
  public
    /// <summary>
    /// Gets or sets the unique identifier for the completion.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Gets or sets the array of completion choices generated for the prompt.
    /// </summary>
    property Choices: TArray<TCompletionChoice> read FChoices write FChoices;
    /// <summary>
    /// Gets the timestamp of when the completion was created.
    /// </summary>
    property Created: Int64 read GetCreated;
    /// <summary>
    /// Gets the timestamp of when the completion was created as a string.
    /// </summary>
    property CreatedAsString: string read GetCreatedAsString;
    /// <summary>
    /// Gets or sets the model used to generate the completion.
    /// </summary>
    property Model: string read FModel write FModel;
    /// <summary>
    /// Gets or sets the system fingerprint that represents the backend configuration used for the completion.
    /// </summary>
    property SystemFingerprint: string read FSystemFingerprint write FSystemFingerprint;
    /// <summary>
    /// Gets or sets the object type, which is always 'text_completion'.
    /// </summary>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// Gets or sets the usage statistics for the completion request, detailing token and compute usage.
    /// </summary>
    property Usage: TUsage read FUsage write FUsage;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TCompletion</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynCompletion</c> type extends the <c>TAsynParams&lt;TCompletion&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynCompletion = TAsynCallBack<TCompletion>;

  /// <summary>
  /// Manages asynchronous streaming chat callBacks for a chat request using <c>TCompletion</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynCompletionStream</c> type extends the <c>TAsynStreamParams&lt;TCompletion&gt;</c> record to support the lifecycle of an asynchronous streaming chat operation.
  /// It provides callbacks for different stages, including when the operation starts, progresses with new data chunks, completes successfully, or encounters an error.
  /// This structure is ideal for handling scenarios where the chat response is streamed incrementally, providing real-time updates to the user interface.
  /// </remarks>
  TAsynCompletionStream = TAsynStreamCallBack<TCompletion>;

  /// <summary>
  /// Manages the routes for creating and streaming completions using the OpenAI API.
  /// This class handles both synchronous and asynchronous operations to interact with the API
  /// for generating text completions.
  /// </summary>
  TCompletionRoute = class(TGenAIRoute)
    /// <summary>
    /// Executes an asynchronous creation of text completions, providing a callback mechanism to handle
    /// the response as soon as it becomes available.
    /// </summary>
    /// <param name="ParamProc">A procedure that configures the parameters for the completion request.</param>
    /// <param name="CallBacks">A function returning TAsynCompletion, which contains callbacks for different stages
    /// of the request lifecycle.</param>
    procedure AsynCreate(const ParamProc: TProc<TCompletionParams>; CallBacks: TFunc<TAsynCompletion>);
    /// <summary>
    /// Executes an asynchronous streaming creation of text completions. This method streams back partial
    /// progress of the completion generation, allowing real-time updates.
    /// </summary>
    /// <param name="ParamProc">A procedure that configures the parameters for the completion request.</param>
    /// <param name="CallBacks">A function returning TAsynCompletionStream, which provides a structured
    /// approach to handle streaming data along with complete responses.</param>
    procedure AsynCreateStream(ParamProc: TProc<TCompletionParams>; CallBacks: TFunc<TAsynCompletionStream>);
    /// <summary>
    /// Creates a completion synchronously and returns a TCompletion object containing the results
    /// and associated metadata.
    /// </summary>
    /// <param name="ParamProc">A procedure to configure the parameters for the completion request.</param>
    /// <returns>A TCompletion object populated with the API response.</returns>
    function Create(const ParamProc: TProc<TCompletionParams>): TCompletion;
    /// <summary>
    /// Initiates a streaming request for generating completions. This method is designed for real-time
    /// interactions where the response is incrementally provided as it is generated.
    /// </summary>
    /// <param name="ParamProc">A procedure to configure the parameters for the completion request.</param>
    /// <param name="Event">A callback event that is triggered as streaming data is received.</param>
    /// <returns>Boolean indicating if the streaming was initiated successfully.</returns>
    function CreateStream(ParamProc: TProc<TCompletionParams>; Event: TStreamCallbackEvent<TCompletion>): Boolean;
  end;

implementation

{ TCompletionParams }

function TCompletionParams.BestOf(const Value: Integer): TCompletionParams;
begin
  Result := TCompletionParams(Add('best_of', Value));
end;

function TCompletionParams.Echo(const Value: Boolean): TCompletionParams;
begin
  Result := TCompletionParams(Add('echo', Value));
end;

function TCompletionParams.FrequencyPenalty(
  const Value: Double): TCompletionParams;
begin
  Result := TCompletionParams(Add('frequency_penalty', Value));
end;

function TCompletionParams.LogitBias(
  const Value: TJSONObject): TCompletionParams;
begin
  Result := TCompletionParams(Add('logit_bias', Value));
end;

function TCompletionParams.Logprobs(const Value: Integer): TCompletionParams;
begin
  Result := TCompletionParams(Add('logprobs', Value));
end;

function TCompletionParams.MaxTokens(const Value: Integer): TCompletionParams;
begin
  Result := TCompletionParams(Add('max_tokens', Value));
end;

function TCompletionParams.Model(const Value: string): TCompletionParams;
begin
  Result := TCompletionParams(Add('model', Value));
end;

function TCompletionParams.N(const Value: Integer): TCompletionParams;
begin
  Result := TCompletionParams(Add('n', Value));
end;

function TCompletionParams.Prompt(const Value: string): TCompletionParams;
begin
  Result := TCompletionParams(Add('prompt', Value));
end;

function TCompletionParams.PresencePenalty(
  const Value: Double): TCompletionParams;
begin
  Result := TCompletionParams(Add('presence_penalty', Value));
end;

function TCompletionParams.Prompt(
  const Value: TArray<string>): TCompletionParams;
begin
  Result := TCompletionParams(Add('prompt', Value));
end;

function TCompletionParams.Seed(const Value: Integer): TCompletionParams;
begin
  Result := TCompletionParams(Add('seed', Value));
end;

function TCompletionParams.Stop(const Value: TArray<string>): TCompletionParams;
begin
  Result := TCompletionParams(Add('stop', Value));
end;

function TCompletionParams.Stop(const Value: string): TCompletionParams;
begin
  Result := TCompletionParams(Add('stop', Value));
end;

function TCompletionParams.Stream(const Value: Boolean): TCompletionParams;
begin
  Result := TCompletionParams(Add('stream', Value));
end;

function TCompletionParams.StreamOptions(
  const Value: Boolean): TCompletionParams;
begin
  Result := TCompletionParams(Add('stream_options', TJSONObject.Create.AddPair('include_usage', Value)));
end;

function TCompletionParams.Suffix(const Value: string): TCompletionParams;
begin
  Result := TCompletionParams(Add('suffix', Value));
end;

function TCompletionParams.Temperature(const Value: Double): TCompletionParams;
begin
  Result := TCompletionParams(Add('temperature', Value));
end;

function TCompletionParams.TopP(const Value: Double): TCompletionParams;
begin
  Result := TCompletionParams(Add('top_p', Value));
end;

function TCompletionParams.User(const Value: string): TCompletionParams;
begin
  Result := TCompletionParams(Add('user', Value));
end;

{ TCompletionChoice }

destructor TCompletionChoice.Destroy;
begin
  if Assigned(FLlogprobs) then
    FLlogprobs.Free;
  inherited;
end;

{ TCompletion }

destructor TCompletion.Destroy;
begin
  for var Item in FChoices do
    Item.Free;
  if Assigned(FUsage) then
    FUsage.Free;
  inherited;
end;

function TCompletion.GetCreated: Int64;
begin
  Result := TInt64OrNull(FCreated).ToInteger;
end;

function TCompletion.GetCreatedAsString: string;
begin
  Result := TInt64OrNull(FCreated).ToUtcDateString;
end;

{ TCompletionRoute }

procedure TCompletionRoute.AsynCreate(const ParamProc: TProc<TCompletionParams>;
  CallBacks: TFunc<TAsynCompletion>);
begin
  with TAsynCallBackExec<TAsynCompletion, TCompletion>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TCompletion
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TCompletionRoute.AsynCreateStream(ParamProc: TProc<TCompletionParams>;
  CallBacks: TFunc<TAsynCompletionStream>);
begin
  var CallBackParams := TUseParamsFactory<TAsynCompletionStream>.CreateInstance(CallBacks);

  var Sender := CallBackParams.Param.Sender;
  var OnStart := CallBackParams.Param.OnStart;
  var OnSuccess := CallBackParams.Param.OnSuccess;
  var OnProgress := CallBackParams.Param.OnProgress;
  var OnError := CallBackParams.Param.OnError;
  var OnCancellation := CallBackParams.Param.OnCancellation;
  var OnDoCancel := CallBackParams.Param.OnDoCancel;

  var Task: ITask := TTask.Create(
          procedure()
          begin
            {--- Pass the instance of the current class in case no value was specified. }
            if not Assigned(Sender) then
              Sender := Self;

            {--- Trigger OnStart callback }
            if Assigned(OnStart) then
              TThread.Queue(nil,
                procedure
                begin
                  OnStart(Sender);
                end);
            try
              var Stop := False;

              {--- Processing }
              CreateStream(ParamProc,
                procedure (var Data: TCompletion; IsDone: Boolean; var Cancel: Boolean)
                begin
                  {--- Check that the process has not been canceled }
                  if Assigned(OnDoCancel) then
                    TThread.Queue(nil,
                        procedure
                        begin
                          Stop := OnDoCancel();
                        end);
                  if Stop then
                    begin
                      {--- Trigger when processus was stopped }
                      if Assigned(OnCancellation) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnCancellation(Sender)
                        end);
                      Cancel := True;
                      Exit;
                    end;
                  if not IsDone and Assigned(Data) then
                    begin
                      var LocalData := Data;
                      Data := nil;

                      {--- Triggered when processus is progressing }
                      if Assigned(OnProgress) then
                        TThread.Synchronize(TThread.Current,
                        procedure
                        begin
                          try
                            OnProgress(Sender, LocalData);
                          finally
                            {--- Makes sure to release the instance containing the data obtained
                                 following processing}
                            LocalData.Free;
                          end;
                        end)
                     else
                       LocalData.Free;
                    end
                  else
                  if IsDone then
                    begin
                      {--- Trigger OnEnd callback when the process is done }
                      if Assigned(OnSuccess) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnSuccess(Sender);
                        end);
                    end;
                end);
            except
              on E: Exception do
                begin
                  var Error := AcquireExceptionObject;
                  try
                    var ErrorMsg := (Error as Exception).Message;

                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(OnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        OnError(Sender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
          end);
  Task.Start;
end;

function TCompletionRoute.Create(
  const ParamProc: TProc<TCompletionParams>): TCompletion;
begin
  Result := API.Post<TCompletion, TCompletionParams>('completions', ParamProc);
end;

function TCompletionRoute.CreateStream(ParamProc: TProc<TCompletionParams>;
  Event: TStreamCallbackEvent<TCompletion>): Boolean;
begin
  var Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Result := API.Post<TCompletionParams>('completions', ParamProc, Response,
      {--- Please refer to the header note for detailed information on the processing of streamed messages. }
      TOpenAIStream<TCompletion>.CreateInstance(Response, Event, TApiDeserializer.Parse<TCompletion>).OnStream);
  finally
    Response.Free;
  end;
end;

end.

unit GenAI.Consts;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils;

const
  DATE_FORMAT = 'yyyy-MM-dd';
  TIME_FORMAT = 'hh:nn:ss';
  DATE_TIME_FORMAT = DATE_FORMAT + ' ' + TIME_FORMAT;

  AudioTypeAccepted: TArray<string> = ['audio/wav', 'audio/mpeg'];
  ImageTypeAccepted: TArray<string> = ['image/png', 'image/jpeg', 'image/gif', 'image/webp', 'binary/octet-stream'];
  DocTypeAccepted: TArray<string> = ['application/pdf'];

  ReasoningModels: TArray<string> = ['o1', 'o1-mini', 'o1-pro', 'o3', 'o3-mini', 'o4-mini'];

function IsReasoningModel(const Value: string): Boolean;

implementation

uses
  System.StrUtils;

function IsReasoningModel(const Value: string): Boolean;
begin
  Result := IndexStr(Value.Trim.Tolower, ReasoningModels) > -1;
end;

end.

unit GenAI.Embeddings;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Threading, REST.Json.Types,
  GenAI.API.Params, GenAI.API, GenAI.Types, GenAI.Async.Support;

type
  /// <summary>
  /// Represents the parameters required to create embeddings using the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class provides methods to specify different parameters for generating embeddings.
  /// The input can be a single string or an array of strings. You can also specify the model,
  /// encoding format, dimensions, and a user identifier. These parameters are used to configure
  /// the request to the OpenAI API to obtain embeddings that can be consumed by machine learning
  /// models and algorithms.
  /// </remarks>
  TEmbeddingsParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the input text for the embedding.
    /// </summary>
    /// <param name="Value">The text to embed, encoded as a string.</param>
    /// <returns>The instance of TEmbeddingsParams for method chaining.</returns>
    function Input(const Value: string): TEmbeddingsParams; overload;
    /// <summary>
    /// Sets the input text for the embedding as an array of strings.
    /// </summary>
    /// <param name="Value">The array of texts to embed.</param>
    /// <returns>The instance of TEmbeddingsParams for method chaining.</returns>
    function Input(const Value: TArray<string>): TEmbeddingsParams; overload;
    /// <summary>
    /// Specifies the model ID to be used for generating embeddings.
    /// </summary>
    /// <param name="Value">The model ID as a string.</param>
    /// <returns>The instance of TEmbeddingsParams for method chaining.</returns>
    function Model(const Value: string): TEmbeddingsParams;
    /// <summary>
    /// Sets the encoding format of the embedding output.
    /// </summary>
    /// <param name="Value">The encoding format, either as TEncodingFormat enum or string.</param>
    /// <returns>The instance of TEmbeddingsParams for method chaining.</returns>
    function EncodingFormat(const Value: TEncodingFormat): TEmbeddingsParams; overload;
    /// <summary>
    /// Sets the encoding format of the embedding output.
    /// </summary>
    /// <param name="Value">The encoding format, either as TEncodingFormat enum or string.</param>
    /// <returns>The instance of TEmbeddingsParams for method chaining.</returns>
    function EncodingFormat(const Value: string): TEmbeddingsParams; overload;
    /// <summary>
    /// Sets the number of dimensions for the embedding output.
    /// </summary>
    /// <param name="Value">The number of dimensions as an integer.</param>
    /// <returns>The instance of TEmbeddingsParams for method chaining.</returns>
    function Dimensions(const Value: Integer): TEmbeddingsParams;
    /// <summary>
    /// Specifies a unique identifier for the end-user, aiding in monitoring and abuse detection.
    /// </summary>
    /// <param name="Value">The user identifier as a string.</param>
    /// <returns>The instance of TEmbeddingsParams for method chaining.</returns>
    function User(const Value: string): TEmbeddingsParams;
  end;

  /// <summary>
  /// Represents a single embedding vector returned by the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class encapsulates the details of an embedding, including its index in the list of returned embeddings,
  /// the embedding vector itself, and the object type. It inherits from TJSONFingerprint to utilize JSON serialization
  /// capabilities.
  /// </remarks>
  TEmbedding = class(TJSONFingerprint)
  private
    FIndex: Int64;
    FEmbedding: TArray<Double>;
    FObject: string;
  public
    /// <summary>
    /// Gets or sets the index of the embedding in the list.
    /// </summary>
    /// <value>
    /// The index as an Int64.
    /// </value>
    property Index: Int64 read FIndex write FIndex;
    /// <summary>
    /// Gets or sets the embedding vector.
    /// </summary>
    /// <value>
    /// The embedding vector as an array of doubles.
    /// </value>
    property Embedding: TArray<Double> read FEmbedding write FEmbedding;
    /// <summary>
    /// Gets or sets the object type.
    /// </summary>
    /// <value>
    /// The object type as a string.
    /// </value>
    property &Object: string read FObject write FObject;
  end;

  /// <summary>
  /// Represents a collection of embedding vectors returned by the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class holds a list of TEmbedding objects, each representing an individual embedding vector.
  /// It includes methods for managing the lifecycle of these objects, including destruction. The class
  /// also inherits from TJSONFingerprint to leverage JSON serialization capabilities.
  /// </remarks>
  TEmbeddings = class(TJSONFingerprint)
  private
    FObject: string;
    FData: TArray<TEmbedding>;
  public
    /// <summary>
    /// Gets or sets the type of the object, always set to 'list'.
    /// </summary>
    /// <value>
    /// The object type as a string.
    /// </value>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// Gets or sets the data array containing the embeddings.
    /// </summary>
    /// <value>
    /// An array of TEmbedding objects.
    /// </value>
    property Data: TArray<TEmbedding> read FData write FData;
    /// <summary>
    /// Destroys the instance of TEmbeddings and frees its contained embeddings.
    /// </summary>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TEmbeddings</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynEmbeddings</c> type extends the <c>TAsynParams&lt;TEmbeddings&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynEmbeddings = TAsynCallBack<TEmbeddings>;

  /// <summary>
  /// Provides routes for creating embeddings via the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class offers methods to asynchronously or synchronously create embeddings based on the parameters
  /// provided by the caller. It utilizes TGenAIRoute as a base to inherit API communication capabilities.
  /// </remarks>
  TEmbeddingsRoute = class(TGenAIRoute)
    /// <summary>
    /// Asynchronously creates embeddings based on the provided parameters.
    /// </summary>
    /// <param name="ParamProc">A procedure that configures the parameters necessary for the embeddings request.</param>
    /// <param name="CallBacks">A callback function to handle the response asynchronously, which accepts a TAsynEmbeddings object.</param>
    /// <remarks>
    /// This method prepares and sends an asynchronous request to the OpenAI API to generate embeddings.
    /// The results are processed in the callback provided by the caller.
    /// </remarks>
    procedure AsynCreate(const ParamProc: TProc<TEmbeddingsParams>; const CallBacks: TFunc<TAsynEmbeddings>);
    /// <summary>
    /// Synchronously creates embeddings based on the provided parameters.
    /// </summary>
    /// <param name="ParamProc">A procedure that configures the parameters necessary for the embeddings request.</param>
    /// <returns>
    /// An instance of TEmbeddings containing the results from the API call.
    /// </returns>
    /// <remarks>
    /// This method sends a synchronous request to the OpenAI API to generate embeddings based on the parameters
    /// specified by ParamProc. The response is returned directly to the caller.
    /// </remarks>
    function Create(const ParamProc: TProc<TEmbeddingsParams>): TEmbeddings;
  end;

implementation

{ TEmbeddingsParams }

function TEmbeddingsParams.Input(const Value: string): TEmbeddingsParams;
begin
  Result := TEmbeddingsParams(Add('input', Value));
end;

function TEmbeddingsParams.Dimensions(const Value: Integer): TEmbeddingsParams;
begin
  Result := TEmbeddingsParams(Add('dimensions', Value));
end;

function TEmbeddingsParams.EncodingFormat(
  const Value: TEncodingFormat): TEmbeddingsParams;
begin
  Result := TEmbeddingsParams(Add('encoding_format', Value.ToString));
end;

function TEmbeddingsParams.EncodingFormat(
  const Value: string): TEmbeddingsParams;
begin
  Result := TEmbeddingsParams(Add('encoding_format', TEncodingFormat.Create(Value).ToString));
end;

function TEmbeddingsParams.Input(
  const Value: TArray<string>): TEmbeddingsParams;
begin
  Result := TEmbeddingsParams(Add('input', Value));
end;

function TEmbeddingsParams.Model(const Value: string): TEmbeddingsParams;
begin
  Result := TEmbeddingsParams(Add('model', Value));
end;

function TEmbeddingsParams.User(const Value: string): TEmbeddingsParams;
begin
  Result := TEmbeddingsParams(Add('user', Value));
end;

{ TEmbeddings }

destructor TEmbeddings.Destroy;
begin
  for var Item in FData do
    Item.Free;
  inherited;
end;

{ TEmbeddingsRoute }

procedure TEmbeddingsRoute.AsynCreate(const ParamProc: TProc<TEmbeddingsParams>;
  const CallBacks: TFunc<TAsynEmbeddings>);
begin
  with TAsynCallBackExec<TAsynEmbeddings, TEmbeddings>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TEmbeddings
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TEmbeddingsRoute.Create(
  const ParamProc: TProc<TEmbeddingsParams>): TEmbeddings;
begin
  Result := API.Post<TEmbeddings, TEmbeddingsParams>('embeddings', ParamProc);
end;

end.

unit GenAI.Errors;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

type
  TErrorCore = class abstract;

  TErrorDetail = class
  private
    FCode: Int64;
    FType: string;
    FMessage: string;
    FParam: string;
  public
    property Code: Int64 read FCode write FCode;
    property &Type: string read FType write FType;
    property Message: string read FMessage write FMessage;
    property Param: string read FParam write FParam;
  end;

  TError = class(TErrorCore)
  private
    FError: TErrorDetail;
  public
    property Error: TErrorDetail read FError write FError;
    destructor Destroy; override;
  end;

implementation

{ TError }

destructor TError.Destroy;
begin
  if Assigned(FError) then
    FError.Free;
  inherited;
end;

end.

unit GenAI.Exceptions;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Net.HttpClient, System.Net.URLClient,
  System.Net.Mime, System.JSON, GenAI.Errors;

type
  /// <summary>
  /// The <c>TGenAIException</c> class represents a base exception for the GenAI library.
  /// It is designed to handle error codes and messages returned by the GenAI API or other internal errors.
  /// </summary>
  /// <remarks>
  /// This class is a foundation for more specific exception classes in the GenAI library.
  /// It provides additional properties and methods to facilitate detailed error handling.
  /// </remarks>
  TGenAIException = class(Exception)
  private
    FCode: Int64;
    FErrorMessage: string;
    FParam: string;
  public
    /// <summary>
    /// Creates an instance of the <c>TGenAIException</c> class with an error code and a <c>TErrorCore</c> object.
    /// </summary>
    /// <param name="ACode">
    /// The error code associated with the exception.
    /// </param>
    /// <param name="AError">
    /// A <c>TErrorCore</c> object containing details of the error.
    /// </param>
    /// <remarks>
    /// This constructor initializes the exception with a code, error message, and optional parameter
    /// from the <c>TErrorCore</c> object.
    /// </remarks>
    constructor Create(const ACode: Int64; const AError: TErrorCore); reintroduce; overload;
    /// <summary>
    /// Creates an instance of the <c>TGenAIException</c> class with an error code and a custom error message.
    /// </summary>
    /// <param name="ACode">
    /// The error code associated with the exception.
    /// </param>
    /// <param name="Value">
    /// A custom error message describing the issue.
    /// </param>
    /// <remarks>
    /// This constructor initializes the exception with a code and a custom error message.
    /// </remarks>
    constructor Create(const ACode: Int64; const Value: string); reintroduce; overload;
    /// <summary>
    /// Formats the error message with the code and description.
    /// </summary>
    /// <returns>
    /// A formatted string in the format: "error {Code}: {ErrorMessage}".
    /// </returns>
    /// <remarks>
    /// Use this method to obtain a user-friendly error description for logging or debugging purposes.
    /// </remarks>
    function FormatErrorMessage: string;
    /// <summary>
    /// The error code associated with the exception.
    /// </summary>
    /// <value>
    /// An <c>Int64</c> representing the error code.
    /// </value>
    property Code: Int64 read FCode write FCode;
    /// <summary>
    /// The detailed error message describing the issue.
    /// </summary>
    /// <value>
    /// A <c>string</c> containing the error message.
    /// </value>
    property ErrorMessage: string read FErrorMessage write FErrorMessage;
    /// <summary>
    /// An optional parameter related to the error, providing additional context.
    /// </summary>
    /// <value>
    /// A <c>string</c> containing the parameter, or an empty string if no parameter is provided.
    /// </value>
    property Param: string read FParam write FParam;
  end;

  /// <summary>
  /// The <c>TGenAIAPIException</c> class represents a generic API-related exception.
  /// It is thrown when there is an issue with the API configuration or request process,
  /// such as a missing API token, invalid base URL, or other configuration errors.
  /// This class serves as a base for more specific API exceptions.
  /// </summary>
  TGenAIAPIException = class(Exception);

  /// <summary>
  /// Invalid Authentication or the requesting API key is not correct or your account is not part of an
  /// organization.
  /// </summary>
  /// <remarks>
  /// Ensure the API key used is correct, clear your browser cache, or generate a new one.
  /// </remarks>
  TGenAIAuthError = class(TGenAIException);

  /// <summary>
  /// Country, region, or territory not supported.
  /// </summary>
  /// <remarks>
  /// Refer to Supported countries and territories.
  /// https://platform.GenAI.com/docs/supported-countries
  /// </remarks>
  TGenAICountryNotSupportedError = class(TGenAIException);

  /// <summary>
  /// A <c>TGenAIRateLimitError</c> indicates that you have hit your assigned rate limit.
  /// This means that you have sent too many tokens or requests in a given period of time,
  /// and our services have temporarily blocked you from sending more.
  /// </summary>
  /// <remarks>
  /// Pace your requests. Read the Rate limit guide.
  /// https://platform.GenAI.com/docs/guides/rate-limits
  /// </remarks>
  TGenAIRateLimitError = class(TGenAIException);

  /// <summary>
  /// The server had an error while processing your request.
  /// </summary>
  /// <remarks>
  /// Retry your request after a brief wait and contact us if the issue persists. Check the status page.
  /// https://status.GenAI.com/
  /// </remarks>
  TGenAIServerError = class(TGenAIException);

  /// <summary>
  /// The engine is currently overloaded, please try again later.
  /// </summary>
  /// <remarks>
  /// Please retry your requests after a brief wait.
  /// </remarks>
  TGenAIEngineOverloadedError = class(TGenAIException);

  /// <summary>
  /// An <c>TGenAIInvalidResponseError</c> error occurs when the API response is either empty or not in the expected format.
  /// This error indicates that the API did not return a valid response that can be processed, possibly due to a server-side issue,
  /// a malformed request, or unexpected input data.
  /// </summary>
  TGenAIInvalidResponseError = class(TGenAIException);

implementation

{ TGenAIException }

constructor TGenAIException.Create(const ACode: Int64; const AError: TErrorCore);
begin
  var Error := (AError as TError).Error;
  Code := ACode;
  ErrorMessage := Error.Message;
  Param := Error.Param;
  inherited Create(FormatErrorMessage);
end;

constructor TGenAIException.Create(const ACode: Int64; const Value: string);
begin
  Code := ACode;
  ErrorMessage := Value;
  Param := EmptyStr;
  inherited Create(FormatErrorMessage);
end;

function TGenAIException.FormatErrorMessage: string;
begin
  Result := Format('error %d: %s', [Code, ErrorMessage]);
end;

end.

unit GenAI.Files;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Threading, System.JSON, REST.Json.Types,
  REST.JsonReflect, System.Net.Mime,
  GenAI.API.Params, GenAI.API, GenAI.Consts, GenAI.Types, GenAI.Async.Support,
  GenAI.API.Lists, GenAI.API.Deletion;

type
  /// <summary>
  /// Represents a class for constructing URL parameters specifically for file-related operations in the API.
  /// </summary>
  /// <remarks>
  /// This class provides methods to configure URL parameters such as purpose, limit, order, and pagination.
  /// It is designed to simplify the creation of query strings for file operations like listing files or filtering them by specific criteria.
  /// </remarks>
  TFileUrlParams = class(TUrlParam)
  public
    /// <summary>
    /// Sets the purpose parameter for the URL, defining the intended use of the files to be retrieved or listed.
    /// </summary>
    /// <param name="Value">
    /// A string that specifies the purpose of the file, such as "assistants", "fine-tune", "batch", or "vision".
    /// </param>
    /// <returns>
    /// Returns an instance of TFileUrlParams, allowing for method chaining.
    /// </returns>
    function Purpose(const Value: string): TFileUrlParams; overload;
    /// <summary>
    /// Sets the purpose parameter using the TFilesPurpose enumeration for better type safety.
    /// </summary>
    /// <param name="Value">
    /// A value from the TFilesPurpose enumeration that specifies the purpose of the file.
    /// </param>
    /// <returns>
    /// Returns an instance of TFileUrlParams, allowing for method chaining.
    /// </returns>
    function Purpose(const Value: TFilesPurpose): TFileUrlParams; overload;
    /// <summary>
    /// Sets the limit parameter, which defines the maximum number of files to be retrieved in the response.
    /// </summary>
    /// <param name="Value">
    /// An integer specifying the maximum number of files to be returned. The value must be between 1 and 10,000.
    /// </param>
    /// <returns>
    /// Returns an instance of TFileUrlParams, allowing for method chaining.
    /// </returns>
    function Limit(const Value: Integer): TFileUrlParams;
    /// <summary>
    /// Sets the order parameter, which defines the sort order for the file listing based on the created_at timestamp.
    /// </summary>
    /// <param name="Value">
    /// A string specifying the sort order. Use "asc" for ascending order or "desc" for descending order.
    /// </param>
    /// <returns>
    /// Returns an instance of TFileUrlParams, allowing for method chaining.
    /// </returns>
    function Order(const Value: string): TFileUrlParams;
    /// <summary>
    /// Sets the after parameter, which acts as a cursor for pagination to fetch the next page of files.
    /// </summary>
    /// <param name="Value">
    /// A string specifying the ID of the last file from the previous page to start fetching the next page.
    /// </param>
    /// <returns>
    /// Returns an instance of TFileUrlParams, allowing for method chaining.
    /// </returns>
    function After(const Value: string): TFileUrlParams;
  end;

  /// <summary>
  /// Represents a class for constructing parameters for uploading files to the API.
  /// </summary>
  /// <remarks>
  /// This class provides methods to configure multipart form data for file uploads,
  /// including setting the file path and specifying its purpose.
  /// It is designed to facilitate file uploads for various use cases such as fine-tuning, batch processing, or assistants.
  /// </remarks>
  TFileUploadParams = class(TMultipartFormData)
  public
    constructor Create; reintroduce;
    /// <summary>
    /// Adds a file to the form data for uploading to the API.
    /// </summary>
    /// <param name="Value">
    /// A string representing the path to the file to be uploaded.
    /// </param>
    /// <returns>
    /// Returns an instance of TFileUploadParams, allowing for method chaining.
    /// </returns>
    function &File(const Value: string): TFileUploadParams; overload;
    /// <summary>
    /// Adds a file to the form data for uploading to the API.
    /// </summary>
    /// <param name="Value">
    /// A <c>TStream</c> object containing the file data.
    /// </param>
    /// <param name="FileName">
    /// A string representing the file path for the image, used for reference purposes.
    /// </param>
    /// <returns>
    /// Returns an instance of TFileUploadParams, allowing for method chaining.
    /// </returns>
    function &File(const Value: TStream; const FileName: string): TFileUploadParams; overload;
    /// <summary>
    /// Sets the purpose parameter for the uploaded file, defining its intended use in the API.
    /// </summary>
    /// <param name="Value">
    /// A string that specifies the purpose of the file, such as "assistants", "fine-tune", "batch", or "vision".
    /// </param>
    /// <returns>
    /// Returns an instance of TFileUploadParams, allowing for method chaining.
    /// </returns>
    function Purpose(const Value: string): TFileUploadParams; overload;
    /// <summary>
    /// Sets the purpose parameter using the TFilesPurpose enumeration for better type safety.
    /// </summary>
    /// <param name="Value">
    /// A value from the TFilesPurpose enumeration that specifies the purpose of the file.
    /// </param>
    /// <returns>
    /// Returns an instance of TFileUploadParams, allowing for method chaining.
    /// </returns>
    function Purpose(const Value: TFilesPurpose): TFileUploadParams; overload;
  end;

  /// <summary>
  /// Represents a file object in the API, containing metadata and attributes of the uploaded file.
  /// </summary>
  /// <remarks>
  /// This class provides properties to access file metadata such as ID, size, creation timestamp, filename,
  /// purpose, and type. It is used for operations that involve file management within the API.
  /// </remarks>
  TFile = class(TJSONFingerprint)
  private
    FId: string;
    FBytes: Int64;
    [JsonNameAttribute('created_at')]
    FCreatedAt: TInt64OrNull;
    FFilename: string;
    FObject: string;
    [JsonReflectAttribute(ctString, rtString, TFilesPurposeInterceptor)]
    FPurpose: TFilesPurpose;
  private
    function GetCreatedAtAsString: string;
    function GetCreatedAt: Int64;
  public
    /// <summary>
    /// Gets or sets the unique identifier of the file.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Gets or sets the size of the file in bytes.
    /// </summary>
    property Bytes: Int64 read FBytes write FBytes;
    /// <summary>
    /// Gets the creation timestamp of the file in Unix seconds.
    /// </summary>
    property CreatedAt: Int64 read GetCreatedAt;
    /// <summary>
    /// Gets the creation timestamp of the file as string.
    /// </summary>
    property CreatedAtAsString: string read GetCreatedAtAsString;
    /// <summary>
    /// Gets or sets the name of the file.
    /// </summary>
    property Filename: string read FFilename write FFilename;
    /// <summary>
    /// Gets or sets the object type, which is always "file".
    /// </summary>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// Gets or sets the purpose of the file, indicating its intended use.
    /// </summary>
    property Purpose: TFilesPurpose read FPurpose write FPurpose;
  end;

  /// <summary>
  /// Represents a collection of file objects retrieved from the API.
  /// </summary>
  /// <remarks>
  /// This class provides properties to access the metadata of a collection of files,
  /// including the list of files, pagination information, and object type.
  /// It is used for operations that involve listing or retrieving multiple files.
  /// </remarks>
  TFiles = TAdvancedList<TFile>;

  /// <summary>
  /// Represents the content of a file retrieved from the API.
  /// </summary>
  /// <remarks>
  /// This class provides properties to access the base64-encoded content of a file
  /// and a method to decode it into a readable string. It is used for operations that involve
  /// retrieving and processing the actual content of files.
  /// </remarks>
  TFileContent = class(TJSONFingerprint)
  private
    FBase64: string;
    /// <summary>
    /// Decodes the base64-encoded content and returns it as a string.
    /// </summary>
    /// <returns>
    /// A string representing the decoded content of the file.
    /// </returns>
    function GetContent: string;
    property Base64: string read FBase64 write FBase64;
  public
    /// <summary>
    /// Gets the decoded content of the file as a string.
    /// </summary>
    property Content: string read GetContent;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TFile</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynFile</c> type extends the <c>TAsynParams&lt;TFile&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynFile = TAsynCallBack<TFile>;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TFiles</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynFiles</c> type extends the <c>TAsynParams&lt;TFiles&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynFiles = TAsynCallBack<TFiles>;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TFiles</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynFiles</c> type extends the <c>TAsynParams&lt;TFiles&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynFileContent = TAsynCallBack<TFileContent>;

  /// <summary>
  /// Represents a route for managing file operations in the API.
  /// </summary>
  /// <remarks>
  /// This class provides methods for performing file-related operations, including uploading files,
  /// listing files, retrieving specific file details or content, and deleting files.
  /// It supports both synchronous and asynchronous operations for efficient file management.
  /// </remarks>
  TFilesRoute = class(TGenAIRoute)
    /// <summary>
    /// Performs an asynchronous file upload operation.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure that configures the parameters for the file upload, including the file path and purpose.
    /// </param>
    /// <param name="CallBacks">
    /// A function that defines callbacks to handle events like success, failure, or progress during the upload process.
    /// </param>
    procedure AsynUpload(const ParamProc: TProc<TFileUploadParams>; const CallBacks: TFunc<TAsynFile>);
    /// <summary>
    /// Performs an asynchronous operation to list all files.
    /// </summary>
    /// <param name="CallBacks">
    /// A function that defines callbacks to handle events like success, failure, or progress during the listing process.
    /// </param>
    procedure AsynList(const CallBacks: TFunc<TAsynFiles>); overload;
    /// <summary>
    /// Performs an asynchronous operation to list files with specified URL parameters.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure that configures the URL parameters for filtering the file list.
    /// </param>
    /// <param name="CallBacks">
    /// A function that defines callbacks to handle events like success, failure, or progress during the listing process.
    /// </param>
    procedure AsynList(const ParamProc: TProc<TFileUrlParams>; const CallBacks: TFunc<TAsynFiles>); overload;
    /// <summary>
    /// Performs an asynchronous operation to retrieve details of a specific file.
    /// </summary>
    /// <param name="FileId">
    /// The unique identifier of the file to retrieve.
    /// </param>
    /// <param name="CallBacks">
    /// A function that defines callbacks to handle events like success, failure, or progress during the retrieval process.
    /// </param>
    procedure AsynRetrieve(const FileId: string; const CallBacks: TFunc<TAsynFile>);
    /// <summary>
    /// Performs an asynchronous operation to retrieve the content of a specific file.
    /// </summary>
    /// <param name="FileId">
    /// The unique identifier of the file whose content is to be retrieved.
    /// </param>
    /// <param name="CallBacks">
    /// A function that defines callbacks to handle events like success, failure, or progress during the retrieval process.
    /// </param>
    procedure AsynRetrieveContent(const FileId: string; const CallBacks: TFunc<TAsynFileContent>);
    /// <summary>
    /// Performs an asynchronous operation to delete a specific file.
    /// </summary>
    /// <param name="FileId">
    /// The unique identifier of the file to delete.
    /// </param>
    /// <param name="CallBacks">
    /// A function that defines callbacks to handle events like success, failure, or progress during the deletion process.
    /// </param>
    procedure AsynDelete(const FileId: string; const CallBacks: TFunc<TAsynDeletion>);
    /// <summary>
    /// Uploads a file to the API synchronously.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure that configures the parameters for the file upload, including the file path and purpose.
    /// </param>
    /// <returns>
    /// Returns an instance of TFile representing the uploaded file.
    /// </returns>
    function Upload(const ParamProc: TProc<TFileUploadParams>): TFile;
    /// <summary>
    /// Lists all files in the API synchronously.
    /// </summary>
    /// <returns>
    /// Returns an instance of TFiles containing the list of files.
    /// </returns>
    function List: TFiles; overload;
    /// <summary>
    /// Lists files with specified URL parameters synchronously.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure that configures the URL parameters for filtering the file list.
    /// </param>
    /// <returns>
    /// Returns an instance of TFiles containing the filtered list of files.
    /// </returns>
    function List(const ParamProc: TProc<TFileUrlParams>): TFiles; overload;
    /// <summary>
    /// Retrieves details of a specific file synchronously.
    /// </summary>
    /// <param name="FileId">
    /// The unique identifier of the file to retrieve.
    /// </param>
    /// <returns>
    /// Returns an instance of TFile containing the file's metadata.
    /// </returns>
    function Retrieve(const FileId: string): TFile;
    /// <summary>
    /// Retrieves the content of a specific file synchronously.
    /// </summary>
    /// <param name="FileId">
    /// The unique identifier of the file whose content is to be retrieved.
    /// </param>
    /// <returns>
    /// Returns an instance of TFileContent containing the file's content.
    /// </returns>
    function RetrieveContent(const FileId: string): TFileContent;
    /// <summary>
    /// Deletes a specific file synchronously.
    /// </summary>
    /// <param name="FileId">
    /// The unique identifier of the file to delete.
    /// </param>
    /// <returns>
    /// Returns an instance of TFileDeletion representing the deleted file.
    /// </returns>
    function Delete(const FileId: string): TDeletion;
  end;

implementation

uses
  System.NetEncoding;

{ TFileUploadParams }

function TFileUploadParams.&File(const Value: string): TFileUploadParams;
begin
  AddFile('file', Value);
  Result := Self;
end;

function TFileUploadParams.&File(const Value: TStream;
  const FileName: string): TFileUploadParams;
begin
  {$IF RTLVersion > 35.0}
    AddStream('file', Value, True, FileName);
  {$ELSE}
    AddStream('file', Value, FileName);
  {$ENDIF}
  Result := Self;
end;

function TFileUploadParams.Purpose(
  const Value: TFilesPurpose): TFileUploadParams;
begin
  AddField('purpose', Value.ToString);
  Result := Self;
end;

function TFileUploadParams.Purpose(const Value: string): TFileUploadParams;
begin
  AddField('purpose', TFilesPurpose.Create(Value).ToString);
  Result := Self;
end;

constructor TFileUploadParams.Create;
begin
  inherited Create(true);
end;

{ TFileUrlParams }

function TFileUrlParams.After(const Value: string): TFileUrlParams;
begin
  Result := TFileUrlParams(Add('after', Value));
end;

function TFileUrlParams.Limit(const Value: Integer): TFileUrlParams;
begin
  Result := TFileUrlParams(Add('limit', Value));
end;

function TFileUrlParams.Order(const Value: string): TFileUrlParams;
begin
  Result := TFileUrlParams(Add('order', Value));
end;

function TFileUrlParams.Purpose(const Value: TFilesPurpose): TFileUrlParams;
begin
  Result := TFileUrlParams(Add('purpose', Value.ToString));
end;

function TFileUrlParams.Purpose(const Value: string): TFileUrlParams;
begin
  Result := TFileUrlParams(Add('purpose', TFilesPurpose.Create(Value).ToString));
end;

{ TFilesRoute }

procedure TFilesRoute.AsynDelete(const FileId: string;
  const CallBacks: TFunc<TAsynDeletion>);
begin
  with TAsynCallBackExec<TAsynDeletion, TDeletion>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TDeletion
      begin
        Result := Self.Delete(FileId);
      end);
  finally
    Free;
  end;
end;

procedure TFilesRoute.AsynList(const CallBacks: TFunc<TAsynFiles>);
begin
  with TAsynCallBackExec<TAsynFiles, TFiles>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TFiles
      begin
        Result := Self.List;
      end);
  finally
    Free;
  end;
end;

procedure TFilesRoute.AsynList(const ParamProc: TProc<TFileUrlParams>;
  const CallBacks: TFunc<TAsynFiles>);
begin
  with TAsynCallBackExec<TAsynFiles, TFiles>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TFiles
      begin
        Result := Self.List(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TFilesRoute.AsynRetrieve(const FileId: string;
  const CallBacks: TFunc<TAsynFile>);
begin
  with TAsynCallBackExec<TAsynFile, TFile>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TFile
      begin
        Result := Self.Retrieve(FileId);
      end);
  finally
    Free;
  end;
end;

procedure TFilesRoute.AsynRetrieveContent(const FileId: string;
  const CallBacks: TFunc<TAsynFileContent>);
begin
  with TAsynCallBackExec<TAsynFileContent, TFileContent>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TFileContent
      begin
        Result := Self.RetrieveContent(FileId);
      end);
  finally
    Free;
  end;
end;

procedure TFilesRoute.AsynUpload(const ParamProc: TProc<TFileUploadParams>;
  const CallBacks: TFunc<TAsynFile>);
begin
  with TAsynCallBackExec<TAsynFile, TFile>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TFile
      begin
        Result := Self.Upload(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TFilesRoute.Delete(const FileId: string): TDeletion;
begin
  Result := API.Delete<TDeletion>('files/' + FileId);
end;

function TFilesRoute.List: TFiles;
begin
  Result := API.Get<TFiles>('files');
end;

function TFilesRoute.List(const ParamProc: TProc<TFileUrlParams>): TFiles;
begin
  Result := API.Get<TFiles, TFileUrlParams>('files', ParamProc);
end;

function TFilesRoute.Retrieve(const FileId: string): TFile;
begin
  Result := API.Get<TFile>('files/' + FileId);
end;

function TFilesRoute.RetrieveContent(const FileId: string): TFileContent;
begin
  Result := API.GetFile<TFileContent>('files/' + FileId + '/content', 'base64');
end;

function TFilesRoute.Upload(const ParamProc: TProc<TFileUploadParams>): TFile;
begin
  Result := API.PostForm<TFile, TFileUploadParams>('files', ParamProc);
end;

{ TFileContent }

function TFileContent.GetContent: string;
begin
  Result :=  TNetEncoding.Base64.Decode(Base64);
end;

{ TFile }

function TFile.GetCreatedAt: Int64;
begin
  Result := TInt64OrNull(FCreatedAt).ToInteger;
end;

function TFile.GetCreatedAtAsString: string;
begin
  Result := TInt64OrNull(FCreatedAt).ToUtcDateString;
end;

end.

unit GenAI.FineTuning;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

(*
    --- NOTE ---
  Difference Between Supervised and DPO (Direct Preference Optimization) Methods

    1. SUPERVISED Fine-Tuning Method

  The supervised method  is a classic fine-tuning approach  where the model is trained on a labeled
  dataset to learn  how to map specific inputs  (prompts)  to target outputs  (ideal responses).

  Key Features:
   - The model learns solely from the examples provided in the training data.
   - Each training example contains a prompt and a corresponding target response.
   - The goal is to minimize the error (loss) between the model's output and the target response in
     the training data.

  Advantages:
   - Easy to implement: Requires only a well-annotated training dataset.
   - Ideal for specific tasks: Works well for well-defined tasks where high-quality labeled data is
     available (e.g., classification, translation, summarization).

  Limitations:
   - Can be prone to overfitting if the training data is not diverse enough.
   - Does not account for human preferences or comparisons between multiple potential responses.

  When to use it:
   - When you have a labeled dataset containing specific examples of what the model should produce.
   - When you aim to train the model  for a specific, well-defined task  (e.g., answering questions
     or generating structured summaries).


    2. DPO (Direct Preference Optimization) Method

  The DPO method is a more advanced approach  that incorporates human preferences into the training
  process. Instead  of  focusing  on  "ideal"  responses,  this method  uses  pairs of responses to
  indicate which one is preferred (based on human or automated evaluations).

  Key Features:
   - The dataset includes comparisons between two responses generated for the same prompt, with one
     response marked as preferred.
   - The model is optimized to replicate these preferences.
   - This method is often used to fine-tune a model to align its responses with subjective or human
     preferences.

  Advantages:
   - Captures human preferences: Improves response quality based on subjective  or context-specific
     criteria.
   - Resilient to data  uncertainty:  Useful when  traditional  labeled  data  is  unavailable, but
     preference judgments are feasible.

  Limitations:
   - Requires a dataset with comparison data, which can be costly or time-consuming to create.
   - More complex to implement and train than the supervised method.

  When to use it:
   - When you want the model to produce responses that reflect subjective or human preferences, for
     example:
       - Generating more fluent or engaging text.
       - Aligning responses  with specific criteria  (e.g., avoiding  bias  or  generating  content
         tailored to a specific domain).

   - When  you  have a dataset containing  response  comparisons  (e.g., human ratings  of response
     quality between two options).


  Choosing Between the Two Methods

 +-------------------+----------------------------------+------------------------------------------+
 +    Criteria       +         Supervised               +                 DPO                      +
 +-------------------+----------------------------------+------------------------------------------+
 +                   +                                  +                                          +
 + Data Availability + Requires data with clear target  + Requires comparisons between responses   +
 +                   + outputs                          + (preferences)                            +
 +-------------------+----------------------------------+------------------------------------------+
 +                   +                                  +                                          +
 + Implementation    + Simpler                          + More complex, needs well-collected       +
 + Complexity        +                                  + preferences                              +
 +                   +                                  +                                          +
 +-------------------+----------------------------------+------------------------------------------+
 +                   +                                  +                                          +
 + Human Alignment   + Limited                          + Strong alignment due to human preference +
 +                   +                                  + incorporation                            +
 +-------------------+----------------------------------+------------------------------------------+
 +                   +                                  +                                          +
 + Primary Use Cases + Well-defined, objective tasks    + Subjective tasks or those requiring      +
 +                   +                                  + fine-tuned alignment                     +
 +-------------------+----------------------------------+------------------------------------------+


    3. Recommendation
        * Use the supervised method if:
            - You have a  labeled  dataset  with ideal responses  for your prompts.
            - Your task is  well-defined and does  not require subjective adjustments  or alignment
              with human preferences.

        * Use the DPO method if:
            - You want the model to generate responses that align with human or specific subjective
              preferences.
            - You have a dataset with comparisons between multiple responses.
            - You  aim  to  improve  response  quality  for  creative  or  open-ended  tasks  where
              preferences  are  key.

  In summary, the  supervised method  is ideal for  well-defined tasks, while  DPO is more suitable
  when human preferences or subjective criteria are central to your project.
*)

interface

uses
  System.SysUtils, System.Classes, System.Threading, System.JSON, REST.Json.Types,
  REST.JsonReflect,
  GenAI.API.Params, GenAI.API, GenAI.Consts, GenAI.Types, GenAI.Async.Support,
  GenAI.API.Lists;

type
  /// <summary>
  /// Represents the configuration parameters for Weights and Biases (WandB) integration
  /// in fine-tuning jobs. These parameters specify project details, run names, entities,
  /// and tags associated with WandB.
  /// </summary>
  TWandbParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the name of the project in Weights and Biases where metrics for the fine-tuning job
    /// will be stored.
    /// </summary>
    /// <param name="Value">
    /// The name of the project to associate with the WandB run.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TWandbParams</c> to allow method chaining.
    /// </returns>
    function Project(const Value: string): TWandbParams;
    /// <summary>
    /// Sets a custom display name for the Weights and Biases run.
    /// If not provided, the fine-tuning job ID will be used as the default name.
    /// </summary>
    /// <param name="Value">
    /// A string representing the custom display name for the WandB run.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TWandbParams</c> to allow method chaining.
    /// </returns>
    function Name(const Value: string): TWandbParams;
    /// <summary>
    /// Sets the entity (e.g., team or username) to associate with the Weights and Biases run.
    /// If not specified, the default entity for the registered WandB API key is used.
    /// </summary>
    /// <param name="Value">
    /// A string representing the entity for the WandB run.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TWandbParams</c> to allow method chaining.
    /// </returns>
    function Entity(const Value: string): TWandbParams;
    /// <summary>
    /// Attaches tags to the Weights and Biases run. These tags can be used for filtering
    /// and categorizing runs within the WandB interface.
    /// </summary>
    /// <param name="Value">
    /// An array of strings representing tags to assign to the WandB run.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TWandbParams</c> to allow method chaining.
    /// </returns>
    function Tags(const Value: TArray<string>): TWandbParams;
    /// <summary>
    /// Creates a new instance of <c>TWandbParams</c> with the specified project, name, entity,
    /// and tags pre-configured.
    /// </summary>
    /// <param name="Project">
    /// The name of the project to associate with the WandB run.
    /// </param>
    /// <param name="Name">
    /// A custom display name for the WandB run.
    /// </param>
    /// <param name="Entity">
    /// The entity (team or username) to associate with the WandB run.
    /// </param>
    /// <param name="Tags">
    /// An array of strings representing tags for the WandB run.
    /// </param>
    /// <returns>
    /// A new instance of <c>TWandbParams</c> with the specified parameters.
    /// </returns>
    class function New(const Project, Name, Entity: string; const Tags: TArray<string>): TWandbParams;
  end;

  /// <summary>
  /// Represents the configuration parameters for integrating external services
  /// into fine-tuning jobs. This class supports defining the type of integration
  /// (e.g., Weights and Biases) and its associated configuration details.
  /// </summary>
  TJobIntegrationParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the type of integration to enable for the fine-tuning job.
    /// For example, "wandb" can be used to enable Weights and Biases integration.
    /// </summary>
    /// <param name="Value">
    /// A string representing the type of integration (e.g., "wandb").
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TJobIntegrationParams</c> to allow method chaining.
    /// </returns>
    function &Type(const Value: string): TJobIntegrationParams;
    /// <summary>
    /// Configures the Weights and Biases (WandB) integration for the fine-tuning job
    /// using a pre-defined <c>TWandbParams</c> object.
    /// </summary>
    /// <param name="Value">
    /// An instance of <c>TWandbParams</c> containing the configuration details
    /// for the WandB integration.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TJobIntegrationParams</c> to allow method chaining.
    /// </returns>
    function Wandb(const Value: TWandbParams): TJobIntegrationParams; overload;
    /// <summary>
    /// Configures the Weights and Biases (WandB) integration for the fine-tuning job
    /// using a raw JSON object.
    /// </summary>
    /// <param name="Value">
    /// A JSON object (<c>TJSONObject</c>) containing the configuration details
    /// for the WandB integration.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TJobIntegrationParams</c> to allow method chaining.
    /// </returns>
    function Wandb(const Value: TJSONObject): TJobIntegrationParams; overload;
  end;

  /// <summary>
  /// Represents the configuration of hyperparameters for fine-tuning jobs.
  /// This class provides methods to set parameters such as batch size,
  /// learning rate, number of epochs, and beta (for DPO).
  /// </summary>
  THyperparametersParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the beta value for the DPO (Direct Preference Optimization) fine-tuning method.
    /// A higher beta value increases the weight of the penalty between the policy
    /// and reference models.
    /// </summary>
    /// <param name="Value">
    /// A floating-point value representing the beta parameter for the DPO method.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>THyperparametersParams</c> to allow method chaining.
    /// </returns>
    function Beta(const Value: Double): THyperparametersParams;
    /// <summary>
    /// Sets the batch size for the fine-tuning job. A larger batch size means
    /// model parameters are updated less frequently, but with lower variance.
    /// </summary>
    /// <param name="Value">
    /// An integer representing the number of examples in each batch.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>THyperparametersParams</c> to allow method chaining.
    /// </returns>
    function BatchSize(const Value: Integer): THyperparametersParams;
    /// <summary>
    /// Sets the learning rate multiplier for the fine-tuning job. A smaller learning
    /// rate may help avoid overfitting, while a larger one speeds up training.
    /// </summary>
    /// <param name="Value">
    /// A floating-point value representing the scaling factor for the learning rate.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>THyperparametersParams</c> to allow method chaining.
    /// </returns>
    function LearningRateMultiplier(const Value: Double): THyperparametersParams;
    /// <summary>
    /// Sets the number of epochs for the fine-tuning job. An epoch refers to one
    /// full cycle through the training dataset.
    /// </summary>
    /// <param name="Value">
    /// An integer representing the number of epochs to train the model.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>THyperparametersParams</c> to allow method chaining.
    /// </returns>
    function NEpochs(const Value: Integer): THyperparametersParams;
  end;

  /// <summary>
  /// Represents the configuration parameters for the supervised fine-tuning method.
  /// This class allows specifying hyperparameters to be used in supervised learning tasks.
  /// </summary>
  TSupervisedMethodParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the hyperparameters for the supervised fine-tuning method.
    /// These hyperparameters include values such as batch size, learning rate,
    /// and the number of epochs.
    /// </summary>
    /// <param name="Value">
    /// An instance of <c>THyperparametersParams</c> that defines the hyperparameters
    /// for supervised fine-tuning.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TSupervisedMethodParams</c> to allow method chaining.
    /// </returns>
    function Hyperparameters(const Value: THyperparametersParams): TSupervisedMethodParams;
    /// <summary>
    /// Creates a new instance of <c>TSupervisedMethodParams</c> with the specified hyperparameters.
    /// This method simplifies initialization when configuring the supervised method for fine-tuning.
    /// </summary>
    /// <param name="Value">
    /// An instance of <c>THyperparametersParams</c> that defines the hyperparameters
    /// for supervised fine-tuning.
    /// </param>
    /// <returns>
    /// A new instance of <c>TSupervisedMethodParams</c> configured with the provided hyperparameters.
    /// </returns>
    class function New(const Value: THyperparametersParams): TSupervisedMethodParams;
  end;

  /// <summary>
  /// Represents the configuration parameters for the DPO (Direct Preference Optimization)
  /// fine-tuning method. This class allows specifying hyperparameters to be used
  /// in DPO-based learning tasks.
  /// </summary>
  TDpoMethodParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the hyperparameters for the DPO fine-tuning method.
    /// These hyperparameters include values such as batch size, learning rate,
    /// number of epochs, and beta.
    /// </summary>
    /// <param name="Value">
    /// An instance of <c>THyperparametersParams</c> that defines the hyperparameters
    /// for the DPO fine-tuning method.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TDpoMethodParams</c> to allow method chaining.
    /// </returns>
    function Hyperparameters(const Value: THyperparametersParams): TDpoMethodParams;
    /// <summary>
    /// Creates a new instance of <c>TDpoMethodParams</c> with the specified hyperparameters.
    /// This method simplifies initialization when configuring the DPO method for fine-tuning.
    /// </summary>
    /// <param name="Value">
    /// An instance of <c>THyperparametersParams</c> that defines the hyperparameters
    /// for the DPO fine-tuning method.
    /// </param>
    /// <returns>
    /// A new instance of <c>TDpoMethodParams</c> configured with the provided hyperparameters.
    /// </returns>
    class function New(const Value: THyperparametersParams): TDpoMethodParams;
  end;

  /// <summary>
  /// Represents the configuration for the fine-tuning method to be used in a job.
  /// This class supports multiple methods, such as supervised learning or
  /// Direct Preference Optimization (DPO), and allows setting their respective parameters.
  /// </summary>
  TJobMethodParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the type of fine-tuning method to use, such as "supervised" or "dpo".
    /// </summary>
    /// <param name="Value">
    /// A string representing the fine-tuning method type (e.g., "supervised" or "dpo").
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TJobMethodParams</c> to allow method chaining.
    /// </returns>
    function &Type(const Value: string): TJobMethodParams; overload;
    /// <summary>
    /// Sets the type of fine-tuning method to use, using the <c>TJobMethodType</c> enumeration.
    /// </summary>
    /// <param name="Value">
    /// A value from the <c>TJobMethodType</c> enumeration representing the fine-tuning method type.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TJobMethodParams</c> to allow method chaining.
    /// </returns>
    function &Type(const Value: TJobMethodType): TJobMethodParams; overload;
    /// <summary>
    /// Configures the supervised fine-tuning method by setting its hyperparameters.
    /// </summary>
    /// <param name="Value">
    /// An instance of <c>TSupervisedMethodParams</c> containing the hyperparameters
    /// for the supervised fine-tuning method.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TJobMethodParams</c> to allow method chaining.
    /// </returns>
    function Supervised(const Value: TSupervisedMethodParams): TJobMethodParams;
    /// <summary>
    /// Configures the DPO (Direct Preference Optimization) fine-tuning method by setting its hyperparameters.
    /// </summary>
    /// <param name="Value">
    /// An instance of <c>TDpoMethodParams</c> containing the hyperparameters
    /// for the DPO fine-tuning method.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TJobMethodParams</c> to allow method chaining.
    /// </returns>
    function Dpo(const Value: TDpoMethodParams): TJobMethodParams;
    /// <summary>
    /// Creates a new instance of <c>TJobMethodParams</c> configured with a supervised fine-tuning method.
    /// </summary>
    /// <param name="Value">
    /// An instance of <c>THyperparametersParams</c> containing the hyperparameters
    /// for the supervised fine-tuning method.
    /// </param>
    /// <returns>
    /// A new instance of <c>TJobMethodParams</c> configured for supervised fine-tuning.
    /// </returns>
    class function NewSupervised(const Value: THyperparametersParams): TJobMethodParams;
    /// <summary>
    /// Creates a new instance of <c>TJobMethodParams</c> configured with a DPO fine-tuning method.
    /// </summary>
    /// <param name="Value">
    /// An instance of <c>THyperparametersParams</c> containing the hyperparameters
    /// for the DPO fine-tuning method.
    /// </param>
    /// <returns>
    /// A new instance of <c>TJobMethodParams</c> configured for DPO fine-tuning.
    /// </returns>
    class function NewDpo(const Value: THyperparametersParams): TJobMethodParams;
  end;

  /// <summary>
  /// Represents the configuration parameters for creating a fine-tuning job.
  /// This class allows setting various properties, such as the model to fine-tune,
  /// training and validation files, hyperparameters, and optional metadata.
  /// </summary>
  TFineTuningJobParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the base model to be fine-tuned.
    /// </summary>
    /// <param name="Value">
    /// A string representing the name of the base model to fine-tune.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TFineTuningJobParams</c> to allow method chaining.
    /// </returns>
    function Model(const Value: string): TFineTuningJobParams;
    /// <summary>
    /// Sets the file ID of the training dataset to be used for fine-tuning.
    /// The file must be uploaded and formatted as a JSONL file with the purpose "fine-tune".
    /// </summary>
    /// <param name="Value">
    /// A string representing the file ID of the training dataset.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TFineTuningJobParams</c> to allow method chaining.
    /// </returns>
    function TrainingFile(const Value: string): TFineTuningJobParams;
    /// <summary>
    /// Sets an optional suffix to be added to the name of the fine-tuned model.
    /// </summary>
    /// <param name="Value">
    /// A string of up to 64 characters to append to the model name.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TFineTuningJobParams</c> to allow method chaining.
    /// </returns>
    function Suffix(const Value: string): TFineTuningJobParams;
    /// <summary>
    /// Sets the file ID of the validation dataset to be used for fine-tuning.
    /// The file must be uploaded and formatted as a JSONL file with the purpose "fine-tune".
    /// </summary>
    /// <param name="Value">
    /// A string representing the file ID of the validation dataset.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TFineTuningJobParams</c> to allow method chaining.
    /// </returns>
    function ValidationFile(const Value: string): TFineTuningJobParams;
    /// <summary>
    /// Configures the integrations (e.g., Weights and Biases) for the fine-tuning job.
    /// </summary>
    /// <param name="Value">
    /// An array of <c>TJobIntegrationParams</c> objects defining the integrations to enable.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TFineTuningJobParams</c> to allow method chaining.
    /// </returns>
    function Integrations(const Value: TArray<TJobIntegrationParams>): TFineTuningJobParams;
    /// <summary>
    /// Sets the random seed for the fine-tuning job to ensure reproducibility.
    /// If not provided, a random seed will be generated.
    /// </summary>
    /// <param name="Value">
    /// An integer representing the random seed for the fine-tuning job.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TFineTuningJobParams</c> to allow method chaining.
    /// </returns>
    function Seed(const Value: Integer): TFineTuningJobParams;
    /// <summary>
    /// Configures the method and hyperparameters for the fine-tuning job.
    /// </summary>
    /// <param name="Value">
    /// An instance of <c>TJobMethodParams</c> that defines the fine-tuning method
    /// and its hyperparameters (e.g., supervised or DPO).
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TFineTuningJobParams</c> to allow method chaining.
    /// </returns>
    function Method(const Value: TJobMethodParams): TFineTuningJobParams; overload;
    /// <summary>
    /// Configures the method and hyperparameters for the fine-tuning job
    /// by specifying the method type and its corresponding hyperparameters.
    /// </summary>
    /// <param name="AType">
    /// The type of fine-tuning method, such as <c>TJobMethodType.supervised</c> or <c>TJobMethodType.dpo</c>.
    /// </param>
    /// <param name="Value">
    /// An instance of <c>THyperparametersParams</c> that defines the hyperparameters
    /// for the specified fine-tuning method.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TFineTuningJobParams</c> to allow method chaining.
    /// </returns>
    function Method(const AType: TJobMethodType; const Value: THyperparametersParams): TFineTuningJobParams; overload;
  end;

  /// <summary>
  /// Represents detailed error information for a fine-tuning job that has failed.
  /// This class contains information about the error code, message, and the parameter
  /// that caused the failure.
  /// </summary>
  TFineTuningJobError = class
  private
    FCode: string;
    FMessage: string;
    FParam: string;
  public
    /// <summary>
    /// Gets or sets the machine-readable error code.
    /// </summary>
    property Code: string read FCode write FCode;
    /// <summary>
    /// Gets or sets the human-readable error message providing details about the error.
    /// </summary>
    property Message: string read FMessage write FMessage;
    /// <summary>
    /// Gets or sets the name of the parameter that caused the error, if applicable.
    /// </summary>
    property Param: string read FParam write FParam;
  end;

  /// <summary>
  /// Represents the hyperparameters used for a fine-tuning job in OpenAI's fine-tuning API.
  /// </summary>
  /// <remarks>
  /// The hyperparameters include options to control the training process, such as the batch size,
  /// learning rate, number of epochs, and beta (used in specific fine-tuning methods like DPO).
  /// These parameters allow customization of the model's fine-tuning behavior for optimal performance.
  /// </remarks>
  THyperparameters = class
  private
    FBeta: Variant;
    [JsonNameAttribute('batch_size')]
    FBatchSize: Variant;
    [JsonNameAttribute('learning_rate_multiplier')]
    FLearningRateMultiplier: Variant;
    [JsonNameAttribute('n_epochs')]
    FNEpochs: Variant;
  public
    /// <summary>
    /// Gets or sets the beta value for the fine-tuning job.
    /// </summary>
    /// <remarks>
    /// The beta value as a number or "auto." A higher beta applies greater weight to the penalty between
    /// the policy and reference model in DPO fine-tuning.
    /// </remarks>
    property Beta: Variant read FBeta write FBeta;
    /// <summary>
    /// Gets or sets the batch size for the fine-tuning job.
    /// </summary>
    /// <remarks>
    /// The batch size as an integer or "auto." A larger batch size reduces the frequency of updates
    /// but decreases the variance in parameter updates.
    /// </remarks>
    property BatchSize: Variant read FBatchSize write FBatchSize;
    /// <summary>
    /// Gets or sets the learning rate multiplier for the fine-tuning job.
    /// </summary>
    /// <remarks>
    /// The learning rate multiplier as a number or "auto." This value scales the base learning rate
    /// to control the magnitude of parameter updates.
    /// </value>
    property LearningRateMultiplier: Variant read FLearningRateMultiplier write FLearningRateMultiplier;
    /// <summary>
    /// Gets or sets the number of epochs for the fine-tuning job.
    /// </summary>
    /// <remarks>
    /// The number of epochs as an integer or "auto." An epoch represents a complete pass through the
    /// training dataset.
    /// </value>
    property NEpochs: Variant read FNEpochs write FNEpochs;
  end;

  /// <summary>
  /// Represents the configuration for integrating with Weights and Biases (WandB) in a fine-tuning job.
  /// </summary>
  /// <remarks>
  /// This class provides methods to set project details, display names, entities, and tags
  /// for runs tracked in WandB during the fine-tuning process.
  /// </remarks>
  TWanDB = class
  private
    FProject: string;
    FName: string;
    FEntity: string;
    FTags: TArray<string>;
  public
    /// <summary>
    /// Gets or sets the project name in WandB under which the fine-tuning metrics will be logged.
    /// </summary>
    /// <param name="Value">
    /// The name of the WandB project.
    /// </param>
    /// <returns>
    /// The updated instance of the <c>TWanDB</c> class.
    /// </returns>
    property Project: string read FProject write FProject;
    /// <summary>
    /// Gets or sets the display name for the run in WandB.
    /// </summary>
    /// <param name="Value">
    /// The display name to set for the run. If not specified, the job ID will be used.
    /// </param>
    /// <returns>
    /// The updated instance of the <c>TWanDB</c> class.
    /// </returns>
    property Name: string read FName write FName;
    /// <summary>
    /// Gets or sets the entity (team or username) associated with the WandB run.
    /// </summary>
    /// <param name="Value">
    /// The entity to associate with the run. If not specified, the default entity
    /// for the registered WandB API key will be used.
    /// </param>
    /// <returns>
    /// The updated instance of the <c>TWanDB</c> class.
    /// </returns>
    property Entity: string read FEntity write FEntity;
    /// <summary>
    /// Gets or sets the tags to be attached to the WandB run.
    /// </summary>
    /// <param name="Value">
    /// An array of strings representing tags to attach to the run. These tags can help categorize and
    /// filter runs in WandB.
    /// </param>
    /// <returns>
    /// The updated instance of the <c>TWanDB</c> class.
    /// </returns>
    property Tags: TArray<string> read FTags write FTags;
  end;

  /// <summary>
  /// Represents the integration settings for a fine-tuning job, including integration with tools
  /// like Weights and Biases (WandB).
  /// </summary>
  /// <remarks>
  /// This class allows configuration of the type of integration and specific settings for each tool,
  /// such as WandB.
  /// </remarks>
  FineTuningJobIntegration = class
  private
    FType: string;
    FWandb: TWanDB;
  public
    /// <summary>
    /// Gets or sets the type of integration being enabled for the fine-tuning job.
    /// </summary>
    /// <remarks>
    /// A string representing the integration type, such as "wandb".
    /// </remarks>
    property &Type: string read FType write FType;
    /// <summary>
    /// Gets or sets the configuration for the Weights and Biases (WandB) integration.
    /// </summary>
    /// <remarks>
    /// An instance of the <c>TWanDB</c> class containing the WandB settings, such as project name,
    /// tags, and entity.
    /// </remarks>
    property Wandb: TWanDB read FWandb write FWandb;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents the configuration for supervised fine-tuning in a fine-tuning job.
  /// </summary>
  /// <remarks>
  /// This class contains the hyperparameters that define the supervised fine-tuning process.
  /// </remarks>
  TSupervised = class
  private
    FHyperparameters: THyperparameters;
  public
    /// <summary>
    /// Gets or sets the hyperparameters for the supervised fine-tuning method.
    /// </summary>
    /// <remarks>
    /// An instance of the <c>THyperparameters</c> class containing the configuration details, such as
    /// batch size, learning rate, and number of epochs.
    /// </remarks>
    property Hyperparameters: THyperparameters read FHyperparameters write FHyperparameters;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents the configuration for the DPO (Direct Preference Optimization) fine-tuning method
  /// in a fine-tuning job.
  /// </summary>
  /// <remarks>
  /// This class contains the hyperparameters that define the DPO fine-tuning process.
  /// </remarks>
  TDpo = class
  private
    FHyperparameters: THyperparameters;
  public
    /// <summary>
    /// Gets or sets the hyperparameters for the DPO fine-tuning method.
    /// </summary>
    /// <remarks
    /// An instance of the <c>THyperparameters</c> class containing the configuration details, such as
    /// beta, batch size, learning rate, and number of epochs.
    /// </remarks>
    property Hyperparameters: THyperparameters read FHyperparameters write FHyperparameters;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents the method configuration for fine-tuning in a fine-tuning job.
  /// </summary>
  /// <remarks>
  /// This class defines the type of fine-tuning method (e.g., supervised or DPO) and includes the
  /// specific configurations for each method.
  /// </remarks>
  TFineTuningMethod = class
  private
    [JsonReflectAttribute(ctString, rtString, TJobMethodTypeInterceptor)]
    FType: TJobMethodType;
    FSupervised: TSupervised;
    FDpo: TDpo;
  public
    /// <summary>
    /// Gets or sets the type of fine-tuning method.
    /// </summary>
    /// <remarks>
    /// A value of type <c>TJobMethodType</c> that specifies whether the method is "supervised" or "dpo".
    /// </remarks>
    property &Type: TJobMethodType read FType write FType;
    /// <summary>
    /// Gets or sets the configuration for supervised fine-tuning.
    /// </summary>
    /// <remarks>
    /// An instance of the <c>TSupervised</c> class containing the hyperparameters for supervised
    /// fine-tuning.
    /// </remarks>
    property Supervised: TSupervised read FSupervised write FSupervised;
    /// <summary>
    /// Gets or sets the configuration for DPO (Direct Preference Optimization) fine-tuning.
    /// </summary>
    /// <remarks>
    /// An instance of the <c>TDpo</c> class containing the hyperparameters for DPO fine-tuning.
    /// </remarks>
    property Dpo: TDpo read FDpo write FDpo;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a fine-tuning job in OpenAI's fine-tuning API.
  /// </summary>
  /// <remarks>
  /// This class contains details about a fine-tuning job, including its status, configuration, and results.
  /// </remarks>
  TFineTuningJob = class(TJSONFingerprint)
  private
    FId: string;
    [JsonNameAttribute('created_at')]
    FCreatedAt: TInt64OrNull;
    FError: TFineTuningJobError;
    [JsonNameAttribute('fine_tuned_model')]
    FFineTunedModel: string;
    [JsonNameAttribute('finished_at')]
    FFinishedAt: TInt64OrNull;
    FHyperparameters: THyperparameters;
    FModel: string;
    FObject: string;
    [JsonNameAttribute('organization_id')]
    FOrganizationId: string;
    [JsonNameAttribute('result_files')]
    FResultFiles: TArray<string>;
    [JsonReflectAttribute(ctString, rtString, TFineTunedStatusInterceptor)]
    FStatus: TFineTunedStatus;
    [JsonNameAttribute('trained_tokens')]
    FTrainedTokens: Int64;
    [JsonNameAttribute('training_file')]
    FTrainingFile: string;
    [JsonNameAttribute('validation_file')]
    FValidationFile: string;
    FIntegrations: TArray<FineTuningJobIntegration>;
    FSeed: Int64;
    [JsonNameAttribute('estimated_finish')]
    FEstimatedFinish: TInt64OrNull;
    FMethod: TFineTuningMethod;
  private
    function GetCreatedAtAsString: string;
    function GetFinishedAtAsString: string;
    function GetEstimatedFinishAsString: string;
    function GetCreatedAt: Int64;
    function GetEstimatedFinish: Int64;
    function GetFinishedAt: Int64;
  public
    /// <summary>
    /// Gets or sets the unique identifier of the fine-tuning job.
    /// </summary>
    /// <remarks>
    /// A string representing the fine-tuning job's ID.
    /// </remarks>
    property Id: string read FId write FId;
    /// <summary>
    /// Gets the creation timestamp of the fine-tuning job in Unix format (seconds).
    /// </summary>
    /// <remarks>
    /// A 64-bit integer representing the creation time of the job.
    /// </remarks>
    property CreatedAt: Int64 read GetCreatedAt;
    /// <summary>
    /// Gets the creation timestamp of the fine-tuning job as a human-readable string.
    /// </summary>
    /// <remarks>
    /// A string representation of the job's creation timestamp.
    /// </remarks>
    property CreatedAtAsString: string read GetCreatedAtAsString;
    /// <summary>
    /// Gets or sets the error details, if the fine-tuning job has failed.
    /// </summary>
    /// <remarks>
    /// An instance of <c>TFineTuningJobError</c> containing error information, or <c>nil</c> if no error occurred.
    /// </remarks>
    property Error: TFineTuningJobError read FError write FError;
    /// <summary>
    /// Gets or sets the name of the fine-tuned model created by this job.
    /// </summary>
    /// <remarks>
    /// A string representing the name of the fine-tuned model, or <c>nil</c> if the job is not complete.
    /// </remarks>
    property FineTunedModel: string read FFineTunedModel write FFineTunedModel;
    /// <summary>
    /// Gets or sets the completion timestamp of the fine-tuning job in Unix format (seconds).
    /// </summary>
    /// <remarks>
    /// A 64-bit integer representing the completion time of the job, or <c>nil</c> if the job is still running.
    /// </remarks>
    property FinishedAt: Int64 read GetFinishedAt;
    /// <summary>
    /// Gets the completion timestamp of the fine-tuning job as a human-readable string.
    /// </summary>
    /// <remarks>
    /// A string representation of the job's completion timestamp.
    /// </remarks>
    property FinishedAtAsString: string read GetFinishedAtAsString;
    /// <summary>
    /// Gets or sets the hyperparameters used in the fine-tuning job.
    /// </summary>
    /// <remarks>
    /// An instance of the <c>THyperparameters</c> class containing the hyperparameter configuration.
    /// </remarks>
    property Hyperparameters: THyperparameters read FHyperparameters write FHyperparameters;
    /// <summary>
    /// Gets or sets the base model being fine-tuned.
    /// </summary>
    /// <remarks>
    /// A string representing the name of the base model.
    /// </remarks>
    property Model: string read FModel write FModel;
    /// <summary>
    /// Gets or sets the object type for the fine-tuning job.
    /// </summary>
    /// <remarks>
    /// A string that always indicates the type of this object, typically "fine_tuning.job".
    /// </remarks>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// Gets or sets the organization ID associated with the fine-tuning job.
    /// </summary>
    /// <remarks>
    /// A string representing the organization ID.
    /// </remarks>
    property OrganizationId: string read FOrganizationId write FOrganizationId;
    /// <summary>
    /// Gets or sets the list of result file IDs generated by the fine-tuning job.
    /// </summary>
    /// <remarks>
    /// An array of strings containing the IDs of the result files.
    /// </remarks>
    property ResultFiles: TArray<string> read FResultFiles write FResultFiles;
    /// <summary>
    /// Gets or sets the current status of the fine-tuning job.
    /// </summary>
    /// <remarks>
    /// A value of type <c>TFineTunedStatus</c> representing the job's status (e.g., running, succeeded, failed).
    /// </remarks>
    property Status: TFineTunedStatus read FStatus write FStatus;
    /// <summary>
    /// Gets or sets the total number of billable tokens processed by this fine-tuning job.
    /// </summary>
    /// <remarks>
    /// A 64-bit integer representing the total tokens processed, or <c>nil</c> if the job is still running.
    /// </remarks>
    property TrainedTokens: Int64 read FTrainedTokens write FTrainedTokens;
    /// <summary>
    /// Gets or sets the file ID used for training data in the fine-tuning job.
    /// </summary>
    /// <remarks>
    /// A string representing the training file ID.
    /// </remarks>
    property TrainingFile: string read FTrainingFile write FTrainingFile;
    /// <summary>
    /// Gets or sets the file ID used for validation data in the fine-tuning job.
    /// </summary>
    /// <remarks>
    /// A string representing the validation file ID, or <c>nil</c> if no validation file was provided.
    /// </remarks>
    property ValidationFile: string read FValidationFile write FValidationFile;
    /// <summary>
    /// Gets or sets the list of integrations enabled for the fine-tuning job.
    /// </summary>
    /// <remarks>
    /// An array of <c>FineTuningJobIntegration</c> instances representing the enabled integrations.
    /// </remarks>
    property Integrations: TArray<FineTuningJobIntegration> read FIntegrations write FIntegrations;
    /// <summary>
    /// Gets or sets the random seed used for the fine-tuning job.
    /// </summary>
    /// <remarks>
    /// A 64-bit integer representing the seed value.
    /// </remarks>
    property Seed: Int64 read FSeed write FSeed;
    /// <summary>
    /// Gets the estimated completion time for the fine-tuning job in Unix format (seconds).
    /// </summary>
    /// <remarks>
    /// A 64-bit integer representing the estimated finish time, or <c>nil</c> if the job is not running.
    /// </remarks>
    property EstimatedFinish: Int64 read GetEstimatedFinish;
    /// <summary>
    /// Gets the estimated completion time of the fine-tuning job as a human-readable string.
    /// </summary>
    /// <remarks>
    /// A string representation of the job's estimated finish time.
    /// </remarks>
    property EstimatedFinishAsString: string read GetEstimatedFinishAsString;
    /// <summary>
    /// Gets or sets the method configuration for the fine-tuning job.
    /// </summary>
    /// <remarks>
    /// An instance of the <c>TFineTuningMethod</c> class containing the method configuration.
    /// </remarks>
    property Method: TFineTuningMethod read FMethod write FMethod;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a list of fine-tuning jobs in OpenAI's fine-tuning API.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TPaginatedList</c> to provide a collection of fine-tuning jobs and their details.
  /// </remarks>
  TFineTuningJobs = TPaginatedList<TFineTuningJob>;

  TEventData = class
  private
  public
  end;

  /// <summary>
  /// Represents an event associated with a fine-tuning job in OpenAI's fine-tuning API.
  /// </summary>
  /// <remarks>
  /// This class provides information about a specific event, including its type, timestamp,
  /// message, and associated data.
  /// </remarks>
  TJobEvent = class
  private
    FObject: string;
    FId: string;
    [JsonNameAttribute('created_at')]
    FCreatedAt: TInt64OrNull;
    FLevel: string;
    FMessage: string;
    FType: string;
    FData: TEventData;
  private
    function GetCreatedAtAsString: string;
    function GetCreatedAt: Int64;
  public
    /// <summary>
    /// Gets or sets the object type of the event.
    /// </summary>
    /// <remarks>
    /// A string that always has the value "fine_tuning.job.event".
    /// </remarks>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// Gets or sets the unique identifier for the event.
    /// </summary>
    /// <remarks>
    /// A string representing the event's unique ID.
    /// </remarks>
    property Id: string read FId write FId;
    /// <summary>
    /// Gets the timestamp when the event was created, in Unix format (seconds).
    /// </summary>
    /// <remarks>
    /// A 64-bit integer representing the event's creation time.
    /// </remarks>
    property CreatedAt: Int64 read GetCreatedAt;
    /// <summary>
    /// Gets the creation timestamp of the event as a human-readable string.
    /// </summary>
    /// <remarks>
    /// A string representation of the event's creation timestamp.
    /// </remarks>
    property CreatedAtAsString: string read GetCreatedAtAsString;
    /// <summary>
    /// Gets or sets the log level of the event.
    /// </summary>
    /// <remarks>
    /// A string indicating the log level (e.g., "info", "warning", "error").
    /// </remarks>
    property Level: string read FLevel write FLevel;
    /// <summary>
    /// Gets or sets the message associated with the event.
    /// </summary>
    /// <remarks>
    /// A string containing a human-readable description of the event.
    /// </remarks>
    property Message: string read FMessage write FMessage;
    /// <summary>
    /// Gets or sets the type of the event.
    /// </summary>
    /// <remarks>
    /// A string describing the event type (e.g., "status", "metrics").
    /// </remarks>
    property &Type: string read FType write FType;
    /// <summary>
    /// Gets or sets the additional data associated with the event.
    /// </summary>
    /// <remarks>
    /// An instance of <c>TEventData</c> containing event-specific data, or <c>nil</c> if no data is available.
    /// </remarks>
    property Data: TEventData read FData write FData;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a list of events associated with a fine-tuning job in OpenAI's fine-tuning API.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TPaginatedList</c> to provide a collection of events for a specific fine-tuning job,
  /// including their details such as type, message, and timestamps.
  /// </remarks>
  TJobEvents = TPaginatedList<TJobEvent>;

  /// <summary>
  /// Represents the metrics collected during a fine-tuning job in OpenAI's fine-tuning API.
  /// </summary>
  /// <remarks>
  /// This class contains various metrics related to the training and validation process,
  /// including loss values and token accuracy.
  /// </remarks>
  TMetrics = class
  private
    FStep: Double;
    [JsonNameAttribute('train_loss')]
    FTrainLoss: Double;
    [JsonNameAttribute('train_mean_token_accuracy')]
    FTrainMeanTokenAccuracy: Double;
    [JsonNameAttribute('valid_loss')]
    FValidLoss: Double;
    [JsonNameAttribute('valid_mean_token_accuracy')]
    FValidMeanTokenAccuracy: Double;
    [JsonNameAttribute('full_valid_loss')]
    FFullValidLoss: Double;
    [JsonNameAttribute('full_valid_mean_token_accuracy')]
    FFullValidMeanTokenAccuracy: Double;
  public
    /// <summary>
    /// Gets or sets the current step number in the fine-tuning process.
    /// </summary>
    /// <remarks>
    /// A double representing the step at which the metrics were collected.
    /// </remarks>
    property Step: Double read FStep write FStep;
    /// <summary>
    /// Gets or sets the training loss at the specified step.
    /// </summary>
    /// <remarks>
    /// A double representing the loss value calculated from the training dataset.
    /// </remarks>
    property TrainLoss: Double read FTrainLoss write FTrainLoss;
    /// <summary>
    /// Gets or sets the mean token accuracy during training at the specified step.
    /// </summary>
    /// <remarks>
    /// A double representing the average accuracy of tokens processed during training.
    /// </remarks>
    property TrainMeanTokenAccuracy: Double read FTrainMeanTokenAccuracy write FTrainMeanTokenAccuracy;
    /// <summary>
    /// Gets or sets the validation loss at the specified step.
    /// </summary>
    /// <remarks>
    /// A double representing the loss value calculated from the validation dataset.
    /// </remarks>
    property ValidLoss: Double read FValidLoss write FValidLoss;
    /// <summary>
    /// Gets or sets the mean token accuracy during validation at the specified step.
    /// </summary>
    /// <remarks>
    /// A double representing the average accuracy of tokens processed during validation.
    /// </remarks>
    property ValidMeanTokenAccuracy: Double read FValidMeanTokenAccuracy write FValidMeanTokenAccuracy;
    /// <summary>
    /// Gets or sets the full validation loss at the specified step.
    /// </summary>
    /// <remarks>
    /// A double representing the loss value calculated from the entire validation dataset.
    /// </remarks>
    property FullValidLoss: Double read FFullValidLoss write FFullValidLoss;
    /// <summary>
    /// Gets or sets the mean token accuracy over the entire validation dataset at the specified step.
    /// </summary>
    /// <remarks>
    /// A double representing the average accuracy of tokens processed over the full validation dataset.
    /// </remarks>
    property FullValidMeanTokenAccuracy: Double read FFullValidMeanTokenAccuracy write FFullValidMeanTokenAccuracy;
  end;

  /// <summary>
  /// Represents a model checkpoint for a fine-tuning job in OpenAI's fine-tuning API.
  /// </summary>
  /// <remarks>
  /// This class contains details about a specific checkpoint, including the step number, metrics,
  /// and the fine-tuned model checkpoint identifier.
  /// </remarks>
  TJobCheckpoint = class
  private
    FId: string;
    [JsonNameAttribute('created_at')]
    FCreatedAt: TInt64OrNull;
    [JsonNameAttribute('fine_tuned_model_checkpoint')]
    FFineTunedModelCheckpoint: string;
    [JsonNameAttribute('step_number')]
    FStepNumber: Int64;
    FMetrics: TMetrics;
    [JsonNameAttribute('fine_tuning_job_id')]
    FFineTuningJobId: string;
    FObject: string;
  private
    function GetCreatedAtAsString: string;
    function GetCreatedAt: Int64;
  public
    /// <summary>
    /// Gets or sets the unique identifier for the checkpoint.
    /// </summary>
    /// <remarks>
    /// A string representing the checkpoint's unique ID.
    /// </remarks>
    property Id: string read FId write FId;
    /// <summary>
    /// Gets the timestamp when the checkpoint was created, in Unix format (seconds).
    /// </summary>
    /// <remarks>
    /// A 64-bit integer representing the checkpoint's creation time.
    /// </remarks>
    property CreatedAt: Int64 read GetCreatedAt;
    /// <summary>
    /// Gets the creation timestamp of the checkpoint as a human-readable string.
    /// </summary>
    /// <remarks>
    /// A string representation of the checkpoint's creation timestamp.
    /// </remarks>
    property CreatedAtAsString: string read GetCreatedAtAsString;
    /// <summary>
    /// Gets or sets the identifier of the fine-tuned model checkpoint.
    /// </summary>
    /// <remarks>
    /// A string representing the name of the fine-tuned model checkpoint.
    /// </remarks>
    property FineTunedModelCheckpoint: string read FFineTunedModelCheckpoint write FFineTunedModelCheckpoint;
    /// <summary>
    /// Gets or sets the step number when this checkpoint was created.
    /// </summary>
    /// <remarks>
    /// A 64-bit integer representing the step number at which the checkpoint was generated.
    /// </remarks>
    property StepNumber: Int64 read FStepNumber write FStepNumber;
    /// <summary>
    /// Gets or sets the metrics recorded at the checkpoint's step.
    /// </summary>
    /// <remarks>
    /// An instance of <c>TMetrics</c> containing metrics such as training loss and accuracy.
    /// </remarks>
    property Metrics: TMetrics read FMetrics write FMetrics;
    /// <summary>
    /// Gets or sets the ID of the fine-tuning job associated with this checkpoint.
    /// </summary>
    /// <remarks>
    /// A string representing the ID of the fine-tuning job that generated this checkpoint.
    /// </remarks>
    property FineTuningJobId: string read FFineTuningJobId write FFineTuningJobId;
    /// <summary>
    /// Gets or sets the object type of the checkpoint.
    /// </summary>
    /// <remarks>
    /// A string that always has the value "fine_tuning.job.checkpoint".
    /// </remarks>
    property &Object: string read FObject write FObject;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a list of checkpoints for a fine-tuning job in OpenAI's fine-tuning API.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TPaginatedList</c> to provide a collection of checkpoints generated during
  /// a fine-tuning job. Each checkpoint includes details such as step number, metrics, and associated model data.
  /// </remarks>
  TJobCheckpoints = TPaginatedList<TJobCheckpoint>;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TFineTuningJob</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynFineTuningJob</c> type extends the <c>TAsynParams&lt;TFineTuningJob&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynFineTuningJob = TAsynCallBack<TFineTuningJob>;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TFineTuningJobs</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynFineTuningJobs</c> type extends the <c>TAsynParams&lt;TFineTuningJobs&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynFineTuningJobs = TAsynCallBack<TFineTuningJobs>;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TJobEvents</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynJobEvents</c> type extends the <c>TAsynParams&lt;TJobEvents&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynJobEvents = TAsynCallBack<TJobEvents>;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TJobCheckpoints</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynFineJobCheckpoints</c> type extends the <c>TAsynParams&lt;TJobCheckpoints&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynJobCheckpoints = TAsynCallBack<TJobCheckpoints>;

  /// <summary>
  /// Provides methods to interact with the OpenAI fine-tuning API routes.
  /// </summary>
  /// <remarks>
  /// This class includes methods for creating, retrieving, listing, canceling, and managing fine-tuning jobs,
  /// as well as accessing associated events and checkpoints.
  /// </remarks>
  TFineTuningRoute = class(TGenAIRoute)
    /// <summary>
    /// Asynchronously creates a new fine-tuning job with the specified parameters.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure that sets the parameters for the fine-tuning job.
    /// </param>
    /// <param name="CallBacks">
    /// A function that defines the asynchronous callback behavior.
    /// </param>
    /// <remarks>
    /// This method initiates a fine-tuning job creation and invokes the provided callbacks when complete.
    /// </remarks>
    procedure AsynCreate(const ParamProc: TProc<TFineTuningJobParams>; const CallBacks: TFunc<TAsynFineTuningJob>);
    /// <summary>
    /// Asynchronously cancels a running fine-tuning job.
    /// </summary>
    /// <param name="JobId">
    /// The ID of the fine-tuning job to cancel.
    /// </param>
    /// <param name="CallBacks">
    /// A function that defines the asynchronous callback behavior.
    /// </param>
    /// <remarks>
    /// This method cancels a fine-tuning job and invokes the provided callbacks when complete.
    /// </remarks>
    procedure AsynCancel(const JobId: string; const CallBacks: TFunc<TAsynFineTuningJob>);
    /// <summary>
    /// Asynchronously retrieves a list of fine-tuning jobs.
    /// </summary>
    /// <param name="CallBacks">
    /// A function that defines the asynchronous callback behavior.
    /// </param>
    /// <remarks>
    /// This method retrieves all fine-tuning jobs associated with the account and invokes the callbacks when complete.
    /// </remarks>
    procedure AsynList(const CallBacks: TFunc<TAsynFineTuningJobs>); overload;
    /// <summary>
    /// Asynchronously retrieves a list of fine-tuning jobs with additional query parameters.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to define query parameters such as pagination.
    /// </param>
    /// <param name="CallBacks">
    /// A function that defines the asynchronous callback behavior.
    /// </param>
    /// <remarks>
    /// This method retrieves fine-tuning jobs using the specified parameters and invokes the callbacks when complete.
    /// </remarks>
    procedure AsynList(const ParamProc: TProc<TUrlPaginationParams>; const CallBacks: TFunc<TAsynFineTuningJobs>); overload;
    /// <summary>
    /// Asynchronously retrieves events for a specific fine-tuning job.
    /// </summary>
    /// <param name="JobId">
    /// The ID of the fine-tuning job for which events are being retrieved.
    /// </param>
    /// <param name="CallBacks">
    /// A function that defines the asynchronous callback behavior.
    /// </param>
    /// <remarks>
    /// This method retrieves status updates and events for the specified fine-tuning job.
    /// </remarks>
    procedure AsynEvents(const JobId: string; const CallBacks: TFunc<TAsynJobEvents>); overload;
    /// <summary>
    /// Asynchronously retrieves events for a specific fine-tuning job with additional query parameters.
    /// </summary>
    /// <param name="JobId">
    /// The ID of the fine-tuning job for which events are being retrieved.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to define query parameters such as pagination.
    /// </param>
    /// <param name="CallBacks">
    /// A function that defines the asynchronous callback behavior.
    /// </param>
    /// <remarks>
    /// This method retrieves status updates and events for the specified fine-tuning job
    /// with additional parameters for customization.
    /// </remarks>
    procedure AsynEvents(const JobId: string; const ParamProc: TProc<TUrlPaginationParams>;
      const CallBacks: TFunc<TAsynJobEvents>); overload;
    /// <summary>
    /// Asynchronously retrieves checkpoints for a specific fine-tuning job.
    /// </summary>
    /// <param name="JobId">
    /// The ID of the fine-tuning job for which checkpoints are being retrieved.
    /// </param>
    /// <param name="CallBacks">
    /// A function that defines the asynchronous callback behavior.
    /// </param>
    /// <remarks>
    /// This method retrieves checkpoints generated during the specified fine-tuning job.
    /// </remarks>
    procedure AsynCheckpoints(const JobId: string; const CallBacks: TFunc<TAsynJobCheckpoints>); overload;
    /// <summary>
    /// Asynchronously retrieves checkpoints for a specific fine-tuning job with additional query parameters.
    /// </summary>
    /// <param name="JobId">
    /// The ID of the fine-tuning job for which checkpoints are being retrieved.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to define query parameters such as pagination.
    /// </param>
    /// <param name="CallBacks">
    /// A function that defines the asynchronous callback behavior.
    /// </param>
    /// <remarks>
    /// This method retrieves checkpoints generated during the specified fine-tuning job
    /// with additional parameters for customization.
    /// </remarks>
    procedure AsynCheckpoints(const JobId: string; const ParamProc: TProc<TUrlPaginationParams>;
      const CallBacks: TFunc<TAsynJobCheckpoints>); overload;
    /// <summary>
    /// Asynchronously retrieves details about a specific fine-tuning job.
    /// </summary>
    /// <param name="JobId">
    /// The ID of the fine-tuning job to retrieve.
    /// </param>
    /// <param name="CallBacks">
    /// A function that defines the asynchronous callback behavior.
    /// </param>
    /// <remarks>
    /// This method retrieves details about the specified fine-tuning job and invokes the callbacks when complete.
    /// </remarks>
    procedure AsynRetrieve(const JobId: string; const CallBacks: TFunc<TAsynFineTuningJob>);
    /// <summary>
    /// Creates a new fine-tuning job with the specified parameters.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure that sets the parameters for the fine-tuning job.
    /// </param>
    /// <returns>
    /// An instance of <c>TFineTuningJob</c> containing the details of the created job.
    /// </returns>
    /// <remarks>
    /// This method synchronously creates a fine-tuning job and returns the job details.
    /// </remarks>
    function Create(const ParamProc: TProc<TFineTuningJobParams>): TFineTuningJob;
    /// <summary>
    /// Cancels a running fine-tuning job.
    /// </summary>
    /// <param name="JobId">
    /// The ID of the fine-tuning job to cancel.
    /// </param>
    /// <returns>
    /// An instance of <c>TFineTuningJob</c> with updated status after cancellation.
    /// </returns>
    /// <remarks>
    /// This method synchronously cancels the specified fine-tuning job.
    /// </remarks>
    function Cancel(const JobId: string): TFineTuningJob;
    /// <summary>
    /// Retrieves a list of fine-tuning jobs.
    /// </summary>
    /// <returns>
    /// An instance of <c>TFineTuningJobs</c> containing the list of fine-tuning jobs.
    /// </returns>
    /// <remarks>
    /// This method synchronously retrieves all fine-tuning jobs associated with the account.
    /// </remarks>
    function List: TFineTuningJobs; overload;
    /// <summary>
    /// Retrieves a list of fine-tuning jobs with additional query parameters.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to define query parameters such as pagination.
    /// </param>
    /// <returns>
    /// An instance of <c>TFineTuningJobs</c> containing the list of fine-tuning jobs.
    /// </returns>
    /// <remarks>
    /// This method synchronously retrieves fine-tuning jobs using the specified parameters.
    /// </remarks>
    function List(const ParamProc: TProc<TUrlPaginationParams>): TFineTuningJobs; overload;
    /// <summary>
    /// Retrieves events for a specific fine-tuning job.
    /// </summary>
    /// <param name="JobId">
    /// The ID of the fine-tuning job for which events are being retrieved.
    /// </param>
    /// <returns>
    /// An instance of <c>TJobEvents</c> containing the events associated with the job.
    /// </returns>
    /// <remarks>
    /// This method synchronously retrieves status updates and events for the specified fine-tuning job.
    /// </remarks>
    function Events(const JobId: string): TJobEvents; overload;
    /// <summary>
    /// Retrieves events for a specific fine-tuning job with additional query parameters.
    /// </summary>
    /// <param name="JobId">
    /// The ID of the fine-tuning job for which events are being retrieved.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to define query parameters such as pagination.
    /// </param>
    /// <returns>
    /// An instance of <c>TJobEvents</c> containing the events associated with the job.
    /// </returns>
    /// <remarks>
    /// This method synchronously retrieves status updates and events for the specified fine-tuning job
    /// with additional parameters for customization.
    /// </remarks>
    function Events(const JobId: string; const ParamProc: TProc<TUrlPaginationParams>): TJobEvents; overload;
    /// <summary>
    /// Retrieves checkpoints for a specific fine-tuning job.
    /// </summary>
    /// <param name="JobId">
    /// The ID of the fine-tuning job for which checkpoints are being retrieved.
    /// </param>
    /// <returns>
    /// An instance of <c>TJobCheckpoints</c> containing the checkpoints generated during the job.
    /// </returns>
    /// <remarks>
    /// This method synchronously retrieves checkpoints for the specified fine-tuning job.
    /// </remarks>
    function Checkpoints(const JobId: string): TJobCheckpoints; overload;
    /// <summary>
    /// Retrieves checkpoints for a specific fine-tuning job with additional query parameters.
    /// </summary>
    /// <param name="JobId">
    /// The ID of the fine-tuning job for which checkpoints are being retrieved.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to define query parameters such as pagination.
    /// </param>
    /// <returns>
    /// An instance of <c>TJobCheckpoints</c> containing the checkpoints generated during the job.
    /// </returns>
    /// <remarks>
    /// This method synchronously retrieves checkpoints for the specified fine-tuning job
    /// with additional parameters for customization.
    /// </remarks>
    function Checkpoints(const JobId: string; const ParamProc: TProc<TUrlPaginationParams>): TJobCheckpoints; overload;
    /// <summary>
    /// Retrieves details about a specific fine-tuning job.
    /// </summary>
    /// <param name="JobId">
    /// The ID of the fine-tuning job to retrieve.
    /// </param>
    /// <returns>
    /// An instance of <c>TFineTuningJob</c> containing the details of the job.
    /// </returns>
    /// <remarks>
    /// This method synchronously retrieves details about the specified fine-tuning job.
    /// </remarks>
    function Retrieve(const JobId: string): TFineTuningJob;
  end;

implementation

{ TFineTuningJobParams }

function TFineTuningJobParams.Integrations(
  const Value: TArray<TJobIntegrationParams>): TFineTuningJobParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TFineTuningJobParams(Add('integrations', JSONArray));
end;

function TFineTuningJobParams.Method(
  const Value: TJobMethodParams): TFineTuningJobParams;
begin
  Result := TFineTuningJobParams(Add('method', Value.Detach));
end;

function TFineTuningJobParams.Method(const AType: TJobMethodType;
  const Value: THyperparametersParams): TFineTuningJobParams;
begin
  case AType of
    TJobMethodType.supervised:
      Result := Method(TJobMethodParams.NewSupervised(Value));
    TJobMethodType.dpo:
      Result := Method(TJobMethodParams.NewDpo(Value));
    else
      Result := Self;
  end;
end;

function TFineTuningJobParams.Model(const Value: string): TFineTuningJobParams;
begin
  Result := TFineTuningJobParams(Add('model', Value));
end;

function TFineTuningJobParams.Seed(const Value: Integer): TFineTuningJobParams;
begin
  Result := TFineTuningJobParams(Add('seed', Value));
end;

function TFineTuningJobParams.Suffix(const Value: string): TFineTuningJobParams;
begin
  Result := TFineTuningJobParams(Add('suffix', Value));
end;

function TFineTuningJobParams.TrainingFile(
  const Value: string): TFineTuningJobParams;
begin
  Result := TFineTuningJobParams(Add('training_file', Value));
end;

function TFineTuningJobParams.ValidationFile(
  const Value: string): TFineTuningJobParams;
begin
  Result := TFineTuningJobParams(Add('validation_file', Value));
end;

{ TJobIntegrationParams }

function TJobIntegrationParams.&Type(const Value: string): TJobIntegrationParams;
begin
  Result := TJobIntegrationParams(Add('type', Value));
end;

function TJobIntegrationParams.Wandb(const Value: TWandbParams): TJobIntegrationParams;
begin
  Result := TJobIntegrationParams(Add('wandb', Value.Detach));
end;

function TJobIntegrationParams.Wandb(const Value: TJSONObject): TJobIntegrationParams;
begin
  Result := TJobIntegrationParams(Add('wandb', Value));
end;

{ TWandbParams }

function TWandbParams.Entity(const Value: string): TWandbParams;
begin
  Result := TWandbParams(Add('entity', Value));
end;

function TWandbParams.Name(const Value: string): TWandbParams;
begin
  Result := TWandbParams(Add('name', Value));
end;

class function TWandbParams.New(const Project, Name, Entity: string;
  const Tags: TArray<string>): TWandbParams;
begin
  Result := TWandbParams.Create.Project(Project).Name(Name).Entity(Entity).Tags(Tags);
end;

function TWandbParams.Project(const Value: string): TWandbParams;
begin
  Result := TWandbParams(Add('project', Value));
end;

function TWandbParams.Tags(const Value: TArray<string>): TWandbParams;
begin
  Result := TWandbParams(Add('tags', Value));
end;

{ TJobMethodParams }

function TJobMethodParams.&Type(const Value: string): TJobMethodParams;
begin
  Result := TJobMethodParams(Add('type', TJobMethodType.Create(Value).ToString));
end;

function TJobMethodParams.Dpo(const Value: TDpoMethodParams): TJobMethodParams;
begin
  Result := TJobMethodParams(Add('dpo', Value.Detach));
end;

class function TJobMethodParams.NewDpo(const Value: THyperparametersParams): TJobMethodParams;
begin
  Result := TJobMethodParams.Create.&Type(TJobMethodType.dpo).Dpo(TDpoMethodParams.New(Value));
end;

class function TJobMethodParams.NewSupervised(
  const Value: THyperparametersParams): TJobMethodParams;
begin
  Result := TJobMethodParams.Create.&Type(TJobMethodType.supervised).Supervised(TSupervisedMethodParams.New(Value));
end;

function TJobMethodParams.Supervised(const Value: TSupervisedMethodParams): TJobMethodParams;
begin
  Result := TJobMethodParams(Add('supervised', Value.Detach));
end;

function TJobMethodParams.&Type(const Value: TJobMethodType): TJobMethodParams;
begin
  Result := TJobMethodParams(Add('type', Value.ToString));
end;

{ THyperparametersParams }

function THyperparametersParams.BatchSize(const Value: Integer): THyperparametersParams;
begin
  Result := THyperparametersParams(Add('batch_size', Value));
end;

function THyperparametersParams.Beta(const Value: Double): THyperparametersParams;
begin
  Result := THyperparametersParams(Add('type', Value));
end;

function THyperparametersParams.LearningRateMultiplier(
  const Value: Double): THyperparametersParams;
begin
  Result := THyperparametersParams(Add('learning_rate_multiplier', Value));
end;

function THyperparametersParams.NEpochs(const Value: Integer): THyperparametersParams;
begin
  Result := THyperparametersParams(Add('n_epochs', Value));
end;

{ TSupervisedMethodParams }

function TSupervisedMethodParams.Hyperparameters(
  const Value: THyperparametersParams): TSupervisedMethodParams;
begin
  Result := TSupervisedMethodParams(Add('hyperparameters', Value.Detach));
end;

class function TSupervisedMethodParams.New(
  const Value: THyperparametersParams): TSupervisedMethodParams;
begin
  Result := TSupervisedMethodParams.Create.Hyperparameters(Value);
end;

{ TDpoMethodParams }

function TDpoMethodParams.Hyperparameters(const Value: THyperparametersParams): TDpoMethodParams;
begin
  Result := TDpoMethodParams(Add('hyperparameters', Value.Detach));
end;

class function TDpoMethodParams.New(const Value: THyperparametersParams): TDpoMethodParams;
begin
  Result := TDpoMethodParams.Create.Hyperparameters(Value);
end;

{ TFineTuningJob }

destructor TFineTuningJob.Destroy;
begin
  if Assigned(FError) then
    FError.Free;
  if Assigned(FHyperparameters) then
    FHyperparameters.Free;
  for var Item in FIntegrations do
    Item.Free;
  if Assigned(FMethod) then
    FMethod.Free;
  inherited;
end;

function TFineTuningJob.GetCreatedAt: Int64;
begin
  Result := TInt64OrNull(FCreatedAt).ToInteger;
end;

function TFineTuningJob.GetCreatedAtAsString: string;
begin
  Result := TInt64OrNull(FCreatedAt).ToUtcDateString;
end;

function TFineTuningJob.GetEstimatedFinish: Int64;
begin
  Result := TInt64OrNull(FEstimatedFinish).ToInteger;
end;

function TFineTuningJob.GetEstimatedFinishAsString: string;
begin
  Result := TInt64OrNull(FEstimatedFinish).ToUtcDateString;
end;

function TFineTuningJob.GetFinishedAt: Int64;
begin
  Result := TInt64OrNull(FFinishedAt).ToInteger;
end;

function TFineTuningJob.GetFinishedAtAsString: string;
begin
  Result := TInt64OrNull(FFinishedAt).ToUtcDateString;
end;

{ FineTuningJobIntegration }

destructor FineTuningJobIntegration.Destroy;
begin
  if Assigned(FWandb) then
    FWandb.Free;
  inherited;
end;

{ TSupervised }

destructor TSupervised.Destroy;
begin
  if Assigned(FHyperparameters) then
    FHyperparameters.Free;
  inherited;
end;

{ TDpo }

destructor TDpo.Destroy;
begin
  if Assigned(FHyperparameters) then
    FHyperparameters.Free;
  inherited;
end;

{ TFineTuningMethod }

destructor TFineTuningMethod.Destroy;
begin
  if Assigned(FSupervised) then
    FSupervised.Free;
  if Assigned(FDpo) then
    FDpo.Free;
  inherited;
end;

{ TFineTuningRoute }

procedure TFineTuningRoute.AsynCancel(const JobId: string;
  const CallBacks: TFunc<TAsynFineTuningJob>);
begin
  with TAsynCallBackExec<TAsynFineTuningJob, TFineTuningJob>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TFineTuningJob
      begin
        Result := Self.Cancel(JobId);
      end);
  finally
    Free;
  end;
end;

procedure TFineTuningRoute.AsynCheckpoints(const JobId: string;
  const CallBacks: TFunc<TAsynJobCheckpoints>);
begin
  with TAsynCallBackExec<TAsynJobCheckpoints, TJobCheckpoints>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TJobCheckpoints
      begin
        Result := Self.Checkpoints(JobId);
      end);
  finally
    Free;
  end;
end;

procedure TFineTuningRoute.AsynCheckpoints(const JobId: string;
  const ParamProc: TProc<TUrlPaginationParams>;
  const CallBacks: TFunc<TAsynJobCheckpoints>);
begin
  with TAsynCallBackExec<TAsynJobCheckpoints, TJobCheckpoints>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TJobCheckpoints
      begin
        Result := Self.Checkpoints(JobId, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TFineTuningRoute.AsynCreate(
  const ParamProc: TProc<TFineTuningJobParams>;
  const CallBacks: TFunc<TAsynFineTuningJob>);
begin
  with TAsynCallBackExec<TAsynFineTuningJob, TFineTuningJob>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TFineTuningJob
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TFineTuningRoute.AsynEvents(const JobId: string;
  const CallBacks: TFunc<TAsynJobEvents>);
begin
  with TAsynCallBackExec<TAsynJobEvents, TJobEvents>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TJobEvents
      begin
        Result := Self.Events(JobId);
      end);
  finally
    Free;
  end;
end;

procedure TFineTuningRoute.AsynEvents(const JobId: string;
  const ParamProc: TProc<TUrlPaginationParams>;
  const CallBacks: TFunc<TAsynJobEvents>);
begin
  with TAsynCallBackExec<TAsynJobEvents, TJobEvents>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TJobEvents
      begin
        Result := Self.Events(JobId, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TFineTuningRoute.AsynList(
  const CallBacks: TFunc<TAsynFineTuningJobs>);
begin
  with TAsynCallBackExec<TAsynFineTuningJobs, TFineTuningJobs>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TFineTuningJobs
      begin
        Result := Self.List;
      end);
  finally
    Free;
  end;
end;

procedure TFineTuningRoute.AsynList(
  const ParamProc: TProc<TUrlPaginationParams>;
  const CallBacks: TFunc<TAsynFineTuningJobs>);
begin
  with TAsynCallBackExec<TAsynFineTuningJobs, TFineTuningJobs>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TFineTuningJobs
      begin
        Result := Self.List(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TFineTuningRoute.AsynRetrieve(const JobId: string;
  const CallBacks: TFunc<TAsynFineTuningJob>);
begin
  with TAsynCallBackExec<TAsynFineTuningJob, TFineTuningJob>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TFineTuningJob
      begin
        Result := Self.Retrieve(JobId);
      end);
  finally
    Free;
  end;
end;

function TFineTuningRoute.Cancel(const JobId: string): TFineTuningJob;
begin
  Result := API.Post<TFineTuningJob>('fine_tuning/jobs/' + JobId + '/cancel');
end;

function TFineTuningRoute.Checkpoints(const JobId: string): TJobCheckpoints;
begin
  Result := API.Get<TJobCheckpoints>('jobs/' + JobId + '/checkpoints');
end;

function TFineTuningRoute.Checkpoints(const JobId: string;
  const ParamProc: TProc<TUrlPaginationParams>): TJobCheckpoints;
begin
  Result := API.Get<TJobCheckpoints, TUrlPaginationParams>('jobs/' + JobId + '/checkpoints', ParamProc);
end;

function TFineTuningRoute.Create(
  const ParamProc: TProc<TFineTuningJobParams>): TFineTuningJob;
begin
  Result := API.Post<TFineTuningJob, TFineTuningJobParams>('fine_tuning/jobs', ParamProc);
end;

function TFineTuningRoute.Events(const JobId: string): TJobEvents;
begin
  Result := API.Get<TJobEvents>('jobs/'+ JobId + '/events');
end;

function TFineTuningRoute.Events(const JobId: string;
  const ParamProc: TProc<TUrlPaginationParams>): TJobEvents;
begin
  Result := API.Get<TJobEvents, TUrlPaginationParams>('jobs/'+ JobId + '/events', ParamProc);
end;

function TFineTuningRoute.List: TFineTuningJobs;
begin
  Result := API.Get<TFineTuningJobs>('fine_tuning/jobs');
end;

function TFineTuningRoute.List(
  const ParamProc: TProc<TUrlPaginationParams>): TFineTuningJobs;
begin
  Result := API.Get<TFineTuningJobs, TUrlPaginationParams>('fine_tuning/jobs', ParamProc);
end;

function TFineTuningRoute.Retrieve(const JobId: string): TFineTuningJob;
begin
  Result := API.Get<TFineTuningJob>('fine_tuning/jobs/' + JobId);
end;

{ TJobEvent }

destructor TJobEvent.Destroy;
begin
  if Assigned(FData) then
    FData.Free;
  inherited;
end;

function TJobEvent.GetCreatedAt: Int64;
begin
  Result := TInt64OrNull(FCreatedAt).ToInteger;
end;

function TJobEvent.GetCreatedAtAsString: string;
begin
  Result := TInt64OrNull(FCreatedAt).ToUtcDateString;
end;

{ TJobCheckpoint }

destructor TJobCheckpoint.Destroy;
begin
  if Assigned(FMetrics) then
    FMetrics.Free;
  inherited;
end;

function TJobCheckpoint.GetCreatedAt: Int64;
begin
  Result := TInt64OrNull(FCreatedAt).ToInteger;
end;

function TJobCheckpoint.GetCreatedAtAsString: string;
begin
  Result := TInt64OrNull(FCreatedAt).ToUtcDateString;
end;

end.

unit GenAI.Functions.Core;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.JSON;

type
  /// <summary>
  /// Interface defining the core structure and functionality of a function in the system.
  /// </summary>
  /// <remarks>
  /// This interface outlines the basic properties and methods that any function implementation must include.
  /// </remarks>
  IFunctionCore = interface
    ['{586B30A0-4C30-47BA-87F1-88A14BCD6F4B}']
    /// <summary>
    /// Retrieves the description of the function.
    /// </summary>
    function GetDescription: string;
    /// <summary>
    /// Retrieves the name of the function.
    /// </summary>
    function GetName: string;
    /// <summary>
    /// Retrieves the parameters required by the function, represented as a JSON schema.
    /// </summary>
    function GetParameters: string;
    /// <summary>
    /// Retrieves the strict schema adherence switch value.
    /// </summary>
    function GetStrict: Boolean;
    /// <summary>
    /// Set value to the strict schema adherence switch.
    /// </summary>
    procedure SetStrict(const Value: Boolean);
    /// <summary>
    /// Retrieves the type of the function, typically "function".
    /// </summary>
    function GetType: string;
    /// <summary>
    /// Executes the function with the provided arguments and returns the result as a string.
    /// </summary>
    /// <param name="Arguments">The arguments passed to the function in JSON format.</param>
    /// <returns>The result of the function execution as a string.</returns>
    function Execute(const Arguments: string): string;
     /// <summary>
    /// Converts the TFunctionCore instance to a JSON object that contains its type and representation.
    /// </summary>
    /// <returns>A JSON object representing the function instance.</returns>
    function ToJson: TJSONObject;
    /// <summary>
    /// Creates a string representation of the TFunctionCore instance in JSON format, including its description, name, and parameters.
    /// </summary>
    /// <returns>A string representation of the function in JSON format.</returns>
    function ToString: string;
    /// <summary>
    /// A brief description of the function's purpose, used by the model to determine when and how to call the function.
    /// </summary>
    property Description: string read GetDescription;
    /// <summary>
    /// The unique identifier of the function that will be called. It must only contain characters from a-z, A-Z, 0-9, underscores, or dashes, and should not exceed 64 characters in length.
    /// </summary>
    property Name: string read GetName;
    //// <summary>
    /// The parameters required by the function, specified as a JSON schema. If no parameters are required, use the schema: {"type": "object", "properties": {}}.
    /// </summary>
    property Parameters: string read GetParameters;
    /// <summary>
    /// The type of the tool. Currently, only "function" is supported.
    /// </summary>
    property &Type: string read GetType;
    /// <summary>
    /// Retrieves the strict schema adherence switch value.
    /// </summary>
    property &Strict: Boolean read GetStrict write SetStrict;
  end;

  /// <summary>
  /// Abstract base class for implementing core function behavior.
  /// </summary>
  /// <remarks>
  /// This class provides basic implementations for some methods and defines the structure that derived classes must follow.
  /// </remarks>
  TFunctionCore = class abstract(TinterfacedObject, IFunctionCore)
  protected
    FStrict: Boolean;
    /// <summary>
    /// Retrieves the description of the function. Derived classes must implement this method.
    /// </summary>
    function GetDescription: string; virtual; abstract;
     /// <summary>
    /// Retrieves the name of the function. Derived classes must implement this method.
    /// </summary>
    function GetName: string; virtual; abstract;
    /// <summary>
    /// Retrieves the parameters required by the function, represented as a JSON schema. Derived classes must implement this method.
    /// </summary>
    function GetParameters: string; virtual; abstract;
    /// <summary>
    /// Retrieves the type of the function, which is "function" by default.
    /// </summary>
    function GetType: string; virtual;
    /// <summary>
    /// Retrieves the strict schema adherence switch value.
    /// </summary>
    function GetStrict: Boolean; virtual;
    /// <summary>
    /// Set value to the strict schema adherence switch.
    /// </summary>
    procedure SetStrict(const Value: Boolean); virtual;
  public
    constructor Create(const IsStrict: Boolean = False);
    /// <summary>
    /// Executes the function with the provided arguments and returns the result as a string. Derived classes must implement this method.
    /// </summary>
    /// <param name="Arguments">The arguments passed to the function in JSON format.</param>
    /// <returns>The result of the function execution as a string.</returns>
    function Execute(const Arguments: string): string; virtual; abstract;
    /// <summary>
    /// Converts the TFunctionCore instance to a JSON object that contains its type and representation.
    /// </summary>
    /// <returns>A JSON object representing the function instance.</returns>
    function ToJson: TJSONObject;
    /// <summary>
    /// Creates a string representation of the TFunctionCore instance in JSON format, including its description, name, and parameters.
    /// </summary>
    /// <returns>A string representation of the function in JSON format.</returns>
    function ToString: string; override;
    /// <summary>
    /// A brief description of the function's purpose, used by the model to determine when and how to call the function.
    /// </summary>
    property Description: string read GetDescription;
    /// <summary>
    /// The unique identifier of the function that will be called. It must only contain characters from a-z, A-Z, 0-9, underscores, or dashes, and should not exceed 64 characters in length.
    /// </summary>
    property Name: string read GetName;
    /// <summary>
    /// The parameters required by the function, specified as a JSON schema. If no parameters are required, use the schema: {"type": "object", "properties": {}}.
    /// </summary>
    property Parameters: string read GetParameters;
    /// <summary>
    /// The type of the tool. Currently, only "function" is supported.
    /// </summary>
    property &Type: string read GetType;
    /// <summary>
    /// Retrieves the strict schema adherence switch value.
    /// </summary>
    property &Strict: Boolean read GetStrict write SetStrict;
  end;

implementation

{ TFunctionCore }

constructor TFunctionCore.Create(const IsStrict: Boolean);
begin
  inherited Create;
  &Strict := IsStrict;
end;

function TFunctionCore.GetStrict: Boolean;
begin
  Result := FStrict;
end;

function TFunctionCore.GetType: string;
begin
  Result := 'function';
end;

procedure TFunctionCore.SetStrict(const Value: Boolean);
begin
  FStrict := Value;
end;

function TFunctionCore.ToJson: TJSONObject;
begin
  Result := TJSONObject.Create;
  try
    Result.AddPair('type', &Type);
    Result.AddPair('function', TJSONObject.ParseJSONValue(ToString));
  except
    on E: Exception do
      begin
        Result.Free;
        raise;
      end;
  end;
end;

function TFunctionCore.ToString: string;
begin
  with TStringWriter.Create do
    try
      Write('"name": "%s",', [Name]);
      Write('"description": "%s",', [Description]);
      Write('"parameters": %s', [Parameters]);
      if &Strict then
        Write(',"strict": %s', [BoolToStr(&Strict, True).ToLower]);
      Result := Format('{%s}', [ToString]);
    finally
      Free;
    end;
end;

end.

unit GenAI.Functions.Example;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, GenAI.Functions.Core, GenAI.Schema, GenAI.Types;
type
  TWeatherReportFunction = class(TFunctionCore)
  protected
    function GetDescription: string; override;
    function GetName: string; override;
    function GetParameters: string; override;
  public
    function Execute(const Arguments: string): string; override;
    class function CreateInstance(const IsStrict: Boolean = False): IFunctionCore;
  end;

implementation

uses
  System.StrUtils, System.JSON;

{ TWeatherReportFunction }

class function TWeatherReportFunction.CreateInstance(const IsStrict: Boolean): IFunctionCore;
begin
  Result := TWeatherReportFunction.create(IsStrict);
end;

function TWeatherReportFunction.Execute(const Arguments: string): string;

  procedure AddToReport(const Value: TJSONObject;
    Temperature: Integer; Forecast: TArray<string>);
  begin
    Value.AddPair('temperature', TJSONNumber.Create(Temperature));
    Value.AddPair('forecast', TJSONArray.Create(Forecast[0], Forecast[1]));
  end;

begin
  Result := EmptyStr;
  var Location := EmptyStr;
  var UnitType := EmptyStr;

  {--- Parse arguments to retrieve parameters }
  var JSON := TJSONObject.ParseJSONValue(Arguments) as TJSONObject;
  try
    if Assigned(JSON) then
    try
      Location := JSON.GetValue('location', '');
      UnitType := JSON.GetValue('unit', '');
    finally
      JSON.Free;
    end;
  except
    Location := EmptyStr;
  end;

  {--- Stop the treatment if location is empty }
  if Location.IsEmpty then
    Exit;

  {--- Build the response }
  JSON := TJSONObject.Create;
  try
    JSON.AddPair('location', Location);
    JSON.AddPair('unit', UnitType);
    if Location.ToLower.IndexOf('paris') > -1 then
      AddToReport(JSON, 14, ['rainy', 'low visibility'])
    else
    if Location.ToLower.IndexOf('marseille') > -1 then
      AddToReport(JSON, 29, ['sunny', 'windy']);
    Result := JSON.ToJSON;
  finally
    JSON.Free;
  end;
end; {Execute}

function TWeatherReportFunction.GetDescription: string;
begin
  Result := 'Get the current weather in a given location.';
end;

function TWeatherReportFunction.GetName: string;
begin
  Result := 'get_weather';
end;

function TWeatherReportFunction.GetParameters: string;
begin
// for Delphi 10.3 et 11
//  Result :=
//    '{'+
//    '"type": "object",'+
//    '"properties": {'+
//         '"location": {'+
//             '"type": "string",'+
//             '"description": "The city and department, e.g. Marseille, 13"'+
//         '},'+
//         '"unit": {'+
//             '"type": "string",'+
//             '"enum": ["celsius", "fahrenheit"]'+
//         '}'+
//     '},'+
//     '"required": ["location"],'+
//     '"additionalProperties": false'+
//  '}';


// for Delphi 12 with triple quotes
//  Result :=
//    '''
//      {
//        "type": "object",
//        "properties": {
//             "location": {
//                 "type": "string",
//                 "description": "The city and department, e.g. Marseille, 13"
//             },
//             "unit": {
//                 "type": "string",
//                 "enum": ["celsius", "fahrenheit"]
//             }
//         },
//         "required": ["location"],
//         "additionalProperties": false
//      }
//    ''';


  {--- If we use the TSchemaParams class defined in the MistralAI.Schema.pas unit }
//  var Schema := TSchemaParams.New(
//    procedure (var Params: TSchemaParams)
//    begin
//      Params.&Type(TSchemaType.object);
//      Params.Properties('properties',
//        procedure (var Params: TSchemaParams)
//        begin
//          Params.Properties('location',
//            procedure (var Params: TSchemaParams)
//            begin
//              Params.&Type(TSchemaType.string);
//              Params.Description('The city and state, e.g. San Francisco, CA');
//            end);
//          Params.Properties('unit',
//            procedure (var Params: TSchemaParams)
//            begin
//              Params.&Type(TSchemaType.string);
//              Params.Enum(['celsius', 'fahrenheit']);
//            end);
//        end);
//      Params.Required(['location', 'unit']);
//      Params.Add('additionalProperties', false);
//    end);
//  Result := Schema.ToJsonString(True);

  var Schema := TSchemaParams.Create
        .&Type(TSchemaType.object)
        .Properties('properties',
          TSchemaParams.Create
            .Properties('location',
               TSchemaParams.Create
                 .&Type(TSchemaType.string)
                 .Description('The city and state, e.g. San Francisco, CA')
               )
            .Properties('unit',
               TSchemaParams.Create
                 .&Type(TSchemaType.string)
                 .Enum(['celsius', 'fahrenheit'])
               )
            )
        .Required(['location', 'unit'])
        .Add('additionalProperties', false);
  Result := Schema.ToJsonString(True);
end;

end.

unit GenAI.Functions.Tools;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, REST.Json.Types,
  GenAI.Functions.Core;

type
  /// <summary>
  /// Represents a tool used for interacting with chat messages, including the ability to convert
  /// functions to JSON format.
  /// </summary>
  TChatMessageTool = record
  private
    FFunction: IFunctionCore;
  public
    /// <summary>
    /// This method converts the TFunctionCore instance to a JSON object containing the type and
    /// representation of the function, and handles exceptions by deleting the JSON object and
    /// propagating the exception if an error occurs
    /// </summary>
    /// <returns>
    /// A <c>TJSONObject</c> representing the function in JSON format.
    /// </returns>
    function ToJson: TJSONObject;
    /// <summary>
    /// The function properties
    /// </summary>
    property &Function: IFunctionCore read FFunction write FFunction;
    /// <summary>
    /// Adds a function to the chat message tool.
    /// </summary>
    /// <param name="AFunction">
    /// The function to be added.
    /// </param>
    /// <returns>
    /// An instance of <c>TChatMessageTool</c> containing the specified function.
    /// </returns>
    class function Add(const AFunction: IFunctionCore): TChatMessageTool; static;
  end;

  /// <summary>
  /// Represents the specifics of a called function, including its name and calculated arguments.
  /// </summary>
  TCalledFunctionSpecifics = class
  private
    FName: string;
    FArguments: string;
  public
    /// <summary>
    /// Gets or sets the name of the called function
    /// </summary>
    property Name: string read FName write FName;
    /// <summary>
    /// Gets or sets the calculed Arguments for the called function
    /// </summary>
    property Arguments: string read FArguments write FArguments;
  end;

  /// <summary>
  /// Represents a called function, containing its specifics such as name and arguments.
  /// </summary>
  TCalledFunction = class
  private
    FId: string;
    FType: string;
    FFunction: TCalledFunctionSpecifics;
  public
    /// <summary>
    /// Gets or sets the id of the called function
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Gets or sets the type of the called function
    /// </summary>
    property &Type: string read FType write FType;
    /// <summary>
    /// Gets or sets the specifics of the called function
    /// </summary>
    property &Function: TCalledFunctionSpecifics read FFunction write FFunction;
    /// <summary>
    /// Destructor that ensures proper memory management by freeing the <c>FFunction</c> property
    /// when the <c>TCalledFunction</c> instance is destroyed.
    /// </summary>
    destructor Destroy; override;
  end;

implementation

{ TChatMessageTool }

class function TChatMessageTool.Add(
  const AFunction: IFunctionCore): TChatMessageTool;
begin
  Result.&Function := AFunction;
end;

function TChatMessageTool.ToJson: TJSONObject;
begin
  Result := FFunction.ToJson;
end;

{ TCalledFunction }

destructor TCalledFunction.Destroy;
begin
  if Assigned(FFunction) then
    FFunction.Free;
  inherited;
end;

end.

unit GenAI.HttpClientAPI;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Net.HttpClient, System.Net.URLClient,
  System.Net.Mime, System.JSON, System.NetConsts, GenAI.API.Params, GenAI.HttpClientInterface;

type
  /// <summary>
  /// Provides an implementation of the <c>IHttpClientAPI</c> interface using Delphi's <c>THTTPClient</c>.
  /// </summary>
  /// <remarks>
  /// This class facilitates making HTTP requests such as GET, POST, DELETE, and PATCH
  /// by wrapping Delphi's <c>THTTPClient</c> and adhering to the <c>IHttpClientAPI</c> interface.
  /// It supports setting timeouts, proxy configurations, and handling response callbacks.
  /// </remarks>
  THttpClientAPI = class(TInterfacedObject, IHttpClientAPI)
  private
    FHttpClient: THttpClient;
    FCheckSettingsProc: TProc;
    procedure SetSendTimeOut(const Value: Integer);
    function GetSendTimeOut: Integer;
    function GetConnectionTimeout: Integer;
    procedure SetConnectionTimeout(const Value: Integer);
    function GetResponseTimeout: Integer;
    procedure SetResponseTimeout(const Value: Integer);
    function GetProxySettings: TProxySettings;
    procedure SetProxySettings(const Value: TProxySettings);
    procedure CheckAPISettings; virtual;
  public
    /// <summary>
    /// Sends an HTTP GET request to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the GET request to.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Get(const URL: string; Response: TStringStream; const Headers: TNetHeaders): Integer; overload;
    /// <summary>
    /// Sends an HTTP GET request to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the GET request to.
    /// </param>
    /// <param name="Response">
    /// A stream to capture the binary response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Get(const URL: string; const Response: TStream; const Headers: TNetHeaders): Integer; overload;
    /// <summary>
    /// Sends an HTTP DELETE request to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the DELETE request to.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Delete(const URL: string; Response: TStringStream; const Headers: TNetHeaders): Integer;
    /// <summary>
    /// Sends an HTTP POST request to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the POST request to.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Post(const URL: string; Response: TStringStream; const Headers: TNetHeaders): Integer; overload;
    /// <summary>
    /// Sends an HTTP POST request with multipart form data to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the POST request to.
    /// </param>
    /// <param name="Body">
    /// The multipart form data to include in the POST request.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Post(const URL: string; Body: TMultipartFormData; Response: TStringStream; const Headers: TNetHeaders): Integer; overload;
    /// <summary>
    /// Sends an HTTP POST request with a JSON body to the specified URL and handles streamed responses.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the POST request to.
    /// </param>
    /// <param name="Body">
    /// The JSON object to include in the POST request body.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <param name="OnReceiveData">
    /// A callback procedure to handle data as it is received during the streaming process.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Post(const URL: string; Body: TJSONObject; Response: TStringStream; const Headers: TNetHeaders; OnReceiveData: TReceiveDataCallback): Integer; overload;
    /// <summary>
    /// Sends an HTTP PATCH request with a JSON body to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the PATCH request to.
    /// </param>
    /// <param name="Body">
    /// The JSON object to include in the PATCH request body.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Patch(const URL: string; Body: TJSONObject; Response: TStringStream; const Headers: TNetHeaders): Integer; overload;
    /// <summary>
    /// Initializes a new instance of the <c>THttpClientAPI</c> class.
    /// </summary>
    /// <param name="CheckProc">
    /// A callback procedure to verify API settings before each request.
    /// </param>
    constructor Create(const CheckProc: TProc);
   /// <summary>
    /// Creates and returns an instance of <c>IHttpClientAPI</c>.
    /// </summary>
    /// <param name="CheckProc">
    /// A callback procedure to verify API settings before each request.
    /// </param>
    /// <returns>
    /// An instance implementing the <c>IHttpClientAPI</c> interface.
    /// </returns>
    class function CreateInstance(const CheckProc: TProc): IHttpClientAPI;
    destructor Destroy; override;
  end;

implementation

{ THttpClientAPI }

procedure THttpClientAPI.CheckAPISettings;
begin
  if Assigned(FCheckSettingsProc) then
    FCheckSettingsProc;
end;

constructor THttpClientAPI.Create(const CheckProc: TProc);
begin
  inherited Create;
  FHttpClient := THTTPClient.Create;
  FHttpClient.AcceptCharSet := 'utf-8';
  FCheckSettingsProc := CheckProc;
end;

class function THttpClientAPI.CreateInstance(
  const CheckProc: TProc): IHttpClientAPI;
begin
  Result := THttpClientAPI.Create(CheckProc);
end;

function THttpClientAPI.Delete(const URL: string;
  Response: TStringStream; const Headers: TNetHeaders): Integer;
begin
  CheckAPISettings;
  Result := FHttpClient.Delete(URL, Response, Headers).StatusCode;
end;

destructor THttpClientAPI.Destroy;
begin
  FHttpClient.Free;
  inherited;
end;

function THttpClientAPI.Get(const URL: string; const Response: TStream;
  const Headers: TNetHeaders): Integer;
begin
  CheckAPISettings;
  Result := FHttpClient.Get(URL, Response, Headers).StatusCode;
end;

function THttpClientAPI.GetConnectionTimeout: Integer;
begin
  Result := FHttpClient.ConnectionTimeout;
end;

function THttpClientAPI.GetProxySettings: TProxySettings;
begin
  Result := FHttpClient.ProxySettings;
end;

function THttpClientAPI.GetResponseTimeout: Integer;
begin
  Result := FHttpClient.ResponseTimeout;
end;

function THttpClientAPI.GetSendTimeOut: Integer;
begin
  Result := FHttpClient.SendTimeout;
end;

function THttpClientAPI.Get(const URL: string;
  Response: TStringStream; const Headers: TNetHeaders): Integer;
begin
  CheckAPISettings;
  Result := FHttpClient.Get(URL, Response, Headers).StatusCode;
end;

function THttpClientAPI.Patch(const URL: string; Body: TJSONObject;
  Response: TStringStream; const Headers: TNetHeaders): Integer;
begin
  CheckAPISettings;
  var Stream := TStringStream.Create;
  try
    Stream.WriteString(Body.ToJSON);
    Stream.Position := 0;
    Result := FHttpClient.Patch(URL, Stream, Response, Headers).StatusCode;
  finally
    Stream.Free;
  end;
end;

function THttpClientAPI.Post(const URL: string; Body: TJSONObject;
  Response: TStringStream; const Headers: TNetHeaders;
  OnReceiveData: TReceiveDataCallback): Integer;
begin
  CheckAPISettings;
  var Stream := TStringStream.Create;
  FHttpClient.ReceiveDataCallBack := OnReceiveData;
  try
    Stream.WriteString(Body.ToJSON);
    Stream.Position := 0;
    Result := FHttpClient.Post(URL, Stream, Response, Headers).StatusCode;
  finally
    FHttpClient.ReceiveDataCallBack := nil;
    Stream.Free;
  end;
end;

procedure THttpClientAPI.SetConnectionTimeout(const Value: Integer);
begin
  FHttpClient.ConnectionTimeout := Value;
end;

procedure THttpClientAPI.SetProxySettings(const Value: TProxySettings);
begin
  FHttpClient.ProxySettings := Value;
end;

procedure THttpClientAPI.SetResponseTimeout(const Value: Integer);
begin
  FHttpClient.ResponseTimeout := Value;
end;

procedure THttpClientAPI.SetSendTimeOut(const Value: Integer);
begin
  FHttpClient.SendTimeout := Value;
end;

function THttpClientAPI.Post(const URL: string; Body: TMultipartFormData;
  Response: TStringStream; const Headers: TNetHeaders): Integer;
begin
  CheckAPISettings;
  Result := FHttpClient.Post(URL, Body, Response, Headers).StatusCode;
end;

function THttpClientAPI.Post(const URL: string; Response: TStringStream;
  const Headers: TNetHeaders): Integer;
begin
  CheckAPISettings;
  var Stream: TStringStream := nil;
  Result := FHttpClient.Post(URL, Stream, Response, Headers).StatusCode;
end;

end.

unit GenAI.HttpClientInterface;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Net.HttpClient, System.Net.URLClient,
  System.JSON, System.Net.Mime;

type
  /// <summary>
  /// Interface for configuring HTTP client parameters such as timeouts and proxy settings.
  /// </summary>
  /// <remarks>
  /// This interface provides properties and methods to set and retrieve various HTTP client configurations,
  /// including send timeout, connection timeout, response timeout, and proxy settings.
  /// Implementers of this interface should ensure that these configurations are appropriately applied
  /// to the underlying HTTP client used for making web requests.
  /// </remarks>
  IHttpClientParam = interface
    ['{BCF51E39-B8CF-4706-90CC-FC93D07230BD}']
    /// <summary>
    /// Sets the send timeout for HTTP requests.
    /// </summary>
    /// <param name="Value">
    /// The timeout duration in milliseconds.
    /// </param>
    procedure SetSendTimeOut(const Value: Integer);
    /// <summary>
    /// Retrieves the send timeout value.
    /// </summary>
    /// <returns>
    /// The send timeout duration in milliseconds.
    /// </returns>
    function GetSendTimeOut: Integer;
    /// <summary>
    /// Retrieves the connection timeout value.
    /// </summary>
    /// <returns>
    /// The connection timeout duration in milliseconds.
    /// </returns>
    function GetConnectionTimeout: Integer;
    /// <summary>
    /// Sets the connection timeout for HTTP requests.
    /// </summary>
    /// <param name="Value">
    /// The timeout duration in milliseconds.
    /// </param>
    procedure SetConnectionTimeout(const Value: Integer);
    /// <summary>
    /// Retrieves the response timeout value.
    /// </summary>
    /// <returns>
    /// The response timeout duration in milliseconds.
    /// </returns>
    function GetResponseTimeout: Integer;
    /// <summary>
    /// Sets the response timeout for HTTP requests.
    /// </summary>
    /// <param name="Value">
    /// The timeout duration in milliseconds.
    /// </param>
    procedure SetResponseTimeout(const Value: Integer);
    /// <summary>
    /// Retrieves the current proxy settings.
    /// </summary>
    /// <returns>
    /// An instance of <c>TProxySettings</c> representing the proxy configuration.
    /// </returns>
    function GetProxySettings: TProxySettings;
    /// <summary>
    /// Sets the proxy settings for HTTP requests.
    /// </summary>
    /// <param name="Value">
    /// An instance of <c>TProxySettings</c> representing the desired proxy configuration.
    /// </param>
    procedure SetProxySettings(const Value: TProxySettings);
    /// <summary>
    /// The send timeout duration in milliseconds.
    /// </summary>
    /// <remarks>
    /// Defines how long the HTTP client will wait while sending a request before timing out.
    /// </remarks>
    property SendTimeOut: Integer read GetSendTimeOut write SetSendTimeOut;
    /// <summary>
    /// The connection timeout duration in milliseconds.
    /// </summary>
    /// <remarks>
    /// Defines how long the HTTP client will wait while establishing a connection before timing out.
    /// </remarks>
    property ConnectionTimeout: Integer read GetConnectionTimeout write SetConnectionTimeout;
    /// <summary>
    /// The response timeout duration in milliseconds.
    /// </summary>
    /// <remarks>
    /// Defines how long the HTTP client will wait for a response after a request has been sent before timing out.
    /// </remarks>
    property ResponseTimeout: Integer read GetResponseTimeout write SetResponseTimeout;
    /// <summary>
    /// The proxy settings for HTTP requests.
    /// </summary>
    /// <remarks>
    /// Configures the HTTP client to route requests through a specified proxy server.
    /// This is useful in environments where direct internet access is restricted.
    /// </remarks>
    property ProxySettings: TProxySettings read GetProxySettings write SetProxySettings;
  end;

  /// <summary>
  /// Interface for performing HTTP operations such as GET, POST, DELETE, and PATCH.
  /// </summary>
  /// <remarks>
  /// Extends <c>IHttpClientParam</c> to include methods for executing various HTTP requests,
  /// allowing for flexible and configurable API interactions.
  /// Implementers should provide concrete implementations for these methods to handle
  /// the specifics of making HTTP requests and processing responses.
  /// </remarks>
  IHttpClientAPI = interface(IHttpClientParam)
    ['{CEE0EB49-85AA-42EB-B147-0E3C3C09EA6D}']
    /// <summary>
    /// Sends an HTTP GET request to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the GET request to.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Get(const URL: string; Response: TStringStream; const Headers: TNetHeaders): Integer; overload;
    /// <summary>
    /// Sends an HTTP GET request to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the GET request to.
    /// </param>
    /// <param name="Response">
    /// A stream to capture the binary response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Get(const URL: string; const Response: TStream; const Headers: TNetHeaders): Integer; overload;
    /// <summary>
    /// Sends an HTTP DELETE request to the specified URL.
    /// </summary>
    /// <param name="Path">
    /// The endpoint URL to send the DELETE request to.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Delete(const Path: string; Response: TStringStream; const Headers: TNetHeaders): Integer;
    /// <summary>
    /// Sends an HTTP POST request to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the POST request to.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Post(const URL: string; Response: TStringStream; const Headers: TNetHeaders): Integer; overload;
    /// <summary>
    /// Sends an HTTP POST request with multipart form data to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the POST request to.
    /// </param>
    /// <param name="Body">
    /// The multipart form data to include in the POST request.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Post(const URL: string; Body: TMultipartFormData; Response: TStringStream; const Headers: TNetHeaders): Integer; overload;
    /// <summary>
    /// Sends an HTTP POST request with a JSON body to the specified URL and handles streamed responses.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the POST request to.
    /// </param>
    /// <param name="Body">
    /// The JSON object to include in the POST request body.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <param name="OnReceiveData">
    /// A callback procedure to handle data as it is received during the streaming process.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Post(const URL: string; Body: TJSONObject; Response: TStringStream; const Headers: TNetHeaders; OnReceiveData: TReceiveDataCallback): Integer; overload;
    /// <summary>
    /// Sends an HTTP PATCH request with a JSON body to the specified URL.
    /// </summary>
    /// <param name="URL">
    /// The endpoint URL to send the PATCH request to.
    /// </param>
    /// <param name="Body">
    /// The JSON object to include in the PATCH request body.
    /// </param>
    /// <param name="Response">
    /// A string stream to capture the response content.
    /// </param>
    /// <param name="Headers">
    /// A list of HTTP headers to include in the request.
    /// </param>
    /// <returns>
    /// The HTTP status code returned by the server.
    /// </returns>
    function Patch(const URL: string; Body: TJSONObject; Response: TStringStream; const Headers: TNetHeaders): Integer;
  end;

implementation

end.

unit GenAI.Httpx;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Net.URLClient, System.Net.HttpClient,
  System.Net.HttpClientComponent, System.NetEncoding;

type
  /// <summary>
  /// THttpx provides utility methods for handling HTTP-related tasks such as
  /// downloading data, encoding it in Base64, and retrieving MIME types.
  /// </summary>
  THttpx = class
    /// <summary>
    /// Converts the content of a stream into a byte array.
    /// </summary>
    /// <param name="AStream">
    /// The input stream to convert.
    /// </param>
    /// <returns>
    /// A byte array containing the data from the input stream.
    /// </returns>
    /// <exception cref="Exception">
    /// Raises an exception if the input stream is null.
    /// </exception>
    class function StreamToBytes(AStream: TStream): TBytes;
    /// <summary>
    /// Loads data from the specified URL, encodes it in Base64, and retrieves its MIME type.
    /// </summary>
    /// <param name="Url">
    /// The URL to fetch the data from.
    /// </param>
    /// <param name="MimeType">
    /// Outputs the MIME type of the data retrieved from the URL.
    /// </param>
    /// <returns>
    /// A Base64-encoded string representing the data fetched from the URL.
    /// </returns>
    class function LoadDataToBase64(const Url: string; var MimeType: string): string; overload;
    /// <summary>
    /// Loads data from the specified URL, encodes it in Base64.
    /// </summary>
    /// <param name="Url">
    /// The URL to fetch the data from.
    /// </param>
    /// <returns>
    /// A Base64-encoded string representing the data fetched from the URL.
    /// </returns>
    class function LoadDataToBase64(const Url: string): string; overload;
    /// <summary>
    /// Retrieves the MIME type of the content at the specified URL.
    /// </summary>
    /// <param name="Url">
    /// The URL of the content to inspect.
    /// </param>
    /// <returns>
    /// A string representing the MIME type of the content at the URL.
    /// </returns>
    class function GetMimeType(const Url: string): string;
    /// <summary>
    /// Validates the accessibility of a specified URL by performing an HTTP HEAD request.
    /// </summary>
    /// <param name="Url">
    /// The URL to validate.
    /// </param>
    /// <exception cref="Exception">
    /// Raises an exception if the URL is not accessible or the server responds with a non-success status code.
    /// </exception>
    /// <remarks>
    /// This method checks the HTTP status code returned by the server for the given URL.
    /// If the status code indicates an error (e.g., 4xx or 5xx), an exception is raised.
    /// If the status code indicates success (e.g., 200-299), no exception is thrown.
    /// </remarks>
    class procedure UrlCheck(const Url: string);
    /// <summary>
    /// Extracts the file name from the path component of a given URI.
    /// </summary>
    /// <param name="Url">
    /// The full URL or URI from which to extract the file name.
    /// </param>
    /// <returns>
    /// A string containing the file name part of the URI. If no file name is present, returns an empty string.
    /// </returns>
    /// <remarks>
    /// This method removes any leading slashes from the file name. It is useful for extracting resource names from URLs.
    /// </remarks>
    class function ExtractURIFileName(const Url: string): string;
  end;

implementation

{ THttpx }

class function THttpx.ExtractURIFileName(const Url: string): string;
begin
  Result := ExtractFileName(TURI.Create(Url).Path).TrimLeft(['/']);
end;

class function THttpx.GetMimeType(const Url: string): string;
begin
  var HttpClient := THTTPClient.Create;
  try
    Result := (HttpClient.Head(Url) as IHTTPResponse).MimeType.ToLower;

    {--- Ensure compatibility with current standards }
    if Result = 'audio/x-wav' then
      Result := 'audio/wav'
  finally
    HttpClient.Free;
  end;
end;

class function THttpx.LoadDataToBase64(const Url: string; var MimeType: string): string;
begin
  MimeType := GetMimeType(Url);
  Result := LoadDataToBase64(Url);
end;

class function THttpx.LoadDataToBase64(const Url: string): string;
begin
  var HttpClient := THTTPClient.Create;
  try
    var Response: IHTTPResponse := HttpClient.Get(Url);
    var DataBytes := StreamToBytes(Response.ContentStream);
    {$IF RTLVersion >= 35.0}
    Result := TNetEncoding.Base64String.EncodeBytesToString(DataBytes);
    {$ELSE}
    Result := TNetEncoding.Base64.EncodeBytesToString(ImageBytes);
    {$ENDIF}
  finally
    HttpClient.Free;
  end;
end;

class function THttpx.StreamToBytes(AStream: TStream): TBytes;
var
  LBytesStream: TBytesStream;
begin
  if not Assigned(AStream) then
    raise Exception.Create('StreamToBytes error: stream is null');

  LBytesStream := TBytesStream.Create;
  try
    AStream.Position := 0;
    LBytesStream.CopyFrom(AStream, AStream.Size);
    Result := LBytesStream.Bytes;
    SetLength(Result, LBytesStream.Size);
  finally
    LBytesStream.Free;
  end;
end;

class procedure THttpx.UrlCheck(const Url: string);
begin
  var HttpClient := THTTPClient.Create;
  try
    case (HttpClient.Head(Url) as IHTTPResponse).StatusCode of
      200..299: ;
      else
        raise Exception.CreateFmt('Address not found or inaccessible : %s', [Url]);
    end;
  finally
    HttpClient.Free;
  end;
end;

end.

unit GenAI.Images;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Threading, System.JSON, REST.Json.Types,
  REST.JsonReflect, System.Net.Mime,
  GenAI.API.Params, GenAI.API, GenAI.Consts, GenAI.Types, GenAI.Async.Support;

type
  /// <summary>
  /// Represents a parameter class for creating images through the OpenAI API, enabling
  /// the configuration of prompts, models, and other settings for image generation.
  /// </summary>
  /// <remarks>
  /// This class provides methods to specify various parameters required for generating images,
  /// such as the text prompt, model, output size, and response format. It is designed
  /// for use with the image creation API to streamline the construction of requests.
  /// </remarks>
  TImageCreateParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the text prompt for the image generation process.
    /// </summary>
    /// <param name="Value">
    /// A string containing the textual description of the desired image.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageCreateParams</c> with the updated prompt.
    /// </returns>
    function Prompt(const Value: string): TImageCreateParams;
    /// <summary>
    /// Allows to set transparency for the background of the generated image(s). This parameter is only
    /// supported for gpt-image-1. Must be one of transparent, opaque or auto (default value).
    /// When auto is used, the model will automatically determine the best background for the image.
    /// </summary>
    /// <param name="Value">
    /// A TBackGroundType such as TBackGroundType.transparent, TBackGroundType.opaque or TBackGroundType.auto.
    /// </param>
    /// <remarks>
    /// If transparent, the output format needs to support transparency, so it should be set to either png
    /// (default value) or webp.
    /// </remarks>
    /// <returns>
    /// Returns an instance of <c>TImageCreateParams</c> with the updated response format.
    /// </returns>
    function BackGround(const Value: TBackGroundType): TImageCreateParams; overload;
    /// <summary>
    /// Allows to set transparency for the background of the generated image(s). This parameter is only
    /// supported for gpt-image-1. Must be one of transparent, opaque or auto (default value).
    /// When auto is used, the model will automatically determine the best background for the image.
    /// </summary>
    /// <param name="Value">
    /// A string representing the TBackGroundType format, such as 'transparent', 'opaque' or 'auto'.
    /// </param>
    /// <remarks>
    /// If transparent, the output format needs to support transparency, so it should be set to either png
    /// (default value) or webp.
    /// </remarks>
    /// <returns>
    /// Returns an instance of <c>TImageCreateParams</c> with the updated response format.
    /// </returns>
    function BackGround(const Value: string): TImageCreateParams; overload;
    /// <summary>
    /// Specifies the model to be used for image generation.
    /// </summary>
    /// <param name="Value">
    /// A string representing the name of the model, typically 'dall-e-2'.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageCreateParams</c> with the specified model.
    /// </returns>
    function Model(const Value: string): TImageCreateParams;
    /// <summary>
    /// Control the content-moderation level for images generated by gpt-image-1
    /// </summary>
    /// </summary>
    /// <param name="Value">
    /// A TImageModerationType e.g. TImageModerationType.low or TImageModerationType.auto
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageCreateParams</c> with the specified model.
    /// </returns>
    /// <remarks>
    /// Must be either low for less restrictive filtering or auto (default value).
    /// </remarks>
    function Moderation(const Value: TImageModerationType): TImageCreateParams; overload;
    /// <summary>
    /// Control the content-moderation level for images generated by gpt-image-1
    /// </summary>
    /// </summary>
    /// <param name="Value">
    /// A string as 'low' or 'auto' to describe the TImageModerationType
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageCreateParams</c> with the specified model.
    /// </returns>
    /// <remarks>
    /// Must be either low for less restrictive filtering or auto (default value).
    /// </remarks>
    function Moderation(const Value: string): TImageCreateParams; overload;
    /// <summary>
    /// Sets the number of images to generate.
    /// </summary>
    /// <param name="Value">
    /// An integer representing the desired number of images, between 1 and 10.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageCreateParams</c> with the specified number of images.
    /// </returns>
    function N(const Value: Integer): TImageCreateParams;
    /// <summary>
    /// The compression level (0-100%) for the generated images.
    /// </summary>
    /// <param name="Value">
    /// An integer between 0 and 100. (defaults to 100)
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageCreateParams</c> with the specified model.
    /// </returns>
    /// <remarks>
    /// This parameter is only supported for gpt-image-1 with the webp or jpeg output formats,
    /// and defaults to 100.
    /// </remarks>
    function OutputCompression(const Value: Integer): TImageCreateParams;
    /// <summary>
    /// The format in which the generated images are returned.
    /// </summary>
    /// <param name="Value">
    /// A TOutputFormatType e.g. TOutputFormatType.png, TOutputFormatType.jpeg or TOutputFormatType.webp
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageCreateParams</c> with the specified model.
    /// </returns>
    /// <remarks>
    /// This parameter is only supported for gpt-image-1. Must be one of png, jpeg, or webp.
    /// </remarks>
    function OutputFormat(const Value: TOutputFormatType): TImageCreateParams; overload;
    /// <summary>
    /// The format in which the generated images are returned.
    /// </summary>
    /// <param name="Value">
    /// A string e.g. 'png', 'jpeg' or 'webp' for the TOutputFormatType
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageCreateParams</c> with the specified model.
    /// </returns>
    /// <remarks>
    /// This parameter is only supported for gpt-image-1. Must be one of png, jpeg, or webp.
    /// </remarks>
    function OutputFormat(const Value: string): TImageCreateParams; overload;
    /// <summary>
    /// Sets the quality of the generated images.
    /// </summary>
    /// <param name="Value">
    /// A string specifying the quality setting, such as 'high', 'medium', or 'low'.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageCreateParams</c> with the updated quality setting.
    /// </returns>
    function Quality(const Value: string): TImageCreateParams;
    /// <summary>
    /// Specifies the response format for the generated image(s).
    /// </summary>
    /// <param name="Value">
    /// A string representing the desired response format, such as 'url' or 'b64_json'.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageCreateParams</c> with the updated response format.
    /// </returns>
    /// <remarks>
    /// URLs are only valid for 60 minutes after the image has been generated. This parameter isn't supported
    /// for gpt-image-1 which will always return base64-encoded images.
    /// </remarks>
    function ResponseFormat(const Value: string): TImageCreateParams; overload;
    /// <summary>
    /// Specifies the response format for the generated image(s) using a predefined format type.
    /// </summary>
    /// <param name="Value">
    /// A <c>TResponseFormat</c> object representing the desired response format.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageCreateParams</c> with the updated response format.
    /// </returns>
    /// <remarks>
    /// URLs are only valid for 60 minutes after the image has been generated. This parameter isn't supported
    /// for gpt-image-1 which will always return base64-encoded images.
    /// </remarks>
    function ResponseFormat(const Value: TResponseFormat): TImageCreateParams; overload;
    /// <summary>
    /// Sets the size of the generated images.
    /// </summary>
    /// <param name="Value">
    /// A string specifying the dimensions of the image, such as '256x256', '512x512', or '1024x1024'.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageCreateParams</c> with the specified image size.
    /// </returns>
    function Size(const Value: string): TImageCreateParams; overload;
    /// <summary>
    /// Sets the size of the generated images using a predefined size type.
    /// </summary>
    /// <param name="Value">
    /// A <c>TImageSize</c> object representing the dimensions of the image.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageCreateParams</c> with the specified image size.
    /// </returns>
    /// <remarks>
    /// 1536x1024 (landscape) and 1024x1536 (portrait) for gpt-image-1
    /// </remarks>
    function Size(const Value: TImageSize): TImageCreateParams; overload;
    /// <summary>
    /// Sets the style for the generated images using a string value.
    /// </summary>
    /// <param name="Value">
    /// A string specifying the desired style for the image, such as 'photorealistic' or 'sketch'.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageCreateParams</c> with the updated style setting.
    /// </returns>
    /// <remarks>
    /// Only supported for dall-e-3
    /// </remarks>
    /// <remarks>
    /// 1536x1024 (landscape) and 1024x1536 (portrait) for gpt-image-1
    /// </remarks>
    function Style(const Value: string): TImageCreateParams; overload;
    /// <summary>
    /// Sets the style for the generated images using a predefined style type.
    /// </summary>
    /// <param name="Value">
    /// A <c>TImageStyle</c> object representing the desired style for the image.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageCreateParams</c> with the updated style setting.
    /// </returns>
    /// <remarks>
    /// Only supported for dall-e-3
    /// </remarks>
    function Style(const Value: TImageStyle): TImageCreateParams; overload;
    /// <summary>
    /// Sets the user identifier for the request.
    /// </summary>
    /// <param name="Value">
    /// A string representing the unique identifier for the end user. This can help
    /// with tracking and monitoring usage.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageCreateParams</c> with the updated user identifier.
    /// </returns>
    function User(const Value: string): TImageCreateParams;
  end;

  /// <summary>
  /// Represents a parameter class for editing images through the OpenAI API, enabling
  /// the configuration of images, masks, prompts, and other settings for image editing.
  /// </summary>
  /// <remarks>
  /// This class provides methods to specify various parameters required for editing images,
  /// such as the image file, mask, text prompt, model, output size, and response format.
  /// It is designed for use with the image editing API to streamline the construction of requests.
  /// </remarks>
  TImageEditParams = class(TMultipartFormData)
  public
    constructor Create; reintroduce;
    /// <summary>
    /// Specifies the image to be edited using a file path.
    /// </summary>
    /// <param name="Value">
    /// A string representing the file path of the image to be edited.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageEditParams</c> with the specified image file.
    /// </returns>
    function Image(const Value: string): TImageEditParams; overload;
    /// <summary>
    /// Specifies the image to be edited using a stream.
    /// </summary>
    /// <param name="Value">
    /// A <c>TStream</c> object containing the image data.
    /// </param>
    /// <param name="FileName">
    /// A string representing the file path for the image, used for reference purposes.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageEditParams</c> with the specified image stream.
    /// </returns>
    function Image(const Value: TStream; const FileName: string): TImageEditParams; overload;
    /// <summary>
    /// Allows to set transparency for the background of the generated image(s). This parameter is only
    /// supported for gpt-image-1. Must be one of transparent, opaque or auto (default value).
    /// When auto is used, the model will automatically determine the best background for the image.
    /// </summary>
    /// <param name="Value">
    /// A TBackGroundType such as TBackGroundType.transparent, TBackGroundType.opaque or TBackGroundType.auto.
    /// </param>
    /// <remarks>
    /// If transparent, the output format needs to support transparency, so it should be set to either png
    /// (default value) or webp.
    /// </remarks>
    /// <returns>
    /// Returns an instance of <c>TImageCreateParams</c> with the updated response format.
    /// </returns>
    function BackGround(const Value: TBackGroundType): TImageEditParams; overload;
    /// <summary>
    /// Allows to set transparency for the background of the generated image(s). This parameter is only
    /// supported for gpt-image-1. Must be one of transparent, opaque or auto (default value).
    /// When auto is used, the model will automatically determine the best background for the image.
    /// </summary>
    /// <param name="Value">
    /// A string representing the TBackGroundType format, such as 'transparent', 'opaque' or 'auto'.
    /// </param>
    /// <remarks>
    /// If transparent, the output format needs to support transparency, so it should be set to either png
    /// (default value) or webp.
    /// </remarks>
    /// <returns>
    /// Returns an instance of <c>TImageCreateParams</c> with the updated response format.
    /// </returns>
    function BackGround(const Value: string): TImageEditParams; overload;
    /// <summary>
    /// Sets the text prompt for the image editing process.
    /// </summary>
    /// <param name="Value">
    /// A string containing the textual description of the desired edits.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageEditParams</c> with the updated prompt.
    /// </returns>
    /// <remarks>
    /// The maximum length is 1000 characters for dall-e-2, and 32000 characters for gpt-image-1.
    /// </remarks>
    function Prompt(const Value: string): TImageEditParams;
    /// <summary>
    /// Specifies the mask image for the areas to be edited using a file path.
    /// </summary>
    /// <param name="Value">
    /// A string representing the file path of the mask image.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageEditParams</c> with the specified mask file.
    /// </returns>
    function Mask(const Value: string): TImageEditParams; overload;
    /// <summary>
    /// Specifies the mask image for the areas to be edited using a stream.
    /// </summary>
    /// <param name="Value">
    /// A <c>TStream</c> object containing the mask image data.
    /// </param>
    /// <param name="FilePath">
    /// A string representing the file path for the mask, used for reference purposes.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageEditParams</c> with the specified mask stream.
    /// </returns>
    function Mask(const Value: TStream; const FilePath: string): TImageEditParams; overload;
    /// <summary>
    /// Specifies the model to be used for image editing.
    /// </summary>
    /// <param name="Value">
    /// A string representing the name of the model, typically 'dall-e-2'.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageEditParams</c> with the specified model.
    /// </returns>
    function Model(const Value: string): TImageEditParams;
    /// <summary>
    /// Sets the number of images to generate during the edit.
    /// </summary>
    /// <param name="Value">
    /// An integer representing the desired number of images, between 1 and 10.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageEditParams</c> with the specified number of images.
    /// </returns>
    function N(const Value: Integer): TImageEditParams;
    /// <summary>
    /// Sets the quality of the generated images.
    /// </summary>
    /// <param name="Value">
    /// A string specifying the quality setting, such as 'high', 'medium', or 'low'.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageCreateParams</c> with the updated quality setting.
    /// </returns>
    function Quality(const Value: string): TImageEditParams; overload;
    /// <summary>
    /// Sets the quality of the generated images.
    /// </summary>
    /// <param name="Value">
    /// A TImageQualityType, such as TImageQualityType.high, TImageQualityType.medium, or TImageQualityType.low.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageCreateParams</c> with the updated quality setting.
    /// </returns>
    function Quality(const Value: TImageQualityType): TImageEditParams; overload;
    /// <summary>
    /// Sets the size of the generated images.
    /// </summary>
    /// <param name="Value">
    /// A string specifying the dimensions of the image, such as '256x256', '512x512', or '1024x1024'.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageEditParams</c> with the specified image size.
    /// </returns>
    /// <remarks>
    /// 1536x1024 (landscape) and 1024x1536 (portrait) for gpt-image-1
    /// </remarks>
    function Size(const Value: string): TImageEditParams; overload;
    /// <summary>
    /// Sets the size of the generated images using a predefined size type.
    /// </summary>
    /// <param name="Value">
    /// A <c>TImageSize</c> object representing the dimensions of the image.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageEditParams</c> with the specified image size.
    /// </returns>
    /// <remarks>
    /// 1536x1024 (landscape) and 1024x1536 (portrait) for gpt-image-1
    /// </remarks>
    function Size(const Value: TImageSize): TImageEditParams; overload;
    /// <summary>
    /// Specifies the response format for the edited image(s).
    /// </summary>
    /// <param name="Value">
    /// A string representing the desired response format, such as 'url' or 'b64_json'.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageEditParams</c> with the updated response format.
    /// </returns>
    /// <remarks>
    /// This parameter is only supported for dall-e-2, as gpt-image-1 will always return base64-encoded images.
    /// </remarks>
    function ResponseFormat(const Value: string): TImageEditParams; overload;
    /// <summary>
    /// Specifies the response format for the edited image(s) using a predefined format type.
    /// </summary>
    /// <param name="Value">
    /// A <c>TResponseFormat</c> object representing the desired response format.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageEditParams</c> with the updated response format.
    /// </returns>
    /// <remarks>
    /// This parameter is only supported for dall-e-2, as gpt-image-1 will always return base64-encoded images.
    /// </remarks>
    function ResponseFormat(const Value: TResponseFormat): TImageEditParams; overload;
    /// <summary>
    /// Sets the user identifier for the request.
    /// </summary>
    /// <param name="Value">
    /// A string representing the unique identifier for the end user. This can help
    /// with tracking and monitoring usage.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageEditParams</c> with the updated user identifier.
    /// </returns>
    function User(const Value: string): TImageEditParams;
  end;

  /// <summary>
  /// Represents a parameter class for creating image variations through the OpenAI API, enabling
  /// the configuration of images, models, and other settings for variation generation.
  /// </summary>
  /// <remarks>
  /// This class provides methods to specify various parameters required for generating image variations,
  /// such as the base image, model, output size, and response format. It is designed
  /// for use with the image variation API to streamline the construction of requests.
  /// </remarks>
  TImageVariationParams = class(TMultipartFormData)
  public
    constructor Create; reintroduce;
    /// <summary>
    /// Specifies the base image to be used for generating variations using a file path.
    /// </summary>
    /// <param name="Value">
    /// A string representing the file path of the base image.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageVariationParams</c> with the specified base image file.
    /// </returns>
    function Image(const Value: string): TImageVariationParams; overload;
    /// <summary>
    /// Specifies the base image to be used for generating variations using a stream.
    /// </summary>
    /// <param name="Value">
    /// A <c>TStream</c> object containing the base image data.
    /// </param>
    /// <param name="FilePath">
    /// A string representing the file path for the image, used for reference purposes.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageVariationParams</c> with the specified base image stream.
    /// </returns>
    function Image(const Value: TStream; const FilePath: string): TImageVariationParams; overload;
    /// <summary>
    /// Specifies the model to be used for generating image variations.
    /// </summary>
    /// <param name="Value">
    /// A string representing the name of the model, typically 'dall-e-2'.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageVariationParams</c> with the specified model.
    /// </returns>
    function Model(const Value: string): TImageVariationParams;
    /// <summary>
    /// Sets the number of variations to generate.
    /// </summary>
    /// <param name="Value">
    /// An integer representing the desired number of image variations, between 1 and 10.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageVariationParams</c> with the specified number of variations.
    /// </returns>
    function N(const Value: Integer): TImageVariationParams;
    /// <summary>
    /// Specifies the response format for the generated image variations.
    /// </summary>
    /// <param name="Value">
    /// A string representing the desired response format, such as 'url' or 'b64_json'.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageVariationParams</c> with the updated response format.
    /// </returns>
    function ResponseFormat(const Value: string): TImageVariationParams; overload;
    /// <summary>
    /// Specifies the response format for the generated image variations using a predefined format type.
    /// </summary>
    /// <param name="Value">
    /// A <c>TResponseFormat</c> object representing the desired response format.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageVariationParams</c> with the updated response format.
    /// </returns>
    function ResponseFormat(const Value: TResponseFormat): TImageVariationParams; overload;
    /// <summary>
    /// Sets the size of the generated image variations.
    /// </summary>
    /// <param name="Value">
    /// A string specifying the dimensions of the image, such as '256x256', '512x512', or '1024x1024'.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageVariationParams</c> with the specified image size.
    /// </returns>
    function Size(const Value: string): TImageVariationParams; overload;
    /// <summary>
    /// Sets the size of the generated image variations using a predefined size type.
    /// </summary>
    /// <param name="Value">
    /// A <c>TImageSize</c> object representing the dimensions of the image.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageVariationParams</c> with the specified image size.
    /// </returns>
    function Size(const Value: TImageSize): TImageVariationParams; overload;
    /// <summary>
    /// Sets the user identifier for the request.
    /// </summary>
    /// <param name="Value">
    /// A string representing the unique identifier for the end user. This can help
    /// with tracking and monitoring usage.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TImageVariationParams</c> with the updated user identifier.
    /// </returns>
    function User(const Value: string): TImageVariationParams;
  end;

  /// <summary>
  /// Represents the data object for an image created through the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class contains the properties of the generated image, including its URL,
  /// base64-encoded content, and the revised prompt (if applicable).
  /// </remarks>
  TImageCreateData = class
  private
    [JsonNameAttribute('b64_json')]
    FB64Json: string;
    FUrl: string;
    [JsonNameAttribute('revised_prompt')]
    FRevisedPrompt: string;
  public
    /// <summary>
    /// Gets or sets the base64-encoded representation of the generated image.
    /// </summary>
    /// <value>
    /// A string containing the base64-encoded image content.
    /// </value>
    /// <remarks>
    ///  Default value for gpt-image-1, and only present if response_format is set to b64_json for dall-e-2
    /// and dall-e-3.
    /// </remarks>
    property B64Json: string read FB64Json write FB64Json;
    /// <summary>
    /// Gets or sets the URL of the generated image.
    /// </summary>
    /// <value>
    /// A string containing the URL of the generated image.
    /// </value>
    property Url: string read FUrl write FUrl;
    /// <summary>
    /// Gets or sets the revised prompt used to generate the image.
    /// </summary>
    /// <value>
    /// A string containing the revised prompt, if applicable.
    /// </value>
    /// <remarks>
    /// For dall-e-3 only
    /// </remarks>
    property RevisedPrompt: string read FRevisedPrompt write FRevisedPrompt;
  end;

  /// <summary>
  /// Represents a part of the generated image, extending the <c>TImageCreateData</c> class
  /// to include file management functionality.
  /// </summary>
  /// <remarks>
  /// This class provides additional methods for handling the generated image, such as
  /// saving it to a file or retrieving it as a stream. It is designed for scenarios where
  /// the generated image needs to be manipulated or stored locally.
  /// </remarks>
  TImagePart = class(TImageCreateData)
  private
    FFileName: string;
  public
    /// <summary>
    /// Retrieves the generated image as a stream.
    /// </summary>
    /// <returns>
    /// A <c>TStream</c> object containing the image data.
    /// </returns>
    function GetStream: TStream;
    /// <summary>
    /// Downloads the generated image and saves it to the specified file path.
    /// </summary>
    /// <param name="FileName">
    /// A string specifying the file path where the image will be saved.
    /// </param>
    procedure Download(const FileName: string);
    /// <summary>
    /// Saves the generated image to the specified file path.
    /// </summary>
    /// <param name="FileName">
    /// A string specifying the file path where the image will be saved.
    /// </param>
    /// <param name="RaiseError">
    /// A boolean value indicating whether to raise an exception if the <c>FileName</c> is empty.
    /// <para>
    /// - If set to <c>True</c>, an exception will be raised for an empty file path.
    /// </para>
    /// <para>
    /// - If set to <c>False</c>, the method will exit silently without saving.
    /// </para>
    /// </param>
    /// <remarks>
    /// This method saves the base64-encoded image content to the specified file. Ensure that
    /// the <c>FileName</c> parameter is valid if <c>RaiseError</c> is set to <c>True</c>.
    /// If the <c>FileName</c> is empty and <c>RaiseError</c> is <c>False</c>, the method
    /// will terminate without performing any operation.
    /// </remarks>
    procedure SaveToFile(const FileName: string; const RaiseError: Boolean = True);
    /// <summary>
    /// Gets or sets the name of the file associated with the generated image.
    /// </summary>
    /// <value>
    /// A string representing the file name.
    /// </value>
    property FileName: string read FFileName write FFileName;
  end;

  TInputTokensDetails = class
  private
    [JsonNameAttribute('image_tokens')]
    FImageTokens: Int64;
    [JsonNameAttribute('text_tokens')]
    FTextTokens: Int64;
  public
    /// <summary>
    /// The number of image tokens in the input prompt.
    /// </summary>
    property ImageTokens: Int64 read FImageTokens write FImageTokens;
    /// <summary>
    /// The number of text tokens in the input prompt.
    /// </summary>
    property TextTokens: Int64 read FTextTokens write FTextTokens;
  end;

  /// <summary>
  /// For gpt-image-1 only, the token usage information for the image generation.
  /// </summary>
  TGenerateImageUsage = class
  private
    [JsonNameAttribute('input_tokens')]
    FInputTokens: Int64;
    [JsonNameAttribute('input_tokens_details')]
    FInputTokensDetails: TInputTokensDetails;
    [JsonNameAttribute('output_tokens')]
    FOutputTokens: Int64;
    [JsonNameAttribute('total_tokens')]
    FTotalTokens: Int64;
  public
    /// <summary>
    /// The number of tokens (images and text) in the input prompt.
    /// </summary>
    property InputTokens: Int64 read FInputTokens write FInputTokens;
    /// <summary>
    /// The input tokens detailed information for the image generation.
    /// </summary>
    property InputTokensDetails: TInputTokensDetails read FInputTokensDetails write FInputTokensDetails;
    /// <summary>
    /// The number of image tokens in the output image.
    /// </summary>
    property OutputTokens: Int64 read FOutputTokens write FOutputTokens;
    /// <summary>
    /// The total number of tokens (images and text) used for the image generation.
    /// </summary>
    property TotalTokens: Int64 read FTotalTokens write FTotalTokens;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents the response object containing a collection of generated images
  /// and metadata about the creation process.
  /// </summary>
  /// <remarks>
  /// This class encapsulates the data returned by the OpenAI API for image generation,
  /// including the timestamp of creation and the list of generated images. It provides
  /// functionality for managing the lifecycle of these objects.
  /// </remarks>
  TGeneratedImages = class(TJSONFingerprint)
  private
    FCreated: TInt64OrNull;
    FData: TArray<TImagePart>;
    FUsage: TGenerateImageUsage;
  private
    function GetCreatedAsString: string;
    function GetCreated: Int64;
  public
    /// <summary>
    /// Gets the timestamp indicating when the images were created.
    /// </summary>
    property Created: Int64 read GetCreated;
    /// <summary>
    /// Gets the timestamp as string, indicating when the images were created.
    /// </summary>
    property CreatedAsString: string read GetCreatedAsString;
    /// <summary>
    /// Gets or sets the collection of generated images.
    /// </summary>
    property Data: TArray<TImagePart> read FData write FData;
    /// <summary>
    /// For gpt-image-1 only, the token usage information for the image generation.
    /// </summary>
    property Usage: TGenerateImageUsage read FUsage write FUsage;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TGeneratedImages</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynImagesCreate</c> type extends the <c>TAsynParams&lt;TGeneratedImages&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynGeneratedImages = TAsynCallBack<TGeneratedImages>;

  /// <summary>
  /// Represents the route handler for image-related operations using the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class provides methods for creating, editing, and generating variations of images.
  /// It supports both synchronous and asynchronous operations, making it suitable for
  /// diverse use cases involving image generation and manipulation.
  /// </remarks>
  TImagesRoute = class(TGenAIRoute)
    /// <summary>
    /// Initiates an asynchronous image creation process.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure that configures the parameters for the image creation request.
    /// </param>
    /// <param name="CallBacks">
    /// A function that defines the callbacks for handling success, error, and completion states.
    /// </param>
    procedure AsynCreate(const ParamProc: TProc<TImageCreateParams>; const CallBacks: TFunc<TAsynGeneratedImages>);
    /// <summary>
    /// Initiates an asynchronous image editing process.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure that configures the parameters for the image editing request.
    /// </param>
    /// <param name="CallBacks">
    /// A function that defines the callbacks for handling success, error, and completion states.
    /// </param>
    procedure AsynEdit(const ParamProc: TProc<TImageEditParams>; const CallBacks: TFunc<TAsynGeneratedImages>);
    /// <summary>
    /// Initiates an asynchronous process for generating variations of an image.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure that configures the parameters for the image variation request.
    /// </param>
    /// <param name="CallBacks">
    /// A function that defines the callbacks for handling success, error, and completion states.
    /// </param>
    procedure AsynVariation(const ParamProc: TProc<TImageVariationParams>; const CallBacks: TFunc<TAsynGeneratedImages>);
    /// <summary>
    /// Creates an image synchronously based on the provided parameters.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure that configures the parameters for the image creation request.
    /// </param>
    /// <returns>
    /// A <c>TGeneratedImages</c> object containing the created images and metadata.
    /// </returns>
    function Create(const ParamProc: TProc<TImageCreateParams>): TGeneratedImages;
    /// <summary>
    /// Edits an image synchronously based on the provided parameters.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure that configures the parameters for the image editing request.
    /// </param>
    /// <returns>
    /// A <c>TGeneratedImages</c> object containing the edited images and metadata.
    /// </returns>
    function Edit(const ParamProc: TProc<TImageEditParams>): TGeneratedImages;
    /// <summary>
    /// Generates variations of an image synchronously based on the provided parameters.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure that configures the parameters for the image variation request.
    /// </param>
    /// <returns>
    /// A <c>TGeneratedImages</c> object containing the image variations and metadata.
    /// </returns>
    function Variation(const ParamProc: TProc<TImageVariationParams>): TGeneratedImages;
  end;

implementation

uses
  GenAI.Httpx, GenAI.NetEncoding.Base64;

{ TImageCreateParams }

function TImageCreateParams.BackGround(
  const Value: TBackGroundType): TImageCreateParams;
begin
  Result := TImageCreateParams(Add('background', Value.ToString));
end;

function TImageCreateParams.BackGround(const Value: string): TImageCreateParams;
begin
  Result := TImageCreateParams(Add('background', TBackGroundType.Create(Value).ToString));
end;

function TImageCreateParams.Model(const Value: string): TImageCreateParams;
begin
  Result := TImageCreateParams(Add('model', Value));
end;

function TImageCreateParams.Moderation(const Value: string): TImageCreateParams;
begin
  Result := TImageCreateParams(Add('moderation', TImageModerationType.Create(Value).ToString));
end;

function TImageCreateParams.Moderation(
  const Value: TImageModerationType): TImageCreateParams;
begin
  Result := TImageCreateParams(Add('moderation', Value.ToString));
end;

function TImageCreateParams.N(const Value: Integer): TImageCreateParams;
begin
  Result := TImageCreateParams(Add('n', Value));
end;

function TImageCreateParams.OutputCompression(
  const Value: Integer): TImageCreateParams;
begin
  Result := TImageCreateParams(Add('output_compression', Value));
end;

function TImageCreateParams.OutputFormat(
  const Value: string): TImageCreateParams;
begin
  Result := TImageCreateParams(Add('output_format', TOutputFormatType.Create(Value).ToString));
end;

function TImageCreateParams.OutputFormat(
  const Value: TOutputFormatType): TImageCreateParams;
begin
  Result := TImageCreateParams(Add('output_format', Value.ToString));
end;

function TImageCreateParams.Prompt(const Value: string): TImageCreateParams;
begin
  Result := TImageCreateParams(Add('prompt', Value));
end;

function TImageCreateParams.Quality(const Value: string): TImageCreateParams;
begin
  Result := TImageCreateParams(Add('quality', Value));
end;

function TImageCreateParams.ResponseFormat(
  const Value: TResponseFormat): TImageCreateParams;
begin
  Result := TImageCreateParams(Add('response_format', Value.ToString));
end;

function TImageCreateParams.ResponseFormat(
  const Value: string): TImageCreateParams;
begin
  Result := TImageCreateParams(Add('response_format', TResponseFormat.Create(Value).ToString));
end;

function TImageCreateParams.Size(const Value: string): TImageCreateParams;
begin
  Result := TImageCreateParams(Add('size', TImageSize.Create(Value).ToString));
end;

function TImageCreateParams.Size(const Value: TImageSize): TImageCreateParams;
begin
  Result := TImageCreateParams(Add('size', Value.ToString));
end;

function TImageCreateParams.Style(
  const Value: TImageStyle): TImageCreateParams;
begin
  Result := TImageCreateParams(Add('style', Value.ToString));
end;

function TImageCreateParams.Style(const Value: string): TImageCreateParams;
begin
  Result := TImageCreateParams(Add('style', TImageStyle.Create(Value).ToString));
end;

function TImageCreateParams.User(const Value: string): TImageCreateParams;
begin
  Result := TImageCreateParams(Add('user', Value));
end;

{ TImagePart }

procedure TImagePart.Download(const FileName: string);
begin
  B64Json := THttpx.LoadDataToBase64(Url);
  SaveToFile(FileName);
end;

function TImagePart.GetStream: TStream;
begin
  {--- Download the image if the generation returns a URL instead of a Base64 string. }
  if B64JSON.IsEmpty then
    begin
      THttpx.UrlCheck(Url);
      B64Json := THttpx.LoadDataToBase64(Url);
    end;

  {--- Create a memory stream to write the decoded content. }
  Result := TMemoryStream.Create;
  try
    {--- Convert the base-64 string directly into the memory stream. }
    DecodeBase64ToStream(B64Json, Result)
  except
    Result.Free;
    raise;
  end;
end;

procedure TImagePart.SaveToFile(const FileName: string;
  const RaiseError: Boolean);
begin
  case RaiseError of
    True :
      if FileName.Trim.IsEmpty then
        raise Exception.Create('File record aborted. SaveToFile requires a filename.');
    else
      if FileName.Trim.IsEmpty then
        Exit;
  end;

  if RaiseError and FileName.Trim.IsEmpty then
    raise Exception.Create('File record aborted. SaveToFile requires a filename.');

  try
    Self.FFileName := FileName;
    {--- Perform the decoding operation and save it into the file specified by the FileName parameter. }
    DecodeBase64ToFile(B64Json, FileName)
  except
    raise;
  end;
end;

{ TImagesRoute }

procedure TImagesRoute.AsynCreate(const ParamProc: TProc<TImageCreateParams>;
  const CallBacks: TFunc<TAsynGeneratedImages>);
begin
  with TAsynCallBackExec<TAsynGeneratedImages, TGeneratedImages>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TGeneratedImages
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TImagesRoute.AsynEdit(const ParamProc: TProc<TImageEditParams>;
  const CallBacks: TFunc<TAsynGeneratedImages>);
begin
  with TAsynCallBackExec<TAsynGeneratedImages, TGeneratedImages>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TGeneratedImages
      begin
        Result := Self.Edit(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TImagesRoute.AsynVariation(
  const ParamProc: TProc<TImageVariationParams>;
  const CallBacks: TFunc<TAsynGeneratedImages>);
begin
  with TAsynCallBackExec<TAsynGeneratedImages, TGeneratedImages>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TGeneratedImages
      begin
        Result := Self.Variation(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TImagesRoute.Create(const ParamProc: TProc<TImageCreateParams>): TGeneratedImages;
begin
  Result := API.Post<TGeneratedImages, TImageCreateParams>('images/generations', ParamProc);
end;

function TImagesRoute.Edit(
  const ParamProc: TProc<TImageEditParams>): TGeneratedImages;
begin
  Result := API.PostForm<TGeneratedImages, TImageEditParams>('images/edits', ParamProc);
end;

function TImagesRoute.Variation(
  const ParamProc: TProc<TImageVariationParams>): TGeneratedImages;
begin
  Result := API.PostForm<TGeneratedImages, TImageVariationParams>('images/variations', ParamProc);
end;

{ TGeneratedImages }

destructor TGeneratedImages.Destroy;
begin
  for var Item in FData do
    Item.Free;
  if Assigned(FUsage) then
    FUsage.Free;
  inherited;
end;

function TGeneratedImages.GetCreated: Int64;
begin
  Result := TInt64OrNull(FCreated).ToInteger;
end;

function TGeneratedImages.GetCreatedAsString: string;
begin
  Result := TInt64OrNull(FCreated).ToUtcDateString;
end;

{ TImageEditParams }

function TImageEditParams.Image(const Value: string): TImageEditParams;
begin
  AddFile('image', Value);
  Result := Self;
end;

function TImageEditParams.BackGround(const Value: string): TImageEditParams;
begin
  AddField('background', TBackGroundType.Create(Value).ToString);
  Result := Self;
end;

function TImageEditParams.BackGround(
  const Value: TBackGroundType): TImageEditParams;
begin
  AddField('background', Value.ToString);
  Result := Self;
end;

constructor TImageEditParams.Create;
begin
  inherited Create(true);
end;

function TImageEditParams.Image(const Value: TStream; const FileName: string): TImageEditParams;
begin
  {$IF RTLVersion > 35.0}
    AddStream('image', Value, True, FileName);
  {$ELSE}
    AddStream('image', Value, FileName);
  {$ENDIF}
  Result := Self;
end;

function TImageEditParams.Mask(const Value: TStream;
  const FilePath: string): TImageEditParams;
begin
  {$IF RTLVersion > 35.0}
    AddStream('mask', Value, True, FilePath);
  {$ELSE}
    AddStream('mask', Value, FilePath);
  {$ENDIF}
  Result := Self;
end;

function TImageEditParams.Mask(const Value: string): TImageEditParams;
begin
  AddFile('mask', Value);
  Result := Self;
end;

function TImageEditParams.Model(const Value: string): TImageEditParams;
begin
  AddField('model', Value);
  Result := Self;
end;

function TImageEditParams.N(const Value: Integer): TImageEditParams;
begin
  AddField('n', Value.ToString);
  Result := Self;
end;

function TImageEditParams.Prompt(const Value: string): TImageEditParams;
begin
  AddField('prompt', Value);
  Result := Self;
end;

function TImageEditParams.Quality(
  const Value: TImageQualityType): TImageEditParams;
begin
  AddField('quality', Value.ToString);
  Result := Self;
end;

function TImageEditParams.Quality(const Value: string): TImageEditParams;
begin
  AddField('quality', TImageQualityType.Create(Value).ToString);
  Result := Self;
end;

function TImageEditParams.ResponseFormat(
  const Value: TResponseFormat): TImageEditParams;
begin
  AddField('response_format', Value.ToString);
  Result := Self;
end;

function TImageEditParams.ResponseFormat(
  const Value: string): TImageEditParams;
begin
  AddField('response_format', TResponseFormat.Create(Value).ToString);
  Result := Self;
end;

function TImageEditParams.Size(const Value: TImageSize): TImageEditParams;
begin
  AddField('size', Value.ToString);
  Result := Self;
end;

function TImageEditParams.User(const Value: string): TImageEditParams;
begin
  AddField('user', Value);
  Result := Self;
end;

function TImageEditParams.Size(const Value: string): TImageEditParams;
begin
  AddField('size', TImageSize.Create(Value).ToString);
  Result := Self;
end;

{ TImageVariationParams }

constructor TImageVariationParams.Create;
begin
  inherited Create(true);
end;

function TImageVariationParams.Image(const Value: TStream;
  const FilePath: string): TImageVariationParams;
begin
  {$IF RTLVersion > 35.0}
    AddStream('image', Value, True, FilePath);
  {$ELSE}
    AddStream('image', Value, FilePath);
  {$ENDIF}
  Result := Self;
end;

function TImageVariationParams.Model(const Value: string): TImageVariationParams;
begin
  AddField('model', Value);
  Result := Self;
end;

function TImageVariationParams.N(const Value: Integer): TImageVariationParams;
begin
  AddField('n', Value.ToString);
  Result := Self;
end;

function TImageVariationParams.ResponseFormat(
  const Value: TResponseFormat): TImageVariationParams;
begin
  AddField('response_format', Value.ToString);
  Result := Self;
end;

function TImageVariationParams.Size(
  const Value: TImageSize): TImageVariationParams;
begin
  AddField('size', Value.ToString);
  Result := Self;
end;

function TImageVariationParams.User(const Value: string): TImageVariationParams;
begin
  AddField('user', Value);
  Result := Self;
end;

function TImageVariationParams.Size(const Value: string): TImageVariationParams;
begin
  AddField('size', TImageSize.Create(Value).ToString);
  Result := Self;
end;

function TImageVariationParams.ResponseFormat(
  const Value: string): TImageVariationParams;
begin
  AddField('response_format', TResponseFormat.Create(Value).ToString);
  Result := Self;
end;

function TImageVariationParams.Image(const Value: string): TImageVariationParams;
begin
  AddFile('image', Value);
  Result := Self;
end;

{ TGenerateImageUsage }

destructor TGenerateImageUsage.Destroy;
begin
  if Assigned(FInputTokensDetails) then
    FInputTokensDetails.Free;
  inherited;
end;

end.

unit GenAI.Messages;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Threading, System.JSON, REST.Json.Types,
  REST.JsonReflect, System.Net.URLClient,
  GenAI.API.Params, GenAI.API, GenAI.Consts, GenAI.Types, GenAI.Async.Support,
  GenAI.Threads, GenAI.API.Lists, GenAI.API.Deletion;

type
  /// <summary>
  /// Represents URL parameters used for customizing requests related to assistants in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TUrlAdvancedParams</c> to provide additional parameters
  /// that can be added to API calls when interacting with assistant-related threads.
  /// </remarks>
  TAssistantsUrlParams = class(TUrlAdvancedParams)
  public
    /// <summary>
    /// Specifies the <c>run_id</c> parameter for filtering messages by a specific run ID.
    /// </summary>
    /// <param name="Value">
    /// The run ID that will be used to filter the API request.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TAssistantsUrlParams</c> for method chaining.
    /// </returns>
    /// <remarks>
    /// The <c>run_id</c> parameter can be used to retrieve messages that are associated
    /// with a specific execution or run within the assistant's context.
    /// </remarks>
    function RunId(const Value: string): TAssistantsUrlParams;
  end;

  /// <summary>
  /// Represents parameters used for updating messages within a thread in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TJSONParam</c> to provide structured key-value pairs
  /// for modifying messages, such as attaching metadata or updating message-specific details.
  /// </remarks>
  TMessagesUpdateParams = class(TJSONParam)
  public
    /// <summary>
    /// Adds or updates metadata for a message.
    /// </summary>
    /// <param name="Value">
    /// A JSON object containing key-value pairs representing metadata.
    /// Each key must be a string of maximum length 64 characters, and each value
    /// must be a string of maximum length 512 characters.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TMessagesUpdateParams</c> for method chaining.
    /// </returns>
    /// <remarks>
    /// Metadata can be useful for storing additional structured information about the message,
    /// such as timestamps, categories, or custom identifiers.
    /// </remarks>
    function Metadata(const Value: TJSONObject): TMessagesUpdateParams;
  end;

  /// <summary>
  /// Represents details related to incomplete messages within a thread in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class contains information on why a message was marked as incomplete,
  /// typically providing a reason for the failure or interruption during processing.
  /// </remarks>
  TIncompleteDetails = class
  private
    FReason: string;
  public
    /// <summary>
    /// Gets or sets the reason for the incomplete message.
    /// </summary>
    /// <remarks>
    /// The reason provides diagnostic information, which may include errors
    /// related to processing, timeouts, or API restrictions.
    /// </remarks>
    property Reason: string read FReason write FReason;
  end;

  /// <summary>
  /// Represents an image file attached to a message within a thread in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class is used to reference an image that is included as part of a message.
  /// The image is identified by its file ID and can have an associated detail level.
  /// </remarks>
  TMessagesImageFile = class
  private
    FFileId: string;
    FDetail: string;
  public
    /// <summary>
    /// Gets or sets the file ID of the image.
    /// </summary>
    /// <remarks>
    /// The file ID is a unique reference used to retrieve or process the image within the API.
    /// </remarks>
    property FileId: string read FFileId write FFileId;
    /// <summary>
    /// Gets or sets the detail level of the image.
    /// </summary>
    /// <remarks>
    /// The detail level can be <c>low</c> for fewer tokens or <c>high</c> for high-resolution processing.
    /// </remarks>
    property Detail: string read FDetail write FDetail;
  end;

  /// <summary>
  /// Represents an external image URL attached to a message within a thread in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class is used to reference an image located at an external URL.
  /// The image can have an associated detail level, which determines the resolution or processing cost.
  /// </remarks>
  TMessagesImageUrl = class
  private
    FUrl: string;
    FDetail: string;
  public
    /// <summary>
    /// Gets or sets the external URL of the image.
    /// </summary>
    /// <remarks>
    /// The URL must point to a supported image format such as JPEG, PNG, or GIF.
    /// </remarks>
    property Url: string read FUrl write FUrl;
    /// <summary>
    /// Gets or sets the detail level of the image.
    /// </summary>
    /// <remarks>
    /// The detail level can be <c>low</c> for lower token consumption or <c>high</c> for detailed processing.
    /// </remarks>
    property Detail: string read FDetail write FDetail;
  end;

  /// <summary>
  /// Represents a citation within a message that references a specific portion of a file in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class is used to provide contextual citations by referencing parts of a file
  /// that the assistant used during message generation or processing.
  /// </remarks>
  TFileCitation = class
  private
    [JsonNameAttribute('file_id')]
    FFileId: string;
  public
    /// <summary>
    /// Gets or sets the file ID for the cited file.
    /// </summary>
    /// <remarks>
    /// The file ID is a reference to the specific file that contains the content being cited.
    /// This ensures that citations in messages are traceable and verifiable.
    /// </remarks>
    property FileId: string read FFileId write FFileId;
  end;

  /// <summary>
  /// Represents the file path of a file generated or referenced during message processing in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class is used to reference a file by its path or identifier, typically when
  /// files are generated dynamically during tasks like code execution or data processing.
  /// </remarks>
  TFilePath = class
  private
    [JsonNameAttribute('file_id')]
    FFileId: string;
  public
    /// <summary>
    /// Gets or sets the file ID for the file path.
    /// </summary>
    /// <remarks>
    /// The file ID uniquely identifies a generated or referenced file, allowing it to be
    /// retrieved or processed within the context of a message.
    /// </remarks>
    property FileId: string read FFileId write FFileId;
  end;

  /// <summary>
  /// Represents an annotation within a message, providing contextual references such as file citations or file paths.
  /// </summary>
  /// <remarks>
  /// This class is used to add annotations that point to specific parts of external files,
  /// providing traceable references within the message content.
  /// </remarks>
  TMesssagesAnnotation = class
  private
    FType: string;
    FText: string;
    [JsonNameAttribute('file_citation')]
    FFileCitation: TFileCitation;
    [JsonNameAttribute('file_path')]
    FFilePath: TFilePath;
    [JsonNameAttribute('start_index')]
    FStartIndex: Int64;
    [JsonNameAttribute('end_index')]
    FEndIndex: Int64;
  public
    /// <summary>
    /// Gets or sets the type of the annotation.
    /// </summary>
    /// <remarks>
    /// Typical values include <c>file_citation</c> and <c>file_path</c>.
    /// </remarks>
    property &Type: string read FType write FType;
    /// <summary>
    /// Gets or sets the annotated text within the message.
    /// </summary>
    property Text: string read FText write FText;
    /// <summary>
    /// Gets or sets the file citation details.
    /// </summary>
    /// <remarks>
    /// This property is used when the annotation refers to a specific part of a file for citation purposes.
    /// </remarks>
    property FileCitation: TFileCitation read FFileCitation write FFileCitation;
    /// <summary>
    /// Gets or sets the file path details.
    /// </summary>
    /// <remarks>
    /// This property is used when the annotation points to a file that was generated or referenced during processing.
    /// </remarks>
    property FilePath: TFilePath read FFilePath write FFilePath;
    /// <summary>
    /// Gets or sets the starting index of the annotated text.
    /// </summary>
    /// <remarks>
    /// The starting index is zero-based and specifies the position where the annotation begins.
    /// </remarks>
    property StartIndex: Int64 read FStartIndex write FStartIndex;
    /// <summary>
    /// Gets or sets the ending index of the annotated text.
    /// </summary>
    /// <remarks>
    /// The ending index is zero-based and specifies the position where the annotation ends.
    /// </remarks>
    property EndIndex: Int64 read FEndIndex write FEndIndex;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents the text content of a message within the OpenAI API, including any associated annotations.
  /// </summary>
  /// <remarks>
  /// This class stores the text content of a message along with any annotations that provide
  /// additional context, such as file citations or file paths.
  /// </remarks>
  TMessagesText = class
  private
    FValue: string;
    FAnnotations: TArray<TMesssagesAnnotation>;
  public
    /// <summary>
    /// Gets or sets the value of the text content.
    /// </summary>
    /// <remarks>
    /// The text content represents the primary message data, such as user input or assistant responses.
    /// </remarks>
    property Value: string read FValue write FValue;
    /// <summary>
    /// Gets or sets the list of annotations associated with the text.
    /// </summary>
    /// <remarks>
    /// Annotations can reference specific parts of external files or provide contextual metadata
    /// related to the message content.
    /// </remarks>
    property Annotations: TArray<TMesssagesAnnotation> read FAnnotations write FAnnotations;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents the content of a message in the OpenAI API, including text, images, and refusal reasons.
  /// </summary>
  /// <remarks>
  /// This class stores various types of content that can be part of a message,
  /// such as plain text, image references, or refusal messages indicating that the assistant
  /// declined to respond.
  /// </remarks>
  TMessagesContent = class
  private
    FType: string;
    [JsonNameAttribute('image_file')]
    FImageFile: TMessagesImageFile;
    [JsonNameAttribute('image_url')]
    FImageUrl: TMessagesImageUrl;
    FText: TMessagesText;
    FRefusal: string;
  public
    /// <summary>
    /// Gets or sets the type of content in the message.
    /// </summary>
    /// <remarks>
    /// Typical values include <c>text</c>, <c>image_file</c>, <c>image_url</c>, or <c>refusal</c>.
    /// </remarks>
    property &Type: string read FType write FType;
    /// <summary>
    /// Gets or sets the image file details if the content includes an image file.
    /// </summary>
    /// <remarks>
    /// This property is populated when the message references an image uploaded as a file.
    /// </remarks>
    property ImageFile: TMessagesImageFile read FImageFile write FImageFile;
    /// <summary>
    /// Gets or sets the external image URL details if the content includes an image URL.
    /// </summary>
    /// <remarks>
    /// This property is populated when the message references an image hosted externally via a URL.
    /// </remarks>
    property ImageUrl: TMessagesImageUrl read FImageUrl write FImageUrl;
    /// <summary>
    /// Gets or sets the text content of the message.
    /// </summary>
    /// <remarks>
    /// This property is populated when the message includes text data, which may contain annotations.
    /// </remarks>
    property Text: TMessagesText read FText write FText;
    /// <summary>
    /// Gets or sets the refusal message content if the assistant declined to respond.
    /// </summary>
    /// <remarks>
    /// This property is populated when the assistant provides a refusal explanation
    /// indicating why a response was not generated.
    /// </remarks>
    property Refusal: string read FRefusal write FRefusal;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a tool associated with an attachment in a message within the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class specifies the type of tool linked to an attachment, such as a code interpreter
  /// or file search tool, which can be used during message processing.
  /// </remarks>
  TAttachmentTool = class
  private
    [JsonReflectAttribute(ctString, rtString, TAssistantsToolsTypeInterceptor)]
    FType: TAssistantsToolsType;
  public
    /// <summary>
    /// Gets or sets the type of tool associated with the attachment.
    /// </summary>
    /// <remarks>
    /// Typical values include <c>code_interpreter</c> and <c>file_search</c>.
    /// The tool determines how the attached file is used during the conversation.
    /// </remarks>
    property &Type: TAssistantsToolsType read FType write FType;
  end;

  /// <summary>
  /// Represents an attachment associated with a message in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class stores information about a file attached to a message and the tools
  /// that can be used to process or interact with the file.
  /// </remarks>
  TAttachment = class
  private
    [JsonNameAttribute('file_id')]
    FFileId: string;
    FTools: TArray<TAttachmentTool>;
  public
    /// <summary>
    /// Gets or sets the file ID of the attachment.
    /// </summary>
    /// <remarks>
    /// The file ID uniquely identifies the attached file within the API and is used to retrieve
    /// or process it during message handling.
    /// </remarks>
    property FileId: string read FFileId write FFileId;
    /// <summary>
    /// Gets or sets the list of tools associated with the attachment.
    /// </summary>
    /// <remarks>
    /// Each tool defines how the attached file will be used, such as executing it with a
    /// code interpreter or searching its contents.
    /// </remarks>
    property Tools: TArray<TAttachmentTool> read FTools write FTools;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a message within a thread in the OpenAI API, including its content, status, metadata, and attachments.
  /// </summary>
  /// <remarks>
  /// This class stores all the details related to a message, such as its creation timestamp,
  /// role, status, and the content it contains (text, images, or other media).
  /// </remarks>
  TMessages = class(TJSONFingerprint)
  private
    FId: string;
    [JsonNameAttribute('created_at')]
    FCreatedAt: TInt64OrNull;
    FObject: string;
    [JsonNameAttribute('thread_id')]
    FThreadId: string;
    [JsonReflectAttribute(ctString, rtString, TMessageStatusInterceptor)]
    FStatus: TMessageStatus;
    [JsonNameAttribute('incomplete_details')]
    FIncompleteDetails: TIncompleteDetails;
    [JsonNameAttribute('completed_at')]
    FCompletedAt: TInt64OrNull;
    [JsonNameAttribute('incomplete_at')]
    FIncompleteAt: TInt64OrNull;
    [JsonReflectAttribute(ctString, rtString, TRoleInterceptor)]
    FRole: TRole;
    FContent: TArray<TMessagesContent>;
    [JsonNameAttribute('assistant_id')]
    FAssistantId: string;
    [JsonNameAttribute('run_id')]
    FRunId: string;
    FAttachments: TArray<TAttachment>;
    [JsonReflectAttribute(ctString, rtString, TMetadataInterceptor)]
    FMetadata: string;
  private
    function GetCreatedAtAsString: string;
    function GetCompletedAtAsString: string;
    function GetIncompleteAtAsString: string;
    function GetCreatedAt: Int64;
    function GetCompletedAt: Int64;
    function GetIncompleteAt: Int64;
  public
    /// <summary>
    /// Gets or sets the unique identifier of the message.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Gets the Unix timestamp (in seconds) indicating when the message was created.
    /// </summary>
    property CreatedAt: Int64 read GetCreatedAt;
    /// <summary>
    /// Gets the formatted creation time as a human-readable string.
    /// </summary>
    property CreatedAtAsString: string read GetCreatedAtAsString;
    /// <summary>
    /// Gets or sets the object type of the message.
    /// </summary>
    /// <remarks>
    /// This value is typically <c>thread.message</c>.
    /// </remarks>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// Gets or sets the ID of the thread that the message belongs to.
    /// </summary>
    property ThreadId: string read FThreadId write FThreadId;
    /// <summary>
    /// Gets or sets the status of the message.
    /// </summary>
    /// <remarks>
    /// The status indicates whether the message is in progress, incomplete, or completed.
    /// </remarks>
    property Status: TMessageStatus read FStatus write FStatus;
    /// <summary>
    /// Gets or sets the details related to why the message is incomplete, if applicable.
    /// </summary>
    property IncompleteDetails: TIncompleteDetails read FIncompleteDetails write FIncompleteDetails;
    /// <summary>
    /// Gets or sets the Unix timestamp (in seconds) when the message was completed.
    /// </summary>
    property CompletedAt: Int64 read GetCompletedAt;
    /// <summary>
    /// Gets the formatted completion time as a human-readable string.
    /// </summary>
    property CompletedAtString: string read GetCompletedAtAsString;
    /// <summary>
    /// Gets the Unix timestamp (in seconds) when the message was marked as incomplete.
    /// </summary>
    property IncompleteAt: Int64 read GetIncompleteAt;
    /// <summary>
    /// Gets the formatted incomplete time as a human-readable string.
    /// </summary>
    property IncompleteAtAsString: string read GetIncompleteAtAsString;
    /// <summary>
    /// Gets or sets the role associated with the message, such as user or assistant.
    /// </summary>
    property Role: TRole read FRole write FRole;
    /// <summary>
    /// Gets or sets the array of content types included in the message.
    /// </summary>
    /// <remarks>
    /// The content array can include text, images, or refusal messages.
    /// </remarks>
    property Content: TArray<TMessagesContent> read FContent write FContent;
    /// <summary>
    /// Gets or sets the assistant ID if the message was generated by an assistant.
    /// </summary>
    property AssistantId: string read FAssistantId write FAssistantId;
    /// <summary>
    /// Gets or sets the run ID associated with the message creation.
    /// </summary>
    property RunId: string read FRunId write FRunId;
    /// <summary>
    /// Gets or sets the list of files attached to the message.
    /// </summary>
    property Attachments: TArray<TAttachment> read FAttachments write FAttachments;
    /// <summary>
    /// Gets or sets the metadata associated with the message.
    /// </summary>
    /// <remarks>
    /// Metadata can store additional key-value pairs providing extra context for the message.
    /// </remarks>
    property Metadata: string read FMetadata write FMetadata;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a list of messages within a thread in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TAdvancedList</c> to provide a collection of <c>TMessages</c> objects,
  /// allowing for easy iteration and manipulation of messages retrieved from the API.
  /// </remarks>
  TMessagesList = TAdvancedList<TMessages>;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TMessages</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynMessages</c> type extends the <c>TAsynParams&lt;TMessages&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynMessages = TAsynCallBack<TMessages>;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TMessagesList</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynMessagesList</c> type extends the <c>TAsynParams&lt;TMessagesList&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynMessagesList = TAsynCallBack<TMessagesList>;

  /// <summary>
  /// Manages the API routes for handling messages within a thread in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class provides methods to create, retrieve, update, delete, and list messages
  /// within a thread. It also supports asynchronous operations for non-blocking message handling.
  /// </remarks>
  TMessagesRoute = class(TGenAIRoute)
  protected
    /// <summary>
    /// Customizes the headers used for the message routes.
    /// </summary>
    procedure HeaderCustomize; override;
  public
    /// <summary>
    /// Asynchronously creates a new message within the specified thread.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread where the message will be created.</param>
    /// <param name="ParamProc">A procedure to configure the message parameters.</param>
    /// <param name="CallBacks">A function to handle the asynchronous call result.</param>
    procedure AsynCreate(const ThreadId: string;
      const ParamProc: TProc<TThreadsMessageParams>;
      const CallBacks: TFunc<TAsynMessages>);
    /// <summary>
    /// Asynchronously retrieves the list of messages within the specified thread.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread to retrieve messages from.</param>
    /// <param name="CallBacks">A function to handle the asynchronous call result.</param>
    procedure AsynList(const ThreadId: string; const CallBacks: TFunc<TAsynMessagesList>); overload;
    /// <summary>
    /// Asynchronously retrieves the list of messages within the specified thread using additional URL parameters.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread to retrieve messages from.</param>
    /// <param name="ParamProc">A procedure to configure the URL parameters.</param>
    /// <param name="CallBacks">A function to handle the asynchronous call result.</param>
    procedure AsynList(const ThreadId: string; const ParamProc: TProc<TAssistantsUrlParams>;
      const CallBacks: TFunc<TAsynMessagesList>); overload;
    /// <summary>
    /// Asynchronously retrieves a specific message by its ID within a thread.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread containing the message.</param>
    /// <param name="MessageId">The ID of the message to retrieve.</param>
    /// <param name="CallBacks">A function to handle the asynchronous call result.</param>
    procedure AsynRetrieve(const ThreadId: string; const MessageId: string;
      const CallBacks: TFunc<TAsynMessages>);
    /// <summary>
    /// Asynchronously updates an existing message within a thread.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread containing the message.</param>
    /// <param name="MessageId">The ID of the message to update.</param>
    /// <param name="ParamProc">A procedure to configure the update parameters.</param>
    /// <param name="CallBacks">A function to handle the asynchronous call result.</param>
    procedure AsynUpdate(const ThreadId: string; const MessageId: string;
      const ParamProc: TProc<TMessagesUpdateParams>;
      const CallBacks: TFunc<TAsynMessages>);
    /// <summary>
    /// Asynchronously deletes a message within a thread.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread containing the message.</param>
    /// <param name="MessageId">The ID of the message to delete.</param>
    /// <param name="CallBacks">A function to handle the asynchronous call result.</param>
    procedure AsynDelete(const ThreadId: string; const MessageId: string;
      const CallBacks: TFunc<TAsynDeletion>);
    /// <summary>
    /// Creates a new message within the specified thread.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread where the message will be created.</param>
    /// <param name="ParamProc">A procedure to configure the message parameters.</param>
    /// <returns>
    /// The newly created message object.
    /// </returns>
    function Create(const ThreadId: string; const ParamProc: TProc<TThreadsMessageParams>): TMessages;
    /// <summary>
    /// Retrieves the list of messages within the specified thread.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread to retrieve messages from.</param>
    /// <returns>
    /// A list of messages associated with the thread.
    /// </returns>
    function List(const ThreadId: string): TMessagesList; overload;
    /// <summary>
    /// Retrieves the list of messages within the specified thread using additional URL parameters.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread to retrieve messages from.</param>
    /// <param name="ParamProc">A procedure to configure the URL parameters.</param>
    /// <returns>
    /// A list of messages associated with the thread.
    /// </returns>
    function List(const ThreadId: string; const ParamProc: TProc<TAssistantsUrlParams>): TMessagesList; overload;
    /// <summary>
    /// Retrieves a specific message by its ID within a thread.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread containing the message.</param>
    /// <param name="MessageId">The ID of the message to retrieve.</param>
    /// <returns>
    /// The message object matching the specified ID.
    /// </returns>
    function Retrieve(const ThreadId: string; const MessageId: string): TMessages;
    /// <summary>
    /// Updates an existing message within a thread.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread containing the message.</param>
    /// <param name="MessageId">The ID of the message to update.</param>
    /// <param name="ParamProc">A procedure to configure the update parameters.</param>
    /// <returns>
    /// The updated message object.
    /// </returns>
    function Update(const ThreadId: string; const MessageId: string; const ParamProc: TProc<TMessagesUpdateParams>): TMessages;
    /// <summary>
    /// Deletes a message within a thread.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread containing the message.</param>
    /// <param name="MessageId">The ID of the message to delete.</param>
    /// <returns>
    /// An object representing the deletion status.
    /// </returns>
    function Delete(const ThreadId: string; const MessageId: string): TDeletion;
  end;

implementation

{ TMessagesRoute }

procedure TMessagesRoute.AsynCreate(const ThreadId: string;
  const ParamProc: TProc<TThreadsMessageParams>;
  const CallBacks: TFunc<TAsynMessages>);
begin
  with TAsynCallBackExec<TAsynMessages, TMessages>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TMessages
      begin
        Result := Self.Create(ThreadId, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TMessagesRoute.AsynDelete(const ThreadId, MessageId: string;
  const CallBacks: TFunc<TAsynDeletion>);
begin
  with TAsynCallBackExec<TAsynDeletion, TDeletion>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TDeletion
      begin
        Result := Self.Delete(ThreadId, MessageId);
      end);
  finally
    Free;
  end;
end;

procedure TMessagesRoute.AsynList(const ThreadId: string;
  const CallBacks: TFunc<TAsynMessagesList>);
begin
  with TAsynCallBackExec<TAsynMessagesList, TMessagesList>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TMessagesList
      begin
        Result := Self.List(ThreadId);
      end);
  finally
    Free;
  end;
end;

procedure TMessagesRoute.AsynList(const ThreadId: string;
  const ParamProc: TProc<TAssistantsUrlParams>;
  const CallBacks: TFunc<TAsynMessagesList>);
begin
  with TAsynCallBackExec<TAsynMessagesList, TMessagesList>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TMessagesList
      begin
        Result := Self.List(ThreadId, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TMessagesRoute.AsynRetrieve(const ThreadId, MessageId: string;
  const CallBacks: TFunc<TAsynMessages>);
begin
  with TAsynCallBackExec<TAsynMessages, TMessages>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TMessages
      begin
        Result := Self.Retrieve(ThreadId, MessageId);
      end);
  finally
    Free;
  end;
end;

procedure TMessagesRoute.AsynUpdate(const ThreadId, MessageId: string;
  const ParamProc: TProc<TMessagesUpdateParams>;
  const CallBacks: TFunc<TAsynMessages>);
begin
  with TAsynCallBackExec<TAsynMessages, TMessages>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TMessages
      begin
        Result := Self.Update(ThreadId, MessageId, ParamProc);
      end);
  finally
    Free;
  end;
end;

function TMessagesRoute.Create(const ThreadId: string;
  const ParamProc: TProc<TThreadsMessageParams>): TMessages;
begin
  HeaderCustomize;
  Result := API.Post<TMessages, TThreadsMessageParams>('threads/' + ThreadId + '/messages', ParamProc);
end;

function TMessagesRoute.Delete(const ThreadId,
  MessageId: string): TDeletion;
begin
  HeaderCustomize;
  Result := API.Delete<TDeletion>('threads/' + ThreadId + '/messages/' + MessageId);
end;

procedure TMessagesRoute.HeaderCustomize;
begin
  inherited;
  API.CustomHeaders := [TNetHeader.Create('OpenAI-Beta', 'assistants=v2')];
end;

function TMessagesRoute.List(const ThreadId: string): TMessagesList;
begin
  HeaderCustomize;
  Result := API.Get<TMessagesList>('threads/' + ThreadId + '/messages');
end;

function TMessagesRoute.List(const ThreadId: string;
  const ParamProc: TProc<TAssistantsUrlParams>): TMessagesList;
begin
  HeaderCustomize;
  Result := API.Get<TMessagesList, TAssistantsUrlParams>('threads/' + ThreadId + '/messages', ParamProc);
end;

function TMessagesRoute.Retrieve(const ThreadId, MessageId: string): TMessages;
begin
  HeaderCustomize;
  Result := API.Get<TMessages>('threads/' + ThreadId + '/messages/' + MessageId);
end;

function TMessagesRoute.Update(const ThreadId, MessageId: string;
  const ParamProc: TProc<TMessagesUpdateParams>): TMessages;
begin
  HeaderCustomize;
  Result := API.Post<TMessages, TMessagesUpdateParams>('threads/' + ThreadId + '/messages/' + MessageId, ParamProc);
end;

{ TMessages }

destructor TMessages.Destroy;
begin
  if Assigned(FIncompleteDetails) then
    FIncompleteDetails.Free;
  for var Item in FContent do
    Item.Free;
  for var Item in FAttachments do
    Item.Free;
  inherited;
end;

function TMessages.GetCompletedAt: Int64;
begin
  Result := TInt64OrNull(FCompletedAt).ToInteger;
end;

function TMessages.GetCompletedAtAsString: string;
begin
  Result := TInt64OrNull(FCompletedAt).ToUctDateString;
end;

function TMessages.GetCreatedAt: Int64;
begin
  Result := TInt64OrNull(FCreatedAt).ToInteger;
end;

function TMessages.GetCreatedAtAsString: string;
begin
  Result := TInt64OrNull(FCreatedAt).ToUtcDateString;
end;

function TMessages.GetIncompleteAt: Int64;
begin
  Result := TInt64OrNull(FIncompleteAt).ToInteger;
end;

function TMessages.GetIncompleteAtAsString: string;
begin
  Result := TInt64OrNull(FIncompleteAt).ToUtcDateString;
end;

{ TMessagesContent }

destructor TMessagesContent.Destroy;
begin
  if Assigned(FImageFile) then
    FImageFile.Free;
  if Assigned(FImageUrl) then
    FImageUrl.Free;
  if Assigned(FText) then
    FText.Free;
  inherited;
end;

{ TMessagesText }

destructor TMessagesText.Destroy;
begin
  for var Item in FAnnotations do
    Item.Free;
  inherited;
end;

{ TMesssagesAnnotation }

destructor TMesssagesAnnotation.Destroy;
begin
  if Assigned(FFileCitation) then
    FFileCitation.Free;
  if Assigned(FFilePath) then
    FFilePath.Free;
  inherited;
end;

{ TAttachment }

destructor TAttachment.Destroy;
begin
  for var Item in FTools do
    Item.Free;
  inherited;
end;

{ TAssistantsUrlParams }

function TAssistantsUrlParams.RunId(const Value: string): TAssistantsUrlParams;
begin
  Result := TAssistantsUrlParams(Add('run_id', Value));
end;

{ TMessagesUpdateParams }

function TMessagesUpdateParams.Metadata(
  const Value: TJSONObject): TMessagesUpdateParams;
begin
  Result := TMessagesUpdateParams(Add('metadata', Value));
end;

end.

unit GenAI.Models;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Threading, REST.Json.Types,
  GenAI.API.Params, GenAI.API, GenAI.Async.Support, GenAI.API.Deletion,
  GenAI.Types;

type
  /// <summary>
  /// Represents an OpenAI model, encapsulating key information about a specific API model.
  /// </summary>
  /// <remarks>
  /// The TModel class stores attributes such as the unique identifier, creation timestamp,
  /// object type, and ownership details of the model. This class is typically used to handle
  /// and manipulate data related to models provided by OpenAI's API.
  /// </remarks>
  TModel = class(TJSONFingerprint)
  private
    FId: string;
    FCreated: TInt64OrNull;
    FObject: string;
    [JsonNameAttribute('owned_by')]
    FOwnedBy: string;
  private
    function GetCreatedAsString: string;
    function GetCreated: Int64;
  public
    /// <summary>
    /// Gets or sets the unique identifier of the model.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Gets the creation timestamp of the model, represented as a Unix timestamp.
    /// </summary>
    property Created: Int64 read GetCreated;
    /// <summary>
    /// Gets the creation timestamp of the model as a string.
    /// </summary>
    property CreatedAsString: string read GetCreatedAsString;
    /// <summary>
    /// Gets or sets the object type, which is consistently set to "model".
    /// </summary>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// Gets or sets the identifier of the organization that owns the model.
    /// </summary>
    property OwnedBy: string read FOwnedBy write FOwnedBy;
  end;

  /// <summary>
  /// Represents a collection of OpenAI models, providing a list structure for managing multiple model instances.
  /// </summary>
  /// <remarks>
  /// The TModels class encapsulates a list of TModel objects, each representing detailed information about
  /// individual models. This collection is useful for operations that require handling multiple models,
  /// such as listing all available models from the OpenAI API.
  /// </remarks>
  TModels = class(TJSONFingerprint)
  private
    FObject: string;
    FData: TArray<TModel>;
  public
    /// <summary>
    /// Gets or sets the type of object, consistently set to "list" in this context.
    /// </summary>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// Gets or sets the array of model objects, providing access to multiple models.
    /// </summary>
    property Data: TArray<TModel> read FData write FData;
    /// <summary>
    /// Destructor to manage the cleanup of the array items when the TModels object is destroyed.
    /// </summary>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TModel</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynModel</c> type extends the <c>TAsynParams&lt;TModel&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynModel = TAsynCallBack<TModel>;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TModels</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynModels</c> type extends the <c>TAsynParams&lt;TModels&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynModels = TAsynCallBack<TModels>;

  /// <summary>
  /// Provides routes for managing model data via API calls, including listing, retrieving, and deleting models.
  /// </summary>
  /// <remarks>
  /// The TModelsRoute class includes methods that facilitate asynchronous and synchronous operations
  /// to list, delete, and retrieve OpenAI models through the API. It acts as a controller for the
  /// interaction with the OpenAI model endpoints.
  /// </remarks>
  TModelsRoute = class(TGenAIRoute)
    /// <summary>
    /// Asynchronously lists all available models and returns them in a TModels object through a callback mechanism.
    /// </summary>
    /// <param name="CallBacks">A set of callback functions for success, error, and start conditions.</param>
    procedure AsynList(const CallBacks: TFunc<TAsynModels>);
    /// <summary>
    /// Asynchronously deletes a specified model by ID and returns the deletion status through a callback mechanism.
    /// </summary>
    /// <param name="ModelId">The unique identifier of the model to be deleted.</param>
    /// <param name="CallBacks">A set of callback functions for success, error, and start conditions.</param>
    procedure AsynDelete(const ModelId: string; const CallBacks: TFunc<TAsynDeletion>);
    /// <summary>
    /// Asynchronously retrieves a specific model by ID and returns it in a TModel object through a callback mechanism.
    /// </summary>
    /// <param name="ModelId">The unique identifier of the model to be retrieved.</param>
    /// <param name="CallBacks">A set of callback functions for success, error, and start conditions.</param>
    procedure AsynRetrieve(const ModelId: string; const CallBacks: TFunc<TAsynModel>);
    /// <summary>
    /// Synchronously lists all available models and returns them in a TModels object.
    /// </summary>
    /// <returns>A TModels object containing a list of all models.</returns>
    function List: TModels;
    /// <summary>
    /// Synchronously deletes a specified model by ID and returns the deletion status.
    /// </summary>
    /// <param name="ModelId">The unique identifier of the model to be deleted.</param>
    /// <returns>A TModelDeletion object indicating the status of the deletion.</returns>
    function Delete(const ModelId: string): TDeletion;
    /// <summary>
    /// Synchronously retrieves a specific model by ID and returns it in a TModel object.
    /// </summary>
    /// <param name="ModelId">The unique identifier of the model to be retrieved.</param>
    /// <returns>A TModel object containing the model details.</returns>
    function Retrieve(const ModelId: string): TModel;
  end;

implementation

{ TModels }

destructor TModels.Destroy;
begin
  for var Item in FData do
    Item.Free;
  inherited;
end;

{ TModelsRoute }

procedure TModelsRoute.AsynDelete(const ModelId: string;
  const CallBacks: TFunc<TAsynDeletion>);
begin
  with TAsynCallBackExec<TAsynDeletion, TDeletion>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TDeletion
      begin
        Result := Self.Delete(ModelId);
      end);
  finally
    Free;
  end;
end;

procedure TModelsRoute.AsynList(const CallBacks: TFunc<TAsynModels>);
begin
  with TAsynCallBackExec<TAsynModels, TModels>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TModels
      begin
        Result := Self.List;
      end);
  finally
    Free;
  end;
end;

procedure TModelsRoute.AsynRetrieve(const ModelId: string;
  const CallBacks: TFunc<TAsynModel>);
begin
  with TAsynCallBackExec<TAsynModel, TModel>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TModel
      begin
        Result := Self.Retrieve(ModelId);
      end);
  finally
    Free;
  end;
end;

function TModelsRoute.Delete(const ModelId: string): TDeletion;
begin
  Result := API.Delete<TDeletion>(Format('models/%s', [ModelId]));
end;

function TModelsRoute.List: TModels;
begin
  Result := API.Get<TModels>('models');
end;

function TModelsRoute.Retrieve(const ModelId: string): TModel;
begin
  Result := API.Get<TModel>(Format('models/%s', [ModelId]));
end;

{ TModel }

function TModel.GetCreated: Int64;
begin
  Result := TInt64OrNull(FCreated).ToInteger;
end;

function TModel.GetCreatedAsString: string;
begin
  Result := TInt64OrNull(FCreated).ToUtcDateString;
end;

end.


unit GenAI.Moderation;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Threading, System.JSON, REST.Json.Types,
  REST.JsonReflect,
  GenAI.API.Params, GenAI.API, GenAI.Consts, GenAI.Types, GenAI.Async.Support;

type
  /// <summary>
  /// Represents a text moderation parameter for a JSON object, enabling the configuration
  /// of text inputs to be classified for moderation purposes.
  /// </summary>
  /// <remarks>
  /// This class provides methods to define the type and content of text data to be
  /// analyzed for potentially harmful content. It is specifically designed for use
  /// in moderation APIs to assess textual content.
  /// </remarks>
  TTextModerationParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the type of input as 'text'. This ensures that the API interprets the
    /// input data as textual content for moderation.
    /// </summary>
    /// <param name="Value">
    /// A string that specifies the input type, typically 'text'.
    /// </param>
    /// <returns>
    /// Returns an instance of TTextModerationParams.
    /// </returns>
    function &Type(const Value: string): TTextModerationParams;
    /// <summary>
    /// Sets the text content to be classified for moderation. This method allows
    /// the inclusion of a string of text that will be evaluated by the moderation API.
    /// </summary>
    /// <param name="Value">
    /// The text content to be analyzed for potentially harmful content.
    /// </param>
    /// <returns>
    /// Returns an instance of TTextModerationParams.
    /// </returns>
    function Text(const Value: string): TTextModerationParams;
    /// <summary>
    /// Creates a new instance of TTextModerationParams with the specified text input.
    /// This method combines the configuration of input type and text content for
    /// streamlined initialization.
    /// </summary>
    /// <param name="Value">
    /// The string of text to be classified for moderation.
    /// </param>
    /// <returns>
    /// Returns a newly instantiated object of TTextModerationParams.
    /// </returns>
    class function New(const Value: string): TTextModerationParams;
  end;

  /// <summary>
  /// Represents a URL moderation parameter for a JSON object, enabling the configuration
  /// of URLs to be classified for moderation purposes.
  /// </summary>
  /// <remarks>
  /// This class provides methods to define and handle URLs as input for moderation.
  /// It supports both direct web URLs and local file paths that can be encoded into
  /// base64 format for evaluation by the moderation API.
  /// </remarks>
  TUrlModerationParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the URL of the resource to be moderated. This can be a direct web link
    /// or a file path for base64 encoding.
    /// </summary>
    /// <param name="Value">
    /// The URL or file path of the resource to be analyzed for potentially harmful content.
    /// </param>
    /// <returns>
    /// Returns an instance of TUrlModerationParams.
    /// </returns>
    function Url(const Value: string): TUrlModerationParams;
    /// <summary>
    /// Creates a new instance of TUrlModerationParams with the specified URL.
    /// This method initializes the URL parameter for moderation requests.
    /// </summary>
    /// <param name="Value">
    /// The URL or file path of the resource to be analyzed.
    /// </param>
    /// <returns>
    /// Returns a newly instantiated object of TUrlModerationParams.
    /// </returns>
    class function New(const Value: string): TUrlModerationParams;
  end;

  /// <summary>
  /// Represents an image moderation parameter for a JSON object, enabling the configuration
  /// of image inputs to be classified for moderation purposes.
  /// </summary>
  /// <remarks>
  /// This class provides methods to define the type and content of image data, either
  /// via direct URLs or base64-encoded strings, to be analyzed for potentially harmful content.
  /// It is specifically designed for use in moderation APIs to assess image content.
  /// </remarks>
  TImageModerationParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the type of input as 'image_url'. This ensures that the API interprets the
    /// input data as an image URL or base64-encoded image for moderation.
    /// </summary>
    /// <param name="Value">
    /// A string that specifies the input type, typically 'image_url'.
    /// </param>
    /// <returns>
    /// Returns an instance of TImageModerationParams.
    /// </returns>
    function &Type(const Value: string): TImageModerationParams;
    /// <summary>
    /// Sets the image URL or base64-encoded data to be classified for moderation.
    /// This method allows the inclusion of an image URL or encoded image data
    /// that will be evaluated by the moderation API.
    /// </summary>
    /// <param name="Value">
    /// The URL or base64-encoded string representing the image content.
    /// </param>
    /// <returns>
    /// Returns an instance of TImageModerationParams.
    /// </returns>
    function ImageUrl(const Value: string): TImageModerationParams;
    /// <summary>
    /// Creates a new instance of TImageModerationParams with the specified image URL or
    /// base64-encoded image data. This method combines the configuration of input type
    /// and image content for streamlined initialization.
    /// </summary>
    /// <param name="Value">
    /// The string of the image URL or base64-encoded data to be classified for moderation.
    /// </param>
    /// <returns>
    /// Returns a newly instantiated object of TImageModerationParams.
    /// </returns>
    class function New(const Value: string): TImageModerationParams;
  end;

  /// <summary>
  /// Represents the parameters for moderation requests, enabling configuration
  /// for input data and model selection to classify content for moderation purposes.
  /// </summary>
  /// <remarks>
  /// This class provides methods to configure and handle inputs for moderation,
  /// such as text, image URLs, or an array of mixed inputs. It also allows
  /// specifying the moderation model to use.
  /// </remarks>
  TModerationParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the input data for the moderation request. This can be a single string
    /// or an array of strings, and the type is determined automatically.
    /// </summary>
    /// <param name="Value">
    /// The input content as a string or an array of strings.
    /// </param>
    /// <returns>
    /// Returns an instance of TModerationParams.
    /// </returns>
    function Input(const Value: string): TModerationParams; overload;
    /// <summary>
    /// Sets multiple input data elements for the moderation request. This method
    /// accepts an array of strings, which can include text or image paths/URLs.
    /// </summary>
    /// <param name="Value">
    /// An array of strings representing text or image inputs.
    /// </param>
    /// <returns>
    /// Returns an instance of TModerationParams.
    /// </returns>
    function Input(const Value: TArray<string>): TModerationParams; overload;
    /// <summary>
    /// Specifies the moderation model to be used for the request. The default
    /// model is "omni-moderation-latest".
    /// </summary>
    /// <param name="Value">
    /// A string representing the name of the moderation model.
    /// </param>
    /// <returns>
    /// Returns an instance of TModerationParams.
    /// </returns>
    function Model(const Value: string): TModerationParams;
  end;

  /// <summary>
  /// Represents the moderation categories used to classify content as potentially harmful.
  /// Each category indicates a specific type of harmful content, such as harassment,
  /// violence, or hate speech.
  /// </summary>
  /// <remarks>
  /// This class provides properties for each moderation category. These properties
  /// are boolean values indicating whether the corresponding category is flagged
  /// for the given input.
  /// </remarks>
  TModerationCategories = class
  private
    FHate: Boolean;
    [JsonNameAttribute('hate/threatening')]
    FHateThreatening: Boolean;
    FHarassment: Boolean;
    [JsonNameAttribute('harassment/threatening')]
    FHarassmentThreatening: Boolean;
    FIllicit: Boolean;
    [JsonNameAttribute('illicit/violent')]
    FIllicitViolent: Boolean;
    [JsonNameAttribute('self-harm')]
    FSelfHarm: Boolean;
    [JsonNameAttribute('self-harm/intent')]
    FSelfHarmIntent: Boolean;
    [JsonNameAttribute('self-harm/instructions')]
    FSelfHarmInstructions: Boolean;
    FSexual: Boolean;
    [JsonNameAttribute('sexual/minors')]
    FSexualMinors: Boolean;
    FViolence: Boolean;
    [JsonNameAttribute('violence/graphics')]
    FViolenceGraphic: Boolean;
  public
    /// <summary>
    /// Indicates whether the content contains hate speech based on race, gender,
    /// ethnicity, religion, nationality, sexual orientation, disability status, or caste.
    /// </summary>
    property Hate: Boolean read FHate write FHate;
    /// <summary>
    /// Indicates whether the content includes hateful speech that also involves
    /// violence or serious harm towards the targeted group.
    /// </summary>
    property HateThreatening: Boolean read FHateThreatening write FHateThreatening;
    /// <summary>
    /// Indicates whether the content contains language that is harassing towards a target.
    /// </summary>
    property Harassment: Boolean read FHarassment write FHarassment;
    /// <summary>
    /// Indicates whether the harassing content also involves threats of violence
    /// or serious harm.
    /// </summary>
    property HarassmentThreatening: Boolean read FHarassmentThreatening write FHarassmentThreatening;
    /// <summary>
    /// Indicates whether the content includes instructions or advice that facilitate
    /// wrongdoing or illicit acts.
    /// </summary>
    property Illicit: Boolean read FIllicit write FIllicit;
    /// <summary>
    /// Indicates whether the illicit content also involves violence or weapon procurement.
    /// </summary>
    property IllicitViolent: Boolean read FIllicitViolent write FIllicitViolent;
    /// <summary>
    /// Indicates whether the content promotes or depicts acts of self-harm, such as
    /// suicide, cutting, or eating disorders.
    /// </summary>
    property SelfHarm: Boolean read FSelfHarm write FSelfHarm;
    /// <summary>
    /// Indicates whether the content explicitly states an intent to commit self-harm.
    /// </summary>
    property SelfHarmIntent: Boolean read FSelfHarmIntent write FSelfHarmIntent;
    /// <summary>
    /// Indicates whether the content provides instructions or encouragement for
    /// acts of self-harm.
    /// </summary>
    property SelfHarmInstructions: Boolean read FSelfHarmInstructions write FSelfHarmInstructions;
    /// <summary>
    /// Indicates whether the content contains sexually explicit material designed
    /// to arouse sexual excitement.
    /// </summary>
    property Sexual: Boolean read FSexual write FSexual;
    /// <summary>
    /// Indicates whether the content contains sexual material involving minors.
    /// </summary>
    property SexualMinors: Boolean read FSexualMinors write FSexualMinors;
    /// <summary>
    /// Indicates whether the content depicts acts of violence, death, or physical injury.
    /// </summary>
    property Violence: Boolean read FViolence write FViolence;
    /// <summary>
    /// Indicates whether the violent content is graphically detailed.
    /// </summary>
    property ViolenceGraphic: Boolean read FViolenceGraphic write FViolenceGraphic;
  end;

  /// <summary>
  /// Represents the scores for various moderation categories, providing numerical
  /// values that indicate the likelihood of content falling into specific harmful
  /// categories.
  /// </summary>
  /// <remarks>
  /// This class defines properties to store scores for multiple categories, such as
  /// hate, harassment, violence, and others. The scores range from 0 to 1, where
  /// higher values indicate a stronger likelihood of the content being flagged for
  /// the respective category.
  /// </remarks>
  TModerationCategoryScores = class
  private
    FHate: Double;
    [JsonNameAttribute('hate/threatening')]
    FHateThreatening: Double;
    FHarassment: Double;
    [JsonNameAttribute('harassment/threatening')]
    FHarassmentThreatening: Double;
    FIllicit: Double;
    [JsonNameAttribute('illicit/violent')]
    FIllicitViolent: Double;
    [JsonNameAttribute('self-harm')]
    FSelfHarm: Double;
    [JsonNameAttribute('self-harm/intent')]
    FSelfHarmIntent: Double;
    [JsonNameAttribute('self-harm/instructions')]
    FSelfHarmInstructions: Double;
    FSexual: Double;
    [JsonNameAttribute('sexual/minors')]
    FSexualMinors: Double;
    FViolence: Double;
    [JsonNameAttribute('violence/graphics')]
    FViolenceGraphic: Double;
  public
    /// <summary>
    /// The score for the 'hate' category, representing the likelihood of hateful content.
    /// </summary>
    property Hate: Double read FHate write FHate;
    /// <summary>
    /// The score for the 'hate/threatening' category, representing the likelihood
    /// of threatening hateful content.
    /// </summary>
    property HateThreatening: Double read FHateThreatening write FHateThreatening;
    /// <summary>
    /// The score for the 'harassment' category, representing the likelihood of
    /// harassing content.
    /// </summary>
    property Harassment: Double read FHarassment write FHarassment;
    /// <summary>
    /// The score for the 'harassment/threatening' category, representing the likelihood
    /// of threatening harassing content.
    /// </summary>
    property HarassmentThreatening: Double read FHarassmentThreatening write FHarassmentThreatening;
    /// <summary>
    /// The score for the 'illicit' category, representing the likelihood of content
    /// promoting illicit activities.
    /// </summary>
    property Illicit: Double read FIllicit write FIllicit;
    /// <summary>
    /// The score for the 'illicit/violent' category, representing the likelihood
    /// of content promoting illicit violence.
    /// </summary>
    property IllicitViolent: Double read FIllicitViolent write FIllicitViolent;
    /// <summary>
    /// The score for the 'self-harm' category, representing the likelihood of content
    /// promoting or encouraging self-harm.
    /// </summary>
    property SelfHarm: Double read FSelfHarm write FSelfHarm;
    /// <summary>
    /// The score for the 'self-harm/intent' category, representing the likelihood
    /// of content indicating self-harm intent.
    /// </summary>
    property SelfHarmIntent: Double read FSelfHarmIntent write FSelfHarmIntent;
    /// <summary>
    /// The score for the 'self-harm/instructions' category, representing the likelihood
    /// of content providing instructions on self-harm.
    /// </summary>
    property SelfHarmInstructions: Double read FSelfHarmInstructions write FSelfHarmInstructions;
    /// <summary>
    /// The score for the 'sexual' category, representing the likelihood of content
    /// with explicit sexual material.
    /// </summary>
    property Sexual: Double read FSexual write FSexual;
    /// <summary>
    /// The score for the 'sexual/minors' category, representing the likelihood
    /// of sexual content involving minors.
    /// </summary>
    property SexualMinors: Double read FSexualMinors write FSexualMinors;
    /// <summary>
    /// The score for the 'violence' category, representing the likelihood of content
    /// involving violence.
    /// </summary>
    property Violence: Double read FViolence write FViolence;
    /// <summary>
    /// The score for the 'violence/graphics' category, representing the likelihood
    /// of content with graphic depictions of violence.
    /// </summary>
    property ViolenceGraphic: Double read FViolenceGraphic write FViolenceGraphic;
  end;

  /// <summary>
  /// Represents a moderation category applied to various input types, providing
  /// details on how different moderation categories are assigned based on input.
  /// </summary>
  /// <remarks>
  /// This class provides properties to retrieve the specific input types (e.g., text or image)
  /// that are associated with each moderation category. It is useful for identifying
  /// the sources of flagged content within a moderation request.
  /// </remarks>
  TModerationCategoryApplied = class
  private
    FHate: TArray<string>;
    [JsonNameAttribute('hate/threatening')]
    FHateThreatening: TArray<string>;
    FHarassment: TArray<string>;
    [JsonNameAttribute('harassment/threatening')]
    FHarassmentThreatening: TArray<string>;
    FIllicit: TArray<string>;
    [JsonNameAttribute('illicit/violent')]
    FIllicitViolent: TArray<string>;
    [JsonNameAttribute('self-harm')]
    FSelfHarm: TArray<string>;
    [JsonNameAttribute('self-harm/intent')]
    FSelfHarmIntent: TArray<string>;
    [JsonNameAttribute('self-harm/instructions')]
    FSelfHarmInstructions: TArray<string>;
    FSexual: TArray<string>;
    [JsonNameAttribute('sexual/minors')]
    FSexualMinors: TArray<string>;
    FViolence: TArray<string>;
    [JsonNameAttribute('violence/graphics')]
    FViolenceGraphic: TArray<string>;
  public
    /// <summary>
    /// Categories applied to hateful content.
    /// </summary>
    property Hate: TArray<string> read FHate write FHate;
    /// <summary>
    /// Categories applied to hateful content that includes threats.
    /// </summary>
    property HateThreatening: TArray<string> read FHateThreatening write FHateThreatening;
    /// <summary>
    /// Categories applied to harassment content.
    /// </summary>
    property Harassment: TArray<string> read FHarassment write FHarassment;
    /// <summary>
    /// Categories applied to harassment content that includes threats.
    /// </summary>
    property HarassmentThreatening: TArray<string> read FHarassmentThreatening write FHarassmentThreatening;
    /// <summary>
    /// Categories applied to illicit content.
    /// </summary>
    property Illicit: TArray<string> read FIllicit write FIllicit;
    /// <summary>
    /// Categories applied to illicit content that involves violence.
    /// </summary>
    property IllicitViolent: TArray<string> read FIllicitViolent write FIllicitViolent;
    /// <summary>
    /// Categories applied to self-harm-related content.
    /// </summary>
    property SelfHarm: TArray<string> read FSelfHarm write FSelfHarm;
    /// <summary>
    /// Categories applied to self-harm content expressing intent.
    /// </summary>
    property SelfHarmIntent: TArray<string> read FSelfHarmIntent write FSelfHarmIntent;
    /// <summary>
    /// Categories applied to self-harm content providing instructions.
    /// </summary>
    property SelfHarmInstructions: TArray<string> read FSelfHarmInstructions write FSelfHarmInstructions;
    /// <summary>
    /// Categories applied to sexual content.
    /// </summary>
    property Sexual: TArray<string> read FSexual write FSexual;
    /// <summary>
    /// Categories applied to sexual content involving minors.
    /// </summary>
    property SexualMinors: TArray<string> read FSexualMinors write FSexualMinors;
    /// <summary>
    /// Categories applied to violent content.
    /// </summary>
    property Violence: TArray<string> read FViolence write FViolence;
    /// <summary>
    /// Categories applied to graphically violent content.
    /// </summary>
    property ViolenceGraphic: TArray<string> read FViolenceGraphic write FViolenceGraphic;
  end;

  /// <summary>
  /// Represents a flagged item that contains information about a harmful content category
  /// and its associated score as determined by a moderation model.
  /// </summary>
  /// <remarks>
  /// This record is used to store details about content that has been flagged during
  /// moderation, including the category of harm and its confidence score. It is
  /// typically part of a collection of flagged items in moderation results.
  /// </remarks>
  TFlaggedItem = record
  private
    FCategory: THarmCategories;
    FScore: Double;
  public
    /// <summary>
    /// Gets or sets the category of harm associated with the flagged item.
    /// </summary>
    property Category: THarmCategories read FCategory write FCategory;
    /// <summary>
    /// Gets or sets the confidence score for the flagged category.
    /// </summary>
    property Score: Double read FScore write FScore;
    /// <summary>
    /// Initializes a new instance of the TFlaggedItem record with the specified
    /// harm category and confidence score.
    /// </summary>
    /// <param name="ACategory">
    /// The category of harm associated with the flagged item.
    /// </param>
    /// <param name="AScore">
    /// The confidence score for the flagged category.
    /// </param>
    constructor Create(const ACategory: THarmCategories; const AScore: Double);
  end;

  /// <summary>
  /// Represents the result of a moderation process, including information about
  /// flagged categories, their confidence scores, and the associated input types.
  /// </summary>
  /// <remarks>
  /// This class provides a detailed overview of the moderation analysis, including
  /// which categories were flagged, the confidence scores for each category, and
  /// the types of inputs (e.g., text or image) associated with flagged categories.
  /// </remarks>
  TModerationResult = class
  strict private
    function GetFlaggedDetail: TArray<TFlaggedItem>;
  private
    FFlagged: Boolean;
    FCategories: TModerationCategories;
    [JsonNameAttribute('category_scores')]
    FCategoryScores: TModerationCategoryScores;
    [JsonNameAttribute('category_applied_input_types')]
    FCategoryAppliedInputTypes: TModerationCategoryApplied;
  public
    /// <summary>
    /// Indicates whether any categories were flagged during moderation.
    /// </summary>
    property Flagged: Boolean read FFlagged write FFlagged;
    /// <summary>
    /// Provides the status of all moderation categories and whether they were flagged.
    /// </summary>
    property Categories: TModerationCategories read FCategories write FCategories;
    /// <summary>
    /// Provides the confidence scores for each moderation category as predicted by the model.
    /// </summary>
    property CategoryScores: TModerationCategoryScores read FCategoryScores write FCategoryScores;
    /// <summary>
    /// Specifies the input types (e.g., text, image) associated with flagged categories.
    /// </summary>
    property CategoryAppliedInputTypes: TModerationCategoryApplied read FCategoryAppliedInputTypes write FCategoryAppliedInputTypes;
    /// <summary>
    /// Retrieves detailed information about flagged items, including their categories
    /// and confidence scores.
    /// </summary>
    property FlaggedDetail: TArray<TFlaggedItem> read GetFlaggedDetail;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents the overall moderation response, including results, model information,
  /// and a unique identifier for the moderation request.
  /// </summary>
  /// <remarks>
  /// This class serves as the main container for moderation data, encapsulating
  /// results from the moderation process, the model used, and the unique request ID.
  /// </remarks>
  TModeration = class(TJSONFingerprint)
  private
    FId: string;
    FModel: string;
    FResults: TArray<TModerationResult>;
  public
    /// <summary>
    /// Gets or sets the unique identifier for the moderation request.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Gets or sets the name of the moderation model used for evaluation.
    /// </summary>
    property Model: string read FModel write FModel;
    /// <summary>
    /// Gets or sets the array of results from the moderation process.
    /// </summary>
    property Results: TArray<TModerationResult> read FResults write FResults;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TModeration</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynModeration</c> type extends the <c>TAsynParams&lt;TModeration&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynModeration = TAsynCallBack<TModeration>;

  /// <summary>
  /// Represents a route for handling moderation requests in the GenAI framework.
  /// This class provides methods for evaluating moderation parameters both
  /// synchronously and asynchronously.
  /// </summary>
  /// <remarks>
  /// This class is designed to manage moderation requests by interfacing with
  /// the GenAI API. It supports both synchronous and asynchronous operations
  /// for evaluating content against moderation models.
  /// </remarks>
  TModerationRoute = class(TGenAIRoute)
    /// <summary>
    /// Asynchronously evaluates the given moderation parameters and triggers
    /// the specified callback functions upon completion.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the moderation parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that defines the asynchronous callbacks for success, error,
    /// and other states during the operation.
    /// </param>
    procedure AsynEvaluate(const ParamProc: TProc<TModerationParams>; CallBacks: TFunc<TAsynModeration>);
    /// <summary>
    /// Synchronously evaluates the given moderation parameters and returns
    /// the moderation result.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the moderation parameters.
    /// </param>
    /// <returns>
    /// Returns a TModeration object containing the results of the moderation process.
    /// </returns>
    function Evaluate(const ParamProc: TProc<TModerationParams>): TModeration;
  end;

implementation

uses
  GenAI.Httpx, GenAI.NetEncoding.Base64;

{ TModerationParams }

function TModerationParams.Input(const Value: string): TModerationParams;
begin
  Result := TModerationParams(Add('input', Value));
end;

function TModerationParams.Input(
  const Value: TArray<string>): TModerationParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    begin
      if Item.ToLower.StartsWith('http') or FileExists(Item) then
        JSONArray.Add( TImageModerationParams.New(Item).Detach ) else
        JSONArray.Add( TTextModerationParams.New(Item).Detach );
    end;
  Result := TModerationParams(Add('input', JSONArray));
end;

function TModerationParams.Model(const Value: string): TModerationParams;
begin
  Result := TModerationParams(Add('model', Value));
end;

{ TTextModerationParams }

class function TTextModerationParams.New(
  const Value: string): TTextModerationParams;
begin
  Result := TTextModerationParams.Create.&Type('text').Text(Value);
end;

function TTextModerationParams.Text(const Value: string): TTextModerationParams;
begin
  Result := TTextModerationParams(Add('text', Value));
end;

function TTextModerationParams.&Type(
  const Value: string): TTextModerationParams;
begin
  Result := TTextModerationParams(Add('type', Value));
end;

{ TImageModerationParams }

function TImageModerationParams.ImageUrl(
  const Value: string): TImageModerationParams;
begin
  Result := TImageModerationParams(Add('image_url', TUrlModerationParams.New(Value).Detach));
end;

class function TImageModerationParams.New(
  const Value: string): TImageModerationParams;
begin
  Result := TImageModerationParams.Create.&Type('image_url').ImageUrl(Value);
end;

function TImageModerationParams.&Type(
  const Value: string): TImageModerationParams;
begin
  Result := TImageModerationParams(Add('type', Value));
end;

{ TUrlModerationParams }

class function TUrlModerationParams.New(
  const Value: string): TUrlModerationParams;
begin
  Result := TUrlModerationParams.Create.Url(Value);
end;

function TUrlModerationParams.Url(const Value: string): TUrlModerationParams;
begin
  Result := TUrlModerationParams(Add('url', GetUrlOrEncodeBase64(Value)));
end;

{ TModeration }

destructor TModeration.Destroy;
begin
  for var Item in FResults do
    Item.Free;
  inherited;
end;

{ TModerationResult }

destructor TModerationResult.Destroy;
begin
  if Assigned(FCategories) then
    FCategories.Free;
  if Assigned(FCategoryScores) then
    FCategoryScores.Free;
  if Assigned(FCategoryAppliedInputTypes) then
    FCategoryAppliedInputTypes.Free;
  inherited;
end;

function TModerationResult.GetFlaggedDetail: TArray<TFlaggedItem>;
begin
  if not Flagged then
    Exit;

  if Categories.Hate then
    Result := Result + [TFlaggedItem.Create(THarmCategories.hate, CategoryScores.Hate)];
  if Categories.HateThreatening then
    Result := Result + [TFlaggedItem.Create(THarmCategories.hateThreatening, CategoryScores.HateThreatening)];
  if Categories.Harassment then
    Result := Result + [TFlaggedItem.Create(THarmCategories.harassment, CategoryScores.Harassment)];
  if Categories.HarassmentThreatening then
    Result := Result + [TFlaggedItem.Create(THarmCategories.harassmentThreatening, CategoryScores.HarassmentThreatening)];
  if Categories.Illicit then
    Result := Result + [TFlaggedItem.Create(THarmCategories.illicit, CategoryScores.Illicit)];
  if Categories.IllicitViolent then
    Result := Result + [TFlaggedItem.Create(THarmCategories.illicitViolent, CategoryScores.IllicitViolent)];
  if Categories.SelfHarm then
    Result := Result + [TFlaggedItem.Create(THarmCategories.selfHarm, CategoryScores.SelfHarm)];
  if Categories.SelfHarmIntent then
    Result := Result + [TFlaggedItem.Create(THarmCategories.selfHarmIntent, CategoryScores.SelfHarmIntent)];
  if Categories.SelfHarmInstructions then
    Result := Result + [TFlaggedItem.Create(THarmCategories.selfHarmInstructions, CategoryScores.SelfHarmInstructions)];
  if Categories.Sexual then
    Result := Result + [TFlaggedItem.Create(THarmCategories.sexual, CategoryScores.Sexual)];
  if Categories.SexualMinors then
    Result := Result + [TFlaggedItem.Create(THarmCategories.sexualMinors, CategoryScores.SexualMinors)];
  if Categories.Violence then
    Result := Result + [TFlaggedItem.Create(THarmCategories.violence, CategoryScores.Violence)];
  if Categories.ViolenceGraphic then
    Result := Result + [TFlaggedItem.Create(THarmCategories.violenceGraphic, CategoryScores.ViolenceGraphic)];
end;

{ TModerationRoute }

procedure TModerationRoute.AsynEvaluate(
  const ParamProc: TProc<TModerationParams>; CallBacks: TFunc<TAsynModeration>);
begin
  with TAsynCallBackExec<TAsynModeration, TModeration>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TModeration
      begin
        Result := Self.Evaluate(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TModerationRoute.Evaluate(
  const ParamProc: TProc<TModerationParams>): TModeration;
begin
  Result := API.Post<TModeration, TModerationParams>('moderations', ParamProc);
end;

{ TFlaggedItem }

constructor TFlaggedItem.Create(const ACategory: THarmCategories;
  const AScore: Double);
begin
  FCategory := ACategory;
  FScore := AScore;
end;

end.

unit GenAI.Monitoring;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Generics.Collections, System.SyncObjs;

type
  /// <summary>
  /// Interface for monitoring request counts in a thread-safe manner.
  /// </summary>
  /// <remarks>
  /// This interface defines methods to increment and decrement a request counter,
  /// as well as a method to check if any requests are currently being processed.
  /// </remarks>
  IRequestMonitor = interface
    ['{4FE090AE-EC69-418A-8B1D-4DB6DB93ECA5}']
    /// <summary>
    /// Increments the request counter.
    /// </summary>
    /// <returns>
    /// The updated number of active requests.
    /// </returns>
    function Inc: Integer;
    /// <summary>
    /// Decrements the request counter.
    /// </summary>
    /// <returns>
    /// The updated number of active requests.
    /// </returns>
    function Dec: Integer;
    /// <summary>
    /// Checks if there are active requests being processed.
    /// </summary>
    /// <returns>
    /// <c>True</c> if there are active requests, otherwise <c>False</c>.
    /// </returns>
    function IsBusy: Boolean;
  end;

  /// <summary>
  /// Implements a thread-safe request monitor.
  /// </summary>
  /// <remarks>
  /// This class provides synchronized methods to track the number of active requests.
  /// It ensures thread safety using a critical section.
  /// </remarks>
  TRequestMonitor = class(TInterfacedObject, IRequestMonitor)
  private
    FLock: TCriticalSection;
    FCount: Integer;
  public
    constructor Create;
    destructor Destroy; override;
    /// <summary>
    /// Increments the request counter in a thread-safe manner.
    /// </summary>
    /// <returns>
    /// The updated number of active requests.
    /// </returns>
    function Inc: Integer;
    /// <summary>
    /// Decrements the request counter in a thread-safe manner.
    /// </summary>
    /// <returns>
    /// The updated number of active requests.
    /// </returns>
    function Dec: Integer;
    /// <summary>
    /// Checks if there are any active requests.
    /// </summary>
    /// <returns>
    /// <c>True</c> if there are active requests, otherwise <c>False</c>.
    /// </returns>
    function IsBusy: Boolean;
  end;

var
  Monitoring: IRequestMonitor;

implementation

{ TRequestMonitor }

constructor TRequestMonitor.Create;
begin
  inherited Create;
  FLock := TCriticalSection.Create;
  FCount := 0;
end;

function TRequestMonitor.Dec: Integer;
begin
  FLock.Enter;
  try
    if FCount > 0 then
      System.Dec(FCount);
    Result := FCount;
  finally
    FLock.Leave;
  end;
end;

destructor TRequestMonitor.Destroy;
begin
  FLock.Free;
  inherited;
end;

function TRequestMonitor.Inc: Integer;
begin
  FLock.Enter;
  try
    System.Inc(FCount);
    Result := FCount;
  finally
    FLock.Leave;
  end;
end;

function TRequestMonitor.IsBusy: Boolean;
begin
  FLock.Enter;
  try
    Result := FCount > 0;
  finally
    FLock.Leave;
  end;
end;

initialization
  Monitoring := TRequestMonitor.Create;
end.

unit GenAI.NetEncoding.Base64;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.NetEncoding, System.Net.Mime,
  GenAI.Consts;

  /// <summary>
  /// Retrieves the MIME type of the specified file based on its location.
  /// </summary>
  /// <param name="FileLocation">The full path to the file whose MIME type is to be resolved.</param>
  /// <returns>
  /// A string representing the MIME type of the file.
  /// If the file does not exist, an exception will be raised.
  /// </returns>
  /// <exception cref="Exception">
  /// Thrown if the specified file cannot be found at the provided location.
  /// </exception>
  /// <remarks>
  /// This method checks if the specified file exists and retrieves its MIME type
  /// using the <c>TMimeTypes.Default.GetFileInfo</c> method.
  /// Ensure the provided path is valid before calling this function.
  /// </remarks>
  function GetMimeType(const FileLocation: string): string;

  /// <summary>
  /// Validates a URL or file location and converts it into a Base64 data URI if appropriate.
  /// </summary>
  /// <param name="Value">
  /// The input string, which can either be a URL or a file path.
  /// </param>
  /// <returns>
  /// A string representing the validated URL or a Base64-encoded data URI for supported image files.
  /// </returns>
  /// <exception cref="Exception">
  /// Thrown in the following cases:
  /// <para>If the URL starts with "http:" (insecure connection).</para>
  /// <para>If the file MIME type is not among the supported image formats: "image/png", "image/jpeg", "image/gif", "image/webp".</para>
  /// <para>If the file does not exist at the specified location.</para>
  /// </exception>
  /// <remarks>
  /// This function performs the following actions:
  /// <para>Checks if the input starts with "https:" and returns it directly if valid.</para>
  /// <para>Throws an exception if the input starts with "http:" to enforce secure connections.</para>
  /// <para>If the input is a file path, resolves its MIME type and verifies if it is a supported image format.</para>
  /// <para>Encodes the file content as a Base64 data URI if it is a supported image.</para>
  /// </remarks>
  function GetUrlOrEncodeBase64(const Value: string): string;

  /// <summary>
  /// Converts a byte array into a Base64-encoded string.
  /// </summary>
  /// <param name="Value">
  /// A <c>TBytes</c> array containing the binary data to be encoded.
  /// </param>
  /// <returns>
  /// A <c>string</c> representing the Base64-encoded content of the byte array.
  /// </returns>
  /// <exception cref="Exception">
  /// Raised if the provided byte array is empty.
  /// </exception>
  /// <remarks>
  /// This function processes the provided byte array, converts it into a memory stream, and encodes the content as a Base64 string.
  /// Ensure the byte array contains data before calling this function.
  /// </remarks>
  function BytesToBase64(const Value: TBytes): string;

  /// <summary>
  /// Converts a byte array into a UTF-8 encoded string.
  /// </summary>
  /// <param name="Value">
  /// A <c>TBytes</c> array containing the binary data to be converted.
  /// </param>
  /// <returns>
  /// A <c>string</c> representing the UTF-8 encoded content of the byte array.
  /// </returns>
  /// <exception cref="Exception">
  /// Raised if the provided byte array is empty.
  /// </exception>
  /// <remarks>
  /// This function processes the provided byte array by writing it to a memory stream,
  /// then reads and converts the data into a string using UTF-8 encoding.
  /// Ensure the byte array contains data before calling this function.
  /// </remarks>
  function BytesToString(const Value: TBytes): string;

  /// <summary>
  /// Encodes the content of a file into a Base64-encoded string.
  /// </summary>
  /// <param name="FileLocation">The full path to the file that will be encoded.</param>
  /// <returns>A Base64-encoded string representing the content of the file.</returns>
  /// <exception cref="Exception">Thrown if the specified file does not exist at the provided location.</exception>
  /// <remarks>
  /// This method reads the file from the specified location and converts it to a Base64 string.
  /// It uses different encoding methods depending on the version of  the RTL.
  /// For RTL version 35.0 and later, it uses <c>TNetEncoding.Base64String.Encode</c>,
  /// and for earlier versions, it uses <c>TNetEncoding.Base64.Encode</c>.
  /// </remarks>
  function EncodeBase64(FileLocation : string) : string; overload;

  /// <summary>
  /// Encodes the content of a specified file into a Base64 string and retrieves its MIME type.
  /// </summary>
  /// <param name="FileLocation">
  /// The full path to the file that will be encoded. This path must be valid and the file must exist.
  /// </param>
  /// <param name="MimeType">
  /// Outputs the MIME type of the file as a string. This parameter is passed by reference and will be updated to reflect the MIME type of the file.
  /// </param>
  /// <returns>
  /// A string representing the Base64-encoded content of the file.
  /// </returns>
  /// <exception cref="System.Exception">
  /// Thrown if the specified file does not exist at the provided location.
  /// </exception>
  /// <remarks>
  /// This function first verifies the existence of the file specified by the path in the <paramref name="FileLocation"/>. If the file exists,
  /// it reads the file's contents into a stream and encodes it into a Base64 string. Simultaneously, it determines the file's MIME type
  /// using the built-in MIME type resolution functionality, updating the <paramref name="MimeType"/> parameter with the result.
  /// This function is useful for converting file data into a format suitable for data transmission or as a data URI.
  /// </remarks>
  function EncodeBase64(FileLocation : string; var MimeType: string) : string; overload;

  /// <summary>
  /// Encodes the content of a stream into a Base64-encoded string.
  /// </summary>
  /// <param name="Value">
  /// A <c>TStream</c> containing the data to be encoded.
  /// </param>
  /// <returns>
  /// A <c>WideString</c> representing the Base64-encoded content of the stream.
  /// </returns>
  /// <exception cref="Exception">
  /// Raised if an error occurs while reading from the stream or during encoding.
  /// </exception>
  /// <remarks>
  /// This function reads the content of the provided stream and converts it into a Base64-encoded string.
  /// Ensure that the stream is properly positioned and contains readable data before calling this function.
  /// For RTL version 35.0 and later, it uses <c>TNetEncoding.Base64String.Encode</c>.
  /// For earlier versions, it uses <c>TNetEncoding.Base64.Encode</c>.
  /// </remarks>
  function EncodeBase64(const Value: TStream): string; overload;

  /// <summary>
  /// Decodes a Base64-encoded string and writes the resulting binary data to a specified file.
  /// </summary>
  /// <param name="Base64Str">The Base64-encoded string to decode.</param>
  /// <param name="FileName">The full path and name of the file where the decoded data will be written.</param>
  /// <exception cref="Exception">
  /// Thrown if the Base64 string cannot be decoded or if there is an error writing to the specified file.
  /// </exception>
  procedure DecodeBase64ToFile(const Base64Str: string; const FileName: string);

  /// <summary>
  /// Decodes a Base64-encoded string and writes the resulting binary data to the provided stream.
  /// </summary>
  /// <param name="Base64Str">The Base64-encoded string to decode.</param>
  /// <param name="Stream">The stream where the decoded binary data will be written. The stream should be writable.</param>
  /// <exception cref="Exception">
  /// Thrown if the Base64 string cannot be decoded or if there is an error writing to the provided stream.
  /// </exception>
  /// <remarks>
  /// After decoding, the stream's position is reset to the beginning.
  /// Ensure that the stream is properly managed and freed after use to avoid memory leaks.
  /// </remarks>
  procedure DecodeBase64ToStream(const Base64Str: string; const Stream: TStream);
  /// <summary>
  /// Retrieves the size of the specified file in bytes.
  /// </summary>
  /// <param name="FileLocation">
  /// The full path to the file whose size is to be determined.
  /// </param>
  /// <returns>
  /// An <c>Int64</c> value representing the file size in bytes.
  /// </returns>
  /// <exception cref="Exception">
  /// Raised if the specified file cannot be accessed or does not exist at the provided location.
  /// </exception>
  /// <remarks>
  /// This function verifies the existence of the specified file and, if accessible, retrieves its size
  /// using the <c>TFile.GetSize</c> method. Ensure that the file path is valid and accessible
  /// before calling this function.
  /// </remarks>
  function FileSize(const FileLocation: string): Int64;

implementation

uses
  System.StrUtils, System.IOUtils;

function EncodeBase64(FileLocation : string): string;
begin
  if not FileExists(FileLocation) then
    raise Exception.CreateFmt('File not found : %s', [FileLocation]);

  var Stream := TMemoryStream.Create;
  var StreamOutput := TStringStream.Create('', TEncoding.UTF8);
  try
    Stream.LoadFromFile(FileLocation);
    Stream.Position := 0;
    {$IF RTLVersion >= 35.0}
    TNetEncoding.Base64String.Encode(Stream, StreamOutput);
    {$ELSE}
    TNetEncoding.Base64.Encode(Stream, StreamOutput);
    {$ENDIF}
    Result := StreamOutput.DataString;
  finally
    Stream.Free;
    StreamOutput.Free;
  end;
end;

function EncodeBase64(FileLocation : string; var MimeType: string) : string;
begin
  Result := EncodeBase64(FileLocation);
  MimeType := GetMimeType(FileLocation);
end;

function GetMimeType(const FileLocation: string): string;
begin
  if not FileExists(FileLocation) then
    raise Exception.CreateFmt('File not found: %s', [FileLocation]);

  var LKind: TMimeTypes.TKind;
  TMimeTypes.Default.GetFileInfo(FileLocation, Result, LKind);
  Result := Result.ToLower;

  {--- Ensure compatibility with current standards }
  if Result = 'audio/x-wav' then
      Result := 'audio/wav'
end;

function GetUrlOrEncodeBase64(const Value: string): string;
begin
  if Value.StartsWith('http') then
    Exit(Value);

  var MimeType := GetMimeType(Value);
  var AcceptedMimeType :=
        (IndexStr(MimeType, ImageTypeAccepted) > -1) or
        (IndexStr(MimeType, DocTypeAccepted) > -1);

  if not AcceptedMimeType then
    raise Exception.Create('Unsupported mime type');
  Result :=  Format('data:%s;base64,%s', [MimeType, EncodeBase64(Value)]);
end;

function BytesToBase64(const Value: TBytes): String;
begin
  if Length(Value) = 0 then
    raise Exception.Create('No data recieved.');
  var MemStream := TMemoryStream.Create;
  try
    MemStream.WriteBuffer(Value[0], Length(Value));
    MemStream.Position := 0;
    Result := EncodeBase64(MemStream);
  finally
    MemStream.Free;
  end;
end;

function BytesToString(const Value: TBytes): string;
begin
  if Length(Value) = 0 then
    raise Exception.Create('BytesToString is empty.');
  var MemStream := TMemoryStream.Create;
  try
    MemStream.WriteBuffer(Value[0], Length(Value));
    MemStream.Position := 0;
    var Reader := TStreamReader.Create(MemStream, TEncoding.UTF8);
    try
      Result := Reader.ReadToEnd;
    finally
      Reader.Free;
    end;
  finally
    MemStream.Free;
  end;
end;

function EncodeBase64(const Value: TStream): string; overload;
begin
  var Stream := TMemoryStream.Create;
  var StreamOutput := TStringStream.Create('', TEncoding.UTF8);
  try
    Stream.LoadFromStream(Value);
    Stream.Position := 0;
    {$IF RTLVersion >= 35.0}
    TNetEncoding.Base64String.Encode(Stream, StreamOutput);
    {$ELSE}
    TNetEncoding.Base64.Encode(Stream, StreamOutput);
    {$ENDIF}
    Result := StreamOutput.DataString;
  finally
    Stream.Free;
    StreamOutput.Free;
  end;
end;

procedure DecodeBase64ToFile(const Base64Str: string; const FileName: string);
begin
  {--- Convert Base64 string to byte array for input stream }
  var Bytes := TEncoding.UTF8.GetBytes(Base64Str);

  {--- Create the flows }
  var InputStream := TBytesStream.Create(Bytes);
  var OutputStream := TFileStream.Create(FileName, fmCreate);
  try
    {--- Decode using TNetEncoding.Base64.Decode (stream) }
    TNetEncoding.Base64.Decode(InputStream, OutputStream);
  finally
    InputStream.Free;
    OutputStream.Free;
  end;
end;

procedure DecodeBase64ToStream(const Base64Str: string; const Stream: TStream);
begin
  {--- Converts the base64 string directly into the memory stream }
  var InputStream := TBytesStream.Create(TEncoding.UTF8.GetBytes(Base64Str));
    try
      TNetEncoding.Base64.Decode(InputStream, Stream);
      Stream.Position := 0;
    finally
      InputStream.Free;
    end;
end;

function FileSize(const FileLocation: string): Int64;
begin
  try
    FileSize := TFile.GetSize(FileLocation);
  except
    raise;
  end;
end;

end.

unit GenAI;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

(*

   This Delphi project relies on several key dependencies that cover network functionality,
   JSON handling,  serialization,  asynchronous operations,  and error management. Here are
   the main categories of dependencies:

     1. Standard Delphi Dependencies:

   Utilizes  native libraries such as  System.Classes,  System.SysUtils,  System.JSON,  and
   System.Net.HttpClient for general operations, input/output, date management, and network
   communications.

     2. JSON and REST:

   Uses units like REST.Json.Types,  REST.Json.Interceptors, and REST.JsonReflect to handle
   object serialization/deserialization and REST API calls.

     3. Custom Exception and Error Handling:

   Internal modules GenAI.Exceptions and GenAI.Errors capture and propagate errors specific
   to the API.

     4. Custom GenAI API Modules:

   Custom modules like GenAI.API, GenAI.API.Params,  and GenAI.HttpClientInterface are used
   to build HTTP requests to the GenAI API and handle asynchronous responses.

     5. Multithreading and Asynchronous Operations:

   Utilizes System.Threading  and internal classes  (such as TAsynCallBack)  to handle long
   running tasks and avoid blocking the main thread.

     6. Testing Dependencies:

   Uses  DUnitX.TestFramework and  related  modules to implement  unit tests  and  validate
   critical project functionality.

   This  project is structured to be modular and extensible, with  abstractions that  allow
   for  easily switching  network  libraries  or  adding  new  features  while  maintaining
   robustness and testability.

*)

interface

uses
  System.SysUtils, System.Classes, System.JSON,
  GenAI.API, GenAI.API.Params, GenAI.Types, GenAI.API.Deletion, GenAI.Models,
  GenAI.Functions.Core, GenAI.Batch.Interfaces, GenAI.Schema, GenAI.Embeddings,
  GenAI.Audio, GenAI.Chat, GenAI.Moderation, GenAI.Images, GenAI.Files, GenAI.Uploads,
  GenAI.Batch, GenAI.Batch.Reader, GenAI.Batch.Builder, GenAI.Completions, GenAI.FineTuning,
  GenAI.Assistants, GenAI.Threads, GenAI.Messages, GenAI.Runs, GenAI.RunSteps,
  GenAI.Vector, GenAI.VectorFiles, GenAI.VectorBatch, GenAI.Monitoring, GenAI.Chat.Parallel,
  GenAI.Responses, GenAI.Responses.InputParams, GenAI.Responses.InputItemList;

type
  /// <summary>
  /// The IGenAI interface provides access to the various features and routes of the Open AI API.
  /// This interface allows interaction with different services such as agents, chat, code completion,
  /// embeddings, file management, fine-tuning, and model information.
  /// </summary>
  /// <remarks>
  /// This interface should be implemented by any class that wants to provide a structured way of accessing
  /// the Open AI services. It includes methods and properties for authenticating with an API key,
  /// configuring the base URL, and accessing different API routes.
  /// </remarks>
  IGenAI = interface
    ['{4A1E56DB-67B7-4553-957E-4324C5BFC983}']
    function GetAPI: TGenAIAPI;
    function GetAPIKey: string;
    procedure SetAPIKey(const Value: string);
    function GetBaseUrl: string;
    procedure SetBaseUrl(const Value: string);

    function GetAssistantsRoute: TAssistantsRoute;
    function GetAudioRoute: TAudioRoute;
    function GetBatchRoute: TBatchRoute;
    function GetChatRoute: TChatRoute;
    function GetCompletionRoute: TCompletionRoute;
    function GetEmbeddingsRoute: TEmbeddingsRoute;
    function GetFilesRoute: TFilesRoute;
    function GetFineTuningRoute: TFineTuningRoute;
    function GetImagesRoute: TImagesRoute;
    function GetMesssagesRoute: TMessagesRoute;
    function GetModelsRoute: TModelsRoute;
    function GetModerationRoute: TModerationRoute;
    function GetRunsRoute: TRunsRoute;
    function GetRunStepRoute: TRunStepRoute;
    function GetThreadsRoute: TThreadsRoute;
    function GetUploadsRoute: TUploadsRoute;
    function GetVectorStoreRoute: TVectorStoreRoute;
    function GetVectorStoreBatchRoute: TVectorStoreBatchRoute;
    function GetVectorStoreFilesRoute: TVectorStoreFilesRoute;
    function GetResponses: TResponsesRoute;

    /// <summary>
    /// Represents the API route handler for managing assistants.
    /// </summary>
    /// <remarks>
    /// This class provides methods to create, retrieve, update, list, and delete assistants
    /// using the OpenAI API. It extends <c>TGenAIRoute</c> to handle API interactions and
    /// custom headers.
    /// </remarks>
    property Assistants: TAssistantsRoute read GetAssistantsRoute;
    /// <summary>
    /// Provides routes to handle audio-related requests including speech generation, transcription, and translation.
    /// </summary>
    /// <remarks>
    /// This class offers a set of methods to interact with OpenAI's API for generating speech from text,
    /// transcribing audio into text, and translating audio into English. It supports both synchronous and asynchronous
    /// operations to accommodate different application needs.
    /// </remarks>
    property Audio: TAudioRoute read GetAudioRoute;
    /// <summary>
    /// Provides routes for managing batches within the OpenAI API.
    /// This class offers methods to create, retrieve, cancel, and list batches, facilitating the orchestration of batch operations.
    /// It is designed to support both synchronous and asynchronous execution of these operations, enhancing flexibility and efficiency
    /// in application workflows.
    /// </summary>
    property Batch: TBatchRoute read GetBatchRoute;
    /// <summary>
    /// Handles the routing and execution of chat-related API requests within the application,
    /// facilitating interaction with AI models for generating chat completions.
    /// </summary>
    /// <remarks>
    /// TChatRoute is designed to manage chat interaction requests and responses, providing
    /// methods for both synchronous and asynchronous operations. This class plays a pivotal
    /// role in integrating and managing the AI-driven chat functionalities within diverse
    /// software architectures.
    /// </remarks>
    property Chat: TChatRoute read GetChatRoute;
    /// <summary>
    /// Manages the routes for creating and streaming completions using the OpenAI API.
    /// This class handles both synchronous and asynchronous operations to interact with the API
    /// for generating text completions.
    /// </summary>
    property Completion: TCompletionRoute read GetCompletionRoute;
    /// <summary>
    /// Provides routes for creating embeddings via the OpenAI API.
    /// </summary>
    /// <remarks>
    /// This class offers methods to asynchronously or synchronously create embeddings based on the parameters
    /// provided by the caller. It utilizes TGenAIRoute as a base to inherit API communication capabilities.
    /// </remarks>
    property Embeddings: TEmbeddingsRoute read GetEmbeddingsRoute;
    /// <summary>
    /// Represents a route for managing file operations in the API.
    /// </summary>
    /// <remarks>
    /// This class provides methods for performing file-related operations, including uploading files,
    /// listing files, retrieving specific file details or content, and deleting files.
    /// It supports both synchronous and asynchronous operations for efficient file management.
    /// </remarks>
    property Files: TFilesRoute read GetFilesRoute;
    /// <summary>
    /// Provides methods to interact with the OpenAI fine-tuning API routes.
    /// </summary>
    /// <remarks>
    /// This class includes methods for creating, retrieving, listing, canceling, and managing fine-tuning jobs,
    /// as well as accessing associated events and checkpoints.
    /// </remarks>
    property FineTuning: TFineTuningRoute read GetFineTuningRoute;
    /// <summary>
    /// Represents the route handler for image-related operations using the OpenAI API.
    /// </summary>
    /// <remarks>
    /// This class provides methods for creating, editing, and generating variations of images.
    /// It supports both synchronous and asynchronous operations, making it suitable for
    /// diverse use cases involving image generation and manipulation.
    /// </remarks>
    property Images: TImagesRoute read GetImagesRoute;
    /// <summary>
    /// Manages the API routes for handling messages within a thread in the OpenAI API.
    /// </summary>
    /// <remarks>
    /// This class provides methods to create, retrieve, update, delete, and list messages
    /// within a thread. It also supports asynchronous operations for non-blocking message handling.
    /// </remarks>
    property Messages : TMessagesRoute read GetMesssagesRoute;
    /// <summary>
    /// Provides routes for managing model data via API calls, including listing, retrieving, and deleting models.
    /// </summary>
    /// <remarks>
    /// The TModelsRoute class includes methods that facilitate asynchronous and synchronous operations
    /// to list, delete, and retrieve OpenAI models through the API. It acts as a controller for the
    /// interaction with the OpenAI model endpoints.
    /// </remarks>
    property Models: TModelsRoute read GetModelsRoute;
    /// <summary>
    /// Represents a route for handling moderation requests in the GenAI framework.
    /// This class provides methods for evaluating moderation parameters both
    /// synchronously and asynchronously.
    /// </summary>
    /// <remarks>
    /// This class is designed to manage moderation requests by interfacing with
    /// the GenAI API. It supports both synchronous and asynchronous operations
    /// for evaluating content against moderation models.
    /// </remarks>
    property Moderation: TModerationRoute read GetModerationRoute;
    /// <summary>
    /// Represents the route for managing execution runs in the OpenAI API.
    /// </summary>
    /// <remarks>
    /// This class provides methods to create, retrieve, update, list, and manage execution runs on threads.
    /// It handles both synchronous and asynchronous requests, allowing efficient interaction with the OpenAI API for execution management.
    /// </remarks>
    property Runs: TRunsRoute read GetRunsRoute;
    /// <summary>
    /// Represents the route for managing run steps within execution runs in the OpenAI API.
    /// </summary>
    /// <remarks>
    /// This class provides methods to list or retrieve details of run steps. It handles both synchronous
    /// and asynchronous requests, enabling efficient interaction with the OpenAI API for managing run steps.
    /// </remarks>
    property RunStep: TRunStepRoute read GetRunStepRoute;
    /// <summary>
    /// Provides an interface for interacting with OpenAI threads via API routes.
    /// This class supports both synchronous and asynchronous operations, including creating, retrieving, modifying, and deleting threads.
    /// </summary>
    /// <remarks>
    /// <para>
    /// The class encapsulates API requests and manages the associated headers, routes, and callbacks required
    /// for interacting with the OpenAI API. Developers can use it to perform thread-related tasks while leveraging
    /// both synchronous and non-blocking (asynchronous) execution flows.
    /// </para>
    /// <para>
    /// The tool resources associated with threads, such as files and vector stores, can be specified to enhance
    /// assistant capabilities like code execution or vector-based searches. Metadata can also be attached
    /// to threads for storing structured information.
    /// </para>
    /// </remarks>
    property Threads: TThreadsRoute read GetThreadsRoute;
    /// <summary>
    /// Manages routes for handling file uploads, including creating uploads, adding parts, completing uploads, and canceling uploads.
    /// </summary>
    /// <remarks>
    /// This class provides methods to interact with the upload API endpoints. It supports asynchronous and synchronous
    /// operations for creating an upload, adding parts to it, completing the upload, and canceling an upload.
    /// </remarks>
    property Uploads: TUploadsRoute read GetUploadsRoute;
    /// <summary>
    /// Provides methods to manage vector stores in the OpenAI API.
    /// </summary>
    /// <remarks>
    /// The <c>TVectorStoreRoute</c> class allows you to create, retrieve, update, list, and delete
    /// vector stores through various API endpoints. It supports both synchronous and asynchronous
    /// operations, making it flexible for different application needs.
    /// </remarks>
    property VectorStore: TVectorStoreRoute read GetVectorStoreRoute;
    /// <summary>
    /// Provides methods to manage file batches within a vector store using the OpenAI API.
    /// </summary>
    /// <remarks>
    /// This class allows users to create, retrieve, cancel, and list file batches associated
    /// with a specific vector store. It supports both synchronous and asynchronous operations,
    /// enabling flexible interaction with the API for managing batch processing.
    /// </remarks>
    property VectorStoreBatch: TVectorStoreBatchRoute read GetVectorStoreBatchRoute;
    /// <summary>
    /// Provides methods to manage files within a vector store using the OpenAI API.
    /// </summary>
    /// <remarks>
    /// The <c>TVectorStoreFilesRoute</c> class allows users to create, retrieve, list, and delete
    /// files associated with a vector store. It supports both synchronous and asynchronous
    /// operations, enabling flexible interaction with the API for managing file storage and processing.
    /// </remarks>
    property VectorStoreFiles: TVectorStoreFilesRoute read GetVectorStoreFilesRoute;

    property Responses: TResponsesRoute read GetResponses;

    /// <summary>
    /// the main API object used for making requests.
    /// </summary>
    /// <returns>
    /// An instance of TGenAIAPI for making API calls.
    /// </returns>
    property API: TGenAIAPI read GetAPI;
    /// Sets or retrieves the API API key for authentication.
    /// </summary>
    /// <param name="Value">
    /// The API key as a string.
    /// </param>
    /// <returns>
    /// The current API key.
    /// </returns>
    property APIKey: string read GetAPIKey write SetAPIKey;
    /// <summary>
    /// Sets or retrieves the base URL for API requests.
    /// Default is https://api.openai.com/v1.
    /// </summary>
    /// <param name="Value">
    /// The base URL as a string.
    /// </param>
    /// <returns>
    /// The current base URL.
    /// </returns>
    property BaseURL: string read GetBaseUrl write SetBaseUrl;
    /// <summary>
    /// Provides access to agent completion API.
    /// An AI agent is an autonomous system using large language models (LLM) to perform tasks based on high-level instructions.
    /// </summary>
    /// <returns>
    /// An instance of TAgentRoute for agent-related operations.
    /// </returns>
  end;

  TGenAIFactory = class
    class function CreateInstance(const AAPIKey: string): IGenAI;
  end;

  /// <summary>
  /// The TGenAI class provides access to the various features and routes of the Open AI API.
  /// This class allows interaction with different services such as agents, chat, code completion,
  /// embeddings, file management, fine-tuning, and model information.
  /// </summary>
  /// <remarks>
  /// This class should be implemented by any class that wants to provide a structured way of accessing
  /// the Open AI services. It includes methods and properties for authenticating with an API key,
  /// configuring the base URL, and accessing different API routes.
  /// </remarks>
  TGenAI = class(TInterfacedObject, IGenAI)
  private
    FAPI: TGenAIAPI;

    FAssistantsRoute: TAssistantsRoute;
    FAudioRoute: TAudioRoute;
    FBatchRoute: TBatchRoute;
    FChatRoute: TChatRoute;
    FCompletionRoute: TCompletionRoute;
    FEmbeddingsRoute: TEmbeddingsRoute;
    FFilesRoute: TFilesRoute;
    FFineTuningRoute: TFineTuningRoute;
    FImagesRoute: TImagesRoute;
    FMessagesRoute: TMessagesRoute;
    FModelsRoute: TModelsRoute;
    FModerationRoute: TModerationRoute;
    FRunsRoute: TRunsRoute;
    FRunStepRoute: TRunStepRoute;
    FThreadsRoute: TThreadsRoute;
    FUploadsRoute: TUploadsRoute;
    FVectorStoreRoute: TVectorStoreRoute;
    FVectorStoreBatchRoute: TVectorStoreBatchRoute;
    FVectorStoreFilesRoute: TVectorStoreFilesRoute;
    FResponsesRoute: TResponsesRoute;

    function GetAPI: TGenAIAPI;
    function GetAPIKey: string;
    procedure SetAPIKey(const Value: string);
    function GetBaseUrl: string;
    procedure SetBaseUrl(const Value: string);

    function GetAssistantsRoute: TAssistantsRoute;
    function GetAudioRoute: TAudioRoute;
    function GetBatchRoute: TBatchRoute;
    function GetChatRoute: TChatRoute;
    function GetCompletionRoute: TCompletionRoute;
    function GetEmbeddingsRoute: TEmbeddingsRoute;
    function GetFilesRoute: TFilesRoute;
    function GetFineTuningRoute: TFineTuningRoute;
    function GetImagesRoute: TImagesRoute;
    function GetMesssagesRoute: TMessagesRoute;
    function GetModelsRoute: TModelsRoute;
    function GetModerationRoute: TModerationRoute;
    function GetRunsRoute: TRunsRoute;
    function GetRunStepRoute: TRunStepRoute;
    function GetThreadsRoute: TThreadsRoute;
    function GetUploadsRoute: TUploadsRoute;
    function GetVectorStoreRoute: TVectorStoreRoute;
    function GetVectorStoreBatchRoute: TVectorStoreBatchRoute;
    function GetVectorStoreFilesRoute: TVectorStoreFilesRoute;
    function GetResponses: TResponsesRoute;

  public
    /// <summary>
    /// the main API object used for making requests.
    /// </summary>
    /// <returns>
    /// An instance of TGenAIAPI for making API calls.
    /// </returns>
    property API: TGenAIAPI read GetAPI;
    /// <summary>
    /// Sets or retrieves the API key for authentication.
    /// </summary>
    /// <param name="Value">
    /// The API key as a string.
    /// </param>
    /// <returns>
    /// The current API key.
    /// </returns>
    property APIKey: string read GetAPIKey write SetAPIKey;
    /// <summary>
    /// Sets or retrieves the base URL for API requests.
    /// Default is https://api.openai.com/v1.
    /// </summary>
    /// <param name="Value">
    /// The base URL as a string.
    /// </param>
    /// <returns>
    /// The current base URL.
    /// </returns>
    property BaseURL: string read GetBaseUrl write SetBaseUrl;
  public
    constructor Create; overload;
    constructor Create(const AAPIKey: string); overload;
    destructor Destroy; override;
  end;

  {$REGION 'GenAI.API'}

  /// <summary>
  /// Manages and processes errors from the GenAI API responses.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TApiHttpHandler</c> and provides error-handling capabilities
  /// by parsing error data and raising appropriate exceptions.
  /// </remarks>
  TApiDeserializer = GenAI.API.TApiDeserializer;

  {$ENDREGION}

  {$REGION 'GenAI.API.Params'}

  /// <summary>
  /// Represents the parameters for listing.
  /// This class provides the functionality to control pagination and set limits on the number of objects retrieved.
  /// It is useful for efficiently managing and navigating through large sets of objects.
  /// </summary>
  TUrlPaginationParams = GenAI.API.Params.TUrlPaginationParams;

  /// <summary>
  /// Represents the advanced parameters for listing and filtering data.
  /// This class extends <see cref="TUrlPaginationParams"/> to provide additional functionality for
  /// sorting and navigating through paginated data.
  /// It is designed to manage more complex scenarios where both pagination and sorting are required.
  /// </summary>
  TUrlAdvancedParams = GenAI.API.Params.TUrlAdvancedParams;

  /// <summary>
  /// Represents a utility class for managing URL parameters and constructing query strings.
  /// </summary>
  /// <remarks>
  /// This class allows the addition of key-value pairs to construct a query string,
  /// which can be appended to a URL for HTTP requests. It provides overloads for adding
  /// various types of values, including strings, integers, booleans, doubles, and arrays.
  /// </remarks>
  TUrlParam = GenAI.API.Params.TUrlParam;

  /// <summary>
  /// Represents a utility class for managing JSON objects and constructing JSON structures dynamically.
  /// </summary>
  /// <remarks>
  /// This class provides methods to add, remove, and manipulate key-value pairs in a JSON object.
  /// It supports various data types, including strings, integers, booleans, dates, arrays, and nested JSON objects.
  /// </remarks>
  TJSONParam = GenAI.API.Params.TJSONParam;

  /// <summary>
  /// Represents a base class for all classes obtained after deserialization.
  /// </summary>
  /// <remarks>
  /// This class is designed to store the raw JSON string returned by the API,
  /// allowing applications to access the original JSON response if needed.
  /// </remarks>
  TJSONFingerprint = GenAI.API.Params.TJSONFingerprint;

  /// <summary>
  /// A custom JSON interceptor for handling string-to-string conversions in JSON serialization and deserialization.
  /// </summary>
  /// <remarks>
  /// This interceptor is designed to override the default behavior of JSON serialization
  /// and deserialization for string values, ensuring compatibility with specific formats
  /// or custom requirements.
  /// </remarks>
  TJSONInterceptorStringToString = GenAI.API.Params.TJSONInterceptorStringToString;

  /// <summary>
  /// Represents a generic key-value parameter manager.
  /// </summary>
  /// <remarks>
  /// This class allows storing and retrieving various types of parameters as key-value pairs.
  /// It supports basic types (integers, strings, booleans, floating-point numbers), objects,
  /// as well as arrays of these types.
  /// </remarks>
  /// <example>
  ///   <code>
  ///     var Params: TParameters;
  ///     begin
  ///       Params := TParameters.Create;
  ///       Params.Add('Limit', 100)
  ///             .Add('Order', 'Asc')
  ///             .Add('IsEnabled', True);
  ///       if Params.Exists('Limit') then
  ///         ShowMessage(IntToStr(Params.GetInteger('Limit')));
  ///       Params.Free;
  ///     end;
  ///   </code>
  /// </example>
  TParameters = GenAI.API.Params.TParameters;

  {$ENDREGION}

  {$REGION 'GenAI.API.Deletion'}

  /// <summary>
  /// Represents a deletion response, providing details about the identifier, object type,
  /// and whether the deletion was successful.
  /// </summary>
  /// <remarks>
  /// This class is primarily used to store the result of a deletion request, including
  /// the unique ID of the deleted object, the type of the object, and a status indicating
  /// whether the deletion was completed successfully.
  /// </remarks>
  TDeletion = GenAI.API.Deletion.TDeletion;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TDeletion</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynDeletion</c> type extends the <c>TAsynParams&lt;TDeletion&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynDeletion = GenAI.API.Deletion.TAsynDeletion;

  {$ENDREGION}

  {$REGION 'GenAI.Functions.Core'}

  /// <summary>
  /// Interface defining the core structure and functionality of a function in the system.
  /// </summary>
  /// <remarks>
  /// This interface outlines the basic properties and methods that any function implementation must include.
  /// </remarks>
  IFunctionCore = GenAI.Functions.Core.IFunctionCore;

  {$ENDREGION}

  {$REGION 'GenAI.Schema'}

  /// <summary>
  /// Provides helper methods for creating property items in OpenAPI schema definitions.
  /// </summary>
  /// <remarks>
  /// This record simplifies the creation of property entries when building schema objects,
  /// particularly for object properties in OpenAPI specifications.
  /// </remarks>
  TPropertyItem = GenAI.Schema.TPropertyItem;

  /// <summary>
  /// Represents the Schema Object in OpenAPI, enabling the definition of input and output data types.
  /// These types can be objects, primitives, or arrays. This class provides methods to build and
  /// configure schema definitions as per the OpenAPI 3.0 Specification.
  /// </summary>
  /// <remarks>
  /// The Schema Object allows the definition of input and output data types in the OpenAPI Specification.
  /// This class provides a fluent interface to construct schema definitions programmatically.
  /// </remarks>
  TSchemaParams = GenAI.Schema.TSchemaParams;

  {$ENDREGION}

  {$REGION 'GenAI.Audio'}

  /// <summary>
  /// Represents the parameters required to generate speech from text using the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class encapsulates the settings that can be configured for the speech synthesis request,
  /// including the model to use, the text input, the voice type, the response format, and the speed of speech.
  /// </remarks>
  TSpeechParams = GenAI.Audio.TSpeechParams;

  /// <summary>
  /// Represents the result of a speech synthesis request.
  /// </summary>
  /// <remarks>
  /// This class handles the response from the OpenAI API after a speech generation request,
  /// providing methods to access the generated audio content either as a stream or by saving it to a file.
  /// </remarks>
  TSpeechResult = GenAI.Audio.TSpeechResult;

  /// <summary>
  /// Represents the parameters required for transcribing audio into text using the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class encapsulates the settings that can be configured for the audio transcription request,
  /// such as the audio file, model to use, language of the audio, optional prompt, response format, and transcription temperature.
  /// </remarks>
  TTranscriptionParams = GenAI.Audio.TTranscriptionParams;

  /// <summary>
  /// Represents a single word from the transcription result with its corresponding timestamps.
  /// </summary>
  /// <remarks>
  /// This class provides detailed information about the timing of each word in the transcribed text,
  /// including the start and end times, which are useful for applications requiring precise synchronization
  /// between the audio and its transcription.
  /// </remarks>
  TTranscriptionWord = GenAI.Audio.TTranscriptionWord;

  /// <summary>
  /// Represents a segment of the transcription, providing details such as segment text and its corresponding timing.
  /// </summary>
  /// <remarks>
  /// This class details each segment of the transcribed audio, offering a deeper level of granularity for applications
  /// that need to break down the transcription into smaller pieces for analysis or display.
  /// </remarks>
  TTranscriptionSegment = GenAI.Audio.TTranscriptionSegment;

  /// <summary>
  /// Represents the full transcription result returned by the OpenAI audio transcription API.
  /// </summary>
  /// <remarks>
  /// This class encapsulates the complete transcription of an audio file, including the language,
  /// duration, and detailed segments and words with their corresponding timestamps.
  /// It serves as a comprehensive container for all the transcription details necessary for further processing
  /// or analysis in applications.
  /// </remarks>
  TTranscription = GenAI.Audio.TTranscription;

  /// <summary>
  /// Represents the parameters required for translating audio into English using the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class encapsulates settings for audio translation requests, including the audio file,
  /// the translation model, optional guiding prompt, response format, and translation temperature.
  /// </remarks>
  TTranslationParams = GenAI.Audio.TTranslationParams;

  /// <summary>
  /// Represents the translation result returned by the OpenAI audio translation API.
  /// </summary>
  /// <remarks>
  /// This class encapsulates the result of translating audio into English, containing the translated text.
  /// It is used to provide a straightforward interface to access the textual translation of spoken content.
  /// </remarks>
  TTranslation = GenAI.Audio.TTranslation;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TSpeechResult</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynSpeechResult</c> type extends the <c>TAsynParams&lt;TSpeechResult&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynSpeechResult = GenAI.Audio.TAsynSpeechResult;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TTranscription</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynTranscription</c> type extends the <c>TAsynParams&lt;TTranscription&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynTranscription = GenAI.Audio.TAsynTranscription;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TTranslation</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynTranslation</c> type extends the <c>TAsynParams&lt;TTranslation&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynTranslation = GenAI.Audio.TAsynTranslation;

  {$ENDREGION}

  {$REGION 'GenAI.Embeddings'}

  /// <summary>
  /// Represents the parameters required to create embeddings using the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class provides methods to specify different parameters for generating embeddings.
  /// The input can be a single string or an array of strings. You can also specify the model,
  /// encoding format, dimensions, and a user identifier. These parameters are used to configure
  /// the request to the OpenAI API to obtain embeddings that can be consumed by machine learning
  /// models and algorithms.
  /// </remarks>
  TEmbeddingsParams = GenAI.Embeddings.TEmbeddingsParams;

  /// <summary>
  /// Represents a single embedding vector returned by the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class encapsulates the details of an embedding, including its index in the list of returned embeddings,
  /// the embedding vector itself, and the object type. It inherits from TJSONFingerprint to utilize JSON serialization
  /// capabilities.
  /// </remarks>
  TEmbedding = GenAI.Embeddings.TEmbedding;

  /// <summary>
  /// Represents a collection of embedding vectors returned by the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class holds a list of TEmbedding objects, each representing an individual embedding vector.
  /// It includes methods for managing the lifecycle of these objects, including destruction. The class
  /// also inherits from TJSONFingerprint to leverage JSON serialization capabilities.
  /// </remarks>
  TEmbeddings = GenAI.Embeddings.TEmbeddings;

  /// <summary>
  /// Manages asynchronous callBacks a request using <c>TEmbeddings</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynEmbeddings</c> type extends the <c>TAsynParams&lt;TEmbeddings&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynEmbeddings = GenAI.Embeddings.TAsynEmbeddings;

  {$ENDREGION}

  {$REGION 'GenAI.Models'}

  /// <summary>
  /// Represents an OpenAI model, encapsulating key information about a specific API model.
  /// </summary>
  /// <remarks>
  /// The TModel class stores attributes such as the unique identifier, creation timestamp,
  /// object type, and ownership details of the model. This class is typically used to handle
  /// and manipulate data related to models provided by OpenAI's API.
  /// </remarks>
  TModel = GenAI.Models.TModel;

  /// <summary>
  /// Represents a collection of OpenAI models, providing a list structure for managing multiple model instances.
  /// </summary>
  /// <remarks>
  /// The TModels class encapsulates a list of TModel objects, each representing detailed information about
  /// individual models. This collection is useful for operations that require handling multiple models,
  /// such as listing all available models from the OpenAI API.
  /// </remarks>
  TModels = GenAI.Models.TModels;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TModel</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynModel</c> type extends the <c>TAsynParams&lt;TModel&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynModel = GenAI.Models.TAsynModel;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TModels</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynModels</c> type extends the <c>TAsynParams&lt;TModels&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynModels = GenAI.Models.TAsynModels;

  {$ENDREGION}

  {$REGION 'GenAI.Chat'}

  /// <summary>
  /// Represents an image URL parameter for a JSON object, allowing the configuration
  /// of URLs or base64 encoded images with optional detail settings.
  /// </summary>
  /// <remarks>
  /// This class provides methods to set the URL and detail level for images that
  /// are to be included as part of JSON requests. It can handle both direct URLs
  /// and base64-encoded image data. The detail level can specify how much information
  /// the image should convey, which can influence processing or display in APIs
  /// consuming these URLs.
  /// </remarks>
  TImageUrl = GenAI.Chat.TImageUrl;

  /// <summary>
  /// Represents an audio input parameter for a JSON object, allowing the configuration
  /// of audio data and format.
  /// </summary>
  /// <remarks>
  /// This class provides methods to set the base64-encoded audio data and its format
  /// for use in JSON requests. The format specifies how the audio data is encoded,
  /// such as 'mp3' or 'wav', which is crucial for correct processing by APIs consuming
  /// this data.
  /// </remarks>
  TInputAudio = GenAI.Chat.TInputAudio;

  /// <summary>
  /// Manages content parameters for different types of inputs like text, images,
  /// and audio within a JSON structure.
  /// </summary>
  /// <remarks>
  /// This class serves as a utility to add various types of content to JSON requests.
  /// It supports handling text content, URLs for images, and base64-encoded audio data.
  /// Each method facilitates the inclusion of these content types into JSON objects
  /// with appropriate formatting and structure.
  /// </remarks>
  TContentParams = GenAI.Chat.TContentParams;

  /// <summary>
  /// Manages function parameters for API requests, allowing the setting of a function's
  /// name and its JSON-formatted arguments.
  /// </summary>
  /// <remarks>
  /// This class facilitates the construction of parameter objects for functions within
  /// JSON requests. It supports specifying the function name and its arguments in a
  /// structured format, ensuring that the function can be called correctly with the
  /// provided parameters.
  /// </remarks>
  TFunctionParams = GenAI.Chat.TFunctionParams;

  /// <summary>
  /// Manages the parameters for tool calls within a JSON structure, facilitating the integration
  /// of tool functionality such as functions or specific actions within an API request.
  /// </summary>
  /// <remarks>
  /// This class allows for specifying the ID, type, and function details for tools that are to be
  /// called within an API request. It ensures that tool interactions are well-defined and correctly
  /// structured to perform expected operations.
  /// </remarks>
  TToolCallsParams = GenAI.Chat.TToolCallsParams;

  /// <summary>
  /// Manages the content parameters for assistant messages, facilitating the integration
  /// of text or refusal content within a JSON structure for virtual assistants.
  /// </summary>
  /// <remarks>
  /// This class provides methods to set text content or a refusal message in responses
  /// generated by an assistant. It allows for precise control over the content delivered
  /// by the assistant, ensuring that responses are appropriate and well-structured.
  /// </remarks>
  TAssistantContentParams = GenAI.Chat.TAssistantContentParams;

  /// <summary>
  /// Represents a message payload within a JSON-based messaging API, facilitating
  /// the structuring of communication between different roles such as user, assistant,
  /// and system.
  /// </summary>
  /// <remarks>
  /// This class provides a flexible framework for constructing message payloads with
  /// various content types and metadata, supporting diverse interactions within a
  /// chat or command-based environment.
  /// </remarks>
  TMessagePayload = GenAI.Chat.TMessagePayload;

  /// <summary>
  /// Manages the configuration of predicted content parts in JSON parameters, useful for
  /// specifying predefined outputs to optimize response generation.
  /// </summary>
  /// <remarks>
  /// This class enables the detailed specification of static or predictable content
  /// that can be used to facilitate more efficient processing when parts of the
  /// response are known in advance. This is especially beneficial in scenarios
  /// where response times are critical and part of the output is predetermined.
  /// </remarks>
  TPredictionPartParams = GenAI.Chat.TPredictionPartParams;

  /// <summary>
  /// Manages the configuration of prediction parameters for JSON requests, specifically
  /// designed to optimize model response generation by including expected content.
  /// </summary>
  /// <remarks>
  /// This class facilitates the integration of predictable or static content within
  /// JSON structured requests to optimize processing efficiencies and response accuracies
  /// in scenarios where certain outputs are known beforehand.
  /// </remarks>
  TPredictionParams = GenAI.Chat.TPredictionParams;

  /// <summary>
  /// Configures audio parameters within JSON requests to manage voice and format
  /// specifications for audio generation.
  /// </summary>
  /// <remarks>
  /// This class is designed to detail the audio output settings, such as voice type
  /// and audio format, to tailor the audio responses generated by models or APIs.
  /// </remarks>
  TAudioParams = GenAI.Chat.TAudioParams;

  /// <summary>
  /// Provides a means to specify a particular function that should be called by
  /// the tool choice mechanism within JSON requests.
  /// </summary>
  /// <remarks>
  /// This class is crucial for specifying which specific function should be executed,
  /// particularly in scenarios involving dynamic or automated decision-making processes
  /// where a specific operational function is needed.
  /// </remarks>
  TToolChoiceFunctionParams = GenAI.Chat.TToolChoiceFunctionParams;

  /// <summary>
  /// Handles the configuration for tool choice parameters, enabling specific function
  /// calls within JSON structured requests.
  /// </summary>
  /// <remarks>
  /// This class is designed to specify which tools or functions the system should use
  /// during the execution of an API call. It facilitates the dynamic selection of
  /// tools based on the requirements of the application, ensuring targeted and
  /// efficient processing.
  /// </remarks>
  TToolChoiceParams = GenAI.Chat.TToolChoiceParams;

  /// <summary>
  /// Approximate location parameters for the search.
  /// </summary>
  TUserLocationApproximate = GenAI.Chat.TUserLocationApproximate;

  /// <summary>
  /// Approximate location parameters for the search.
  /// </summary>
  TUserLocation = GenAI.Chat.TUserLocation;

  /// <summary>
  /// Manages parameters for chat request configurations in JSON format, supporting a wide
  /// range of attributes to customize the chat completion process.
  /// </summary>
  /// <remarks>
  /// This class facilitates the comprehensive configuration of chat-related parameters,
  /// allowing the control over model selection, token limitations, response modalities,
  /// and various other settings to optimize interaction dynamics and computational efficiency.
  /// </remarks>
  TChatParams = GenAI.Chat.TChatParams;

  /// <summary>
  /// Represents the parameters for updating an existing chat completion.
  /// </summary>
  /// <remarks>
  /// Use this class to configure one or more metadata fields on a chat completion
  /// before sending an update request to the API.
  /// </remarks>
  TChatUpdateParams = GenAI.Chat.TChatUpdateParams;

  /// <summary>
  /// Represents a single token's top log probability details.
  /// </summary>
  TTopLogprobs = GenAI.Chat.TTopLogprobs;

  /// <summary>
  /// Details about the log probabilities for a specific token, including its top probable alternatives.
  /// </summary>
  TLogprobsDetail = GenAI.Chat.TLogprobsDetail;

  /// <summary>
  /// Manages the collection of log probability details for both content and refusal message tokens.
  /// </summary>
  TLogprobs = GenAI.Chat.TLogprobs;

  /// <summary>
  /// Represents a function parameter in a tool call, specifying the function name
  /// and its arguments.
  /// </summary>
  /// <remarks>
  /// This class is used within the context of an API that supports remote function
  /// calls, enabling the specification of the function's name and the corresponding
  /// arguments in JSON format.
  /// </remarks>
  TFunction = GenAI.Chat.TFunction;

  /// <summary>
  /// Encapsulates a tool call within a chat or API interaction, linking the call
  /// to a specific function with its parameters.
  /// </summary>
  /// <remarks>
  /// TToolcall is used to manage the execution of backend functions as part of
  /// an interactive session or a workflow, associating each tool call with a unique
  /// identifier and the necessary function parameters.
  /// </remarks>
  TToolcall = GenAI.Chat.TToolcall;

  /// <summary>
  /// Represents audio data that can be streamed or stored during a chat or API session,
  /// including its identifier and expiration metadata.
  /// </summary>
  /// <remarks>
  /// TAudioData is used in contexts where audio responses are managed, providing
  /// support for both temporary and persistent storage of audio files with associated
  /// metadata about expiration and format.
  /// </remarks>
  TAudioData = GenAI.Chat.TAudioData;

  /// <summary>
  /// Represents audio data for use within a JSON structure, facilitating the management
  /// of audio file information including IDs, expiration, data, and transcripts.
  /// </summary>
  /// <remarks>
  /// This class allows for detailed control and retrieval of audio data properties, useful
  /// for audio processing applications that require handling of both metadata and streamable
  /// content. It extends TAudioData to provide additional functionalities like saving to files
  /// or retrieving the stream directly.
  /// </remarks>
  TAudio = GenAI.Chat.TAudio;

  /// <summary>
  /// Represents a URL citation within a message, providing details about
  /// the referenced web resource, including its title, URL, and position in the text.
  /// </summary>
  /// <remarks>
  /// This class is used to store metadata about a URL citation found in a chat message.
  /// It includes the start and end indices of the citation within the message text,
  /// the URL itself, and the title of the referenced resource.
  /// </remarks>
  TUrlCitation = GenAI.Chat.TUrlCitation;

  /// <summary>
  /// Represents an annotation within a message, providing additional metadata
  /// related to web citations, such as referenced URLs.
  /// </summary>
  /// <remarks>
  /// This class is used to store information about web citations that appear in a chat message.
  /// It includes the type of annotation (which is always "url_citation") and a reference
  /// to a <c>TUrlCitation</c> instance containing details about the cited web resource.
  /// </remarks>
  TAnnotation = GenAI.Chat.TAnnotation;

  /// <summary>
  /// Represents a delta update for chat completions, encapsulating modifications
  /// made during streaming or batch updates of chat messages.
  /// </summary>
  /// <remarks>
  /// TDelta class is crucial for real-time updates in chat interfaces, allowing
  /// dynamic response and modification tracking. It includes properties for managing
  /// content changes, associated tool calls, and the role and refusal messages within
  /// the chat structure.
  /// </remarks>
  TDelta = GenAI.Chat.TDelta;

  /// <summary>
  /// Represents a message within a chat conversation, encapsulating the content, role,
  /// and additional interactive elements like tool calls and audio data.
  /// </summary>
  /// <remarks>
  /// TMessage class is designed to facilitate detailed interaction within chat systems,
  /// supporting rich content types including text, tools, and audio. It handles the roles
  /// of participants, ensuring appropriate responses based on user or system activity, and
  /// integrates external tool functions as part of the conversation flow.
  /// </remarks>
  TChatMessage = GenAI.Chat.TChatMessage;

  /// <summary>
  /// Represents a choice or option generated during a chat interaction, encapsulating
  /// specific responses and associated data like logs and deltas.
  /// </summary>
  /// <remarks>
  /// TChoice is integral to managing multiple potential responses in interactive systems
  /// like chatbots, where each choice can represent a different continuation of the conversation.
  /// This class includes detailed information about the response, reasoning, and any associated
  /// changes or tool calls made during the interaction.
  /// </remarks>
  TChoice = GenAI.Chat.TChoice;

  /// <summary>
  /// Represents detailed token usage statistics for a specific chat completion, providing insights into
  /// how tokens are allocated across different categories such as audio, reasoning, and predictions.
  /// </summary>
  /// <remarks>
  /// TCompletionDetail is essential for monitoring and analyzing the computational resources used during
  /// chat interactions. This class helps in understanding the efficiency and distribution of token usage
  /// within the completion process, aiding in optimization and resource management.
  /// </remarks>
  TCompletionDetail = GenAI.Chat.TCompletionDetail;

  /// <summary>
  /// Provides detailed statistics about the tokens used in the prompt of a chat session,
  /// highlighting the resource utilization during the initial stages of chat interactions.
  /// </summary>
  /// <remarks>
  /// TPromptDetail is crucial for evaluating the computational cost of initiating chat interactions,
  /// specifically in terms of the number of tokens used for audio and cached content. This class aids
  /// in optimizing token usage, ensuring efficient management of resources in chat applications.
  /// </remarks>
  TPromptDetail = GenAI.Chat.TPromptDetail;

  /// <summary>
  /// Provides a comprehensive overview of token usage statistics for a chat completion request,
  /// facilitating detailed analysis of computational resource allocation.
  /// </summary>
  /// <remarks>
  /// TUsage is instrumental in tracking and managing the resource usage in chat applications,
  /// offering insights into how tokens are distributed between the prompt and completion phases.
  /// This class allows developers to assess and optimize the efficiency of the token utilization process.
  /// </remarks>
  TUsage = GenAI.Chat.TUsage;

  /// <summary>
  /// Represents a chat completion response returned by the model, including all relevant
  /// interaction details, choices, and usage statistics.
  /// </summary>
  /// <remarks>
  /// TChat is crucial for handling the outputs of chat models, providing developers with
  /// structured data on the interactions, including the chosen responses, reasons for
  /// completion, and detailed token usage. This class facilitates the integration and
  /// management of AI-powered chat functionalities within applications.
  /// </remarks>
  TChat = GenAI.Chat.TChat;

  /// <summary>
  /// Manages asynchronous chat callBacks for a request using <c>TChat</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynChat</c> type extends the <c>TAsynParams&lt;TChat&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynChat = GenAI.Chat.TAsynChat;

  /// <summary>
  /// Manages asynchronous streaming callBacks for a request using <c>TChat</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynChatStream</c> type extends the <c>TAsynStreamParams&lt;TChat&gt;</c> record to support the lifecycle of an asynchronous streaming chat operation.
  /// It provides callbacks for different stages, including when the operation starts, progresses with new data chunks, completes successfully, or encounters an error.
  /// This structure is ideal for handling scenarios where the chat response is streamed incrementally, providing real-time updates to the user interface.
  /// </remarks>
  TAsynChatStream = GenAI.Chat.TAsynChatStream;

  /// <summary>
  /// Provides URL parameter helpers for retrieving chat messages by completion ID,
  /// supporting pagination and sort ordering.
  /// </summary>
  TUrlChatParams = GenAI.Chat.TUrlChatParams;

  /// <summary>
  /// Provides URL parameter helpers for listing chat completions,
  /// supporting pagination, metadata filtering, model filtering, and sort ordering.
  /// </summary>
  TUrlChatListParams = GenAI.Chat.TUrlChatListParams;

  /// <summary>
  /// Represents a single message returned in a chat completion response,
  /// including its content, author role, optional audio payload, and any
  /// associated annotations or tool call details.
  /// </summary>
  TChatCompletionMessage = GenAI.Chat.TChatCompletionMessage;

  /// <summary>
  /// Represents a paginated list of chat completion messages, including
  /// navigation cursors and flags for additional pages.
  /// </summary>
  TChatMessages = GenAI.Chat.TChatMessages;

  /// <summary>
  /// Represents a paginated list of chat completion responses returned by the API.
  /// </summary>
  /// <remarks>
  /// Contains an array of <c>TChat</c> objects along with pagination cursors and a flag
  /// indicating whether additional pages are available.
  /// </remarks>
  TChatCompletion = GenAI.Chat.TChatCompletion;

  /// <summary>
  /// Represents the result of a chat completion deletion request.
  /// </summary>
  /// <remarks>
  /// This class is used to deserialize the API response when a chat completion
  /// is deleted. It includes the identifier of the deleted completion, the
  /// object type returned by the service, and a flag indicating whether the
  /// deletion was successful.
  TChatDelete = GenAI.Chat.TChatDelete;

  /// <summary>
  /// Represents an asynchronous callback structure for retrieving chat messages.
  /// </summary>
  /// <remarks>
  /// Use this callback type to handle the lifecycle events (start, success, error, and cancellation)
  /// when fetching <see cref="TChatMessages"/> instances asynchronously.
  /// </remarks>
  TAsynChatMessages = GenAI.Chat.TAsynChatMessages;

  /// <summary>
  /// Represents an asynchronous callback structure for retrieving chat completion results.
  /// </summary>
  /// <remarks>
  /// Use this callback type to handle the lifecycle events (start, success, error, and cancellation)
  /// when fetching <see cref="TChatCompletion"/> instances asynchronously.
  /// </remarks>
  TAsynChatCompletion = GenAI.Chat.TAsynChatCompletion;

  /// <summary>
  /// Represents an asynchronous callback structure for deleting a chat completion.
  /// </summary>
  /// <remarks>
  /// Use this callback type to handle the lifecycle events (start, success, error, and cancellation)
  /// when performing an asynchronous delete operation for a <see cref="TChatDelete"/> instance.
  /// </remarks>
  TAsynChatDelete = GenAI.Chat.TAsynChatDelete;

  {$ENDREGION}

  {$REGION 'GenAI.Completions'}

  /// <summary>
  /// Represents parameters for generating text completions using a specified model.
  /// This class provides a fluent interface to set various parameters like model,
  /// prompt, maximum tokens, and more that influence the behavior of the completion
  /// generation process.
  /// </summary>
  /// <remarks>
  /// Instances of this class can be customized using its methods to set values for
  /// different parameters like echo, stop sequences, penalties, etc. Each method
  /// modifies the instance and returns the same modified instance, allowing for
  /// method chaining.
  /// </remarks>
  TCompletionParams = GenAI.Completions.TCompletionParams;

  /// <summary>
  /// Represents the log probabilities and associated metadata for tokens generated in a text completion.
  /// This class is part of the detailed response structure providing insights into the model's token generation process.
  /// </summary>
  TChoicesLogprobs = GenAI.Completions.TChoicesLogprobs;

  /// <summary>
  /// Represents a single choice from the set of completions generated by the model.
  /// This class includes details about the text generated, the reasons for stopping,
  /// and probabilities associated with the tokens.
  /// </summary>
  TCompletionChoice = GenAI.Completions.TCompletionChoice;

  /// <summary>
  /// Represents the response from the completion API containing all generated choices,
  /// their details, and associated system information.
  /// This class extends TJSONFingerprint to include metadata about the API interaction.
  /// </summary>
  TCompletion = GenAI.Completions.TCompletion;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TCompletion</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynCompletion</c> type extends the <c>TAsynParams&lt;TCompletion&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynCompletion = GenAI.Completions.TAsynCompletion;

  /// <summary>
  /// Manages asynchronous streaming callBacks for a request using <c>TCompletion</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynCompletionStream</c> type extends the <c>TAsynStreamParams&lt;TCompletion&gt;</c> record to support the lifecycle of an asynchronous streaming chat operation.
  /// It provides callbacks for different stages, including when the operation starts, progresses with new data chunks, completes successfully, or encounters an error.
  /// This structure is ideal for handling scenarios where the chat response is streamed incrementally, providing real-time updates to the user interface.
  /// </remarks>
  TAsynCompletionStream = GenAI.Completions.TAsynCompletionStream;

  {$ENDREGION}

  {$REGION 'GenAI.Moderation'}

  /// <summary>
  /// Represents a text moderation parameter for a JSON object, enabling the configuration
  /// of text inputs to be classified for moderation purposes.
  /// </summary>
  /// <remarks>
  /// This class provides methods to define the type and content of text data to be
  /// analyzed for potentially harmful content. It is specifically designed for use
  /// in moderation APIs to assess textual content.
  /// </remarks>
  TTextModerationParams = GenAI.Moderation.TTextModerationParams;

  /// <summary>
  /// Represents a URL moderation parameter for a JSON object, enabling the configuration
  /// of URLs to be classified for moderation purposes.
  /// </summary>
  /// <remarks>
  /// This class provides methods to define and handle URLs as input for moderation.
  /// It supports both direct web URLs and local file paths that can be encoded into
  /// base64 format for evaluation by the moderation API.
  /// </remarks>
  TUrlModerationParams = GenAI.Moderation.TUrlModerationParams;

  /// <summary>
  /// Represents an image moderation parameter for a JSON object, enabling the configuration
  /// of image inputs to be classified for moderation purposes.
  /// </summary>
  /// <remarks>
  /// This class provides methods to define the type and content of image data, either
  /// via direct URLs or base64-encoded strings, to be analyzed for potentially harmful content.
  /// It is specifically designed for use in moderation APIs to assess image content.
  /// </remarks>
  TImageModerationParams = GenAI.Moderation.TImageModerationParams;

  /// <summary>
  /// Represents the parameters for moderation requests, enabling configuration
  /// for input data and model selection to classify content for moderation purposes.
  /// </summary>
  /// <remarks>
  /// This class provides methods to configure and handle inputs for moderation,
  /// such as text, image URLs, or an array of mixed inputs. It also allows
  /// specifying the moderation model to use.
  /// </remarks>
  TModerationParams = GenAI.Moderation.TModerationParams;

  /// <summary>
  /// Represents the moderation categories used to classify content as potentially harmful.
  /// Each category indicates a specific type of harmful content, such as harassment,
  /// violence, or hate speech.
  /// </summary>
  /// <remarks>
  /// This class provides properties for each moderation category. These properties
  /// are boolean values indicating whether the corresponding category is flagged
  /// for the given input.
  /// </remarks>
  TModerationCategories = GenAI.Moderation.TModerationCategories;

  /// <summary>
  /// Represents the scores for various moderation categories, providing numerical
  /// values that indicate the likelihood of content falling into specific harmful
  /// categories.
  /// </summary>
  /// <remarks>
  /// This class defines properties to store scores for multiple categories, such as
  /// hate, harassment, violence, and others. The scores range from 0 to 1, where
  /// higher values indicate a stronger likelihood of the content being flagged for
  /// the respective category.
  /// </remarks>
  TModerationCategoryScores = GenAI.Moderation.TModerationCategoryScores;

  /// <summary>
  /// Represents a moderation category applied to various input types, providing
  /// details on how different moderation categories are assigned based on input.
  /// </summary>
  /// <remarks>
  /// This class provides properties to retrieve the specific input types (e.g., text or image)
  /// that are associated with each moderation category. It is useful for identifying
  /// the sources of flagged content within a moderation request.
  /// </remarks>
  TModerationCategoryApplied = GenAI.Moderation.TModerationCategoryApplied;

  /// <summary>
  /// Represents a flagged item that contains information about a harmful content category
  /// and its associated score as determined by a moderation model.
  /// </summary>
  /// <remarks>
  /// This record is used to store details about content that has been flagged during
  /// moderation, including the category of harm and its confidence score. It is
  /// typically part of a collection of flagged items in moderation results.
  /// </remarks>
  TFlaggedItem = GenAI.Moderation.TFlaggedItem;

  /// <summary>
  /// Represents the result of a moderation process, including information about
  /// flagged categories, their confidence scores, and the associated input types.
  /// </summary>
  /// <remarks>
  /// This class provides a detailed overview of the moderation analysis, including
  /// which categories were flagged, the confidence scores for each category, and
  /// the types of inputs (e.g., text or image) associated with flagged categories.
  /// </remarks>
  TModerationResult = GenAI.Moderation.TModerationResult;

  /// <summary>
  /// Represents the overall moderation response, including results, model information,
  /// and a unique identifier for the moderation request.
  /// </summary>
  /// <remarks>
  /// This class serves as the main container for moderation data, encapsulating
  /// results from the moderation process, the model used, and the unique request ID.
  /// </remarks>
  TModeration = GenAI.Moderation.TModeration;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TModeration</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynModeration</c> type extends the <c>TAsynParams&lt;TModeration&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynModeration = GenAI.Moderation.TAsynModeration;

  {$ENDREGION}

  {$REGION 'GenAI.Images'}

  /// <summary>
  /// Represents a parameter class for creating images through the OpenAI API, enabling
  /// the configuration of prompts, models, and other settings for image generation.
  /// </summary>
  /// <remarks>
  /// This class provides methods to specify various parameters required for generating images,
  /// such as the text prompt, model, output size, and response format. It is designed
  /// for use with the image creation API to streamline the construction of requests.
  /// </remarks>
  TImageCreateParams = GenAI.Images.TImageCreateParams;

  /// <summary>
  /// Represents a parameter class for editing images through the OpenAI API, enabling
  /// the configuration of images, masks, prompts, and other settings for image editing.
  /// </summary>
  /// <remarks>
  /// This class provides methods to specify various parameters required for editing images,
  /// such as the image file, mask, text prompt, model, output size, and response format.
  /// It is designed for use with the image editing API to streamline the construction of requests.
  /// </remarks>
  TImageEditParams = GenAI.Images.TImageEditParams;

  /// <summary>
  /// Represents a parameter class for creating image variations through the OpenAI API, enabling
  /// the configuration of images, models, and other settings for variation generation.
  /// </summary>
  /// <remarks>
  /// This class provides methods to specify various parameters required for generating image variations,
  /// such as the base image, model, output size, and response format. It is designed
  /// for use with the image variation API to streamline the construction of requests.
  /// </remarks>
  TImageVariationParams = GenAI.Images.TImageVariationParams;

  /// <summary>
  /// Represents the data object for an image created through the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class contains the properties of the generated image, including its URL,
  /// base64-encoded content, and the revised prompt (if applicable).
  /// </remarks>
  TImageCreateData = GenAI.Images.TImageCreateData;

  /// <summary>
  /// Represents a part of the generated image, extending the <c>TImageCreateData</c> class
  /// to include file management functionality.
  /// </summary>
  /// <remarks>
  /// This class provides additional methods for handling the generated image, such as
  /// saving it to a file or retrieving it as a stream. It is designed for scenarios where
  /// the generated image needs to be manipulated or stored locally.
  /// </remarks>
  TImagePart = GenAI.Images.TImagePart;

  /// <summary>
  /// Represents the response object containing a collection of generated images
  /// and metadata about the creation process.
  /// </summary>
  /// <remarks>
  /// This class encapsulates the data returned by the OpenAI API for image generation,
  /// including the timestamp of creation and the list of generated images. It provides
  /// functionality for managing the lifecycle of these objects.
  /// </remarks>
  TGeneratedImages = GenAI.Images.TGeneratedImages;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TGeneratedImages</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynImagesCreate</c> type extends the <c>TAsynParams&lt;TGeneratedImages&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynGeneratedImages = GenAI.Images.TAsynGeneratedImages;

  {$ENDREGION}

  {$REGION 'GenAI.Files'}

  /// <summary>
  /// Represents a class for constructing URL parameters specifically for file-related operations in the API.
  /// </summary>
  /// <remarks>
  /// This class provides methods to configure URL parameters such as purpose, limit, order, and pagination.
  /// It is designed to simplify the creation of query strings for file operations like listing files or filtering them by specific criteria.
  /// </remarks>
  TFileUrlParams = GenAI.Files.TFileUrlParams;

  /// <summary>
  /// Represents a class for constructing parameters for uploading files to the API.
  /// </summary>
  /// <remarks>
  /// This class provides methods to configure multipart form data for file uploads,
  /// including setting the file path and specifying its purpose.
  /// It is designed to facilitate file uploads for various use cases such as fine-tuning, batch processing, or assistants.
  /// </remarks>
  TFileUploadParams = GenAI.Files.TFileUploadParams;

  /// <summary>
  /// Represents a file object in the API, containing metadata and attributes of the uploaded file.
  /// </summary>
  /// <remarks>
  /// This class provides properties to access file metadata such as ID, size, creation timestamp, filename,
  /// purpose, and type. It is used for operations that involve file management within the API.
  /// </remarks>
  TFile = GenAI.Files.TFile;

  /// <summary>
  /// Represents a collection of file objects retrieved from the API.
  /// </summary>
  /// <remarks>
  /// This class provides properties to access the metadata of a collection of files,
  /// including the list of files, pagination information, and object type.
  /// It is used for operations that involve listing or retrieving multiple files.
  /// </remarks>
  TFiles = GenAI.Files.TFiles;

  /// <summary>
  /// Represents the content of a file retrieved from the API.
  /// </summary>
  /// <remarks>
  /// This class provides properties to access the base64-encoded content of a file
  /// and a method to decode it into a readable string. It is used for operations that involve
  /// retrieving and processing the actual content of files.
  /// </remarks>
  TFileContent = GenAI.Files.TFileContent;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TFile</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynFile</c> type extends the <c>TAsynParams&lt;TFile&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynFile = GenAI.Files.TAsynFile;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TFiles</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynFiles</c> type extends the <c>TAsynParams&lt;TFiles&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynFiles = GenAI.Files.TAsynFiles;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TFiles</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynFiles</c> type extends the <c>TAsynParams&lt;TFiles&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynFileContent = GenAI.Files.TAsynFileContent;

  {$ENDREGION}

  {$REGION 'GenAI.Uploads'}

  /// <summary>
  /// Represents the parameters required for creating an upload object in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class provides methods to configure the necessary fields for initiating an upload.
  /// An upload is used to prepare a file for adding multiple parts and eventually creating
  /// a File object that can be utilized within the platform.
  /// </remarks>
  TUploadCreateParams = GenAI.Uploads.TUploadCreateParams;

  /// <summary>
  /// Represents parameters for creating an upload part in a multipart form-data request.
  /// </summary>
  /// <remarks>
  /// This class provides methods to add data to the form-data structure, allowing the uploading
  /// of individual parts (chunks) of a file. It is specifically designed for use with APIs
  /// that handle large file uploads by splitting the file into smaller parts.
  /// </remarks>
  TUploadPartParams = GenAI.Uploads.TUploadPartParams;

  /// <summary>
  /// Represents parameters for completing an upload by specifying the order of parts and optional checksum validation.
  /// </summary>
  /// <remarks>
  /// This class provides methods to configure the finalization of a multipart upload by
  /// specifying the part IDs in the correct order and verifying the file's integrity using an MD5 checksum.
  /// </remarks>
  TUploadCompleteParams = GenAI.Uploads.TUploadCompleteParams;

  /// <summary>
  /// Represents the metadata and details of an upload, including its status, purpose, and associated file.
  /// </summary>
  /// <remarks>
  /// This class provides properties to access information about an upload object, such as its ID,
  /// filename, size, purpose, status, and expiration time. It also includes a reference to the
  /// associated file object once the upload is completed.
  /// </remarks>
  TUpload = GenAI.Uploads.TUpload;

  /// <summary>
  /// Represents metadata and details of a single upload part, including its ID, creation timestamp, and associated upload.
  /// </summary>
  /// <remarks>
  /// This class provides properties to access information about an upload part, such as its unique ID,
  /// creation time, and the ID of the parent upload to which it belongs.
  /// </remarks>
  TUploadPart = GenAI.Uploads.TUploadPart;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TUpload</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynUpload</c> type extends the <c>TAsynParams&lt;TUpload&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynUpload = GenAI.Uploads.TAsynUpload;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TUploadPart</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynUploadPart</c> type extends the <c>TAsynParams&lt;TUploadPart&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynUploadPart = GenAI.Uploads.TAsynUploadPart;

  {$ENDREGION}

  {$REGION 'GenAI.Batch'}

  /// <summary>
  /// Represents the parameters required to create a batch operation within the OpenAI API.
  /// This class encapsulates the settings and metadata necessary to initiate a batch process, including the input file, endpoint specification,
  /// completion window, and any optional metadata associated with the batch.
  /// </summary>
  TBatchCreateParams = GenAI.Batch.TBatchCreateParams;

  /// <summary>
  /// Represents the error details associated with a specific request within a batch operation.
  /// This class holds detailed information about an error, including a machine-readable code, a human-readable message,
  /// and the specific parameter or line that caused the error. This facilitates debugging and error handling in batch processing.
  /// </summary>
  TBatchErrorsData = GenAI.Batch.TBatchErrorsData;

  /// <summary>
  /// Represents a collection of errors associated with a batch operation.
  /// This class aggregates all errors that occurred during the execution of a batch, facilitating centralized error management
  /// and analysis. Each error is detailed by an instance of TBatchErrorsData, which provides specific error information.
  /// </summary>
  TBatchErrors = GenAI.Batch.TBatchErrors;

  /// <summary>
  /// Provides a count of requests at various stages of processing within a batch operation.
  /// This class includes properties for tracking the total number of requests, the number of requests that have been completed successfully,
  /// and the number of requests that have failed. This information is crucial for monitoring and managing the progress of batch operations.
  /// </summary>
  TBatchRequestCounts = GenAI.Batch.TBatchRequestCounts;

  /// <summary>
  /// Represents a batch operation as managed by the OpenAI API, encapsulating comprehensive details
  /// necessary for managing batch processing tasks. This class includes functionalities such as tracking
  /// the batch's progress, its inputs and outputs, handling errors, and managing lifecycle timestamps.
  /// </summary>
  TBatch = GenAI.Batch.TBatch;

  /// <summary>
  /// Represents a collection of batch objects from the OpenAI API.
  /// This class provides an aggregated view of multiple batch entries, enabling effective navigation and management
  /// of batch operations. It includes functionality for pagination to handle large sets of data efficiently.
  /// </summary>
  TBatches = GenAI.Batch.TBatches;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TBatch</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynBatch</c> type extends the <c>TAsynParams&lt;TBatch&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynBatch = GenAI.Batch.TAsynBatch;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TBatches</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynBatches</c> type extends the <c>TAsynParams&lt;TBatches&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynBatches = GenAI.Batch.TAsynBatches;

  {$ENDREGION}

  {$REGION 'GenAI.FineTuning'}

  /// <summary>
  /// Represents the configuration parameters for Weights and Biases (WandB) integration
  /// in fine-tuning jobs. These parameters specify project details, run names, entities,
  /// and tags associated with WandB.
  /// </summary>
  TWandbParams = GenAI.FineTuning.TWandbParams;

  /// <summary>
  /// Represents the configuration parameters for integrating external services
  /// into fine-tuning jobs. This class supports defining the type of integration
  /// (e.g., Weights and Biases) and its associated configuration details.
  /// </summary>
  TJobIntegrationParams = GenAI.FineTuning.TJobIntegrationParams;

  /// <summary>
  /// Represents the configuration of hyperparameters for fine-tuning jobs.
  /// This class provides methods to set parameters such as batch size,
  /// learning rate, number of epochs, and beta (for DPO).
  /// </summary>
  THyperparametersParams = GenAI.FineTuning.THyperparametersParams;

  /// <summary>
  /// Represents the configuration parameters for the supervised fine-tuning method.
  /// This class allows specifying hyperparameters to be used in supervised learning tasks.
  /// </summary>
  TSupervisedMethodParams = GenAI.FineTuning.TSupervisedMethodParams;

  /// <summary>
  /// Represents the configuration parameters for the DPO (Direct Preference Optimization)
  /// fine-tuning method. This class allows specifying hyperparameters to be used
  /// in DPO-based learning tasks.
  /// </summary>
  TDpoMethodParams = GenAI.FineTuning.TDpoMethodParams;

  /// <summary>
  /// Represents the configuration for the fine-tuning method to be used in a job.
  /// This class supports multiple methods, such as supervised learning or
  /// Direct Preference Optimization (DPO), and allows setting their respective parameters.
  /// </summary>
  TJobMethodParams = GenAI.FineTuning.TJobMethodParams;

  /// <summary>
  /// Represents the configuration parameters for creating a fine-tuning job.
  /// This class allows setting various properties, such as the model to fine-tune,
  /// training and validation files, hyperparameters, and optional metadata.
  /// </summary>
  TFineTuningJobParams = GenAI.FineTuning.TFineTuningJobParams;

  /// <summary>
  /// Represents detailed error information for a fine-tuning job that has failed.
  /// This class contains information about the error code, message, and the parameter
  /// that caused the failure.
  /// </summary>
  TFineTuningJobError = GenAI.FineTuning.TFineTuningJobError;

  /// <summary>
  /// Represents the hyperparameters used for a fine-tuning job in OpenAI's fine-tuning API.
  /// </summary>
  /// <remarks>
  /// The hyperparameters include options to control the training process, such as the batch size,
  /// learning rate, number of epochs, and beta (used in specific fine-tuning methods like DPO).
  /// These parameters allow customization of the model's fine-tuning behavior for optimal performance.
  /// </remarks>
  THyperparameters = GenAI.FineTuning.THyperparameters;

  /// <summary>
  /// Represents the configuration for integrating with Weights and Biases (WandB) in a fine-tuning job.
  /// </summary>
  /// <remarks>
  /// This class provides methods to set project details, display names, entities, and tags
  /// for runs tracked in WandB during the fine-tuning process.
  /// </remarks>
  TWanDB = GenAI.FineTuning.TWanDB;

  /// <summary>
  /// Represents the integration settings for a fine-tuning job, including integration with tools
  /// like Weights and Biases (WandB).
  /// </summary>
  /// <remarks>
  /// This class allows configuration of the type of integration and specific settings for each tool,
  /// such as WandB.
  /// </remarks>
  FineTuningJobIntegration = GenAI.FineTuning.FineTuningJobIntegration;

  /// <summary>
  /// Represents the configuration for supervised fine-tuning in a fine-tuning job.
  /// </summary>
  /// <remarks>
  /// This class contains the hyperparameters that define the supervised fine-tuning process.
  /// </remarks>
  TSupervised = GenAI.FineTuning.TSupervised;

  /// <summary>
  /// Represents the configuration for the DPO (Direct Preference Optimization) fine-tuning method
  /// in a fine-tuning job.
  /// </summary>
  /// <remarks>
  /// This class contains the hyperparameters that define the DPO fine-tuning process.
  /// </remarks>
  TDpo = GenAI.FineTuning.TDpo;

  /// <summary>
  /// Represents the method configuration for fine-tuning in a fine-tuning job.
  /// </summary>
  /// <remarks>
  /// This class defines the type of fine-tuning method (e.g., supervised or DPO) and includes the
  /// specific configurations for each method.
  /// </remarks>
  TFineTuningMethod = GenAI.FineTuning.TFineTuningMethod;

  /// <summary>
  /// Represents a fine-tuning job in OpenAI's fine-tuning API.
  /// </summary>
  /// <remarks>
  /// This class contains details about a fine-tuning job, including its status, configuration, and results.
  /// </remarks>
  TFineTuningJob = GenAI.FineTuning.TFineTuningJob;

  /// <summary>
  /// Represents a list of fine-tuning jobs in OpenAI's fine-tuning API.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TJobList</c> to provide a collection of fine-tuning jobs and their details.
  /// </remarks>
  TFineTuningJobs = GenAI.FineTuning.TFineTuningJobs;

  /// <summary>
  /// Represents an event associated with a fine-tuning job in OpenAI's fine-tuning API.
  /// </summary>
  /// <remarks>
  /// This class provides information about a specific event, including its type, timestamp,
  /// message, and associated data.
  /// </remarks>
  TJobEvent = GenAI.FineTuning.TJobEvent;

  /// <summary>
  /// Represents a list of events associated with a fine-tuning job in OpenAI's fine-tuning API.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TJobList</c> to provide a collection of events for a specific fine-tuning job,
  /// including their details such as type, message, and timestamps.
  /// </remarks>
  TJobEvents = GenAI.FineTuning.TJobEvents;

  /// <summary>
  /// Represents the metrics collected during a fine-tuning job in OpenAI's fine-tuning API.
  /// </summary>
  /// <remarks>
  /// This class contains various metrics related to the training and validation process,
  /// including loss values and token accuracy.
  /// </remarks>
  TMetrics = GenAI.FineTuning.TMetrics;

  /// <summary>
  /// Represents a model checkpoint for a fine-tuning job in OpenAI's fine-tuning API.
  /// </summary>
  /// <remarks>
  /// This class contains details about a specific checkpoint, including the step number, metrics,
  /// and the fine-tuned model checkpoint identifier.
  /// </remarks>
  TJobCheckpoint = GenAI.FineTuning.TJobCheckpoint;

  /// <summary>
  /// Represents a list of checkpoints for a fine-tuning job in OpenAI's fine-tuning API.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TJobList</c> to provide a collection of checkpoints generated during
  /// a fine-tuning job. Each checkpoint includes details such as step number, metrics, and associated model data.
  /// </remarks>
  TJobCheckpoints = GenAI.FineTuning.TJobCheckpoints;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TFineTuningJob</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynFineTuningJob</c> type extends the <c>TAsynParams&lt;TFineTuningJob&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynFineTuningJob = GenAI.FineTuning.TAsynFineTuningJob;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TFineTuningJobs</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynFineTuningJobs</c> type extends the <c>TAsynParams&lt;TFineTuningJobs&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynFineTuningJobs = GenAI.FineTuning.TAsynFineTuningJobs;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TJobEvents</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynJobEvents</c> type extends the <c>TAsynParams&lt;TJobEvents&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynJobEvents = GenAI.FineTuning.TAsynJobEvents;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TJobCheckpoints</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynFineJobCheckpoints</c> type extends the <c>TAsynParams&lt;TJobCheckpoints&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynJobCheckpoints = GenAI.FineTuning.TAsynJobCheckpoints;

  {$ENDREGION}

  {$REGION 'GenAI.Assistants'}

  /// <summary>
  /// Represents the parameters used to configure ranking options in a file search operation.
  /// </summary>
  /// <remarks>
  /// This class provides methods to set the ranker and score threshold, which define
  /// how search results are ranked and filtered. It extends <c>TJSONParam</c> to support
  /// serialization to JSON format.
  /// </remarks>
  TRankingOptionsParams = GenAI.Assistants.TRankingOptionsParams;

  /// <summary>
  /// Represents the parameters used to configure the file search tool in an assistant.
  /// </summary>
  /// <remarks>
  /// This class provides methods to set the maximum number of results and ranking options
  /// for the file search operation. It extends <c>TJSONParam</c> to enable JSON serialization.
  /// </remarks>
  TFileSearchToolParams = GenAI.Assistants.TFileSearchToolParams;

  /// <summary>
  /// Represents the parameters used to define a custom function for an assistant.
  /// </summary>
  /// <remarks>
  /// This class provides methods to set the function's name, description, parameters,
  /// and strict mode. It extends <c>TJSONParam</c> to enable JSON serialization.
  /// </remarks>
  TAssistantsFunctionParams = GenAI.Assistants.TAssistantsFunctionParams;

  /// <summary>
  /// Represents the parameters used to configure tools for an assistant.
  /// </summary>
  /// <remarks>
  /// This class provides methods to define different types of tools, including
  /// file search and custom functions. It extends <c>TJSONParam</c> to support
  /// JSON serialization.
  /// </remarks>
  TAssistantsToolsParams = GenAI.Assistants.TAssistantsToolsParams;

  /// <summary>
  /// Represents the parameters used to configure the code interpreter tool for an assistant.
  /// </summary>
  /// <remarks>
  /// This class provides methods to specify the file IDs that the code interpreter tool
  /// can access. It extends <c>TJSONParam</c> to enable JSON serialization.
  /// </remarks>
  TCodeInterpreterParams = GenAI.Assistants.TCodeInterpreterParams;

  /// <summary>
  /// Represents the parameters used to configure static chunking for file processing.
  /// </summary>
  /// <remarks>
  /// This class provides methods to set the maximum chunk size and overlap between chunks.
  /// It is used to control how large text or data is divided into manageable parts for
  /// processing. The class extends <c>TJSONParam</c> to enable JSON serialization.
  /// </remarks>
  TChunkStaticParams = GenAI.Assistants.TChunkStaticParams;

  /// <summary>
  /// Represents the parameters used to configure the chunking strategy for file processing.
  /// </summary>
  /// <remarks>
  /// This class provides methods to define the type of chunking strategy and configure
  /// specific parameters, such as static chunking options. It extends <c>TJSONParam</c>
  /// to enable JSON serialization.
  /// </remarks>
  TChunkingStrategyParams = GenAI.Assistants.TChunkingStrategyParams;

  /// <summary>
  /// Represents the parameters used to configure vector stores for file search operations.
  /// </summary>
  /// <remarks>
  /// This class provides methods to specify file IDs, chunking strategies, and metadata
  /// associated with vector stores. It extends <c>TJSONParam</c> to enable JSON serialization.
  /// </remarks>
  TVectorStoresParams = GenAI.Assistants.TVectorStoresParams;

  /// <summary>
  /// Represents the parameters used to configure file search operations in an assistant.
  /// </summary>
  /// <remarks>
  /// This class provides methods to specify vector store IDs and configure vector stores
  /// for efficient file searching. It extends <c>TJSONParam</c> to enable JSON serialization.
  /// </remarks>
  TFileSearchParams = GenAI.Assistants.TFileSearchParams;

  /// <summary>
  /// Represents the parameters used to configure tool resources for an assistant.
  /// </summary>
  /// <remarks>
  /// This class provides methods to specify resources for the code interpreter and
  /// file search tools. It extends <c>TJSONParam</c> to enable JSON serialization.
  /// </remarks>
  TToolResourcesParams = GenAI.Assistants.TToolResourcesParams;

  /// <summary>
  /// Represents the parameters used to define a JSON schema for structured responses.
  /// </summary>
  /// <remarks>
  /// This class provides methods to specify the schema name, description, and structure.
  /// It allows strict schema adherence for function calls and output validation.
  /// Extends <c>TJSONParam</c> to enable JSON serialization.
  /// </remarks>
  TJsonSchemaParams = GenAI.Assistants.TJsonSchemaParams;

  /// <summary>
  /// Represents the parameters used to configure the response format for an assistant.
  /// </summary>
  /// <remarks>
  /// This class provides methods to define the type of response format, including JSON
  /// schema and structured outputs. It extends <c>TJSONParam</c> to enable JSON serialization.
  /// </remarks>
  TResponseFormatParams = GenAI.Assistants.TResponseFormatParams;

  /// <summary>
  /// Represents the parameters used to configure an assistant.
  /// </summary>
  /// <remarks>
  /// This class provides methods to specify the assistant's model, name, description,
  /// instructions, tools, and response format. It extends <c>TJSONParam</c> to enable
  /// JSON serialization.
  /// </remarks>
  TAssistantsParams = GenAI.Assistants.TAssistantsParams;

  /// <summary>
  /// Represents the ranking options for a file search operation.
  /// </summary>
  /// <remarks>
  /// This class provides properties to configure the ranking mechanism of a file search,
  /// including the ranker type and score threshold for filtering results.
  /// </remarks>
  TRankingOptions = GenAI.Assistants.TRankingOptions;

  /// <summary>
  /// Represents the file search configuration for an assistant.
  /// </summary>
  /// <remarks>
  /// This class provides properties to define the file search behavior, including the
  /// maximum number of search results and ranking options for filtering results.
  /// </remarks>
  TAssistantsFileSearch = GenAI.Assistants.TAssistantsFileSearch;

  /// <summary>
  /// Represents a custom function definition for an assistant.
  /// </summary>
  /// <remarks>
  /// This class provides properties to define a function's name, description, parameters,
  /// and strict mode. Functions allow the assistant to execute predefined operations.
  /// </remarks>
  TAssistantsFunction = GenAI.Assistants.TAssistantsFunction;

  /// <summary>
  /// Represents a tool configuration for an assistant.
  /// </summary>
  /// <remarks>
  /// This class provides properties to define different types of tools that an assistant
  /// can use, such as file search or custom functions. Each tool configuration includes
  /// specific settings based on its type.
  /// </remarks>
  TAssistantsTools = GenAI.Assistants.TAssistantsTools;

  /// <summary>
  /// Represents the configuration for the code interpreter tool.
  /// </summary>
  /// <remarks>
  /// This class provides properties to specify the files accessible to the code interpreter.
  /// It enables the assistant to process and analyze code-related files.
  /// </remarks>
  TCodeInterpreter = GenAI.Assistants.TCodeInterpreter;

  /// <summary>
  /// Represents the configuration for the file search tool.
  /// </summary>
  /// <remarks>
  /// This class provides properties to specify the vector stores used for file searching.
  /// It enables the assistant to perform efficient and accurate file searches.
  /// </remarks>
  TFileSearch = GenAI.Assistants.TFileSearch;

  /// <summary>
  /// Represents the resources used by the tools configured for an assistant.
  /// </summary>
  /// <remarks>
  /// This class provides properties to define the resources available to tools such as
  /// the code interpreter and file search. These resources ensure that tools can perform
  /// their operations efficiently.
  /// </remarks>
  TToolResources = GenAI.Assistants.TToolResources;

  /// <summary>
  /// Represents an assistant configuration and its associated properties.
  /// </summary>
  /// <remarks>
  /// This class provides properties to define the assistant's settings, including its
  /// name, model, instructions, tools, and metadata. It extends <c>TJSONFingerprint</c>
  /// to support JSON serialization.
  /// </remarks>
  TAssistant = GenAI.Assistants.TAssistant;

  /// <summary>
  /// Represents a list of assistant objects.
  /// </summary>
  /// <remarks>
  /// This type is a specialization of <c>TAdvancedList</c> for handling a collection of
  /// <c>TAssistant</c> objects. It includes pagination metadata and provides access to
  /// multiple assistant configurations in a structured format.
  /// </remarks>
  TAssistants = GenAI.Assistants.TAssistants;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TAssistant</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynAssistant</c> type extends the <c>TAsynParams&lt;TAssistant&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynAssistant = GenAI.Assistants.TAsynAssistant;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TAssistants</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynAssistants</c> type extends the <c>TAsynParams&lt;TAssistants&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynAssistants = GenAI.Assistants.TAsynAssistants;

  {$ENDREGION}

  {$REGION 'GenAI.Messages'}

  /// <summary>
  /// Represents URL parameters used for customizing requests related to assistants in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TUrlAdvancedParams</c> to provide additional parameters
  /// that can be added to API calls when interacting with assistant-related threads.
  /// </remarks>
  TAssistantsUrlParams = GenAI.Messages.TAssistantsUrlParams;

  /// <summary>
  /// Represents parameters used for updating messages within a thread in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TJSONParam</c> to provide structured key-value pairs
  /// for modifying messages, such as attaching metadata or updating message-specific details.
  /// </remarks>
  TMessagesUpdateParams = GenAI.Messages.TMessagesUpdateParams;

  /// <summary>
  /// Represents details related to incomplete messages within a thread in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class contains information on why a message was marked as incomplete,
  /// typically providing a reason for the failure or interruption during processing.
  /// </remarks>
  TIncompleteDetails = GenAI.Messages.TIncompleteDetails;

  /// <summary>
  /// Represents an image file attached to a message within a thread in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class is used to reference an image that is included as part of a message.
  /// The image is identified by its file ID and can have an associated detail level.
  /// </remarks>
  TMessagesImageFile = GenAI.Messages.TMessagesImageFile;

  /// <summary>
  /// Represents an external image URL attached to a message within a thread in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class is used to reference an image located at an external URL.
  /// The image can have an associated detail level, which determines the resolution or processing cost.
  /// </remarks>
  TMessagesImageUrl = GenAI.Messages.TMessagesImageUrl;

  /// <summary>
  /// Represents a citation within a message that references a specific portion of a file in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class is used to provide contextual citations by referencing parts of a file
  /// that the assistant used during message generation or processing.
  /// </remarks>
  TFileCitation = GenAI.Messages.TFileCitation;

  /// <summary>
  /// Represents the file path of a file generated or referenced during message processing in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class is used to reference a file by its path or identifier, typically when
  /// files are generated dynamically during tasks like code execution or data processing.
  /// </remarks>
  TFilePath = GenAI.Messages.TFilePath;

  /// <summary>
  /// Represents an annotation within a message, providing contextual references such as file citations or file paths.
  /// </summary>
  /// <remarks>
  /// This class is used to add annotations that point to specific parts of external files,
  /// providing traceable references within the message content.
  /// </remarks>
  TMesssagesAnnotation = GenAI.Messages.TMesssagesAnnotation;

  /// <summary>
  /// Represents the text content of a message within the OpenAI API, including any associated annotations.
  /// </summary>
  /// <remarks>
  /// This class stores the text content of a message along with any annotations that provide
  /// additional context, such as file citations or file paths.
  /// </remarks>
  TMessagesText = GenAI.Messages.TMessagesText;

  /// <summary>
  /// Represents the content of a message in the OpenAI API, including text, images, and refusal reasons.
  /// </summary>
  /// <remarks>
  /// This class stores various types of content that can be part of a message,
  /// such as plain text, image references, or refusal messages indicating that the assistant
  /// declined to respond.
  /// </remarks>
  TMessagesContent = GenAI.Messages.TMessagesContent;

  /// <summary>
  /// Represents a tool associated with an attachment in a message within the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class specifies the type of tool linked to an attachment, such as a code interpreter
  /// or file search tool, which can be used during message processing.
  /// </remarks>
  TAttachmentTool = GenAI.Messages.TAttachmentTool;

  /// <summary>
  /// Represents an attachment associated with a message in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class stores information about a file attached to a message and the tools
  /// that can be used to process or interact with the file.
  /// </remarks>
  TAttachment = GenAI.Messages.TAttachment;

  /// <summary>
  /// Represents a message within a thread in the OpenAI API, including its content, status, metadata, and attachments.
  /// </summary>
  /// <remarks>
  /// This class stores all the details related to a message, such as its creation timestamp,
  /// role, status, and the content it contains (text, images, or other media).
  /// </remarks>
  TMessages = GenAI.Messages.TMessages;

  /// <summary>
  /// Represents a list of messages within a thread in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TAdvancedList</c> to provide a collection of <c>TMessages</c> objects,
  /// allowing for easy iteration and manipulation of messages retrieved from the API.
  /// </remarks>
  TMessagesList = GenAI.Messages.TMessagesList;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TMessages</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynMessages</c> type extends the <c>TAsynParams&lt;TMessages&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynMessages = GenAI.Messages.TAsynMessages;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TMessagesList</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynMessagesList</c> type extends the <c>TAsynParams&lt;TMessagesList&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynMessagesList = GenAI.Messages.TAsynMessagesList;

  {$ENDREGION}

  {$REGION 'GenAI.Threads'}

  /// <summary>
  /// Represents parameters for specifying image files in OpenAI threads.
  /// This class is used to define image-related details such as the file ID and image detail level.
  /// </summary>
  TThreadsImageFileParams = GenAI.Threads.TThreadsImageFileParams;

  /// <summary>
  /// Represents parameters for specifying image URLs in OpenAI threads.
  /// This class is used to define URL-related details such as the image URL and its detail level.
  /// </summary>
  TThreadsImageUrlParams = GenAI.Threads.TThreadsImageUrlParams;

  /// <summary>
  /// Represents the parameters used to define the content of messages in OpenAI threads.
  /// This can include text content, image files, or image URLs.
  /// </summary>
  TThreadsContentParams = GenAI.Threads.TThreadsContentParams;

  /// <summary>
  /// Represents attachments that can be included in messages in OpenAI threads.
  /// Attachments can be files with specific tools applied, such as a code interpreter or file search.
  /// </summary>
  TThreadsAttachment = GenAI.Threads.TThreadsAttachment;

  /// <summary>
  /// Represents the parameters used to define a message in OpenAI threads.
  /// A message contains details such as its role, content, attachments, and metadata.
  /// </summary>
  TThreadsMessageParams = GenAI.Threads.TThreadsMessageParams;

  /// <summary>
  /// Represents the parameters for creating a new thread in OpenAI threads.
  /// This includes defining initial messages, tool resources, and metadata.
  /// </summary>
  TThreadsCreateParams = GenAI.Threads.TThreadsCreateParams;

  /// <summary>
  /// Represents the parameters used to modify an existing thread in OpenAI threads.
  /// This includes updating tool resources and metadata.
  /// </summary>
  TThreadsModifyParams = GenAI.Threads.TThreadsModifyParams;

  /// <summary>
  /// Represents a thread object in OpenAI threads.
  /// A thread contains messages, tool resources, metadata, and other properties related to its creation and management.
  /// </summary>
  TThreads = GenAI.Threads.TThreads;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TThreads</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynThreads</c> type extends the <c>TAsynParams&lt;TThreads&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynThreads = GenAI.Threads.TAsynThreads;

  {$ENDREGION}

  {$REGION 'GenAI.Runs'}

  /// <summary>
  /// Represents the URL parameters for API requests related to execution runs on threads.
  /// </summary>
  /// <remarks>
  /// This class is used to customize and configure URL-based parameters for retrieving or managing runs in API requests.
  /// It extends the base functionality of <c>TUrlAdvancedParams</c>, enabling additional customization for OpenAI API endpoints related to execution runs.
  /// </remarks>
  TRunsUrlParams = GenAI.Runs.TRunsUrlParams;

  /// <summary>
  /// Represents the configuration for selecting a tool choice when creating or running an execution run on a thread in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class allows specifying the tool type and, optionally, the name of the function to be called during the run.
  /// The tool choice is essential for directing the assistant to use specific tools like functions during an API run execution.
  /// </remarks>
  TRunsToolChoice = GenAI.Runs.TRunsToolChoice;

  /// <summary>
  /// Represents the truncation strategy configuration for a run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class allows specifying how the thread context should be truncated when constructing the prompt for the run.
  /// Different truncation strategies help optimize token usage and focus the context on relevant messages.
  /// </remarks>
  TRunsTruncationStrategy = GenAI.Runs.TRunsTruncationStrategy;

  /// <summary>
  /// Represents the core parameters for creating or modifying a run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class provides methods to configure various settings such as model selection, instructions, token limits, tool usage, and other options that affect the behavior of the run.
  /// </remarks>
  TRunsCoreParams = GenAI.Runs.TRunsCoreParams;

  /// <summary>
  /// Represents the parameters for creating a run in the OpenAI API, extending the core parameters with additional settings.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TRunsCoreParams</c> by adding options for including additional messages at the start of the thread.
  /// It allows fine-tuning the initial context and behavior of the assistant during the run.
  /// </remarks>
  TRunsParams = GenAI.Runs.TRunsParams;

  /// <summary>
  /// Represents the parameters for creating a new thread and running it in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TRunsCoreParams</c> and allows configuring both the thread and the tools/resources available to the assistant during the run.
  /// It is used when you need to create a new conversation thread and immediately execute the run.
  /// </remarks>
  TCreateRunsParams = GenAI.Runs.TCreateRunsParams;

  /// <summary>
  /// Represents the parameters for updating an existing run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class allows modifying metadata associated with a run, enabling the attachment of key-value pairs for tracking additional information.
  /// </remarks>
  TRunUpdateParams = GenAI.Runs.TRunUpdateParams;

  /// <summary>
  /// Represents the parameters for submitting tool outputs to a run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class allows specifying the output generated by a tool and associating it with the appropriate tool call within the run.
  /// Tool outputs are required to continue or complete certain runs that depend on external computations.
  /// </remarks>
  TToolOutputParam = GenAI.Runs.TToolOutputParam;

  /// <summary>
  /// Represents the parameters for submitting tool outputs to a run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class is used when a run requires external tool outputs to continue.
  /// It allows specifying the outputs from the tools and submitting them in a structured manner.
  /// </remarks>
  TSubmitToolParams = GenAI.Runs.TSubmitToolParams;

  /// <summary>
  /// Represents the tool output submissions required to continue a run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class holds the collection of tool call outputs that are needed to satisfy the required action of a run.
  /// Each tool call output contains the necessary details to be processed by the run.
  /// </remarks>
  TSubmitToolOutputs = GenAI.Runs.TSubmitToolOutputs;

  /// <summary>
  /// Represents details about an action required to continue an execution run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// When a run is paused and requires input or tool output to proceed, this class provides information on the specific action needed.
  /// </remarks>
  TRequiredAction = GenAI.Runs.TRequiredAction;

  /// <summary>
  /// Represents details about the last error encountered during an execution run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class provides information about the error, including its code and a descriptive message.
  /// </remarks>
  TLastError = GenAI.Runs.TLastError;

  /// <summary>
  /// Represents details about why an execution run is incomplete in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class provides the reason explaining why the run did not complete successfully, such as token limits or other restrictions.
  /// </remarks>
  TIncompleteDetailsReason = GenAI.Runs.TIncompleteDetailsReason;

  /// <summary>
  /// Represents token usage statistics for an execution run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class tracks the number of tokens used during the run, including prompt tokens, completion tokens, and the total token count.
  /// </remarks>
  TRunUsage = GenAI.Runs.TRunUsage;

  /// <summary>
  /// Represents the truncation strategy used to manage the context window for an execution run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class allows control over how much of the thread's context is included in the prompt, which helps optimize token usage.
  /// </remarks>
  TTruncationStrategy = GenAI.Runs.TTruncationStrategy;

  /// <summary>
  /// Represents an execution run on a thread in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class contains information about the run, such as its status, associated assistant, model, instructions, token usage, and any errors encountered.
  /// </remarks>
  TRun = GenAI.Runs.TRun;

  /// <summary>
  /// Represents a list of execution runs on a thread in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class is a collection of <c>TRun</c> objects, providing access to multiple execution runs associated with a specific thread.
  /// It can be used to iterate through and retrieve information about each run.
  /// </remarks>
  TRuns = GenAI.Runs.TRuns;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TRun</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynRun</c> type extends the <c>TAsynParams&lt;TRun&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynRun = GenAI.Runs.TAsynRun;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TRuns</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynRuns</c> type extends the <c>TAsynParams&lt;TRuns&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynRuns = GenAI.Runs.TAsynRuns;

  {$ENDREGION}

  {$REGION 'GenAI.RunSteps'}

  /// <summary>
  /// Represents URL parameters for retrieving specific run step details in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class is used to customize URL parameters when making requests to retrieve details about
  /// specific steps within an execution run. It enables including additional fields in the API response.
  /// </remarks>
  TRetrieveStepUrlParam = GenAI.RunSteps.TRetrieveStepUrlParam;

  /// <summary>
  /// Represents URL parameters for listing or retrieving multiple run steps in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class is used to customize URL parameters when making requests to list or retrieve details
  /// about multiple steps within an execution run. It allows for including additional data in the API response.
  /// </remarks>
  TRunStepUrlParam = GenAI.RunSteps.TRunStepUrlParam;

  /// <summary>
  /// Represents details about the message creation step within an execution run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class provides information related to a message created during a run step, such as
  /// the unique identifier of the created message.
  /// </remarks>
  TRunStepMessageCreation = GenAI.RunSteps.TRunStepMessageCreation;

  /// <summary>
  /// Represents details of an image output generated during a code interpreter run step in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class provides information about an image output, including the unique file identifier.
  /// </remarks>
  TOutputImage = GenAI.RunSteps.TOutputImage;

  /// <summary>
  /// Represents the output generated by the code interpreter during a run step in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class contains details about the output from the code interpreter, which can include logs
  /// and image outputs.
  /// </remarks>
  TCodeInterpreterOutput = GenAI.RunSteps.TCodeInterpreterOutput;

  /// <summary>
  /// Represents the details of a code interpreter step within an execution run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class contains information about the input provided to the code interpreter and the outputs
  /// it generated, such as logs or images.
  /// </remarks>
  TRunStepCodeInterpreter = GenAI.RunSteps.TRunStepCodeInterpreter;

  /// <summary>
  /// Represents the content of a search result within a file search tool call during an execution run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class contains details about the content type and the corresponding text found during the file search.
  /// </remarks>
  TResultContent = GenAI.RunSteps.TResultContent;

  /// <summary>
  /// Represents a result from a file search tool call within an execution run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class contains information about a file search result, including the file details, score, and
  /// the content found within the file.
  /// </remarks>
  TRunFileSearchResult = GenAI.RunSteps.TRunFileSearchResult;

  /// <summary>
  /// Represents details of a file search tool call within an execution run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class contains information about the file search operation, including the ranking options used
  /// and the results retrieved from the search.
  /// </remarks>
  TRunStepFileSearch = GenAI.RunSteps.TRunStepFileSearch;

  /// <summary>
  /// Represents details of a function tool call within an execution run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class contains information about a function tool call, including the function name,
  /// arguments passed, and the output generated.
  /// </remarks>
  TRunStepFunction = GenAI.RunSteps.TRunStepFunction;

  /// <summary>
  /// Represents details of tool calls made during a specific run step in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class provides information about various tool calls, such as code interpreter executions,
  /// file searches, or function invocations.
  /// </remarks>
  TRunStepToolCalls = GenAI.RunSteps.TRunStepToolCalls;

  /// <summary>
  /// Represents the detailed information of a run step within an execution run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class provides details about the type of run step and any associated tool calls
  /// or message creation activities.
  /// </remarks>
  TRunStepDetails = GenAI.RunSteps.TRunStepDetails;

  /// <summary>
  /// Represents a specific step within an execution run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class contains details about the run step, such as its type, status, associated assistant,
  /// and any outputs or errors generated during the step.
  /// </remarks>
  TRunStep = GenAI.RunSteps.TRunStep;

  /// <summary>
  /// Represents a collection of run steps within an execution run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class is a list of <c>TRunStep</c> objects, providing access to multiple steps within a run.
  /// It allows for iteration over the run steps to retrieve their details, such as outputs, statuses, or errors.
  /// </remarks>
  TRunSteps = GenAI.RunSteps.TRunSteps;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TRunStep</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynRunStep</c> type extends the <c>TAsynParams&lt;TRunStep&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynRunStep = GenAI.RunSteps.TAsynRunStep;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TRunSteps</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynRunSteps</c> type extends the <c>TAsynParams&lt;TRunSteps&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynRunSteps = GenAI.RunSteps.TAsynRunSteps;

  {$ENDREGION}

  {$REGION 'GenAI.Vector'}

  /// <summary>
  /// Represents URL parameters for configuring requests to manage vector stores in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// The <c>TVectorStoreUrlParam</c> class is designed to facilitate customization of query parameters
  /// when interacting with the vector stores API, such as listing or filtering vector stores.
  /// It extends the base <c>TUrlAdvancedParams</c> class, inheriting functionality for parameter management.
  /// </remarks>
  TVectorStoreUrlParam = GenAI.Vector.TVectorStoreUrlParam;

  /// <summary>
  /// Represents parameters for specifying the expiration policy of a vector store in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// The <c>TExpiresAfterParams</c> class is used to configure when a vector store should expire
  /// based on a specified anchor timestamp and the number of days after the anchor.
  /// This helps in automatically managing the lifecycle of vector stores.
  /// </remarks>
  TExpiresAfterParams = GenAI.Vector.TExpiresAfterParams;

  /// <summary>
  /// Represents the parameters required to create a new vector store in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// The <c>TVectorStoreCreateParams</c> class provides methods for setting parameters such as file IDs,
  /// expiration policies, chunking strategies, and metadata. These parameters are used when making
  /// API requests to create a vector store that can be utilized by tools like file search.
  /// </remarks>
  TVectorStoreCreateParams = GenAI.Vector.TVectorStoreCreateParams;

  /// <summary>
  /// Represents the parameters required to update an existing vector store in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// The <c>TVectorStoreUpdateParams</c> class provides methods for updating properties such as
  /// the vector store name, expiration policy, and metadata. These parameters are used when making
  /// API requests to modify an existing vector store.
  /// </remarks>
  TVectorStoreUpdateParams = GenAI.Vector.TVectorStoreUpdateParams;

  /// <summary>
  /// Represents the counts of files in various processing states within a vector store in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// The <c>TVectorFileCounts</c> class provides detailed counts of files associated with a vector store,
  /// including files that are being processed, successfully completed, failed, or canceled.
  /// This helps monitor the status and progress of file processing in a vector store.
  /// </remarks>
  TVectorFileCounts = GenAI.Vector.TVectorFileCounts;

  /// <summary>
  /// Represents the expiration policy for a vector store in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// The <c>TExpiresAfter</c> class defines when a vector store will expire based on an anchor timestamp
  /// and the number of days after the anchor. This class is useful for managing the automatic cleanup
  /// or deactivation of vector stores.
  /// </remarks>
  TExpiresAfter = GenAI.Vector.TExpiresAfter;

  /// <summary>
  /// Represents a vector store in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// The <c>TVectorStore</c> class encapsulates the properties and status of a vector store,
  /// including its name, creation timestamp, expiration settings, file usage, and metadata.
  /// A vector store is used to store and retrieve processed files for use by tools such as file search.
  /// </remarks>
  TVectorStore = GenAI.Vector.TVectorStore;

  /// <summary>
  /// Represents a collection of vector stores in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// The <c>TVectorStores</c> class is a list of <c>TVectorStore</c> objects, providing access to multiple
  /// vector stores. It allows iteration over the vector stores to retrieve details such as their status,
  /// usage, expiration policies, and metadata.
  /// </remarks>
  TVectorStores = GenAI.Vector.TVectorStores;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TVectorStore</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynVectorStore</c> type extends the <c>TAsynParams&lt;TVectorStore&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynVectorStore = GenAI.Vector.TAsynVectorStore;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TVectorStores</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynVectorStores</c> type extends the <c>TAsynParams&lt;TVectorStores&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynVectorStores = GenAI.Vector.TAsynVectorStores;

  {$ENDREGION}

  {$REGION 'GenAI.VectorFiles'}

  /// <summary>
  /// Represents URL parameters for configuring requests related to vector store files in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// The <c>TVectorStoreFilesUrlParams</c> class allows users to customize the URL query parameters
  /// when listing or filtering files associated with a specific vector store.
  /// This is useful when retrieving files with particular statuses or conditions.
  /// </remarks>
  TVectorStoreFilesUrlParams = GenAI.VectorFiles.TVectorStoreFilesUrlParams;

  /// <summary>
  /// Represents parameters for creating vector store files in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// The <c>TVectorStoreFilesCreateParams</c> class allows users to specify key parameters such as
  /// the file ID and chunking strategy when adding a file to a vector store. These parameters
  /// determine how the file will be chunked and indexed within the vector store.
  /// </remarks>
  TVectorStoreFilesCreateParams = GenAI.VectorFiles.TVectorStoreFilesCreateParams;

  /// <summary>
  /// Represents the static chunking strategy settings for dividing files into chunks in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// The <c>TChunkingStrategyStatic</c> class defines the static configuration for chunking a file
  /// into smaller, overlapping segments. This strategy is used when users want precise control over
  /// the size and overlap of the chunks.
  /// </remarks>
  TChunkingStrategyStatic = GenAI.VectorFiles.TChunkingStrategyStatic;

  /// <summary>
  /// Represents the chunking strategy configuration used for splitting files into chunks in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// The <c>TChunkingStrategy</c> class defines how files are divided into chunks for indexing in a vector store.
  /// It supports both static and dynamic chunking strategies, depending on the configuration.
  /// </remarks>
  TChunkingStrategy = GenAI.VectorFiles.TChunkingStrategy;

  /// <summary>
  /// Represents a file attached to a vector store in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// The <c>TVectorStoreFile</c> class encapsulates details about a file added to a vector store,
  /// including its ID, usage, creation timestamp, status, and chunking strategy. This information
  /// is used to monitor file processing and storage within the vector store.
  /// </remarks>
  TVectorStoreFile = GenAI.VectorFiles.TVectorStoreFile;

  /// <summary>
  /// Represents a list of files attached to a vector store in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// The <c>TVectorStoreFiles</c> class is a collection of <c>TVectorStoreFile</c> objects,
  /// providing access to details about multiple files within a vector store. It supports
  /// iteration, allowing users to retrieve information about each file, such as its status,
  /// usage, and chunking strategy.
  /// </remarks>
  TVectorStoreFiles = GenAI.VectorFiles.TVectorStoreFiles;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TVectorStoreFile</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynVectorStoreFile</c> type extends the <c>TAsynParams&lt;TVectorStoreFile&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynVectorStoreFile = GenAI.VectorFiles.TAsynVectorStoreFile;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TVectorStoreFiles</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynVectorStoreFiles</c> type extends the <c>TAsynParams&lt;TVectorStoreFiles&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynVectorStoreFiles = GenAI.VectorFiles.TAsynVectorStoreFiles;

  {$ENDREGION}

  {$REGION 'GenAI.VectorBatch'}

  /// <summary>
  /// Represents URL parameters for configuring requests related to file batches in a vector store using the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TVectorStoreFilesUrlParams</c> and provides the ability to customize the URL query parameters
  /// when listing or filtering batches of files associated with a specific vector store.
  /// It is useful for narrowing down results or retrieving batches with particular statuses.
  /// </remarks>
  TVectorStoreBatchUrlParams = GenAI.VectorBatch.TVectorStoreBatchUrlParams;

  /// <summary>
  /// Represents the parameters for creating file batches in a vector store using the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TVectorStoreFilesCreateParams</c> and allows users to define key parameters
  /// when creating a new batch of files in a vector store, including the file IDs and chunking strategy.
  /// These settings control how files are processed and chunked before being stored.
  /// </remarks>
  TVectorStoreBatchCreateParams = GenAI.VectorBatch.TVectorStoreBatchCreateParams;

  /// <summary>
  /// Represents a batch of files attached to a vector store in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class provides details about a file batch within a vector store, including its creation timestamp,
  /// status, and the number of files processed. It is used to monitor and manage the batch processing of files
  /// for indexing and retrieval in the vector store.
  /// </remarks>
  TVectorStoreBatch = GenAI.VectorBatch.TVectorStoreBatch;

  /// <summary>
  /// Represents a list of file batches attached to a vector store in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TAdvancedList&lt;TVectorStoreBatch&gt;</c> and provides an iterable
  /// collection of file batches within a vector store. Each batch contains information such as
  /// its status, creation timestamp, and file counts.
  /// </remarks>
  TVectorStoreBatches = GenAI.VectorBatch.TVectorStoreBatches;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TVectorStoreBatch</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynVectorStoreBatch</c> type extends the <c>TAsynParams&lt;TVectorStoreBatch&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynVectorStoreBatch = GenAI.VectorBatch.TAsynVectorStoreBatch;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TVectorStoreBatches</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynVectorStoreBatches</c> type extends the <c>TAsynParams&lt;TVectorStoreBatches&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynVectorStoreBatches = GenAI.VectorBatch.TAsynVectorStoreBatches;

  {$ENDREGION}

  {$REGION 'GenAI.Chat.Parallel'}

  /// <summary>
  /// Represents an item in a bundle of chat prompts and responses.
  /// </summary>
  /// <remarks>
  /// This class stores information about a single chat request, including its index,
  /// associated prompt, generated response, and related chat object.
  /// It is used within a <c>TBundleList</c> to manage multiple asynchronous chat requests.
  /// </remarks>
  TBundleItem = GenAI.Chat.Parallel.TBundleItem;

  /// <summary>
  /// Manages a collection of <c>TBundleItem</c> objects.
  /// </summary>
  /// <remarks>
  /// This class provides methods to add, retrieve, and count items in a bundle.
  /// It is designed to store multiple chat request items processed in parallel.
  /// The internal storage uses a <c>TObjectList&lt;TBundleItem&gt;</c> with automatic memory management.
  /// </remarks>
  TBundleList = GenAI.Chat.Parallel.TBundleList;

  /// <summary>
  /// Represents an asynchronous callback buffer for handling chat responses.
  /// </summary>
  /// <remarks>
  /// This class is a specialized type used to manage asynchronous operations
  /// related to chat request processing. It inherits from <c>TAsynCallBack&lt;TBundleList&gt;</c>,
  /// enabling structured handling of callback events.
  /// </remarks>
  TAsynBundleList = GenAI.Chat.Parallel.TAsynBundleList;
  TAsynBuffer = TAsynBundleList; //deprecated : naming error

  /// <summary>
  /// Represents the parameters used for configuring a chat request bundle.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TParameters</c> and provides specific methods for setting chat-related
  /// parameters, such as prompts, model selection, and reasoning effort.
  /// It is used to structure and pass multiple requests efficiently in parallel processing.
  /// </remarks>
  TBundleParams = GenAI.Chat.Parallel.TBundleParams;

  {$ENDREGION}

  {$REGION 'GenAI.Responses.InputParams'}

  TItemContent = GenAI.Responses.InputParams.TItemContent;

  TInputListItem = GenAI.Responses.InputParams.TInputListItem;

  TInputMessage = GenAI.Responses.InputParams.TInputMessage;

  TItemInputMessage = GenAI.Responses.InputParams.TItemInputMessage;

  TInputItemReference = GenAI.Responses.InputParams.TInputItemReference;

  TOutputNotation = GenAI.Responses.InputParams.TOutputNotation;

  TOutputMessageContent = GenAI.Responses.InputParams.TOutputMessageContent;

  TItemOutputMessage = GenAI.Responses.InputParams.TItemOutputMessage;

  TFileSearchToolCallResult = GenAI.Responses.InputParams.TFileSearchToolCallResult;

  TFileSearchToolCall = GenAI.Responses.InputParams.TFileSearchToolCall;

  TPendingSafetyCheck = GenAI.Responses.InputParams.TPendingSafetyCheck;

  TAcknowledgedSafetyCheckParams = GenAI.Responses.InputParams.TAcknowledgedSafetyCheckParams;

  TComputerToolCallOutputObject = GenAI.Responses.InputParams.TComputerToolCallOutputObject;

  TComputerToolCallAction = GenAI.Responses.InputParams.TComputerToolCallAction;

  TComputerClick = GenAI.Responses.InputParams.TComputerClick;

  TComputerDoubleClick = GenAI.Responses.InputParams.TComputerDoubleClick;

  TComputerToolCallOutput = GenAI.Responses.InputParams.TComputerToolCallOutput;

  TWebSearchToolCall = GenAI.Responses.InputParams.TWebSearchToolCall;

  TFunctionToolCall = GenAI.Responses.InputParams.TFunctionToolCall;

  TFunctionToolCalloutput = GenAI.Responses.InputParams.TFunctionToolCalloutput;

  TReasoningTextContent = GenAI.Responses.InputParams.TReasoningTextContent;

  TReasoningObject = GenAI.Responses.InputParams.TReasoningObject;

  TComputerToolCall = GenAI.Responses.InputParams.TComputerToolCall;

  {$ENDREGION}

  {$REGION 'GenAI.Responses.InputItemList'}

  TFileSearchResult = GenAI.Responses.InputItemList.TFileSearchResult;

  TDragPoint = GenAI.Responses.InputItemList.TDragPoint;

  TPendingSafetyChecks = GenAI.Responses.InputItemList.TPendingSafetyChecks;

  TComputerOutput = GenAI.Responses.InputItemList.TComputerOutput;

  TAcknowledgedSafetyCheck = GenAI.Responses.InputItemList.TAcknowledgedSafetyCheck;

  TComputerActionCommon = GenAI.Responses.InputItemList.TComputerActionCommon;

  TComputerActionClick = GenAI.Responses.InputItemList.TComputerActionClick;

  TComputerActionDoubleClick = GenAI.Responses.InputItemList.TComputerActionDoubleClick;

  TComputerActionDrag = GenAI.Responses.InputItemList.TComputerActionDrag;

  TComputerActionKeyPressed = GenAI.Responses.InputItemList.TComputerActionKeyPressed;

  TComputerActionMove = GenAI.Responses.InputItemList.TComputerActionMove;

  TComputerActionScreenshot = GenAI.Responses.InputItemList.TComputerActionScreenshot;

  TComputerActionScroll = GenAI.Responses.InputItemList.TComputerActionScroll;

  TComputerActionType = GenAI.Responses.InputItemList.TComputerActionType;

  TComputerActionWait = GenAI.Responses.InputItemList.TComputerActionWait;

  TComputerAction = GenAI.Responses.InputItemList.TComputerAction;

  TResponseMessageAnnotationCommon = GenAI.Responses.InputItemList.TResponseMessageAnnotationCommon;

  TAnnotationFileCitation = GenAI.Responses.InputItemList.TAnnotationFileCitation;

  TAnnotationUrlCitation = GenAI.Responses.InputItemList.TAnnotationUrlCitation;

  TAnnotationFilePath = GenAI.Responses.InputItemList.TAnnotationFilePath;

  TResponseMessageAnnotation = GenAI.Responses.InputItemList.TResponseMessageAnnotation;

  TResponseItemContentCommon = GenAI.Responses.InputItemList.TResponseItemContentCommon;

  TResponseItemContentTextInput = GenAI.Responses.InputItemList.TResponseItemContentTextInput;

  TResponseItemContentImageInput = GenAI.Responses.InputItemList.TResponseItemContentImageInput;

  TResponseItemContentFileInput = GenAI.Responses.InputItemList.TResponseItemContentFileInput;

  TResponseItemContentOutputText = GenAI.Responses.InputItemList.TResponseItemContentOutputText;

  TResponseItemContentRefusal = GenAI.Responses.InputItemList.TResponseItemContentRefusal;

  TResponseItemContent = GenAI.Responses.InputItemList.TResponseItemContent;

  TResponseItemCommon = GenAI.Responses.InputItemList.TResponseItemCommon;

  TResponseItemInputMessage = GenAI.Responses.InputItemList.TResponseItemInputMessage;

  TResponseItemOutputMessage = GenAI.Responses.InputItemList.TResponseItemOutputMessage;

  TResponseItemFileSearchToolCall = GenAI.Responses.InputItemList.TResponseItemFileSearchToolCall;

  TResponseItemComputerToolCall = GenAI.Responses.InputItemList.TResponseItemComputerToolCall;

  TResponseItemComputerToolCallOutput = GenAI.Responses.InputItemList.TResponseItemComputerToolCallOutput;

  TResponseItemWebSearchToolCall = GenAI.Responses.InputItemList.TResponseItemWebSearchToolCall;

  TResponseItemFunctionToolCall = GenAI.Responses.InputItemList.TResponseItemFunctionToolCall;

  TResponseItemFunctionToolCallOutput = GenAI.Responses.InputItemList.TResponseItemFunctionToolCallOutput;

  TResponseItem = GenAI.Responses.InputItemList.TResponseItem;

  TResponses = GenAI.Responses.InputItemList.TResponses;

  {$ENDREGION}

  {$REGION 'GenAI.Responses'}

  TReasoningParams = GenAI.Responses.TReasoningParams;

  TTextFormatParams = GenAI.Responses.TTextFormatParams;

  TTextFormatTextPrams = GenAI.Responses.TTextFormatTextPrams;

  TTextJSONSchemaParams = GenAI.Responses.TTextJSONSchemaParams;

  TTextJSONObjectParams = GenAI.Responses.TTextJSONObjectParams;

  TTextParams = GenAI.Responses.TTextParams;

  TResponseToolChoiceParams = GenAI.Responses.TResponseToolChoiceParams;

  THostedToolParams = GenAI.Responses.THostedToolParams;

  TFunctionToolParams = GenAI.Responses.TFunctionToolParams;

  TFileSearchFilters = GenAI.Responses.TFileSearchFilters;

  TComparisonFilter = GenAI.Responses.TComparisonFilter;

  TCompoundFilter = GenAI.Responses.TCompoundFilter;

  TResponseToolParams = GenAI.Responses.TResponseToolParams;

  TResponseFileSearchParams = GenAI.Responses.TResponseFileSearchParams;

  TResponseFunctionParams = GenAI.Responses.TResponseFunctionParams;

  TResponseComputerUseParams = GenAI.Responses.TResponseComputerUseParams;

  TResponseUserLocationParams = GenAI.Responses.TResponseUserLocationParams;

  TResponseWebSearchParams = GenAI.Responses.TResponseWebSearchParams;

  TResponsesParams = GenAI.Responses.TResponsesParams;

  TResponseError = GenAI.Responses.TResponseError;

  TResponseIncompleteDetails = GenAI.Responses.TResponseIncompleteDetails;

  TResponseMessageContentCommon = GenAI.Responses.TResponseMessageContentCommon;

  TResponseMessageContent = GenAI.Responses.TResponseMessageContent;

  TResponseMessageRefusal = GenAI.Responses.TResponseMessageRefusal;

  TResponseContent = GenAI.Responses.TResponseContent;

  TResponseReasoningSummary = GenAI.Responses.TResponseReasoningSummary;

  TResponseReasoning = GenAI.Responses.TResponseReasoning;

  TResponseRankingOptions = GenAI.Responses.TResponseRankingOptions;

  TResponseFileSearchFiltersCommon = GenAI.Responses.TResponseFileSearchFiltersCommon;

  TResponseFileSearchFiltersComparaison = GenAI.Responses.TResponseFileSearchFiltersComparaison;

  TResponseFileSearchFiltersCompound = GenAI.Responses.TResponseFileSearchFiltersCompound;

  TResponseFileSearchFilters = GenAI.Responses.TResponseFileSearchFilters;

  TResponseWebSearchLocation = GenAI.Responses.TResponseWebSearchLocation;

  TResponseOutputCommon = GenAI.Responses.TResponseOutputCommon;

  TResponseOutputMessage = GenAI.Responses.TResponseOutputMessage;

  TResponseOutputFileSearch = GenAI.Responses.TResponseOutputFileSearch;

  TResponseOutputFunction = GenAI.Responses.TResponseOutputFunction;

  TResponseOutputWebSearch = GenAI.Responses.TResponseOutputWebSearch;

  TResponseOutputComputer = GenAI.Responses.TResponseOutputComputer;

  TResponseOutputReasoning = GenAI.Responses.TResponseOutputReasoning;

  TResponseOutput = GenAI.Responses.TResponseOutput;

  TResponseTextFormatCommon = GenAI.Responses.TResponseTextFormatCommon;

  TResponseFormatText = GenAI.Responses.TResponseFormatText;

  TResponseFormatJSONObject = GenAI.Responses.TResponseFormatJSONObject;

  TResponseFormatJSONSchema = GenAI.Responses.TResponseFormatJSONSchema;

  TResponseTextFormat = GenAI.Responses.TResponseTextFormat;

  TResponseText = GenAI.Responses.TResponseText;

  TResponseToolCommon = GenAI.Responses.TResponseToolCommon;

  TResponseToolFileSearch = GenAI.Responses.TResponseToolFileSearch;

  TResponseToolFunction = GenAI.Responses.TResponseToolFunction;

  TResponseToolComputerUse = GenAI.Responses.TResponseToolComputerUse;

  TResponseToolWebSearch = GenAI.Responses.TResponseToolWebSearch;

  TResponseTool = GenAI.Responses.TResponseTool;

  TInputTokensDetails = GenAI.Responses.TInputTokensDetails;

  TOutputTokensDetails = GenAI.Responses.TOutputTokensDetails;

  TResponseUsage = GenAI.Responses.TResponseUsage;

  TResponse = GenAI.Responses.TResponse;

  TUrlIncludeParams = GenAI.Responses.TUrlIncludeParams;

  TUrlResponseListParams = GenAI.Responses.TUrlResponseListParams;

  TResponseDelete = GenAI.Responses.TResponseDelete;

  TResponseStreamingCommon = GenAI.Responses.TResponseStreamingCommon;

  TResponseCreated = GenAI.Responses.TResponseCreated;

  TResponseInProgress = GenAI.Responses.TResponseInProgress;

  TResponseCompleted = GenAI.Responses.TResponseCompleted;

  TResponseFailed = GenAI.Responses.TResponseFailed;

  TRresponseIncomplete = GenAI.Responses.TRresponseIncomplete;

  TResponseOutputItemAdded = GenAI.Responses.TResponseOutputItemAdded;

  TResponseOutputItemDone = GenAI.Responses.TResponseOutputItemDone;

  TResponseContentpartAdded = GenAI.Responses.TResponseContentpartAdded;

  TResponseContentpartDone = GenAI.Responses.TResponseContentpartDone;

  TResponseOutputTextDelta = GenAI.Responses.TResponseOutputTextDelta;

  TResponseOutputTextAnnotationAdded = GenAI.Responses.TResponseOutputTextAnnotationAdded;

  TResponseOutputTextDone = GenAI.Responses.TResponseOutputTextDone;

  TResponseRefusalDelta = GenAI.Responses.TResponseRefusalDelta;

  TResponseRefusalDone = GenAI.Responses.TResponseRefusalDone;

  TResponseFunctionCallArgumentsDelta = GenAI.Responses.TResponseFunctionCallArgumentsDelta;

  TResponseFunctionCallArgumentsDone = GenAI.Responses.TResponseFunctionCallArgumentsDone;

  TResponseFileSearchCallInprogress = GenAI.Responses.TResponseFileSearchCallInprogress;

  TResponseFileSearchCallSearching = GenAI.Responses.TResponseFileSearchCallSearching;

  TResponseFileSearchCallCompleted = GenAI.Responses.TResponseFileSearchCallCompleted;

  TResponseWebSearchCallInprogress = GenAI.Responses.TResponseWebSearchCallInprogress;

  TResponseWebSearchCallSearching = GenAI.Responses.TResponseWebSearchCallSearching;

  TResponseWebSearchCallCompleted = GenAI.Responses.TResponseWebSearchCallCompleted;

  TResponseStreamError = GenAI.Responses.TResponseStreamError;

  TResponseStream = GenAI.Responses.TResponseStream;

  TResponseEvent = GenAI.Responses.TResponseEvent;

  TAsynResponse = GenAI.Responses.TAsynResponse;

  TAsynResponseStream = GenAI.Responses.TAsynResponseStream;

  TAsynResponseDelete = GenAI.Responses.TAsynResponseDelete;

  TAsynResponses = GenAI.Responses.TAsynResponses;

  {$ENDREGION}

function FromDeveloper(const Content: string; const Name: string = ''):TMessagePayload;
function FromSystem(const Content: string; const Name: string = ''):TMessagePayload;
function FromUser(const Content: string; const Name: string = ''):TMessagePayload; overload;
function FromUser(const Content: string; const Docs: TArray<string>; const Name: string = ''):TMessagePayload; overload;
function FromUser(const Docs: TArray<string>; const Name: string = ''):TMessagePayload; overload;
function FromAssistant(const ParamProc: TProcRef<TMessagePayload>): TMessagePayload; overload;
function FromAssistant(const Value: TMessagePayload): TMessagePayload; overload;
function FromAssistant(const Value: string): TMessagePayload; overload;
function FromAssistantAudioId(const Value: string): TMessagePayload;
function FromTool(const Content: string; const ToolCallId: string): TMessagePayload;

function ToolCall(const Id: string; const Name: string; const Arguments: string): TToolCallsParams;
function PredictionPart(const AType: string; const Text: string): TPredictionPartParams;
function ToolName(const Name: string): TToolChoiceParams;

function Code_interpreter: TAssistantsToolsParams; overload;
function Code_interpreter(const FileIds: TArray<string>): TToolResourcesParams; overload;

function RankingOptions(const ScoreThreshold: Double; const Ranker: string = 'auto'): TRankingOptionsParams;

function Vector_store(const FileIds: TArray<string>;
  const Metadata: TJSONObject = nil): TVectorStoresParams; overload;
function Vector_store(const FileIds: TArray<string>;
  const ChunkingStrategy: TChunkingStrategyParams;
  const Metadata: TJSONObject = nil): TVectorStoresParams; overload;

function web_search_preview(const SearchWebOption: string = ''): TResponseWebSearchParams;
function Locate: TResponseUserLocationParams;
function file_search(const vector_store_ids: TArray<string> = []): TResponseFileSearchParams;


function HttpMonitoring: IRequestMonitor;

var
  JSONLChatReader: GenAI.Batch.Interfaces.IJSONLReader<TChat>;
  JSONLEmbeddingReader: GenAI.Batch.Interfaces.IJSONLReader<TEmbeddings>;
  BatchBuilder: GenAI.Batch.Interfaces.IBatchJSONBuilder;

implementation

function FromDeveloper(const Content: string; const Name: string = ''):TMessagePayload;
begin
  Result := TMessagePayload.Developer(Content, Name);
end;

function FromSystem(const Content: string; const Name: string = ''):TMessagePayload;
begin
  Result := TMessagePayload.System(Content, Name);
end;

function FromUser(const Content: string; const Name: string = ''):TMessagePayload;
begin
  Result := TMessagePayload.User(Content, Name);
end;

function FromUser(const Content: string; const Docs: TArray<string>; const Name: string = ''):TMessagePayload;
begin
  Result := TMessagePayload.User(Content, Docs, Name);
end;

function FromUser(const Docs: TArray<string>;
  const Name: string = ''):TMessagePayload;
begin
  Result := TMessagePayload.User(Docs, Name);
end;

function FromAssistant(const ParamProc: TProcRef<TMessagePayload>): TMessagePayload;
begin
  Result := TMessagePayload.Assistant(ParamProc);
end;

function FromAssistant(const Value: TMessagePayload): TMessagePayload;
begin
  Result := TMessagePayload.Assistant(Value);
end;

function FromAssistant(const Value: string): TMessagePayload; overload;
begin
  Result := TMessagePayload.Assistant(Value);
end;

function FromAssistantAudioId(const Value: string): TMessagePayload;
begin
  Result := TMessagePayload.AssistantAudioId(Value);
end;

function FromTool(const Content: string; const ToolCallId: string): TMessagePayload;
begin
  Result := TMessagePayload.Tool(content, ToolCallId);
end;

function ToolCall(const Id: string; const Name: string; const Arguments: string): TToolCallsParams;
begin
  Result := TToolCallsParams.New(Id, Name, Arguments);
end;

function PredictionPart(const AType: string; const Text: string): TPredictionPartParams;
begin
  Result := TPredictionPartParams.New(AType, Text);
end;

function ToolName(const Name: string): TToolChoiceParams;
begin
  Result := TToolChoiceParams.New(Name);
end;

function Code_interpreter: TAssistantsToolsParams;
begin
  Result := TAssistantsToolsParams.Create.&Type(TAssistantsToolsType.code_interpreter);
end;

function Code_interpreter(const FileIds: TArray<string>): TToolResourcesParams;
begin
  Result := TToolResourcesParams.Create.CodeInterpreter(FileIds);
end;

function RankingOptions(const ScoreThreshold: Double; const Ranker: string = 'auto'): TRankingOptionsParams;
begin
  Result := TRankingOptionsParams.Create.Ranker(Ranker).ScoreThreshold(ScoreThreshold);
end;

function Vector_store(const FileIds: TArray<string>; const Metadata: TJSONObject): TVectorStoresParams;
begin
  if Length(FileIds) = 0 then
    raise Exception.Create('File Ids can''t be null');
  Result := TVectorStoresParams.Create.FileIds(FileIds);
  if Assigned(Metadata) then
    Result := Result.Metadata(Metadata);
end;

function Vector_store(const FileIds: TArray<string>;
  const ChunkingStrategy: TChunkingStrategyParams;
  const Metadata: TJSONObject = nil): TVectorStoresParams; overload;
begin
  Result := Vector_store(FileIds, Metadata).ChunkingStrategy(ChunkingStrategy);
end;

function web_search_preview(const SearchWebOption: string): TResponseWebSearchParams;
begin
  Result := TResponseWebSearchParams.New;
  if not SearchWebOption.Trim.IsEmpty then
    Result.SearchContextSize(SearchWebOption);
end;

function Locate: TResponseUserLocationParams;
begin
  Result := TResponseUserLocationParams.New;
end;

function file_search(const vector_store_ids: TArray<string>): TResponseFileSearchParams;
begin
  Result := TResponseFileSearchParams.New;
  if Length(vector_store_ids) > 0 then
    Result.VectorStoreIds(vector_store_ids);
end;

function HttpMonitoring: IRequestMonitor;
begin
  Result := Monitoring;
end;

{ TGenAI }

constructor TGenAI.Create;
begin
  inherited;
  FAPI := TGenAIAPI.Create;
end;

constructor TGenAI.Create(const AAPIKey: string);
begin
  Create;
  APIKey := AAPIKey;
end;

destructor TGenAI.Destroy;
begin
  FAssistantsRoute.Free;
  FAudioRoute.Free;
  FBatchRoute.Free;
  FChatRoute.Free;
  FCompletionRoute.Free;
  FEmbeddingsRoute.Free;
  FFilesRoute.Free;
  FFineTuningRoute.Free;
  FImagesRoute.Free;
  FMessagesRoute.Free;
  FModelsRoute.Free;
  FModerationRoute.Free;
  FRunsRoute.Free;
  FRunStepRoute.Free;
  FThreadsRoute.Free;
  FUploadsRoute.Free;
  FVectorStoreRoute.Free;
  FVectorStoreBatchRoute.Free;
  FVectorStoreFilesRoute.Free;
  FResponsesRoute.Free;
  FAPI.Free;
  inherited;
end;

function TGenAI.GetAPI: TGenAIAPI;
begin
  Result := FAPI;
end;

function TGenAI.GetAudioRoute: TAudioRoute;
begin
  if not Assigned(FAudioRoute) then
    FAudioRoute := TAudioRoute.CreateRoute(API);
  Result := FAudioRoute;
end;

function TGenAI.GetBaseUrl: string;
begin
  Result := FAPI.BaseURL;
end;

function TGenAI.GetBatchRoute: TBatchRoute;
begin
  if not Assigned(FBatchRoute) then
    FBatchRoute := TBatchRoute.CreateRoute(API);
  Result := FBatchRoute;
end;

function TGenAI.GetEmbeddingsRoute: TEmbeddingsRoute;
begin
  if not Assigned(FEmbeddingsRoute) then
    FEmbeddingsRoute := TEmbeddingsRoute.CreateRoute(API);
  Result := FEmbeddingsRoute;
end;

function TGenAI.GetFilesRoute: TFilesRoute;
begin
  if not Assigned(FFilesRoute) then
    FFilesRoute := TFilesRoute.CreateRoute(API);
  Result := FFilesRoute;
end;

function TGenAI.GetFineTuningRoute: TFineTuningRoute;
begin
  if not Assigned(FFineTuningRoute) then
    FFineTuningRoute := TFineTuningRoute.CreateRoute(API);
  Result := FFineTuningRoute;
end;

function TGenAI.GetImagesRoute: TImagesRoute;
begin
  if not Assigned(FImagesRoute) then
    FImagesRoute := TImagesRoute.CreateRoute(API);
  Result := FImagesRoute;
end;

function TGenAI.GetMesssagesRoute: TMessagesRoute;
begin
  if not Assigned(FMessagesRoute) then
    FMessagesRoute := TMessagesRoute.CreateRoute(API);
  Result := FMessagesRoute;
end;

function TGenAI.GetModelsRoute: TModelsRoute;
begin
  if not Assigned(FModelsRoute) then
    FModelsRoute := TModelsRoute.CreateRoute(API);
  Result := FModelsRoute;
end;

function TGenAI.GetModerationRoute: TModerationRoute;
begin
  if not Assigned(FModerationRoute) then
    FModerationRoute := TModerationRoute.CreateRoute(API);
  Result := FModerationRoute;
end;

function TGenAI.GetResponses: TResponsesRoute;
begin
  if not Assigned(FResponsesRoute) then
    FResponsesRoute := TResponsesRoute.CreateRoute(API);
  Result := FResponsesRoute;
end;

function TGenAI.GetRunsRoute: TRunsRoute;
begin
  if not Assigned(FRunsRoute) then
    FRunsRoute := TRunsRoute.CreateRoute(API);
  Result := FRunsRoute;
end;

function TGenAI.GetRunStepRoute: TRunStepRoute;
begin
  if not Assigned(FRunStepRoute) then
    FRunStepRoute := TRunStepRoute.CreateRoute(API);
  Result := FRunStepRoute;
end;

function TGenAI.GetThreadsRoute: TThreadsRoute;
begin
  if not Assigned(FThreadsRoute) then
    FThreadsRoute := TThreadsRoute.CreateRoute(API);
  Result := FThreadsRoute;
end;

function TGenAI.GetUploadsRoute: TUploadsRoute;
begin
  if not Assigned(FUploadsRoute) then
    FUploadsRoute := TUploadsRoute.CreateRoute(API);
  Result := FUploadsRoute;
end;

function TGenAI.GetVectorStoreBatchRoute: TVectorStoreBatchRoute;
begin
  if not Assigned(FVectorStoreBatchRoute) then
    FVectorStoreBatchRoute := TVectorStoreBatchRoute.CreateRoute(API);
  Result := FVectorStoreBatchRoute;
end;

function TGenAI.GetVectorStoreFilesRoute: TVectorStoreFilesRoute;
begin
  if not Assigned(FVectorStoreFilesRoute) then
    FVectorStoreFilesRoute := TVectorStoreFilesRoute.CreateRoute(API);
  Result := FVectorStoreFilesRoute;
end;

function TGenAI.GetVectorStoreRoute: TVectorStoreRoute;
begin
  if not Assigned(FVectorStoreRoute) then
    FVectorStoreRoute := TVectorStoreRoute.CreateRoute(API);
  Result := FVectorStoreRoute;
end;

function TGenAI.GetChatRoute: TChatRoute;
begin
  if not Assigned(FChatRoute) then
    FChatRoute := TChatRoute.CreateRoute(API);
  Result := FChatRoute;
end;

function TGenAI.GetCompletionRoute: TCompletionRoute;
begin
  if not Assigned(FCompletionRoute) then
    FCompletionRoute := TCompletionRoute.CreateRoute(API);
  Result := FCompletionRoute;
end;

function TGenAI.GetAPIKey: string;
begin
  Result := FAPI.APIKey;
end;

function TGenAI.GetAssistantsRoute: TAssistantsRoute;
begin
  if not Assigned(FAssistantsRoute) then
    FAssistantsRoute := TAssistantsRoute.CreateRoute(API);
  Result := FAssistantsRoute;
end;

procedure TGenAI.SetBaseUrl(const Value: string);
begin
  FAPI.BaseURL := Value;
end;

procedure TGenAI.SetAPIKey(const Value: string);
begin
  FAPI.APIKey := Value;
end;

{ TGenAIFactory }

class function TGenAIFactory.CreateInstance(const AAPIKey: string): IGenAI;
begin
  Result := TGenAI.Create(AAPIKey);
end;

initialization
  JSONLChatReader := TJSONLReader<TChat>.CreateInstance;
  JSONLEmbeddingReader := TJSONLReader<TEmbeddings>.CreateInstance;
  BatchBuilder := TBatchJSONBuilder.Create;
end.

unit GenAI.Responses.Helpers;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.StrUtils, GenAI.NetEncoding.Base64, GenAI.Httpx, GenAI.Consts;

type
  /// <summary>
  /// Provides helper methods for determining MIME types, extracting file names and details,
  /// and checking if a MIME type corresponds to an image or PDF document.
  /// </summary>
  TFormatHelper = record
    const S_DETAIL = 'detail=';
    const S_FILEID = 'file_id';
    /// <summary>
    /// Retrieves the MIME type for the given file location or URL and extracts any detail parameter.
    /// </summary>
    /// <param name="FileLocation">The path or URL of the file, optionally containing a "detail=" parameter.</param>
    /// <param name="Detail">Output parameter that receives the detail string if present; otherwise returns an empty string.</param>
    /// <returns>The MIME type as a string, or "file_id" for unknown or remote identifiers.</returns>
    class function GetMimeType(const FileLocation: string; var Detail: string): string; overload; static;
    /// <summary>
    /// Retrieves the MIME type for the given file location or URL.
    /// </summary>
    /// <param name="FileLocation">The path or URL of the file.</param>
    /// <returns>The MIME type as a string, or "file_id" if the file does not exist locally.</returns>
    class function GetMimeType(const FileLocation: string): string; overload; static;
    /// <summary>
    /// Extracts the base file name and detail parameter from a file location string.
    /// </summary>
    /// <param name="FileLocation">The full file location, potentially including a "detail=" query segment.</param>
    /// <param name="Detail">Output parameter that receives the detail value if found; otherwise returns an empty string.
    /// </param>
    /// <returns>The base file name or URL without the detail segment.</returns>
    class function ExtractFileName(const FileLocation: string; var Detail: string): string; static;
    /// <summary>
    /// Checks if the specified MIME type represents a PDF document.
    /// </summary>
    /// <param name="MimeType">The MIME type to check.</param>
    /// <returns>True if the MIME type corresponds to a PDF; otherwise False.</returns>
    class function IsPDFDocument(const MimeType: string): Boolean; static;
    /// <summary>
    /// Checks if the specified MIME type represents an accepted image document.
    /// </summary>
    /// <param name="MimeType">The MIME type to check.</param>
    /// <returns>True if the MIME type corresponds to an image; otherwise False.</returns>
    class function IsImageDocument(const MimeType: string): Boolean; static;
  end;

implementation

{ TFormatHelper }

class function TFormatHelper.ExtractFileName(const FileLocation: string;
  var Detail: string): string;
begin
  var index := FileLocation.Trim.ToLower.IndexOf(S_DETAIL);
  if index > -1 then
    begin
      Detail := FileLocation.Trim.ToLower.Substring(index + length(S_DETAIL)).Trim;
      Result := FileLocation.Trim.ToLower.Substring(0, index - 1).Trim;
    end
  else
    begin
      Detail := EmptyStr;
      Result := FileLocation;
    end;
end;

class function TFormatHelper.GetMimeType(const FileLocation: string;
  var Detail: string): string;
begin
  var Filename := ExtractFileName(FileLocation, Detail);

  {--- Retrieve MimeType }
  if Filename.ToLower.StartsWith('http') then
    begin
      THttpx.UrlCheck(Filename);
      Result := THttpx.GetMimeType(Filename)
    end
  else
  if FileExists(FileName) then
    begin
      Result := GenAI.NetEncoding.Base64.GetMimeType(Filename);
    end
  else
    Result := S_FILEID;
end;

class function TFormatHelper.GetMimeType(const FileLocation: string): string;
var
  Detail: string;
begin
  Result := GetMimeType(FileLocation, Detail);
end;

class function TFormatHelper.IsImageDocument(const MimeType: string): Boolean;
begin
  Result := IndexStr(MimeType.Trim.ToLower, ImageTypeAccepted) <> -1;
end;

class function TFormatHelper.IsPDFDocument(const MimeType: string): Boolean;
begin
  Result := IndexStr(MimeType.Trim.ToLower, DocTypeAccepted) <> -1;
end;

end.

unit GenAI.Responses.InputItemList;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Threading, System.JSON, REST.Json.Types,
  REST.JsonReflect,
  GenAI.API.Params, GenAI.API, GenAI.Consts, GenAI.Schema, GenAI.Types,
  GenAI.Async.Params, GenAI.Async.Support, GenAI.Assistants;

type
  TFileSearchResult = class
  private
    [JsonReflectAttribute(ctString, rtString, TMetadataInterceptor)]
    FAttributes: string;
    [JsonNameAttribute('file_id')]
    FFileId: string;
    FFilename: string;
    FScore: Double;
    FText: string;
  public
    /// <summary>
    /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information
    /// about the object in a structured format, and querying for objects via API or the dashboard. Keys are strings with
    /// a maximum length of 64 characters. Values are strings with a maximum length of 512 characters, booleans, or numbers.
    /// </summary>
    property Attributes: string read FAttributes write FAttributes;
    /// <summary>
    /// The unique ID of the file.
    /// </summary>
    property FileId: string read FFileId write FFileId;
    /// <summary>
    /// The name of the file.
    /// </summary>
    property Filename: string read FFilename write FFilename;
    /// <summary>
    /// The relevance score of the file - a value between 0 and 1.
    /// </summary>
    property Score: Double read FScore write FScore;
    /// <summary>
    /// The text that was retrieved from the file.
    /// </summary>
    property Text: string read FText write FText;
  end;

  TDragPoint = class
  private
    FX: Int64;
    FY: Int64;
  public
    /// <summary>
    /// The x-coordinate.
    /// </summary>
    property X: Int64 read FX write FX;
    /// <summary>
    /// The y-coordinate.
    /// </summary>
    property Y: Int64 read FY write FY;
  end;

  TPendingSafetyChecks = class
  private
    FCode: string;
    FId: string;
    FMessage: string;
  public
    /// <summary>
    /// The type of the pending safety check.
    /// </summary>
    property Code: string read FCode write FCode;
    /// <summary>
    /// The ID of the pending safety check.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Details about the pending safety check.
    /// </summary>
    property Message: string read FMessage write FMessage;
  end;

  TComputerOutput = class
  private
    FType: string;
    [JsonNameAttribute('file_id')]
    FFileId: string;
    [JsonNameAttribute('image_url')]
    FImageUrl: string;
  public
    /// <summary>
    /// The identifier of an uploaded file that contains the screenshot.
    /// </summary>
    property FileId: string read FFileId write FFileId;
    /// <summary>
    /// The URL of the screenshot image.
    /// </summary>
    property ImageUrl: string read FImageUrl write FImageUrl;
    /// <summary>
    /// Specifies the event type. For a computer screenshot, this property is always set to computer_screenshot.
    /// </summary>
    property &Type: string read FType write FType;
  end;

  TAcknowledgedSafetyCheck = class
  private
    FCode: string;
    FId: string;
    FMessage: string;
  public
    /// <summary>
    /// The type of the pending safety check.
    /// </summary>
    property Code: string read FCode write FCode;
    /// <summary>
    /// The ID of the pending safety check.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Details about the pending safety check.
    /// </summary>
    property Message: string read FMessage write FMessage;
  end;

  TComputerActionCommon = class
  private
    [JsonReflectAttribute(ctString, rtString, TResponseComputerTypeInterceptor)]
    FType: TResponseComputerType;
  public
    /// <summary>
    /// Specifies the event type.
    /// </summary>
    property &Type: TResponseComputerType read FType write FType;
  end;

  TComputerActionClick = class(TComputerActionCommon)
  private
    [JsonReflectAttribute(ctString, rtString, TMouseButtonInterceptor)]
    FButton: TMouseButton;
    FX: Int64;
    FY: Int64;
  public
    /// <summary>
    /// Indicates which mouse button was pressed during the click. One of left, right, wheel, back, or forward.
    /// </summary>
    property Button: TMouseButton read FButton write FButton;
    /// <summary>
    /// The x-coordinate where the click occurred.
    /// </summary>
    property X: Int64 read FX write FX;
    /// <summary>
    /// The y-coordinate where the click occurred.
    /// </summary>
    property Y: Int64 read FY write FY;
  end;

  TComputerActionDoubleClick = class(TComputerActionClick)
    {--- This class does not introduce any new functionality; all methods and properties
         are inherited from its ancestor. }
  end;

  TComputerActionDrag = class(TComputerActionDoubleClick)
  private
    FPath: TArray<TDragPoint>;
  public
    /// <summary>
    /// An array of coordinates representing the path of the drag action. Coordinates will appear as an array
    /// of objects, eg [ { x: 100, y: 200 }, { x: 200, y: 300 }
    /// </summary>
    property Path: TArray<TDragPoint> read FPath write FPath;
    destructor Destroy; override;
  end;

  TComputerActionKeyPressed = class(TComputerActionDrag)
  private
    FKeys: TArray<string>;
  public
    /// <summary>
    /// The combination of keys the model is requesting to be pressed. This is an array of strings, each representing a key.
    /// </summary>
    property Keys: TArray<string> read FKeys write FKeys;
  end;

  TComputerActionMove = class(TComputerActionKeyPressed)
    {--- This class does not introduce any new functionality; all methods and properties
         are inherited from its ancestor. }
  end;

  TComputerActionScreenshot = class(TComputerActionMove)
    {--- This class does not introduce any new functionality; all methods and properties
         are inherited from its ancestor. }
  end;

  TComputerActionScroll = class(TComputerActionScreenshot)
  private
     {--- X and Y are already described in TComputerActionClick }
    [JsonNameAttribute('scroll_x')]
    FScrollX: Int64;
    [JsonNameAttribute('scroll_y')]
    FScrollY: Int64;
  public
    /// <summary>
    /// The horizontal scroll distance.
    /// </summary>
    property ScrollX: Int64 read FScrollX write FScrollX;
    /// <summary>
    /// The vertical scroll distance.
    /// </summary>
    property ScrollY: Int64 read FScrollY write FScrollY;
  end;

  TComputerActionType = class(TComputerActionScroll)
  private
    FText: string;
  public
    /// <summary>
    /// The text to type.
    /// </summary>
    property Text: string read FText write FText;
  end;

  TComputerActionWait = class(TComputerActionType)
    {--- This class does not introduce any new functionality; all methods and properties
         are inherited from its ancestor. }
  end;

  {--- This class is made up of the following classes:
     TComputerActionCommon, TComputerActionClick, TComputerActionDoubleClick,
     TComputerActionDrag, TComputerActionKeyPressed, TComputerActionMove,
     TComputerActionScreenshot, TComputerActionScroll, TComputerActionType
     TComputerActionWait }
  TComputerAction = class(TComputerActionWait);

  TResponseMessageAnnotationCommon = class
  private
    [JsonReflectAttribute(ctString, rtString, TResponseAnnotationTypeInterceptor)]
    FType: TResponseAnnotationType;
  public
    /// <summary>
    /// The type of the file citation. One of file_citation, url_citation or file_path
    /// </summary>
    property &Type: TResponseAnnotationType read FType write FType;
  end;

  TAnnotationFileCitation = class(TResponseMessageAnnotationCommon)
  private
    [JsonNameAttribute('file_id')]
    FFileId: string;
    FIndex: Int64;
  public
    /// <summary>
    /// The ID of the file.
    /// </summary>
    property FileId: string read FFileId write FFileId;
    /// <summary>
    /// The index of the file in the list of files.
    /// </summary>
    property Index: Int64 read FIndex write FIndex;
  end;

  TAnnotationUrlCitation = class(TAnnotationFileCitation)
  private
    [JsonNameAttribute('end_index')]
    FEndIndex: Int64;
    [JsonNameAttribute('start_index')]
    FStartIndex: Int64;
    FTitle: string;
    FUrl: string;
  public
    /// <summary>
    /// The index of the last character of the URL citation in the message.
    /// </summary>
    property EndIndex: Int64 read FEndIndex write FEndIndex;
    /// <summary>
    /// The index of the first character of the URL citation in the message.
    /// </summary>
    property StartIndex: Int64 read FStartIndex write FStartIndex;
    /// <summary>
    /// The title of the web resource.
    /// </summary>
    property Title: string read FTitle write FTitle;
    /// <summary>
    /// The URL of the web resource.
    /// </summary>
    property Url: string read FUrl write FUrl;
  end;

  TAnnotationFilePath = class(TAnnotationUrlCitation)
    {--- This class does not introduce any new functionality; all methods and properties
         are inherited from its ancestor. }
  end;

  {--- This class is made up of the following classes:
     TResponseMessageAnnotationCommon, TAnnotationFileCitation, TAnnotationUrlCitation,
     TAnnotationFilePath }
  TResponseMessageAnnotation = class(TAnnotationFilePath);

  TResponseItemContentCommon = class
  private
    [JsonReflectAttribute(ctString, rtString, TResponseItemContentTypeInterceptor)]
    FType: TResponseItemContentType;
  public
    /// <summary>
    /// The type of the input item. One of input_text, input_image, input_file
    /// </summary>
    property &Type: TResponseItemContentType read FType write FType;
  end;

  TResponseItemContentTextInput = class(TResponseItemContentCommon)
  private
    FText: string;
  public
    /// <summary>
    /// The text input to the model.
    /// </summary>
    property Text: string read FText write FText;
  end;

  TResponseItemContentImageInput = class(TResponseItemContentTextInput)
  private
    [JsonReflectAttribute(ctString, rtString, TImageDetailInterceptor)]
    FDetail: TImageDetail;
    [JsonNameAttribute('file_id')]
    FFileId: string;
    [JsonNameAttribute('image_url')]
    FImageUrl: string;
  public
    /// <summary>
    /// The detail level of the image to be sent to the model. One of high, low, or auto. Defaults to auto.
    /// </summary>
    property Detail: TImageDetail read FDetail write FDetail;
    /// <summary>
    /// The ID of the file to be sent to the model.
    /// </summary>
    property FileId: string read FFileId write FFileId;
    /// <summary>
    /// The URL of the image to be sent to the model. A fully qualified URL or base64 encoded image in a data URL.
    /// </summary>
    property ImageUrl: string read FImageUrl write FImageUrl;
  end;

  TResponseItemContentFileInput = class(TResponseItemContentImageInput)
  private
    [JsonNameAttribute('file_data')]
    FFileData: string;
    FFilename: string;
  public
    /// <summary>
    /// The content of the file to be sent to the model.
    /// </summary>
    property FileData: string read FFileData write FFileData;
    /// <summary>
    /// The name of the file to be sent to the model.
    /// </summary>
    property Filename: string read FFilename write FFilename;
  end;

  TResponseItemContentOutputText = class(TResponseItemContentFileInput)
  private
    FAnnotations: TArray<TResponseMessageAnnotation>;
  public
    /// <summary>
    /// The annotations of the text output.
    /// </summary>
    property Annotations: TArray<TResponseMessageAnnotation> read FAnnotations write FAnnotations;
    destructor Destroy; override;
  end;

  TResponseItemContentRefusal = class(TResponseItemContentOutputText)
  private
    FRefusal: string;
  public
    /// <summary>
    /// The refusal explanationfrom the model.
    /// </summary>
    property Refusal: string read FRefusal write FRefusal;
  end;

  {--- This class is made up of the following classes:
     TResponseItemContentCommon, TResponseItemContentTextInput, TResponseItemContentImageInput,
     TResponseItemContentFileInput, TResponseItemContentOutputText, TResponseItemContentRefusal}
  TResponseItemContent = class(TResponseItemContentRefusal);

  TResponseItemCommon = class
  private
    FId: string;
    [JsonReflectAttribute(ctString, rtString, TResponseTypesInterceptor)]
    FType: TResponseTypes;
    FStatus: string;
  public
    /// <summary>
    /// The unique ID of the object.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// The status of item. One of in_progress, completed, or incomplete. Populated when items are returned via API.
    /// </summary>
    property Status: string read FStatus write FStatus;
    /// <summary>
    /// The type of the object input.
    /// </summary>
    property &Type: TResponseTypes read FType write FType;
  end;

  TResponseItemInputMessage = class(TResponseItemCommon)
  private
    [JsonReflectAttribute(ctString, rtString, TRoleInterceptor)]
    FRole: TRole;
    FContent: TArray<TResponseItemContent>;
  public
    /// <summary>
    /// The role of the message input. One of user, system, or developer.
    /// </summary>
    property Role: TRole read FRole write FRole;
    /// <summary>
    /// A list of one or many input items to the model, containing different content types.
    /// </summary>
    property Content: TArray<TResponseItemContent> read FContent write FContent;
    destructor Destroy; override;
  end;

  TResponseItemOutputMessage = class(TResponseItemInputMessage)
    {--- This class does not introduce any new functionality; all methods and properties
         are inherited from its ancestor. }
  end;

  TResponseItemFileSearchToolCall = class(TResponseItemOutputMessage)
  private
    FQueries: TArray<string>;
    FResults: TArray<TFileSearchResult>;
  public
    /// <summary>
    /// The queries used to search for files.
    /// </summary>
    property Queries: TArray<string> read FQueries write FQueries;
    /// <summary>
    /// The results of the file search tool call.
    /// </summary>
    property Results: TArray<TFileSearchResult> read FResults write FResults;
    destructor Destroy; override;
  end;

  TResponseItemComputerToolCall = class(TResponseItemFileSearchToolCall)
  private
    FAction: TComputerAction;
    [JsonNameAttribute('call_id')]
    FCallId: string;
    [JsonNameAttribute('pending_safety_checks')]
    FPendingSafetyChecks: TArray<TPendingSafetyChecks>;
  public
    /// <summary>
    /// Action to execute on computer
    /// </summary>
    property Action: TComputerAction read FAction write FAction;
    /// <summary>
    /// An identifier used when responding to the tool call with output.
    /// </summary>
    property CallId: string read FCallId write FCallId;
    /// <summary>
    /// The pending safety checks for the computer call.
    /// </summary>
    property PendingSafetyChecks: TArray<TPendingSafetyChecks> read FPendingSafetyChecks write FPendingSafetyChecks;
    destructor Destroy; override;
  end;

  TResponseItemComputerToolCallOutput = class(TResponseItemComputerToolCall)
  private
    FOutput: TComputerOutput;
    [JsonNameAttribute('acknowledged_safety_checks')]
    FAcknowledgedSafetyChecks: TArray<TAcknowledgedSafetyCheck>;
  public
    /// <summary>
    /// A computer screenshot image used with the computer use tool.
    /// </summary>
    property Output: TComputerOutput read FOutput write FOutput;
    /// <summary>
    /// The safety checks reported by the API that have been acknowledged by the developer.
    /// </summary>
    property AcknowledgedSafetyChecks: TArray<TAcknowledgedSafetyCheck> read FAcknowledgedSafetyChecks write FAcknowledgedSafetyChecks;
    destructor Destroy; override;
  end;

  TResponseItemWebSearchToolCall = class(TResponseItemComputerToolCallOutput)
    {--- This class does not introduce any new functionality; all methods and properties
         are inherited from its ancestor. }
  end;

  TResponseItemFunctionToolCall = class(TResponseItemWebSearchToolCall)
  private
    FArguments: string;
    FName: string;
  public
    /// <summary>
    /// A JSON string of the arguments to pass to the function.
    /// </summary>
    property Arguments: string read FArguments write FArguments;
    /// <summary>
    /// The name of the function to run.
    /// </summary>
    property Name: string read FName write FName;
  end;

  TResponseItemFunctionToolCallOutput = class(TResponseItemFunctionToolCall)
  private
//    FOutput: string;
  public
//    property Output: string read FOutput write FOutput;
  end;

  {--- This class is made up of the following classes:
    TResponseItemCommon, TResponseItemInputMessage, TResponseItemOutputMessage,
    TResponseItemFileSearchToolCall, TResponseItemComputerToolCall,
    TResponseItemComputerToolCallOutput, TResponseItemWebSearchToolCall,
    TResponseItemFunctionToolCall, TResponseItemFunctionToolCallOutput}
  TResponseItem = class(TResponseItemFunctionToolCallOutput);

  TResponses = class(TJSONFingerprint)
  private
    [JsonNameAttribute('first_id')]
    FFirstId: string;
    [JsonNameAttribute('has_more')]
    FHasMore: Boolean;
    [JsonNameAttribute('last_id')]
    FLastId: string;
    FObject: string;
    FData: TArray<TResponseItem>;
  public
    /// <summary>
    /// A list of items used to generate this response.
    /// </summary>
    property Data: TArray<TResponseItem> read FData write FData;
    /// <summary>
    /// The ID of the first item in the list.
    /// </summary>
    property FirstId: string read FFirstId write FFirstId;
    /// <summary>
    /// Whether there are more items available.
    /// </summary>
    property HasMore: Boolean read FHasMore write FHasMore;
    /// <summary>
    /// The ID of the last item in the list.
    /// </summary>
    property LastId: string read FLastId write FLastId;
    /// <summary>
    /// The type of object returned, must be list.
    /// </summary>
    property &Object: string read FObject write FObject;
    destructor Destroy; override;
  end;

implementation

{ TResponseItemContentOutputText }

destructor TResponseItemContentOutputText.Destroy;
begin
  for var Item in FAnnotations do
    Item.Free;
  inherited;
end;

{ TResponseItemInputMessage }

destructor TResponseItemInputMessage.Destroy;
begin
  for var Item in FContent do
    Item.Free;
  inherited;
end;

{ TResponseItemFileSearchToolCall }

destructor TResponseItemFileSearchToolCall.Destroy;
begin
  for var Item in FResults do
    Item.Free;
  inherited;
end;

{ TComputerActionDrag }

destructor TComputerActionDrag.Destroy;
begin
  for var Item in FPath do
    Item.Free;
  inherited;
end;

{ TResponseItemComputerToolCall }

destructor TResponseItemComputerToolCall.Destroy;
begin
  if Assigned(FAction) then
    FAction.Free;
  for var Item in FPendingSafetyChecks do
    Item.Free;
  inherited;
end;

{ TResponseItemComputerToolCallOutput }

destructor TResponseItemComputerToolCallOutput.Destroy;
begin
  if Assigned(FOutput) then
    FOutput.Free;
  for var Item in FAcknowledgedSafetyChecks do
    Item.Free;
  inherited;
end;

{ TResponses }

destructor TResponses.Destroy;
begin
  for var Item in FData do
    Item.Free;
  inherited;
end;

end.

unit GenAI.Responses.InputParams;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Threading, System.JSON, REST.Json.Types,
  REST.JsonReflect,
  GenAI.API.Params, GenAI.API, GenAI.Consts, GenAI.Schema, GenAI.Types;

type
  TItemContent = class(TJSONParam)
    /// <summary>
    /// The type of the input item.
    /// </summary>
    function &Type(const Value: TInputItemType): TItemContent; overload;
    /// <summary>
    /// The type of the input item.
    /// </summary>
    function &Type(const Value: string): TItemContent; overload;
    /// <summary>
    /// The text input to the model.
    /// </summary>
    function Text(const Value: string): TItemContent;
    /// <summary>
    /// The detail level of the image to be sent to the model. One of high, low, or auto. Defaults to auto.
    /// </summary>
    function Detail(const Value: TImageDetail): TItemContent; overload;
    /// <summary>
    /// The detail level of the image to be sent to the model. One of high, low, or auto. Defaults to auto.
    /// </summary>
    function Detail(const Value: string): TItemContent; overload;
    /// <summary>
    /// The ID of the file to be sent to the model.
    /// </summary>
    function FileId(const Value: string): TItemContent;
    /// <summary>
    /// The URL of the image to be sent to the model. A fully qualified URL or base64 encoded image in a data URL.
    /// </summary>
    function ImageUrl(const Value: string): TItemContent;
    /// <summary>
    /// The content of the file to be sent to the model.
    /// </summary>
    function FileData(const Value: string): TItemContent;
    /// <summary>
    /// The name of the file to be sent to the model.
    /// </summary>
    function FileName(const Value: string): TItemContent;

    class function NewText: TItemContent;
    class function NewImage: TItemContent; overload;
    class function NewImage(const Value: string; const Detail: string = 'auto'): TItemContent; overload;
    class function NewFile: TItemContent;
    class function NewFileData(const FileLocation: string): TItemContent;
  end;

  /// <summary>
  /// Value is TInputListItem or his descendant e.g. TInputMessage, TItemInputMessage, TItemOutputMessage,
  /// TItemOutputMessage, TFileSearchToolCall, TComputerToolCall, TInputItemReference
  /// </summary>
  TInputListItem = class(TJSONParam);

  TInputMessage = class(TInputListItem)
  public
    /// <summary>
    /// The role of the message input. One of user, assistant, system, or developer.
    /// </summary>
    function Role(const Value: TRole): TInputMessage; overload;
    /// <summary>
    /// The role of the message input. One of user, assistant, system, or developer.
    /// </summary>
    function Role(const Value: string): TInputMessage; overload;
    /// <summary>
    /// The type of the message input.
    /// </summary>
    function &Type(const Value: string = 'message'): TInputMessage;
    /// <summary>
    /// Text, image, or audio input to the model, used to generate a response. Can also contain previous
    /// assistant responses.
    /// </summary>
    function Content(const Value: string): TInputMessage; overload;
    /// <summary>
    /// Text, image, or audio input to the model, used to generate a response. Can also contain previous
    /// assistant responses.
    /// </summary>
    function Content(const Value: TJSONArray): TInputMessage; overload;
    /// <summary>
    /// Text, image, or audio input to the model, used to generate a response. Can also contain previous
    /// assistant responses.
    /// </summary>
    function Content(const Value: TArray<TItemContent>): TInputMessage; overload;

    class function New: TInputMessage;
  end;

  TItemInputMessage = class(TInputMessage)
  public
    /// <summary>
    /// The role of the message input. One of user, system, or developer.
    /// </summary>
    function Role(const Value: TRole): TItemInputMessage; overload;
    /// <summary>
    /// The role of the message input. One of user, system, or developer.
    /// </summary>
    function Role(const Value: string): TItemInputMessage; overload;
    /// <summary>
    /// The type of the message input
    /// </summary>
    function &Type(const Value: string = 'message'): TItemInputMessage;
    /// <summary>
    /// A list of one or many input items to the model, containing different content
    /// </summary>
    function Content(const Value: string): TItemInputMessage; overload;
    /// <summary>
    /// A list of one or many input items to the model, containing different content
    /// </summary>
    function Content(const Value: TArray<TItemContent>): TItemInputMessage; overload;
    /// <summary>
    /// The status of item. One of in_progress, completed, or incomplete. Populated when items are returned via API.
    /// </summary>
    function Status(const Value: TMessageStatus): TItemInputMessage; overload;
    /// <summary>
    /// The status of item. One of in_progress, completed, or incomplete. Populated when items are returned via API.
    /// </summary>
    function Status(const Value: string): TItemInputMessage; overload;

    class function New: TItemInputMessage;
  end;

  TInputItemReference = class(TInputListItem)
  public
    /// <summary>
    /// The ID of the item to reference.
    /// </summary>
    function Id(const Value: string): TInputItemReference;
    /// <summary>
    /// The type of item to reference. Always item_reference.
    /// </summary>
    function &Type(const Value: string = 'item_reference'): TInputItemReference;

    class function New: TInputItemReference; overload;
    class function New(const Value: string): TInputItemReference; overload;
  end;

  TOutputNotation = class(TJSONParam)
  public
    /// <summary>
    /// The ID of the file.
    /// </summary>
    function FileId(const Value: string): TOutputNotation;
    /// <summary>
    /// The index of the file in the list of files.
    /// </summary>
    function Index(const Value: Integer): TOutputNotation;
    /// <summary>
    /// The type of the file citation. file_citation, url_citation or file_path
    /// </summary>
    function &Type(const Value: string): TOutputNotation;
    /// <summary>
    /// The index of the last character of the URL citation in the message.
    /// </summary>
    function EndIndex(const Value: Integer): TOutputNotation;
    /// <summary>
    /// The index of the first character of the URL citation in the message.
    /// </summary>
    function StartIndex(const Value: Integer): TOutputNotation;
    /// <summary>
    /// The title of the web resource.
    /// </summary>
    function Title(const Value: string): TOutputNotation;
    /// <summary>
    /// The URL of the web resource.
    /// </summary>
    function Url(const Value: string): TOutputNotation;
    /// <summary>
    /// File citation
    /// </summary>
    class function NewFileCitation: TOutputNotation;
    /// <summary>
    /// A path to a file.
    /// </summary>
    class function NewFilePath: TOutputNotation;
    /// <summary>
    /// URL citation
    /// </summary>
    class function NewUrlCitation: TOutputNotation;
  end;

  TOutputMessageContent = class(TJSONParam)
  public
    /// <summary>
    /// The type of the output text. Always output_text.
    /// </summary>
    function &Type(const Value: string): TOutputMessageContent;
    /// <summary>
    /// The text output from the model.
    /// </summary>
    function Text(const Value: string): TOutputMessageContent;
    /// <summary>
    /// The annotations of the text output.
    /// </summary>
    function Annotations(const Value: TArray<TOutputNotation>): TOutputMessageContent;
    /// <summary>
    /// The refusal explanationfrom the model.
    /// </summary>
    function Refusal(const Value: string): TOutputMessageContent;
    /// <summary>
    /// A text output from the model.
    /// </summary>
    class function NewOutputText: TOutputMessageContent;
    /// <summary>
    /// A refusal from the model.
    /// </summary>
    class function NewRefusal: TOutputMessageContent;
  end;

  TItemOutputMessage = class(TInputListItem)
  public
    /// <summary>
    /// The unique ID of the output message.
    /// </summary>
    function Id(const Value: string): TItemOutputMessage;
    /// <summary>
    /// The role of the output message. Always assistant.
    /// </summary>
    function Role(const Value: TRole): TItemOutputMessage; overload;
    /// <summary>
    /// The role of the output message. Always assistant.
    /// </summary>
    function Role(const Value: string): TItemOutputMessage; overload;
    /// <summary>
    /// The status of the message input. One of in_progress, completed, or incomplete. Populated when input items
    /// are returned via API.
    /// </summary>
    function Status(const Value: TMessageStatus): TItemOutputMessage; overload;
    /// <summary>
    /// The status of the message input. One of in_progress, completed, or incomplete. Populated when input items
    /// are returned via API.
    /// </summary>
    function Status(const Value: string): TItemOutputMessage; overload;
    /// <summary>
    /// The type of the output message. Always message.
    /// </summary>
    function &Type(const Value: string = 'message'): TItemOutputMessage; overload;
    /// <summary>
    /// The content of the output message.
    /// </summary>
    function Content(const Value: TArray<TOutputMessageContent>): TItemOutputMessage;

    class function New: TItemOutputMessage;
  end;

  TFileSearchToolCallResult = class(TJSONParam)
  public
    /// <summary>
    /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
    /// information about the object in a structured format, and querying for objects via API or the dashboard.
    /// Keys are strings with a maximum length of 64 characters. Values are strings with a maximum length of
    /// 512 characters, booleans, or numbers.
    /// </summary>
    function Attributes(const Value: TJSONObject): TFileSearchToolCallResult;
    /// <summary>
    /// The unique ID of the file.
    /// </summary>
    function FileId(const Value: string): TFileSearchToolCallResult;
    /// <summary>
    /// The name of the file.
    /// </summary>
    function Filename(const Value: string): TFileSearchToolCallResult;
    /// <summary>
    /// The relevance score of the file - a value between 0 and 1.
    /// </summary>
    function Score(const Value: Double): TFileSearchToolCallResult;
    /// <summary>
    /// The text that was retrieved from the file.
    /// </summary>
    function Text(const Value: string): TFileSearchToolCallResult;

    class function New: TFileSearchToolCallResult;
  end;

  TFileSearchToolCall = class(TInputListItem)
  public
    /// <summary>
    /// The unique ID of the file search tool call.
    /// </summary>
    function Id(const Value: string): TFileSearchToolCall;
    /// <summary>
    /// The queries used to search for files.
    /// </summary>
    function Queries(const Value: TArray<string>): TFileSearchToolCall;
    /// <summary>
    /// The status of the file search tool call. One of in_progress, searching, incomplete or failed,
    /// </summary>
    function Status(const Value: TFileSearchToolCallType): TFileSearchToolCall; overload;
    /// <summary>
    /// The status of the file search tool call. One of in_progress, searching, incomplete or failed,
    /// </summary>
    function Status(const Value: string): TFileSearchToolCall; overload;
    /// <summary>
    /// The type of the file search tool call. Always file_search_call.
    /// </summary>
    function &Type(const Value: string = 'file_search_call'): TFileSearchToolCall;
    /// <summary>
    /// The results of the file search tool call.
    /// </summary>
    function Results(const Value: TArray<TFileSearchToolCallResult>): TFileSearchToolCall;

    class function New: TFileSearchToolCall;
  end;

  TPendingSafetyCheck = class(TJSONParam)
  public
    /// <summary>
    /// The type of the pending safety check.
    /// </summary>
    function Code(const Value: string): TPendingSafetyCheck;
    /// <summary>
    /// The ID of the pending safety check.
    /// </summary>
    function Id(const Value: string): TPendingSafetyCheck;
    /// <summary>
    /// Details about the pending safety check.
    /// </summary>
    function Message(const Value: string): TPendingSafetyCheck;
  end;

  TAcknowledgedSafetyCheckParams = class(TJSONParam)
  public
    /// <summary>
    /// The type of the pending safety check.
    /// </summary>
    function Code(const Value: string): TAcknowledgedSafetyCheckParams;
    /// <summary>
    /// The ID of the pending safety check.
    /// </summary>
    function Id(const Value: string): TAcknowledgedSafetyCheckParams;
    /// <summary>
    /// Details about the pending safety check.
    /// </summary>
    function Message(const Value: string): TAcknowledgedSafetyCheckParams;

    class function New: TAcknowledgedSafetyCheckParams;
  end;

  TComputerToolCallOutputObject = class(TJSONParam)
  public
    /// <summary>
    /// The identifier of an uploaded file that contains the screenshot.
    /// </summary>
    function FileId(const Value: string): TComputerToolCallOutputObject;
    /// <summary>
    /// The URL of the screenshot image.
    /// </summary>
    function ImageUrl(const Value: string): TComputerToolCallOutputObject;
    /// <summary>
    /// The type of the computer tool call output. Always computer_screenshot.
    /// </summary>
    function &Type(const Value: string = 'computer_screenshot'): TComputerToolCallOutputObject;

    class function New: TComputerToolCallOutputObject;
  end;

  TComputerToolCallAction = class(TJSONParam);

  TComputerClick = class(TComputerToolCallAction)
  public
    /// <summary>
    /// Indicates which mouse button was pressed during the click. One of left, right, wheel, back, or forward.
    /// </summary>
    function Button(const Value: TMouseButton): TComputerClick; overload;
    /// <summary>
    /// Indicates which mouse button was pressed during the click. One of left, right, wheel, back, or forward.
    /// </summary>
    function Button(const Value: string): TComputerClick; overload;
    /// <summary>
    /// Specifies the event type. For a click action, this property is always set to click.
    /// </summary>
    function &Type(const Value: string = 'click'): TComputerClick;
    /// <summary>
    /// The x-coordinate where the click occurred.
    /// </summary>
    function X(const Value: Integer): TComputerClick;
    /// <summary>
    /// The y-coordinate where the click occurred.
    /// </summary>
    function Y(const Value: Integer): TComputerClick;

    class function New: TComputerClick;
  end;

  TComputerDoubleClick = class(TComputerToolCallAction)
    /// <summary>
    /// Specifies the event type. For a double click action, this property is always set to double_click.
    /// </summary>
    function &Type(const Value: string = 'double_click'): TComputerDoubleClick;
    /// <summary>
    /// The x-coordinate where the double click occurred.
    /// </summary>
    function X(const Value: Integer): TComputerDoubleClick;
    /// <summary>
    /// The y-coordinate where the double click occurred.
    /// </summary>
    function Y(const Value: Integer): TComputerDoubleClick;

    class function New: TComputerDoubleClick;
  end;

  TComputerToolCallOutput = class(TComputerToolCallAction)
  public
    /// <summary>
    /// acknowledged safety checks for computer tool call outpu
    /// </summary>
    function AcknowledgedSafetyChecks(const Value: TArray<TAcknowledgedSafetyCheckParams>): TComputerToolCallOutput;
    /// <summary>
    /// The ID of the computer tool call that produced the output.
    /// </summary>
    function CallId(const Value: string): TComputerToolCallOutput;
    /// <summary>
    /// The unique ID of the computer tool call.
    /// </summary>
    function Id(const Value: string): TComputerToolCallOutput;
    /// <summary>
    /// The output of a computer tool call.
    /// </summary>
    function Output(const Value: TComputerToolCallOutputObject): TComputerToolCallOutput;
    /// <summary>
    /// The status of the file search tool call. One of in_progress, searching, incomplete or failed
    /// </summary>
    function Status(const Value: TMessageStatus): TComputerToolCallOutput; overload;
    /// <summary>
    /// The status of the file search tool call. One of in_progress, searching, incomplete or failed
    /// </summary>
    function Status(const Value: string): TComputerToolCallOutput; overload;
    /// <summary>
    /// The type of the computer tool call output. Always computer_call_output.
    /// </summary>
    function &Type(const Value: string = 'computer_call_output'): TComputerToolCallOutput;

    class function New: TComputerToolCallOutput;
  end;

  TWebSearchToolCall = class(TComputerToolCallAction)
  public
    /// <summary>
    /// The unique ID of the web search tool call.
    /// </summary>
    function Id(const Value: string): TWebSearchToolCall;
    /// <summary>
    /// The status of the web search tool call. One of in_progress, searching, incomplete or failed
    /// </summary>
    function Status(const Value: TMessageStatus): TWebSearchToolCall; overload;
    /// <summary>
    /// The status of the web search tool call. One of in_progress, searching, incomplete or failed
    /// </summary>
    function Status(const Value: string): TWebSearchToolCall; overload;
    /// <summary>
    /// The type of the web search tool call. Always web_search_call.
    /// </summary>
    function &Type(const Value: string = 'web_search_call'): TWebSearchToolCall;

    class function New: TWebSearchToolCall;
  end;

  TFunctionToolCall = class(TComputerToolCallAction)
  public
    /// <summary>
    /// A JSON string of the arguments to pass to the function.
    /// </summary>
    function Arguments(const Value: string): TFunctionToolCall;
    /// <summary>
    /// The unique ID of the function tool call generated by the model.
    /// </summary>
    function CallId(const Value: string): TFunctionToolCall;
    /// <summary>
    /// The unique ID of the function tool call.
    /// </summary>
    function Id(const Value: string): TFunctionToolCall;
    /// <summary>
    /// The name of the function to run.
    /// </summary>
    function Name(const Value: string): TFunctionToolCall;
    /// <summary>
    /// The status of the item. One of in_progress, completed, or incomplete. Populated when items are returned via API.
    /// </summary>
    function Status(const Value: TMessageStatus): TFunctionToolCall; overload;
    /// <summary>
    /// The status of the item. One of in_progress, completed, or incomplete. Populated when items are returned via API.
    /// </summary>
    function Status(const Value: string): TFunctionToolCall; overload;
    /// <summary>
    /// The type of the function tool call. Always function_call.
    /// </summary>
    function &Type(const Value: string = 'function_call'): TFunctionToolCall;

    class function New: TFunctionToolCall;
  end;

  TFunctionToolCalloutput = class(TComputerToolCallAction)
  public
    /// <summary>
    /// The unique ID of the function tool call generated by the model.
    /// </summary>
    function CallId(const Value: string): TFunctionToolCalloutput;
    /// <summary>
    /// The name of the function tool call
    /// </summary>
    function Id(const Value: string): TFunctionToolCalloutput;
    /// <summary>
    /// A JSON string of the output of the function tool call.
    /// </summary>
    function Output(const Value: string): TFunctionToolCalloutput;
    /// <summary>
    /// The status of the item. One of in_progress, completed, or incomplete. Populated when items are returned via API.
    /// </summary>
    function Status(const Value: TMessageStatus): TFunctionToolCalloutput; overload;
    /// <summary>
    /// The status of the item. One of in_progress, completed, or incomplete. Populated when items are returned via API.
    /// </summary>
    function Status(const Value: string): TFunctionToolCalloutput; overload;
    /// <summary>
    /// The type of the function tool call output. Always function_call_output.
    /// </summary>
    function &Type(const Value: string = 'function_call_output'): TFunctionToolCalloutput;

    class function New: TFunctionToolCalloutput;
  end;

  TReasoningTextContent = class(TJSONParam)
  public
    /// <summary>
    /// A short summary of the reasoning used by the model when generating the response.
    /// </summary>
    function Text(const Value: string): TReasoningTextContent;
    /// <summary>
    /// The type of the object. Always summary_text.
    /// </summary>
    function &Type(const Value: string = 'summary_text'): TReasoningTextContent;

    class function New: TReasoningTextContent;
  end;

  TReasoningObject = class(TComputerToolCallAction)
  public
    /// <summary>
    /// The unique identifier of the reasoning content.
    /// </summary>
    function Id(const Value: string): TReasoningObject;
    /// <summary>
    /// The status of the item. One of in_progress, completed, or incomplete. Populated when items are returned via API.
    /// </summary>
    function Status(const Value: TMessageStatus): TReasoningObject; overload;
    /// <summary>
    /// The status of the item. One of in_progress, completed, or incomplete. Populated when items are returned via API.
    /// </summary>
    function Status(const Value: string): TReasoningObject; overload;
    /// <summary>
    /// Reasoning text contents.
    /// </summary>
    function Summary(const Value: TArray<TReasoningTextContent>): TReasoningObject;
    /// <summary>
    /// The type of the object. Always reasoning.
    /// </summary>
    function &Type(const Value: string = 'reasoning'): TReasoningObject;

    class function New: TReasoningObject;
  end;

  TComputerToolCall = class(TInputListItem)
  public
    /// <summary>
    /// The computer action
    /// </summary>
    /// <remarks>
    /// Value is TComputerToolCallAction class or his descendant e.g. TComputerClick,
    /// TComputerDoubleClick, TComputerToolCallOutput, TWebSearchToolCall, TFunctionToolCall,
    /// TFunctionToolCalloutput, TReasoningObject
    /// </remarks>
    function Action(const Value: TComputerToolCallAction): TComputerToolCall;
    /// <summary>
    /// An identifier used when responding to the tool call with output.
    /// </summary>
    function CallId(const Value: string): TComputerToolCall;
    /// <summary>
    /// The unique ID of the computer call.
    /// </summary>
    function Id(const Value: string): TComputerToolCall;
    /// <summary>
    /// The pending safety checks for the computer call.
    /// </summary>
    function PendingSafetyChecks(const Value: TArray<TPendingSafetyCheck>): TComputerToolCall;
    /// <summary>
    /// The status of the item. One of in_progress, completed, or incomplete. Populated when items are returned via API.
    /// </summary>
    function Status(const Value: TMessageStatus): TComputerToolCall; overload;
    /// <summary>
    /// The status of the item. One of in_progress, completed, or incomplete. Populated when items are returned via API.
    /// </summary>
    function Status(const Value: string): TComputerToolCall; overload;
    /// <summary>
    /// The type of the computer call. Always computer_call.
    /// </summary>
    function &Type(const Value: string = 'computer_call'): TComputerToolCall;

    class function New: TComputerToolCall;
  end;

implementation

uses
  System.StrUtils, GenAI.NetEncoding.Base64, GenAI.Responses.Helpers, GenAI.Httpx;

{ TItemContent }

function TItemContent.Detail(const Value: TImageDetail): TItemContent;
begin
  Result := TItemContent(Add('detail', Value.ToString));
end;

function TItemContent.Detail(const Value: string): TItemContent;
begin
  Result := TItemContent(Add('detail', TImageDetail.Create(Value).ToString));
end;

function TItemContent.FileData(const Value: string): TItemContent;
begin
  Result := TItemContent(Add('file_data', Value));
end;

function TItemContent.FileId(const Value: string): TItemContent;
begin
  Result := TItemContent(Add('file_id', Value));
end;

function TItemContent.FileName(const Value: string): TItemContent;
begin
  Result := TItemContent(Add('filename', Value));
end;

function TItemContent.ImageUrl(const Value: string): TItemContent;
var
  Detail: string;
begin
  var FileName := TFormatHelper.ExtractFileName(Value, Detail);
  if Detail.IsEmpty then
    Result := TItemContent(Add('image_url', GetUrlOrEncodeBase64(Value)))
  else
    Result := TItemContent(Add('image_url', GetUrlOrEncodeBase64(Filename))).Detail(Detail);
end;

class function TItemContent.NewFile: TItemContent;
begin
  Result := TItemContent.Create.&Type('input_file');
end;

class function TItemContent.NewFileData(const FileLocation: string): TItemContent;
var
  MimeType: string;
  Data: string;
  FileName: string;
begin
  {--- Retrieve mimetype }
  if FileLocation.ToLower.StartsWith('http') then
    begin
      Data := THttpx.LoadDataToBase64(FileLocation, MimeType);
      Data := Format('data:%s;base64,%s', [MimeType, Data]);
      FileName := THttpx.ExtractURIFileName(FileLocation);
    end
  else
    begin
      MimeType := GetMimeType(FileLocation);
      Data := GetUrlOrEncodeBase64(FileLocation);
      FileName := ExtractFileName(FileLocation);
    end;

  {--- Pdf file managment }
  var index := IndexStr(MimeType, DocTypeAccepted);
  if index = -1 then
    raise Exception.Create('PDF files only accepted');

  Result := Create.&Type('input_file').FileName(FileName).FileData(Data);
end;

class function TItemContent.NewImage: TItemContent;
begin
  Result := TItemContent.Create.&Type('input_image');
end;

class function TItemContent.NewImage(const Value, Detail: string): TItemContent;
begin
  if Value.ToLower.StartsWith('http') then
    Result := NewImage.Detail(Detail).ImageUrl(Value)
  else
  if FileExists(Value.Trim) then
    Result :=  NewImage.Detail(Detail).ImageUrl(Value)
  else
    Result := NewImage.Detail(Detail).FileId(Value);
end;

class function TItemContent.NewText: TItemContent;
begin
  Result := TItemContent.Create.&Type('input_text');
end;

function TItemContent.Text(const Value: string): TItemContent;
begin
  Result := TItemContent(Add('text', Value));
end;

function TItemContent.&Type(const Value: TInputItemType): TItemContent;
begin
  Result := TItemContent(Add('type', Value.ToString));
end;

function TItemContent.&Type(const Value: string): TItemContent;
begin
  Result := TItemContent(Add('type', TInputItemType.Create(Value).ToString));
end;

{ TInputMessage }

function TInputMessage.Content(const Value: string): TInputMessage;
begin
  Result := TInputMessage(Add('content', Value));
end;

function TInputMessage.Content(const Value: TArray<TItemContent>): TInputMessage;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TInputMessage(Add('content', JSONArray));
end;

function TInputMessage.Content(const Value: TJSONArray): TInputMessage;
begin
  Result := TInputMessage(Add('content', Value));
end;

class function TInputMessage.New: TInputMessage;
begin
  Result := TInputMessage.Create.&Type();
end;

function TInputMessage.Role(const Value: TRole): TInputMessage;
begin
  Result := TInputMessage(Add('role', Value.ToString));
end;

function TInputMessage.Role(const Value: string): TInputMessage;
begin
  Result := TInputMessage(Add('role', TRole.Create(Value).ToString));
end;

function TInputMessage.&Type(const Value: string): TInputMessage;
begin
  Result := TInputMessage(Add('type', Value));
end;

{ TItemInputMessage }

function TItemInputMessage.&Type(const Value: string): TItemInputMessage;
begin
  Result := TItemInputMessage(inherited &Type(Value));
end;

function TItemInputMessage.Content(
  const Value: TArray<TItemContent>): TItemInputMessage;
begin
  Result := TItemInputMessage(inherited Content(Value));
end;

class function TItemInputMessage.New: TItemInputMessage;
begin
  Result := TItemInputMessage.Create.&Type();
end;

function TItemInputMessage.Content(const Value: string): TItemInputMessage;
begin
  Result := TItemInputMessage(inherited Content(Value));
end;

function TItemInputMessage.Role(const Value: string): TItemInputMessage;
begin
  Result := TItemInputMessage(inherited Role(Value));
end;

function TItemInputMessage.Role(const Value: TRole): TItemInputMessage;
begin
  Result := TItemInputMessage(inherited Role(Value));
end;

function TItemInputMessage.Status(const Value: string): TItemInputMessage;
begin
  Result := TItemInputMessage(Add('status', TMessageStatus.Create(Value).ToString));
end;

function TItemInputMessage.Status(
  const Value: TMessageStatus): TItemInputMessage;
begin
  Result := TItemInputMessage(Add('status', Value.ToString));
end;

{ TInputItemReference }

class function TInputItemReference.New(
  const Value: string): TInputItemReference;
begin
  Result := New.Id(Value);
end;

class function TInputItemReference.New: TInputItemReference;
begin
  Result := TInputItemReference.Create.&Type();
end;

function TInputItemReference.&Type(const Value: string): TInputItemReference;
begin
  Result := TInputItemReference(Add('type', Value));
end;

function TInputItemReference.Id(const Value: string): TInputItemReference;
begin
  Result := TInputItemReference(Add('id', Value));
end;

{ TItemOutputMessage }

function TItemOutputMessage.&Type(const Value: string): TItemOutputMessage;
begin
  Result := TItemOutputMessage(Add('type', Value));
end;

function TItemOutputMessage.Content(
  const Value: TArray<TOutputMessageContent>): TItemOutputMessage;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TItemOutputMessage(Add('content', JSONArray));
end;

function TItemOutputMessage.Id(const Value: string): TItemOutputMessage;
begin
  Result := TItemOutputMessage(Add('id', Value));
end;

class function TItemOutputMessage.New: TItemOutputMessage;
begin
  Result := TItemOutputMessage.Create.&Type().Role('assistant');
end;

function TItemOutputMessage.Role(const Value: TRole): TItemOutputMessage;
begin
  Result := TItemOutputMessage(Add('role', Value.ToString));
end;

function TItemOutputMessage.Role(const Value: string): TItemOutputMessage;
begin
  Result := TItemOutputMessage(Add('role', TRole.Create(Value).ToString));
end;

function TItemOutputMessage.Status(const Value: string): TItemOutputMessage;
begin
  Result := TItemOutputMessage(Add('status', TMessageStatus.Create(Value).ToString));
end;

function TItemOutputMessage.Status(
  const Value: TMessageStatus): TItemOutputMessage;
begin
  Result := TItemOutputMessage(Add('status', Value.ToString));
end;

{ TOutputMessageContent }

function TOutputMessageContent.&Type(
  const Value: string): TOutputMessageContent;
begin
  Result := TOutputMessageContent(Add('type', Value));
end;

function TOutputMessageContent.Annotations(
  const Value: TArray<TOutputNotation>): TOutputMessageContent;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TOutputMessageContent(Add('annotations', JSONArray));
end;

class function TOutputMessageContent.NewOutputText: TOutputMessageContent;
begin
  Result := TOutputMessageContent.Create.&Type('output_text');
end;

class function TOutputMessageContent.NewRefusal: TOutputMessageContent;
begin
  Result := TOutputMessageContent.Create.&Type('refusal');
end;

function TOutputMessageContent.Refusal(
  const Value: string): TOutputMessageContent;
begin
  Result := TOutputMessageContent(Add('refusal', Value));
end;

function TOutputMessageContent.Text(const Value: string): TOutputMessageContent;
begin
  Result := TOutputMessageContent(Add('text', Value));
end;

{ TOutputNotation }

function TOutputNotation.&Type(const Value: string): TOutputNotation;
begin
  Result := TOutputNotation(Add('type', Value));
end;

function TOutputNotation.EndIndex(const Value: Integer): TOutputNotation;
begin
  Result := TOutputNotation(Add('end_index', Value));
end;

function TOutputNotation.FileId(const Value: string): TOutputNotation;
begin
  Result := TOutputNotation(Add('file_id', Value));
end;

function TOutputNotation.Index(const Value: Integer): TOutputNotation;
begin
  Result := TOutputNotation(Add('index', Value));
end;

class function TOutputNotation.NewFileCitation: TOutputNotation;
begin
  Result := TOutputNotation.Create.&Type('file_citation');
end;

class function TOutputNotation.NewFilePath: TOutputNotation;
begin
  Result := TOutputNotation.Create.&Type('file_path');
end;

class function TOutputNotation.NewUrlCitation: TOutputNotation;
begin
  Result := TOutputNotation.Create.&Type('url_citation');
end;

function TOutputNotation.StartIndex(const Value: Integer): TOutputNotation;
begin
  Result := TOutputNotation(Add('start_index', Value));
end;

function TOutputNotation.Title(const Value: string): TOutputNotation;
begin
  Result := TOutputNotation(Add('title', Value));
end;

function TOutputNotation.Url(const Value: string): TOutputNotation;
begin
  Result := TOutputNotation(Add('url', Value));
end;

{ TFileSearchToolCall }

function TFileSearchToolCall.&Type(const Value: string): TFileSearchToolCall;
begin
   Result := TFileSearchToolCall(Add('type', Value));
end;

function TFileSearchToolCall.Id(const Value: string): TFileSearchToolCall;
begin
  Result := TFileSearchToolCall(Add('id', Value));
end;

class function TFileSearchToolCall.New: TFileSearchToolCall;
begin
  Result := TFileSearchToolCall.Create.&Type();
end;

function TFileSearchToolCall.Queries(
  const Value: TArray<string>): TFileSearchToolCall;
begin
  Result := TFileSearchToolCall(Add('queries', Value));
end;

function TFileSearchToolCall.Results(
  const Value: TArray<TFileSearchToolCallResult>): TFileSearchToolCall;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TFileSearchToolCall(Add('results', JSONArray));
end;

function TFileSearchToolCall.Status(const Value: string): TFileSearchToolCall;
begin
  Result := TFileSearchToolCall(Add('status', TFileSearchToolCallType.Create(Value).ToString));
end;

function TFileSearchToolCall.Status(
  const Value: TFileSearchToolCallType): TFileSearchToolCall;
begin
  Result := TFileSearchToolCall(Add('status', Value.ToString));
end;

{ TFileSearchToolCallResult }

function TFileSearchToolCallResult.Attributes(
  const Value: TJSONObject): TFileSearchToolCallResult;
begin
  Result := TFileSearchToolCallResult(Add('attributes', Value));
end;

function TFileSearchToolCallResult.FileId(
  const Value: string): TFileSearchToolCallResult;
begin
  Result := TFileSearchToolCallResult(Add('file_id', Value));
end;

function TFileSearchToolCallResult.Filename(
  const Value: string): TFileSearchToolCallResult;
begin
  Result := TFileSearchToolCallResult(Add('filename', Value));
end;

class function TFileSearchToolCallResult.New: TFileSearchToolCallResult;
begin
  Result := TFileSearchToolCallResult.Create;
end;

function TFileSearchToolCallResult.Score(
  const Value: Double): TFileSearchToolCallResult;
begin
  Result := TFileSearchToolCallResult(Add('score', Value));
end;

function TFileSearchToolCallResult.Text(
  const Value: string): TFileSearchToolCallResult;
begin
  Result := TFileSearchToolCallResult(Add('text', Value));
end;

{ TComputerToolCall }

function TComputerToolCall.Action(
  const Value: TComputerToolCallAction): TComputerToolCall;
begin
  Result := TComputerToolCall(Add('action', Value.Detach));
end;

function TComputerToolCall.CallId(const Value: string): TComputerToolCall;
begin
  Result := TComputerToolCall(Add('call_id', Value));
end;

function TComputerToolCall.Id(const Value: string): TComputerToolCall;
begin
  Result := TComputerToolCall(Add('id', Value));
end;

class function TComputerToolCall.New: TComputerToolCall;
begin
  Result := TComputerToolCall.Create.&Type();
end;

function TComputerToolCall.PendingSafetyChecks(
  const Value: TArray<TPendingSafetyCheck>): TComputerToolCall;
begin
  var JSONArray := TJSONArray.Create;
  for var item in Value do
    JSONArray.Add(Item.Detach);
  Result := TComputerToolCall(Add('pending_safety_checks', JSONArray));
end;

function TComputerToolCall.Status(const Value: string): TComputerToolCall;
begin
  Result := TComputerToolCall(Add('status', TMessageStatus.Create(Value).ToString));
end;

function TComputerToolCall.Status(
  const Value: TMessageStatus): TComputerToolCall;
begin
  Result := TComputerToolCall(Add('status', Value.ToString));
end;

function TComputerToolCall.&Type(const Value: string): TComputerToolCall;
begin
  Result := TComputerToolCall(Add('type', Value));
end;

{ TPendingSafetyCheck }

function TPendingSafetyCheck.Code(const Value: string): TPendingSafetyCheck;
begin
  Result := TPendingSafetyCheck(Add('code', Value));
end;

function TPendingSafetyCheck.Id(const Value: string): TPendingSafetyCheck;
begin
  Result := TPendingSafetyCheck(Add('id', Value));
end;

function TPendingSafetyCheck.Message(const Value: string): TPendingSafetyCheck;
begin
  Result := TPendingSafetyCheck(Add('message', Value));
end;

{ TComputerClick }

function TComputerClick.&Type(const Value: string): TComputerClick;
begin
  Result := TComputerClick(Add('type', Value));
end;

function TComputerClick.Button(const Value: TMouseButton): TComputerClick;
begin
  Result := TComputerClick(Add('button', Value.ToString));
end;

function TComputerClick.Button(const Value: string): TComputerClick;
begin
  Result := TComputerClick(Add('button', TMouseButton.Create(Value).ToString));
end;

class function TComputerClick.New: TComputerClick;
begin
  Result := TComputerClick.Create.&Type();
end;

function TComputerClick.X(const Value: Integer): TComputerClick;
begin
  Result := TComputerClick(Add('x', Value));
end;

function TComputerClick.Y(const Value: Integer): TComputerClick;
begin
  Result := TComputerClick(Add('y', Value));
end;


{ TComputerDoubleClick }

class function TComputerDoubleClick.New: TComputerDoubleClick;
begin
  Result := TComputerDoubleClick.Create.&Type();
end;

function TComputerDoubleClick.&Type(const Value: string): TComputerDoubleClick;
begin
  Result := TComputerDoubleClick(Add('type', Value));
end;

function TComputerDoubleClick.X(const Value: Integer): TComputerDoubleClick;
begin
  Result := TComputerDoubleClick(Add('x', Value));
end;

function TComputerDoubleClick.Y(const Value: Integer): TComputerDoubleClick;
begin
  Result := TComputerDoubleClick(Add('y', Value));
end;

{ TComputerToolCallOutput }

function TComputerToolCallOutput.&Type(
  const Value: string): TComputerToolCallOutput;
begin
  Result := TComputerToolCallOutput(Add('type', Value));
end;

function TComputerToolCallOutput.AcknowledgedSafetyChecks(
  const Value: TArray<TAcknowledgedSafetyCheckParams>): TComputerToolCallOutput;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TComputerToolCallOutput(Add('acknowledged_safety_checks', JSONArray));
end;

function TComputerToolCallOutput.CallId(
  const Value: string): TComputerToolCallOutput;
begin
  Result := TComputerToolCallOutput(Add('call_id', Value));
end;

function TComputerToolCallOutput.Id(
  const Value: string): TComputerToolCallOutput;
begin
  Result := TComputerToolCallOutput(Add('id', Value));
end;

class function TComputerToolCallOutput.New: TComputerToolCallOutput;
begin
  Result := TComputerToolCallOutput.Create.&Type();
end;

function TComputerToolCallOutput.Output(
  const Value: TComputerToolCallOutputObject): TComputerToolCallOutput;
begin
  Result := TComputerToolCallOutput(Add('output', Value.Detach));
end;

function TComputerToolCallOutput.Status(
  const Value: string): TComputerToolCallOutput;
begin
  Result := TComputerToolCallOutput(Add('status', TMessageStatus.Create(Value).ToString));
end;

function TComputerToolCallOutput.Status(
  const Value: TMessageStatus): TComputerToolCallOutput;
begin
  Result := TComputerToolCallOutput(Add('status', Value.ToString));
end;

{ TComputerToolCallOutputObject }

function TComputerToolCallOutputObject.&Type(
  const Value: string): TComputerToolCallOutputObject;
begin
  Result := TComputerToolCallOutputObject(Add('type', Value));
end;

function TComputerToolCallOutputObject.FileId(
  const Value: string): TComputerToolCallOutputObject;
begin
  Result := TComputerToolCallOutputObject(Add('file_id', Value));
end;

function TComputerToolCallOutputObject.ImageUrl(
  const Value: string): TComputerToolCallOutputObject;
begin
  Result := TComputerToolCallOutputObject(Add('image_url', Value));
end;

class function TComputerToolCallOutputObject.New: TComputerToolCallOutputObject;
begin
  Result := TComputerToolCallOutputObject.Create.&Type();
end;


{ TAcknowledgedSafetyCheckParams }

function TAcknowledgedSafetyCheckParams.Code(
  const Value: string): TAcknowledgedSafetyCheckParams;
begin
  Result := TAcknowledgedSafetyCheckParams(Add('code', Value));
end;

function TAcknowledgedSafetyCheckParams.Id(
  const Value: string): TAcknowledgedSafetyCheckParams;
begin
  Result := TAcknowledgedSafetyCheckParams(Add('id', Value));
end;

function TAcknowledgedSafetyCheckParams.Message(
  const Value: string): TAcknowledgedSafetyCheckParams;
begin
  Result := TAcknowledgedSafetyCheckParams(Add('message', Value));
end;

class function TAcknowledgedSafetyCheckParams.New: TAcknowledgedSafetyCheckParams;
begin
  Result := TAcknowledgedSafetyCheckParams.Create;
end;

{ TWebSearchToolCall }

function TWebSearchToolCall.Id(const Value: string): TWebSearchToolCall;
begin
  Result := TWebSearchToolCall(Add('id', Value));
end;

class function TWebSearchToolCall.New: TWebSearchToolCall;
begin
  Result := TWebSearchToolCall.Create.&Type();
end;

function TWebSearchToolCall.Status(const Value: string): TWebSearchToolCall;
begin
  Result := TWebSearchToolCall(Add('status', TMessageStatus.Create(Value).ToString));
end;

function TWebSearchToolCall.Status(
  const Value: TMessageStatus): TWebSearchToolCall;
begin
  Result := TWebSearchToolCall(Add('status', Value.ToString));
end;

function TWebSearchToolCall.&Type(const Value: string): TWebSearchToolCall;
begin
  Result := TWebSearchToolCall(Add('type', Value));
end;

{ TFunctionToolCall }

function TFunctionToolCall.&Type(const Value: string): TFunctionToolCall;
begin
  Result := TFunctionToolCall(Add('type', Value));
end;

function TFunctionToolCall.Arguments(const Value: string): TFunctionToolCall;
begin
  Result := TFunctionToolCall(Add('arguments', Value));
end;

function TFunctionToolCall.CallId(const Value: string): TFunctionToolCall;
begin
  Result := TFunctionToolCall(Add('call_id', Value));
end;

function TFunctionToolCall.Id(const Value: string): TFunctionToolCall;
begin
  Result := TFunctionToolCall(Add('id', Value));
end;

function TFunctionToolCall.Name(const Value: string): TFunctionToolCall;
begin
  Result := TFunctionToolCall(Add('name', Value));
end;

class function TFunctionToolCall.New: TFunctionToolCall;
begin
  Result := TFunctionToolCall.Create.&Type();
end;

function TFunctionToolCall.Status(const Value: string): TFunctionToolCall;
begin
  Result := TFunctionToolCall(Add('status', TMessageStatus.Create(Value).ToString));
end;

function TFunctionToolCall.Status(
  const Value: TMessageStatus): TFunctionToolCall;
begin
  Result := TFunctionToolCall(Add('status', Value.ToString));
end;

{ TFunctionToolCalloutput }

function TFunctionToolCalloutput.&Type(
  const Value: string): TFunctionToolCalloutput;
begin
  Result := TFunctionToolCalloutput(Add('type', Value));
end;

function TFunctionToolCalloutput.CallId(
  const Value: string): TFunctionToolCalloutput;
begin
  Result := TFunctionToolCalloutput(Add('call_id', Value));
end;

function TFunctionToolCalloutput.Id(
  const Value: string): TFunctionToolCalloutput;
begin
  Result := TFunctionToolCalloutput(Add('id', Value));
end;

class function TFunctionToolCalloutput.New: TFunctionToolCalloutput;
begin
  Result := TFunctionToolCalloutput.Create.&Type();
end;

function TFunctionToolCalloutput.Output(
  const Value: string): TFunctionToolCalloutput;
begin
  Result := TFunctionToolCalloutput(Add('output', Value));
end;

function TFunctionToolCalloutput.Status(
  const Value: string): TFunctionToolCalloutput;
begin
  Result := TFunctionToolCalloutput(Add('status', TMessageStatus.Create(Value).ToString));
end;

function TFunctionToolCalloutput.Status(
  const Value: TMessageStatus): TFunctionToolCalloutput;
begin
  Result := TFunctionToolCalloutput(Add('status', Value.ToString));
end;

{ TReasoningObject }

function TReasoningObject.Id(const Value: string): TReasoningObject;
begin
  Result := TReasoningObject(Add('id', Value));
end;

class function TReasoningObject.New: TReasoningObject;
begin
  Result := TReasoningObject.Create.&Type();
end;

function TReasoningObject.Status(const Value: string): TReasoningObject;
begin
  Result := TReasoningObject(Add('status', TMessageStatus.Create(Value).ToString));
end;

function TReasoningObject.Summary(
  const Value: TArray<TReasoningTextContent>): TReasoningObject;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TReasoningObject(Add('summary', JSONArray));
end;

function TReasoningObject.Status(const Value: TMessageStatus): TReasoningObject;
begin
  Result := TReasoningObject(Add('status', Value.ToString));
end;

function TReasoningObject.&Type(const Value: string): TReasoningObject;
begin
  Result := TReasoningObject(Add('type', Value));
end;

{ TReasoningTextContent }

class function TReasoningTextContent.New: TReasoningTextContent;
begin
  Result := TReasoningTextContent.Create.&Type();
end;

function TReasoningTextContent.Text(const Value: string): TReasoningTextContent;
begin
  Result := TReasoningTextContent(Add('text', Value));
end;

function TReasoningTextContent.&Type(
  const Value: string): TReasoningTextContent;
begin
  Result := TReasoningTextContent(Add('type', Value));
end;

end.

unit GenAI.Responses;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Threading, System.JSON, REST.Json.Types,
  REST.JsonReflect, REST.Json,
  GenAI.API.Params, GenAI.API, GenAI.Consts, GenAI.Schema, GenAI.Types,
  GenAI.Async.Params, GenAI.Async.Support, GenAI.Assistants, GenAI.Functions.Core,
  GenAI.Responses.InputParams, GenAI.Responses.InputItemList, GenAI.Chat.Parallel;

type
  TReasoningParams = class(TJSONParam)
  public
    /// <summary>
    /// Constrains effort on reasoning for reasoning models. Currently supported values are low, medium, and high.
    /// Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
    /// </summary>
    /// <remarks>
    /// o-series models only
    /// </remarks>
    function Effort(const Value: TReasoningEffort): TReasoningParams; overload;
    /// <summary>
    /// Constrains effort on reasoning for reasoning models. Currently supported values are low, medium, and high.
    /// Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
    /// </summary>
    /// <remarks>
    /// o-series models only
    /// </remarks>
    function Effort(const Value: string): TReasoningParams; overload;
    /// <summary>
    /// A summary of the reasoning performed by the model. This can be useful for debugging and understanding the
    /// model's reasoning process. One of concise or detailed.
    /// </summary>
    function Summary(const Value: TReasoningGenerateSummary): TReasoningParams; overload;
    /// <summary>
    /// A summary of the reasoning performed by the model. This can be useful for debugging and understanding the
    /// model's reasoning process. One of concise or detailed.
    /// </summary>
    function Summary(const Value: string): TReasoningParams; overload;

    class function New: TReasoningParams;
  end;

  /// <summary>
  /// Value is TTextFormatParams or his descendant e.g. TTextFormatTextPrams, TTextJSONSchemaParams, TTextJSONObjectParams,
  /// TTextParams
  /// </summary>
  TTextFormatParams = class(TJSONParam);

  TTextFormatTextPrams = class(TTextFormatParams)
  public
    /// <summary>
    /// The type of response format being defined. Always text.
    /// </summary>
    function &Type(const Value: string = 'text'): TTextFormatTextPrams;

    class function New: TTextFormatTextPrams;
  end;

  TTextJSONSchemaParams = class(TTextFormatParams)
  public
    /// <summary>
    /// A description of what the response format is for, used by the model to determine how to respond in the format.
    /// </summary>
    function Description(const Value: string): TTextJSONSchemaParams;
    /// <summary>
    /// The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
    /// </summary>
    function Name(const Value: string): TTextJSONSchemaParams;
    /// <summary>
    /// The schema for the response format, described as a JSON Schema object. Learn how to build JSON schemas here.
    /// </summary>
    function Schema(const Value: TSchemaParams): TTextJSONSchemaParams; overload;
    /// <summary>
    /// The schema for the response format, described as a JSON Schema object. Learn how to build JSON schemas here.
    /// </summary>
    function Schema(const Value: string): TTextJSONSchemaParams; overload;
    /// <summary>
    /// Whether to enable strict schema adherence when generating the output. If set to true, the model will always
    /// follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict
    /// is true.
    /// </summary>
    function Strict(const Value: Boolean): TTextJSONSchemaParams;
    /// <summary>
    /// The type of response format being defined. Always json_schema.
    /// </summary>
    function &Type(const Value: string = 'json_schema'): TTextJSONSchemaParams;

    class function New: TTextJSONSchemaParams;
  end;

  TTextJSONObjectParams = class(TTextFormatParams)
  public
    /// <summary>
    /// The type of response format being defined. Always json_object.
    /// </summary>
    function &Type(const Value: string = 'json_object'): TTextJSONObjectParams;

    class function New: TTextJSONObjectParams;
  end;

  TTextParams = class(TJSONParam)
  public
    /// <summary>
    /// An object specifying the format that the model must output.
    /// <para>
    /// - Configuring { "type": "json_schema" } enables Structured Outputs,
    /// which ensures the model will match your supplied JSON schema.
    /// </para>
    /// <para>
    /// - The default format is { "type": "text" } with no additional options.
    /// </para>
    /// <para>
    /// - Not recommended for gpt-4o and newer models:
    /// Setting to { "type": "json_object" } enables the older JSON mode, which ensures the message the model generates
    /// is valid JSON. Using json_schema is preferred for models that support it.
    /// </para>
    /// </summary>
    function Format(const Value: TTextFormatParams): TTextParams;
  end;

  /// <summary>
  /// Value is TResponseToolChoiceParams or his descendant e.g. THostedToolParams, TFunctionToolParams
  /// </summary>
  TResponseToolChoiceParams = class(TJSONParam);

  THostedToolParams = class(TResponseToolChoiceParams)
  public
    /// <summary>
    /// The type of hosted tool the model should to use. Learn more about built-in tools.
    /// <para>
    /// Allowed values are:
    /// </para>
    /// <para>
    /// - file_search
    /// </para>
    /// <para>
    /// - web_search_preview
    /// </para>
    /// <para>
    /// - computer_use_preview
    /// </para>
    /// </summary>
    function &Type(const Value: THostedTooltype): THostedToolParams; overload;
    /// <summary>
    /// The type of hosted tool the model should to use. Learn more about built-in tools.
    /// <para>
    /// Allowed values are:
    /// </para>
    /// <para>
    /// - file_search
    /// </para>
    /// <para>
    /// - web_search_preview
    /// </para>
    /// <para>
    /// - computer_use_preview
    /// </para>
    /// </summary>
    function &Type(const Value: string): THostedToolParams; overload;

    class function New(const Value: string): THostedToolParams;
  end;

  TFunctionToolParams = class(TResponseToolChoiceParams)
  public
    /// <summary>
    /// The name of the function to call.
    /// </summary>
    function Name(const Value: string): TFunctionToolParams;
    /// <summary>
    /// For function calling, the type is always function.
    /// </summary>
    function &Type(const Value: string = 'function'): TFunctionToolParams;

    class function New: TFunctionToolParams;
  end;

  /// <summary>
  /// Value is TFileSearchFilters or his descendant e.g. TComparisonFilter, TCompoundFilter
  /// </summary>
  TFileSearchFilters = class(TJSONParam);

  TComparisonFilter = class(TFileSearchFilters)
  public
    /// <summary>
    /// The key to compare against the value.
    /// </summary>
    function Key(const Value: string): TComparisonFilter;
    /// <summary>
    /// Specifies the comparison operator: eq, ne, gt, gte, lt, lte.
    /// </summary>
    /// <remarks>
    /// <para>
    /// - eq: equals
    /// </para>
    /// <para>
    /// - ne: not equal
    /// </para>
    /// <para>
    /// - gt: greater than
    /// </para>
    /// <para>
    /// - gte: greater than or equal
    /// </para>
    /// <para>
    /// - lt: less than
    /// </para>
    /// <para>
    /// - lte: less than or equal
    /// </para>
    /// </remarks>
    function &Type(const Value: TComparisonFilterType): TComparisonFilter; overload;
    /// <summary>
    /// Specifies the comparison operator: eq, ne, gt, gte, lt, lte.
    /// </summary>
    /// <remarks>
    /// <para>
    /// - eq: equals
    /// </para>
    /// <para>
    /// - ne: not equal
    /// </para>
    /// <para>
    /// - gt: greater than
    /// </para>
    /// <para>
    /// - gte: greater than or equal
    /// </para>
    /// <para>
    /// - lt: less than
    /// </para>
    /// <para>
    /// - lte: less than or equal
    /// </para>
    /// </remarks>
    function &Type(const Value: string): TComparisonFilter; overload;
    /// <summary>
    /// Uses text for comparison
    /// <para>
    /// equals for eq, notEqual for ne, greaterThan for gt, greaterThanOrEqual for gte, lessThan for lt, lessThanOrEqual for lte
    /// </para>
    /// </summary>
    function Comparison(const Value: string): TComparisonFilter;
    /// <summary>
    /// The value to compare against the attribute key; supports string, number, or boolean types.
    /// </summary>
    function Value(const Value: string): TComparisonFilter; overload;
    /// <summary>
    /// The value to compare against the attribute key; supports string, number, or boolean types.
    /// </summary>
    function Value(const Value: Integer): TComparisonFilter; overload;
    /// <summary>
    /// The value to compare against the attribute key; supports string, number, or boolean types.
    /// </summary>
    function Value(const Value: Double): TComparisonFilter; overload;
    /// <summary>
    /// The value to compare against the attribute key; supports string, number, or boolean types.
    /// </summary>
    function Value(const Value: Boolean): TComparisonFilter; overload;

    class function New: TComparisonFilter; overload;
    class function New(const Key, Comparison, Value: string): TComparisonFilter; overload;
    class function New(const Key, Comparison: string; const Value: Integer): TComparisonFilter; overload;
    class function New(const Key, Comparison: string; const Value: Double): TComparisonFilter; overload;
    class function New(const Key, Comparison: string; const Value: Boolean): TComparisonFilter; overload;
  end;

  TCompoundFilter = class(TFileSearchFilters)
  public
    /// <summary>
    /// Type of operation: and or or.
    /// </summary>
    function &Type(const Value: TCompoundFilterType): TCompoundFilter;
    function &And: TCompoundFilter; overload;
    function &Or: TCompoundFilter; overload;
    /// <summary>
    /// Array of filters to combine. Items can be ComparisonFilter or CompoundFilter.
    /// </summary>
    function Filters(const Value: TArray<TFileSearchFilters>): TCompoundFilter;

    class function New: TCompoundFilter;
    class function &And(const Value: TArray<TFileSearchFilters>): TCompoundFilter; overload;
    class function &Or(const Value: TArray<TFileSearchFilters>): TCompoundFilter; overload;
  end;

  /// <summary>
  /// Value is TResponseToolParams or his descendant e.g. TResponseFileSearchParams, TResponseFunctionParams,
  /// TResponseComputerUseParams, TResponseWebSearchParams
  /// </summary>
  TResponseToolParams = class(TJSONParam);

  TResponseFileSearchParams = class(TResponseToolParams)
  public
    /// <summary>
    /// The IDs of the vector stores to search.
    /// </summary>
    function VectorStoreIds(const Value: TArray<string>): TResponseFileSearchParams;
    /// <summary>
    /// A filter to apply based on file attributes.
    /// </summary>
    /// <remarks>
    /// Value is TFileSearchFilters or his descendant e.g. TComparisonFilter, TCompoundFilter
    /// </remarks>
    function Filters(const Value: TFileSearchFilters): TResponseFileSearchParams;
    /// <summary>
    /// The maximum number of results to return. This number should be between 1 and 50 inclusive
    /// </summary>
    function MaxNumResults(const Value: Integer): TResponseFileSearchParams;
    /// <summary>
    /// Ranking options for search.
    /// </summary>
    function RankingOptions(const Value: TRankingOptionsParams): TResponseFileSearchParams;
    /// <summary>
    /// The type of the file search tool. Always file_search.
    /// </summary>
    function &Type(const Value: string = 'file_search'): TResponseFileSearchParams;

    class function New: TResponseFileSearchParams;
  end;

  TResponseFunctionParams = class(TResponseToolParams)
  public
    /// <summary>
    /// A description of the function. Used by the model to determine whether or not to call the function.
    /// </summary>
    function Description(const Value: string): TResponseFunctionParams;
    /// <summary>
    /// The name of the function to call.
    /// </summary>
    function Name(const Value: string): TResponseFunctionParams;
    /// <summary>
    /// A JSON schema object describing the parameters of the function.
    /// </summary>
    function Parameters(const Value: TSchemaParams): TResponseFunctionParams; overload;
    /// <summary>
    /// A JSON schema object describing the parameters of the function.
    /// </summary>
    function Parameters(const Value: string): TResponseFunctionParams; overload;
    /// <summary>
    /// Whether to enforce strict parameter validation. Default true.
    /// </summary>
    function Strict(const Value: Boolean): TResponseFunctionParams;
    /// <summary>
    /// The type of the function tool. Always function.
    /// </summary>
    function &Type(const Value: string = 'function'): TResponseFunctionParams;

    class function New: TResponseFunctionParams; overload;
    class function New(const Value: IFunctionCore): TResponseFunctionParams; overload;
  end;

  TResponseComputerUseParams = class(TResponseToolParams)
  public
    /// <summary>
    /// The height of the computer display
    /// </summary>
    function DisplayHeight(const Value: Integer): TResponseComputerUseParams;
    /// <summary>
    /// The width of the computer display.
    /// </summary>
    function DisplayWidth(const Value: Integer): TResponseComputerUseParams;
    /// <summary>
    /// The type of computer environment to control.
    /// </summary>
    function Environment(const Value: string): TResponseComputerUseParams;
    /// <summary>
    /// The type of the computer use tool. Always computer_use_preview.
    /// </summary>
    function &Type(const Value: string = 'computer_use_preview'): TResponseComputerUseParams;

    class function New: TResponseComputerUseParams;
  end;

  TResponseUserLocationParams = class(TJSONParam)
  public
    /// <summary>
    /// Free text input for the city of the user, e.g. San Francisco.
    /// </summary>
    function City(const Value: string): TResponseUserLocationParams;
    /// <summary>
    /// The two-letter ISO country code of the user, e.g. US.
    /// </summary>
    function Country(const Value: string): TResponseUserLocationParams;
    /// <summary>
    /// Free text input for the region of the user, e.g. California.
    /// </summary>
    function Region(const Value: string): TResponseUserLocationParams;
    /// <summary>
    /// The IANA timezone of the user, e.g. America/Los_Angeles.
    /// </summary>
    function Timezone(const Value: string): TResponseUserLocationParams;
    /// <summary>
    /// The type of location approximation. Always approximate.
    /// </summary>
    function &Type(const Value: string = 'approximate'): TResponseUserLocationParams;

    class function New: TResponseUserLocationParams;
  end;

  TResponseWebSearchParams = class(TResponseToolParams)
  public
    /// <summary>
    /// High level guidance for the amount of context window space to use for the search.
    /// One of low, medium, or high. medium is the default.
    /// </summary>
    function SearchContextSize(const Value: TSearchWebOptions): TResponseWebSearchParams; overload;
    /// <summary>
    /// High level guidance for the amount of context window space to use for the search.
    /// One of low, medium, or high. medium is the default.
    /// </summary>
    function SearchContextSize(const Value: string = 'medium'): TResponseWebSearchParams; overload;
    /// <summary>
    /// Approximate location parameters for the search.
    /// </summary>
    function UserLocation(const Value: TResponseUserLocationParams): TResponseWebSearchParams;
    /// <summary>
    /// The type of the web search tool. One of:
    /// <para>
    /// - web_search_preview
    /// </para>
    /// <para>
    /// - web_search_preview_2025_03_11
    /// </para>
    /// </summary>
    function &Type(const Value: TWebSearchType): TResponseWebSearchParams; overload;
    /// <summary>
    /// The type of the web search tool. One of:
    /// <para>
    /// - web_search_preview
    /// </para>
    /// <para>
    /// - web_search_preview_2025_03_11
    /// </para>
    /// </summary>
    function &Type(const Value: string = 'web_search_preview'): TResponseWebSearchParams; overload;

    class function New: TResponseWebSearchParams;
  end;

  TResponsesParams = class(TJSONParam)
  public
    /// <summary>
    /// Text, image, or file inputs to the model, used to generate a response.
    /// </summary>
    function Input(const Value: string): TResponsesParams; overload;
    /// <summary>
    /// Text, image, or file inputs to the model, used to generate a response.
    /// </summary>
    /// <param name="Value">
    /// Value is TInputListItem or his descendant e.g. TInputMessage, TItemInputMessage, TItemOutputMessage,
    /// TItemOutputMessage, TFileSearchToolCall, TComputerToolCall
    /// </param>
    function Input(const Value: TArray<TInputListItem>): TResponsesParams; overload;
    /// <summary>
    /// Text, image, or file inputs to the model, used to generate a response.
    /// </summary>
    /// <param name="Value">
    /// Value is TJSONArray
    /// </param>
    function Input(const Value: TJSONArray): TResponsesParams; overload;
    /// <summary>
    /// Method to create a user default role message payload with multiple document references
    /// (images and/or PDF)-local or distant documents.
    /// </summary>
    /// <param name="Content">
    /// The main content of the user message.
    /// </param>
    /// <param name="Docs">
    /// An array of document paths to include. Only for images.
    /// </param>
    function Input(const Content: string; const Docs: TArray<string>; const Role: string = 'user'): TResponsesParams; overload;
    /// <summary>
    /// Model ID used to generate the response, like gpt-4o or o1. OpenAI offers a wide range of models
    /// with different capabilities, performance characteristics, and price points. Refer to the model
    /// guide to browse and compare available models.
    /// </summary>
    function Model(const Value: string): TResponsesParams;
    /// <summary>
    /// Specify additional output data to include in the model response. Currently supported values are:
    /// <para>
    /// file_search_call.results: Include the search results of the file search tool call.
    /// </para>
    /// <para>
    /// message.input_image.image_url: Include image urls from the input message.
    /// </para>
    /// <para>
    /// computer_call_output.output.image_url: Include image urls from the computer call output.
    /// </para>
    /// </summary>
    function Include(const Value: TArray<TOutputIncluding>): TResponsesParams; overload;
    /// <summary>
    /// Specify additional output data to include in the model response. Currently supported values are:
    /// <para>
    /// file_search_call.results: Include the search results of the file search tool call.
    /// </para>
    /// <para>
    /// message.input_image.image_url: Include image urls from the input message.
    /// </para>
    /// <para>
    /// computer_call_output.output.image_url: Include image urls from the computer call output.
    /// </para>
    /// </summary>
    function Include(const Value: TArray<string>): TResponsesParams; overload;
    /// <summary>
    /// Inserts a system (or developer) message as the first item in the model's context.
    /// </summary>
    /// <remarks>
    /// When using along with previous_response_id, the instructions from a previous response will not be carried
    /// over to the next response. This makes it simple to swap out system (or developer) messages in new responses.
    /// </remarks>
    function Instructions(const Value: string): TResponsesParams;
    /// <summary>
    /// An upper bound for the number of tokens that can be generated for a response, including visible output tokens
    /// and reasoning tokens.
    /// </summary>
    function MaxOutputTokens(const Value: Integer): TResponsesParams;
    /// <summary>
    /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information
    /// about the object in a structured format, and querying for objects via API or the dashboard.
    /// </summary>
    /// <remarks>
    /// Keys are strings with a maximum length of 64 characters. Values are strings with a maximum length of 512 characters.
    /// </remarks>
    function Metadata(const Value: TJSONObject): TResponsesParams;
    /// <summary>
    /// Whether to allow the model to run tool calls in parallel.
    /// </summary>
    function ParallelToolCalls(const Value: Boolean): TResponsesParams;
    /// <summary>
    /// The unique ID of the previous response to the model. Use this to create multi-turn conversations. Learn more about
    /// conversation state.
    /// </summary>
    function PreviousResponseId(const Value: string): TResponsesParams;
    /// <summary>
    /// o-series models only. Configuration options for reasoning models.
    /// </summary>
    function Reasoning(const Value: TReasoningParams): TResponsesParams; overload;
    /// <summary>
    /// o-series models only. Configuration options for reasoning models.
    /// </summary>
    function Reasoning(const Value: string): TResponsesParams; overload;
    /// <summary>
    /// Whether to store the generated model response for later retrieval via API.
    /// </summary>
    function Store(const Value: Boolean = True): TResponsesParams;
    /// <summary>
    /// if set to true, the model response data will be streamed to the client as it is generated using server-sent events.
    /// </summary>
    function Stream(const Value: Boolean = True): TResponsesParams;
    /// <summary>
    /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while
    /// lower values like 0.2 will make it more focused and deterministic. We generally recommend altering this or top_p
    /// but not both.
    /// </summary>
    function Temperature(const Value: Double): TResponsesParams;
    /// <summary>
    /// Configuration options for a text response from the model. Can be plain text or structured JSON data. Learn more:
    /// <para>
    /// - Text inputs and outputs https://platform.openai.com/docs/guides/text
    /// </para>
    /// <para>
    /// - Structured Outputs https://platform.openai.com/docs/guides/structured-outputs
    /// </para>
    /// </summary>
    function Text(const Value: TTextParams): TResponsesParams; overload;
    /// <summary>
    /// Configuration options for a text response from the model. Can be plain text or structured JSON data. Learn more:
    /// <para>
    /// - Text inputs and outputs https://platform.openai.com/docs/guides/text
    /// </para>
    /// <para>
    /// - Structured Outputs https://platform.openai.com/docs/guides/structured-outputs
    /// </para>
    /// </summary>
    /// <remarks>
    /// Value is TTextFormatParams or his descendant e.g. TTextFormatTextPrams, TTextJSONSchemaParams, TTextJSONObjectParams,
    /// TTextParams
    /// </remarks>
    function Text(const Value: TTextFormatParams): TResponsesParams; overload;
    /// <summary>
    /// Configuration options for a text response from the model. Can be plain text or structured JSON data. Learn more:
    /// <para>
    /// - Text inputs and outputs https://platform.openai.com/docs/guides/text
    /// </para>
    /// <para>
    /// - Structured Outputs https://platform.openai.com/docs/guides/structured-outputs
    /// </para>
    /// </summary>
    function Text(const Value: string; const SchemaParams: TTextJSONSchemaParams = nil): TResponsesParams; overload;
    /// <summary>
    /// Configuration options for a text response from the model. Can be plain text or structured JSON data. Learn more:
    /// <para>
    /// - Text inputs and outputs https://platform.openai.com/docs/guides/text
    /// </para>
    /// <para>
    /// - Structured Outputs https://platform.openai.com/docs/guides/structured-outputs
    /// </para>
    /// </summary>
    function Text(const Value: TResponseOption; const SchemaParams: TTextJSONSchemaParams = nil): TResponsesParams; overload;
    /// <summary>
    /// How the model should select which tool (or tools) to use when generating a response. See the tools parameter
    /// to see how to specify which tools the model can call.
    /// </summary>
    function ToolChoice(const Value: TToolChoice): TResponsesParams; overload;
    /// <summary>
    /// How the model should select which tool (or tools) to use when generating a response. See the tools parameter
    /// to see how to specify which tools the model can call.
    /// </summary>
    /// <remarks>
    /// Controls which (if any) tool is called by the model.
    /// <para>
    /// - none means the model will not call any tool and instead generates a message.
    /// </para>
    /// <para>
    /// - auto means the model can pick between generating a message or calling one or more tools.
    /// </para>
    /// <para>
    /// - required means the model must call one or more tools.
    /// </para>
    /// </remarks>
    function ToolChoice(const Value: string): TResponsesParams; overload;
    /// <summary>
    /// How the model should select which tool (or tools) to use when generating a response. See the tools parameter
    /// to see how to specify which tools the model can call.
    /// </summary>
    /// <remarks>
    /// Value is TResponseToolChoiceParams or his descendant e.g. THostedToolParams, TFunctionToolParams
    /// </remarks>
    function ToolChoice(const Value: TResponseToolChoiceParams): TResponsesParams; overload;
    /// <summary>
    /// An array of tools the model may call while generating a response. You can specify which tool to use by setting
    /// the tool_choice parameter.
    /// <para>
    /// The two categories of tools you can provide the model are:
    /// </para>
    /// <para>
    /// - Built-in tools: Tools that are provided by OpenAI that extend the model's capabilities, like web search or
    /// file search. Learn more about built-in tools.
    /// </para>
    /// <para>
    /// - Function calls (custom tools): Functions that are defined by you, enabling the model to call your own code.
    /// Learn more about function calling.
    /// </para>
    /// </summary>
    /// <remarks>
    /// The descendant avalaible for then TResponseToolParams class are :
    /// <para>
    /// - TResponseFileSearchParams, TResponseFunctionParams, TResponseComputerUseParams, TResponseWebSearchParams
    /// </para>
    /// </remarks>
    function Tools(const Value: TArray<TResponseToolParams>): TResponsesParams; overload;
    /// <summary>
    /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of
    /// the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass
    /// are considered.
    /// </summary>
    /// <remarks>
    /// We generally recommend altering this or temperature but not both.
    /// </remarks>
    function TopP(const Value: Double): TResponsesParams;
    /// <summary>
    /// The truncation strategy to use for the model response.
    /// </summary>
    /// <remarks>
    /// <para>
    /// - auto: If the context of this response and previous ones exceeds the model's context window size, the model
    /// will truncate the response to fit the context window by dropping input items in the middle of the conversation.
    /// </para>
    /// <para>
    /// - disabled (default): If a model response will exceed the context window size for a model, the request will fail
    /// with a 400 error.
    /// </para>
    /// </remarks>
    function Truncation(const Value: TResponseTruncationType): TResponsesParams; overload;
    /// <summary>
    /// The truncation strategy to use for the model response.
    /// </summary>
    /// <remarks>
    /// <para>
    /// - auto: If the context of this response and previous ones exceeds the model's context window size, the model
    /// will truncate the response to fit the context window by dropping input items in the middle of the conversation.
    /// </para>
    /// <para>
    /// - disabled (default): If a model response will exceed the context window size for a model, the request will fail
    /// with a 400 error.
    /// </para>
    /// </remarks>
    function Truncation(const Value: string): TResponsesParams; overload;
    /// <summary>
    /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. Learn more.
    /// </summary>
    function User(const Value: string): TResponsesParams;
  end;

  TResponseError = class
  private
    FCode: string;
    FMessage: string;
  public
    /// <summary>
    /// The error code for the response.
    /// </summary>
    property Code: string read FCode write FCode;
    /// <summary>
    /// A human-readable description of the error.
    /// </summary>
    property Message: string read FMessage write FMessage;
  end;

  TResponseIncompleteDetails = class
  private
    FReason: string;
  public
    /// <summary>
    /// The reason why the response is incomplete.
    /// </summary>
    property Reason: string read FReason write FReason;
  end;

  TResponseMessageContentCommon = class
  private
    [JsonReflectAttribute(ctString, rtString, TResponseContentTypeInterceptor)]
    FType: TResponseContentType;
  public
    /// <summary>
    /// The type of the output text. One of output_text or refusal
    /// </summary>
    property &Type: TResponseContentType read FType write FType;
  end;

  TResponseMessageContent = class(TResponseMessageContentCommon)
  private
    FAnnotations: TArray<TResponseMessageAnnotation>;
    FText: string;
  public
    /// <summary>
    /// The annotations of the text output.
    /// </summary>
    property Annotations: TArray<TResponseMessageAnnotation> read FAnnotations write FAnnotations;
    /// <summary>
    /// The text output from the model.
    /// </summary>
    property Text: string read FText write FText;
    destructor Destroy; override;
  end;

  TResponseMessageRefusal = class(TResponseMessageContent)
  private
    FRefusal: string;
  public
    /// <summary>
    /// The refusal explanationfrom the model.
    /// </summary>
    property Refusal: string read FRefusal write FRefusal;
  end;

  {--- This class is made up of the following classes:
     TResponseMessageContentCommon, TResponseMessageContent, TResponseMessageRefusal }
  TResponseContent = class(TResponseMessageRefusal);

  TResponseReasoningSummary = class
  private
    FText: string;
    FType: string;
  public
    /// <summary>
    /// A short summary of the reasoning used by the model when generating the response.
    /// </summary>
    property Text: string read FText write FText;
    /// <summary>
    /// The type of the object. Always summary_text.
    /// </summary>
    property &Type: string read FType write FType;
  end;

  TResponseReasoning = class
  private
    [JsonReflectAttribute(ctString, rtString, TReasoningEffortInterceptor)]
    FEffort: TReasoningEffort;
    FSummary: string;
  public
    /// <summary>
    /// o-series models only
    /// </summary>
    /// <remarks>
    /// Constrains effort on reasoning for reasoning models. Currently supported values are low, medium, and high.
    /// Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
    /// </remarks>
    property Effort: TReasoningEffort read FEffort write FEffort;
    /// <summary>
    /// A summary of the reasoning performed by the model. This can be useful for debugging and understanding
    /// the model's reasoning process. One of auto, concise, or detailed.
    /// </summary>
    property Summary: string read FSummary write FSummary;
  end;

  TResponseRankingOptions = class
  private
    FRanker: string;
    [JsonNameAttribute('score_threshold')]
    FScoreThreshold: Double;
  public
    /// <summary>
    /// The ranker to use for the file search.
    /// </summary>
    property Ranker: string read FRanker write FRanker;
    /// <summary>
    /// The score threshold for the file search, a number between 0 and 1. Numbers closer to 1 will attempt to return
    /// only the most relevant results, but may return fewer results.
    /// </summary>
    property ScoreThreshold: Double read FScoreThreshold write FScoreThreshold;
  end;

  TResponseFileSearchFiltersCommon = class
  private
    [JsonReflectAttribute(ctString, rtString, TResponseToolsFilterTypeInterceptor)]
    FType: TResponseToolsFilterType;
  public
    /// <summary>
    /// Specifies the comparison operator or the type of operation
    /// </summary>
    property &Type: TResponseToolsFilterType read FType write FType;
  end;

  TResponseFileSearchFiltersComparaison = class(TResponseFileSearchFiltersCommon)
  private
    FKey: string;
    FValue: Variant;
  public
    /// <summary>
    /// The key to compare against the value.
    /// </summary>
    property Key: string read FKey write FKey;
    /// <summary>
    /// The value to compare against the attribute key; supports string, number, or boolean types.
    /// </summary>
    property Value: Variant read FValue write FValue;
  end;

  TResponseFileSearchFiltersCompound = class(TResponseFileSearchFiltersComparaison)
  private
    FFilters: TArray<TResponseFileSearchFiltersCompound>;
  public
    /// <summary>
    /// Array of filters to combine. Items can be ComparisonFilter or CompoundFilter.
    /// </summary>
    property Filters: TArray<TResponseFileSearchFiltersCompound> read FFilters write FFilters;
    destructor Destroy; override;
  end;

  {--- This class is made up of the following classes:
    TResponseFileSearchFiltersCommon, TResponseFileSearchFiltersComparaison,
    TResponseFileSearchFiltersCompound }
  TResponseFileSearchFilters = class(TResponseFileSearchFiltersCompound);

  TResponseWebSearchLocation = class
  private
    FType: string;
    FCity: string;
    FCountry: string;
    FRegion: string;
    FTimezone: string;
  public
    /// <summary>
    /// The type of location approximation. Always approximate.
    /// </summary>
    property &Type: string read FType write FType;
    /// <summary>
    /// Free text input for the city of the user, e.g. San Francisco.
    /// </summary>
    property City: string read FCity write FCity;
    /// <summary>
    /// The two-letter ISO country code of the user, e.g. US. https://en.wikipedia.org/wiki/ISO_3166-1
    /// </summary>
    property Country: string read FCountry write FCountry;
    /// <summary>
    /// Free text input for the region of the user, e.g. California.
    /// </summary>
    property Region: string read FRegion write FRegion;
    /// <summary>
    /// The IANA timezone of the user, e.g. America/Los_Angeles. https://timeapi.io/documentation/iana-timezones
    /// </summary>
    property Timezone: string read FTimezone write FTimezone;
  end;

  TResponseOutputCommon = class
  private
    FId: string;
    FStatus: string;
    [JsonReflectAttribute(ctString, rtString, TResponseTypesInterceptor)]
    FType: TResponseTypes;
  public
    /// <summary>
    /// The unique ID of the output message.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// The status of the message. One of in_progress, completed, incomplete (or failed)
    /// </summary>
    property Status: string read FStatus write FStatus;
    /// <summary>
    /// The type of the output message
    /// </summary>
    property &Type: TResponseTypes read FType write FType;
  end;

  TResponseOutputMessage = class(TResponseOutputCommon)
  private
    FContent: TArray<TResponseContent>;
    [JsonReflectAttribute(ctString, rtString, TRoleInterceptor)]
    FRole: TRole;
  public
    /// <summary>
    /// The content of the output message.
    /// </summary>
    property Content: TArray<TResponseContent> read FContent write FContent;
    /// <summary>
    /// The role of the output message. Always assistant.
    /// </summary>
    property Role: TRole read FRole write FRole;
    destructor Destroy; override;
  end;

  TResponseOutputFileSearch = class(TResponseOutputMessage)
  private
    FQueries: TArray<string>;
    FResults: TArray<TFileSearchResult>;
  public
    /// <summary>
    /// The queries used to search for files.
    /// </summary>
    property Queries: TArray<string> read FQueries write FQueries;
    /// <summary>
    /// The results of the file search tool call.
    /// </summary>
    property Results: TArray<TFileSearchResult> read FResults write FResults;
    destructor Destroy; override;
  end;

  TResponseOutputFunction = class(TResponseOutputFileSearch)
  private
    FArguments: string;
    [JsonNameAttribute('call_id')]
    FCallId: string;
    FName: string;
  public
    /// <summary>
    /// A JSON string of the arguments to pass to the function.
    /// </summary>
    property Arguments: string read FArguments write FArguments;
    /// <summary>
    /// The unique ID of the function tool call generated by the model.
    /// </summary>
    property CallId: string read FCallId write FCallId;
    /// <summary>
    /// The name of the function to run.
    /// </summary>
    property Name: string read FName write FName;
  end;

  TResponseOutputWebSearch = class(TResponseOutputFunction)
    {--- All fields are already described into ancestors }
  end;

  TResponseOutputComputer = class(TResponseOutputWebSearch)
  private
    {--- FCallId: string; already défined in TResponseOutputFunction }
    FAction: TComputerAction;
    [JsonNameAttribute('pending_safety_checks')]
    FPendingSafetyChecks: TArray<TPendingSafetyChecks>;
  public
    /// <summary>
    /// Action to execute on computer
    /// </summary>
    property Action: TComputerAction read FAction write FAction;
    /// <summary>
    /// The pending safety checks for the computer call.
    /// </summary>
    property PendingSafetyChecks: TArray<TPendingSafetyChecks> read FPendingSafetyChecks write FPendingSafetyChecks;
    destructor Destroy; override;
  end;

  TResponseOutputReasoning = class(TResponseOutputComputer)
  private
    FSummary: TArray<TResponseReasoningSummary>;
  public
    /// <summary>
    /// Reasoning text contents.
    /// </summary>
    property Summary: TArray<TResponseReasoningSummary> read FSummary write FSummary;
    destructor Destroy; override;
  end;

  {--- This class is made up of the following classes:
    TResponseOutputCommon, TResponseOutputMessage, TResponseOutputFileSearch, TResponseOutputFunction,
    TResponseOutputWebSearch, TResponseOutputComputer, TResponseOutputReasoning}
  TResponseOutput = class(TResponseOutputReasoning);

  TResponseTextFormatCommon = class
  private
    [JsonReflectAttribute(ctString, rtString, TResponseFormatTypeInterceptor)]
    FType: TResponseFormatType;
  public
    /// <summary>
    /// The type of response format being defined. One of text, json_schema, json_object
    /// </summary>
    property &Type: TResponseFormatType read FType write FType;
  end;

  TResponseFormatText = class(TResponseTextFormatCommon)
    {--- All fields are already described into ancestors }
  end;

  TResponseFormatJSONObject = class(TResponseFormatText)
    {--- All fields are already described into ancestors }
  end;

  TResponseFormatJSONSchema = class(TResponseFormatJSONObject)
  private
    FName: string;
    [JsonReflectAttribute(ctString, rtString, TMetadataInterceptor)]
    FSchema: string;
    FDescription: string;
    FStrict: Boolean;
  public
    /// <summary>
    /// The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum
    /// length of 64.
    /// </summary>
    property Name: string read FName write FName;
    /// <summary>
    /// The schema for the response format, described as a JSON Schema object.
    /// </summary>
    /// <remarks>
    /// Learn how to build JSON schemas https://json-schema.org/.
    /// </remarks>
    property Schema: string read FSchema write FSchema;
    /// <summary>
    /// A description of what the response format is for, used by the model to determine how to respond in the format.
    /// </summary>
    property Description: string read FDescription write FDescription;
    /// <summary>
    /// Whether to enable strict schema adherence when generating the output. If set to true, the model will always
    /// follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict
    /// is true.
    /// </summary>
    /// <remarks>
    /// To learn more, read the Structured Outputs guide https://platform.openai.com/docs/guides/structured-outputs
    /// </remarks>
    property Strict: Boolean read FStrict write FStrict;
  end;

  {--- This class is made up of the following classes:
    TResponseTextFormatCommon, TResponseFormatText, TResponseFormatJSONObject,
    TResponseFormatJSONSchema }
  TResponseTextFormat = class(TResponseFormatJSONSchema);

  TResponseText = class
  private
    FFormat: TResponseTextFormat;
  public
    /// <summary>
    /// An object specifying the format that the model must output.
    /// </summary>
    property Format: TResponseTextFormat read FFormat write FFormat;
    destructor Destroy; override;
  end;

  TResponseToolCommon = class
  private
    [JsonReflectAttribute(ctString, rtString, TResponseToolsTypeInterceptor)]
    FType: TResponseToolsType;
  public
    /// <summary>
    /// The type of the tool
    /// </summary>
    property &Type: TResponseToolsType read FType write FType;
  end;

  TResponseToolFileSearch = class(TResponseToolCommon)
  private
    [JsonNameAttribute('vector_store_ids')]
    FVectorStoreIds: TArray<string>;
    FFilters: TResponseFileSearchFilters;
    [JsonNameAttribute('max_num_results')]
    FMaxNumResults: Int64;
    [JsonNameAttribute('ranking_options')]
    FRankingOptions: TResponseRankingOptions;
  public
    /// <summary>
    /// The IDs of the vector stores to search.
    /// </summary>
    property VectorStoreIds: TArray<string> read FVectorStoreIds write FVectorStoreIds;
    /// <summary>
    /// A filter to apply based on file attributes.
    /// </summary>
    property Filters: TResponseFileSearchFilters read FFilters write FFilters;
    /// <summary>
    /// The maximum number of results to return. This number should be between 1 and 50 inclusive.
    /// </summary>
    property MaxNumResults: Int64 read FMaxNumResults write FMaxNumResults;
    /// <summary>
    /// Ranking options for search.
    /// </summary>
    property RankingOptions: TResponseRankingOptions read FRankingOptions write FRankingOptions;
    destructor Destroy; override;
  end;

  TResponseToolFunction = class(TResponseToolFileSearch)
  private
    FName: string;
    [JsonReflectAttribute(ctString, rtString, TMetadataInterceptor)]
    FParameters: string;
    FStrict: Boolean;
    FDescription: string;
  public
    /// <summary>
    /// The name of the function to call.
    /// </summary>
    property Name: string read FName write FName;
    /// <summary>
    /// A JSON schema object describing the parameters of the function.
    /// </summary>
    property Parameters: string read FParameters write FParameters;
    /// <summary>
    /// Whether to enforce strict parameter validation. Default true.
    /// </summary>
    property Strict: Boolean read FStrict write FStrict;
    /// <summary>
    /// A description of the function. Used by the model to determine whether or not to call the function.
    /// </summary>
    property Description: string read FDescription write FDescription;
  end;

  TResponseToolComputerUse = class(TResponseToolFunction)
  private
    [JsonNameAttribute('display_height')]
    FDisplayHeight: Int64;
    [JsonNameAttribute('display_width')]
    FDisplayWidth: Int64;
    FEnvironment: string;
  public
    /// <summary>
    /// The height of the computer display.
    /// </summary>
    property DisplayHeight: Int64 read FDisplayHeight write FDisplayHeight;
    /// <summary>
    /// The width of the computer display.
    /// </summary>
    property DisplayWidth: Int64 read FDisplayWidth write FDisplayWidth;
    /// <summary>
    /// The type of computer environment to control.
    /// </summary>
    property Environment: string read FEnvironment write FEnvironment;
  end;

  TResponseToolWebSearch = class(TResponseToolComputerUse)
  private
    [JsonReflectAttribute(ctString, rtString, TReasoningEffortInterceptor)]
    [JsonNameAttribute('search_context_size')]
    FSearchContextSize: TReasoningEffort;
    [JsonNameAttribute('user_location')]
    FUserLocation: TResponseWebSearchLocation;
  public
    /// <summary>
    /// High level guidance for the amount of context window space to use for the search. One of low, medium, or high.
    /// medium is the default.
    /// </summary>
    property SearchContextSize: TReasoningEffort read FSearchContextSize write FSearchContextSize;
    /// <summary>
    /// Approximate location parameters for the search.
    /// </summary>
    property UserLocation: TResponseWebSearchLocation read FUserLocation write FUserLocation;
    destructor Destroy; override;
  end;

  {--- This class is made up of the following classes:
    TResponseToolCommon, TResponseToolFileSearch, TResponseToolFunction,
    TResponseToolComputerUse, TResponseToolWebSearch}
  TResponseTool = class(TResponseToolWebSearch);

  TInputTokensDetails = class
  private
    [JsonNameAttribute('cached_tokens')]
    FCachedTokens: Int64;
  public
    /// <summary>
    /// The number of tokens that were retrieved from the cache.
    /// </summary>
    /// <remarks>
    /// More on prompt caching. https://platform.openai.com/docs/guides/prompt-caching
    /// </remarks>
    property CachedTokens: Int64 read FCachedTokens write FCachedTokens;
  end;

  TOutputTokensDetails = class
  private
    [JsonNameAttribute('reasoning_tokens')]
    FReasoningTokens: Int64;
  public
    /// <summary>
    /// The number of reasoning tokens.
    /// </summary>
    property ReasoningTokens: Int64 read FReasoningTokens write FReasoningTokens;
  end;

  TResponseUsage = class
  private
    [JsonNameAttribute('input_tokens')]
    FInputTokens: Int64;
    [JsonNameAttribute('input_tokens_details')]
    FInputTokensDetails: TInputTokensDetails;
    [JsonNameAttribute('output_tokens')]
    FOutputTokens: Int64;
    [JsonNameAttribute('output_tokens_details')]
    FOutputTokensDetails: TOutputTokensDetails;
    [JsonNameAttribute('total_tokens')]
    FTotalTokens: Int64;
  public
    /// <summary>
    /// The number of input tokens.
    /// </summary>
    property InputTokens: Int64 read FInputTokens write FInputTokens;
    /// <summary>
    /// A detailed breakdown of the input tokens.
    /// </summary>
    property InputTokensDetails: TInputTokensDetails read FInputTokensDetails write FInputTokensDetails;
    /// <summary>
    /// The number of output tokens.
    /// </summary>
    property OutputTokens: Int64 read FOutputTokens write FOutputTokens;
    /// <summary>
    /// A detailed breakdown of the output tokens.
    /// </summary>
    property OutputTokensDetails: TOutputTokensDetails read FOutputTokensDetails write FOutputTokensDetails;
    /// <summary>
    /// The total number of tokens used.
    /// </summary>
    property TotalTokens: Int64 read FTotalTokens write FTotalTokens;
    destructor Destroy; override;
  end;

  TResponse = class(TJSONFingerprint)
  private
    [JsonNameAttribute('created_at')]
    FCreatedAt: TInt64OrNull;
    FError: TResponseError;
    FId: string;
    [JsonNameAttribute('incomplete_details')]
    FIncompleteDetails: TResponseIncompleteDetails;
    FInstructions: string;
    [JsonNameAttribute('max_output_tokens')]
    FMaxOutputTokens: Int64;
    [JsonReflectAttribute(ctString, rtString, TMetadataInterceptor)]
    FMetadata: string;
    FModel: string;
    FObject: string;
    FOutput: TArray<TResponseOutput>;
    [JsonNameAttribute('parallel_tool_calls')]
    FParallelToolCalls: Boolean;
    [JsonNameAttribute('previous_response_id')]
    FPreviousResponseId: string;
    FReasoning: TResponseReasoning;
    [JsonNameAttribute('service_tier')]
    FServiceTier: string;
    [JsonReflectAttribute(ctString, rtString, TResponseStatusInterceptor)]
    FStatus: TResponseStatus;
    FTemperature: Double;
    FText: TResponseText;
    {--- tool_choice string or object :
      This data may be represented in either string or object format, which can lead to complications
      during the deserialization process. }
    FTools: TArray<TResponseTool>;
    [JsonNameAttribute('top_p')]
    FTopP: Double;
    FUsage: TResponseUsage;
    FUser: string;
  protected
    function GetCreatedAtAsString: string;
  public
    /// <summary>
    /// Unix timestamp (in seconds) of when this Response was created.
    /// </summary>
    property CreatedAt: TInt64OrNull read FCreatedAt write FCreatedAt;
    /// <summary>
    /// Unix timestamp as string of when this Response was created.
    /// </summary>
    property CreatedAtAsString: string read GetCreatedAtAsString;
    /// <summary>
    /// An error object returned when the model fails to generate a Response.
    /// </summary>
    property Error: TResponseError read FError write FError;
    /// <summary>
    /// Unique identifier for this Response.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Details about why the response is incomplete.
    /// </summary>
    property IncompleteDetails: TResponseIncompleteDetails read FIncompleteDetails write FIncompleteDetails;
    /// <summary>
    /// Inserts a system (or developer) message as the first item in the model's context.
    /// </summary>
    /// <remarks>
    /// When using along with previous_response_id, the instructions from a previous response will not be carried over
    /// to the next response. This makes it simple to swap out system (or developer) messages in new responses.
    /// </remarks>
    property Instructions: string read FInstructions write FInstructions;
    /// <summary>
    /// An upper bound for the number of tokens that can be generated for a response, including visible output tokens
    /// and reasoning tokens.
    /// </summary>
    property MaxOutputTokens: Int64 read FMaxOutputTokens write FMaxOutputTokens;
    /// <summary>
    /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information
    /// about the object in a structured format, and querying for objects via API or the dashboard.
    /// </summary>
    /// <remarks>
    /// Keys are strings with a maximum length of 64 characters. Values are strings with a maximum length of 512 characters.
    /// </remarks>
    property Metadata: string read FMetadata write FMetadata;
    /// <summary>
    /// Model ID used to generate the response, like gpt-4o or o3. OpenAI offers a wide range of models with different
    /// capabilities, performance characteristics, and price points.
    /// </summary>
    property Model: string read FModel write FModel;
    /// <summary>
    /// The object type of this resource - always set to response.
    /// </summary>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// An array of content items generated by the model.
    /// <para>
    /// - The length and order of items in the output array is dependent on the model's response.
    /// </para>
    /// <para>
    /// - Rather than accessing the first item in the output array and assuming it's an assistant message with the content
    /// generated by the model, you might consider using the output_text property where supported in SDKs.
    /// </para>
    /// </summary>
    property Output: TArray<TResponseOutput> read FOutput write FOutput;
    /// <summary>
    /// Whether to allow the model to run tool calls in parallel.
    /// </summary>
    property ParallelToolCalls: Boolean read FParallelToolCalls write FParallelToolCalls;
    /// <summary>
    /// The unique ID of the previous response to the model. Use this to create multi-turn conversations.
    /// Learn more about conversation state.
    /// </summary>
    property PreviousResponseId: string read FPreviousResponseId write FPreviousResponseId;
    /// <summary>
    /// o-series models only
    /// </summary>
    property Reasoning: TResponseReasoning read FReasoning write FReasoning;
    /// <summary>
    /// Specifies the latency tier to use for processing the request. This parameter is relevant for customers
    /// subscribed to the scale tier service:
    /// <para>
    /// - If set to 'auto', and the Project is Scale tier enabled, the system will utilize scale tier credits
    /// until they are exhausted.
    /// </para>
    /// <para>
    /// - If set to 'auto', and the Project is not Scale tier enabled, the request will be processed using the
    /// default service tier with a lower uptime SLA and no latency guarentee.
    /// </para>
    /// <para>
    /// - If set to 'default', the request will be processed using the default service tier with a lower uptime
    /// SLA and no latency guarentee.
    /// </para>
    /// <para>
    /// - If set to 'flex', the request will be processed with the Flex Processing service tier. Learn more.
    /// </para>
    /// <para>
    /// - When not set, the default behavior is 'auto'.
    /// </para>
    /// When this parameter is set, the response body will include the service_tier utilized.
    /// </summary>
    property ServiceTier: string read FServiceTier write FServiceTier;
    /// <summary>
    /// The status of the response generation. One of completed, failed, in_progress, or incomplete.
    /// </summary>
    property Status: TResponseStatus read FStatus write FStatus;
    /// <summary>
    /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random,
    /// while lower values like 0.2 will make it more focused and deterministic. We generally recommend altering this
    /// or top_p but not both.
    /// </summary>
    property Temperature: Double read FTemperature write FTemperature;
    /// <summary>
    /// Configuration options for a text response from the model. Can be plain text or structured JSON data. Learn more:
    /// <para>
    /// - Text inputs and outputs https://platform.openai.com/docs/guides/text
    /// </para>
    /// <para>
    /// - Structured Outputs https://platform.openai.com/docs/guides/structured-outputs
    /// </para>
    /// </summary>
    property Text: TResponseText read FText write FText;
    /// <summary>
    /// An array of tools the model may call while generating a response. You can specify which tool to use by setting the
    /// tool_choice parameter.
    /// </summary>
    /// <remarks>
    /// The two categories of tools you can provide the model are:
    /// <para>
    /// - Built-in tools: Tools that are provided by OpenAI that extend the model's capabilities, like web search or file
    /// search. Learn more about built-in tools.
    /// </para>
    /// <para>
    /// - Function calls (custom tools): Functions that are defined by you, enabling the model to call your own code. Learn
    /// more about function calling.
    /// </para>
    /// </remarks>
    property Tools: TArray<TResponseTool> read FTools write FTools;
    /// <summary>
    /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of
    /// the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are
    /// considered.
    /// </summary>
    /// <remarks>
    /// We generally recommend altering this or temperature but not both.
    /// </remarks>
    property TopP: Double read FTopP write FTopP;
    /// <summary>
    /// Represents token usage details including input tokens, output tokens, a breakdown of output tokens, and the total
    /// tokens used.
    /// </summary>
    property Usage: TResponseUsage read FUsage write FUsage;
    /// <summary>
    /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse.
    /// </summary>
    /// <remarks>
    /// Learn more. https://platform.openai.com/docs/guides/safety-best-practices#end-user-ids
    /// </remarks>
    property User: string read FUser write FUser;
    destructor Destroy; override;
  end;

  TUrlIncludeParams = class(TUrlParam)
  public
    /// <summary>
    /// Additional fields to include in the response. See the include parameter for Response creation above for more information.
    /// </summary>
    function Include(const Value: TArray<string>): TURLIncludeParams; overload;
    /// <summary>
    /// Additional fields to include in the response. See the include parameter for Response creation above for more information.
    /// </summary>
    function Include(const Value: TArray<TOutputIncluding>): TURLIncludeParams; overload;
  end;

  TUrlResponseListParams = class(TUrlParam)
  public
    /// <summary>
    /// An item ID to list items after, used in pagination.
    /// </summary>
    function After(const Value: string): TUrlResponseListParams;
    /// <summary>
    /// An item ID to list items before, used in pagination.
    /// </summary>
    function Before(const Value: string): TUrlResponseListParams;
    /// <summary>
    /// Additional fields to include in the response. See the include parameter for Response creation above for more information.
    /// </summary>
    function Include(const Value: TArray<string>): TUrlResponseListParams; overload;
    /// <summary>
    /// Additional fields to include in the response. See the include parameter for Response creation above for more information.
    /// </summary>
    function Include(const Value: TArray<TOutputIncluding>): TUrlResponseListParams; overload;
    /// <summary>
    /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.
    /// </summary>
    function Limit(const Value: Integer): TUrlResponseListParams;
    /// <summary>
    /// The order to return the input items in. Default is asc.
    /// <para>
    /// - asc: Return the input items in ascending order.
    /// </para>
    /// <para>
    /// - desc: Return the input items in descending order.
    /// </para>
    /// </summary>
    function Order(const Value: string): TUrlResponseListParams;
  end;

  TResponseDelete = class(TJSONFingerprint)
  private
    FId: string;
    FObject: string;
    FDeleted: Boolean;
  public
    /// <summary>
    /// The ID of the response to delete.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Allways reponse.deleted
    /// </summary>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// True if the response has been deleted
    /// </summary>
    property Deleted: Boolean read FDeleted write FDeleted;
  end;

  TResponseStreamingCommon = class(TJSONFingerprint)
  private
    [JsonReflectAttribute(ctString, rtString, TResponseStreamTypeInterceptor)]
    FType: TResponseStreamType;
  public
    /// <summary>
    /// The type of the event.
    /// </summary>
    property &Type: TResponseStreamType read FType write FType;
  end;

  /// <summary>
  /// response.created : An event that is emitted when a response is created.
  /// </summary>
  TResponseCreated = class(TResponseStreamingCommon)
  private
    FResponse: TResponse;
  public
    /// <summary>
    /// The response depending of the type value (created, in_prgress, completed, failed or incomplete).
    /// </summary>
    property Response: TResponse read FResponse write FResponse;
    destructor Destroy; override;
  end;

  /// <summary>
  /// response.in_progress : Emitted when the response is in progress.
  /// </summary>
  TResponseInProgress = class(TResponseCreated)
    {--- This class does not introduce any new functionality; all methods and properties
         are inherited from its ancestor. }
  end;

  /// <summary>
  /// response.completed : Emitted when the model response is complete.
  /// </summary>
  TResponseCompleted = class(TResponseInProgress)
    {--- This class does not introduce any new functionality; all methods and properties
         are inherited from its ancestor. }
  end;

  /// <summary>
  /// response.failed : An event that is emitted when a response fails.
  /// </summary>
  TResponseFailed = class(TResponseCompleted)
    {--- This class does not introduce any new functionality; all methods and properties
         are inherited from its ancestor. }
  end;

  /// <summary>
  /// response.incomplete : An event that is emitted when a response finishes as incomplete.
  /// </summary>
  TRresponseIncomplete = class(TResponseFailed)
    {--- This class does not introduce any new functionality; all methods and properties
         are inherited from its ancestor. }
  end;

  /// <summary>
  /// response.output_item.added : Emitted when a new output item is added.
  /// </summary>
  TResponseOutputItemAdded = class(TRresponseIncomplete)
  private
    FItem: TResponseOutput;
    [JsonNameAttribute('output_index')]
    FOutputIndex: Integer;
  public
    property Item: TResponseOutput read FItem write FItem;
    property OutputIndex: Integer read FOutputIndex write FOutputIndex;
    destructor Destroy; override;
  end;

  /// <summary>
  /// response.output_item.done : Emitted when an output item is marked done.
  /// </summary>
  TResponseOutputItemDone = class(TResponseOutputItemAdded)
    {--- This class does not introduce any new functionality; all methods and properties
         are inherited from its ancestor. }
  end;

  /// <summary>
  /// response.content_part.added : Emitted when a new content part is added.
  /// </summary>
  TResponseContentpartAdded = class(TResponseOutputItemDone)
  private
    [JsonNameAttribute('content_index')]
    FContentIndex: Int64;
    [JsonNameAttribute('item_id')]
    FItemId: string;
    [JsonNameAttribute('output_index')]
    FOutputIndex: Int64;
    FPart: TResponseContent;
  public
    property ContentIndex: Int64 read FContentIndex write FContentIndex;
    property ItemId: string read FItemId write FItemId;
    property OutputIndex: Int64 read FOutputIndex write FOutputIndex;
    property Part: TResponseContent read FPart write FPart;
    destructor Destroy; override;
  end;

  /// <summary>
  /// response.content_part.done : Emitted when a content part is done.
  /// </summary>
  TResponseContentpartDone = class(TResponseContentpartAdded)
    {--- This class does not introduce any new functionality; all methods and properties
         are inherited from its ancestor. }
  end;

  /// <summary>
  /// response.output_text.delta : Emitted when there is an additional text delta.
  /// </summary>
  TResponseOutputTextDelta = class(TResponseContentpartDone)
  private
    FDelta: string;
  public
    property Delta: string read FDelta write FDelta;
  end;

  /// <summary>
  /// response.output_text.annotation.added : Emitted when a text annotation is added.
  /// </summary>
  TResponseOutputTextAnnotationAdded = class(TResponseOutputTextDelta)
  private
    FAnnotation: TResponseMessageAnnotation;
    [JsonNameAttribute('annotation_index')]
    FAnnotationIndex: Int64;
  public
    property AnnotationIndex: Int64 read FAnnotationIndex write FAnnotationIndex;
    property Annotation: TResponseMessageAnnotation read FAnnotation write FAnnotation;
    destructor Destroy; override;
  end;

  /// <summary>
  /// response.output_text.done : Emitted when text content is finalized.
  /// </summary>
  TResponseOutputTextDone = class(TResponseOutputTextAnnotationAdded)
  private
    FText: string;
  public
    property Text: string read FText write FText;
  end;

  /// <summary>
  /// response.refusal.delta : Emitted when there is a partial refusal text.
  /// </summary>
  TResponseRefusalDelta = class(TResponseOutputTextDone)
    {--- This class does not introduce any new functionality; all methods and properties
         are inherited from its ancestor. }
  end;

  /// <summary>
  /// response.refusal.done : Emitted when refusal text is finalized.
  /// </summary>
  TResponseRefusalDone = class(TResponseRefusalDelta)
  private
    FRefusal: string;
  public
    property Refusal: string read FRefusal write FRefusal;
  end;

  /// <summary>
  /// response.function_call_arguments.delta : Emitted when there is a partial function-call arguments delta.
  /// </summary>
  TResponseFunctionCallArgumentsDelta = class(TResponseRefusalDone)
    {--- This class does not introduce any new functionality; all methods and properties
         are inherited from its ancestor. }
  end;

  /// <summary>
  /// response.function_call_arguments.done : Emitted when function-call arguments are finalized.
  /// </summary>
  TResponseFunctionCallArgumentsDone = class(TResponseFunctionCallArgumentsDelta)
  private
    FArguments: string;
  public
    property Arguments: string read FArguments write FArguments;
  end;

  /// <summary>
  /// response.file_search_call.in_progress : Emitted when a file search call is initiated.
  /// </summary>
  TResponseFileSearchCallInprogress = class(TResponseFunctionCallArgumentsDone)
    {--- This class does not introduce any new functionality; all methods and properties
         are inherited from its ancestor. }
  end;

  /// <summary>
  /// response.file_search_call.searching : Emitted when a file search is currently searching.
  /// </summary>
  TResponseFileSearchCallSearching = class(TResponseFileSearchCallInprogress)
    {--- This class does not introduce any new functionality; all methods and properties
         are inherited from its ancestor. }
  end;

  /// <summary>
  /// response.file_search_call.completed : Emitted when a file search call is completed (results found).
  /// </summary>
  TResponseFileSearchCallCompleted = class(TResponseFileSearchCallSearching)
    {--- This class does not introduce any new functionality; all methods and properties
         are inherited from its ancestor. }
  end;

  /// <summary>
  /// response.web_search_call.in_progress : Emitted when a web search call is initiated.
  /// </summary>
  TResponseWebSearchCallInprogress = class(TResponseFileSearchCallCompleted)
    {--- This class does not introduce any new functionality; all methods and properties
         are inherited from its ancestor. }
  end;

  /// <summary>
  /// response.web_search_call.searching : Emitted when a web search call is executing.
  /// </summary>
  TResponseWebSearchCallSearching = class(TResponseWebSearchCallInprogress)
    {--- This class does not introduce any new functionality; all methods and properties
         are inherited from its ancestor. }
  end;

  /// <summary>
  /// response.web_search_call.completed : Emitted when a web search call is completed.
  /// </summary>
  TResponseWebSearchCallCompleted = class(TResponseWebSearchCallSearching)
    {--- This class does not introduce any new functionality; all methods and properties
         are inherited from its ancestor. }
  end;

  TResponseReasoningSummaryPartAdded = class(TResponseWebSearchCallCompleted)
  private
    [JsonNameAttribute('summary_index')]
    FSummaryIndex: Int64;
  public
    property SummaryIndex: Int64 read FSummaryIndex write FSummaryIndex;
  end;

  TResponseReasoningSummaryPartDone = class(TResponseReasoningSummaryPartAdded)
    {--- This class does not introduce any new functionality; all methods and properties
         are inherited from its ancestor. }
  end;

  TResponseReasoningSummaryTextDelta = class(TResponseReasoningSummaryPartDone)
    {--- This class does not introduce any new functionality; all methods and properties
         are inherited from its ancestor. }
  end;

  TResponseReasoningSummaryTextDone = class(TResponseReasoningSummaryTextDelta)
    {--- This class does not introduce any new functionality; all methods and properties
         are inherited from its ancestor. }
  end;

  /// <summary>
  /// response.error: Emitted when an error occurs.
  /// </summary>
  TResponseStreamError = class(TResponseReasoningSummaryTextDone)
  private
    FCode: string;
    FMessage: string;
    FParam: string;
  public
    /// <summary>
    /// The error code.
    /// </summary>
    property Code: string read FCode write FCode;
    /// <summary>
    /// The error message.
    /// </summary>
    property Message: string read FMessage write FMessage;
    /// <summary>
    /// The error parameter.
    /// </summary>
    property Param: string read FParam write FParam;
  end;

  {--- This class is made up of the following classes:
     TResponseStreamingCommon, TResponseCreated, TResponseInProgress,
     TResponseCompleted, TResponseFailed, TRresponseIncomplete,
     TResponseOutputItemAdded, TResponseOutputItemDone, TResponseContentpartAdded,
     TResponseContentpartDone, TResponseOutputTextDelta, TResponseOutputTextAnnotationAdded,
     TResponseOutputTextDone, TResponseRefusalDelta, TResponseRefusalDone,
     TResponseFunctionCallArgumentsDelta, TResponseFunctionCallArgumentsDone, TResponseFileSearchCallInprogress,
     TResponseFileSearchCallSearching, TResponseFileSearchCallCompleted, TResponseWebSearchCallInprogress,
     TResponseWebSearchCallSearching, TResponseWebSearchCallCompleted, TResponseReasoningSummaryPartAdded,
     TResponseReasoningSummaryPartDone, TResponseReasoningSummaryTextDelta, TResponseReasoningSummaryTextDone,
     TResponseStreamError }
  TResponseStream = class(TResponseStreamError);

  /// <summary>
  /// Represents the callback procedure type used for processing streaming AI responses.
  /// </summary>
  /// <param name="Response">
  /// A variable of type TResponseStream containing the latest chunk of streamed response data.
  /// </param>
  /// <param name="IsDone">
  /// A Boolean value indicating whether the streaming response has completed.
  /// </param>
  /// <param name="Cancel">
  /// A variable Boolean that can be set to True to cancel further streaming events.
  /// </param>
  /// <remarks>
  /// TResponseEvent is used in streaming methods to deliver incremental response data.
  /// This callback is invoked repeatedly as new data becomes available. When <paramref name="IsDone"/> is True,
  /// the streaming process has finished, and no further updates will be sent. If needed, you can set <paramref name="Cancel"/>
  /// to True in order to stop receiving additional streamed data.
  /// </remarks>
  TResponseEvent = reference to procedure(var Response: TResponseStream; IsDone: Boolean; var Cancel: Boolean);

  /// <summary>
  /// Manages asynchronous responses callBacks for a responses request using <c>TResponse</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynResponse</c> type extends the <c>TAsynParams&lt;TResponse&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynResponse = TAsynCallBack<TResponse>;

  /// <summary>
  /// Manages asynchronous streaming responses callBacks for a responses request using <c>TResponseStream</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynResponseStream</c> type extends the <c>TAsynStreamParams&lt;TResponseStream&gt;</c> record to support the lifecycle of an asynchronous streaming responses operation.
  /// It provides callbacks for different stages, including when the operation starts, progresses with new data chunks, completes successfully, or encounters an error.
  /// This structure is ideal for handling scenarios where the responses response is streamed incrementally, providing real-time updates to the user interface.
  /// </remarks>
  TAsynResponseStream = TAsynStreamCallBack<TResponseStream>;

  /// <summary>
  /// Manages asynchronous callbacks for a response deletion request.
  /// </summary>
  /// <remarks>
  /// This type is a specialized alias for <c>TAsynCallBack&lt;TResponseDelete&gt;</c> and is used to handle asynchronous operations
  /// related to deletion requests. It encapsulates a <c>TResponseDelete</c> instance containing details about the deletion outcome,
  /// including the identifier of the deleted response, the type of object involved, and a boolean flag indicating if the deletion
  /// was successful. This mechanism allows for non-blocking deletion operations and provides a consistent interface for handling
  /// deletion responses in asynchronous workflows.
  /// </remarks>
  TAsynResponseDelete = TAsynCallBack<TResponseDelete>;

  /// <summary>
  /// Provides an asynchronous callback mechanism for handling operations that return a collection of responses.
  /// </summary>
  /// <remarks>
  /// This type is an alias for <c>TAsynCallBack&lt;TResponses&gt;</c>, which facilitates asynchronous workflows by encapsulating
  /// the results of operations that yield a paginated set of response items. The underlying <c>TResponses</c> type represents
  /// a structured collection that includes metadata for pagination (such as first and last identifiers, and a flag indicating
  /// whether more data is available) and an array of <c>TResponseItem</c> instances. Each <c>TResponseItem</c> may contain various
  /// elements such as text content, annotations, file search results, and tool call outputs. This design supports non-blocking
  /// operations and efficient handling of complex response data in an asynchronous context.
  /// </remarks>
  TAsynResponses = TAsynCallBack<TResponses>;

  /// <summary>
  /// Provides methods to create, retrieve, delete, and list AI responses.
  /// </summary>
  /// <remarks>
  /// TResponsesRoute is a subclass of TGenAIRoute and implements both synchronous and asynchronous
  /// operations for interacting with the “responses” endpoint of the API. It also supports
  /// overloads that allow additional parameter configuration.
  /// </remarks>
  TResponsesRoute = class(TGenAIRoute)
    /// <summary>
    /// Asynchronously creates a new AI response.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the request parameters using a TResponsesParams instance.
    /// </param>
    /// <param name="CallBacks">
    /// A callback function that returns a TAsynResponse instance, used to handle start, success, and error events.
    /// </param>
    /// <remarks>
    /// Sends a non-blocking request to create an AI response.
    ///
    /// <code>
    /// Client.Responses.AsynCreate(
    ///   procedure (Params: TResponsesParams)
    ///   begin
    ///     Params.Model('gpt-4.1-mini');
    ///     Params.Input('What is the difference between a mathematician and a physicist?');
    ///   end,
    ///   function : TAsynResponse
    ///   begin
    ///     Result.Sender := Self;
    ///     Result.OnStart := procedure(Sender: TObject)
    ///       begin
    ///         // Initialization code
    ///       end;
    ///     Result.OnSuccess := procedure(Sender: TObject; Value: TResponse)
    ///       begin
    ///         // Process the created response
    ///       end;
    ///     Result.OnError := procedure(Sender: TObject; const ErrorMsg: string)
    ///       begin
    ///         // Handle any errors
    ///       end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsynCreate(ParamProc: TProc<TResponsesParams>; CallBacks: TFunc<TAsynResponse>);
    /// <summary>
    /// Asynchronously creates a streamed AI response.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the request parameters using a TResponsesParams instance.
    /// </param>
    /// <param name="Event">
    /// A callback of type TResponseEvent that is invoked repeatedly as streaming data is received.
    /// </param>
    /// <returns>
    /// True if the streaming response request was successfully initiated.
    /// </returns>
    /// <remarks>
    /// Initiates a streaming request to receive incremental output from the AI.
    ///
    /// <code>
    ///   Client.Responses.AsynCreateStream(
    ///      procedure (Params: TResponsesParams)
    ///      begin
    ///        Params.Model('gpt-4.1-mini');
    ///        Params.Input('What is the difference between a mathematician and a physicist?');
    ///        Params.Stream;
    ///      end,
    ///      function : TAsynResponseStream
    ///      begin
    ///        Result.Sender := Self;
    ///        Result.OnStart := StartCallback;
    ///        Result.OnProgress := ProgressCallback;
    ///        Result.OnError := ErrorCallback;
    ///        Result.OnDoCancel := CancelCallback;
    ///        Result.OnCancellation := CancellationCallback;
    ///      end)
    /// </code>
    /// </remarks>
    procedure AsynCreateStream(ParamProc: TProc<TResponsesParams>; CallBacks: TFunc<TAsynResponseStream>);
    /// <summary>
    /// Asynchronously retrieves an AI response identified by its ID.
    /// </summary>
    /// <param name="ResponseId">
    /// The unique identifier of the response to retrieve.
    /// </param>
    /// <param name="CallBacks">
    /// A callback function that returns a TAsynResponse instance to handle the retrieval process.
    /// </param>
    /// <remarks>
    /// Retrieves the specified response asynchronously.
    ///
    /// <code>
    /// Client.Responses.AsynRetrieve('response_id_here',
    ///   function : TAsynResponse
    ///   begin
    ///     Result.Sender := Self;
    ///     Result.OnStart := StartCallback;
    ///     Result.OnSuccess := SuccessCallback;
    ///     Result.OnError := ErrorCallback;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsynRetrieve(const ResponseId: string; CallBacks: TFunc<TAsynResponse>); overload;
    /// <summary>
    /// Asynchronously retrieves an AI response by its ID with additional URL parameters.
    /// </summary>
    /// <param name="ResponseId">
    /// The unique identifier of the response to retrieve.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure additional URL parameters using a TURLIncludeParams instance.
    /// </param>
    /// <param name="CallBacks">
    /// A callback function that returns a TAsynResponse instance to handle the retrieval process.
    /// </param>
    /// <remarks>
    /// Retrieves the specified response asynchronously with extra URL configuration.
    ///
    /// <code>
    /// Client.Responses.AsynRetrieve('response_id_here',
    ///   procedure(Params: TURLIncludeParams)
    ///   begin
    ///     Params.Include(['file_search_result', 'input_image_url']);
    ///   end,
    ///   function : TAsynResponse
    ///   begin
    ///     Result.Sender := Self;
    ///     Result.OnStart := StartCallback;
    ///     Result.OnSuccess := SuccessCallback;
    ///     Result.OnError := ErrorCallback;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsynRetrieve(const ResponseId: string; const ParamProc: TProc<TURLIncludeParams>; CallBacks: TFunc<TAsynResponse>); overload;
    /// <summary>
    /// Asynchronously deletes an AI response identified by its ID.
    /// </summary>
    /// <param name="ResponseId">
    /// The unique identifier of the response to delete.
    /// </param>
    /// <param name="CallBacks">
    /// A callback function that returns a TAsynResponseDelete instance to handle deletion events.
    /// </param>
    /// <remarks>
    /// Sends a non-blocking deletion request for the specified response.
    ///
    /// <code>
    /// Client.Responses.AsynDelete('response_id_here',
    ///   function : TAsynResponseDelete
    ///   begin
    ///     Result.Sender := Self;
    ///     Result.OnStart := StartCallback;
    ///     Result.OnSuccess := SuccessCallback;
    ///     Result.OnError := ErrorCallback;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsynDelete(const ResponseId: string; CallBacks: TFunc<TAsynResponseDelete>);
    /// <summary>
    /// Asynchronously lists the input items used to generate a specific AI response.
    /// </summary>
    /// <param name="ResponseId">
    /// The unique identifier of the response.
    /// </param>
    /// <param name="CallBacks">
    /// A callback function that returns a TAsynResponses instance to handle the listing process.
    /// </param>
    /// <remarks>
    /// Retrieves the input items associated with the given response asynchronously.
    ///
    /// <code>
    /// Client.Responses.AsynList('response_id_here',
    ///   function : TAsynResponses
    ///   begin
    ///     Result.Sender := Self;
    ///     Result.OnStart := StartCallback;
    ///     Result.OnSuccess := SuccessCallback;
    ///     Result.OnError := ErrorCallback;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsynList(const ResponseId: string; CallBacks: TFunc<TAsynResponses>); overload;
    /// <summary>
    /// Asynchronously lists the input items used to generate a specific AI response with additional URL parameters.
    /// </summary>
    /// <param name="ResponseId">
    /// The unique identifier of the response.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure additional URL parameters using a TUrlResponseListParams instance.
    /// </param>
    /// <param name="CallBacks">
    /// A callback function that returns a TAsynResponses instance to handle the listing process.
    /// </param>
    /// <remarks>
    /// Retrieves the list of input items asynchronously with extra configuration.
    ///
    /// <code>
    /// Client.Responses.AsynList('response_id_here',
    ///   procedure (Params: TUrlResponseListParams)
    ///   begin
    ///     Params.Limit(15);
    ///   end,
    ///   function : TAsynResponses
    ///   begin
    ///     Result.Sender := Self;
    ///     Result.OnStart := StartCallback;
    ///     Result.OnSuccess := SuccessCallback;
    ///     Result.OnError := ErrorCallback;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsynList(const ResponseId: string; const ParamProc: TProc<TUrlResponseListParams>; CallBacks: TFunc<TAsynResponses>); overload;
    /// <summary>
    /// Synchronously creates a new AI response.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the request parameters using a TResponsesParams instance.
    /// </param>
    /// <returns>
    /// A TResponse object representing the newly created AI response.
    /// </returns>
    /// <remarks>
    /// Sends a blocking request to create an AI response and returns the result.
    ///
    /// <code>
    /// var
    ///   Response: TResponse;
    /// begin
    ///   Response := Client.Responses.Create(
    ///     procedure (Params: TResponsesParams)
    ///     begin
    ///       Params.Model('gpt-4.1-mini');
    ///       Params.Input('What is the difference between a mathematician and a physicist?');
    ///     end);
    ///   try
    ///     // Process the response
    ///   finally
    ///     Response.Free;
    ///   end;
    /// end;
    /// </code>
    /// </remarks>
    function Create(ParamProc: TProc<TResponsesParams>): TResponse;
    /// <summary>
    /// Synchronously creates a streaming AI response.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the streaming response parameters via a TResponsesParams instance.
    /// </param>
    /// <param name="Event">
    /// A callback (of type TResponseEvent) that is invoked as streaming data is received and when the stream completes.
    /// </param>
    /// <returns>
    /// True if the streaming response request was successfully initiated; otherwise, False.
    /// </returns>
    /// <remarks>
    /// This method sends a request to begin a streaming AI response and blocks until the initial response is accepted.
    /// Use it when you require immediate confirmation that the stream has been started. Stream data is handled via the specified callback.
    ///
    /// <code>
    /// var
    ///   StreamStarted: Boolean;
    /// begin
    ///   StreamStarted := Client.Responses.CreateStream(
    ///     procedure (Params: TResponsesParams)
    ///     begin
    ///       Params.Model('gpt-4.1-mini');
    ///       Params.Input('What is the difference between a mathematician and a physicist?');
    ///       Params.Stream;
    ///     end,
    ///     procedure (var Chat: TResponseStream; IsDone: Boolean; var Cancel: Boolean)
    ///     begin
    ///       if not IsDone then
    ///         // Process the intermediate streaming data
    ///       else
    ///         // Handle the completion of the stream
    ///     end);
    /// end;
    /// </code>
    /// </remarks>
    function CreateStream(ParamProc: TProc<TResponsesParams>; Event: TResponseEvent): Boolean;
    /// <summary>
    /// Synchronously retrieves an AI response by its ID.
    /// </summary>
    /// <param name="ResponseId">
    /// The unique identifier of the response to retrieve.
    /// </param>
    /// <returns>
    /// A TResponse object with the details of the requested AI response.
    /// </returns>
    /// <remarks>
    /// Fetches the specified response in a blocking manner.
    ///
    /// <code>
    /// var
    ///   Response: TResponse;
    /// begin
    ///   Response := Client.Responses.Retrieve('response_id_here');
    ///   try
    ///     // Work with the response data
    ///   finally
    ///     Response.Free;
    ///   end;
    /// end;
    /// </code>
    /// </remarks>
    function Retrieve(const ResponseId: string): TResponse; overload;
    /// <summary>
    /// Synchronously retrieves an AI response by its ID with additional URL parameters.
    /// </summary>
    /// <param name="ResponseId">
    /// The unique identifier of the response to retrieve.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure additional URL parameters using a TURLIncludeParams instance.
    /// </param>
    /// <returns>
    /// A TResponse object with the details of the requested AI response.
    /// </returns>
    /// <remarks>
    /// Retrieves the specified response with extra configuration in a blocking manner.
    ///
    /// <code>
    /// var
    ///   Response: TResponse;
    /// begin
    ///   Response := Client.Responses.Retrieve('response_id_here',
    ///     procedure (Params: TURLIncludeParams)
    ///     begin
    ///       Params.Include(['file_search_result', 'input_image_url']);
    ///     end);
    ///   try
    ///     // Process the response
    ///   finally
    ///     Response.Free;
    ///   end;
    /// end;
    /// </code>
    /// </remarks>
    function Retrieve(const ResponseId: string; const ParamProc: TProc<TURLIncludeParams>): TResponse; overload;
    /// <summary>
    /// Synchronously deletes an AI response by its ID.
    /// </summary>
    /// <param name="ResponseId">
    /// The unique identifier of the response to delete.
    /// </param>
    /// <returns>
    /// A TResponseDelete object indicating the result of the deletion.
    /// </returns>
    /// <remarks>
    /// Sends a blocking deletion request for the specified response.
    ///
    /// <code>
    /// var
    ///   DeleteResult: TResponseDelete;
    /// begin
    ///   DeleteResult := Client.Responses.Delete('response_id_here');
    ///   try
    ///     // Verify deletion status
    ///   finally
    ///     DeleteResult.Free;
    ///   end;
    /// end;
    /// </code>
    /// </remarks>
    function Delete(const ResponseId: string): TResponseDelete;
    /// <summary>
    /// Synchronously lists input items used to generate a specific AI response.
    /// </summary>
    /// <param name="ResponseId">
    /// The unique identifier of the AI response.
    /// </param>
    /// <returns>
    /// A TResponses object containing the list of input items.
    /// </returns>
    /// <remarks>
    /// Retrieves the list of input items in a blocking manner.
    ///
    /// <code>
    /// var
    ///   Responses: TResponses;
    /// begin
    ///   Responses := Client.Responses.List('response_id_here');
    ///   try
    ///     // Process the list of input items
    ///   finally
    ///     Responses.Free;
    ///   end;
    /// end;
    /// </code>
    /// </remarks>
    function List(const ResponseId: string): TResponses; overload;
    /// <summary>
    /// Synchronously lists input items used to generate a specific AI response with additional URL parameters.
    /// </summary>
    /// <param name="ResponseId">
    /// The unique identifier of the AI response.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure additional URL parameters using a TUrlResponseListParams instance.
    /// </param>
    /// <returns>
    /// A TResponses object containing the list of input items.
    /// </returns>
    /// <remarks>
    /// Retrieves the list of input items with extra configuration in a blocking manner.
    ///
    /// <code>
    /// var
    ///   Responses: TResponses;
    /// begin
    ///   Responses := Client.Responses.List('response_id_here',
    ///     procedure (Params: TUrlResponseListParams)
    ///     begin
    ///       Params.Limit(50);
    ///     end);
    ///   try
    ///     // Process the list of input items
    ///   finally
    ///     Responses.Free;
    ///   end;
    /// end;
    /// </code>
    /// </remarks>
    function List(const ResponseId: string; const ParamProc: TProc<TUrlResponseListParams>): TResponses; overload;
    /// <summary>
    /// Initiates parallel processing of "responses" prompts by creating multiple "responses"
    /// asynchronously, with results stored in a bundle and provided back to the callback function.
    /// This method allows for parallel processing of multiple prompts in an efficient manner,
    /// handling errors and successes for each chat completion.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure delegate that configures the parameters for the bundle. It is responsible
    /// for providing the necessary settings (such as model and reasoning effort) for the chat completions.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns an instance of TAsynBuffer, which manages the lifecycle of the
    /// asynchronous operation. The callbacks include handlers for start, error, and success events.
    /// </param>
    /// <remarks>
    /// The method allows for efficient parallel processing of multiple prompts by delegating
    /// individual tasks to separate threads. It handles the reasoning effort for specific models
    /// and ensures each task's result is properly bundled and communicated back to the caller.
    /// If an error occurs, the error handling callback will be triggered, and the rest of the tasks
    /// will continue processing. The success callback is triggered once all tasks are completed.
    /// </remarks>
    procedure CreateParallel(ParamProc: TProc<TBundleParams>; const CallBacks: TFunc<TAsynBundleList>);
  end;

implementation

uses
  System.StrUtils, GenAI.NetEncoding.Base64, GenAI.Responses.Helpers;

{ TResponsesParams }

function TResponsesParams.Include(
  const Value: TArray<TOutputIncluding>): TResponsesParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.ToString);
  Result := TResponsesParams(Add('include', JSONArray));
end;

function TResponsesParams.Include(
  const Value: TArray<string>): TResponsesParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(TOutputIncluding.Create(Item).ToString);
  Result := TResponsesParams(Add('include', JSONArray));
end;

function TResponsesParams.Input(const Content: string;
  const Docs: TArray<string>; const Role: string): TResponsesParams;
var
  MimeType: string;
begin
  {--- Create an array with content (text and image documents }
  var JSONArray := TJSONArray.Create;
  JSONArray.Add(TItemContent.NewText.Text(Content).Detach);
  for var Item in Docs do
    begin
      MimeType := TFormatHelper.GetMimeType(Item);
      if TFormatHelper.IsPDFDocument(MimeType) then
        JSONArray.Add(TItemContent.NewFileData(Item).Detach)
      else
      if TFormatHelper.IsImageDocument(MimeType) then
        JSONArray.Add(TItemContent.NewImage(Item).Detach)
      else
      if MimeType = TFormatHelper.S_FILEID then
        JSONArray.Add(TItemContent.NewFile.FileId(Item).Detach)
      else
        raise Exception.CreateFmt('%s : Mime type not supported', [MimeType]);
    end;

  {--- Create the input message }
  var InputMessage := TJSONArray.Create.Add(TInputMessage.Create.Role(Role).Content(JSONArray).Detach);

  Result := TResponsesParams(Add('input', InputMessage));
end;

function TResponsesParams.Input(const Value: TJSONArray): TResponsesParams;
begin
  Result := TResponsesParams(Add('input', Value));
end;

function TResponsesParams.Input(const Value: TArray<TInputListItem>): TResponsesParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TResponsesParams(Add('input', JSONArray));
end;

function TResponsesParams.Input(const Value: string): TResponsesParams;
begin
  Result := TResponsesParams(Add('input', Value));
end;

function TResponsesParams.Instructions(const Value: string): TResponsesParams;
begin
  Result := TResponsesParams(Add('instructions', Value));
end;

function TResponsesParams.MaxOutputTokens(
  const Value: Integer): TResponsesParams;
begin
  Result := TResponsesParams(Add('max_output_tokens', Value));
end;

function TResponsesParams.Metadata(const Value: TJSONObject): TResponsesParams;
begin
  Result := TResponsesParams(Add('metadata', Value));
end;

function TResponsesParams.Model(const Value: string): TResponsesParams;
begin
  Result := TResponsesParams(Add('model', Value));
end;

function TResponsesParams.ParallelToolCalls(
  const Value: Boolean): TResponsesParams;
begin
  Result := TResponsesParams(Add('parallel_tool_calls', Value));
end;

function TResponsesParams.PreviousResponseId(
  const Value: string): TResponsesParams;
begin
  Result := TResponsesParams(Add('previous_response_id', Value));
end;

function TResponsesParams.Reasoning(const Value: TReasoningParams): TResponsesParams;
begin
  Result := TResponsesParams(Add('reasoning', Value.Detach));
end;

function TResponsesParams.Reasoning(const Value: string): TResponsesParams;
begin
  Result := TResponsesParams(Add('reasoning', TReasoningParams.New.Effort(Value).Detach));
end;

function TResponsesParams.Store(const Value: Boolean): TResponsesParams;
begin
  Result := TResponsesParams(Add('store', Value));
end;

function TResponsesParams.Stream(const Value: Boolean): TResponsesParams;
begin
  Result := TResponsesParams(Add('stream', Value));
end;

function TResponsesParams.Temperature(const Value: Double): TResponsesParams;
begin
  Result := TResponsesParams(Add('temperature', Value));
end;

function TResponsesParams.Text(const Value: TResponseOption;
  const SchemaParams: TTextJSONSchemaParams): TResponsesParams;
begin
  Result := Text(Value.ToString, SchemaParams);
end;

function TResponsesParams.ToolChoice(const Value: string): TResponsesParams;
begin
  Result := TResponsesParams(Add('tool_choice', TToolChoice.Create(Value).ToString));
end;

function TResponsesParams.ToolChoice(
  const Value: TToolChoice): TResponsesParams;
begin
  Result := TResponsesParams(Add('tool_choice', Value.ToString));
end;

function TResponsesParams.ToolChoice(
  const Value: TResponseToolChoiceParams): TResponsesParams;
begin
  Result := TResponsesParams(Add('tool_choice', Value.Detach));
end;

function TResponsesParams.Tools(
  const Value: TArray<TResponseToolParams>): TResponsesParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TResponsesParams(Add('tools', JSONArray));
end;

function TResponsesParams.TopP(const Value: Double): TResponsesParams;
begin
  Result := TResponsesParams(Add('top_p', Value));
end;

function TResponsesParams.Truncation(const Value: string): TResponsesParams;
begin
  Result := TResponsesParams(Add('truncation', TResponseTruncationType.Create(Value).ToString));
end;

function TResponsesParams.User(const Value: string): TResponsesParams;
begin
  Result := TResponsesParams(Add('user', Value));
end;

function TResponsesParams.Truncation(
  const Value: TResponseTruncationType): TResponsesParams;
begin
  Result := TResponsesParams(Add('truncation', Value.ToString));
end;

function TResponsesParams.Text(const Value: string;
  const SchemaParams: TTextJSONSchemaParams): TResponsesParams;
begin
  case TResponseOption.Create(Value) of
    TResponseOption.text:
      begin
        Result := Text(TTextFormatTextPrams.New);
        if Assigned(SchemaParams) then
          SchemaParams.Free;
      end;
    TResponseOption.json_object:
      begin
        Result := Text(TTextJSONObjectParams.New);
        if Assigned(SchemaParams) then
          SchemaParams.Free;
      end
    else
      begin
        if not Assigned(SchemaParams) then
          raise Exception.Create('Text options: Schema not defined.');
        Result := Text(SchemaParams);
      end;
  end;
end;

function TResponsesParams.Text(
  const Value: TTextFormatParams): TResponsesParams;
begin
  if Assigned(Value) then
    Result := Text(TTextParams.Create.Format(Value)) else
    Result := Self;
end;

function TResponsesParams.Text(const Value: TTextParams): TResponsesParams;
begin
  Result := TResponsesParams(Add('text', Value.Detach));
end;

{ TReasoningParams }

function TReasoningParams.Effort(const Value: TReasoningEffort): TReasoningParams;
begin
  Result := TReasoningParams(Add('effort', Value.ToString));
end;

function TReasoningParams.Effort(const Value: string): TReasoningParams;
begin
  Result := TReasoningParams(Add('effort', TReasoningEffort.Create(Value).ToString));
end;

function TReasoningParams.Summary(const Value: string): TReasoningParams;
begin
  Result := TReasoningParams(Add('summary', TReasoningGenerateSummary.Create(Value).ToString));
end;

class function TReasoningParams.New: TReasoningParams;
begin
  Result := TReasoningParams.Create;
end;

function TReasoningParams.Summary(
  const Value: TReasoningGenerateSummary): TReasoningParams;
begin
  Result := TReasoningParams(Add('summary', Value.ToString));
end;

{ TTextParams }

function TTextParams.Format(const Value: TTextFormatParams): TTextParams;
begin
  Result := TTextParams(Add('format', Value.Detach));
end;

{ TTextFormatTextPrams }

class function TTextFormatTextPrams.New: TTextFormatTextPrams;
begin
  Result := TTextFormatTextPrams.Create.&Type();
end;

function TTextFormatTextPrams.&Type(const Value: string): TTextFormatTextPrams;
begin
  Result := TTextFormatTextPrams(Add('type', Value));
end;

{ TTextJSONSchemaParams }

function TTextJSONSchemaParams.&Type(
  const Value: string): TTextJSONSchemaParams;
begin
  Result := TTextJSONSchemaParams(Add('type', Value));
end;

function TTextJSONSchemaParams.Description(
  const Value: string): TTextJSONSchemaParams;
begin
  Result := TTextJSONSchemaParams(Add('description', Value));
end;

function TTextJSONSchemaParams.Name(const Value: string): TTextJSONSchemaParams;
begin
  Result := TTextJSONSchemaParams(Add('name', Value));
end;

class function TTextJSONSchemaParams.New: TTextJSONSchemaParams;
begin
  Result := TTextJSONSchemaParams.Create.&Type();
end;

function TTextJSONSchemaParams.Schema(
  const Value: TSchemaParams): TTextJSONSchemaParams;
begin
  Result := TTextJSONSchemaParams(Add('schema', Value.Detach));
end;

function TTextJSONSchemaParams.Schema(
  const Value: string): TTextJSONSchemaParams;
begin
  var JSON := TJSONObject.ParseJSONValue(Value.ToLower.Replace(sLineBreak, '').Replace(#10, '').Replace(#13, '')) as TJSONObject;
  Result := TTextJSONSchemaParams(Add('schema', JSON));
end;

function TTextJSONSchemaParams.Strict(
  const Value: Boolean): TTextJSONSchemaParams;
begin
  Result := TTextJSONSchemaParams(Add('strict', Value));
end;

{ TTextJSONObjectParams }

class function TTextJSONObjectParams.New: TTextJSONObjectParams;
begin
  Result := TTextJSONObjectParams.Create.&Type();
end;

function TTextJSONObjectParams.&Type(
  const Value: string): TTextJSONObjectParams;
begin
  Result := TTextJSONObjectParams(Add('type', Value));
end;

{ THostedToolParams }

function THostedToolParams.&Type(
  const Value: THostedTooltype): THostedToolParams;
begin
  Result := THostedToolParams(Add('type', Value.ToString));
end;

class function THostedToolParams.New(const Value: string): THostedToolParams;
begin
  Result := THostedToolParams.Create.&Type(Value);
end;

function THostedToolParams.&Type(const Value: string): THostedToolParams;
begin
  Result := THostedToolParams(Add('type', THostedTooltype.Create(Value).ToString));
end;

{ TFunctionToolParams }

function TFunctionToolParams.Name(const Value: string): TFunctionToolParams;
begin
  Result := TFunctionToolParams(Add('name', Value));
end;

class function TFunctionToolParams.New: TFunctionToolParams;
begin
  Result := TFunctionToolParams.Create.&Type();
end;

function TFunctionToolParams.&Type(const Value: string): TFunctionToolParams;
begin
  Result := TFunctionToolParams(Add('type', Value));
end;

{ TResponseFileSearchParams }

function TResponseFileSearchParams.Filters(
  const Value: TFileSearchFilters): TResponseFileSearchParams;
begin
  Result := TResponseFileSearchParams(Add('filters', Value.Detach));
end;

function TResponseFileSearchParams.MaxNumResults(
  const Value: Integer): TResponseFileSearchParams;
begin
  Result := TResponseFileSearchParams(Add('max_num_results', Value));
end;

class function TResponseFileSearchParams.New: TResponseFileSearchParams;
begin
  Result := TResponseFileSearchParams.Create.&Type();
end;

function TResponseFileSearchParams.RankingOptions(
  const Value: TRankingOptionsParams): TResponseFileSearchParams;
begin
  Result := TResponseFileSearchParams(Add('ranking_options', Value.Detach));
end;

function TResponseFileSearchParams.&Type(
  const Value: string): TResponseFileSearchParams;
begin
  Result := TResponseFileSearchParams(Add('type', Value));
end;

function TResponseFileSearchParams.VectorStoreIds(
  const Value: TArray<string>): TResponseFileSearchParams;
begin
  Result := TResponseFileSearchParams(Add('vector_store_ids', Value));
end;

{ TComparisonFilter }

function TComparisonFilter.&Type(
  const Value: TComparisonFilterType): TComparisonFilter;
begin
  Result := TComparisonFilter(Add('type', Value.ToString));
end;

class function TComparisonFilter.New: TComparisonFilter;
begin
  Result := TComparisonFilter.Create;
end;

function TComparisonFilter.&Type(const Value: string): TComparisonFilter;
begin
  Result := TComparisonFilter(Add('type', TComparisonFilterType.Create(Value).ToString));
end;

function TComparisonFilter.Comparison(const Value: string): TComparisonFilter;
begin
  Result := TComparisonFilter(Add('type', TComparisonFilterType.ToOperator(Value).ToString));
end;

function TComparisonFilter.Key(const Value: string): TComparisonFilter;
begin
  Result := TComparisonFilter(Add('key', Value));
end;

class function TComparisonFilter.New(const Key, Comparison: string;
  const Value: Double): TComparisonFilter;
begin
  Result := New.Key(Key).Comparison(Comparison).Value(Value);
end;

class function TComparisonFilter.New(const Key, Comparison: string;
  const Value: Integer): TComparisonFilter;
begin
  Result := New.Key(Key).Comparison(Comparison).Value(Value);
end;

class function TComparisonFilter.New(const Key, Comparison,
  Value: string): TComparisonFilter;
begin
  Result := New.Key(Key).Comparison(Comparison).Value(Value);
end;

class function TComparisonFilter.New(const Key, Comparison: string;
  const Value: Boolean): TComparisonFilter;
begin
  Result := New.Key(Key).Comparison(Comparison).Value(Value);
end;

function TComparisonFilter.Value(const Value: string): TComparisonFilter;
begin
  Result := TComparisonFilter(Add('value', Value));
end;

function TComparisonFilter.Value(const Value: Integer): TComparisonFilter;
begin
  Result := TComparisonFilter(Add('value', Value));
end;

function TComparisonFilter.Value(const Value: Double): TComparisonFilter;
begin
  Result := TComparisonFilter(Add('value', Value));
end;

function TComparisonFilter.Value(const Value: Boolean): TComparisonFilter;
begin
  Result := TComparisonFilter(Add('value', Value));
end;

{ TCompoundFilter }

function TCompoundFilter.&And: TCompoundFilter;
begin
  Result := &Type(TCompoundFilterType.and);
end;

class function TCompoundFilter.&And(
  const Value: TArray<TFileSearchFilters>): TCompoundFilter;
begin
  Result := TCompoundFilter.New.&And.Filters(Value);
end;

function TCompoundFilter.Filters(
  const Value: TArray<TFileSearchFilters>): TCompoundFilter;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TCompoundFilter(Add('filters', JSONArray));
end;

class function TCompoundFilter.New: TCompoundFilter;
begin
  Result := TCompoundFilter.Create;
end;

function TCompoundFilter.&Or: TCompoundFilter;
begin
  Result := &Type(TCompoundFilterType.or);
end;

class function TCompoundFilter.&Or(
  const Value: TArray<TFileSearchFilters>): TCompoundFilter;
begin
  Result := TCompoundFilter.New.&Or.Filters(Value);
end;

function TCompoundFilter.&Type(
  const Value: TCompoundFilterType): TCompoundFilter;
begin
  Result := TCompoundFilter(Add('type', Value.ToString));
end;

{ TResponseFunctionParams }

function TResponseFunctionParams.&Type(
  const Value: string): TResponseFunctionParams;
begin
  Result := TResponseFunctionParams(Add('type', Value));
end;

function TResponseFunctionParams.Description(
  const Value: string): TResponseFunctionParams;
begin
  Result := TResponseFunctionParams(Add('description', Value));
end;

function TResponseFunctionParams.Name(
  const Value: string): TResponseFunctionParams;
begin
  Result := TResponseFunctionParams(Add('name', Value));
end;

class function TResponseFunctionParams.New(
  const Value: IFunctionCore): TResponseFunctionParams;
begin
  Result := New.Description(Value.Description).Name(Value.Name).Parameters(Value.Parameters).Strict(Value.&Strict);
end;

class function TResponseFunctionParams.New: TResponseFunctionParams;
begin
  Result := TResponseFunctionParams.Create.&Type();
end;

function TResponseFunctionParams.Parameters(
  const Value: string): TResponseFunctionParams;
begin
  var JSON := TJSONObject.ParseJSONValue(Value.ToLower.Replace(sLineBreak, '').Replace(#10, '').Replace(#13, '')) as TJSONObject;
  Result := TResponseFunctionParams(Add('parameters', JSON));
end;

function TResponseFunctionParams.Parameters(
  const Value: TSchemaParams): TResponseFunctionParams;
begin
  Result := TResponseFunctionParams(Add('parameters', Value.Detach));
end;

function TResponseFunctionParams.Strict(
  const Value: Boolean): TResponseFunctionParams;
begin
  Result := TResponseFunctionParams(Add('strict', Value));
end;

{ TResponseComputerUseParams }

function TResponseComputerUseParams.&Type(
  const Value: string): TResponseComputerUseParams;
begin
  Result := TResponseComputerUseParams(Add('type', Value));
end;

function TResponseComputerUseParams.DisplayHeight(
  const Value: Integer): TResponseComputerUseParams;
begin
  Result := TResponseComputerUseParams(Add('display_height', Value));
end;

function TResponseComputerUseParams.DisplayWidth(
  const Value: Integer): TResponseComputerUseParams;
begin
  Result := TResponseComputerUseParams(Add('display_width', Value));
end;

function TResponseComputerUseParams.Environment(
  const Value: string): TResponseComputerUseParams;
begin
  Result := TResponseComputerUseParams(Add('environment', Value));
end;

class function TResponseComputerUseParams.New: TResponseComputerUseParams;
begin
  Result := TResponseComputerUseParams.Create.&Type();
end;

{ TResponseWebSearchParams }

function TResponseWebSearchParams.&Type(
  const Value: TWebSearchType): TResponseWebSearchParams;
begin
  Result := TResponseWebSearchParams(Add('type', Value.ToString));
end;

function TResponseWebSearchParams.&Type(
  const Value: string): TResponseWebSearchParams;
begin
  Result := TResponseWebSearchParams(Add('type', TWebSearchType.Create(Value).ToString));
end;


function TResponseWebSearchParams.UserLocation(
  const Value: TResponseUserLocationParams): TResponseWebSearchParams;
begin
  Result := TResponseWebSearchParams(Add('user_location', Value.Detach));
end;

function TResponseWebSearchParams.SearchContextSize(
  const Value: TSearchWebOptions): TResponseWebSearchParams;
begin
  Result := TResponseWebSearchParams(Add('search_context_size', Value.ToString));
end;

class function TResponseWebSearchParams.New: TResponseWebSearchParams;
begin
  Result := TResponseWebSearchParams.Create.&Type();
end;

function TResponseWebSearchParams.SearchContextSize(
  const Value: string): TResponseWebSearchParams;
begin
  Result := TResponseWebSearchParams(Add('search_context_size', TSearchWebOptions.Create(Value).ToString));
end;

{ TResponseUserLocationParams }

function TResponseUserLocationParams.City(
  const Value: string): TResponseUserLocationParams;
begin
  Result := TResponseUserLocationParams(Add('city', Value));
end;

function TResponseUserLocationParams.Country(
  const Value: string): TResponseUserLocationParams;
begin
  Result := TResponseUserLocationParams(Add('country', Value));
end;

class function TResponseUserLocationParams.New: TResponseUserLocationParams;
begin
  Result := TResponseUserLocationParams.Create.&Type();
end;

function TResponseUserLocationParams.Region(
  const Value: string): TResponseUserLocationParams;
begin
  Result := TResponseUserLocationParams(Add('region', Value));
end;

function TResponseUserLocationParams.Timezone(
  const Value: string): TResponseUserLocationParams;
begin
  Result := TResponseUserLocationParams(Add('timezone', Value));
end;

function TResponseUserLocationParams.&Type(
  const Value: string): TResponseUserLocationParams;
begin
  Result := TResponseUserLocationParams(Add('type', Value));
end;

{ TResponse }

destructor TResponse.Destroy;
begin
  if Assigned(FError) then
    FError.Free;
  if Assigned(FIncompleteDetails) then
    FIncompleteDetails.Free;
  for var Item in FOutput do
    Item.Free;
  if Assigned(FReasoning) then
    FReasoning.Free;
  if Assigned(FText) then
    FText.Free;
  for var Item in FTools do
    Item.Free;
  if Assigned(FUsage) then
    FUsage.Free;
  inherited;
end;

function TResponse.GetCreatedAtAsString: string;
begin
  Result := TInt64OrNull(FCreatedAt).ToUtcDateString;
end;

{ TResponseOutputMessage }

destructor TResponseOutputMessage.Destroy;
begin
  for var Item in FContent do
    Item.Free;
  inherited;
end;

{ TResponseMessageContent }

destructor TResponseMessageContent.Destroy;
begin
  for var Item in FAnnotations do
    Item.Free;
  inherited;
end;

{ TResponseOutputFileSearch }

destructor TResponseOutputFileSearch.Destroy;
begin
  for var Item in FResults do
    Item.Free;
  inherited;
end;

{ TResponseOutputComputer }

destructor TResponseOutputComputer.Destroy;
begin
  if Assigned(FAction) then
    FAction.Free;
  for var Item in FPendingSafetyChecks do
    Item.Free;
  inherited;
end;

{ TResponseOutputReasoning }

destructor TResponseOutputReasoning.Destroy;
begin
  for var Item in FSummary do
    Item.Free;
  inherited;
end;

{ TResponseText }

destructor TResponseText.Destroy;
begin
  if Assigned(FFormat) then
    FFormat.Free;
  inherited;
end;

{ TResponseToolFileSearch }

destructor TResponseToolFileSearch.Destroy;
begin
  if Assigned(FFilters) then
    FFilters.Free;
  if Assigned(FRankingOptions) then
    FRankingOptions.Free;
  inherited;
end;

{ ResponseFileSearchFiltersCompound }

destructor TResponseFileSearchFiltersCompound.Destroy;
begin
  for var Item in FFilters do
    Item.Free;
  inherited;
end;

{ TResponseToolWebSearch }

destructor TResponseToolWebSearch.Destroy;
begin
  if Assigned(FUserLocation) then
    FUserLocation.Free;
  inherited;
end;

{ TResponseUsage }

destructor TResponseUsage.Destroy;
begin
  if Assigned(FInputTokensDetails) then
    FInputTokensDetails.Free;
  if Assigned(FOutputTokensDetails) then
    FOutputTokensDetails.Free;
  inherited;
end;

{ TResponsesRoute }

procedure TResponsesRoute.AsynCreate(ParamProc: TProc<TResponsesParams>;
  CallBacks: TFunc<TAsynResponse>);
begin
  with TAsynCallBackExec<TAsynResponse, TResponse>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TResponse
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TResponsesRoute.AsynCreateStream(ParamProc: TProc<TResponsesParams>;
  CallBacks: TFunc<TAsynResponseStream>);
begin
  var CallBackParams := TUseParamsFactory<TAsynResponseStream>.CreateInstance(CallBacks);

  var Sender := CallBackParams.Param.Sender;
  var OnStart := CallBackParams.Param.OnStart;
  var OnSuccess := CallBackParams.Param.OnSuccess;
  var OnProgress := CallBackParams.Param.OnProgress;
  var OnError := CallBackParams.Param.OnError;
  var OnCancellation := CallBackParams.Param.OnCancellation;
  var OnDoCancel := CallBackParams.Param.OnDoCancel;
  var CancelTag := 0;

  var Task: ITask := TTask.Create(
          procedure()
          begin
            {--- Pass the instance of the current class in case no value was specified. }
            if not Assigned(Sender) then
              Sender := Self;

            {--- Trigger OnStart callback }
            if Assigned(OnStart) then
              TThread.Queue(nil,
                procedure
                begin
                  OnStart(Sender);
                end);
            try
              var Stop := False;

              {--- Processing }
              CreateStream(ParamProc,
                procedure (var Response: TResponseStream; IsDone: Boolean; var Cancel: Boolean)
                begin
                  {--- Check that the process has not been canceled }
                  if Assigned(OnDoCancel) and (CancelTag = 0) then
                    TThread.Queue(nil,
                        procedure
                        begin
                          Stop := OnDoCancel();
                          if Stop then
                            Inc(CancelTag);
                        end);
                  if Stop then
                    begin
                      {--- Trigger when processus was stopped }
                      if (CancelTag = 1) and Assigned(OnCancellation) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnCancellation(Sender);
                        end);
                      Inc(CancelTag);
                      Cancel := True;
                      Exit;
                    end;
                  if not IsDone and Assigned(Response) then
                    begin
                      var LocalResponse := Response;
                      Response := nil;

                      {--- Triggered when processus is progressing }
                      if Assigned(OnProgress) then
                        TThread.Synchronize(TThread.Current,
                        procedure
                        begin
                          try
                            OnProgress(Sender, LocalResponse);
                          finally
                            {--- Makes sure to release the instance containing the data obtained
                                 following processing}
                            LocalResponse.Free;
                          end;
                        end)
                     else
                       LocalResponse.Free;
                    end
                  else
                  if IsDone then
                    begin
                      {--- Trigger OnEnd callback when the process is done }
                      if Assigned(OnSuccess) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnSuccess(Sender);
                        end);
                    end;
                end);
            except
              on E: Exception do
                begin
                  var Error := AcquireExceptionObject;
                  try
                    var ErrorMsg := (Error as Exception).Message;

                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(OnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        OnError(Sender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
          end);
  Task.Start;
end;

procedure TResponsesRoute.AsynDelete(const ResponseId: string;
  CallBacks: TFunc<TAsynResponseDelete>);
begin
  with TAsynCallBackExec<TAsynResponseDelete, TResponseDelete>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TResponseDelete
      begin
        Result := Self.Delete(ResponseId);
      end);
  finally
    Free;
  end;
end;

procedure TResponsesRoute.AsynList(const ResponseId: string;
  const ParamProc: TProc<TUrlResponseListParams>;
  CallBacks: TFunc<TAsynResponses>);
begin
  with TAsynCallBackExec<TAsynResponses, TResponses>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TResponses
      begin
        Result := Self.List(ResponseId, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TResponsesRoute.AsynList(const ResponseId: string;
  CallBacks: TFunc<TAsynResponses>);
begin
  with TAsynCallBackExec<TAsynResponses, TResponses>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TResponses
      begin
        Result := Self.List(ResponseId);
      end);
  finally
    Free;
  end;
end;

procedure TResponsesRoute.AsynRetrieve(const ResponseId: string;
  const ParamProc: TProc<TURLIncludeParams>; CallBacks: TFunc<TAsynResponse>);
begin
  with TAsynCallBackExec<TAsynResponse, TResponse>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TResponse
      begin
        Result := Self.Retrieve(ResponseId, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TResponsesRoute.AsynRetrieve(const ResponseId: string;
  CallBacks: TFunc<TAsynResponse>);
begin
  with TAsynCallBackExec<TAsynResponse, TResponse>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TResponse
      begin
        Result := Self.Retrieve(ResponseId);
      end);
  finally
    Free;
  end;
end;

function TResponsesRoute.Create(ParamProc: TProc<TResponsesParams>): TResponse;
begin
  Result := API.Post<TResponse, TResponsesParams>('responses', ParamProc);
end;

procedure TResponsesRoute.CreateParallel(ParamProc: TProc<TBundleParams>;
  const CallBacks: TFunc<TAsynBundleList>);
var
  Tasks: TArray<ITask>;
  BundleParams: TBundleParams;
  ReasoningEffort: string;
begin
  BundleParams := TBundleParams.Create;
  try
    if not Assigned(ParamProc) then
      raise Exception.Create('The lambda can''t be null');

    ParamProc(BundleParams);
    var Bundle := TBundleList.Create;
    var Ranking := 0;
    var ErrorExists := False;
    var Prompts := BundleParams.GetPrompt;
    var Counter := Length(Prompts);

    {--- Set the reasoning effort if necessary }
    if IsReasoningModel(BundleParams.GetModel) then
      ReasoningEffort := BundleParams.GetReasoningEffort
    else
      ReasoningEffort := EmptyStr;

    if Assigned(CallBacks.OnStart) then
      CallBacks.OnStart(CallBacks.Sender);

    SetLength(Tasks, Length(Prompts));
    for var index := 0 to Pred(Length(Prompts)) do
      begin
        Tasks[index] := TTask.Run(
          procedure
          begin
            var Buffer := Bundle.Add(index + 1);
            Buffer.Prompt := Prompts[index];
            try
              var Response := Create(
                procedure (Params: TResponsesParams)
                begin
                  {--- Set the model for the process }
                  Params.Model(BundleParams.GetModel);

                  {--- If reasoning model then set de reasoning parameters }
                  if not ReasoningEffort.IsEmpty then
                    Params.Reasoning(TReasoningParams.New.Effort(ReasoningEffort));

                  {--- Set the developer instructions }
                  Params.Instructions(BundleParams.GetSystem);

                  {--- Set the current prompt }
                  Params.Input(Buffer.Prompt);

                  {--- Set the web search parameters if necessary }
                  if not BundleParams.GetSearchSize.IsEmpty then
                    begin
                      var Search_web := TResponseWebSearchParams.New.SearchContextSize(BundleParams.GetSearchSize);

                      {---- Set the location if necessary }
                      if not BundleParams.GetCity.IsEmpty or
                         not BundleParams.GetCountry.IsEmpty then
                        begin
                          {--- "Location object" instantiation }
                          var Locate := TResponseUserLocationParams.New;

                          {--- Process for the city location }
                          if not BundleParams.GetCity.IsEmpty then
                            Locate.City(BundleParams.GetCity);

                            {--- Process for the country location }
                          if not BundleParams.GetCountry.IsEmpty then
                            Locate.Country(BundleParams.GetCountry);

                          {--- Sets the location object into the Search_web instance  }
                          Search_web.UserLocation(Locate);
                        end;

                      {--- Set the web search tool }
                      Params.Tools([Search_web]);
                    end;

                  {--- No storage because this type of treatment must be ephemeral }
                  Params.Store(False);
                end);
              Inc(Ranking);
              Buffer.FinishIndex := Ranking;

              {--- Construct the response as a directly usable text }
              for var Item in Response.Output do
                for var SubItem in Item.Content do
                  Buffer.Response := Buffer.Response + SubItem.Text + #10;

              {--- Return the "Response" object in the buffer }
              Buffer.Chat := Response;
            except
              on E: Exception do
                begin
                  {--- Catch the exception }
                  var Error := AcquireExceptionObject;
                  ErrorExists := True;
                  try
                    var ErrorMsg := (Error as Exception).Message;
                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(CallBacks.OnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        CallBacks.OnError(CallBacks.Sender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
          end);

        if ErrorExists then
          Continue;

        {--- TTask.WaitForAll is not used due to a memory leak in TLightweightEvent/TCompleteEventsWrapper.
             See report RSP-12462 and RSP-25999. }
        TTaskHelper.ContinueWith(Tasks[Index],
          procedure
          begin
            Dec(Counter);
            if Counter = 0 then
              begin
                try
                  if not ErrorExists and Assigned(CallBacks.OnSuccess) then
                    CallBacks.OnSuccess(CallBacks.Sender, Bundle);
                finally
                  Bundle.Free;
                end;
              end;
          end);
        {--- Need a delay, otherwise the process runs only with the first task. }
        Sleep(30);
      end;
  finally
    BundleParams.Free;
  end;
end;

function TResponsesRoute.Retrieve(const ResponseId: string): TResponse;
begin
  Result := API.Get<TResponse>('responses/' + ResponseID);
end;

function TResponsesRoute.CreateStream(ParamProc: TProc<TResponsesParams>;
  Event: TResponseEvent): Boolean;

(*
    {"type":"response.created","response":{"id":"resp_67ffeb4f88f4819183b0c7bfd76270970c4424583b6f214d","object":"response","created_at":1744825167,"status":"in_progress","error":null,"incomplete_details":null,"instructions":null,"max_output_tokens":null,"model":"gpt-4.1-nano-2025-04-14","output":[],"parallel_tool_calls":true,"previous_response_id":null,"reasoning":{"effort":null,"summary":null},"store":false,"temperature":1.0,"text":{"format":{"type":"text"}},"tool_choice":"auto","tools":[],"top_p":1.0,"truncation":"disabled","usage":null,"user":null,"metadata":{}}}
    {"type":"response.in_progress","response":{"id":"resp_67ffeb4f88f4819183b0c7bfd76270970c4424583b6f214d","object":"response","created_at":1744825167,"status":"in_progress","error":null,"incomplete_details":null,"instructions":null,"max_output_tokens":null,"model":"gpt-4.1-nano-2025-04-14","output":[],"parallel_tool_calls":true,"previous_response_id":null,"reasoning":{"effort":null,"summary":null},"store":false,"temperature":1.0,"text":{"format":{"type":"text"}},"tool_choice":"auto","tools":[],"top_p":1.0,"truncation":"disabled","usage":null,"user":null,"metadata":{}}}
    {"type":"response.output_item.added","output_index":0,"item":{"id":"msg_67ffeb4fbe28819193360cdfa54b544e0c4424583b6f214d","type":"message","status":"in_progress","content":[],"role":"assistant"}}
    {"type":"response.content_part.added","item_id":"msg_67ffeb4fbe28819193360cdfa54b544e0c4424583b6f214d","output_index":0,"content_index":0,"part":{"type":"output_text","annotations":[],"text":""}}
    {"type":"response.output_text.delta","item_id":"msg_67ffeb4fbe28819193360cdfa54b544e0c4424583b6f214d","output_index":0,"content_index":0,"delta":"Great"}
    ...
    {"type":"response.output_text.done","item_id":"msg_67ffeb4fbe28819193360cdfa54b544e0c4424583b6f214d","output_index":0,"content_index":0,"text":"message."}
    {"type":"response.content_part.done","item_id":"msg_67ffeb4fbe28819193360cdfa54b544e0c4424583b6f214d","output_index":0,"content_index":0,"part":{"type":"output_text","annotations":[],"text":"message"}}
    {"type":"response.output_item.done","output_index":0,"item":{"id":"msg_67ffeb4fbe28819193360cdfa54b544e0c4424583b6f214d","type":"message","status":"completed","content":[{"type":"output_text","annotations":[],"text":"messagele":"assistant"}}
*)

var
  Response: TStringStream;

  {--- Persistent variables between callbacks }
  CurrentEvent, CurrentData: string;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    CurrentEvent := EmptyStr;
    CurrentData := EmptyStr;

    Result := API.Post<TResponsesParams>('responses', ParamProc, Response,
      procedure(const Sender: TObject; AContentLength, AReadCount: Int64; var AAbort: Boolean)
      var
        IsDone: Boolean;
        ResponseData: TResponseStream;

        {--- Local buffer containing only the part not yet processed }
        Buffer: string;
        BufferPos, PosLineEnd: Integer;
        Line: string;
        NewBuffer: string;
      begin
        {--- Retrieve only the new portion of the stream }
        Buffer := Response.DataString;

        {--- local position in Buffer }
        BufferPos := 0;

        {--- As long as a complete line (terminated by LF) is available }
        while True do
          begin
            PosLineEnd := Buffer.IndexOf(#10, BufferPos);
            if PosLineEnd < 0 then
              {--- incomplete line, wait for the rest }
              Break;

            {--- Line extraction }
            Line := Buffer.Substring(BufferPos, PosLineEnd - BufferPos).Trim([' ', #13, #10]);
            BufferPos := PosLineEnd + 1;

            if Line.IsEmpty then
              begin
                {--- End of event block }
                if not CurrentData.Trim.IsEmpty then
                  begin
                    IsDone := CurrentEvent = 'response.completed';
                    ResponseData := nil;
                    if not IsDone then
                      begin
                        {--- Quick check before JSON parsing (potential optimization) }
                        if (CurrentData.Trim.StartsWith('{')) or (CurrentData.Trim.StartsWith('[')) then
                          begin
                            try
                              ResponseData := TApiDeserializer.Parse<TResponseStream>(CurrentData);
                            except
                              {--- If there is a mistake, nothing will be done. }
                              ResponseData := nil;
                            end;
                          end;
                      end;

                    try
                      {--- Call the callback with the event, the cat object and the end flag }
                      Event(ResponseData, IsDone, AAbort);
                    finally
                      ResponseData.Free;
                    end;
                  end;

                {--- Reset for next block }
                CurrentEvent := EmptyStr;
                CurrentData := EmptyStr;
              end
            else
              begin
                {--- Retrieving the information "event: ..." }
                if Line.StartsWith('event: ') then
                  begin
                    CurrentEvent := Line.Substring(7).Trim([' ', #13, #10])
                  end
                else
                {--- Retrieving the information "data: ..." }
                if Line.StartsWith('data: ') then
                  begin
                    if not CurrentData.IsEmpty then
                      CurrentData := CurrentData + sLineBreak;
                    CurrentData := CurrentData + Line.Substring(6).Trim([' ', #13, #10]);
                  end;
              end;
          end;

        {--- Buffer cleanup: keep only the incomplete portion }
        if BufferPos > 0 then
          begin
            NewBuffer := Buffer.Substring(BufferPos);

            {--- We empty the stream }
            Response.Size := 0;

            {--- then we rewrite the remaining fragment. }
            if not NewBuffer.IsEmpty then
              Response.WriteString(NewBuffer);
          end;
      end);
  finally
    Response.Free;
  end;
end;

function TResponsesRoute.Delete(const ResponseId: string): TResponseDelete;
begin
  Result := API.Delete<TResponseDelete>('responses/' + ResponseId);
end;

function TResponsesRoute.List(const ResponseId: string;
  const ParamProc: TProc<TUrlResponseListParams>): TResponses;
begin
  Result := API.Get<TResponses, TUrlResponseListParams>('responses/' + ResponseId + '/input_items', ParamProc);
end;

function TResponsesRoute.List(const ResponseId: string): TResponses;
begin
  Result := API.Get<TResponses>('responses/' + ResponseId + '/input_items');
end;

function TResponsesRoute.Retrieve(const ResponseId: string;
  const ParamProc: TProc<TURLIncludeParams>): TResponse;
begin
  Result := API.Get<TResponse, TURLIncludeParams>('responses/' + ResponseID, ParamProc);
end;

{ TUrlIncludeParams }

function TUrlIncludeParams.Include(
  const Value: TArray<string>): TUrlIncludeParams;
begin
  Result := TUrlIncludeParams(Add('include', Value));
end;

function TUrlIncludeParams.Include(
  const Value: TArray<TOutputIncluding>): TUrlIncludeParams;
var
  Include: TArray<string>;
begin
  for var Item in Value do
    Include := Include + [Item.ToString];
  Result := TUrlIncludeParams(Add('include', Include));
end;

{ TUrlResponseListParams }

function TUrlResponseListParams.After(
  const Value: string): TUrlResponseListParams;
begin
  Result := TUrlResponseListParams(Add('after', Value));
end;

function TUrlResponseListParams.Before(
  const Value: string): TUrlResponseListParams;
begin
  Result := TUrlResponseListParams(Add('before', Value));
end;

function TUrlResponseListParams.Include(
  const Value: TArray<TOutputIncluding>): TUrlResponseListParams;
var
  Include: TArray<string>;
begin
  for var Item in Value do
    Include := Include + [Item.ToString];
  Result := TUrlResponseListParams(Add('include', Include));
end;

function TUrlResponseListParams.Limit(
  const Value: Integer): TUrlResponseListParams;
begin
  Result := TUrlResponseListParams(Add('limit', Value));
end;

function TUrlResponseListParams.Include(
  const Value: TArray<string>): TUrlResponseListParams;
begin
  Result := TUrlResponseListParams(Add('include', Value));
end;

function TUrlResponseListParams.Order(
  const Value: string): TUrlResponseListParams;
begin
  Result := TUrlResponseListParams(Add('order', Value));
end;

{ TResponseCreated }

destructor TResponseCreated.Destroy;
begin
  if Assigned(FResponse) then
    FResponse.Free;
  inherited;
end;

{ TResponseOutputItemAdded }

destructor TResponseOutputItemAdded.Destroy;
begin
  if Assigned(FItem) then
    FItem.Free;
  inherited;
end;

{ TResponseContentpartAdded }

destructor TResponseContentpartAdded.Destroy;
begin
  if Assigned(FPart) then
    FPart.Free;
  inherited;
end;

{ TResponseOutputTextAnnotationAdded }

destructor TResponseOutputTextAnnotationAdded.Destroy;
begin
  if Assigned(FAnnotation) then
    FAnnotation.Free;
  inherited;
end;

end.

unit GenAI.Runs;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Threading, System.JSON, REST.Json.Types,
  REST.JsonReflect, System.Net.URLClient,
  GenAI.API.Params, GenAI.API, GenAI.Consts, GenAI.Types, GenAI.Async.Support,
  GenAI.API.Lists, GenAI.Assistants, GenAI.Threads, GenAI.Messages, GenAI.Chat;

type
  /// <summary>
  /// Represents the URL parameters for API requests related to execution runs on threads.
  /// </summary>
  /// <remarks>
  /// This class is used to customize and configure URL-based parameters for retrieving or
  /// managing runs in API requests.
  /// It extends the base functionality of <c>TUrlAdvancedParams</c>, enabling additional
  /// customization for OpenAI API endpoints related to execution runs.
  /// </remarks>
  TRunsUrlParams = TUrlAdvancedParams;

  /// <summary>
  /// Represents the configuration for selecting a tool choice when creating or running an execution
  /// run on a thread in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class allows specifying the tool type and, optionally, the name of the function to be
  /// called during the run.
  /// The tool choice is essential for directing the assistant to use specific tools like functions
  /// during an API run execution.
  /// </remarks>
  TRunsToolChoice = class(TJSONParam)
  public
    /// <summary>
    /// Sets the type of the tool to be used for this run.
    /// </summary>
    /// <param name="Value">
    /// The type of tool to use. For example, "function" when the assistant is expected to call
    /// a function during the run.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TRunsToolChoice</c> to allow method chaining.
    /// </returns>
    function &Type(const Value: string): TRunsToolChoice;
    /// <summary>
    /// Sets the name of the function to be called by the assistant during the run.
    /// </summary>
    /// <param name="Value">
    /// The name of the function. It should match a function defined within the assistant's toolset.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TRunsToolChoice</c> to allow method chaining.
    /// </returns>
    function &function(const Value: string): TRunsToolChoice;
    /// <summary>
    /// Creates a new tool choice with the specified function name.
    /// </summary>
    /// <param name="FunctionName">
    /// The name of the function that should be called by the assistant during the run.
    /// </param>
    /// <returns>
    /// Returns a new instance of <c>TRunsToolChoice</c> configured with the specified function
    /// name and tool type set to "function".
    /// </returns>
    class function New(const FunctionName: string): TRunsToolChoice;
  end;

  /// <summary>
  /// Represents the truncation strategy configuration for a run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class allows specifying how the thread context should be truncated when constructing
  /// the prompt for the run.
  /// Different truncation strategies help optimize token usage and focus the context on relevant
  /// messages.
  /// </remarks>
  TRunsTruncationStrategy = class(TJSONParam)
  public
    /// <summary>
    /// Sets the type of truncation strategy to be used.
    /// </summary>
    /// <param name="Value">
    /// The truncation strategy type. For example, "auto" to automatically determine which messages
    /// to drop or "last_messages" to keep the most recent messages.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TRunsTruncationStrategy</c> to allow method chaining.
    /// </returns>
    function &Type(const Value: string): TRunsTruncationStrategy; overload;
    /// <summary>
    /// Sets the type of truncation strategy using the predefined <c>TTruncationStrategyType</c>.
    /// </summary>
    /// <param name="Value">
    /// The truncation strategy type as an enumerated value.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TRunsTruncationStrategy</c> to allow method chaining.
    /// </returns>
    function &Type(const Value: TTruncationStrategyType): TRunsTruncationStrategy; overload;
    /// <summary>
    /// Specifies the number of recent messages to retain when using the "last_messages" truncation
    /// strategy.
    /// </summary>
    /// <param name="Value">
    /// The number of most recent messages to keep in the context.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TRunsTruncationStrategy</c> to allow method chaining.
    /// </returns>
    function LastMessages(const Value: Integer): TRunsTruncationStrategy;
  end;

  /// <summary>
  /// Represents the core parameters for creating or modifying a run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class provides methods to configure various settings such as model selection,
  /// instructions, token limits, tool usage, and other options that affect the behavior
  /// of the run.
  /// </remarks>
  TRunsCoreParams = class(TJSONParam)
  public
    /// <summary>
    /// Specifies the assistant to be used for the run.
    /// </summary>
    /// <param name="Value">
    /// The ID of the assistant that will execute the run.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TRunsCoreParams</c> to allow method chaining.
    /// </returns>
    function AssistantId(const Value: string): TRunsCoreParams;
    /// <summary>
    /// Specifies the model to be used for the run, overriding the default model of the assistant
    /// if provided.
    /// </summary>
    /// <param name="Value">
    /// The ID of the model to use.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TRunsCoreParams</c> to allow method chaining.
    /// </returns>
    function Model(const Value: string): TRunsCoreParams;
    /// <summary>
    /// Sets the primary instructions or system message that the assistant will follow during the run.
    /// </summary>
    /// <param name="Value">
    /// The instruction text.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TRunsCoreParams</c> to allow method chaining.
    /// </returns>
    function Instructions(const Value: string): TRunsCoreParams;
    /// <summary>
    /// Appends additional instructions to the existing ones for the run.
    /// </summary>
    /// <param name="Value">
    /// The additional instruction text to append.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TRunsCoreParams</c> to allow method chaining.
    /// </returns>
    function AdditionalInstructions(const Value: string): TRunsCoreParams;
    /// <summary>
    /// Sets the list of tools that can be used by the assistant during the run.
    /// </summary>
    /// <param name="Value">
    /// An array of tool configuration parameters.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TRunsCoreParams</c> to allow method chaining.
    /// </returns>
    function Tools(const Value: TArray<TAssistantsToolsParams>): TRunsCoreParams;
    /// <summary>
    /// Adds metadata to the run in the form of key-value pairs.
    /// </summary>
    /// <param name="Value">
    /// A JSON object containing metadata information.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TRunsCoreParams</c> to allow method chaining.
    /// </returns>
    function Metadata(const Value: TJSONObject): TRunsCoreParams;
    /// <summary>
    /// Specifies the temperature for sampling during the run.
    /// </summary>
    /// <param name="Value">
    /// The temperature value between 0 and 2, where higher values produce more random output.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TRunsCoreParams</c> to allow method chaining.
    /// </returns>
    function Temperature(const Value: Double): TRunsCoreParams;
    /// <summary>
    /// Specifies the nucleus sampling value (top-p) to be used during the run.
    /// </summary>
    /// <param name="Value">
    /// A value between 0 and 1, where smaller values consider fewer tokens.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TRunsCoreParams</c> to allow method chaining.
    /// </returns>
    function TopP(const Value: Double): TRunsCoreParams;
    /// <summary>
    /// Enables or disables token streaming during the run.
    /// </summary>
    /// <param name="Value">
    /// Set to <c>True</c> to enable streaming of tokens as they are generated.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TRunsCoreParams</c> to allow method chaining.
    /// </returns>
    function Stream(const Value: Boolean): TRunsCoreParams;
    /// <summary>
    /// Sets the maximum number of prompt tokens allowed during the run.
    /// </summary>
    /// <param name="Value">
    /// The maximum number of tokens to use for the input prompt.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TRunsCoreParams</c> to allow method chaining.
    /// </returns>
    function MaxPromptTokens(const Value: Integer): TRunsCoreParams;
    /// <summary>
    /// Sets the maximum number of completion tokens allowed during the run.
    /// </summary>
    /// <param name="Value">
    /// The maximum number of tokens to be generated as the output.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TRunsCoreParams</c> to allow method chaining.
    /// </returns>
    function MaxCompletionTokens(const Value: Integer): TRunsCoreParams;
    /// <summary>
    /// Specifies the truncation strategy to be used when constructing the context for the run.
    /// </summary>
    /// <param name="Value">
    /// The truncation strategy to apply.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TRunsCoreParams</c> to allow method chaining.
    /// </returns>
    function TruncationStrategy(const Value: TRunsTruncationStrategy): TRunsCoreParams;
    /// <summary>
    /// Sets the tool choice configuration for the run.
    /// </summary>
    /// <param name="Value">
    /// The tool choice string or object defining which tool to invoke.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TRunsCoreParams</c> to allow method chaining.
    /// </returns>
    function ToolChoice(const Value: string): TRunsCoreParams; overload;
    /// <summary>
    /// Sets the tool choice using an object that specifies the tool and optional function details.
    /// </summary>
    /// <param name="Value">
    /// An object containing the tool and function details.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TRunsCoreParams</c> to allow method chaining.
    /// </returns>
    function ToolChoice(const Value: TRunsToolChoice): TRunsCoreParams; overload;
    /// <summary>
    /// Enables or disables parallel tool calls during the run.
    /// </summary>
    /// <param name="Value">
    /// Set to <c>True</c> to enable multiple tool calls to run in parallel.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TRunsCoreParams</c> to allow method chaining.
    /// </returns>
    function ParallelToolCalls(const Value: Boolean): TRunsCoreParams;
    /// <summary>
    /// Specifies the response format to be used by the assistant during the run.
    /// </summary>
    /// <param name="Value">
    /// The format string or object describing the expected response format.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TRunsCoreParams</c> to allow method chaining.
    /// </returns>
    function ResponseFormat(const Value: string = 'auto'): TRunsCoreParams; overload;
    /// <summary>
    /// Specifies the response format using a structured object.
    /// </summary>
    /// <param name="Value">
    /// A structured response format parameter.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TRunsCoreParams</c> to allow method chaining.
    /// </returns>
    function ResponseFormat(const Value: TResponseFormatParams): TRunsCoreParams; overload;
    /// <summary>
    /// Specifies the response format using a JSON object.
    /// </summary>
    /// <param name="Value">
    /// A JSON object describing the response format.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TRunsCoreParams</c> to allow method chaining.
    /// </returns>
    function ResponseFormat(const Value: TJSONObject): TRunsCoreParams; overload;
  end;

  /// <summary>
  /// Represents the parameters for creating a run in the OpenAI API, extending the core parameters
  /// with additional settings.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TRunsCoreParams</c> by adding options for including additional messages
  /// at the start of the thread.
  /// It allows fine-tuning the initial context and behavior of the assistant during the run.
  /// </remarks>
  TRunsParams = class(TRunsCoreParams)
  public
    /// <summary>
    /// Specifies additional messages to be included at the start of the run.
    /// </summary>
    /// <param name="Value">
    /// An array of message parameters representing the messages to include.
    /// Each message defines a role (e.g., user or assistant) and its content.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TRunsParams</c> to allow method chaining.
    /// </returns>
    function AdditionalMessages(const Value: TArray<TThreadsMessageParams>): TRunsParams;
  end;

  /// <summary>
  /// Represents the parameters for creating a new thread and running it in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TRunsCoreParams</c> and allows configuring both the thread and the
  /// tools/resources available to the assistant during the run.
  /// It is used when you need to create a new conversation thread and immediately execute the run.
  /// </remarks>
  TCreateRunsParams = class(TRunsCoreParams)
  public
    /// <summary>
    /// Specifies the configuration for creating the initial thread associated with the run.
    /// </summary>
    /// <param name="Value">
    /// A <c>TThreadsCreateParams</c> object containing details about the initial messages, roles,
    /// and context for the thread.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TCreateRunsParams</c> to allow method chaining.
    /// </returns>
    function Thread(const Value: TThreadsCreateParams): TCreateRunsParams;
    /// <summary>
    /// Specifies the tools and resources that will be available to the assistant during the run.
    /// </summary>
    /// <param name="Value">
    /// A <c>TToolResourcesParams</c> object defining the resources, such as files or vector stores,
    /// that the assistant can access during the run.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TCreateRunsParams</c> to allow method chaining.
    /// </returns>
    function ToolResources(const Value: TToolResourcesParams): TCreateRunsParams;
  end;

  /// <summary>
  /// Represents the parameters for updating an existing run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class allows modifying metadata associated with a run, enabling the attachment of
  /// key-value pairs for tracking additional information.
  /// </remarks>
  TRunUpdateParams = class(TJSONParam)
  public
    /// <summary>
    /// Updates the metadata associated with the run.
    /// </summary>
    /// <param name="Value">
    /// A JSON object containing key-value pairs representing additional information about the run.
    /// Keys have a maximum length of 64 characters, and values have a maximum length of 512 characters.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TRunUpdateParams</c> to allow method chaining.
    /// </returns>
    function Metadata(const Value: TJSONObject): TRunUpdateParams;
  end;

  /// <summary>
  /// Represents the parameters for submitting tool outputs to a run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class allows specifying the output generated by a tool and associating it with
  /// the appropriate tool call within the run.
  /// Tool outputs are required to continue or complete certain runs that depend on external
  /// computations.
  /// </remarks>
  TToolOutputParam = class(TJSONParam)
  public
    /// <summary>
    /// Specifies the ID of the tool call that the output corresponds to.
    /// </summary>
    /// <param name="Value">
    /// The ID of the tool call, as provided in the required action details of the run.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TToolOutputParam</c> to allow method chaining.
    /// </returns>
    function ToolCallId(const Value: string): TToolOutputParam;
    /// <summary>
    /// Sets the output produced by the tool.
    /// </summary>
    /// <param name="Value">
    /// The output value generated by the tool, which will be submitted to the run.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TToolOutputParam</c> to allow method chaining.
    /// </returns>
    function Output(const Value: string): TToolOutputParam;
  end;

  /// <summary>
  /// Represents the parameters for submitting tool outputs to a run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class is used when a run requires external tool outputs to continue.
  /// It allows specifying the outputs from the tools and submitting them in a structured manner.
  /// </remarks>
  TSubmitToolParams = class(TJSONParam)
  public
    /// <summary>
    /// Specifies the outputs generated by the tools that are being submitted.
    /// </summary>
    /// <param name="Value">
    /// An instance of <c>TToolOutputParam</c> containing the details of the tool outputs, such
    /// as the tool call ID and its corresponding output.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TSubmitToolParams</c> to allow method chaining.
    /// </returns>
    function ToolOutputs(const Value: TArray<TToolOutputParam>): TSubmitToolParams;
    /// <summary>
    /// Enables or disables token streaming when submitting tool outputs.
    /// </summary>
    /// <param name="Value">
    /// Set to <c>True</c> to enable streaming, allowing the server to return a stream of events
    /// as the submission is processed.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TSubmitToolParams</c> to allow method chaining.
    /// </returns>
    function Stream(const Value: Boolean): TSubmitToolParams;
  end;

  /// <summary>
  /// Represents the tool output submissions required to continue a run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class holds the collection of tool call outputs that are needed to satisfy the required
  /// action of a run.
  /// Each tool call output contains the necessary details to be processed by the run.
  /// </remarks>
  TSubmitToolOutputs = class
  private
    [JsonNameAttribute('tool_calls')]
    FToolCalls: TArray<TToolcall>;
  public
    /// <summary>
    /// Gets or sets the array of tool call objects representing the outputs to be submitted.
    /// </summary>
    property ToolCalls: TArray<TToolcall> read FToolCalls write FToolCalls;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents details about an action required to continue an execution run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// When a run is paused and requires input or tool output to proceed, this class provides
  /// information on the specific action needed.
  /// </remarks>
  TRequiredAction = class
  private
    FType: string;
    [JsonNameAttribute('submit_tool_outputs')]
    FSubmitToolOutputs: TSubmitToolOutputs;
  public
    /// <summary>
    /// Gets or sets the type of required action.
    /// </summary>
    property &Type: string read FType write FType;
    /// <summary>
    /// Gets or sets details about the tool outputs required to continue the run.
    /// </summary>
    property SubmitToolOutputs: TSubmitToolOutputs read FSubmitToolOutputs write FSubmitToolOutputs;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents details about the last error encountered during an execution run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class provides information about the error, including its code and a descriptive message.
  /// </remarks>
  TLastError = class
  private
    FCode: string;
    FMessage: string;
  public
    /// <summary>
    /// Gets or sets the code associated with the error.
    /// </summary>
    /// <remarks>
    /// Possible values include server_error, rate_limit_exceeded, or invalid_prompt.
    /// </remarks>
    property Code: string read FCode write FCode;
    /// <summary>
    /// Gets or sets a human-readable message describing the error.
    /// </summary>
    property Message: string read FMessage write FMessage;
  end;

  /// <summary>
  /// Represents details about why an execution run is incomplete in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class provides the reason explaining why the run did not complete successfully,
  /// such as token limits or other restrictions.
  /// </remarks>
  TIncompleteDetailsReason = class
  private
    FReason: string;
  public
    /// <summary>
    /// Gets or sets the reason explaining why the run is incomplete.
    /// </summary>
    property Reason: string read FReason write FReason;
  end;

  /// <summary>
  /// Represents token usage statistics for an execution run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class tracks the number of tokens used during the run, including prompt tokens,
  /// completion tokens, and the total token count.
  /// </remarks>
  TRunUsage = class
  private
    [JsonNameAttribute('completion_tokens')]
    FCompletionTokens: Int64;
    [JsonNameAttribute('prompt_tokens')]
    FPromptTokens: Int64;
    [JsonNameAttribute('total_tokens')]
    FTotalTokens: Int64;
  public
    /// <summary>
    /// Gets or sets the number of completion tokens used during the run.
    /// </summary>
    property CompletionTokens: Int64 read FCompletionTokens write FCompletionTokens;
    /// <summary>
    /// Gets or sets the number of prompt tokens used during the run.
    /// </summary>
    property PromptTokens: Int64 read FPromptTokens write FPromptTokens;
    /// <summary>
    /// Gets or sets the total number of tokens (prompt + completion) used during the run.
    /// </summary>
    property TotalTokens: Int64 read FTotalTokens write FTotalTokens;
  end;

  /// <summary>
  /// Represents the truncation strategy used to manage the context window for an execution run
  /// in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class allows control over how much of the thread's context is included in the prompt,
  /// which helps optimize token usage.
  /// </remarks>
  TTruncationStrategy = class
  private
    [JsonReflectAttribute(ctString, rtString, TTruncationStrategyTypeInterceptor)]
    FType: TTruncationStrategyType;
    [JsonNameAttribute('last_messages')]
    FLastMessages: Int64;
  public
    /// <summary>
    /// Gets or sets the type of truncation strategy.
    /// </summary>
    /// <remarks>
    /// Common types include "auto" for automatic truncation and "last_messages" for retaining only
    /// the most recent messages.
    /// </remarks>
    property &Type: TTruncationStrategyType read FType write FType;
    /// <summary>
    /// Gets or sets the number of most recent messages to retain when using the "last_messages"
    /// truncation strategy.
    /// </summary>
    property LastMessages: Int64 read FLastMessages write FLastMessages;
  end;

  TRunTimeStamp = class(TJSONFingerprint)
  protected
    function GetCreatedAtAsString: string; virtual; abstract;
    function GetExpiresAtAsString: string; virtual; abstract;
    function GetStartedAtAsString: string; virtual; abstract;
    function GetCancelledAtAsString: string; virtual; abstract;
    function GetFailedAtAsString: string; virtual; abstract;
    function GetCompletedAtAsString: string; virtual; abstract;
  public
    property CreatedAtAsString: string read GetCreatedAtAsString;
    property ExpiresAtAsString: string read GetExpiresAtAsString;
    property StartedAtAsString: string read GetStartedAtAsString;
    property CancelledAtAsString: string read GetCancelledAtAsString;
    property FailedAtAsString: string read GetFailedAtAsString;
    property CompletedAtAsString: string read GetCompletedAtAsString;
  end;

  /// <summary>
  /// Represents an execution run on a thread in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class contains information about the run, such as its status, associated assistant,
  /// model, instructions, token usage, and any errors encountered.
  /// </remarks>
  TRun = class(TRunTimeStamp)
  private
    FId: string;
    [JsonNameAttribute('created_at')]
    FCreatedAt: TInt64OrNull;
    FObject: string;
    [JsonNameAttribute('thread_id')]
    FThreadId: string;
    [JsonNameAttribute('assistant_id')]
    FAssistantId: string;
    [JsonReflectAttribute(ctString, rtString, TRunStatusInterceptor)]
    FStatus: TRunStatus;
    [JsonNameAttribute('required_action')]
    FRequiredAction: TRequiredAction;
    [JsonNameAttribute('last_error')]
    FLastError: TLastError;
    [JsonNameAttribute('expires_at')]
    FExpiresAt: TInt64OrNull;
    [JsonNameAttribute('started_at')]
    FStartedAt: TInt64OrNull;
    [JsonNameAttribute('cancelled_at')]
    FCancelledAt: TInt64OrNull;
    [JsonNameAttribute('failed_at')]
    FFailedAt: TInt64OrNull;
    [JsonNameAttribute('completed_at')]
    FCompletedAt: TInt64OrNull;
    [JsonNameAttribute('incomplete_details')]
    FIncompleteDetails: TIncompleteDetails;
    FModel: string;
    FInstructions: string;
    FTools: TArray<TAssistantsTools>;
    [JsonReflectAttribute(ctString, rtString, TMetadataInterceptor)]
    FMetadata: string;
    FUsage: TRunUsage;
    FTemperature: Double;
    [JsonNameAttribute('top_p')]
    FTopP: Double;
    [JsonNameAttribute('max_prompt_tokens')]
    FMaxPromptTokens: Int64;
    [JsonNameAttribute('max_completion_tokens')]
    FMaxCompletionTokens: Int64;
    [JsonNameAttribute('truncation_strategy')]
    FTruncationStrategy: TTruncationStrategy;
    [JsonNameAttribute('tool_choice')]
    FToolChoice: string;
    [JsonNameAttribute('parallel_tool_calls')]
    FParallelToolCalls: Boolean;
    [JsonNameAttribute('response_format')]
    FResponseFormat: string;
  private
    function GetCreatedAt: Int64;
    function GetExpiresAt: Int64;
    function GetStartedAt: Int64;
    function GetCancelledAt: Int64;
    function GetFailedAt: Int64;
    function GetCompletedAt: Int64;
  protected
    function GetCreatedAtAsString: string; override;
    function GetExpiresAtAsString: string; override;
    function GetStartedAtAsString: string; override;
    function GetCancelledAtAsString: string; override;
    function GetFailedAtAsString: string; override;
    function GetCompletedAtAsString: string; override;
  public
    /// <summary>
    /// Gets or sets the unique identifier of the run.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Gets the creation timestamp of the run.
    /// </summary>
    property CreatedAt: Int64 read GetCreatedAt;
    /// <summary>
    /// Gets or sets the object type, which is always "thread.run".
    /// </summary>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// Gets or sets the ID of the thread associated with this run.
    /// </summary>
    property ThreadId: string read FThreadId write FThreadId;
    /// <summary>
    /// Gets or sets the ID of the assistant used during the run.
    /// </summary>
    property AssistantId: string read FAssistantId write FAssistantId;
    /// <summary>
    /// Gets or sets the status of the run.
    /// </summary>
    /// <remarks>
    /// Possible statuses include "queued", "in_progress", "requires_action", "failed",
    /// "completed", and others.
    /// </remarks>
    property Status: TRunStatus read FStatus write FStatus;
    /// <summary>
    /// Gets or sets details of any required action to continue the run.
    /// </summary>
    property RequiredAction: TRequiredAction read FRequiredAction write FRequiredAction;
    /// <summary>
    /// Gets or sets details about the last error encountered during the run, if any.
    /// </summary>
    property LastError: TLastError read FLastError write FLastError;
    /// <summary>
    /// Gets the expiration timestamp of the run.
    /// </summary>
    property ExpiresAt: Int64 read GetExpiresAt;
    /// <summary>
    /// Gets the timestamp when the run started.
    /// </summary>
    property StartedAt: Int64 read GetStartedAt;
    /// <summary>
    /// Gets the timestamp when the run was canceled, if applicable.
    /// </summary>
    property CancelledAt: Int64 read GetCancelledAt;
    /// <summary>
    /// Gets the timestamp when the run failed, if applicable.
    /// </summary>
    property FailedAt: Int64 read GetFailedAt;
    /// <summary>
    /// Gets the timestamp when the run was completed, if applicable.
    /// </summary>
    property CompletedAt: Int64 read GetCompletedAt;
    /// <summary>
    /// Gets or sets details explaining why the run is incomplete, if applicable.
    /// </summary>
    property IncompleteDetails: TIncompleteDetails read FIncompleteDetails write FIncompleteDetails;
    /// <summary>
    /// Gets or sets the model used during the run.
    /// </summary>
    property Model: string read FModel write FModel;
    /// <summary>
    /// Gets or sets the instructions provided to the assistant for this run.
    /// </summary>
    property Instructions: string read FInstructions write FInstructions;
    /// <summary>
    /// Gets or sets the tools available or used by the assistant during the run.
    /// </summary>
    property Tools: TArray<TAssistantsTools> read FTools write FTools;
    /// <summary>
    /// Gets or sets metadata associated with the run.
    /// </summary>
    property Metadata: string read FMetadata write FMetadata;
    /// <summary>
    /// Gets or sets the token usage statistics for this run.
    /// </summary>
    property Usage: TRunUsage read FUsage write FUsage;
    /// <summary>
    /// Gets or sets the sampling temperature used for the run.
    /// </summary>
    /// <remarks>
    /// Higher values make the output more random, while lower values make it more focused
    /// and deterministic.
    /// </remarks>
    property Temperature: Double read FTemperature write FTemperature;
    /// <summary>
    /// Gets or sets the nucleus sampling parameter for the run.
    /// </summary>
    /// <remarks>
    /// The top_p value determines the probability mass to consider for selecting tokens
    /// during generation.
    /// </remarks>
    property TopP: Double read FTopP write FTopP;
    /// <summary>
    /// Gets or sets the maximum number of prompt tokens allowed during the run.
    /// </summary>
    property MaxPromptTokens: Int64 read FMaxPromptTokens write FMaxPromptTokens;
    /// <summary>
    /// Gets or sets the maximum number of completion tokens allowed during the run.
    /// </summary>
    property MaxCompletionTokens: Int64 read FMaxCompletionTokens write FMaxCompletionTokens;
    /// <summary>
    /// Gets or sets the truncation strategy used for the run.
    /// </summary>
    property TruncationStrategy: TTruncationStrategy read FTruncationStrategy write FTruncationStrategy;
    /// <summary>
    /// Gets or sets the tool choice configuration for the run.
    /// </summary>
    property ToolChoice: string read FToolChoice write FToolChoice;
    /// <summary>
    /// Gets or sets whether parallel tool calls are enabled during the run.
    /// </summary>
    property ParallelToolCalls: Boolean read FParallelToolCalls write FParallelToolCalls;
    /// <summary>
    /// Gets or sets the response format expected for the run.
    /// </summary>
    property ResponseFormat: string read FResponseFormat write FResponseFormat;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a list of execution runs on a thread in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class is a collection of <c>TRun</c> objects, providing access to multiple execution
  /// runs associated with a specific thread.
  /// It can be used to iterate through and retrieve information about each run.
  /// </remarks>
  TRuns = TAdvancedList<TRun>;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TRun</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynRun</c> type extends the <c>TAsynParams&lt;TRun&gt;</c> record to handle the lifecycle
  /// of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts,
  /// completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynRun = TAsynCallBack<TRun>;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TRuns</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynRuns</c> type extends the <c>TAsynParams&lt;TRuns&gt;</c> record to handle the
  /// lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts,
  /// completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynRuns = TAsynCallBack<TRuns>;

  /// <summary>
  /// Represents the route for managing execution runs in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class provides methods to create, retrieve, update, list, and manage execution runs on threads.
  /// It handles both synchronous and asynchronous requests, allowing efficient interaction with
  /// the OpenAI API for execution management.
  /// </remarks>
  TRunsRoute = class(TGenAIRoute)
  protected
    /// <summary>
    /// Customizes the headers used for the message routes.
    /// </summary>
    procedure HeaderCustomize; override;
  public
    /// <summary>
    /// Asynchronously creates an execution run on a thread.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread to run.</param>
    /// <param name="ParamProc">A procedure specifying run parameters.</param>
    /// <param name="CallBacks">Callback functions to handle asynchronous execution.</param>
    procedure AsynCreate(const ThreadId: string; const ParamProc: TProc<TRunsParams>;
      const CallBacks: TFunc<TAsynRun>);
    /// <summary>
    /// Asynchronously creates a thread and runs it in one request.
    /// </summary>
    /// <param name="ParamProc">A procedure specifying thread creation and run parameters.</param>
    /// <param name="CallBacks">Callback functions to handle asynchronous execution.</param>
    procedure AsynCreateAndRun(const ParamProc: TProc<TCreateRunsParams>;
      const CallBacks: TFunc<TAsynRun>);
    /// <summary>
    /// Asynchronously retrieves a list of execution runs associated with a thread.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread whose runs are to be listed.</param>
    /// <param name="CallBacks">Callback functions to handle asynchronous execution.</param>
    procedure AsynList(const ThreadId: string; const CallBacks: TFunc<TAsynRuns>); overload;
    /// <summary>
    /// Asynchronously retrieves a filtered list of execution runs associated with a thread.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread whose runs are to be listed.</param>
    /// <param name="ParamProc">A procedure specifying filter parameters for listing runs.</param>
    /// <param name="CallBacks">Callback functions to handle asynchronous execution.</param>
    procedure AsynList(const ThreadId: string; const ParamProc: TProc<TRunsUrlParams>;
      const CallBacks: TFunc<TAsynRuns>); overload;
    /// <summary>
    /// Asynchronously retrieves details of a specific execution run.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread that contains the run.</param>
    /// <param name="RunId">The ID of the run to retrieve.</param>
    /// <param name="CallBacks">Callback functions to handle asynchronous execution.</param>
    procedure AsynRetrieve(const ThreadId: string; const RunId: string;
      const CallBacks: TFunc<TAsynRun>);
    /// <summary>
    /// Asynchronously updates an existing execution run with new metadata.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread containing the run.</param>
    /// <param name="RunId">The ID of the run to update.</param>
    /// <param name="ParamProc">A procedure specifying update parameters.</param>
    /// <param name="CallBacks">Callback functions to handle asynchronous execution.</param>
    procedure AsynUpdate(const ThreadId: string; const RunId: string;
      const ParamProc: TProc<TRunUpdateParams>;
      const CallBacks: TFunc<TAsynRun>);
    /// <summary>
    /// Asynchronously submits tool outputs for a paused run that requires them to continue.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread containing the run.</param>
    /// <param name="RunId">The ID of the run requiring tool outputs.</param>
    /// <param name="ParamProc">A procedure specifying tool output parameters.</param>
    /// <param name="CallBacks">Callback functions to handle asynchronous execution.</param>
    procedure AsynSubmitTool(const ThreadId: string; const RunId: string;
      const ParamProc: TProc<TSubmitToolParams>;
      const CallBacks: TFunc<TAsynRun>);
    /// <summary>
    /// Asynchronously cancels an execution run that is in progress.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread containing the run.</param>
    /// <param name="RunId">The ID of the run to cancel.</param>
    /// <param name="CallBacks">Callback functions to handle asynchronous execution.</param>
    procedure AsynCancel(const ThreadId: string; const RunId: string;
      const CallBacks: TFunc<TAsynRun>);
    /// <summary>
    /// Creates a new execution run on a thread.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread to run.</param>
    /// <param name="ParamProc">A procedure specifying run parameters.</param>
    /// <returns>The created <c>TRun</c> object representing the execution run.</returns>
    function Create(const ThreadId: string; const ParamProc: TProc<TRunsParams>): TRun;
    /// <summary>
    /// Creates a thread and runs it in one request.
    /// </summary>
    /// <param name="ParamProc">A procedure specifying thread creation and run parameters.</param>
    /// <returns>The created <c>TRun</c> object representing the execution run.</returns>
    function CreateAndRun(const ParamProc: TProc<TCreateRunsParams>): TRun;
    /// <summary>
    /// Retrieves a list of execution runs associated with a thread.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread whose runs are to be listed.</param>
    /// <returns>A list of <c>TRun</c> objects representing the execution runs.</returns>
    function List(const ThreadId: string): TRuns; overload;
    /// <summary>
    /// Retrieves a filtered list of execution runs associated with a thread.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread whose runs are to be listed.</param>
    /// <param name="ParamProc">A procedure specifying filter parameters for listing runs.</param>
    /// <returns>A list of <c>TRun</c> objects representing the filtered execution runs.</returns>
    function List(const ThreadId: string; const ParamProc: TProc<TRunsUrlParams>): TRuns; overload;
    /// <summary>
    /// Retrieves details of a specific execution run.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread containing the run.</param>
    /// <param name="RunId">The ID of the run to retrieve.</param>
    /// <returns>The <c>TRun</c> object containing the run details.</returns>
    function Retrieve(const ThreadId: string; const RunId: string): TRun;
    /// <summary>
    /// Updates an existing execution run with new metadata.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread containing the run.</param>
    /// <param name="RunId">The ID of the run to update.</param>
    /// <param name="ParamProc">A procedure specifying update parameters.</param>
    /// <returns>The updated <c>TRun</c> object.</returns>
    function Update(const ThreadId: string; const RunId: string;
      const ParamProc: TProc<TRunUpdateParams>): TRun;
    /// <summary>
    /// Submits tool outputs for a paused run that requires them to continue.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread containing the run.</param>
    /// <param name="RunId">The ID of the run requiring tool outputs.</param>
    /// <param name="ParamProc">A procedure specifying tool output parameters.</param>
    /// <returns>The updated <c>TRun</c> object after tool submission.</returns>
    function SubmitTool(const ThreadId: string; const RunId: string;
      const ParamProc: TProc<TSubmitToolParams>): TRun;
    /// <summary>
    /// Cancels an execution run that is in progress.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread containing the run.</param>
    /// <param name="RunId">The ID of the run to cancel.</param>
    /// <returns>The <c>TRun</c> object with the updated status indicating cancellation.</returns>
    function Cancel(const ThreadId: string; const RunId: string): TRun;
  end;

implementation

{ TRunsRoute }

procedure TRunsRoute.AsynCancel(const ThreadId, RunId: string;
  const CallBacks: TFunc<TAsynRun>);
begin
  with TAsynCallBackExec<TAsynRun, TRun>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TRun
      begin
        Result := Self.Cancel(ThreadId, RunId);
      end);
  finally
    Free;
  end;
end;

procedure TRunsRoute.AsynCreate(const ThreadId: string;
  const ParamProc: TProc<TRunsParams>; const CallBacks: TFunc<TAsynRun>);
begin
  with TAsynCallBackExec<TAsynRun, TRun>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TRun
      begin
        Result := Self.Create(ThreadId, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TRunsRoute.AsynCreateAndRun(const ParamProc: TProc<TCreateRunsParams>;
  const CallBacks: TFunc<TAsynRun>);
begin
  with TAsynCallBackExec<TAsynRun, TRun>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TRun
      begin
        Result := Self.CreateAndRun(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TRunsRoute.AsynList(const ThreadId: string;
  const ParamProc: TProc<TRunsUrlParams>; const CallBacks: TFunc<TAsynRuns>);
begin
  with TAsynCallBackExec<TAsynRuns, TRuns>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TRuns
      begin
        Result := Self.List(ThreadId, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TRunsRoute.AsynList(const ThreadId: string;
  const CallBacks: TFunc<TAsynRuns>);
begin
  with TAsynCallBackExec<TAsynRuns, TRuns>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TRuns
      begin
        Result := Self.List(ThreadId);
      end);
  finally
    Free;
  end;
end;

procedure TRunsRoute.AsynRetrieve(const ThreadId, RunId: string;
  const CallBacks: TFunc<TAsynRun>);
begin
  with TAsynCallBackExec<TAsynRun, TRun>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TRun
      begin
        Result := Self.Retrieve(ThreadId, RunId);
      end);
  finally
    Free;
  end;
end;

procedure TRunsRoute.AsynSubmitTool(const ThreadId, RunId: string;
  const ParamProc: TProc<TSubmitToolParams>; const CallBacks: TFunc<TAsynRun>);
begin
  with TAsynCallBackExec<TAsynRun, TRun>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TRun
      begin
        Result := Self.SubmitTool(ThreadId, RunId, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TRunsRoute.AsynUpdate(const ThreadId, RunId: string;
  const ParamProc: TProc<TRunUpdateParams>; const CallBacks: TFunc<TAsynRun>);
begin
  with TAsynCallBackExec<TAsynRun, TRun>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TRun
      begin
        Result := Self.Update(ThreadId, RunId, ParamProc);
      end);
  finally
    Free;
  end;
end;

function TRunsRoute.Cancel(const ThreadId, RunId: string): TRun;
begin
  HeaderCustomize;
  Result := API.Post<TRun>('threads/' + ThreadId + '/runs/' + RunId + '/cancel');
end;

function TRunsRoute.Create(const ThreadId: string;
  const ParamProc: TProc<TRunsParams>): TRun;
begin
  HeaderCustomize;
  Result := API.Post<TRun, TRunsParams>('threads/' + ThreadId + '/runs', ParamProc);
end;

function TRunsRoute.CreateAndRun(
  const ParamProc: TProc<TCreateRunsParams>): TRun;
begin
  HeaderCustomize;
  Result := API.Post<TRun, TCreateRunsParams>('threads/runs', ParamProc);
end;

procedure TRunsRoute.HeaderCustomize;
begin
  inherited;
  API.CustomHeaders := [TNetHeader.Create('OpenAI-Beta', 'assistants=v2')];
end;

function TRunsRoute.List(const ThreadId: string): TRuns;
begin
  HeaderCustomize;
  Result := API.Get<TRuns>('threads/' + ThreadId + '/runs');
end;

function TRunsRoute.List(const ThreadId: string;
  const ParamProc: TProc<TRunsUrlParams>): TRuns;
begin
  HeaderCustomize;
  Result := API.Get<TRuns, TRunsUrlParams>('threads/' + ThreadId + '/runs', ParamProc);
end;

function TRunsRoute.Retrieve(const ThreadId, RunId: string): TRun;
begin
  HeaderCustomize;
  Result := API.Get<TRun>('threads/' + ThreadId + '/runs/' + RunId);
end;

function TRunsRoute.SubmitTool(const ThreadId, RunId: string;
  const ParamProc: TProc<TSubmitToolParams>): TRun;
begin
  HeaderCustomize;
  Result := API.Post<TRun, TSubmitToolParams>('threads/' + ThreadId + '/runs/' + RunId + '/submit_tool_outputs', ParamProc);
end;

function TRunsRoute.Update(const ThreadId, RunId: string;
  const ParamProc: TProc<TRunUpdateParams>): TRun;
begin
  HeaderCustomize;
  Result := API.Post<TRun, TRunUpdateParams>('threads/' + ThreadId + '/runs/' + RunId, ParamProc);
end;

{ TRunsCoreParams }

function TRunsCoreParams.AdditionalInstructions(const Value: string): TRunsCoreParams;
begin
  Result := TRunsCoreParams(Add('additional_instructions', Value));
end;

function TRunsCoreParams.AssistantId(const Value: string): TRunsCoreParams;
begin
  Result := TRunsCoreParams(Add('assistant_id', Value));
end;

function TRunsCoreParams.Instructions(const Value: string): TRunsCoreParams;
begin
  Result := TRunsCoreParams(Add('instructions', Value));
end;

function TRunsCoreParams.MaxCompletionTokens(const Value: Integer): TRunsCoreParams;
begin
  Result := TRunsCoreParams(Add('max_completion_tokens', Value));
end;

function TRunsCoreParams.MaxPromptTokens(const Value: Integer): TRunsCoreParams;
begin
  Result := TRunsCoreParams(Add('max_prompt_tokens', Value));
end;

function TRunsCoreParams.Metadata(const Value: TJSONObject): TRunsCoreParams;
begin
  Result := TRunsCoreParams(Add('metadata', Value));
end;

function TRunsCoreParams.Model(const Value: string): TRunsCoreParams;
begin
  Result := TRunsCoreParams(Add('model', Value));
end;

function TRunsCoreParams.ParallelToolCalls(const Value: Boolean): TRunsCoreParams;
begin
  Result := TRunsCoreParams(Add('parallel_tool_calls', Value));
end;

function TRunsCoreParams.ResponseFormat(
  const Value: TResponseFormatParams): TRunsCoreParams;
begin
  Result := TRunsCoreParams(Add('response_format', Value.Detach));
end;

function TRunsCoreParams.ResponseFormat(const Value: string): TRunsCoreParams;
begin
  Result := TRunsCoreParams(Add('response_format', Value));
end;

function TRunsCoreParams.Stream(const Value: Boolean): TRunsCoreParams;
begin
  Result := TRunsCoreParams(Add('stream', Value));
end;

function TRunsCoreParams.Temperature(const Value: Double): TRunsCoreParams;
begin
  Result := TRunsCoreParams(Add('temperature', Value));
end;

function TRunsCoreParams.ToolChoice(const Value: string): TRunsCoreParams;
begin
  Result := TRunsCoreParams(Add('tool_choice', Value));
end;

function TRunsCoreParams.ToolChoice(const Value: TRunsToolChoice): TRunsCoreParams;
begin
  Result := TRunsCoreParams(Add('tool_choice', Value.Detach));
end;

function TRunsCoreParams.Tools(const Value: TArray<TAssistantsToolsParams>): TRunsCoreParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TRunsCoreParams(Add('tools', JSONArray));
end;

function TRunsCoreParams.TopP(const Value: Double): TRunsCoreParams;
begin
  Result := TRunsCoreParams(Add('top_p', Value));
end;

function TRunsCoreParams.TruncationStrategy(
  const Value: TRunsTruncationStrategy): TRunsCoreParams;
begin
  Result := TRunsCoreParams(Add('truncation_strategy', Value.Detach));
end;

function TRunsCoreParams.ResponseFormat(const Value: TJSONObject): TRunsCoreParams;
begin
  Result := TRunsCoreParams(Add('response_format', Value));
end;

{ TRunsTruncationStrategy }

function TRunsTruncationStrategy.LastMessages(
  const Value: Integer): TRunsTruncationStrategy;
begin
  Result := TRunsTruncationStrategy(Add('last_messages', Value));
end;

function TRunsTruncationStrategy.&Type(const Value: string): TRunsTruncationStrategy;
begin
  Result := TRunsTruncationStrategy(Add('type', TTruncationStrategyType.Create(Value).ToString));
end;

function TRunsTruncationStrategy.&Type(
  const Value: TTruncationStrategyType): TRunsTruncationStrategy;
begin
  Result := TRunsTruncationStrategy(Add('type', Value.ToString));
end;

{ TRunsToolChoice }

function TRunsToolChoice.&function(
  const Value: string): TRunsToolChoice;
begin
  Result := TRunsToolChoice(Add('function', TJSONObject.Create.AddPair('name', Value)));
end;

class function TRunsToolChoice.New(
  const FunctionName: string): TRunsToolChoice;
begin
  Result := TRunsToolChoice.Create.&Type('function').&function(FunctionName);
end;

function TRunsToolChoice.&Type(
  const Value: string): TRunsToolChoice;
begin
  Result := TRunsToolChoice(Add('type', Value));
end;

{ TRun }

destructor TRun.Destroy;
begin
  if Assigned(FRequiredAction) then
    FRequiredAction.Free;
  if Assigned(FLastError) then
    FLastError.Free;
  if Assigned(FIncompleteDetails) then
    FIncompleteDetails.Free;
  for var Item in FTools do
    Item.Free;
  if Assigned(FUsage) then
    FUsage.Free;
  if Assigned(FTruncationStrategy) then
    FTruncationStrategy.Free;
  inherited;
end;

function TRun.GetCancelledAt: Int64;
begin
  Result := TInt64OrNull(FCancelledAt).ToInteger;
end;

function TRun.GetCancelledAtAsString: string;
begin
  Result := TInt64OrNull(FCancelledAt).ToUtcDateString;
end;

function TRun.GetCompletedAt: Int64;
begin
  Result := TInt64OrNull(FCompletedAt).ToInteger;
end;

function TRun.GetCompletedAtAsString: string;
begin
  Result := TInt64OrNull(FCompletedAt).ToUtcDateString;
end;

function TRun.GetCreatedAt: Int64;
begin
  Result := TInt64OrNull(FCreatedAt).ToInteger;
end;

function TRun.GetCreatedAtAsString: string;
begin
  Result := TInt64OrNull(FCreatedAt).ToUtcDateString;
end;

function TRun.GetExpiresAt: Int64;
begin
  Result := TInt64OrNull(FExpiresAt).ToInteger;
end;

function TRun.GetExpiresAtAsString: string;
begin
  Result := TInt64OrNull(FExpiresAt).ToUtcDateString;
end;

function TRun.GetFailedAt: Int64;
begin
  Result := TInt64OrNull(FFailedAt).ToInteger;
end;

function TRun.GetFailedAtAsString: string;
begin
  Result := TInt64OrNull(FFailedAt).ToUtcDateString;
end;

function TRun.GetStartedAt: Int64;
begin
  Result := TInt64OrNull(StartedAt).ToInteger;
end;

function TRun.GetStartedAtAsString: string;
begin
  Result := TInt64OrNull(FStartedAt).ToUtcDateString;
end;

{ TRequiredAction }

destructor TRequiredAction.Destroy;
begin
  if Assigned(FSubmitToolOutputs) then
    FSubmitToolOutputs.Free;
  inherited;
end;

{ TSubmitToolOutputs }

destructor TSubmitToolOutputs.Destroy;
begin
  for var Item in FToolCalls do
    Item.Free;
  inherited;
end;

{ TRunsParams }

function TRunsParams.AdditionalMessages(
  const Value: TArray<TThreadsMessageParams>): TRunsParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TRunsParams(Add('additional_messages', JSONArray));
end;

{ TCreateRunsParams }

function TCreateRunsParams.Thread(
  const Value: TThreadsCreateParams): TCreateRunsParams;
begin
  Result := TCreateRunsParams(Add('thread', Value.Detach));
end;

function TCreateRunsParams.ToolResources(
  const Value: TToolResourcesParams): TCreateRunsParams;
begin
  Result := TCreateRunsParams(Add('tool_resources', Value.Detach));
end;

{ TRunUpdateParams }

function TRunUpdateParams.Metadata(const Value: TJSONObject): TRunUpdateParams;
begin
  Result := TRunUpdateParams(Add('metadata', Value));
end;

{ TToolOutputParam }

function TToolOutputParam.Output(const Value: string): TToolOutputParam;
begin
  Result := TToolOutputParam(Add('output', Value));
end;

function TToolOutputParam.ToolCallId(const Value: string): TToolOutputParam;
begin
  Result := TToolOutputParam(Add('tool_call_id', Value));
end;

{ TSubmitToolParams }

function TSubmitToolParams.Stream(const Value: Boolean): TSubmitToolParams;
begin
  Result := TSubmitToolParams(Add('stream', Value));
end;

function TSubmitToolParams.ToolOutputs(
  const Value: TArray<TToolOutputParam>): TSubmitToolParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TSubmitToolParams(Add('tool_outputs', JSONArray));
end;

end.

unit GenAI.RunSteps;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Threading, System.JSON, REST.Json.Types,
  REST.JsonReflect, System.Net.URLClient,
  GenAI.API.Params, GenAI.API, GenAI.Consts, GenAI.Types, GenAI.Async.Support,
  GenAI.API.Lists, GenAI.Assistants, GenAI.Runs;

type
  /// <summary>
  /// Represents URL parameters for retrieving specific run step details in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class is used to customize URL parameters when making requests to retrieve details about
  /// specific steps within an execution run. It enables including additional fields in the API response.
  /// </remarks>
  TRetrieveStepUrlParam = class(TUrlParam)
  public
    /// <summary>
    /// Specifies the additional fields to include in the API response when retrieving run step details.
    /// </summary>
    /// <param name="Value">
    /// An array of strings representing the fields to include in the response. For example, including
    /// the tool call results or additional step metadata.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TRetrieveStepUrlParam</c>, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// The include parameter helps retrieve additional step details, such as file search results,
    /// tool outputs, or other relevant content within a step.
    /// </remarks>
    function Include(const Value: TArray<string>): TRetrieveStepUrlParam;
  end;

  /// <summary>
  /// Represents URL parameters for listing or retrieving multiple run steps in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class is used to customize URL parameters when making requests to list or retrieve details
  /// about multiple steps within an execution run. It allows for including additional data in the API response.
  /// </remarks>
  TRunStepUrlParam = class(TUrlAdvancedParams)
  public
    /// <summary>
    /// Specifies the additional fields to include in the API response when listing or retrieving run steps.
    /// </summary>
    /// <param name="Value">
    /// An array of strings representing the fields to include in the response, such as tool call outputs
    /// or file search results.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TRunStepUrlParam</c>, enabling method chaining.
    /// </returns>
    /// <remarks>
    /// The include parameter allows retrieving extended information about the run steps, like intermediate
    /// tool outputs, search results, and any additional metadata attached to a step.
    /// </remarks>
    function Include(const Value: TArray<string>): TRunStepUrlParam;
  end;

  /// <summary>
  /// Represents details about the message creation step within an execution run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class provides information related to a message created during a run step, such as
  /// the unique identifier of the created message.
  /// </remarks>
  TRunStepMessageCreation = class
  private
    [JsonNameAttribute('message_id')]
    FMessageId: string;
  public
    /// <summary>
    /// Gets or sets the unique identifier of the message created during this run step.
    /// </summary>
    property MessageId: string read FMessageId write FMessageId;
  end;

  /// <summary>
  /// Represents details of an image output generated during a code interpreter run step in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class provides information about an image output, including the unique file identifier.
  /// </remarks>
  TOutputImage = class
  private
    [JsonNameAttribute('file_id')]
    FFileId: string;
  public
    /// <summary>
    /// Gets or sets the unique identifier of the file containing the image output.
    /// </summary>
    property FileId: string read FFileId write FFileId;
  end;

  /// <summary>
  /// Represents the output generated by the code interpreter during a run step in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class contains details about the output from the code interpreter, which can include logs
  /// and image outputs.
  /// </remarks>
  TCodeInterpreterOutput = class
  private
    FType: string;
    FLogs: string;
    FImage: TOutputImage;
  public
    /// <summary>
    /// Gets or sets the type of the output generated, such as logs or images.
    /// </summary>
    property &Type: string read FType write FType;
    /// <summary>
    /// Gets or sets the text-based logs generated during the code interpreter run step.
    /// </summary>
    property Logs: string read FLogs write FLogs;
    /// <summary>
    /// Gets or sets the image output generated by the code interpreter, if available.
    /// </summary>
    property Image: TOutputImage read FImage write FImage;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents the details of a code interpreter step within an execution run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class contains information about the input provided to the code interpreter and the outputs
  /// it generated, such as logs or images.
  /// </remarks>
  TRunStepCodeInterpreter = class
  private
    FInput: string;
    FOutputs: TArray<TCodeInterpreterOutput>;
  public
    /// <summary>
    /// Gets or sets the input provided to the code interpreter during the run step.
    /// </summary>
    property Input: string read FInput write FInput;
    /// <summary>
    /// Gets or sets the outputs generated by the code interpreter, which may include logs and images.
    /// </summary>
    property Outputs: TArray<TCodeInterpreterOutput> read FOutputs write FOutputs;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents the content of a search result within a file search tool call during an execution run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class contains details about the content type and the corresponding text found during the file search.
  /// </remarks>
  TResultContent = class
  private
    FType: string;
    FText: string;
  public
    /// <summary>
    /// Gets or sets the type of the content, such as text or another supported format.
    /// </summary>
    property &Type: string read FType write FType;
    /// <summary>
    /// Gets or sets the textual content retrieved from the file search result.
    /// </summary>
    property Text: string read FText write FText;
  end;

  /// <summary>
  /// Represents a result from a file search tool call within an execution run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class contains information about a file search result, including the file details, score, and
  /// the content found within the file.
  /// </remarks>
  TRunFileSearchResult = class
  private
    [JsonNameAttribute('file_id')]
    FFileId: string;
    [JsonNameAttribute('file_name')]
    FFileName: string;
    FScore: Double;
    FContent: TArray<TResultContent>;
  public
    /// <summary>
    /// Gets or sets the unique identifier of the file where the search result was found.
    /// </summary>
    property FileId: string read FFileId write FFileId;
    /// <summary>
    /// Gets or sets the name of the file where the search result was found.
    /// </summary>
    property FileName: string read FFileName write FFileName;
    /// <summary>
    /// Gets or sets the score assigned to this search result, indicating its relevance.
    /// </summary>
    property Score: Double read FScore write FScore;
    /// <summary>
    /// Gets or sets the array of content results found in the file, such as matching text or data.
    /// </summary>
    property Content: TArray<TResultContent> read FContent write FContent;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents details of a file search tool call within an execution run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class contains information about the file search operation, including the ranking options used
  /// and the results retrieved from the search.
  /// </remarks>
  TRunStepFileSearch = class
  private
    [JsonNameAttribute('ranking_options')]
    FRankingOptions: TRankingOptions;
    FResults: TArray<TRunFileSearchResult>;
  public
    /// <summary>
    /// Gets or sets the ranking options used to determine the relevance of search results.
    /// </summary>
    property RankingOptions: TRankingOptions read FRankingOptions write FRankingOptions;
    /// <summary>
    /// Gets or sets the array of search results, each containing details about the matching files and content.
    /// </summary>
    property Results: TArray<TRunFileSearchResult> read FResults write FResults;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents details of a function tool call within an execution run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class contains information about a function tool call, including the function name,
  /// arguments passed, and the output generated.
  /// </remarks>
  TRunStepFunction = class
  private
    FName: string;
    FArguments: string;
    FOutput: string;
  public
    /// <summary>
    /// Gets or sets the name of the function called during this run step.
    /// </summary>
    property Name: string read FName write FName;
    /// <summary>
    /// Gets or sets the arguments provided to the function during the tool call.
    /// </summary>
    property Arguments: string read FArguments write FArguments;
    /// <summary>
    /// Gets or sets the output generated by the function after execution.
    /// </summary>
    property Output: string read FOutput write FOutput;
  end;

  /// <summary>
  /// Represents details of tool calls made during a specific run step in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class provides information about various tool calls, such as code interpreter executions,
  /// file searches, or function invocations.
  /// </remarks>
  TRunStepToolCalls = class
  private
    FId: string;
    [JsonReflectAttribute(ctString, rtString, TAssistantsToolsTypeInterceptor)]
    FType: TAssistantsToolsType;
    [JsonNameAttribute('code_interpreter')]
    FCodeInterpreter: TRunStepCodeInterpreter;
    [JsonNameAttribute('file_search')]
    FFileSearch: TRunStepFileSearch;
    FFunction: TRunStepFunction;
  public
    /// <summary>
    /// Gets or sets the unique identifier of the tool call.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Gets or sets the type of the tool call, such as a code interpreter, file search, or function.
    /// </summary>
    property &Type: TAssistantsToolsType read FType write FType;
    /// <summary>
    /// Gets or sets the details of the code interpreter tool call if applicable.
    /// </summary>
    property CodeInterpreter: TRunStepCodeInterpreter read FCodeInterpreter write FCodeInterpreter;
    /// <summary>
    /// Gets or sets the details of the file search tool call if applicable.
    /// </summary>
    property FileSearch: TRunStepFileSearch read FFileSearch write FFileSearch;
    /// <summary>
    /// Gets or sets the details of the function tool call if applicable.
    /// </summary>
    property &Function: TRunStepFunction read FFunction write FFunction;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents the detailed information of a run step within an execution run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class provides details about the type of run step and any associated tool calls
  /// or message creation activities.
  /// </remarks>
  TRunStepDetails = class
  private
    [JsonReflectAttribute(ctString, rtString, TRunStepTypeInterceptor)]
    FType: TRunStepType;
    [JsonNameAttribute('message_creation')]
    FMessageCreation: TRunStepMessageCreation;
    [JsonNameAttribute('tool_calls')]
    FToolCalls: TArray<TRunStepToolCalls>;
  public
    /// <summary>
    /// Gets or sets the type of the run step, such as message creation or tool calls.
    /// </summary>
    property &Type: TRunStepType read FType write FType;
    /// <summary>
    /// Gets or sets the details of a message created during this run step, if applicable.
    /// </summary>
    property MessageCreation: TRunStepMessageCreation read FMessageCreation write FMessageCreation;
    /// <summary>
    /// Gets or sets the array of tool calls made during this run step, if any.
    /// </summary>
    property ToolCalls: TArray<TRunStepToolCalls> read FToolCalls write FToolCalls;
    destructor Destroy; override;
  end;

  TRunStepTimestamp = class(TJSONFingerprint)
  protected
    function GetCreatedAtAsString: string; virtual; abstract;
    function GetExpiredAtAsString: string; virtual; abstract;
    function GetCancelledAtAsString: string; virtual; abstract;
    function GetFailedAtAsString: string; virtual; abstract;
    function GetCompletedAtAsString: string; virtual; abstract;
  public
    property CreatedAtAsString: string read GetCreatedAtAsString;
    property ExpiredAtAsString: string read GetExpiredAtAsString;
    property CancelledAtAsString: string read GetCancelledAtAsString;
    property FailedAtAsString: string read GetFailedAtAsString;
    property CompletedAtAsString: string read GetCompletedAtAsString;
  end;

  /// <summary>
  /// Represents a specific step within an execution run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class contains details about the run step, such as its type, status, associated assistant,
  /// and any outputs or errors generated during the step.
  /// </remarks>
  TRunStep = class(TRunStepTimestamp)
  private
    FId: string;
    FObject: string;
    [JsonNameAttribute('created_at')]
    FCreatedAt: TInt64OrNull;
    [JsonNameAttribute('assistant_id')]
    FAssistantId: string;
    [JsonNameAttribute('thread_id')]
    FThreadId: string;
    [JsonNameAttribute('run_id')]
    FRunId: string;
    [JsonReflectAttribute(ctString, rtString, TRunStepTypeInterceptor)]
    FType: TRunStepType;
    [JsonReflectAttribute(ctString, rtString, TRunStatusInterceptor)]
    FStatus: TRunStatus;
    [JsonNameAttribute('step_details')]
    FStepDetails: TRunStepDetails;
    [JsonNameAttribute('last_error')]
    FLastError: TLastError;
    [JsonNameAttribute('expired_at')]
    FExpiredAt: TInt64OrNull;
    [JsonNameAttribute('cancelled_at')]
    FCancelledAt: TInt64OrNull;
    [JsonNameAttribute('failed_at')]
    FFailedAt: TInt64OrNull;
    [JsonNameAttribute('completed_at')]
    FCompletedAt: TInt64OrNull;
    [JsonReflectAttribute(ctString, rtString, TMetadataInterceptor)]
    FMetadata: string;
    FUsage: TRunUsage;
    function GetCreatedAt: Int64;
    function GetExpiredAt: Int64;
    function GetCancelledAt: Int64;
    function GetFailedAt: Int64;
    function GetCompletedAt: Int64;
  protected
    function GetCreatedAtAsString: string; override;
    function GetExpiredAtAsString: string; override;
    function GetCancelledAtAsString: string; override;
    function GetFailedAtAsString: string; override;
    function GetCompletedAtAsString: string; override;
  public
    /// <summary>
    /// Gets or sets the unique identifier of the run step.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Gets or sets the object type, which is always "thread.run.step".
    /// </summary>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// Gets the creation timestamp of the run step.
    /// </summary>
    property CreatedAt: Int64 read GetCreatedAt;
    /// <summary>
    /// Gets or sets the ID of the assistant associated with the run step.
    /// </summary>
    property AssistantId: string read FAssistantId write FAssistantId;
    /// <summary>
    /// Gets or sets the ID of the thread to which the run step belongs.
    /// </summary>
    property ThreadId: string read FThreadId write FThreadId;
    /// <summary>
    /// Gets or sets the ID of the execution run associated with this step.
    /// </summary>
    property RunId: string read FRunId write FRunId;
    /// <summary>
    /// Gets or sets the type of the run step, such as message creation or tool calls.
    /// </summary>
    property &Type: TRunStepType read FType write FType;
    /// <summary>
    /// Gets or sets the status of the run step, which can be in progress, completed, failed, or cancelled.
    /// </summary>
    property Status: TRunStatus read FStatus write FStatus;
    /// <summary>
    /// Gets or sets detailed information about the run step, including tool calls or message creation.
    /// </summary>
    property StepDetails: TRunStepDetails read FStepDetails write FStepDetails;
    /// <summary>
    /// Gets or sets details about the last error encountered during the run step, if any.
    /// </summary>
    property LastError: TLastError read FLastError write FLastError;
    /// <summary>
    /// Gets the timestamp when the run step expired, if applicable.
    /// </summary>
    property ExpiredAt: Int64 read GetExpiredAt;
    /// <summary>
    /// Gets the timestamp when the run step was cancelled, if applicable.
    /// </summary>
    property CancelledAt: Int64 read GetCancelledAt;
    /// <summary>
    /// Gets the timestamp when the run step failed, if applicable.
    /// </summary>
    property FailedAt: Int64 read GetFailedAt;
    /// <summary>
    /// Gets the timestamp when the run step was completed, if applicable.
    /// </summary>
    property CompletedAt: Int64 read GetCompletedAt;
    /// <summary>
    /// Gets or sets any metadata associated with the run step.
    /// </summary>
    property Metadata: string read FMetadata write FMetadata;
    /// <summary>
    /// Gets or sets usage statistics related to token consumption during the run step.
    /// </summary>
    property Usage: TRunUsage read FUsage write FUsage;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a collection of run steps within an execution run in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class is a list of <c>TRunStep</c> objects, providing access to multiple steps within a run.
  /// It allows for iteration over the run steps to retrieve their details, such as outputs, statuses, or errors.
  /// </remarks>
  TRunSteps = TAdvancedList<TRunStep>;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TRunStep</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynRunStep</c> type extends the <c>TAsynParams&lt;TRunStep&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynRunStep = TAsynCallBack<TRunStep>;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TRunSteps</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynRunSteps</c> type extends the <c>TAsynParams&lt;TRunSteps&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynRunSteps = TAsynCallBack<TRunSteps>;

  /// <summary>
  /// Represents the route for managing run steps within execution runs in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class provides methods to list or retrieve details of run steps. It handles both synchronous
  /// and asynchronous requests, enabling efficient interaction with the OpenAI API for managing run steps.
  /// </remarks>
  TRunStepRoute = class(TGenAIRoute)
  protected
    procedure HeaderCustomize; override;
  public
    /// <summary>
    /// Asynchronously retrieves a list of run steps associated with an execution run.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread containing the run.</param>
    /// <param name="RunId">The ID of the run whose steps are to be listed.</param>
    /// <param name="CallBacks">Callback functions to handle the asynchronous execution.</param>
    procedure AsynList(const ThreadId: string;
      const RunId: string;
      const CallBacks: TFunc<TAsynRunSteps>); overload;
    /// <summary>
    /// Asynchronously retrieves a filtered list of run steps based on specified parameters.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread containing the run.</param>
    /// <param name="RunId">The ID of the run whose steps are to be listed.</param>
    /// <param name="ParamProc">A procedure specifying the filter parameters for the list.</param>
    /// <param name="CallBacks">Callback functions to handle the asynchronous execution.</param>
    procedure AsynList(const ThreadId: string;
      const RunId: string;
      const ParamProc: TProc<TRunStepUrlParam>;
      const CallBacks: TFunc<TAsynRunSteps>); overload;
    /// <summary>
    /// Asynchronously retrieves details of a specific run step.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread containing the run.</param>
    /// <param name="RunId">The ID of the run to which the step belongs.</param>
    /// <param name="StepId">The ID of the run step to retrieve.</param>
    /// <param name="CallBacks">Callback functions to handle the asynchronous execution.</param>
    procedure AsynRetrieve(const ThreadId: string;
      const RunId: string;
      const StepId: string;
      const CallBacks: TFunc<TAsynRunStep>); overload;
    /// <summary>
    /// Asynchronously retrieves details of a specific run step with additional options.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread containing the run.</param>
    /// <param name="RunId">The ID of the run to which the step belongs.</param>
    /// <param name="StepId">The ID of the run step to retrieve.</param>
    /// <param name="ParamProc">A procedure specifying additional options for the retrieval.</param>
    /// <param name="CallBacks">Callback functions to handle the asynchronous execution.</param>
    procedure AsynRetrieve(const ThreadId: string;
      const RunId: string;
      const StepId: string;
      const ParamProc: TProc<TRetrieveStepUrlParam>;
      const CallBacks: TFunc<TAsynRunStep>); overload;
    /// <summary>
    /// Retrieves a list of run steps associated with a specific execution run.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread containing the run.</param>
    /// <param name="RunId">The ID of the run whose steps are to be listed.</param>
    /// <returns>A list of <c>TRunStep</c> objects representing the steps within the run.</returns>
    function List(const ThreadId: string; const RunId: string): TRunSteps; overload;
    /// <summary>
    /// Retrieves a filtered list of run steps based on specified parameters.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread containing the run.</param>
    /// <param name="RunId">The ID of the run whose steps are to be listed.</param>
    /// <param name="ParamProc">A procedure specifying the filter parameters for the list.</param>
    /// <returns>A list of <c>TRunStep</c> objects representing the filtered steps.</returns>
    function List(const ThreadId: string; const RunId: string;
      const ParamProc: TProc<TRunStepUrlParam>): TRunSteps; overload;
    /// <summary>
    /// Retrieves details of a specific run step within an execution run.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread containing the run.</param>
    /// <param name="RunId">The ID of the run to which the step belongs.</param>
    /// <param name="StepId">The ID of the run step to retrieve.</param>
    /// <returns>A <c>TRunStep</c> object containing the details of the specified run step.</returns>
    function Retrieve(const ThreadId: string; const RunId: string;
      const StepId: string): TRunStep; overload;
    /// <summary>
    /// Retrieves details of a specific run step with additional options.
    /// </summary>
    /// <param name="ThreadId">The ID of the thread containing the run.</param>
    /// <param name="RunId">The ID of the run to which the step belongs.</param>
    /// <param name="StepId">The ID of the run step to retrieve.</param>
    /// <param name="ParamProc">A procedure specifying additional options for the retrieval.</param>
    /// <returns>A <c>TRunStep</c> object containing the details of the specified run step.</returns>
    function Retrieve(const ThreadId: string; const RunId: string;
      const StepId: string; const ParamProc: TProc<TRetrieveStepUrlParam>): TRunStep; overload;
  end;

implementation

{ TRetrieveStepUrlParam }

function TRetrieveStepUrlParam.Include(
  const Value: TArray<string>): TRetrieveStepUrlParam;
begin
  Result := TRetrieveStepUrlParam(Add('include', Value));
end;

{ TRunStepUrlParam }

function TRunStepUrlParam.Include(
  const Value: TArray<string>): TRunStepUrlParam;
begin
  Result := TRunStepUrlParam(Add('include', Value));
end;

{ TRunStep }

destructor TRunStep.Destroy;
begin
  if Assigned(FStepDetails) then
    FStepDetails.Free;
  if Assigned(FLastError) then
    FLastError.Free;
  if Assigned(FUsage) then
    FUsage.Free;
  inherited;
end;

function TRunStep.GetCancelledAt: Int64;
begin
  Result := TInt64OrNull(FCancelledAt).ToInteger;
end;

function TRunStep.GetCancelledAtAsString: string;
begin
  Result := TInt64OrNull(FCancelledAt).ToUtcDateString;
end;

function TRunStep.GetCompletedAt: Int64;
begin
  Result := TInt64OrNull(CompletedAt).ToInteger;
end;

function TRunStep.GetCompletedAtAsString: string;
begin
  Result := TInt64OrNull(FCompletedAt).ToUtcDateString;
end;

function TRunStep.GetCreatedAt: Int64;
begin
  Result := TInt64OrNull(FCreatedAt).ToInteger;
end;

function TRunStep.GetCreatedAtAsString: string;
begin
  Result := TInt64OrNull(FCreatedAt).ToUtcDateString;
end;

function TRunStep.GetExpiredAt: Int64;
begin
  Result := TInt64OrNull(FExpiredAt).ToInteger;
end;

function TRunStep.GetExpiredAtAsString: string;
begin
  Result := TInt64OrNull(FExpiredAt).ToUtcDateString;
end;

function TRunStep.GetFailedAt: Int64;
begin
  Result := TInt64OrNull(FFailedAt).ToInteger;
end;

function TRunStep.GetFailedAtAsString: string;
begin
  Result := TInt64OrNull(FFailedAt).ToUtcDateString;
end;

{ TRunStepDetails }

destructor TRunStepDetails.Destroy;
begin
  if Assigned(FMessageCreation) then
    FMessageCreation.Free;
  for var Item in FToolCalls do
    Item.Free;
  inherited;
end;

{ TRunStepToolCalls }

destructor TRunStepToolCalls.Destroy;
begin
  if Assigned(FCodeInterpreter) then
    FCodeInterpreter.Free;
  if Assigned(FFileSearch) then
    FFileSearch.Free;
  if Assigned(FFunction) then
    FFunction.Free;
  inherited;
end;

{ TRunStepCodeInterpreter }

destructor TRunStepCodeInterpreter.Destroy;
begin
  for var Item in FOutputs do
    Item.Free;
  inherited;
end;

{ TCodeInterpreterOutput }

destructor TCodeInterpreterOutput.Destroy;
begin
  if Assigned(FImage) then
    FImage.Free;
  inherited;
end;

{ TRunStepFileSearch }

destructor TRunStepFileSearch.Destroy;
begin
  if Assigned(FRankingOptions) then
    FRankingOptions.Free;
  for var Item in FResults do
    Item.Free;
  inherited;
end;

{ TRunFileSearchResult }

destructor TRunFileSearchResult.Destroy;
begin
  for var Item in FContent do
    Item.Free;
  inherited;
end;

{ TRunStepRoute }

procedure TRunStepRoute.AsynList(const ThreadId, RunId: string;
  const CallBacks: TFunc<TAsynRunSteps>);
begin
  with TAsynCallBackExec<TAsynRunSteps, TRunSteps>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TRunSteps
      begin
        Result := Self.List(ThreadId, RunId);
      end);
  finally
    Free;
  end;
end;

procedure TRunStepRoute.AsynList(const ThreadId, RunId: string;
  const ParamProc: TProc<TRunStepUrlParam>;
  const CallBacks: TFunc<TAsynRunSteps>);
begin
  with TAsynCallBackExec<TAsynRunSteps, TRunSteps>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TRunSteps
      begin
        Result := Self.List(ThreadId, RunId, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TRunStepRoute.AsynRetrieve(const ThreadId, RunId, StepId: string;
  const ParamProc: TProc<TRetrieveStepUrlParam>;
  const CallBacks: TFunc<TAsynRunStep>);
begin
  with TAsynCallBackExec<TAsynRunStep, TRunStep>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TRunStep
      begin
        Result := Self.Retrieve(ThreadId, RunId, StepId, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TRunStepRoute.AsynRetrieve(const ThreadId, RunId, StepId: string;
  const CallBacks: TFunc<TAsynRunStep>);
begin
  with TAsynCallBackExec<TAsynRunStep, TRunStep>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TRunStep
      begin
        Result := Self.Retrieve(ThreadId, RunId, StepId);
      end);
  finally
    Free;
  end;
end;

procedure TRunStepRoute.HeaderCustomize;
begin
  inherited;
  API.CustomHeaders := [TNetHeader.Create('OpenAI-Beta', 'assistants=v2')];
end;

function TRunStepRoute.List(const ThreadId, RunId: string;
  const ParamProc: TProc<TRunStepUrlParam>): TRunSteps;
begin
  HeaderCustomize;
  Result := API.Get<TRunSteps, TRunStepUrlParam>('threads/' + ThreadId + '/runs/' + RunId + '/steps', ParamProc);
end;

function TRunStepRoute.List(const ThreadId, RunId: string): TRunSteps;
begin
  HeaderCustomize;
  Result := API.Get<TRunSteps>('threads/' + ThreadId + '/runs/' + RunId + '/steps');
end;

function TRunStepRoute.Retrieve(const ThreadId, RunId,
  StepId: string): TRunStep;
begin
  HeaderCustomize;
  Result := API.Get<TRunStep>('threads/' + ThreadId + '/runs/' + RunId + '/steps/' + StepId);
end;

function TRunStepRoute.Retrieve(const ThreadId, RunId, StepId: string;
  const ParamProc: TProc<TRetrieveStepUrlParam>): TRunStep;
begin
  HeaderCustomize;
  Result := API.Get<TRunStep, TRetrieveStepUrlParam>('threads/' + ThreadId + '/runs/' + RunId + '/steps/' + StepId, ParamProc);
end;

end.

unit GenAI.Schema;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, REST.Json.Types,
  GenAI.API.Params, GenAI.Types;

type
  TSchemaParams = class;

  /// <summary>
  /// Provides helper methods for creating property items in OpenAPI schema definitions.
  /// </summary>
  /// <remarks>
  /// This record simplifies the creation of property entries when building schema objects,
  /// particularly for object properties in OpenAPI specifications.
  /// </remarks>
  TPropertyItem = record
  public
    /// <summary>
    /// Creates a JSON pair representing a property in a schema object.
    /// </summary>
    /// <param name="Key">The name of the property.</param>
    /// <param name="Value">The data type of the property as a <c>TSchemaType</c>.</param>
    /// <returns>A <c>TJSONPair</c> representing the property key-value pair.</returns>
    /// <remarks>
    /// This method facilitates the addition of properties to schema objects by creating
    /// a JSON pair with the specified key and data type.
    /// </remarks>
    class function Add(Key: string; Value: TSchemaType): TJSONPair; static;
  end;

  /// <summary>
  /// Represents the Schema Object in OpenAPI, enabling the definition of input and output data types.
  /// These types can be objects, primitives, or arrays. This class provides methods to build and
  /// configure schema definitions as per the OpenAPI 3.0 Specification.
  /// </summary>
  /// <remarks>
  /// The Schema Object allows the definition of input and output data types in the OpenAPI Specification.
  /// This class provides a fluent interface to construct schema definitions programmatically.
  /// </remarks>
  TSchemaParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the data type of the schema.
    /// </summary>
    /// <param name="Value">The data type to assign to the schema, specified as a <c>TSchemaType</c> value.</param>
    /// <returns>The current <c>TSchemaParams</c> instance to allow for method chaining.</returns>
    /// <remarks>
    /// The <c>type</c> keyword is required in the Schema Object to define the data type.
    /// Valid types include <c>string</c>, <c>number</c>, <c>integer</c>, <c>boolean</c>, <c>array</c>, and <c>object</c>.
    /// </remarks>
    function &Type(const Value: TSchemaType): TSchemaParams;
    /// <summary>
    /// Specifies the format of the data type.
    /// </summary>
    /// <param name="Value">The format of the data type, as a string.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>format</c> keyword is an optional modifier to provide more fine-grained data type information.
    /// Common formats include <c>int32</c>, <c>int64</c> for <c>integer</c> types; <c>float</c>, <c>double</c>
    /// for <c>number</c> types; and <c>byte</c>, <c>binary</c>, <c>date</c>, <c>date-time</c>, <c>password</c> for <c>string</c> types.
    /// </remarks>
    function Format(const Value: string): TSchemaParams;
    /// <summary>
    /// Adds a description to the schema.
    /// </summary>
    /// <param name="Value">A brief description of the schema. Supports Markdown for formatting.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>description</c> keyword provides a description of the schema and can include examples of use.
    /// This field supports Markdown syntax for rich text representation.
    /// </remarks>
    function Description(const Value: string): TSchemaParams;
    /// <summary>
    /// Specifies whether the schema's value can be null.
    /// </summary>
    /// <param name="Value">A boolean indicating if the schema allows null values.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>nullable</c> keyword is a boolean property that indicates if the value of the schema can be null.
    /// By default, this is false.
    /// </remarks>
    function Nullable(const Value: Boolean): TSchemaParams;
    /// <summary>
    /// Specifies an enumeration of possible values.
    /// </summary>
    /// <param name="Value">An array of string values that the schema can take.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>enum</c> keyword restricts the value of the schema to a fixed set of values.
    /// The schema's type must be <c>string</c> when using enum.
    /// </remarks>
    function Enum(const Value: TArray<string>): TSchemaParams;
    /// <summary>
    /// Specifies the maximum number of items allowed in an array schema.
    /// </summary>
    /// <param name="Value">The maximum number of items as a string.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>maxItems</c> keyword applies to schemas of type <c>array</c> and restricts the maximum number
    /// of items the array can contain.
    /// </remarks>
    function MaxItems(const Value: string): TSchemaParams;
    /// <summary>
    /// Specifies the minimum number of items required in an array schema.
    /// </summary>
    /// <param name="Value">The minimum number of items as a string.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>minItems</c> keyword applies to schemas of type <c>array</c> and defines the minimum number
    /// of items the array must contain.
    /// </remarks>
    function MinItems(const Value: string): TSchemaParams;
    /// <summary>
    /// Adds a property to an object schema.
    /// </summary>
    /// <param name="Key">The name of the property.</param>
    /// <param name="Value">A <c>TSchemaParams</c> instance defining the property's schema.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>properties</c> keyword is used to define the properties of an object schema.
    /// Each property is a key-value pair where the key is the property name and the value is a schema defining the property.
    /// </remarks>
    function Properties(const Key: string; const Value: TSchemaParams): TSchemaParams; overload;
    /// <summary>
    /// Adds a property to an object schema using a parameterized procedure to configure the property's schema.
    /// </summary>
    /// <param name="Key">The name of the property.</param>
    /// <param name="ParamProc">A procedure that takes a <c>TSchemaParams</c> instance to configure the property's schema.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// This overload allows you to define the property's schema inline using a procedural configuration.
    /// </remarks>
    function Properties(const Key: string; const ParamProc: TProcRef<TSchemaParams>): TSchemaParams; overload;
    /// <summary>
    /// Adds multiple properties to an object schema.
    /// </summary>
    /// <param name="Value">An array of <c>TJSONPair</c> instances representing the properties.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// This overload allows adding multiple properties at once to the object schema.
    /// </remarks>
    function Properties(const Value: TArray<TJSONPair>): TSchemaParams; overload;
    /// <summary>
    /// Specifies which properties are required in an object schema.
    /// </summary>
    /// <param name="Value">An array of property names that are required.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>required</c> keyword lists the property names that must be included when an object instance
    /// is validated against the schema.
    /// </remarks>
    function Required(const Value: TArray<string>): TSchemaParams;
    /// <summary>
    /// Specifies the schema of the items in an array schema.
    /// </summary>
    /// <param name="Value">A <c>TSchemaParams</c> instance defining the schema of the array items.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>items</c> keyword is used in array schemas to define the schema of each item in the array.
    /// </remarks>
    function Items(const Value: TSchemaParams): TSchemaParams; overload;
    /// <summary>
    /// Specifies the schema of the items in an array schema using a parameterized procedure.
    /// </summary>
    /// <param name="ParamProc">A procedure that configures a <c>TSchemaParams</c> instance to define the array items' schema.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// This overload allows you to define the items' schema inline using a procedural configuration.
    /// </remarks>
    function Items(const ParamProc: TProcRef<TSchemaParams>): TSchemaParams; overload;
    /// <summary>
    /// Creates a new instance of <c>TSchemaParams</c>.
    /// </summary>
    /// <returns>A new <c>TSchemaParams</c> instance.</returns>
    class function New: TSchemaParams; overload;
    /// <summary>
    /// Creates and configures a new instance of <c>TSchemaParams</c> using a parameterized procedure.
    /// </summary>
    /// <param name="ParamProc">A procedure that configures the new <c>TSchemaParams</c> instance.</param>
    /// <returns>A new <c>TSchemaParams</c> instance.</returns>
    /// <remarks>
    /// This overload allows you to create and configure the instance inline.
    /// </remarks>
    class function New(const ParamProc: TProcRef<TSchemaParams>): TSchemaParams; overload;
  end;

implementation

uses
  System.StrUtils, System.Rtti, Rest.Json;

{ TSchemaParams }

function TSchemaParams.Description(const Value: string): TSchemaParams;
begin
  Result := TSchemaParams(Add('description', Value));
end;

function TSchemaParams.Enum(const Value: TArray<string>): TSchemaParams;
begin
  Result := TSchemaParams(Add('enum', Value));
end;

function TSchemaParams.Format(const Value: string): TSchemaParams;
begin
  Result := TSchemaParams(Add('format', Value));
end;

function TSchemaParams.Items(
  const ParamProc: TProcRef<TSchemaParams>): TSchemaParams;
begin
  if Assigned(ParamProc) then
    begin
      var Value := TSchemaParams.Create;
      ParamProc(Value);
      Result := Items(Value);
    end
  else Result := Self;
end;

function TSchemaParams.Items(const Value: TSchemaParams): TSchemaParams;
begin
  Result := TSchemaParams(Add('items', Value.Detach));
end;

function TSchemaParams.MaxItems(const Value: string): TSchemaParams;
begin
  Result := TSchemaParams(Add('maxItems', Value));
end;

function TSchemaParams.MinItems(const Value: string): TSchemaParams;
begin
  Result := TSchemaParams(Add('minItems', Value));
end;

class function TSchemaParams.New: TSchemaParams;
begin
  Result := TSchemaParams.Create;
end;

class function TSchemaParams.New(
  const ParamProc: TProcRef<TSchemaParams>): TSchemaParams;
begin
  Result := TSchemaParams.Create;
  if Assigned(ParamProc) then
    begin
      ParamProc(Result);
    end
end;

function TSchemaParams.Nullable(const Value: Boolean): TSchemaParams;
begin
  Result := TSchemaParams(Add('nullable', Value.ToString));
end;

function TSchemaParams.Properties(
  const Value: TArray<TJSONPair>): TSchemaParams;
begin
  var JSONValue := TJSONObject.Create;
  for var Item in Value do
    begin
      JSONValue.AddPair(Item);
    end;
  Result := TSchemaParams(Add('properties', JSONValue));
end;

function TSchemaParams.Properties(const Key: string;
  const ParamProc: TProcRef<TSchemaParams>): TSchemaParams;
begin
  if Assigned(ParamProc) then
    begin
      var Value := TSchemaParams.Create;
      ParamProc(Value);
      Result := Properties(Key, Value);
    end
  else Result := Self;
end;

function TSchemaParams.Properties(const Key: string;
  const Value: TSchemaParams): TSchemaParams;
begin
  Result := TSchemaParams(Add(Key, Value.Detach));
end;

function TSchemaParams.Required(const Value: TArray<string>): TSchemaParams;
begin
  Result := TSchemaParams(Add('required', Value));
end;

function TSchemaParams.&Type(const Value: TSchemaType): TSchemaParams;
begin
  Result := TSchemaParams(Add('type', Value.ToString));
end;

{ TPropertyItem }

class function TPropertyItem.Add(Key: string; Value: TSchemaType): TJSONPair;
begin
  Result := TJSONPair.Create(Key, Value.ToString);
end;

end.

unit GenAI.Threads;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Threading, System.JSON, REST.Json.Types,
  REST.JsonReflect, System.Net.URLClient,
  GenAI.API.Params, GenAI.API, GenAI.Consts, GenAI.Types, GenAI.Async.Support,
  GenAI.API.Deletion, GenAI.Assistants;

type
  /// <summary>
  /// Represents parameters for specifying image files in OpenAI threads.
  /// This class is used to define image-related details such as the file ID and image detail level.
  /// </summary>
  TThreadsImageFileParams = class(TJSONparam)
  public
    /// <summary>
    /// Sets the file ID of the image to be used in the thread.
    /// </summary>
    /// <param name="Value">
    /// The unique file ID referencing the image within the thread.
    /// </param>
    /// <returns>
    /// The updated <c>TThreadsImageFileParams</c> object with the specified file ID.
    /// </returns>
    function FileId(const Value: string): TThreadsImageFileParams;
    /// <summary>
    /// Sets the detail level for the specified image.
    /// </summary>
    /// <param name="Value">
    /// The desired image detail level, which can be low, high, or auto.
    /// </param>
    /// <returns>
    /// The updated <c>TThreadsImageFileParams</c> object with the specified detail level.
    /// </returns>
    function Detail(const Value: TImageDetail): TThreadsImageFileParams;
  end;

  /// <summary>
  /// Represents parameters for specifying image URLs in OpenAI threads.
  /// This class is used to define URL-related details such as the image URL and its detail level.
  /// </summary>
  TThreadsImageUrlParams = class(TJSONparam)
  public
    /// <summary>
    /// Sets the external URL of the image to be used in the thread.
    /// </summary>
    /// <param name="Value">
    /// The URL pointing to the image resource. The URL must reference a supported image format such as JPEG, PNG, GIF, or WebP.
    /// </param>
    /// <returns>
    /// The updated <c>TThreadsImageUrlParams</c> object with the specified image URL.
    /// </returns>
    function Url(const Value: string): TThreadsImageUrlParams;
    /// <summary>
    /// Sets the detail level for the specified image URL.
    /// </summary>
    /// <param name="Value">
    /// The desired image detail level, which can be low, high, or auto.
    /// </param>
    /// <returns>
    /// The updated <c>TThreadsImageUrlParams</c> object with the specified detail level.
    /// </returns>
    function Detail(const Value: TImageDetail): TThreadsImageUrlParams;
  end;

  /// <summary>
  /// Represents the parameters used to define the content of messages in OpenAI threads.
  /// This can include text content, image files, or image URLs.
  /// </summary>
  TThreadsContentParams = class(TJSONparam)
  public
    /// <summary>
    /// Sets the type of content for the message.
    /// </summary>
    /// <param name="Value">
    /// The type of the content, such as "text" or "image".
    /// </param>
    /// <returns>
    /// The updated <c>TThreadsContentParams</c> object with the specified content type.
    /// </returns>
    function &Type(const Value: string): TThreadsContentParams; overload;
    /// <summary>
    /// Sets the type of content for the message using an enumerated type.
    /// </summary>
    /// <param name="Value">
    /// The content type as an enumeration, such as <c>TThreadsContentType.text</c> or <c>TThreadsContentType.image_file</c>.
    /// </param>
    /// <returns>
    /// The updated <c>TThreadsContentParams</c> object with the specified content type.
    /// </returns>
    function &Type(const Value: TThreadsContentType): TThreadsContentParams; overload;
    /// <summary>
    /// Specifies an image file to be included as part of the message content.
    /// </summary>
    /// <param name="Value">
    /// The image file parameters, including the file ID and detail level.
    /// </param>
    /// <returns>
    /// The updated <c>TThreadsContentParams</c> object with the specified image file.
    /// </returns>
    function ImageFile(const Value: TThreadsImageFileParams): TThreadsContentParams;
    /// <summary>
    /// Specifies an image URL to be included as part of the message content.
    /// </summary>
    /// <param name="Value">
    /// The image URL parameters, including the URL and detail level.
    /// </param>
    /// <returns>
    /// The updated <c>TThreadsContentParams</c> object with the specified image URL.
    /// </returns>
    function ImageUrl(const Value: TThreadsImageUrlParams): TThreadsContentParams;
    /// <summary>
    /// Sets the text content for the message.
    /// </summary>
    /// <param name="Value">
    /// The text to be included in the message content.
    /// </param>
    /// <returns>
    /// The updated <c>TThreadsContentParams</c> object with the specified text content.
    /// </returns>
    function Text(const Value: string): TThreadsContentParams;
  end;

  /// <summary>
  /// Represents attachments that can be included in messages in OpenAI threads.
  /// Attachments can be files with specific tools applied, such as a code interpreter or file search.
  /// </summary>
  TThreadsAttachment = class(TJSONparam)
    /// <summary>
    /// Sets the file ID of the attachment to be included in the message.
    /// </summary>
    /// <param name="Value">
    /// The unique file ID referencing the attachment within the thread.
    /// </param>
    /// <returns>
    /// The updated <c>TThreadsAttachment</c> object with the specified file ID.
    /// </returns>
    function FileId(const Value: string): TThreadsAttachment;
    /// <summary>
    /// Specifies the tool to associate with the attachment, such as a code interpreter or file search.
    /// </summary>
    /// <param name="Value">
    /// The tool type as an enumerated value, either <c>code_interpreter</c> or <c>file_search</c>.
    /// </param>
    /// <returns>
    /// The updated <c>TThreadsAttachment</c> object with the specified tool.
    /// </returns>
    function Tool(const Value: TAssistantsToolsType): TThreadsAttachment; overload;
    /// <summary>
    /// Specifies the tool to associate with the attachment using a string representation.
    /// </summary>
    /// <param name="Value">
    /// The tool type as a string, such as "code_interpreter" or "file_search".
    /// </param>
    /// <returns>
    /// The updated <c>TThreadsAttachment</c> object with the specified tool.
    /// </returns>
    function Tool(const Value: string): TThreadsAttachment; overload;
  end;

  /// <summary>
  /// Represents the parameters used to define a message in OpenAI threads.
  /// A message contains details such as its role, content, attachments, and metadata.
  /// </summary>
  TThreadsMessageParams = class(TJSONparam)
  public
    /// <summary>
    /// Sets the role of the message sender.
    /// </summary>
    /// <param name="Value">
    /// The role as a string, such as "user" or "assistant".
    /// </param>
    /// <returns>
    /// The updated <c>TThreadsMessageParams</c> object with the specified role.
    /// </returns>
    function Role(const Value: string): TThreadsMessageParams; overload;
    /// <summary>
    /// Sets the role of the message sender using an enumerated value.
    /// </summary>
    /// <param name="Value">
    /// The role as an enumerated value, such as <c>TRole.user</c> or <c>TRole.assistant</c>.
    /// </param>
    /// <returns>
    /// The updated <c>TThreadsMessageParams</c> object with the specified role.
    /// </returns>
    function Role(const Value: TRole): TThreadsMessageParams; overload;
    /// <summary>
    /// Sets the content of the message as a text string.
    /// </summary>
    /// <param name="Value">
    /// The text content to include in the message.
    /// </param>
    /// <returns>
    /// The updated <c>TThreadsMessageParams</c> object with the specified text content.
    /// </returns>
    function Content(const Value: string): TThreadsMessageParams; overload;
    /// <summary>
    /// Sets the content of the message using an array of content parameters.
    /// This can be used for messages containing multiple content types such as text and images.
    /// </summary>
    /// <param name="Value">
    /// An array of content parameters specifying the details of each content part.
    /// </param>
    /// <returns>
    /// The updated <c>TThreadsMessageParams</c> object with the specified content array.
    /// </returns>
    function Content(const Value: TArray<TThreadsContentParams>): TThreadsMessageParams; overload;
    /// <summary>
    /// Adds attachments to the message.
    /// </summary>
    /// <param name="Value">
    /// An array of attachments to include in the message. Each attachment can specify a file and a tool to apply to it.
    /// </param>
    /// <returns>
    /// The updated <c>TThreadsMessageParams</c> object with the specified attachments.
    /// </returns>
    function Attachments(const Value: TArray<TThreadsAttachment>): TThreadsMessageParams;
    /// <summary>
    /// Sets metadata for the message as a JSON object.
    /// Metadata can be used to store additional structured information about the message.
    /// </summary>
    /// <param name="Value">
    /// A JSON object containing key-value pairs of metadata.
    /// </param>
    /// <returns>
    /// The updated <c>TThreadsMessageParams</c> object with the specified metadata.
    /// </returns>
    function Metadata(const Value: TJSONObject): TThreadsMessageParams;
  end;

  /// <summary>
  /// Represents the parameters for creating a new thread in OpenAI threads.
  /// This includes defining initial messages, tool resources, and metadata.
  /// </summary>
  TThreadsCreateParams = class(TJSONparam)
  public
    /// <summary>
    /// Sets the initial message for the thread using a string.
    /// </summary>
    /// <param name="Value">
    /// The message content as a string, typically sent by the user to start the thread.
    /// </param>
    /// <returns>
    /// The updated <c>TThreadsCreateParams</c> object with the specified message.
    /// </returns>
    function Messages(const Value: string): TThreadsCreateParams; overload;
    /// <summary>
    /// Sets the initial messages for the thread using an array of message parameters.
    /// </summary>
    /// <param name="Value">
    /// An array of message parameters representing the initial conversation context.
    /// </param>
    /// <returns>
    /// The updated <c>TThreadsCreateParams</c> object with the specified messages.
    /// </returns>
    function Messages(const Value: TArray<TThreadsMessageParams>): TThreadsCreateParams; overload;
    /// <summary>
    /// Associates tool resources with the thread, such as files for the code interpreter or vector stores.
    /// </summary>
    /// <param name="Value">
    /// A set of tool resources, such as file IDs or vector store IDs, that can be used by the assistant tools.
    /// </param>
    /// <returns>
    /// The updated <c>TThreadsCreateParams</c> object with the specified tool resources.
    /// </returns>
    function ToolResources(const Value: TToolResourcesParams): TAssistantsParams;
    /// <summary>
    /// Attaches metadata to the thread as a JSON object.
    /// Metadata can store additional structured information related to the thread creation.
    /// </summary>
    /// <param name="Value">
    /// A JSON object containing key-value pairs of metadata.
    /// </param>
    /// <returns>
    /// The updated <c>TThreadsCreateParams</c> object with the specified metadata.
    /// </returns>
    function Metadata(const Value: TJSONObject): TThreadsCreateParams;
  end;

  /// <summary>
  /// Represents the parameters used to modify an existing thread in OpenAI threads.
  /// This includes updating tool resources and metadata.
  /// </summary>
  TThreadsModifyParams = class(TJSONparam)
  public
    /// <summary>
    /// Updates the tool resources associated with the thread.
    /// This can include files for the code interpreter or vector store configurations.
    /// </summary>
    /// <param name="Value">
    /// A set of tool resources, such as file IDs or vector store IDs, that can be used by the assistant tools.
    /// </param>
    /// <returns>
    /// The updated <c>TThreadsModifyParams</c> object with the specified tool resources.
    /// </returns>
    function ToolResources(const Value: TToolResourcesParams): TThreadsModifyParams;
    /// <summary>
    /// Updates the metadata associated with the thread as a JSON object.
    /// Metadata can be used to store additional structured information about the thread.
    /// </summary>
    /// <param name="Value">
    /// A JSON object containing key-value pairs of metadata.
    /// </param>
    /// <returns>
    /// The updated <c>TThreadsModifyParams</c> object with the specified metadata.
    /// </returns>
    function Metadata(const Value: TJSONObject): TThreadsModifyParams;
  end;

  /// <summary>
  /// Represents a thread object in OpenAI threads.
  /// A thread contains messages, tool resources, metadata, and other properties related to its creation and management.
  /// </summary>
  TThreads = class(TJSONFingerprint)
  private
    FId: string;
    [JsonNameAttribute('created_at')]
    FCreatedAt: TInt64OrNull;
    FObject: string;
    [JsonNameAttribute('tool_resources')]
    FToolResources: TToolResources;
    [JsonReflectAttribute(ctString, rtString, TMetadataInterceptor)]
    FMetadata: string;
  private
    function GetCreatedAtAsString: string;
    function GetCreatedAt: Int64;
  public
    /// <summary>
    /// Gets or sets the unique identifier of the thread.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Gets or sets the unique identifier of the thread.
    /// </summary>
    property CreatedAt: Int64 read GetCreatedAt;
    /// <summary>
    /// Gets the formatted creation time as a human-readable string.
    /// </summary>
    property CreatedAtAsString: string read GetCreatedAtAsString;
    /// <summary>
    /// Gets or sets the Unix timestamp (in seconds) for when the thread was created.
    /// </summary>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// Gets or sets the tool resources associated with the thread.
    /// This includes files for the code interpreter or vector store configurations.
    /// </summary>
    property ToolResources: TToolResources read FToolResources write FToolResources;
    /// <summary>
    /// Gets or sets the metadata containing additional structured information about the thread.
    /// </summary>
    property Metadata: string read FMetadata write FMetadata;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TThreads</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynThreads</c> type extends the <c>TAsynParams&lt;TThreads&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynThreads = TAsynCallBack<TThreads>;

  /// <summary>
  /// Provides an interface for interacting with OpenAI threads via API routes.
  /// This class supports both synchronous and asynchronous operations, including creating, retrieving, modifying, and deleting threads.
  /// </summary>
  /// <remarks>
  /// <para>
  /// The class encapsulates API requests and manages the associated headers, routes, and callbacks required
  /// for interacting with the OpenAI API. Developers can use it to perform thread-related tasks while leveraging
  /// both synchronous and non-blocking (asynchronous) execution flows.
  /// </para>
  /// <para>
  /// The tool resources associated with threads, such as files and vector stores, can be specified to enhance
  /// assistant capabilities like code execution or vector-based searches. Metadata can also be attached
  /// to threads for storing structured information.
  /// </para>
  /// </remarks>
  TThreadsRoute = class(TGenAIRoute)
  protected
    /// <summary>
    /// Customizes the API headers specific to thread management operations.
    /// Adds the "OpenAI-Beta" header for proper API versioning.
    /// </summary>
    procedure HeaderCustomize; override;
  public
    /// <summary>
    /// Asynchronously creates a new thread using the specified parameters and callback functions.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the thread creation parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A set of callback functions to handle the asynchronous response.
    /// </param>
    procedure AsynCreate(const ParamProc: TProc<TThreadsCreateParams>; const CallBacks: TFunc<TAsynThreads>); overload;
    /// <summary>
    /// Asynchronously creates a new thread using the default parameters and callback functions.
    /// </summary>
    /// <param name="CallBacks">
    /// A set of callback functions to handle the asynchronous response.
    /// </param>
    procedure AsynCreate(const CallBacks: TFunc<TAsynThreads>); overload;
    /// <summary>
    /// Asynchronously retrieves a thread by its ID.
    /// </summary>
    /// <param name="ThreadId">
    /// The unique identifier of the thread to retrieve.
    /// </param>
    /// <param name="CallBacks">
    /// A set of callback functions to handle the asynchronous response.
    /// </param>
    procedure AsynRetrieve(const ThreadId: string; const CallBacks: TFunc<TAsynThreads>);
    /// <summary>
    /// Asynchronously modifies an existing thread using the specified parameters and callback functions.
    /// </summary>
    /// <param name="ThreadId">
    /// The unique identifier of the thread to modify.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure the thread modification parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A set of callback functions to handle the asynchronous response.
    /// </param>
    procedure AsynModify(const ThreadId: string; const ParamProc: TProc<TThreadsModifyParams>;
      const CallBacks: TFunc<TAsynThreads>);
    /// <summary>
    /// Asynchronously deletes a thread by its ID.
    /// </summary>
    /// <param name="ThreadId">
    /// The unique identifier of the thread to delete.
    /// </param>
    /// <param name="CallBacks">
    /// A set of callback functions to handle the asynchronous response.
    /// </param>
    procedure AsynDelete(const ThreadId: string; const CallBacks: TFunc<TAsynDeletion>);
    /// <summary>
    /// Synchronously creates a new thread using the specified parameters.
    /// </summary>
    /// <param name="ParamProc">
    /// An optional procedure to configure the thread creation parameters.
    /// </param>
    /// <returns>
    /// The created thread object.
    /// </returns>
    function Create(const ParamProc: TProc<TThreadsCreateParams> = nil): TThreads;
    /// <summary>
    /// Synchronously retrieves a thread by its ID.
    /// </summary>
    /// <param name="ThreadId">
    /// The unique identifier of the thread to retrieve.
    /// </param>
    /// <returns>
    /// The retrieved thread object.
    /// </returns>
    function Retrieve(const ThreadId: string): TThreads;
    /// <summary>
    /// Synchronously modifies an existing thread using the specified parameters.
    /// </summary>
    /// <param name="ThreadId">
    /// The unique identifier of the thread to modify.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure the thread modification parameters.
    /// </param>
    /// <returns>
    /// The modified thread object.
    /// </returns>
    function Modify(const ThreadId: string; const ParamProc: TProc<TThreadsModifyParams>): TThreads;
    /// <summary>
    /// Synchronously deletes a thread by its ID.
    /// </summary>
    /// <param name="ThreadId">
    /// The unique identifier of the thread to delete.
    /// </param>
    /// <returns>
    /// The deletion status of the thread.
    /// </returns>
    function Delete(const ThreadId: string): TDeletion;
  end;

implementation

{ TThreadsMessageParams }

function TThreadsMessageParams.Attachments(
  const Value: TArray<TThreadsAttachment>): TThreadsMessageParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
    Result := TThreadsMessageParams(Add('attachments', JSONArray));
end;

function TThreadsMessageParams.Content(
  const Value: TArray<TThreadsContentParams>): TThreadsMessageParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TThreadsMessageParams(Add('content', JSONArray));
end;

function TThreadsMessageParams.Content(
  const Value: string): TThreadsMessageParams;
begin
  Result := TThreadsMessageParams(Add('content', Value));
end;

function TThreadsMessageParams.Metadata(
  const Value: TJSONObject): TThreadsMessageParams;
begin
  Result := TThreadsMessageParams(Add('metadata', Value));
end;

function TThreadsMessageParams.Role(
  const Value: string): TThreadsMessageParams;
begin
  Result := TThreadsMessageParams(Add('role', TRole.Create(Value).ToString));
end;

function TThreadsMessageParams.Role(
  const Value: TRole): TThreadsMessageParams;
begin
  Result := TThreadsMessageParams(Add('role', Value.ToString));
end;

{ TThreadsContentParams }

function TThreadsContentParams.ImageFile(
  const Value: TThreadsImageFileParams): TThreadsContentParams;
begin
  Result := TThreadsContentParams(Add('image_file', Value.Detach));
end;

function TThreadsContentParams.ImageUrl(
  const Value: TThreadsImageUrlParams): TThreadsContentParams;
begin
  Result := TThreadsContentParams(Add('image_url', Value.Detach));
end;

function TThreadsContentParams.Text(const Value: string): TThreadsContentParams;
begin
  Result := TThreadsContentParams(Add('text', Value));
end;

function TThreadsContentParams.&Type(
  const Value: string): TThreadsContentParams;
begin
  Result := TThreadsContentParams(Add('type', TThreadsContentType.Create(Value).ToString));
end;

function TThreadsContentParams.&Type(
  const Value: TThreadsContentType): TThreadsContentParams;
begin
  Result := TThreadsContentParams(Add('type', Value.ToString));
end;

{ TThreadsImageFileParams }

function TThreadsImageFileParams.Detail(
  const Value: TImageDetail): TThreadsImageFileParams;
begin
  Result := TThreadsImageFileParams(Add('detail', Value.ToString));
end;

function TThreadsImageFileParams.FileId(
  const Value: string): TThreadsImageFileParams;
begin
  Result := TThreadsImageFileParams(Add('file_id', Value));
end;

{ TThreadsImageUrlParams }

function TThreadsImageUrlParams.Detail(
  const Value: TImageDetail): TThreadsImageUrlParams;
begin
  Result := TThreadsImageUrlParams(Add('detail', Value.ToString));
end;

function TThreadsImageUrlParams.Url(
  const Value: string): TThreadsImageUrlParams;
begin
  Result := TThreadsImageUrlParams(Add('url', Value));
end;

{ TThreadsAttachment }

function TThreadsAttachment.FileId(const Value: string): TThreadsAttachment;
begin
  Result := TThreadsAttachment(Add('file_id', Value));
end;

function TThreadsAttachment.Tool(
  const Value: TAssistantsToolsType): TThreadsAttachment;
begin
  case Value of
    TAssistantsToolsType.code_interpreter,
    TAssistantsToolsType.file_search:
      Result := TThreadsAttachment(Add('tools', TJSONObject.Create.AddPair('type', Value.ToString)));
    else
      raise Exception.CreateFmt('%s: Threads attachments tools type value not managed', [Value.ToString]);
  end;
end;

function TThreadsAttachment.Tool(const Value: string): TThreadsAttachment;
begin
  Result := Tool(TAssistantsToolsType.Create(Value));
end;

{ TThreadsCreateParams }

function TThreadsCreateParams.Messages(
  const Value: string): TThreadsCreateParams;
begin
  var Msg := TThreadsMessageParams.Create.Role('user').Content([TThreadsContentParams.Create.&Type('text').Text(Value)]);
  Result := TThreadsCreateParams(Add('messages', Msg.Detach));
end;

function TThreadsCreateParams.Messages(
  const Value: TArray<TThreadsMessageParams>): TThreadsCreateParams;
begin
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);
  Result := TThreadsCreateParams(Add('messages', JSONArray));
end;

function TThreadsCreateParams.Metadata(
  const Value: TJSONObject): TThreadsCreateParams;
begin
  Result := TThreadsCreateParams(Add('metadata', Value));
end;

function TThreadsCreateParams.ToolResources(
  const Value: TToolResourcesParams): TAssistantsParams;
begin
  Result := TAssistantsParams(Add('tool_resources', Value.Detach));
end;

{ TThreadsRoute }

procedure TThreadsRoute.AsynCreate(const ParamProc: TProc<TThreadsCreateParams>;
  const CallBacks: TFunc<TAsynThreads>);
begin
  with TAsynCallBackExec<TAsynThreads, TThreads>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TThreads
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TThreadsRoute.AsynCreate(const CallBacks: TFunc<TAsynThreads>);
begin
  with TAsynCallBackExec<TAsynThreads, TThreads>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TThreads
      begin
        Result := Self.Create();
      end);
  finally
    Free;
  end;
end;

procedure TThreadsRoute.AsynDelete(const ThreadId: string;
  const CallBacks: TFunc<TAsynDeletion>);
begin
  with TAsynCallBackExec<TAsynDeletion, TDeletion>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TDeletion
      begin
        Result := Self.Delete(ThreadId);
      end);
  finally
    Free;
  end;
end;

procedure TThreadsRoute.AsynModify(const ThreadId: string;
  const ParamProc: TProc<TThreadsModifyParams>;
  const CallBacks: TFunc<TAsynThreads>);
begin
  with TAsynCallBackExec<TAsynThreads, TThreads>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TThreads
      begin
        Result := Self.Modify(ThreadId, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TThreadsRoute.AsynRetrieve(const ThreadId: string;
  const CallBacks: TFunc<TAsynThreads>);
begin
  with TAsynCallBackExec<TAsynThreads, TThreads>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TThreads
      begin
        Result := Self.Retrieve(ThreadId);
      end);
  finally
    Free;
  end;
end;

function TThreadsRoute.Create(
  const ParamProc: TProc<TThreadsCreateParams>): TThreads;
begin
  HeaderCustomize;
  Result := API.Post<TThreads, TThreadsCreateParams>('threads', ParamProc)
end;

function TThreadsRoute.Delete(const ThreadId: string): TDeletion;
begin
  HeaderCustomize;
  Result := API.Delete<TDeletion>('threads/' + ThreadId);
end;

procedure TThreadsRoute.HeaderCustomize;
begin
  inherited;
  API.CustomHeaders := [TNetHeader.Create('OpenAI-Beta', 'assistants=v2')];
end;

function TThreadsRoute.Modify(const ThreadId: string;
  const ParamProc: TProc<TThreadsModifyParams>): TThreads;
begin
  HeaderCustomize;
  Result := API.Post<TThreads, TThreadsModifyParams>('threads/' + ThreadId, ParamProc);
end;

function TThreadsRoute.Retrieve(const ThreadId: string): TThreads;
begin
  HeaderCustomize;
  Result := API.Get<TThreads>('threads/' + ThreadId);
end;

{ TThreadsModifyParams }

function TThreadsModifyParams.Metadata(
  const Value: TJSONObject): TThreadsModifyParams;
begin
  Result := TThreadsModifyParams(Add('metadata', Value));
end;

function TThreadsModifyParams.ToolResources(
  const Value: TToolResourcesParams): TThreadsModifyParams;
begin
  Result := TThreadsModifyParams(Add('tool_resources', Value.Detach));
end;

{ TThreads }

destructor TThreads.Destroy;
begin
  if Assigned(FToolResources) then
    FToolResources.Free;
  inherited;
end;

function TThreads.GetCreatedAt: Int64;
begin
  Result := TInt64OrNull(FCreatedAt).ToInteger;
end;

function TThreads.GetCreatedAtAsString: string;
begin
  Result := TInt64OrNull(FCreatedAt).ToUtcDateString;
end;

end.

unit GenAI.Tutorial.FMX;

{ Tutorial Support Unit

   WARNING:
     This module is intended solely to illustrate the examples provided in the
     README.md file of the repository :
          https://github.com/MaxiDonkey/DelphiGenAI
     Under no circumstances should the methods described below be used outside
     of the examples presented on the repository's page.
}

interface

uses
  System.SysUtils, System.Classes, Winapi.Messages, FMX.Types, FMX.StdCtrls, FMX.ExtCtrls,
  FMX.Controls, FMX.Forms, Winapi.Windows, FMX.Graphics, FMX.Dialogs, FMX.Memo.Types,
  FMX.Media, FMX.Objects, FMX.Controls.Presentation, FMX.ScrollBox, FMX.Memo, System.UITypes,
  System.Types, System.JSON, GenAI, GenAI.Types;

type
  TToolProc = procedure (const Value: string) of object;

  /// <summary>
  /// Represents a tutorial hub for handling visual components in a Delphi application,
  /// including text display, button interactions, and navigation through pages.
  /// </summary>
  TFMXTutorialHub = class
  private
    FMemo1: TMemo;
    FMemo2: TMemo;
    FMemo3: TMemo;
    FImage: TImage;
    FButton: TButton;
    FModelId: string;
    FFileName: string;
    FTool: IFunctionCore;
    FToolCall: TToolProc;
    FCancel: Boolean;
    FMediaPlayer: TMediaPlayer;
    FClient: IGenAI;
    FId: string;
    FAudioId: string;
    FTranscript: string;
    procedure OnButtonClick(Sender: TObject);
    procedure SetButton(const Value: TButton);
    procedure SetMemo1(const Value: TMemo);
    procedure SetFileName(const Value: string);
    procedure SetMemo2(const Value: TMemo);
    procedure SetMemo3(const Value: TMemo);
    procedure SetJSONRequest(const Value: string);
    procedure SetJSONResponse(const Value: string);
  public
    /// <summary>
    /// Play audio using the mediaplayer.
    /// </summary>
    procedure PlayAudio;
    /// <summary>
    /// Gets or sets IGenAI interface.
    /// </summary>
    property Client: IGenAI read FClient write FClient;
    /// <summary>
    /// Gets or sets the first memo component for displaying messages or data.
    /// </summary>
    property Memo1: TMemo read FMemo1 write SetMemo1;
    /// <summary>
    /// Gets or sets the second memo component for displaying messages or data.
    /// </summary>
    property Memo2: TMemo read FMemo2 write SetMemo2;
    /// <summary>
    /// Gets or sets the third memo component for displaying messages or data.
    /// </summary>
    property Memo3: TMemo read FMemo3 write SetMemo3;
    /// <summary>
    /// Sets text Timage component.
    /// </summary>
    property Image: TImage read FImage write FImage;
    /// <summary>
    /// Sets text for displaying JSON request.
    /// </summary>
    property JSONRequest: string write SetJSONRequest;
    /// <summary>
    /// Sets text for displaying JSON response.
    /// </summary>
    property JSONResponse: string write SetJSONResponse;
    /// <summary>
    /// Gets or sets the button component used to trigger actions or handle cancellation.
    /// </summary>
    property Button: TButton read FButton write SetButton;
    /// <summary>
    /// Gets or sets a value indicating whether the operation has been canceled.
    /// </summary>
    property Cancel: Boolean read FCancel write FCancel;
    /// <summary>
    /// Gets or sets the model identifier associated with the tutorial hub.
    /// </summary>
    property ModelId: string read FModelId write FModelId;
    /// <summary>
    /// Gets or sets the filename associated with the tutorial hub.
    /// </summary>
    property FileName: string read FFileName write SetFileName;
    /// <summary>
    /// Gets or sets the core function tool used for processing.
    /// </summary>
    property Tool: IFunctionCore read FTool write FTool;
    /// <summary>
    /// Gets or sets the procedure for handling tool-specific calls.
    /// </summary>
    property ToolCall: TToolProc read FToolCall write FToolCall;
    /// <summary>
    /// Gets or sets the ID to simplify its usage.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Gets or sets the ID used to manage audio references.
    /// </summary>
    property AudioId: string read FAudioId write FAudioId;
    /// <summary>
    /// Gets or sets the transcript with audio response.
    /// </summary>
    property Transcript: string read FTranscript write FTranscript;
    /// <summary>
    /// Gets or sets a TMediaplayer.
    /// </summary>
    property MediaPlayer: TMediaPlayer read FMediaPlayer write FMediaPlayer;
    procedure DisplayWeatherStream(const Value: string);
    procedure DisplayWeatherAudio(const Value: string);
    procedure SpeechChat(const  Value: string);
    procedure JSONRequestClear;
    procedure JSONResponseClear;
    constructor Create(const AClient: IGenAI; const AMemo1, AMemo2, AMemo3: TMemo;
      const AImage: TImage; const AButton: TButton; const AMediaPlayer: TMediaPlayer);
  end;

  procedure Cancellation(Sender: TObject);
  function DoCancellation: Boolean;
  procedure Start(Sender: TObject);

  procedure Display(Sender: TObject); overload;
  procedure Display(Sender: TObject; Value: string); overload;
  procedure Display(Sender: TObject; Value: TArray<string>); overload;
  procedure Display(Sender: TObject; Value: TModel); overload;
  procedure Display(Sender: TObject; Value: TModels); overload;
  procedure Display(Sender: TObject; Value: TDeletion); overload;
  procedure Display(Sender: TObject; Value: TEmbedding); overload;
  procedure Display(Sender: TObject; Value: TEmbeddings); overload;
  procedure Display(Sender: TObject; Value: TSpeechResult); overload;
  procedure Display(Sender: TObject; Value: TTranscription); overload;
  procedure Display(Sender: TObject; Value: TTranslation); overload;
  procedure Display(Sender: TObject; Value: TChat); overload;
  procedure Display(Sender: TObject; Value: TModeration); overload;
  procedure Display(Sender: TObject; Value: TModerationResult); overload;
  procedure Display(Sender: TObject; Value: TGeneratedImages); overload;
  procedure Display(Sender: TObject; Value: TFile); overload;
  procedure Display(Sender: TObject; Value: TFiles); overload;
  procedure Display(Sender: TObject; Value: TFileContent); overload;
  procedure Display(Sender: TObject; Value: TUpload); overload;
  procedure Display(Sender: TObject; Value: TUploadPart); overload;
  procedure Display(Sender: TObject; Value: TBatch); overload;
  procedure Display(Sender: TObject; Value: TBatches); overload;
  procedure Display(Sender: TObject; Value: TCompletion); overload;
  procedure Display(Sender: TObject; Value: TVectorStore); overload;
  procedure Display(Sender: TObject; Value: TVectorStores); overload;
  procedure Display(Sender: TObject; Value: TVectorStoreFile); overload;
  procedure Display(Sender: TObject; Value: TVectorStoreFiles); overload;
  procedure Display(Sender: TObject; Value: TVectorStoreBatch); overload;
  procedure Display(Sender: TObject; Value: TVectorStoreBatches); overload;
  procedure Display(Sender: TObject; Value: TAssistant); overload;
  procedure Display(Sender: TObject; Value: TAssistants); overload;
  procedure Display(Sender: TObject; Value: TThreads); overload;
  procedure Display(Sender: TObject; Value: TMessages); overload;
  procedure Display(Sender: TObject; Value: TMessagesList); overload;
  procedure Display(Sender: TObject; Value: TRun); overload;
  procedure Display(Sender: TObject; Value: TRuns); overload;
  procedure Display(Sender: TObject; Value: TRunStep); overload;
  procedure Display(Sender: TObject; Value: TRunSteps); overload;
  procedure Display(Sender: TObject; Value: TResponse); overload;
  procedure Display(Sender: TObject; Value: TResponseDelete); overload;
  procedure Display(Sender: TObject; Value: TResponses); overload;
  procedure Display(Sender: TObject; Value: TChatMessages); overload;
  procedure Display(Sender: TObject; Value: TChatCompletion); overload;
  procedure Display(Sender: TObject; Value: TChatDelete); overload;

  procedure DisplayStream(Sender: TObject; Value: string); overload;
  procedure DisplayStream(Sender: TObject; Value: TChat); overload;
  procedure DisplayStream(Sender: TObject; Value: TCompletion); overload;
  procedure DisplayStream(Sender: TObject; Value: TResponseStream); overload;

  procedure DisplayChunk(Value: string); overload;
  procedure DisplayChunk(Value: TChat); overload;
  procedure DisplayChunk(Value: TCompletion); overload;
  procedure DisplayChunk(Value: TResponseStream); overload;

  procedure DisplayAudio(Sender: TObject; Value: TChat);
  procedure DisplayAudioEx(Sender: TObject; Value: TChat);

  function F(const Name, Value: string): string; overload;
  function F(const Name: string; const Value: TArray<string>): string; overload;
  function F(const Name: string; const Value: boolean): string; overload;
  function F(const Name: string; const State: Boolean; const Value: Double): string; overload;

var
  /// <summary>
  /// A global instance of the <see cref="TFMXTutorialHub"/> class used as the main tutorial hub.
  /// </summary>
  /// <remarks>
  /// This variable serves as the central hub for managing tutorial components, such as memos, buttons, and pages.
  /// It is initialized dynamically during the application's runtime, and its memory is automatically released during
  /// the application's finalization phase.
  /// </remarks>
  TutorialHub: TFMXTutorialHub = nil;

implementation

procedure Cancellation(Sender: TObject);
begin
  if TutorialHub.Cancel then
    begin
      Display(Sender, 'The operation was cancelled');
      Display(Sender);
      TutorialHub.Cancel := False;
    end;
end;

function DoCancellation: Boolean;
begin
  Result := TutorialHub.Cancel;
end;

procedure Start(Sender: TObject);
begin
  Display(Sender, 'Please wait...');
  Display(Sender);
  TutorialHub.Cancel := False;
  TutorialHub.JSONResponseClear;
end;

procedure Display(Sender: TObject; Value: string);
var
  M: TMemo;
begin
  if Sender is TMemo then
    M := Sender as TMemo else
    M := (Sender as TFMXTutorialHub).Memo1;
  M.Lines.Add(Value);
  M.ViewportPosition := PointF(M.ViewportPosition.X, M.Content.Height - M.Height);
end;

procedure Display(Sender: TObject; Value: TArray<string>);
begin
  var index := 0;
  for var Item in Value do
    begin
      if not Item.IsEmpty then
        begin
          if index = 0 then
            Display(Sender, Item) else
            Display(Sender, '    ' + Item);
        end;
      Inc(index);
    end;
end;

procedure Display(Sender: TObject);
begin
  Display(Sender, sLineBreak);
end;

procedure Display(Sender: TObject; Value: TModel);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    EmptyStr,
    F('id', Value.Id),
    F('object', Value.&Object),
    F('owned_by', Value.OwnedBy),
    F('created', Value.CreatedAsString)
  ]);
  Display(Sender, EmptyStr);
end;

procedure Display(Sender: TObject; Value: TModels);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, 'Models list');
  if System.Length(Value.Data) = 0 then
    begin
      Display(Sender, 'No model found');
      Exit;
    end;
  for var Item in Value.Data do
    begin
      Display(Sender, Item);
      Application.ProcessMessages;
    end;
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TDeletion);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    EmptyStr,
    F('id', Value.Id),
    F('object', Value.&Object),
    F('deleted', BoolToStr(Value.Deleted, True))
  ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TEmbedding);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  var index := 1;
  for var Item in Value.Embedding do
    begin
      Display(Sender, F(Format('V[%d]', [index]), Item.ToString(ffNumber, 2, 6)));
      Inc(index);
    end;
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TEmbeddings);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    Display(Sender, Item);
end;

procedure Display(Sender: TObject; Value: TSpeechResult);
begin
  {--- Display the JSON response }
  TutorialHub.JSONResponse := Value.JSONResponse;

  {--- The file name can not be null }
  if TutorialHub.FileName.IsEmpty then
    raise Exception.Create('Set filename value in HFTutorial instance');

  {--- Save the audio into a file. }
  Value.SaveToFile(TutorialHub.FileName);

  {--- Play the audio result }
  TutorialHub.PlayAudio;
end;

procedure Display(Sender: TObject; Value: TTranscription);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, Value.Text);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TTranslation);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, Value.Text);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TChat);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Choices do
    if Item.FinishReason = TFinishReason.tool_calls then
      begin
        if Assigned(TutorialHub.ToolCall) then
          begin
            for var Func in Item.Message.ToolCalls do
              begin
                Display(Sender, Func.&function.Arguments);
                var Evaluation := TutorialHub.Tool.Execute(Func.&function.Arguments);
                Display(Sender, Evaluation);
                Display(Sender);
                TutorialHub.ToolCall(Evaluation);
              end;
          end;
      end
    else
      begin
        Display(Sender, Item.Message.Content);
      end;
  Display(Sender, sLineBreak);
end;

procedure Display(Sender: TObject; Value: TModeration);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Results do
    Display(Sender, Item);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TModerationResult);
begin
  for var Item in Value.FlaggedDetail do
    Display(Sender, [
      EmptyStr,
      F(Item.Category.ToString, Item.Score.ToString(ffNumber, 3, 3))
    ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TGeneratedImages);
begin
  {--- Load image when url is not null. }
  if not TutorialHub.FileName.IsEmpty then
    begin
      if not Value.Data[0].Url.IsEmpty then
        Value.Data[0].Download(TutorialHub.FileName) else
        Value.Data[0].SaveToFile(TutorialHub.FileName);
    end;

  {--- Load image into a stream }
  var Stream := Value.Data[0].GetStream;
  try
    {--- Display the JSON response. }
    TutorialHub.JSONResponse := Value.JSONResponse;

    {--- Display the revised prompt. }
    Display(Sender, Value.Data[0].RevisedPrompt);

    {--- Load the stream into the TImage. }
    TutorialHub.Image.Bitmap.LoadFromStream(Stream);
  finally
    Stream.Free;
  end;
end;

procedure Display(Sender: TObject; Value: TFile);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    Value.Filename,
    F('id', [
      Value.Id,
      F('purpose', Value.Purpose.ToString),
      F('created_at', Value.CreatedAtAsString)
    ])
  ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TFiles);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    Display(Sender, Item);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TFileContent);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, Value.Content);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TUpload);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(TutorialHub, [
      F(Value.Id, Value.&Object),
      F(Value.Filename, Value.Bytes.ToString),
      Value.Purpose.ToString,
      Value.Status,
      Value.CreatedAtAsString,
      Value.ExpiresAtAsString
    ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TUploadPart);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(TutorialHub, [
      Value.Id,
      F(Value.&Object, F('upload_id', Value.UploadId)),
      Value.CreatedAtAsString
    ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TBatch);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;

  Display(Sender, [
      Value.Id,
      F('endpoint', Value.Endpoint),
      F('output_file_id', Value.OutputFileId),
      F('Status', Value.Status.ToString),
      F('in_progress_at', Value.InProgressAtAsString),
      F('expires_at', Value.ExpiresAtAsString),
      F('metadata', Value.Metadata)
    ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TBatches);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    Display(Sender, Item);
  Display(Sender, [
    F('has more', BoolToStr(Value.HasMore, True)),
    F('first_id', Value.FirstId),
    F('last_id', Value.LastId)
  ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TCompletion);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Choices do
    Display(Sender, Item.Text);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TVectorStore);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    F('id', Value.Id),
    F('object', Value.&Object),
    F('name', Value.Name),
    F('created_at', Value.CreatedAtAsString),
    F('metadata', Value.Metadata)
  ]);
  Display(Sender, sLineBreak);
end;

procedure Display(Sender: TObject; Value: TVectorStores);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    begin
      Display(Sender, Item);
    end;
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TVectorStoreFile);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    F('id', Value.Id),
    F('object', Value.&Object),
    F('usage_bytes', Value.UsageBytes.ToString),
    F('status', Value.Status.ToString)
  ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TVectorStoreFiles);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    Display(Sender, Item);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TVectorStoreBatch);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    F('id', Value.Id),
    F('object', Value.&Object),
    F('vector_store_id', Value.VectorStoreId),
    F('status', Value.Status.ToString)
  ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TVectorStoreBatches);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    Display(Sender, Item);
  Display(Sender)
end;

procedure Display(Sender: TObject; Value: TAssistant);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    F('id', Value.Id),
    F('object', Value.&Object),
    F('name', Value.Name),
    F('model', Value.Model)
  ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TAssistants);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    Display(Sender, Item);
  Display(Sender)
end;

procedure Display(Sender: TObject; Value: TThreads);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    F('id', Value.Id),
    F('object', Value.&Object),
    F('created_at', Value.CreatedAtAsString)
  ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TMessages);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, F('id', [Value.Id, F('status', Value.Status.ToString)]));
  for var Item in Value.Content do
    Display(Sender, Item.Text.Value);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TMessagesList);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    Display(Sender, Item);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TRun);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    F('id', Value.Id),
    F('status',Value.Status.ToString),
    F('thread_id', Value.ThreadId),
    F('assistant_id', Value.AssistantId),
    F('expires_at', Value.ExpiresAtAsString)
  ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TRuns);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    Display(Sender, Item);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TRunStep);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    F('id', Value.Id),
    F('status',Value.Status.ToString),
    F('thread_id', Value.ThreadId),
    F('assistant_id', Value.AssistantId),
    F('run_id', Value.RunId),
    F('step_details.type', Value.StepDetails.&Type.ToString),
    F('step_details.message_creation.MessageId', Value.StepDetails.MessageCreation.MessageId)
  ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TRunSteps);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    Display(Sender, Item);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TResponse);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Output do
    begin
      if Item.&Type = TResponseTypes.function_call then
        begin
           Display(Sender, Item.Arguments);
           var Evaluation := TutorialHub.Tool.Execute(Item.Arguments);
           Display(Sender, Evaluation);
           Display(Sender);
           TutorialHub.ToolCall(Evaluation);
        end
      else
        begin
          for var SubItem in Item.Content do
            Display(Sender, SubItem.Text);
        end;
    end;
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TResponseDelete);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    F('id', Value.Id),
    F('object', Value.&Object),
    F('deleted', BoolToStr(Value.Deleted, True))
  ]);
end;

procedure Display(Sender: TObject; Value: TResponses);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    begin
      for var SubItem in Item.Content do
        begin
          Display(Sender, SubItem.Text);
          Display(Sender);
        end;
    end;
end;

procedure Display(Sender: TObject; Value: TChatMessages);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    begin
      Display(Sender, Item.Content);
      Display(Sender);
    end;
end;

procedure Display(Sender: TObject; Value: TChatCompletion);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    begin
      for var SubItem in Item.Choices do
        begin
          Display(Sender, SubItem.Message.Content);
          Display(Sender);
        end;
    end;
end;

procedure Display(Sender: TObject; Value: TChatDelete);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, Value.Id);
  Display(Sender, F('Deleted', BoolToStr(Value.Deleted, True)));
  Display(Sender);
end;

procedure DisplayStream(Sender: TObject; Value: string);
var
  M: TMemo;
  CurrentLine: string;
begin
  if Sender is TMemo then
    M := Sender as TMemo
  else
    M := (Sender as TFMXTutorialHub).Memo1;
  var ShouldScroll := M.ViewportPosition.Y >= (M.Content.Height - M.Height - 16);
  M.Lines.BeginUpdate;
  try
    var Lines := Value.Replace(#13, '').Split([#10]);
    if System.Length(Lines) > 0 then
    begin
      if M.Lines.Count > 0 then
        CurrentLine := M.Lines[M.Lines.Count - 1]
      else
        CurrentLine := EmptyStr;
      CurrentLine := CurrentLine + Lines[0];
      if M.Lines.Count > 0 then
        M.Lines[M.Lines.Count - 1] := CurrentLine
      else
        M.Lines.Add(CurrentLine);
      for var i := 1 to High(Lines) do
        M.Lines.Add(Lines[i]);
    end;
  finally
    M.Lines.EndUpdate;
  end;
  if ShouldScroll then
    M.ViewportPosition := PointF(M.ViewportPosition.X, M.Content.Height - M.Height + 1);
end;

procedure DisplayStream(Sender: TObject; Value: TChat);
begin
  if Assigned(Value) then
    begin
      for var Item in Value.Choices do
        begin
          DisplayStream(Sender, Item.Delta.Content);
        end;
      DisplayChunk(Value);
    end;
end;

procedure DisplayStream(Sender: TObject; Value: TCompletion);
begin
  if Assigned(Value) then
    begin
      DisplayStream(Sender, Value.Choices[0].Text);
      DisplayChunk(Value);
    end;
end;

procedure DisplayStream(Sender: TObject; Value: TResponseStream);
begin
  if Assigned(Value) then
    begin
      DisplayStream(Sender, Value.Delta);
      DisplayChunk(Value);
    end;
end;

procedure DisplayChunk(Value: string);
begin
   var JSONValue := TJSONObject.ParseJSONValue(Value);
  TutorialHub.Memo3.Lines.BeginUpdate;
  try
    Display(TutorialHub.Memo3, JSONValue.ToString);
  finally
    TutorialHub.Memo3.Lines.EndUpdate;
    JSONValue.Free;
  end;
end;

procedure DisplayChunk(Value: TChat);
begin
  DisplayChunk(Value.JSONResponse);
end;

procedure DisplayChunk(Value: TCompletion);
begin
  DisplayChunk(Value.JSONResponse);
end;

procedure DisplayChunk(Value: TResponseStream);
begin
  DisplayChunk(Value.JSONResponse);
end;

procedure DisplayAudio(Sender: TObject; Value: TChat);
begin
  {--- Display the JSON response }
  TutorialHub.JSONResponse := Value.JSONResponse;

  {--- We need an audio filename for the tutorial }
  if TutorialHub.FileName.IsEmpty then
    raise Exception.Create('Set filename value in HFTutorial instance');

  {--- Store the audio Id. }
  TutorialHub.AudioId := Value.Choices[0].Message.Audio.Id;

  {--- Store the audio transcript. }
  TutorialHub.Transcript := Value.Choices[0].Message.Audio.Transcript;

  {--- The audio response is stored in a file. }
  Value.Choices[0].Message.Audio.SaveToFile(TutorialHub.FileName);

  {--- Display the textual response. }
  Display(Sender, Value.Choices[0].Message.Audio.Transcript);

  {--- Play audio response. }
  TutorialHub.PlayAudio;
  Display(Sender, sLineBreak);
end;

procedure DisplayAudioEx(Sender: TObject; Value: TChat);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  DisplayStream(Sender, Value.Choices[0].Message.Content);
  TutorialHub.SpeechChat(Value.Choices[0].Message.Content);
end;

function F(const Name, Value: string): string;
begin
  if not Value.IsEmpty then
    Result := Format('%s: %s', [Name, Value])
end;

function F(const Name: string; const Value: TArray<string>): string;
begin
  var index := 0;
  for var Item in Value do
    begin
      if index = 0 then
        Result := Format('%s: %s', [Name, Item]) else
        Result := Result + '    ' + Item;
      Inc(index);
    end;
end;

function F(const Name: string; const Value: boolean): string;
begin
  Result := Format('%s: %s', [Name, BoolToStr(Value, True)])
end;

function F(const Name: string; const State: Boolean; const Value: Double): string;
begin
  Result := Format('%s (%s): %s%%', [Name, BoolToStr(State, True), (Value * 100).ToString(ffNumber, 3, 3)])
end;

{ TFMXTutorialHub }

constructor TFMXTutorialHub.Create(const AClient: IGenAI; const AMemo1, AMemo2,
  AMemo3: TMemo; const AImage: TImage; const AButton: TButton;
  const AMediaPlayer: TMediaPlayer);
begin
  inherited Create;
  Memo1 := AMemo1;
  Memo2 := AMemo2;
  Memo3 := AMemo3;
  Image := AImage;
  Button := AButton;
  FMediaPlayer := AMediaPlayer;
  Client := AClient;
end;

procedure TFMXTutorialHub.DisplayWeatherAudio(const Value: string);
begin
  FileName := 'AudioWeather.mp3';

  //Asynchronous example
  Client.Chat.AsynCreate(
    procedure (Params: TChatParams)
    begin
      Params.Model('gpt-4o-audio-preview');
      Params.Modalities(['text', 'audio']);
      Params.Audio('verse', 'mp3');
      Params.Messages([
        FromSystem('You are a weather presenter on a prime time TV channel.'),
        FromUser(Value)
      ]);
      Params.MaxCompletionTokens(1024);
    end,
    function : TAsynChat
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := DisplayAudio;
      Result.OnError := Display;
    end);
end;

procedure TFMXTutorialHub.DisplayWeatherStream(const Value: string);
begin
  //Asynchronous example
  Client.Chat.AsynCreateStream(
    procedure(Params: TChatParams)
    begin
      Params.Model('gpt-4o');
      Params.Messages([
          FromSystem('You are a weather presenter on a prime time TV channel.'),
          FromUser(Value)]);
      Params.MaxCompletionTokens(1024);
      Params.Stream;
    end,
    function : TAsynChatStream
    begin
      Result.Sender := TutorialHub;
      Result.OnProgress := DisplayStream;
      Result.OnError := Display;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
    end);
end;

procedure TFMXTutorialHub.JSONRequestClear;
begin
  Memo2.Lines.Clear;
end;

procedure TFMXTutorialHub.JSONResponseClear;
begin
  Memo3.Lines.Clear;
end;

procedure TFMXTutorialHub.OnButtonClick(Sender: TObject);
begin
  Cancel := True;
end;

procedure TFMXTutorialHub.PlayAudio;
begin
  with MediaPlayer do
    begin
      FileName := Self.FileName;
      Play;
    end;
end;

procedure TFMXTutorialHub.SetButton(const Value: TButton);
begin
  FButton := Value;
  FButton.OnClick := OnButtonClick;
  FButton.Text := 'Cancel';
end;

procedure TFMXTutorialHub.SetFileName(const Value: string);
begin
  FFileName := Value;
  FMediaPlayer.Clear;     //verif
end;

procedure TFMXTutorialHub.SetJSONRequest(const Value: string);
begin
  Memo2.Lines.Text := Value;
  Memo2.SelStart := 0;
  Application.ProcessMessages;
end;

procedure TFMXTutorialHub.SetJSONResponse(const Value: string);
begin
  Memo3.Lines.Text := Value;
  Memo2.SelStart := 0;
  Application.ProcessMessages;
end;

procedure TFMXTutorialHub.SetMemo1(const Value: TMemo);
begin
  FMemo1 := Value;
  FMemo1.TextSettings.WordWrap := True;
end;

procedure TFMXTutorialHub.SetMemo2(const Value: TMemo);
begin
  FMemo2 := Value;
end;

procedure TFMXTutorialHub.SetMemo3(const Value: TMemo);
begin
  FMemo3 := Value;
end;

procedure TFMXTutorialHub.SpeechChat(const Value: string);
begin
  FileName := 'SpeechChat.mp3';

  //Asynchronous example
  Client.Chat.AsynCreate(
    procedure (Params: TChatParams)
    begin
      Params.Model('gpt-4o-audio-preview');
      Params.Modalities(['text', 'audio']);
      Params.Audio('ash', 'mp3');
      Params.Messages([
        FromUser(Value)
      ]);
      Params.MaxCompletionTokens(1024);
    end,
    function : TAsynChat
    begin
      Result.Sender := TutorialHub;
      Result.OnSuccess := DisplayAudio;
      Result.OnError := Display;
    end);
end;

initialization
finalization
  if Assigned(TutorialHub) then
    TutorialHub.Free;
end.

unit GenAI.Tutorial.VCL;

{ Tutorial Support Unit

   WARNING:
     This module is intended solely to illustrate the examples provided in the
     README.md file of the repository :
          https://github.com/MaxiDonkey/DelphiGenAI
     Under no circumstances should the methods described below be used outside
     of the examples presented on the repository's page.
}

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes,
  Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.ExtCtrls,
  System.UITypes, Vcl.MPlayer, system.JSON, GenAI, GenAI.Types;

type
  TToolProc = procedure (const Value: string) of object;

  /// <summary>
  /// Represents a tutorial hub for handling visual components in a Delphi application,
  /// including text display, button interactions, and navigation through pages.
  /// </summary>
  TVCLTutorialHub = class
  private
    FMemo1: TMemo;
    FMemo2: TMemo;
    FMemo3: TMemo;
    FImage: TImage;
    FButton: TButton;
    FModelId: string;
    FFileName: string;
    FTool: IFunctionCore;
    FToolCall: TToolProc;
    FCancel: Boolean;
    FMediaPlayer: TMediaPlayer;
    FClient: IGenAI;
    FId: string;
    FAudioId: string;
    FTranscript: string;
    procedure OnButtonClick(Sender: TObject);
    procedure SetButton(const Value: TButton);
    procedure SetMemo1(const Value: TMemo);
    procedure SetFileName(const Value: string);
    procedure SetMemo2(const Value: TMemo);
    procedure SetMemo3(const Value: TMemo);
    procedure SetJSONRequest(const Value: string);
    procedure SetJSONResponse(const Value: string);
  public
    /// <summary>
    /// Play audio using the mediaplayer.
    /// </summary>
    procedure PlayAudio;
    /// <summary>
    /// Gets or sets IGenAI interface.
    /// </summary>
    property Client: IGenAI read FClient write FClient;
    /// <summary>
    /// Gets or sets the first memo component for displaying messages or data.
    /// </summary>
    property Memo1: TMemo read FMemo1 write SetMemo1;
    /// <summary>
    /// Gets or sets the second memo component for displaying messages or data.
    /// </summary>
    property Memo2: TMemo read FMemo2 write SetMemo2;
    /// <summary>
    /// Gets or sets the third memo component for displaying messages or data.
    /// </summary>
    property Memo3: TMemo read FMemo3 write SetMemo3;
    /// <summary>
    /// Sets text Timage component.
    /// </summary>
    property Image: TImage read FImage write FImage;
    /// <summary>
    /// Sets text for displaying JSON request.
    /// </summary>
    property JSONRequest: string write SetJSONRequest;
    /// <summary>
    /// Sets text for displaying JSON response.
    /// </summary>
    property JSONResponse: string write SetJSONResponse;
    /// <summary>
    /// Gets or sets the button component used to trigger actions or handle cancellation.
    /// </summary>
    property Button: TButton read FButton write SetButton;
    /// <summary>
    /// Gets or sets a value indicating whether the operation has been canceled.
    /// </summary>
    property Cancel: Boolean read FCancel write FCancel;
    /// <summary>
    /// Gets or sets the model identifier associated with the tutorial hub.
    /// </summary>
    property ModelId: string read FModelId write FModelId;
    /// <summary>
    /// Gets or sets the filename associated with the tutorial hub.
    /// </summary>
    property FileName: string read FFileName write SetFileName;
    /// <summary>
    /// Gets or sets the core function tool used for processing.
    /// </summary>
    property Tool: IFunctionCore read FTool write FTool;
    /// <summary>
    /// Gets or sets the procedure for handling tool-specific calls.
    /// </summary>
    property ToolCall: TToolProc read FToolCall write FToolCall;
    /// <summary>
    /// Gets or sets the ID to simplify its usage.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Gets or sets the ID used to manage audio references.
    /// </summary>
    property AudioId: string read FAudioId write FAudioId;
    /// <summary>
    /// Gets or sets the transcript with audio response.
    /// </summary>
    property Transcript: string read FTranscript write FTranscript;
    /// <summary>
    /// Gets or sets a TMediaplayer.
    /// </summary>
    property MediaPlayer: TMediaPlayer read FMediaPlayer write FMediaPlayer;
    procedure DisplayWeatherStream(const Value: string);
    procedure DisplayWeatherAudio(const Value: string);
    procedure SpeechChat(const  Value: string);
    procedure JSONRequestClear;
    procedure JSONResponseClear;
    constructor Create(const AClient: IGenAI; const AMemo1, AMemo2, AMemo3: TMemo;
      const AImage: TImage; const AButton: TButton; const AMediaPlayer: TMediaPlayer);
  end;

  procedure Cancellation(Sender: TObject);
  function DoCancellation: Boolean;
  procedure Start(Sender: TObject);

  procedure Display(Sender: TObject); overload;
  procedure Display(Sender: TObject; Value: string); overload;
  procedure Display(Sender: TObject; Value: TArray<string>); overload;
  procedure Display(Sender: TObject; Value: TModel); overload;
  procedure Display(Sender: TObject; Value: TModels); overload;
  procedure Display(Sender: TObject; Value: TDeletion); overload;
  procedure Display(Sender: TObject; Value: TEmbedding); overload;
  procedure Display(Sender: TObject; Value: TEmbeddings); overload;
  procedure Display(Sender: TObject; Value: TSpeechResult); overload;
  procedure Display(Sender: TObject; Value: TTranscription); overload;
  procedure Display(Sender: TObject; Value: TTranslation); overload;
  procedure Display(Sender: TObject; Value: TChat); overload;
  procedure Display(Sender: TObject; Value: TModeration); overload;
  procedure Display(Sender: TObject; Value: TModerationResult); overload;
  procedure Display(Sender: TObject; Value: TGeneratedImages); overload;
  procedure Display(Sender: TObject; Value: TFile); overload;
  procedure Display(Sender: TObject; Value: TFiles); overload;
  procedure Display(Sender: TObject; Value: TFileContent); overload;
  procedure Display(Sender: TObject; Value: TUpload); overload;
  procedure Display(Sender: TObject; Value: TUploadPart); overload;
  procedure Display(Sender: TObject; Value: TBatch); overload;
  procedure Display(Sender: TObject; Value: TBatches); overload;
  procedure Display(Sender: TObject; Value: TCompletion); overload;
  procedure Display(Sender: TObject; Value: TVectorStore); overload;
  procedure Display(Sender: TObject; Value: TVectorStores); overload;
  procedure Display(Sender: TObject; Value: TVectorStoreFile); overload;
  procedure Display(Sender: TObject; Value: TVectorStoreFiles); overload;
  procedure Display(Sender: TObject; Value: TVectorStoreBatch); overload;
  procedure Display(Sender: TObject; Value: TVectorStoreBatches); overload;
  procedure Display(Sender: TObject; Value: TAssistant); overload;
  procedure Display(Sender: TObject; Value: TAssistants); overload;
  procedure Display(Sender: TObject; Value: TThreads); overload;
  procedure Display(Sender: TObject; Value: TMessages); overload;
  procedure Display(Sender: TObject; Value: TMessagesList); overload;
  procedure Display(Sender: TObject; Value: TRun); overload;
  procedure Display(Sender: TObject; Value: TRuns); overload;
  procedure Display(Sender: TObject; Value: TRunStep); overload;
  procedure Display(Sender: TObject; Value: TRunSteps); overload;
  procedure Display(Sender: TObject; Value: TResponse); overload;
  procedure Display(Sender: TObject; Value: TResponseDelete); overload;
  procedure Display(Sender: TObject; Value: TResponses); overload;
  procedure Display(Sender: TObject; Value: TChatMessages); overload;
  procedure Display(Sender: TObject; Value: TChatCompletion); overload;
  procedure Display(Sender: TObject; Value: TChatDelete); overload;

  procedure DisplayStream(Sender: TObject; Value: string); overload;
  procedure DisplayStream(Sender: TObject; Value: TChat); overload;
  procedure DisplayStream(Sender: TObject; Value: TCompletion); overload;
  procedure DisplayStream(Sender: TObject; Value: TResponseStream); overload;

  procedure DisplayChunk(Value: string); overload;
  procedure DisplayChunk(Value: TChat); overload;
  procedure DisplayChunk(Value: TCompletion); overload;
  procedure DisplayChunk(Value: TResponseStream); overload;

  procedure DisplayAudio(Sender: TObject; Value: TChat);
  procedure DisplayAudioEx(Sender: TObject; Value: TChat);

  function F(const Name, Value: string): string; overload;
  function F(const Name: string; const Value: TArray<string>): string; overload;
  function F(const Name: string; const Value: boolean): string; overload;
  function F(const Name: string; const State: Boolean; const Value: Double): string; overload;

var
  /// <summary>
  /// A global instance of the <see cref="TVCLTutorialHub"/> class used as the main tutorial hub.
  /// </summary>
  /// <remarks>
  /// This variable serves as the central hub for managing tutorial components, such as memos, buttons, and pages.
  /// It is initialized dynamically during the application's runtime, and its memory is automatically released during
  /// the application's finalization phase.
  /// </remarks>
  TutorialHub: TVCLTutorialHub = nil;

implementation

procedure Cancellation(Sender: TObject);
begin
  if TutorialHub.Cancel then
    begin
      Display(Sender, 'The operation was cancelled');
      Display(Sender);
      TutorialHub.Cancel := False;
    end;
end;

function DoCancellation: Boolean;
begin
  Result := TutorialHub.Cancel;
end;

procedure Start(Sender: TObject);
begin
  Display(Sender, 'Please wait...');
  Display(Sender);
  TutorialHub.Cancel := False;
  TutorialHub.JSONResponseClear;
end;

procedure Display(Sender: TObject; Value: string);
var
  M: TMemo;
begin
  if Sender is TMemo then
    M := TMemo(Sender) else
    M := (Sender as TVCLTutorialHub).Memo1;

  var S := Value.Split([#10]);
  if System.Length(S) = 0 then
    begin
      M.Lines.Add(Value)
    end
  else
    begin
      for var Item in S do
        M.Lines.Add(Item);
    end;

  M.Perform(WM_VSCROLL, SB_BOTTOM, 0);
end;

procedure Display(Sender: TObject; Value: TArray<string>);
begin
  var index := 0;
  for var Item in Value do
    begin
      if not Item.IsEmpty then
        begin
          if index = 0 then
            Display(Sender, Item) else
            Display(Sender, '    ' + Item);
        end;
      Inc(index);
    end;
end;

procedure Display(Sender: TObject);
begin
  Display(Sender, sLineBreak);
end;

procedure Display(Sender: TObject; Value: TModel);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    EmptyStr,
    F('id', Value.Id),
    F('object', Value.&Object),
    F('owned_by', Value.OwnedBy),
    F('created', Value.CreatedAsString)
  ]);
  Display(Sender, EmptyStr);
end;

procedure Display(Sender: TObject; Value: TModels);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, 'Models list');
  if System.Length(Value.Data) = 0 then
    begin
      Display(Sender, 'No model found');
      Exit;
    end;
  for var Item in Value.Data do
    begin
      Display(Sender, Item);
      Application.ProcessMessages;
    end;
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TDeletion);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    EmptyStr,
    F('id', Value.Id),
    F('object', Value.&Object),
    F('deleted', BoolToStr(Value.Deleted, True))
  ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TEmbedding);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  var index := 1;
  for var Item in Value.Embedding do
    begin
      Display(Sender, F(Format('V[%d]', [index]), Item.ToString(ffNumber, 2, 6)));
      Inc(index);
    end;
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TEmbeddings);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    Display(Sender, Item);
end;

procedure Display(Sender: TObject; Value: TSpeechResult);
begin
  {--- Display the JSON response }
  TutorialHub.JSONResponse := Value.JSONResponse;

  {--- The file name can not be null }
  if TutorialHub.FileName.IsEmpty then
    raise Exception.Create('Set filename value in HFTutorial instance');

  {--- Save the audio into a file. }
  Value.SaveToFile(TutorialHub.FileName);

  {--- Play the audio result }
  TutorialHub.PlayAudio;
end;

procedure Display(Sender: TObject; Value: TTranscription);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, Value.Text);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TTranslation);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, Value.Text);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TChat);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Choices do
    if Item.FinishReason = TFinishReason.tool_calls then
      begin
        if Assigned(TutorialHub.ToolCall) then
          begin
            for var Func in Item.Message.ToolCalls do
              begin
                Display(Sender, Func.&function.Arguments);
                var Evaluation := TutorialHub.Tool.Execute(Func.&function.Arguments);
                Display(Sender, Evaluation);
                Display(Sender);
                TutorialHub.ToolCall(Evaluation);
              end;
          end;
      end
    else
      begin
        Display(Sender, Item.Message.Content);
      end;
  Display(Sender, sLineBreak);
end;

procedure Display(Sender: TObject; Value: TModeration);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Results do
    Display(Sender, Item);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TModerationResult);
begin
  for var Item in Value.FlaggedDetail do
    Display(Sender, [
      EmptyStr,
      F(Item.Category.ToString, Item.Score.ToString(ffNumber, 3, 3))
    ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TGeneratedImages);
begin
  {--- Load image when url is not null. }
  if not TutorialHub.FileName.IsEmpty then
    begin
      if not Value.Data[0].Url.IsEmpty then
        Value.Data[0].Download(TutorialHub.FileName) else
        Value.Data[0].SaveToFile(TutorialHub.FileName);
    end;

  {--- Load image into a stream }
  var Stream := Value.Data[0].GetStream;
  try
    {--- Display the JSON response. }
    TutorialHub.JSONResponse := Value.JSONResponse;

    {--- Display the revised prompt. }
    Display(Sender, Value.Data[0].RevisedPrompt);

    {--- Load the stream into the TImage. }
    TutorialHub.Image.Picture.LoadFromStream(Stream);
  finally
    Stream.Free;
  end;
end;

procedure Display(Sender: TObject; Value: TFile);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    Value.Filename,
    F('id', [
      Value.Id,
      F('purpose', Value.Purpose.ToString),
      F('created_at', Value.CreatedAtAsString)
    ])
  ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TFiles);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    Display(Sender, Item);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TFileContent);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, Value.Content);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TUpload);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(TutorialHub, [
      F(Value.Id, Value.&Object),
      F(Value.Filename, Value.Bytes.ToString),
      Value.Purpose.ToString,
      Value.Status,
      Value.CreatedAtAsString,
      Value.ExpiresAtAsString
    ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TUploadPart);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(TutorialHub, [
      Value.Id,
      F(Value.&Object, F('upload_id', Value.UploadId)) //,
//      Value.CreatedAtAsString
    ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TBatch);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;

  Display(Sender, [
      Value.Id,
      F('endpoint', Value.Endpoint),
      F('output_file_id', Value.OutputFileId),
      F('Status', Value.Status.ToString),
      F('in_progress_at', Value.InProgressAtAsString),
      F('expires_at', Value.ExpiresAtAsString),
      F('metadata', Value.Metadata)
    ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TBatches);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    Display(Sender, Item);
  Display(Sender, [
    F('has more', BoolToStr(Value.HasMore, True)),
    F('first_id', Value.FirstId),
    F('last_id', Value.LastId)
  ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TCompletion);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Choices do
    Display(Sender, Item.Text);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TVectorStore);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    F('id', Value.Id),
    F('object', Value.&Object),
    F('name', Value.Name),
    F('created_at', Value.CreatedAtAsString),
    F('metadata', Value.Metadata)
  ]);
  Display(Sender, sLineBreak);
end;

procedure Display(Sender: TObject; Value: TVectorStores);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    begin
      Display(Sender, Item);
    end;
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TVectorStoreFile);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    F('id', Value.Id),
    F('object', Value.&Object),
    F('usage_bytes', Value.UsageBytes.ToString),
    F('status', Value.Status.ToString)
  ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TVectorStoreFiles);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    Display(Sender, Item);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TVectorStoreBatch);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    F('id', Value.Id),
    F('object', Value.&Object),
    F('vector_store_id', Value.VectorStoreId),
    F('status', Value.Status.ToString)
  ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TVectorStoreBatches);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    Display(Sender, Item);
  Display(Sender)
end;

procedure Display(Sender: TObject; Value: TAssistant);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    F('id', Value.Id),
    F('object', Value.&Object),
    F('name', Value.Name),
    F('model', Value.Model)
  ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TAssistants);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    Display(Sender, Item);
  Display(Sender)
end;

procedure Display(Sender: TObject; Value: TThreads);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    F('id', Value.Id),
    F('object', Value.&Object),
    F('created_at', Value.CreatedAtAsString)
  ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TMessages);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, F('id', [Value.Id, F('status', Value.Status.ToString)]));
  for var Item in Value.Content do
    Display(Sender, Item.Text.Value);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TMessagesList);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    Display(Sender, Item);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TRun);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    F('id', Value.Id),
    F('status',Value.Status.ToString),
    F('thread_id', Value.ThreadId),
    F('assistant_id', Value.AssistantId),
    F('expires_at', Value.ExpiresAtAsString)
  ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TRuns);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    Display(Sender, Item);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TRunStep);
begin
  if not Value.JSONResponse.IsEmpty then
    TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    F('id', Value.Id),
    F('status',Value.Status.ToString),
    F('thread_id', Value.ThreadId),
    F('assistant_id', Value.AssistantId),
    F('run_id', Value.RunId),
    F('step_details.type', Value.StepDetails.&Type.ToString),
    F('step_details.message_creation.MessageId', Value.StepDetails.MessageCreation.MessageId)
  ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TRunSteps);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    Display(Sender, Item);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TResponse);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Output do
    begin
      if Item.&Type = TResponseTypes.function_call then
        begin
           Display(Sender, Item.Arguments);
           var Evaluation := TutorialHub.Tool.Execute(Item.Arguments);
           Display(Sender, Evaluation);
           Display(Sender);
           TutorialHub.ToolCall(Evaluation);
        end
      else
        begin
          for var SubItem in Item.Content do
            Display(Sender, SubItem.Text);
        end;
    end;
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TResponseDelete);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, [
    F('id', Value.Id),
    F('object', Value.&Object),
    F('deleted', BoolToStr(Value.Deleted, True))
  ]);
end;

procedure Display(Sender: TObject; Value: TResponses);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    begin
      for var SubItem in Item.Content do
        begin
          Display(Sender, SubItem.Text);
          Display(Sender);
        end;
    end;
end;

procedure Display(Sender: TObject; Value: TChatMessages);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    begin
      Display(Sender, Item.Content);
      Display(Sender);
    end;
end;

procedure Display(Sender: TObject; Value: TChatCompletion);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Data do
    begin
      for var SubItem in Item.Choices do
        begin
          Display(Sender, SubItem.Message.Content);
          Display(Sender);
        end;
    end;
end;

procedure Display(Sender: TObject; Value: TChatDelete);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  Display(Sender, Value.Id);
  Display(Sender, F('Deleted', BoolToStr(Value.Deleted, True)));
  Display(Sender);
end;

//procedure DisplayStream(Sender: TObject; Value: string);
//var
//  M: TMemo;
//  CurrentLine: string;
//  Lines: TArray<string>;
//begin
//  if Value.Trim.IsEmpty then
//    Exit;
//  if Sender is TMemo then
//    M := TMemo(Sender) else
//    M := (Sender as TVCLTutorialHub).Memo1;
//  var OldSelStart := M.SelStart;
//  var ShouldScroll := (OldSelStart = M.GetTextLen);
//  M.Lines.BeginUpdate;
//  try
//    Lines := Value.Split([#10]);
//    if System.Length(Lines) > 0 then
//    begin
//      if M.Lines.Count > 0 then
//        CurrentLine := M.Lines[M.Lines.Count - 1]
//      else
//        CurrentLine := '';
//      CurrentLine := CurrentLine + Lines[0];
//      if M.Lines.Count > 0 then
//        M.Lines[M.Lines.Count - 1] := CurrentLine
//      else
//        M.Lines.Add(CurrentLine);
//      for var i := 1 to High(Lines) do
//        M.Lines.Add(Lines[i]);
//    end;
//  finally
//    M.Lines.EndUpdate;
//  end;
//  if ShouldScroll then
//  begin
//    M.SelStart := M.GetTextLen;
//    M.SelLength := 0;
//    M.Perform(EM_SCROLLCARET, 0, 0);
//  end;
//end;

procedure DisplayStream(Sender: TObject; Value: string);
var
  M   : TMemo;
  Txt : string;
begin
  if Value.IsEmpty then Exit;

  if Sender is TMemo then
    M := TMemo(Sender)
  else
    M := (Sender as TVCLTutorialHub).Memo1;

  Txt := StringReplace(Value, '\n', sLineBreak, [rfReplaceAll]);
  Txt := StringReplace(Txt, #10,  sLineBreak, [rfReplaceAll]);

  M.Lines.BeginUpdate;
  try
    M.SelStart   := M.GetTextLen;
    M.SelLength  := 0;
    M.SelText    := Txt;
  finally
    M.Lines.EndUpdate;
  end;

  M.Perform(EM_SCROLLCARET, 0, 0);
end;

procedure DisplayStream(Sender: TObject; Value: TChat);
begin
  if Assigned(Value) then
    begin
      for var Item in Value.Choices do
        begin
          DisplayStream(Sender, Item.Delta.Content);
        end;
      DisplayChunk(Value);
    end;
end;

procedure DisplayStream(Sender: TObject; Value: TCompletion);
begin
  if Assigned(Value) then
    begin
      DisplayStream(Sender, Value.Choices[0].Text);
      DisplayChunk(Value);
    end;
end;

procedure DisplayStream(Sender: TObject; Value: TResponseStream);
begin
  if Assigned(Value) then
    begin
      DisplayStream(Sender, Value.Delta);
      DisplayChunk(Value);
    end;
end;

procedure DisplayChunk(Value: TChat);
begin
  DisplayChunk(Value.JSONResponse);
end;

procedure DisplayChunk(Value: string);
begin
  var JSONValue := TJSONObject.ParseJSONValue(Value);
  TutorialHub.Memo3.Lines.BeginUpdate;
  try
    Display(TutorialHub.Memo3, JSONValue.ToString);
  finally
    TutorialHub.Memo3.Lines.EndUpdate;
    JSONValue.Free;
  end;
end;

procedure DisplayChunk(Value: TCompletion);
begin
  DisplayChunk(Value.JSONResponse);
end;

procedure DisplayChunk(Value: TResponseStream);
begin
  DisplayChunk(Value.JSONResponse);
end;

procedure DisplayAudio(Sender: TObject; Value: TChat);
begin
  {--- Display the JSON response }
  TutorialHub.JSONResponse := Value.JSONResponse;

  {--- We need an audio filename for the tutorial }
  if TutorialHub.FileName.IsEmpty then
    raise Exception.Create('Set filename value in HFTutorial instance');

  {--- Store the audio Id. }
  TutorialHub.AudioId := Value.Choices[0].Message.Audio.Id;

  {--- Store the audio transcript. }
  TutorialHub.Transcript := Value.Choices[0].Message.Audio.Transcript;

  {--- The audio response is stored in a file. }
  Value.Choices[0].Message.Audio.SaveToFile(TutorialHub.FileName);

  {--- Display the textual response. }
  Display(Sender, Value.Choices[0].Message.Audio.Transcript);

  {--- Play audio response. }
  TutorialHub.PlayAudio;
  Display(Sender, sLineBreak);
end;

procedure DisplayAudioEx(Sender: TObject; Value: TChat);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  DisplayStream(Sender, Value.Choices[0].Message.Content);
  TutorialHub.SpeechChat(Value.Choices[0].Message.Content);
end;

function F(const Name, Value: string): string;
begin
  if not Value.IsEmpty then
    Result := Format('%s: %s', [Name, Value])
end;

function F(const Name: string; const Value: TArray<string>): string;
begin
  var index := 0;
  for var Item in Value do
    begin
      if index = 0 then
        Result := Format('%s: %s', [Name, Item]) else
        Result := Result + '    ' + Item;
      Inc(index);
    end;
end;

function F(const Name: string; const Value: boolean): string;
begin
  Result := Format('%s: %s', [Name, BoolToStr(Value, True)])
end;

function F(const Name: string; const State: Boolean; const Value: Double): string;
begin
  Result := Format('%s (%s): %s%%', [Name, BoolToStr(State, True), (Value * 100).ToString(ffNumber, 3, 2)])
end;

{ TVCLTutorialHub }

constructor TVCLTutorialHub.Create(const AClient: IGenAI; const AMemo1, AMemo2, AMemo3: TMemo;
  const AImage: TImage; const AButton: TButton; const AMediaPlayer: TMediaPlayer);
begin
  inherited Create;
  Memo1 := AMemo1;
  Memo2 := AMemo2;
  Memo3 := AMemo3;
  Image := AImage;
  Button := AButton;
  FMediaPlayer := AMediaPlayer;
  Client := AClient;
end;

procedure TVCLTutorialHub.DisplayWeatherAudio(const Value: string);
begin
  FileName := 'AudioWeather.mp3';

  //Asynchronous example
  Client.Chat.AsynCreate(
    procedure (Params: TChatParams)
    begin
      Params.Model('gpt-4o-audio-preview');
      Params.Modalities(['text', 'audio']);
      Params.Audio('verse', 'mp3');
      Params.Messages([
        FromSystem('You are a weather presenter on a prime time TV channel.'),
        FromUser(Value)
      ]);
      Params.MaxCompletionTokens(1024);
    end,
    function : TAsynChat
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := DisplayAudio;
      Result.OnError := Display;
    end);
end;

procedure TVCLTutorialHub.DisplayWeatherStream(const Value: string);
begin
  //Asynchronous example
  Client.Chat.AsynCreateStream(
    procedure(Params: TChatParams)
    begin
      Params.Model('gpt-4o');
      Params.Messages([
          FromSystem('You are a weather presenter on a prime time TV channel.'),
          FromUser(Value)]);
      Params.MaxCompletionTokens(1024);
      Params.Stream;
    end,
    function : TAsynChatStream
    begin
      Result.Sender := TutorialHub;
      Result.OnProgress := DisplayStream;
      Result.OnError := Display;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
    end);
end;

procedure TVCLTutorialHub.JSONRequestClear;
begin
  Memo2.Clear;
end;

procedure TVCLTutorialHub.JSONResponseClear;
begin
  Memo3.Clear;
end;

procedure TVCLTutorialHub.OnButtonClick(Sender: TObject);
begin
  Cancel := True;
end;

procedure TVCLTutorialHub.PlayAudio;
begin
  with TutorialHub.MediaPlayer do
    begin
      FileName := TutorialHub.FileName;
      Open;
      Play;
    end;
end;

procedure TVCLTutorialHub.SetButton(const Value: TButton);
begin
  FButton := Value;
  FButton.OnClick := OnButtonClick;
  FButton.Caption := 'Cancel';
end;

procedure TVCLTutorialHub.SetFileName(const Value: string);
begin
  FFileName := Value;
  FMediaPlayer.Close;
end;

procedure TVCLTutorialHub.SetJSONRequest(const Value: string);
begin
  Memo2.Lines.Text := Value;
  Memo2.SelStart := 0;
  Application.ProcessMessages;
end;

procedure TVCLTutorialHub.SetJSONResponse(const Value: string);
begin
  Memo3.Lines.Text := Value;
  Memo2.SelStart := 0;
  Application.ProcessMessages;
end;

procedure TVCLTutorialHub.SetMemo1(const Value: TMemo);
begin
  FMemo1 := Value;
  FMemo1.ScrollBars := TScrollStyle.ssVertical;
end;

procedure TVCLTutorialHub.SetMemo2(const Value: TMemo);
begin
  FMemo2 := Value;
  FMemo2.ScrollBars := TScrollStyle.ssBoth;
end;

procedure TVCLTutorialHub.SetMemo3(const Value: TMemo);
begin
  FMemo3 := Value;
  FMemo3.ScrollBars := TScrollStyle.ssBoth;
end;

procedure TVCLTutorialHub.SpeechChat(const Value: string);
begin
  FileName := 'SpeechChat.mp3';

  //Asynchronous example
  Client.Chat.AsynCreate(
    procedure (Params: TChatParams)
    begin
      Params.Model('gpt-4o-audio-preview');
      Params.Modalities(['text', 'audio']);
      Params.Audio('ash', 'mp3');
      Params.Messages([
        FromUser(Value)
      ]);
      Params.MaxCompletionTokens(1024);
    end,
    function : TAsynChat
    begin
      Result.Sender := TutorialHub;
      Result.OnSuccess := DisplayAudio;
      Result.OnError := Display;
    end);
end;

initialization
finalization
  if Assigned(TutorialHub) then
    TutorialHub.Free;
end.

unit GenAI.Types;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.TypInfo, System.Variants, System.Rtti, GenAI.Consts,
  GenAI.API.Params;

{$SCOPEDENUMS ON}

type
  TIntegerOrNull = type Variant;

  TIntegerOrNullHelper = record Helper for TIntegerOrNull
    constructor Create(const Value: Variant);
    function isNull: Boolean;
    function ToInteger: Integer;
    function ToString: string;
  end;

  TInt64OrNull = type Variant;

  TInt64OrNullHelper = record Helper for TInt64OrNull
    constructor Create(const Value: Variant);
    function isNull: Boolean;
    function ToUtcDateString: string;
    function ToInteger: Int64;
    function ToString: string;
  end;

  TDoubleOrNull = type Variant;

  TDoubleOrNullHelper = record Helper for TDoubleOrNull
    constructor Create(const Value: Variant);
    function isNull: Boolean;
    function ToDouble: Double;
    function ToString: string;
  end;

  TBooleanOrNull = type Variant;

  TBooleanOrNullHelper = record Helper for TBooleanOrNull
    constructor Create(const Value: Variant);
    function isNull: Boolean;
    function ToBoolean: Boolean;
    function ToString: string;
  end;

  TStringOrNull = type Variant;

  TStringOrNullHelper = record Helper for TStringOrNull
    constructor Create(const Value: Variant);
    function isNull: Boolean;
    function ToString: string;
  end;

  TMetadataInterceptor = class(TJSONInterceptorStringToString)
  public
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  {$REGION 'GenAI.Batch.Interfaces'}

  /// <summary>
  /// Enumerates the supported relative URLs for OpenAI's batch processing API.
  /// </summary>
  /// <remarks>
  /// The <c>TBatchUrl</c> type defines the specific endpoints that can be used when constructing
  /// batch requests to OpenAI's API. Each enumeration value corresponds to a relative URL path
  /// for a particular API functionality.
  /// </remarks>
  TBatchUrl = (
    /// <summary>
    /// Represents the relative URL for the Chat Completions endpoint.
    /// </summary>
    chat_completions,
    /// <summary>
    /// Represents the relative URL for the Embeddings endpoint.
    /// </summary>
    embeddings
  );

  TBatchUrlHelper = record Helper for TBatchUrl
    constructor Create(const Value: string);
    function ToString: string;
  end;

  {$ENDREGION}

  {$REGION 'GenAI.Schema'}

  /// <summary>
  /// Type contains the list of OpenAPI data types as defined by :
  /// <para>
  /// - https://spec.openapis.org/oas/v3.0.3#data-types
  /// </para>
  /// </summary>
  TSchemaType = (
    /// <summary>
    /// Not specified, should not be used.
    /// </summary>
    unspecified,
    /// <summary>
    /// String type.
    /// </summary>
    &string,
    /// <summary>
    /// Number type.
    /// </summary>
    number,
    /// <summary>
    /// Integer type.
    /// </summary>
    &integer,
    /// <summary>
    /// Boolean type.
    /// </summary>
    &boolean,
    /// <summary>
    /// Array type.
    /// </summary>
    &array,
    /// <summary>
    /// Object type.
    /// </summary>
    &object
  );

  TSchemaTypeHelper = record Helper for TSchemaType
    constructor Create(const Value: string);
    function ToString: string;
  end;

  {$ENDREGION}

  {$REGION 'GenAI.Chat'}

  /// <summary>
  /// Specifies the roles used in the chat-based API to define the behavior
  /// and context of messages exchanged between the user and the model.
  /// </summary>
  /// <remarks>
  /// The roles help structure the conversation and guide the model's
  /// responses by assigning different functions to the participants.
  /// Each role has a specific purpose and impact on how the model interprets
  /// the input and generates the output.
  /// </remarks>
  TRole = (
    /// <summary>
    /// Represents the model's responses generated during the conversation.
    /// </summary>
    /// <remarks>
    /// The assistant role is used to define messages that provide answers,
    /// clarifications, or actions requested by the user.
    /// </remarks>
    assistant,
    /// <summary>
    /// Represents messages sent by the end user of the model.
    /// </summary>
    /// <remarks>
    /// The user role defines the primary input for the model, often containing
    /// questions, instructions, or other prompts to request information or perform tasks.
    /// </remarks>
    user,
    /// <summary>
    /// Represents instructions or configuration defined by the developer.
    /// </summary>
    /// <remarks>
    /// The developer role, formerly known as the system role, sets the overarching
    /// behavior and tone of the model. These instructions are prioritized and guide
    /// the model in interpreting and responding to user inputs.
    /// </remarks>
    developer,
    /// <summary>
    /// Represents the system-level instructions or metadata.
    /// </summary>
    /// <remarks>
    /// The system role is typically used to define the broader behavior and
    /// system-level rules for the chat interactions. It influences the entire
    /// conversation at a higher level.
    /// </remarks>
    system,
    /// <summary>
    /// Represents a tool or action within the context of the conversation.
    /// </summary>
    /// <remarks>
    /// The tool role indicates the invocation of external tools or systems
    /// to supplement the model's functionality. It is commonly used for
    /// retrieval, calculations, or integration with external APIs.
    /// </remarks>
    tool
  );

  TRoleHelper = record Helper for TRole
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TRoleInterceptor = class(TJSONInterceptorStringToString)
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Specifies the audio formats available for input and output operations
  /// when using audio-related functionalities in the model.
  /// </summary>
  /// <remarks>
  /// The TAudioFormat enumeration defines the supported audio formats
  /// that can be used for audio input and output. Some formats are available
  /// for both input and output, while others are restricted to output only.
  /// </remarks>
  TAudioFormat = (
    /// <summary>
    /// Waveform Audio File Format (WAV).
    /// </summary>
    /// <remarks>
    /// This format is uncompressed and provides high-quality audio.
    /// It is supported for both input and output operations.
    /// </remarks>
    wav,
    /// <summary>
    /// MPEG Layer III Audio (MP3).
    /// </summary>
    /// <remarks>
    /// This is a compressed audio format widely used for its smaller file size
    /// while retaining acceptable quality. It is supported for both input and output operations.
    /// </remarks>
    mp3,
    /// <summary>
    /// Free Lossless Audio Codec (FLAC).
    /// </summary>
    /// <remarks>
    /// This is a lossless audio compression format that maintains
    /// the highest quality without loss of fidelity. It is supported only for output operations.
    /// </remarks>
    flac,
    /// <summary>
    /// Opus Audio Codec (OPUS).
    /// </summary>
    /// <remarks>
    /// A highly efficient codec designed for interactive speech and music transmission.
    /// It provides excellent audio quality at low bitrates. It is supported only for output operations.
    /// </remarks>
    opus,
    /// <summary>
    /// Pulse Code Modulation 16-bit (PCM16).
    /// </summary>
    /// <remarks>
    /// A raw, uncompressed audio format often used for high-quality audio
    /// processing. It is supported only for output operations.
    /// </remarks>
    pcm16
  );

  TAudioFormatHelper = record Helper for TAudioFormat
    constructor Create(const Value: string);
    function ToString: string;
    class function MimeTypeInput(const Value: string): TAudioFormat; static;
  end;

  /// <summary>
  /// Specifies the level of detail for images used in chat completion requests.
  /// </summary>
  /// <remarks>
  /// The TImageDetail enumeration defines the supported levels of detail for images
  /// provided as input in chat completions. Adjusting the detail level influences how
  /// much information is extracted or emphasized in the processing of the image.
  /// </remarks>
  TImageDetail = (
    /// <summary>
    /// Low - A lower level of image detail.
    /// </summary>
    /// <remarks>
    /// The low detail level processes images with reduced focus on finer details,
    /// resulting in faster processing times. This setting is suitable for simple
    /// images or scenarios where fine-grained information is not critical.
    /// </remarks>
    low,
    /// <summary>
    /// High - A higher level of image detail.
    /// </summary>
    /// <remarks>
    /// The high detail level processes images with greater attention to finer details,
    /// enabling more precise interpretation or generation. This setting is ideal for
    /// complex images or when accuracy and detail are important.
    /// </remarks>
    high,
    /// <summary>
    /// Auto - Automatically determines the level of image detail.
    /// </summary>
    /// <remarks>
    /// The auto setting allows the model to dynamically choose the appropriate level
    /// of detail based on the input image and context. This is the default option,
    /// balancing processing time and detail extraction.
    /// </remarks>
    auto
  );

  TImageDetailHelper = record Helper for TImageDetail
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TImageDetailInterceptor = class(TJSONInterceptorStringToString)
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Specifies the level of reasoning effort used by the o1 series models during a completion request.
  /// </summary>
  /// <remarks>
  /// The TReasoningEffort enumeration defines the complexity and depth of reasoning the model applies
  /// to generate responses. The reasoning effort impacts both the latency and the number of reasoning tokens generated.
  /// </remarks>
  TReasoningEffort = (
    /// <summary>
    /// Low - Minimal reasoning effort.
    /// </summary>
    /// <remarks>
    /// This level of reasoning is suitable for straightforward tasks that require little to no complex thinking.
    /// It minimizes the number of reasoning tokens generated, resulting in faster responses and lower costs.
    /// </remarks>
    low,
    /// <summary>
    /// Medium - Moderate reasoning effort.
    /// </summary>
    /// <remarks>
    /// This level strikes a balance between speed and complexity. It is ideal for tasks that require some
    /// level of logical reasoning, such as basic coding, problem-solving, or general explanations.
    /// </remarks>
    medium,
    /// <summary>
    /// High - Advanced reasoning effort.
    /// </summary>
    /// <remarks>
    /// This level is designed for complex reasoning tasks, such as solving advanced mathematical problems,
    /// implementing intricate algorithms, or addressing challenging scientific questions.
    /// High reasoning effort generates more reasoning tokens and requires longer processing times,
    /// which may result in higher costs.
    /// </remarks>
    high
  );

  TReasoningEffortHelper = record Helper for TReasoningEffort
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TReasoningEffortInterceptor = class(TJSONInterceptorStringToString)
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Specifies the supported input and output modalities for the GPT-4o-audio-preview model.
  /// </summary>
  /// <remarks>
  /// The TModalities enumeration defines the types of data that the model can process
  /// as input or generate as output. The current supported modalities are text and audio,
  /// which can be used in various combinations to create flexible interaction patterns.
  /// </remarks>
  TModalities = (
    /// <summary>
    /// Text - The model processes or generates text as input or output.
    /// </summary>
    /// <remarks>
    /// Text is the default modality for many tasks, allowing for both textual input
    /// prompts and output responses. It is often used in scenarios where precise
    /// communication or reasoning is required.
    /// </remarks>
    text,
    /// <summary>
    /// Audio - The model processes or generates audio as input or output.
    /// </summary>
    /// <remarks>
    /// Audio allows for spoken input to be transcribed into text or for generating
    /// speech output. This modality is ideal for voice-based applications,
    /// transcription tasks, or scenarios requiring audio responses.
    /// </remarks>
    audio
  );

  TModalitiesHelper = record Helper for TModalities
    constructor Create(const Value: string);
    function ToString: string;
  end;

  /// <summary>
  /// Specifies the available voice options for audio responses generated by the model.
  /// </summary>
  /// <remarks>
  /// The TChatVoice enumeration defines a set of expressive and natural-sounding
  /// voices that can be used to personalize the audio output. While most voices
  /// are recommended for high-quality and expressive output, some legacy voices
  /// are supported but may have reduced expressiveness.
  /// </remarks>
  TChatVoice = (
    /// <summary>
    /// Ash - A neutral and balanced voice suitable for a wide range of contexts.
    /// </summary>
    /// <remarks>
    /// Ash provides clear and steady speech output, making it ideal for general use.
    /// This voice maintains a professional and neutral tone.
    /// </remarks>
    ash,
    /// <summary>
    /// Ballad - A warm and melodious voice designed for expressive communication.
    /// </summary>
    /// <remarks>
    /// Ballad excels at creating engaging and emotional tones, often preferred for
    /// storytelling, customer support, or other contexts requiring a softer and friendlier style.
    /// </remarks>
    ballad,
    /// <summary>
    /// Coral - A vibrant and energetic voice designed to convey enthusiasm.
    /// </summary>
    /// <remarks>
    /// Coral is ideal for use cases that require a lively and dynamic tone,
    /// such as promotional content or upbeat messaging.
    /// </remarks>
    coral,
    /// <summary>
    /// Sage - A calm and soothing voice that emphasizes clarity and relaxation.
    /// </summary>
    /// <remarks>
    /// Sage is perfect for applications such as guided meditations, instructions,
    /// or any scenario that benefits from a tranquil and reassuring voice.
    /// </remarks>
    sage,
    /// <summary>
    /// Verse - A rich and articulate voice with a refined and formal tone.
    /// </summary>
    /// <remarks>
    /// Verse is well-suited for professional or educational use cases where
    /// precision and clarity are critical.
    /// </remarks>
    verse
  );

  TChatVoiceHelper = record Helper for TChatVoice
    constructor Create(const Value: string);
    function ToString: string;
  end;

  /// <summary>
  /// Specifies the behavior of the model regarding the use of tools during execution.
  /// </summary>
  /// <remarks>
  /// The TToolChoice enumeration defines how the model interacts with tools, such as functions,
  /// during the generation of responses. It allows you to control whether the model uses tools
  /// and how it decides to call them.
  /// </remarks>
  TToolChoice = (
    /// <summary>
    /// None - The model will not call any tools and will generate a direct message instead.
    /// </summary>
    /// <remarks>
    /// Use this option when you want the model to generate responses purely from its own reasoning
    /// and avoid any interaction with tools or external functions.
    /// This is the default behavior when no tools are present.
    /// </remarks>
    none,
    /// <summary>
    /// Auto - The model can decide whether to generate a message or call one or more tools.
    /// </summary>
    /// <remarks>
    /// This option provides the model with flexibility to determine the best course of action
    /// based on the input and available tools. It is the default behavior when tools are present.
    /// </remarks>
    auto,
    /// <summary>
    /// Required - The model must call one or more tools during execution.
    /// </summary>
    /// <remarks>
    /// Use this option when tool usage is mandatory for the task at hand. The model will
    /// strictly adhere to calling the tools specified and will not generate a direct message
    /// without doing so.
    /// </remarks>
    required);

  TToolChoiceHelper = record Helper for TToolChoice
    constructor Create(const Value: string);
    function ToString: string;
  end;

  /// <summary>
  /// Specifies the reasons why the model stopped generating tokens during a chat completion response.
  /// </summary>
  /// <remarks>
  /// The TFinishReason enumeration represents the various conditions under which the model concludes
  /// token generation. It provides insight into whether the stop was expected, due to a limitation, or
  /// triggered by a specific event.
  /// </remarks>
  TFinishReason = (
    /// <summary>
    /// Stop - The model reached a natural stop point or a specified stop sequence.
    /// </summary>
    /// <remarks>
    /// This is the most common reason for completion and indicates that the model
    /// has successfully generated a complete response as intended.
    /// </remarks>
    stop,
    /// <summary>
    /// Length - The model stopped because the maximum token limit was reached.
    /// </summary>
    /// <remarks>
    /// This occurs when the token count exceeds the maximum specified in the request.
    /// The response may be incomplete, and increasing the token limit could yield
    /// a more complete result.
    /// </remarks>
    length,
    /// <summary>
    /// Content_Filter - The model omitted content due to a flag triggered by content filters.
    /// </summary>
    /// <remarks>
    /// This reason indicates that the generated content was flagged as potentially
    /// violating safety or policy guidelines. The response may have been modified
    /// or truncated to comply with content standards.
    /// </remarks>
    content_filter,
    /// <summary>
    /// Tool_Calls - The model stopped because it invoked a tool or function.
    /// </summary>
    /// <remarks>
    /// This reason indicates that the model has delegated part of the task to an
    /// external tool or function. The tool or function may provide supplementary
    /// data or complete the response on behalf of the model.
    /// </remarks>
    tool_calls
  );

  TFinishReasonHelper = record Helper for TFinishReason
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TFinishReasonInterceptor = class(TJSONInterceptorStringToString)
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Specifies the types of tools the model can call during execution.
  /// </summary>
  /// <remarks>
  /// The TToolCalls enumeration defines the supported types of tools that the model
  /// can invoke during the generation of responses. Currently, only the "function"
  /// tool type is supported, which allows the model to generate JSON inputs for specific functions.
  /// </remarks>
  TToolCalls = (
    /// <summary>
    /// Function - Represents a callable function tool.
    /// </summary>
    /// <remarks>
    /// The function type enables the model to interact with developer-defined functions by
    /// generating JSON inputs. Functions can be used to extend the model's capabilities,
    /// such as performing calculations, retrieving data, or triggering external processes.
    /// </remarks>
    tfunction
  );

  TToolCallsHelper = record Helper for TToolCalls
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TToolCallsInterceptor = class(TJSONInterceptorStringToString)
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// High level guidance for the amount of context window space to use for the search.
  /// </summary>
  TSearchWebOptions = (
    /// <summary>
    /// Least context, lowest cost, fastest response, but potentially lower answer quality.
    /// </summary>
    low,
    /// <summary>
    /// (default): Balanced context, cost, and latency.
    /// </summary>
    medium,
    /// <summary>
    /// Most comprehensive context, highest cost, slower response.
    /// </summary>
    high
  );

  TSearchWebOptionsHelper = record Helper for TSearchWebOptions
    constructor Create(const Value: string);
    function ToString: string;
  end;

  {$ENDREGION}

  {$REGION 'GenAI.Audio'}

  /// <summary>
  /// Specifies the available voices for generating audio in text-to-speech (TTS) operations.
  /// </summary>
  /// <remarks>
  /// The TAudioVoice enumeration defines a range of voices that can be used to personalize
  /// the audio output for text-to-speech generation. Each voice offers unique characteristics
  /// and is suited for different use cases.
  /// </remarks>
type
  TAudioVoice = (
    /// <summary>
    /// Alloy - A basic and straightforward voice with minimal expressiveness.
    /// </summary>
    /// <remarks>
    /// Alloy is suitable for simple applications or when a neutral tone is sufficient.
    /// It is less expressive compared to the more advanced voices.
    /// </remarks>
    alloy,
    /// <summary>
    /// Ash - A versatile and balanced voice suitable for general purposes.
    /// </summary>
    /// <remarks>
    /// Ash provides a clear and steady tone, making it ideal for professional or
    /// everyday applications where clarity is important.
    /// </remarks>
    ash,
    /// <summary>
    /// Coral - A vibrant and expressive voice designed for energetic and engaging output.
    /// </summary>
    /// <remarks>
    /// Coral is perfect for scenarios where enthusiasm and energy are required,
    /// such as marketing or promotional audio content.
    /// </remarks>
    coral,
    /// <summary>
    /// Echo - A basic voice with minimal expressiveness, primarily for legacy support.
    /// </summary>
    /// <remarks>
    /// Echo may be used for simple or experimental applications, but it lacks
    /// the natural tone and advanced features of more expressive voices.
    /// </remarks>
    echo,
    /// <summary>
    /// Fable - A rich and storytelling-oriented voice with a warm and engaging tone.
    /// </summary>
    /// <remarks>
    /// Fable is ideal for use cases such as audiobooks, narrations, and other
    /// storytelling contexts where a captivating voice is essential.
    /// </remarks>
    fable,
    /// <summary>
    /// Onyx - A deep and authoritative voice with a commanding tone.
    /// </summary>
    /// <remarks>
    /// Onyx is well-suited for formal announcements, educational content, or any
    /// scenario requiring a strong and confident presence.
    /// </remarks>
    onyx,
    /// <summary>
    /// Nova - A bright and uplifting voice with a modern and youthful feel.
    /// </summary>
    /// <remarks>
    /// Nova is perfect for dynamic and contemporary use cases, such as product
    /// demos, explainer videos, or engaging digital content.
    /// </remarks>
    nova,
    /// <summary>
    /// Sage - A calm and soothing voice that emphasizes clarity and relaxation.
    /// </summary>
    /// <remarks>
    /// Sage is particularly effective for guided meditations, instructions, or
    /// any scenario requiring a tranquil and reassuring voice.
    /// </remarks>
    sage,
    /// <summary>
    /// Shimmer - A playful and expressive voice with a whimsical tone.
    /// </summary>
    /// <remarks>
    /// Shimmer is ideal for creative and imaginative contexts, such as children’s
    /// stories, games, or other lighthearted applications.
    /// </remarks>
    shimmer
  );

  TAudioVoiceHelper = record Helper for TAudioVoice
    constructor Create(const Value: string);
    function ToString: string;
  end;

  /// <summary>
  /// Specifies the audio formats available for speech output in text-to-speech (TTS) operations.
  /// </summary>
  /// <remarks>
  /// The TSpeechFormat enumeration defines the supported audio file formats for speech generation.
  /// Each format has unique characteristics that make it suitable for specific use cases, such as
  /// compatibility, compression, or audio quality.
  /// </remarks>
  TSpeechFormat = (
    /// <summary>
    /// MP3 - MPEG Layer III Audio.
    /// </summary>
    /// <remarks>
    /// A widely used compressed audio format known for its small file size and good quality.
    /// MP3 is compatible with almost all devices and applications, making it a versatile choice.
    /// </remarks>
    mp3,
    /// <summary>
    /// Opus - Opus Audio Codec.
    /// </summary>
    /// <remarks>
    /// A highly efficient audio codec optimized for interactive speech and music transmission.
    /// Opus provides excellent quality at low bitrates and is ideal for streaming or bandwidth-constrained applications.
    /// </remarks>
    opus,
    /// <summary>
    /// AAC - Advanced Audio Codec.
    /// </summary>
    /// <remarks>
    /// A compressed audio format offering better quality than MP3 at similar bitrates.
    /// AAC is widely used in modern devices and is commonly found in streaming services and mobile applications.
    /// </remarks>
    aac,
    /// <summary>
    /// FLAC - Free Lossless Audio Codec.
    /// </summary>
    /// <remarks>
    /// A lossless compression format that preserves audio quality without sacrificing any fidelity.
    /// FLAC is suitable for high-quality audio applications where accuracy and detail are critical.
    /// </remarks>
    flac,
    /// <summary>
    /// WAV - Waveform Audio File Format.
    /// </summary>
    /// <remarks>
    /// An uncompressed audio format that offers the highest quality.
    /// WAV is commonly used in professional audio editing, mastering, and archival purposes due to its raw data fidelity.
    /// </remarks>
    wav,
    /// <summary>
    /// PCM - Pulse Code Modulation.
    /// </summary>
    /// <remarks>
    /// A raw, uncompressed audio format that directly represents sound waveforms.
    /// PCM is often used in professional audio systems and processing where raw, high-quality audio data is needed.
    /// </remarks>
    pcm
  );

  TSpeechFormatHelper = record Helper for TSpeechFormat
    constructor Create(const Value: string);
    function ToString: string;
  end;

  /// <summary>
  /// Specifies the available output formats for transcription responses.
  /// </summary>
  /// <remarks>
  /// The TTranscriptionResponseFormat enumeration defines the formats in which
  /// the transcription results can be returned. Different formats are suited for
  /// various use cases, such as simple text outputs, detailed JSON structures,
  /// or subtitle files for video applications.
  /// </remarks>
  TTranscriptionResponseFormat = (
    /// <summary>
    /// JSON - A structured format containing transcription data in JSON.
    /// </summary>
    /// <remarks>
    /// This format provides a detailed and structured output, making it suitable
    /// for programmatic parsing and integration with systems that require data
    /// in JSON format.
    /// </remarks>
    json,
    /// <summary>
    /// Text - A plain text format containing only the transcription.
    /// </summary>
    /// <remarks>
    /// This format outputs the transcription as a simple text string, ideal for
    /// scenarios where minimal formatting and simplicity are required.
    /// </remarks>
    text,
    /// <summary>
    /// SRT - SubRip Subtitle format for captions.
    /// </summary>
    /// <remarks>
    /// This format generates subtitles with timestamps in the widely used SRT
    /// format, which can be easily used for video captioning or subtitling.
    /// </remarks>
    srt,
    /// <summary>
    /// Verbose_JSON - A detailed JSON format with timestamps and additional metadata.
    /// </summary>
    /// <remarks>
    /// This format provides comprehensive transcription details, including word-level
    /// or segment-level timestamps (if enabled). It is ideal for applications requiring
    /// granular control or analysis of transcription data.
    /// </remarks>
    verbose_json,
    /// <summary>
    /// VTT - Web Video Text Tracks format for captions.
    /// </summary>
    /// <remarks>
    /// This format outputs captions in the VTT format, which is compatible with
    /// web-based video players and other applications requiring timed captions.
    /// </remarks>
    vtt
  );

  TTranscriptionResponseFormatHelper = record Helper for TTranscriptionResponseFormat
    constructor Create(const Value: string);
    function ToString: string;
  end;

  {$ENDREGION}

  {$REGION 'GenAI.Embeddings'}

  /// <summary>
  /// Specifies the available encoding formats for embeddings in the API response.
  /// </summary>
  /// <remarks>
  /// The TEncodingFormat enumeration defines the formats in which the embedding vectors
  /// can be returned. Each format serves different purposes depending on the use case,
  /// such as numerical computation or compact representation.
  /// </remarks>
  TEncodingFormat = (
    /// <summary>
    /// Float - The embeddings are returned as an array of floating-point numbers.
    /// </summary>
    /// <remarks>
    /// This format provides the embeddings as precise numerical data, suitable for
    /// direct computation, mathematical operations, or integration into machine
    /// learning pipelines. It is the default and most commonly used format.
    /// </remarks>
    float,
    /// <summary>
    /// Base64 - The embeddings are returned as a base64-encoded string.
    /// </summary>
    /// <remarks>
    /// This format provides the embeddings as a compact base64-encoded string,
    /// which is ideal for storage or transmission where raw numerical data
    /// is not practical. The base64 format can be decoded to retrieve the original
    /// floating-point array if needed.
    /// </remarks>
    base64
  );

  TEncodingFormatHelper = record Helper for TEncodingFormat
    constructor Create(const Value: string);
    function ToString: string;
  end;

  {$ENDREGION}

  {$REGION 'GenAI.Moderation'}

  THarmCategories = (
    hate,
    hateThreatening,
    harassment,
    harassmentThreatening,
    illicit,
    illicitViolent,
    selfHarm,
    selfHarmIntent,
    selfHarmInstructions,
    sexual,
    sexualMinors,
    violence,
    violenceGraphic
  );

  THarmCategoriesHelper = record Helper for THarmCategories
    function ToString: string;
    class function Create(const Value: string): TEncodingFormat; static;
  end;

  {$ENDREGION}

  {$REGION 'GenAI.Images'}

  /// <summary>
  /// Specifies the format of the response for image generation requests.
  /// </summary>
  /// <remarks>
  /// The TResponseFormat enumeration defines the output format for images generated by the API.
  /// Depending on the use case, the images can be returned as a URL pointing to the generated image
  /// or as a base64-encoded JSON string.
  /// </remarks>
  TResponseFormat = (
    /// <summary>
    /// URL - The generated image is returned as a URL.
    /// </summary>
    /// <remarks>
    /// This is the default format for responses. The API returns a URL pointing to the
    /// generated image, which can be accessed directly via a browser or used in applications.
    /// This format is ideal for immediate use or display of the image.
    /// </remarks>
    url,
    /// <summary>
    /// B64_JSON - The generated image is returned as a base64-encoded JSON string.
    /// </summary>
    /// <remarks>
    /// This format provides the image content encoded as a base64 string within a JSON object.
    /// It is suitable for scenarios where the image needs to be embedded directly in another
    /// application, stored inline, or transmitted without relying on external URLs.
    /// </remarks>
    b64_json
  );

  TResponseFormatHelper = record Helper for TResponseFormat
    constructor Create(const Value: string);
    function ToString: string;
  end;

  /// <summary>
  /// Specifies the size of the images generated by the API.
  /// </summary>
  /// <remarks>
  /// The TImageSize enumeration defines the supported dimensions for generated images.
  /// The available sizes depend on the specific model being used (e.g., DALL-E 2 or DALL-E 3).
  /// Choosing the appropriate size affects the resolution and level of detail in the output image.
  /// </remarks>
  TImageSize = (
    /// <summary>
    /// 256x256 - A small square image with dimensions 256x256 pixels.
    /// </summary>
    /// <remarks>
    /// This size is suitable for low-resolution requirements or scenarios where small,
    /// compact images are needed, such as thumbnails or icons. Supported in DALL-E 2.
    /// </remarks>
    r256x256,
    /// <summary>
    /// 512x512 - A medium square image with dimensions 512x512 pixels.
    /// </summary>
    /// <remarks>
    /// This size provides a balance between resolution and file size, making it useful
    /// for general-purpose applications or when moderate detail is sufficient. Supported in DALL-E 2.
    /// </remarks>
    r512x512,
    /// <summary>
    /// 1024x1024 - A high-resolution square image with dimensions 1024x1024 pixels.
    /// </summary>
    /// <remarks>
    /// This is the default size for image generation and is suitable for scenarios
    /// requiring high detail and clarity. Supported in both DALL-E 2 and DALL-E 3.
    /// </remarks>
    r1024x1024,
    /// <summary>
    /// 1792x1024 - A wide rectangular image with dimensions 1792x1024 pixels.
    /// </summary>
    /// <remarks>
    /// This size is designed for applications requiring a landscape-oriented image
    /// with higher resolution and detail. Supported in DALL-E 3.
    /// </remarks>
    r1792x1024,
    /// <summary>
    /// 1024x1792 - A tall rectangular image with dimensions 1024x1792 pixels.
    /// </summary>
    /// <remarks>
    /// This size is ideal for portrait-oriented applications, such as posters,
    /// banners, or artwork. Supported in DALL-E 3.
    /// </remarks>
    r1024x1792,
    /// <summary>
    /// landscape
    /// </summary>
    /// <remarks>
    /// Only for gpt-image-1
    /// </remarks>
    r1536x1024,
    /// <summary>
    /// portrait
    /// </summary>
    /// <remarks>
    /// Only for gpt-image-1
    /// </remarks>
    r1024x1536
  );

  TImageSizeHelper = record Helper for TImageSize
    constructor Create(const Value: string);
    function ToString: string;
  end;

  /// <summary>
  /// Specifies the style of the images generated by the API.
  /// </summary>
  /// <remarks>
  /// The TImageStyle enumeration defines the visual style of the generated images.
  /// Each style influences the appearance and artistic qualities of the output,
  /// allowing developers to customize the aesthetic based on their needs.
  /// This parameter is only supported for DALL-E 3 models.
  /// </remarks>
  TImageStyle = (
    /// <summary>
    /// Vivid - A hyper-real and dramatic visual style.
    /// </summary>
    /// <remarks>
    /// The vivid style generates images with striking, vibrant colors and
    /// high contrast. This style is ideal for creating bold and visually impactful
    /// artwork or content that demands attention.
    /// </remarks>
    vivid,
    /// <summary>
    /// Natural - A realistic and less hyper-realistic visual style.
    /// </summary>
    /// <remarks>
    /// The natural style focuses on producing images with a more subdued,
    /// lifelike appearance. This style is well-suited for applications requiring
    /// realistic representations, such as illustrations or content with a professional tone.
    /// </remarks>
    natural
  );

  TImageStyleHelper = record Helper for TImageStyle
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TBackGroundType = (
    transparent,
    opaque,
    auto
  );

  TBackGroundTypeHelper = record Helper for TBackGroundType
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TImageModerationType = (
    low,
    auto
  );

  TImageModerationTypeHelper = record Helper for TImageModerationType
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TOutputFormatType = (
    png,
    jpeg,
    webp
  );

  TOutputFormatTypeHelper = record Helper for TOutputFormatType
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TImageQualityType = (
    /// <summary>
    /// Only for gpt-image-1
    /// </summary>
    high,
    /// <summary>
    /// Only for gpt-image-1
    /// </summary>
    medium,
    /// <summary>
    /// Only for gpt-image-1
    /// </summary>
    low,
    /// <summary>
    /// Only for dall-e-2
    /// </summary>
    standard,
    /// <summary>
    /// Defaults to auto
    /// </summary>
    auto
  );

  TImageQualityTypeHelper = record Helper for TImageQualityType
    constructor Create(const Value: string);
    function ToString: string;
  end;

  {$ENDREGION}

  {$REGION 'GenAI.Files'}

  /// <summary>
  /// Specifies the intended purpose of a file uploaded to the OpenAI API.
  /// </summary>
  /// <remarks>
  /// The TFilesPurpose enumeration defines the various use cases for uploaded files.
  /// Each purpose aligns with a specific functionality or endpoint within the API,
  /// such as fine-tuning, batch processing, or providing input for assistants.
  /// </remarks>
  TFilesPurpose = (
    /// <summary>
    /// Assistants - Used for input files for Assistants and Message API.
    /// </summary>
    /// <remarks>
    /// Files uploaded with this purpose are intended to serve as input for the
    /// Assistants API, which supports various modalities such as text, images,
    /// and audio. Examples include text prompts or image files.
    /// </remarks>
    assistants,
    /// <summary>
    /// Assistants_Output - Used for output files from the Assistants API.
    /// </summary>
    /// <remarks>
    /// This purpose is used for storing output files generated by the Assistants API.
    /// Examples include transcription results or image generation results.
    /// </remarks>
    assistants_output,
    /// <summary>
    /// Batch - Used for input files for the Batch API.
    /// </summary>
    /// <remarks>
    /// Files uploaded with this purpose are meant for batch processing tasks.
    /// These files typically contain .jsonl formatted data for tasks requiring
    /// bulk processing.
    /// </remarks>
    batch,
    /// <summary>
    /// Batch_Output - Used for output files generated by the Batch API.
    /// </summary>
    /// <remarks>
    /// This purpose is used to store results from batch processing tasks, such as
    /// processed outputs from bulk data uploads.
    /// </remarks>
    batch_output,
    /// <summary>
    /// Fine-Tune - Used for input files for fine-tuning models.
    /// </summary>
    /// <remarks>
    /// Files uploaded with this purpose must be in .jsonl format and meet
    /// specific requirements for fine-tuning models. These files provide
    /// the training data for creating customized models.
    /// </remarks>
    finetune,
    /// <summary>
    /// Fine-Tune_Results - Used for results files generated from fine-tuning jobs.
    /// </summary>
    /// <remarks>
    /// This purpose is used for files containing the output of fine-tuning processes,
    /// such as evaluation results or metrics derived from the training process.
    /// </remarks>
    finetune_results,
    /// <summary>
    /// Vision - Used for image input files in vision-related tasks.
    /// </summary>
    /// <remarks>
    /// Files uploaded with this purpose are intended for vision tasks supported
    /// by the Assistants API, such as image analysis or processing.
    /// </remarks>
    vision,
    /// <summary>
    /// Used for eval data sets
    /// </summary>
    evals,
    /// <summary>
    /// Flexible file type for any purpose
    /// </summary>
    user_data
  );

  TFilesPurposeHelper = record Helper for TFilesPurpose
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TFilesPurposeInterceptor = class(TJSONInterceptorStringToString)
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  {$ENDREGION}

  {$REGION 'GenAI.Batch'}

  /// <summary>
  /// Enumerates the possible statuses of a batch operation, describing each stage
  /// from validation to completion or cancellation.
  /// </summary>
  TBatchStatus = (
    /// <summary>
    /// The input file is being validated before the batch can begin.
    /// This is the initial stage where inputs are checked for correctness.
    /// </summary>
    validating,
    /// <summary>
    /// The input file has failed the validation process.
    /// This status indicates an error in the input data that prevents the batch from proceeding.
    /// </summary>
    failed,
    /// <summary>
    /// The input file was successfully validated and the batch is currently being run.
    /// Processing of the batch data is underway.
    /// </summary>
    in_progress,
    /// <summary>
    /// The batch has completed and the results are being prepared.
    /// This stage signifies that the main processing is done but the output is not yet finalized.
    /// </summary>
    finalizing,
    /// <summary>
    /// The batch has been completed and the results are ready.
    /// Indicates that all processing has concluded successfully and the outputs are available for use.
    /// </summary>
    completed,
    /// <summary>
    /// The batch was not able to be completed within the 24-hour time window.
    /// This status is used when the processing time exceeds the maximum allowed duration.
    /// </summary>
    expired,
    /// <summary>
    /// The batch is being cancelled (may take up to 10 minutes).
    /// During this time, the system is terminating any ongoing operations related to the batch.
    /// </summary>
    cancelling,
    /// <summary>
    /// The batch was cancelled.
    /// This final status confirms that the batch has been successfully stopped before completion.
    /// </summary>
    cancelled
  );

  TBatchStatusHelper = record Helper for TBatchStatus
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TBatchStatusInterceptor = class(TJSONInterceptorStringToString)
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  {$ENDREGION}

  {$REGION 'GenAI.FineTuning'}

  TJobMethodType = (
    supervised,
    dpo
  );

  TJobMethodTypeHHelper = record Helper for TJobMethodType
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TJobMethodTypeInterceptor = class(TJSONInterceptorStringToString)
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  TFineTunedStatus = (
    validating_files,
    queued,
    running,
    succeeded,
    failed,
    cancelled
  );

  TFineTunedStatusHelper = record Helper for TFineTunedStatus
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TFineTunedStatusInterceptor = class(TJSONInterceptorStringToString)
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  {$ENDREGION}

  {$REGION 'GenAI.Assistants'}

  TAssistantsToolsType = (
    code_interpreter,
    file_search,
    &function
  );

  TAssistantsToolsTypeHelper = record Helper for TAssistantsToolsType
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TAssistantsToolsTypeInterceptor = class(TJSONInterceptorStringToString)
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  TChunkingStrategyType = (
    auto,
    &static
  );

  TChunkingStrategyTypeHelper = record Helper for TChunkingStrategyType
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TResponseFormatType = (
    auto,
    text,
    json_object,
    json_schema
  );

  TResponseFormatTypeHelper = record Helper for TResponseFormatType
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TResponseFormatTypeInterceptor = class(TJSONInterceptorStringToString)
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  {$ENDREGION}

  {$REGION 'GenAI.Assistants'}

  TThreadsContentType = (
    text,
    image_url,
    image_file
  );

  TThreadsContentTypeHelper = record Helper for TThreadsContentType
    constructor Create(const Value: string);
    function ToString: string;
  end;

  {$ENDREGION}

  {$REGION 'GenAI.Messages'}

  TMessageStatus = (
    in_progress,
    incomplete,
    completed
  );

  TMessageStatusHelper = record Helper for TMessageStatus
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TMessageStatusInterceptor = class(TJSONInterceptorStringToString)
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  {$ENDREGION}

  {$REGION 'GenAI.Runs'}

  TTruncationStrategyType = (
    auto,
    last_messages
  );

  TTruncationStrategyTypeHelper = record Helper for TTruncationStrategyType
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TTruncationStrategyTypeInterceptor = class(TJSONInterceptorStringToString)
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  TRunStatus = (
    queued,
    in_progress,
    requires_action,
    cancelling,
    cancelled,
    failed,
    completed,
    incomplete,
    expired
  );

  TRunStatusHelper = record Helper for TRunStatus
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TRunStatusInterceptor = class(TJSONInterceptorStringToString)
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  {$ENDREGION}

  {$REGION 'GenAI.RunSteps'}

  TRunStepType = (
    message_creation,
    tool_calls
  );

  TRunStepTypeHelper = record Helper for TRunStepType
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TRunStepTypeInterceptor = class(TJSONInterceptorStringToString)
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  {$ENDREGION}

  {$REGION 'GenAI.Responses'}

  TOutputIncluding = (
    /// <summary>
    /// Include the search results of the file search tool call.
    /// </summary>
    file_search_result,
    /// <summary>
    /// Include image urls from the input message.
    /// </summary>
    input_image_url,
    /// <summary>
    /// Include image urls from the computer call output.
    /// </summary>
    computer_call_image_url,
    /// <summary>
    /// Includes an encrypted version of reasoning tokens in reasoning item outputs. This enables reasoning
    /// items to be used in multi-turn conversations when using the Responses API statelessly (like when
    /// the store parameter is set to false, or when an organization is enrolled in the zero data retention
    /// program).
    /// </summary>
    reasoning_encrypted_content
  );

  TOutputIncludingHelper = record Helper for TOutputIncluding
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TReasoningGenerateSummary = (
    concise,
    detailed
  );

  TReasoningGenerateSummaryHelper = record Helper for TReasoningGenerateSummary
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TInputItemType = (
    input_text,
    input_image,
    input_file
  );

  TInputItemTypeHelper = record Helper for TInputItemType
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TFileSearchToolCallType = (
    in_progress,
    searching,
    incomplete,
    failed
  );

  TFileSearchToolCallTypeHelper = record Helper for TFileSearchToolCallType
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TFileSearchToolCallTypeInterceptor = class(TJSONInterceptorStringToString)
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  TMouseButton = (
    left,
    right,
    wheel,
    back,
    forward
  );

  TMouseButtonHelper = record Helper for TMouseButton
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TMouseButtonInterceptor = class(TJSONInterceptorStringToString)
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  TResponseOption = (
    text,
    json_schema,
    json_object
  );

  TResponseOptionHelper = record Helper for TResponseOption
    constructor Create(const Value: string);
    function ToString: string;
  end;

  THostedTooltype = (
    file_search,
    web_search_preview,
    computer_use_preview
  );

  THostedTooltypeHelper = record Helper for THostedTooltype
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TComparisonFilterType = (
    eq,
    ne,
    gt,
    gte,
    lt,
    lte
  );

  TComparisonFilterTypeHelper = record Helper for TComparisonFilterType
    constructor Create(const Value: string);
    function ToString: string;
    class function ToOperator(const Value: string): TComparisonFilterType; static;
  end;

  TCompoundFilterType = (
    &and,
    &or
  );

  TCompoundFilterTypeHelper = record Helper for TCompoundFilterType
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TWebSearchType = (
    web_search_preview,
    web_search_preview_2025_03_11
  );

  TWebSearchTypeHelper = record Helper for TWebSearchType
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TResponseTruncationType = (
    auto,
    disabled
  );

  TResponseTruncationTypeHelper = record Helper for TResponseTruncationType
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TResponseTypes = (
    message,
    file_search_call,
    function_call,
    web_search_call,
    computer_call,
    reasoning,
    computer_call_output,
    function_call_output
  );

  TResponseTypesHelper = record Helper for TResponseTypes
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TResponseTypesInterceptor = class(TJSONInterceptorStringToString)
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  TResponseContentType = (
    output_text,
    refusal,
    summary_text
  );

  TResponseContentTypeHelper = record Helper for TResponseContentType
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TResponseContentTypeInterceptor = class(TJSONInterceptorStringToString)
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  TResponseAnnotationType = (
    file_citation,
    url_citation,
    file_path
  );

  TResponseAnnotationTypeHelper = record Helper for TResponseAnnotationType
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TResponseAnnotationTypeInterceptor = class(TJSONInterceptorStringToString)
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  TResponseComputerType = (
    click,
    double_click,
    drag,
    keypress,
    move,
    screenshot,
    scroll,
    &type,
    wait
  );

  TResponseComputerTypeHelper = record Helper for TResponseComputerType
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TResponseComputerTypeInterceptor = class(TJSONInterceptorStringToString)
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  TResponseStatus = (
    in_progress,
    incomplete,
    completed,
    failed
  );

  TResponseStatusHelper = record Helper for TResponseStatus
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TResponseStatusInterceptor = class(TJSONInterceptorStringToString)
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  TResponseToolsType = (
    file_search,
    &function,
    computer_use_preview,
    web_search_preview,
    web_search_preview_2025_03_11
  );

  TResponseToolsTypeHelper = record Helper for TResponseToolsType
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TResponseToolsTypeInterceptor = class(TJSONInterceptorStringToString)
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  TResponseToolsFilterType = (
    eq,
    ne,
    gt,
    gte,
    lt,
    lte,
    &and,
    &or
  );

  TResponseToolsFilterTypeHelper = record Helper for TResponseToolsFilterType
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TResponseToolsFilterTypeInterceptor = class(TJSONInterceptorStringToString)
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  TResponseItemContentType = (
    input_text,
    input_image,
    input_file,
    output_text,
    refusal
  );

  TResponseItemContentTypeHelper = record Helper for TResponseItemContentType
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TResponseItemContentTypeInterceptor = class(TJSONInterceptorStringToString)
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  TResponseStreamType = (
    created,
    in_progress,
    completed,
    failed,
    incomplete,
    output_item_added,
    output_item_done,
    content_part_added,
    content_part_done,
    output_text_delta,
    output_text_annotation_added,
    output_text_done,
    refusal_delta,
    refusal_done,
    function_call_arguments_delta,
    function_call_arguments_done,
    file_search_call_in_progress,
    file_search_call_searching,
    file_search_call_completed,
    web_search_call_in_progress,
    web_search_call_searching,
    web_search_call_completed,

    reasoning_summary_part_add,
    reasoning_summary_part_done,
    reasoning_summary_text_delta,
    reasoning_summary_text_done,

    error
  );

  TResponseStreamTypeHelper = record Helper for TResponseStreamType
    constructor Create(const Value: string);
    function ToString: string;
  end;

  TResponseStreamTypeInterceptor = class(TJSONInterceptorStringToString)
    function StringConverter(Data: TObject; Field: string): string; override;
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  {$ENDREGION}

function TimestampToDateTime(const Value: Int64; const UTC: Boolean = False): TDateTime;
function TimestampToString(const Value: Int64; const UTC: Boolean = False): string;

var UtcTimestamp: Boolean = True;

implementation

uses
  System.StrUtils, System.DateUtils;

type
  TEnumValueRecovery = class
    class function TypeRetrieve<T>(const Value: string; const References: TArray<string>): T;
  end;

function TimestampToDateTime(const Value: Int64; const UTC: Boolean): TDateTime;
begin
  Result := UnixToDateTime(Value, UTC);
end;

 function TimestampToString(const Value: Int64; const UTC: Boolean): string;
begin
  {--- null date before 01/01/1970 }
  if Value <= 0 then
    Result := 'null' else
    Result := DateTimeToStr(TimestampToDateTime(Value, UTC))
end;

{ TEnumValueRecovery }

class function TEnumValueRecovery.TypeRetrieve<T>(const Value: string;
  const References: TArray<string>): T;
var
  pInfo: PTypeInfo;
begin
  pInfo := TypeInfo(T);
  if pInfo.Kind <> tkEnumeration then
    raise Exception.Create('TRecovery.TypeRetrieve<T>: T is not an enumerated type');

  var index := IndexStr(Value.ToLower, References);
  if index = -1 then
    raise Exception.CreateFmt('%s : Unable to retrieve enum value.', [Value]);

  Move(index, Result, SizeOf(Result));
end;

{ TRoleHelper }

constructor TRoleHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TRole>(Value,
            ['assistant', 'user', 'developer', 'system', 'tool']);
end;

function TRoleHelper.ToString: string;
begin
  case Self of
    TRole.assistant:
      Exit('assistant');
    TRole.user:
      Exit('user');
    TRole.developer:
      Exit('developer');
    TRole.system:
      Exit('system');
    TRole.tool:
      Exit('tool');
  end;
end;

{ TAudioFormatHelper }

constructor TAudioFormatHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TAudioFormat>(Value,
            ['wav', 'mp3', 'flac', 'opus', 'pcm16']);
end;

class function TAudioFormatHelper.MimeTypeInput(
  const Value: string): TAudioFormat;
begin
  Result := TEnumValueRecovery.TypeRetrieve<TAudioFormat>(Value, AudioTypeAccepted);
end;

function TAudioFormatHelper.ToString: string;
begin
  case Self of
    TAudioFormat.wav:
      Exit('wav');
    TAudioFormat.mp3:
      Exit('mp3');
    TAudioFormat.flac:
      Exit('flac');
    TAudioFormat.opus:
      Exit('opus');
    TAudioFormat.pcm16:
      Exit('pcm16');
  end;
end;

{ TImageDetailHelper }

constructor TImageDetailHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TImageDetail>(Value, ['low', 'high', 'auto']);
end;

function TImageDetailHelper.ToString: string;
begin
  case Self of
    TImageDetail.low:
      Exit('low');
    TImageDetail.high:
      Exit('high');
    TImageDetail.auto:
      Exit('auto');
  end;
end;

{ TImageDetailInterceptor }

function TImageDetailInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TImageDetail>.ToString;
end;

procedure TImageDetailInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TImageDetail.Create(Arg)));
end;

{ TReasoningEffortHelper }

constructor TReasoningEffortHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TReasoningEffort>(Value, ['low', 'medium', 'high']);
end;

function TReasoningEffortHelper.ToString: string;
begin
  case Self of
    TReasoningEffort.low:
      Exit('low');
    TReasoningEffort.medium:
      Exit('medium');
    TReasoningEffort.high:
      Exit('high');
  end;
end;

{ TReasoningEffortInterceptor }

function TReasoningEffortInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TReasoningEffort>.ToString;
end;

procedure TReasoningEffortInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TReasoningEffort.Create(Arg)));
end;

{ TModalitiesHelper }

constructor TModalitiesHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TModalities>(Value, ['text', 'audio']);
end;

function TModalitiesHelper.ToString: string;
begin
  case Self of
    TModalities.text:
      Exit('text');
    TModalities.audio:
      Exit('audio');
  end;
end;

{ TChatVoiceHelper }

constructor TChatVoiceHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TChatVoice>(Value,
            ['ash', 'ballad', 'coral', 'sage', 'verse']);
end;

function TChatVoiceHelper.ToString: string;
begin
  case Self of
    TChatVoice.ash:
      Exit('ash');
    TChatVoice.ballad:
      Exit('ballad');
    TChatVoice.coral:
      Exit('coral');
    TChatVoice.sage:
      Exit('sage');
    TChatVoice.verse:
      Exit('verse');
  end;
end;

{ TToolChoiceHelper }

constructor TToolChoiceHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TToolChoice>(Value, ['none', 'auto', 'required']);
end;

function TToolChoiceHelper.ToString: string;
begin
  case Self of
    TToolChoice.none:
      Exit('none');
    TToolChoice.auto:
      Exit('auto');
    TToolChoice.required:
      Exit('required');
  end;
end;

{ TFinishReasonHelper }

constructor TFinishReasonHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TFinishReason>(Value,
            ['stop', 'length', 'content_filter', 'tool_calls']);
end;

function TFinishReasonHelper.ToString: string;
begin
  case Self of
    TFinishReason.stop:
      Exit('stop');
    TFinishReason.length:
      Exit('length');
    TFinishReason.content_filter:
      Exit('content_filter');
    TFinishReason.tool_calls:
      Exit('tool_calls');
  end;
end;

{ TFinishReasonInterceptor }

function TFinishReasonInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TFinishReason>.ToString;
end;

procedure TFinishReasonInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TFinishReason.Create(Arg)));
end;

{ TRoleInterceptor }

function TRoleInterceptor.StringConverter(Data: TObject; Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TRole>.ToString;
end;

procedure TRoleInterceptor.StringReverter(Data: TObject; Field, Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TRole.Create(Arg)));
end;

{ TToolCallsHelper }

constructor TToolCallsHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TToolCalls>(Value, ['function']);
end;

function TToolCallsHelper.ToString: string;
begin
  case Self of
    TToolCalls.tfunction:
      Exit('function');
  end;
end;

{ TToolCallsInterceptor }

function TToolCallsInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TToolCalls>.ToString;
end;

procedure TToolCallsInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TToolCalls.Create(Arg)));
end;

{ TAudioVoiceHelper }

constructor TAudioVoiceHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TAudioVoice>(Value,
    ['alloy', 'ash', 'coral', 'echo', 'fable', 'onyx', 'nova', 'sage', 'shimmer']);
end;

function TAudioVoiceHelper.ToString: string;
begin
  case self of
    TAudioVoice.alloy:
      Exit('alloy');
    TAudioVoice.ash:
      Exit('ash');
    TAudioVoice.coral:
      Exit('coral');
    TAudioVoice.echo:
      Exit('echo');
    TAudioVoice.fable:
      Exit('fable');
    TAudioVoice.onyx:
      Exit('onyx');
    TAudioVoice.nova:
      Exit('nova');
    TAudioVoice.sage:
      Exit('sage');
    TAudioVoice.shimmer:
      Exit('shimmer');
  end;
end;

{ TSpeechFormatHelper }

constructor TSpeechFormatHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TSpeechFormat>(Value,
            ['mp3', 'opus', 'aac', 'flac', 'wav', 'pcm']);
end;

function TSpeechFormatHelper.ToString: string;
begin
  case self of
    TSpeechFormat.mp3:
      Exit('mp3');
    TSpeechFormat.opus:
      Exit('opus');
    TSpeechFormat.aac:
      Exit('aac');
    TSpeechFormat.flac:
      Exit('flac');
    TSpeechFormat.wav:
      Exit('wav');
    TSpeechFormat.pcm:
      Exit('pcm');
  end;
end;

{ TTranscriptionResponseFormatHelper }

constructor TTranscriptionResponseFormatHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TTranscriptionResponseFormat>(Value,
            ['json', 'text', 'srt', 'verbose_json', 'vtt']);
end;

function TTranscriptionResponseFormatHelper.ToString: string;
begin
  case Self of
    TTranscriptionResponseFormat.json:
      Exit('json');
    TTranscriptionResponseFormat.text:
      Exit('text');
    TTranscriptionResponseFormat.srt:
      Exit('srt');
    TTranscriptionResponseFormat.verbose_json:
      Exit('verbose_json');
    TTranscriptionResponseFormat.vtt:
      Exit('vtt');
  end;
end;

{ TEncodingFormatHelper }

constructor TEncodingFormatHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TEncodingFormat>(Value, ['float', 'base64']);
end;

function TEncodingFormatHelper.ToString: string;
begin
  case Self of
    TEncodingFormat.float:
      Exit('float');
    TEncodingFormat.base64:
      Exit('base64');
  end;
end;

{ THarmCategoriesHelper }

class function THarmCategoriesHelper.Create(
  const Value: string): TEncodingFormat;
begin
  Result := TEnumValueRecovery.TypeRetrieve<TEncodingFormat>(Value,
    ['hate', 'hate threatening', 'harassment', 'harassment threatening',
     'illicit', 'illicit violent', 'self harm', 'self harm intent',
     'self harm instructions', 'sexual', 'sexual minors', 'violence',
     'violence graphic'
    ]);
end;

function THarmCategoriesHelper.ToString: string;
begin
  case Self of
    THarmCategories.hate:
      Exit('hate');
    THarmCategories.hateThreatening:
      Exit('hate threatening');
    THarmCategories.harassment:
      Exit('harassment');
    THarmCategories.harassmentThreatening:
      Exit('harassment threatening');
    THarmCategories.illicit:
      Exit('illicit');
    THarmCategories.illicitViolent:
      Exit('illicit violent');
    THarmCategories.selfHarm:
      Exit('self harm');
    THarmCategories.selfHarmIntent:
      Exit('self harm intent');
    THarmCategories.selfHarmInstructions:
      Exit('self harm instructions');
    THarmCategories.sexual:
      Exit('sexual');
    THarmCategories.sexualMinors:
      Exit('sexual minors');
    THarmCategories.violence:
      Exit('violence');
    THarmCategories.violenceGraphic:
      Exit('violence graphic');
  end;
end;

{ TResponseFormatHelper }

constructor TResponseFormatHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TResponseFormat>(Value, ['url', 'b64_json']);
end;

function TResponseFormatHelper.ToString: string;
begin
  case Self of
    TResponseFormat.url:
      Exit('url');
    TResponseFormat.b64_json:
      Exit('b64_json');
  end;
end;

{ TImageSizeHelper }

constructor TImageSizeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TImageSize>(Value,
            ['256x256', '512x512', '1024x1024', '1792x1024', '1024x1792',
             '1536x1024', '1024x1536']);
end;

function TImageSizeHelper.ToString: string;
begin
  case Self of
    TImageSize.r256x256:
      Exit('256x256');
    TImageSize.r512x512:
      Exit('512x512');
    TImageSize.r1024x1024:
      Exit('1024x1024');
    TImageSize.r1792x1024:
      Exit('1792x1024');
    TImageSize.r1024x1792:
      Exit('1024x1792');
    TImageSize.r1536x1024:
      Exit('1536x1024');
    TImageSize.r1024x1536:
      Exit('1024x1536');
  end;
end;

{ TImageStyleHelper }

constructor TImageStyleHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TImageStyle>(Value, ['vivid', 'natural']);
end;

function TImageStyleHelper.ToString: string;
begin
  case Self of
    TImageStyle.vivid:
      Exit('vivid');
    TImageStyle.natural:
      Exit('natural');
  end;
end;

{ TFilesPurposeHelper }

constructor TFilesPurposeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TFilesPurpose>(Value,
            ['assistants', 'assistants_output', 'batch', 'batch_output',
             'fine-tune', 'fine-tune-results', 'vision', 'evals', 'user_data']);
end;

function TFilesPurposeHelper.ToString: string;
begin
  case Self of
    TFilesPurpose.assistants:
      Exit('assistants');
    TFilesPurpose.assistants_output:
      Exit('assistants_output');
    TFilesPurpose.batch:
      Exit('batch');
    TFilesPurpose.batch_output:
      Exit('batch_output');
    TFilesPurpose.finetune:
      Exit('fine-tune');
    TFilesPurpose.finetune_results:
      Exit('fine-tune-results');
    TFilesPurpose.vision:
      Exit('vision');
    TFilesPurpose.evals:
      Exit('evals');
    TFilesPurpose.user_data:
      Exit('user_data')
  end;
end;

{ TFilesPurposeInterceptor }

function TFilesPurposeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TFilesPurpose>.ToString;
end;

procedure TFilesPurposeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TFilesPurpose.Create(Arg)));
end;

{ TMetadataInterceptor }

procedure TMetadataInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  Arg := Format('{%s}', [Trim(Arg.Replace('`', '"').Replace(#10, ''))]);
  while Arg.Contains(', ') do Arg := Arg.Replace(', ', ',');
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, Arg.Replace(',', ', '));
end;

{ TBatchStatusHelper }

constructor TBatchStatusHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TBatchStatus>(Value,
            ['validating', 'failed', 'in_progress', 'finalizing',
             'completed', 'expired', 'cancelling', 'cancelled']);
end;

function TBatchStatusHelper.ToString: string;
begin
  case Self of
    TBatchStatus.validating:
      Exit('validating');
    TBatchStatus.failed:
      Exit('failed');
    TBatchStatus.in_progress:
      Exit('in_progress');
    TBatchStatus.finalizing:
      Exit('finalizing');
    TBatchStatus.completed:
      Exit('completed');
    TBatchStatus.expired:
      Exit('expired');
    TBatchStatus.cancelling:
      Exit('cancelling');
    TBatchStatus.cancelled:
      Exit('cancelled');
  end;
end;

{ TBatchStatusInterceptor }

function TBatchStatusInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TBatchStatus>.ToString;
end;

procedure TBatchStatusInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TBatchStatus.Create(Arg)));
end;

{ TBatchUrlHelper }

constructor TBatchUrlHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TBatchUrl>(Value,
            ['/v1/chat/completions', '/v1/embeddings']);
end;

function TBatchUrlHelper.ToString: string;
begin
  case Self of
    TBatchUrl.chat_completions:
      Exit('/v1/chat/completions');
    TBatchUrl.embeddings:
      Exit('/v1/embeddings');
  end;
end;

{ TSchemaTypeHelper }

constructor TSchemaTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TSchemaType>(Value,
            ['unspecified', 'string', 'number', 'integer',
             'boolean', 'array', 'object']);
end;

function TSchemaTypeHelper.ToString: string;
begin
  case self of
    TSchemaType.unspecified:
      Exit('unspecified');
    TSchemaType.string:
      Exit('string');
    TSchemaType.number:
      Exit('number');
    TSchemaType.integer:
      Exit('integer');
    TSchemaType.boolean:
      Exit('boolean');
    TSchemaType.array:
      Exit('array');
    TSchemaType.object:
      Exit('object');
  end;
end;

{ TJobMethodTypeHHelper }

constructor TJobMethodTypeHHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TJobMethodType>(Value, ['supervised', 'dpo']);
end;

function TJobMethodTypeHHelper.ToString: string;
begin
  case self of
    TJobMethodType.supervised:
      Exit('supervised');
    TJobMethodType.dpo:
      Exit('dpo');
  end;
end;

{ TJobMethodTypeInterceptor }

function TJobMethodTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TJobMethodType>.ToString;
end;

procedure TJobMethodTypeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TJobMethodType.Create(Arg)));
end;

{ TFineTunedStatusHelper }

constructor TFineTunedStatusHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TFineTunedStatus>(Value,
            ['validating_files', 'queued', 'running', 'succeeded',
             'failed', 'cancelled']);
end;

function TFineTunedStatusHelper.ToString: string;
begin
  case self of
    TFineTunedStatus.validating_files:
      Exit('validating_files');
    TFineTunedStatus.queued:
      Exit('queued');
    TFineTunedStatus.running:
      Exit('running');
    TFineTunedStatus.succeeded:
      Exit('succeeded');
    TFineTunedStatus.failed:
      Exit('failed');
    TFineTunedStatus.cancelled:
      Exit('cancelled');
  end;
end;

{ TFineTunedStatusInterceptor }

function TFineTunedStatusInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TFineTunedStatus>.ToString;
end;

procedure TFineTunedStatusInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TFineTunedStatus.Create(Arg)));
end;

{ TAssistantsToolsTypeHelper }

constructor TAssistantsToolsTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TAssistantsToolsType>(Value,
            ['code_interpreter', 'file_search', 'function']);
end;

function TAssistantsToolsTypeHelper.ToString: string;
begin
  case self of
    TAssistantsToolsType.code_interpreter:
      Exit('code_interpreter');
    TAssistantsToolsType.file_search:
      Exit('file_search');
    TAssistantsToolsType.function:
      Exit('function');
  end;
end;

{ TAssistantsToolsTypeInterceptor }

function TAssistantsToolsTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TAssistantsToolsType>.ToString;
end;

procedure TAssistantsToolsTypeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TAssistantsToolsType.Create(Arg)));
end;

{ TChunkingStrategyTypeHelper }

constructor TChunkingStrategyTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TChunkingStrategyType>(Value, ['auto', 'static']);
end;

function TChunkingStrategyTypeHelper.ToString: string;
begin
  case self of
    TChunkingStrategyType.auto:
      Exit('auto');
    TChunkingStrategyType.static:
      Exit('static');
  end;
end;

{ TResponseFormatTypeHelper }

constructor TResponseFormatTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TResponseFormatType>(Value,
            ['auto', 'text', 'json_object', 'json_schema']);
end;

function TResponseFormatTypeHelper.ToString: string;
begin
  case self of
    TResponseFormatType.auto:
      Exit('auto');
    TResponseFormatType.text:
      Exit('text');
    TResponseFormatType.json_object:
      Exit('json_object');
    TResponseFormatType.json_schema:
      Exit('json_schema');
  end;
end;

{ TResponseFormatTypeInterceptor }

function TResponseFormatTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TResponseFormatType>.ToString;
end;

procedure TResponseFormatTypeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TResponseFormatType.Create(Arg)));
end;

{ TThreadsContentTypeHelper }

constructor TThreadsContentTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TThreadsContentType>(Value,
            ['text', 'image_url', 'image_file']);
end;

function TThreadsContentTypeHelper.ToString: string;
begin
  case self of
    TThreadsContentType.text:
      Exit('text');
    TThreadsContentType.image_url:
      Exit('image_url');
    TThreadsContentType.image_file:
      Exit('image_file');
  end;
end;

{ TMessageStatusHelper }

constructor TMessageStatusHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TMessageStatus>(Value,
            ['in_progress', 'incomplete', 'completed']);
end;

function TMessageStatusHelper.ToString: string;
begin
  case self of
    TMessageStatus.in_progress:
      Exit('in_progress');
    TMessageStatus.incomplete:
      Exit('incomplete');
    TMessageStatus.completed:
      Exit('completed');
  end;
end;

{ TMessageStatusInterceptor }

function TMessageStatusInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TMessageStatus>.ToString;
end;

procedure TMessageStatusInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TMessageStatus.Create(Arg)));
end;

{ TTruncationStrategyTypeHelper }

constructor TTruncationStrategyTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TTruncationStrategyType>(Value,
            ['auto', 'last_messages']);
end;

function TTruncationStrategyTypeHelper.ToString: string;
begin
  case self of
    TTruncationStrategyType.auto:
      Exit('auto');
    TTruncationStrategyType.last_messages:
      Exit('last_messages');
  end;
end;

{ TTruncationStrategyTypeInterceptor }

function TTruncationStrategyTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TTruncationStrategyType>.ToString;
end;

procedure TTruncationStrategyTypeInterceptor.StringReverter(Data: TObject;
  Field, Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TTruncationStrategyType.Create(Arg)));
end;

{ TRunStatusHelper }

constructor TRunStatusHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TRunStatus>(Value,
            ['queued', 'in_progress', 'requires_action', 'cancelling',
             'cancelled', 'failed', 'completed', 'incomplete',
             'expired']);
end;

function TRunStatusHelper.ToString: string;
begin
  case self of
    TRunStatus.queued:
      Exit('queued');
    TRunStatus.in_progress:
      Exit('in_progress');
    TRunStatus.requires_action:
      Exit('requires_action');
    TRunStatus.cancelling:
      Exit('cancelling');
    TRunStatus.cancelled:
      Exit('cancelled');
    TRunStatus.failed:
      Exit('failed');
    TRunStatus.completed:
      Exit('completed');
    TRunStatus.incomplete:
      Exit('incomplete');
    TRunStatus.expired:
      Exit('expired');
  end;
end;

{ TRunStatusInterceptor }

function TRunStatusInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TRunStatus>.ToString;
end;

procedure TRunStatusInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TRunStatus.Create(Arg)));
end;

{ TRunStepTypeHelper }

constructor TRunStepTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TRunStepType>(Value,
            ['message_creation', 'tool_calls']);
end;

function TRunStepTypeHelper.ToString: string;
begin
  case self of
    TRunStepType.message_creation:
      Exit('message_creation');
    TRunStepType.tool_calls:
      Exit('tool_calls');
  end;
end;

{ TRunStepTypeInterceptor }

function TRunStepTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TRunStepType>.ToString;
end;

procedure TRunStepTypeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TRunStepType.Create(Arg)));
end;

{ TStringOrNullHelper }

constructor TStringOrNullHelper.Create(const Value: Variant);
begin
  Self := Value;
end;

function TStringOrNullHelper.isNull: Boolean;
begin
  case VarType(Self) of
    varString,
    varUString,
    varAny:
      Exit(False);
    else
      Exit(True);
  end;
end;

function TStringOrNullHelper.ToString: string;
begin
  if Self.isNull then
    Result := 'null' else
    Result := VarToStr(Self);
end;

{ TIntegerOrNullHelper }

constructor TIntegerOrNullHelper.Create(const Value: Variant);
begin
  Self := Value;
end;

function TIntegerOrNullHelper.isNull: Boolean;
begin
  case VarType(Self) of
    varSmallint,
    varInteger,
    varShortInt,
    varByte,
    varWord,
    varUInt32:
      Exit(False);
    else
      Exit(True);
  end;
end;

function TIntegerOrNullHelper.ToInteger: Integer;
begin
  if Self.isNull then
    Result := 0 else
    Result := VarAsType(Self, varInteger);
end;

function TIntegerOrNullHelper.ToString: string;
begin
  if Self.isNull then
    Result := 'null' else
    Result := Self.ToInteger.ToString;
end;

{ TInt64OrNullHelper }

constructor TInt64OrNullHelper.Create(const Value: Variant);
begin
  Self := Value;
end;

function TInt64OrNullHelper.isNull: Boolean;
begin
  case VarType(Self) of
    varSmallint,
    varInteger,
    varInt64,
    varShortInt,
    varByte,
    varWord,
    varUInt32,
    varUInt64:
      Exit(False);
    else
      Exit(True);
  end;
end;

function TInt64OrNullHelper.ToInteger: Int64;
begin
  if Self.isNull then
    Result := 0 else
    Result := VarAsType(Self, varInt64);
end;

function TInt64OrNullHelper.ToString: string;
begin
  if Self.isNull then
    Result := 'null' else
    Result := Self.ToInteger.ToString;
end;

function TInt64OrNullHelper.ToUtcDateString: string;
begin
  Result := TimestampToString(Self.ToInteger, UtcTimestamp);
end;

{ TDoubleOrNullHelper }

constructor TDoubleOrNullHelper.Create(const Value: Variant);
begin
  Self := Value;
end;

function TDoubleOrNullHelper.isNull: Boolean;
begin
  case VarType(Self) of
    varSmallint,
    varInteger,
    varInt64,
    varSingle,
    varDouble,
    varCurrency,
    varShortInt,
    varByte,
    varWord,
    varUInt32,
    varUInt64:
      Exit(False);
    else
      Exit(True);
  end;
end;

function TDoubleOrNullHelper.ToDouble: Double;
begin
  if Self.isNull then
    Result := 0 else
    Result := VarAsType(Self, varDouble);
end;

function TDoubleOrNullHelper.ToString: string;
begin
  if Self.isNull then
    Result := 'null' else
    Result := Self.ToDouble.ToString;
end;

{ TBooleanOrNullHelper }

constructor TBooleanOrNullHelper.Create(const Value: Variant);
begin
  Self := Value;
end;

function TBooleanOrNullHelper.isNull: Boolean;
begin
  case VarType(Self) of
    varBoolean:
      Exit(False);
    varByte,
    varShortInt:
      Exit(not ((Self = 0) or (Self = 1) or (Self = -1)));
    else
      Exit(True);
  end;
end;

function TBooleanOrNullHelper.ToBoolean: Boolean;
begin
  if Self.isNull then
    Result := False else
    Result := VarAsType(Self, varBoolean);
end;

function TBooleanOrNullHelper.ToString: string;
begin
  if Self.isNull then
    Result := 'null' else
    Result := BoolToStr(Self.ToBoolean, True);
end;

{ TSearchWebOptionsHelper }

constructor TSearchWebOptionsHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TSearchWebOptions>(Value,
            ['low', 'medium', 'high']);
end;

function TSearchWebOptionsHelper.ToString: string;
begin
  case Self of
    TSearchWebOptions.low:
      Exit('low');
    TSearchWebOptions.medium:
      Exit('medium');
    TSearchWebOptions.high:
      Exit('high');
  end;
end;

{ TOutputIncludingHelper }

constructor TOutputIncludingHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TOutputIncluding>(Value,
            ['file_search_call.results',
             'message.input_image.image_url',
             'computer_call_output.output.image_url',
             'reasoning.encrypted_content']);
end;

function TOutputIncludingHelper.ToString: string;
begin
  case self of
    TOutputIncluding.file_search_result:
      Exit('file_search_call.results');
    TOutputIncluding.input_image_url:
      Exit('message.input_image.image_url');
    TOutputIncluding.computer_call_image_url:
      Exit('computer_call_output.output.image_url');
    TOutputIncluding.reasoning_encrypted_content:
      Exit('reasoning.encrypted_content');
  end;
end;

{ TReasoningGenerateSummaryHelper }

constructor TReasoningGenerateSummaryHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TReasoningGenerateSummary>(Value,
            ['concise', 'detailed']);
end;

function TReasoningGenerateSummaryHelper.ToString: string;
begin
  case self of
    TReasoningGenerateSummary.concise:
      Exit('concise');
    TReasoningGenerateSummary.detailed:
      Exit('detailed');
  end;
end;

{ TInputItemTypeHelper }

constructor TInputItemTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TInputItemType>(Value,
            ['input_text', 'input_image', 'input_file']);
end;

function TInputItemTypeHelper.ToString: string;
begin
  case self of
    TInputItemType.input_text:
      Exit('input_text');
    TInputItemType.input_image:
      Exit('input_image');
    TInputItemType.input_file:
      Exit('input_file');
  end;
end;

{ TFileSearchToolCallTypeHelper }

constructor TFileSearchToolCallTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TFileSearchToolCallType>(Value,
            ['in_progress', 'searching', 'incomplete', 'failed']);
end;

function TFileSearchToolCallTypeHelper.ToString: string;
begin
  case Self of
    TFileSearchToolCallType.in_progress:
      Exit('in_progress');
    TFileSearchToolCallType.searching:
      Exit('searching');
    TFileSearchToolCallType.incomplete:
      Exit('incomplete');
    TFileSearchToolCallType.failed:
      Exit('failed');
  end;
end;

{ TFileSearchToolCallTypeInterceptor }

function TFileSearchToolCallTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TFileSearchToolCallType>.ToString;
end;

procedure TFileSearchToolCallTypeInterceptor.StringReverter(Data: TObject;
  Field, Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TFileSearchToolCallType.Create(Arg)));
end;

{ TMouseButtonHelper }

constructor TMouseButtonHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TMouseButton>(Value,
            ['left', 'right', 'wheel', 'back', 'forward']);
end;

function TMouseButtonHelper.ToString: string;
begin
  case self of
    TMouseButton.left:
      Exit('left');
    TMouseButton.right:
      Exit('right');
    TMouseButton.wheel:
      Exit('wheel');
    TMouseButton.back:
      Exit('back');
    TMouseButton.forward:
      Exit('forward');
  end;
end;

{ TMouseButtonInterceptor }

function TMouseButtonInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TMouseButton>.ToString;
end;

procedure TMouseButtonInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TMouseButton.Create(Arg)));
end;

{ TResponseOptionHelper }

constructor TResponseOptionHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TResponseOption>(Value,
            ['text', 'json_schema', 'json_object']);
end;

function TResponseOptionHelper.ToString: string;
begin
  case self of
    TResponseOption.text:
      Exit('text');
    TResponseOption.json_schema:
      Exit('json_schema');
    TResponseOption.json_object:
      Exit('json_object');
  end;
end;

{ THostedTooltypeHelper }

constructor THostedTooltypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<THostedTooltype>(Value,
            ['file_search', 'web_search_preview', 'computer_use_preview']);
end;

function THostedTooltypeHelper.ToString: string;
begin
  case self of
    THostedTooltype.file_search:
      Exit('file_search');
    THostedTooltype.web_search_preview:
      Exit('web_search_preview');
    THostedTooltype.computer_use_preview:
      Exit('computer_use_preview');
  end;
end;

{ TComparisonFilterTypeHelper }

constructor TComparisonFilterTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TComparisonFilterType>(Value,
            ['eq', 'ne', 'gt', 'gte', 'lt', 'lte']);
end;

class function TComparisonFilterTypeHelper.ToOperator(
  const Value: string): TComparisonFilterType;
begin
  Result := TEnumValueRecovery.TypeRetrieve<TComparisonFilterType>(Value,
            ['equals', 'notEqual'.ToLower, 'greaterThan'.ToLower,
             'greaterThanOrEqual'.ToLower, 'lessThan'.ToLower, 'lessThanOrEqual'.ToLower]);
end;

function TComparisonFilterTypeHelper.ToString: string;
begin
  case self of
    TComparisonFilterType.eq:
      Exit('eq');
    TComparisonFilterType.ne:
      Exit('ne');
    TComparisonFilterType.gt:
      Exit('gt');
    TComparisonFilterType.gte:
      Exit('gte');
    TComparisonFilterType.lt:
      Exit('lt');
    TComparisonFilterType.lte:
      Exit('lte');
  end;
end;

{ TCompoundFilterTypeHelper }

constructor TCompoundFilterTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TCompoundFilterType>(Value,
            ['and', 'or']);
end;

function TCompoundFilterTypeHelper.ToString: string;
begin
  case self of
    TCompoundFilterType.and:
      Exit('and');
    TCompoundFilterType.or:
      Exit('or');
  end;
end;

{ TWebSearchTypeHelper }

constructor TWebSearchTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TWebSearchType>(Value,
            ['web_search_preview', 'web_search_preview_2025_03_11']);
end;

function TWebSearchTypeHelper.ToString: string;
begin
  case self of
    TWebSearchType.web_search_preview:
      Exit('web_search_preview');
    TWebSearchType.web_search_preview_2025_03_11:
      Exit('web_search_preview_2025_03_11');
  end;
end;

{ TResponseTruncationTypeHelper }

constructor TResponseTruncationTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TResponseTruncationType>(Value,
            ['auto', 'disabled']);
end;

function TResponseTruncationTypeHelper.ToString: string;
begin
  case self of
    TResponseTruncationType.auto:
      Exit('auto');
    TResponseTruncationType.disabled:
      Exit('disabled');
  end;
end;

{ TResponseTypesHelper }

constructor TResponseTypesHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TResponseTypes>(Value,
            ['message', 'file_search_call', 'function_call', 'web_search_call',
             'computer_call', 'reasoning', 'computer_call_output', 'function_call_output']);
end;

function TResponseTypesHelper.ToString: string;
begin
  case self of
    TResponseTypes.message:
      Exit('message');
    TResponseTypes.file_search_call:
      Exit('file_search_call');
    TResponseTypes.function_call:
      Exit('function_call');
    TResponseTypes.web_search_call:
      Exit('web_search_call');
    TResponseTypes.computer_call:
      Exit('computer_call');
    TResponseTypes.reasoning:
      Exit('reasoning');
    TResponseTypes.computer_call_output:
      Exit('computer_call_outpu');
    TResponseTypes.function_call_output:
      Exit('function_call_output');
  end;
end;

{ TResponseTypesInterceptor }

function TResponseTypesInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TResponseTypes>.ToString;
end;

procedure TResponseTypesInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TResponseTypes.Create(Arg)));
end;

{ TResponseContentTypeHelper }

constructor TResponseContentTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TResponseContentType>(Value,
            ['output_text', 'refusal', 'summary_text']);
end;

function TResponseContentTypeHelper.ToString: string;
begin
  case Self of
    TResponseContentType.output_text:
      Exit('output_text');
    TResponseContentType.refusal:
      Exit('refusal');
    TResponseContentType.summary_text:
      Exit('summary_text');
  end;
end;

{ TResponseContentTypeInterceptor }

function TResponseContentTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TResponseContentType>.ToString;
end;

procedure TResponseContentTypeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TResponseContentType.Create(Arg)));
end;

{ TResponseAnnotationTypeHelper }

constructor TResponseAnnotationTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TResponseAnnotationType>(Value,
            ['file_citation', 'url_citation', 'file_path']);
end;

function TResponseAnnotationTypeHelper.ToString: string;
begin
  case self of
    TResponseAnnotationType.file_citation:
      Exit('file_citation');
    TResponseAnnotationType.url_citation:
      Exit('url_citation');
    TResponseAnnotationType.file_path:
      Exit('file_path');
  end;
end;

{ TResponseAnnotationTypeInterceptor }

function TResponseAnnotationTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TResponseAnnotationType>.ToString;
end;

procedure TResponseAnnotationTypeInterceptor.StringReverter(Data: TObject;
  Field, Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TResponseAnnotationType.Create(Arg)));
end;

{ TResponseComputerTypeHelper }

constructor TResponseComputerTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TResponseComputerType>(Value,
            ['click', 'double_click', 'drag',
             'keypress', 'move', 'screenshot',
             'scroll', 'type', 'wait']);
end;

function TResponseComputerTypeHelper.ToString: string;
begin
  case self of
    TResponseComputerType.click:
      Exit('click');
    TResponseComputerType.double_click:
      Exit('double_click');
    TResponseComputerType.drag:
      Exit('drag');
    TResponseComputerType.keypress:
      Exit('keypress');
    TResponseComputerType.move:
      Exit('move');
    TResponseComputerType.screenshot:
      Exit('screenshot');
    TResponseComputerType.scroll:
      Exit('scroll');
    TResponseComputerType.type:
      Exit('type');
    TResponseComputerType.wait:
      Exit('wait');
  end;
end;

{ TResponseComputerTypeInterceptor }

function TResponseComputerTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TResponseComputerType>.ToString;
end;

procedure TResponseComputerTypeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TResponseComputerType.Create(Arg)));
end;

{ TResponseStatusHelper }

constructor TResponseStatusHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TResponseStatus>(Value,
            ['in_progress', 'incomplete', 'completed', 'failed']);
end;

function TResponseStatusHelper.ToString: string;
begin
  case self of
    TResponseStatus.in_progress:
      Exit('in_progress');
    TResponseStatus.incomplete:
      Exit('incomplete');
    TResponseStatus.completed:
      Exit('completed');
    TResponseStatus.failed:
      Exit('failed');
  end;
end;

{ TResponseStatusInterceptor }

function TResponseStatusInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TResponseStatus>.ToString;
end;

procedure TResponseStatusInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TResponseStatus.Create(Arg)));
end;

{ TResponseToolsTypeHelper }

constructor TResponseToolsTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TResponseToolsType>(Value,
            ['file_search', 'function', 'computer_use_preview', 'web_search_preview',
             'web_search_preview_2025_03_11']);
end;

function TResponseToolsTypeHelper.ToString: string;
begin
  case self of
    TResponseToolsType.file_search:
      Exit('file_search');
    TResponseToolsType.function:
      Exit('function');
    TResponseToolsType.computer_use_preview:
      Exit('computer_use_preview');
    TResponseToolsType.web_search_preview:
      Exit('web_search_preview');
    TResponseToolsType.web_search_preview_2025_03_11:
      Exit('web_search_preview_2025_03_11');
  end;
end;

{ TResponseToolsTypeInterceptor }

function TResponseToolsTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TResponseToolsType>.ToString;
end;

procedure TResponseToolsTypeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TResponseToolsType.Create(Arg)));
end;

{ TResponseToolsFilterTypeHelper }

constructor TResponseToolsFilterTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TResponseToolsFilterType>(Value,
            ['eq', 'ne', 'gt', 'gte',
             'lt', 'lte', 'and', 'or']);
end;

function TResponseToolsFilterTypeHelper.ToString: string;
begin
  case self of
    TResponseToolsFilterType.eq:
      Exit('eq');
    TResponseToolsFilterType.ne:
      Exit('ne');
    TResponseToolsFilterType.gt:
      Exit('gt');
    TResponseToolsFilterType.gte:
      Exit('gte');
    TResponseToolsFilterType.lt:
      Exit('lt');
    TResponseToolsFilterType.lte:
      Exit('lte');
    TResponseToolsFilterType.and:
      Exit('and');
    TResponseToolsFilterType.or:
      Exit('or');
  end;
end;

{ TResponseToolsFilterTypeInterceptor }

function TResponseToolsFilterTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TResponseToolsFilterType>.ToString;
end;

procedure TResponseToolsFilterTypeInterceptor.StringReverter(Data: TObject;
  Field, Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TResponseToolsFilterType.Create(Arg)));
end;

{ TResponseItemContentTypeHelper }

constructor TResponseItemContentTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TResponseItemContentType>(Value,
            ['input_text', 'input_image', 'input_file', 'output_text', 'refusal']);
end;

function TResponseItemContentTypeHelper.ToString: string;
begin
  case self of
    TResponseItemContentType.input_text:
      Exit('input_text');
    TResponseItemContentType.input_image:
      Exit('input_image');
    TResponseItemContentType.input_file:
      Exit('input_file');
    TResponseItemContentType.output_text:
      Exit('output_text');
    TResponseItemContentType.refusal:
      Exit('refusal');
  end;
end;

{ TResponseItemContentTypeInterceptor }

function TResponseItemContentTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TResponseItemContentType>.ToString;
end;

procedure TResponseItemContentTypeInterceptor.StringReverter(Data: TObject;
  Field, Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TResponseItemContentType.Create(Arg)));
end;

{ TResponseStreamTypeHelper }

constructor TResponseStreamTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TResponseStreamType>(Value,
            [ 'response.created',
              'response.in_progress',
              'response.completed',
              'response.failed',
              'response.incomplete',
              'response.output_item.added',
              'response.output_item.done',
              'response.content_part.added',
              'response.content_part.done',
              'response.output_text.delta',
              'response.output_text.annotation.added',
              'response.output_text.done',
              'response.refusal.delta',
              'response.refusal.done',
              'response.function_call_arguments.delta',
              'response.function_call_arguments.done',
              'response.file_search_call.in_progress',
              'response.file_search_call.searching',
              'response.file_search_call.completed',
              'response.web_search_call.in_progress',
              'response.web_search_call.searching',
              'response.web_search_call.completed',
              'response.reasoning_summary_part.added',
              'response.reasoning_summary_part.done',
              'response.reasoning_summary_text.delta',
              'response.reasoning_summary_text.done',
              'error'
            ]);
end;

function TResponseStreamTypeHelper.ToString: string;
begin
  case self of
    TResponseStreamType.created:
      Exit('response.created');
    TResponseStreamType.in_progress:
      Exit('response.in_progress');
    TResponseStreamType.completed:
      Exit('response.completed');
    TResponseStreamType.failed:
      Exit('response.failed');
    TResponseStreamType.incomplete:
      Exit('response.incomplete');
    TResponseStreamType.output_item_added:
      Exit('response.output_item.added');
    TResponseStreamType.output_item_done:
      Exit('response.output_item.done');
    TResponseStreamType.content_part_added:
      Exit('response.content_part.added');
    TResponseStreamType.content_part_done:
      Exit('response.content_part.done');
    TResponseStreamType.output_text_delta:
      Exit('response.output_text.delta');
    TResponseStreamType.output_text_annotation_added:
      Exit('response.output_text.annotation.added');
    TResponseStreamType.output_text_done:
      Exit('response.output_text.done');
    TResponseStreamType.refusal_delta:
      Exit('response.refusal.delta');
    TResponseStreamType.refusal_done:
      Exit('response.refusal.done');
    TResponseStreamType.function_call_arguments_delta:
      Exit('response.function_call_arguments.delta');
    TResponseStreamType.function_call_arguments_done:
      Exit('response.function_call_arguments.done');
    TResponseStreamType.file_search_call_in_progress:
      Exit('response.file_search_call.in_progress');
    TResponseStreamType.file_search_call_searching:
      Exit('response.file_search_call.searching');
    TResponseStreamType.file_search_call_completed:
      Exit('response.file_search_call.completed');
    TResponseStreamType.web_search_call_in_progress:
      Exit('response.web_search_call.in_progress');
    TResponseStreamType.web_search_call_searching:
      Exit('response.web_search_call.searching');
    TResponseStreamType.web_search_call_completed:
      Exit('response.web_search_call.completed');

    TResponseStreamType.reasoning_summary_part_add:
      Exit('response.reasoning_summary_part.added');
    TResponseStreamType.reasoning_summary_part_done:
      Exit('response.reasoning_summary_part.done');
    TResponseStreamType.reasoning_summary_text_delta:
      Exit('response.reasoning_summary_text.delta');
    TResponseStreamType.reasoning_summary_text_done:
      Exit('response.reasoning_summary_text.done');


    TResponseStreamType.error:
      Exit('error');
  end;
end;

{ TResponseStreamTypeInterceptor }

function TResponseStreamTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TResponseStreamType>.ToString;
end;

procedure TResponseStreamTypeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TResponseStreamType.Create(Arg)));
end;

{ TBackGroundTypeHelper }

constructor TBackGroundTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TBackGroundType>(Value,
            ['transparent', 'opaque', 'auto']);
end;

function TBackGroundTypeHelper.ToString: string;
begin
  case self of
    TBackGroundType.transparent:
      Exit('transparent');
    TBackGroundType.opaque:
      Exit('opaque');
    TBackGroundType.auto:
      Exit('auto');
  end;
end;

{ TImageModerationTypeHelper }

constructor TImageModerationTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TImageModerationType>(Value,
            ['low', 'auto']);
end;

function TImageModerationTypeHelper.ToString: string;
begin
  case self of
    TImageModerationType.low:
      Exit('low');
    TImageModerationType.auto:
      Exit('auto');
  end;
end;

{ TOutputFormatTypeHelper }

constructor TOutputFormatTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TOutputFormatType>(Value,
            ['png', 'jpeg', 'webp']);
end;

function TOutputFormatTypeHelper.ToString: string;
begin
  case self of
    TOutputFormatType.png:
      Exit('png');
    TOutputFormatType.jpeg:
      Exit('jpeg');
    TOutputFormatType.webp:
      Exit('webp');
  end;
end;

{ TImageQualityTypeHelper }

constructor TImageQualityTypeHelper.Create(const Value: string);
begin
  Self := TEnumValueRecovery.TypeRetrieve<TImageQualityType>(Value,
            ['high', 'medium', 'low', 'standard', 'auto']);
end;

function TImageQualityTypeHelper.ToString: string;
begin
  case self of
    TImageQualityType.high:
      Exit('high');
    TImageQualityType.medium:
      Exit('medium');
    TImageQualityType.low:
      Exit('low');
    TImageQualityType.standard:
      Exit('standard');
    TImageQualityType.auto:
      Exit('auto');
  end;
end;

end.

unit GenAI.Uploads;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Threading, System.JSON, REST.Json.Types,
  REST.JsonReflect, System.Net.Mime,
  GenAI.API.Params, GenAI.API, GenAI.Consts, GenAI.Types, GenAI.Async.Support,
  GenAI.Files;

type
  /// <summary>
  /// Represents the parameters required for creating an upload object in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class provides methods to configure the necessary fields for initiating an upload.
  /// An upload is used to prepare a file for adding multiple parts and eventually creating
  /// a File object that can be utilized within the platform.
  /// </remarks>
  TUploadCreateParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the filename of the file to be uploaded.
    /// </summary>
    /// <param name="Value">
    /// A string that specifies the name of the file.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TUploadCreateParams</c> with the filename set.
    /// </returns>
    function Filename(const Value: string): TUploadCreateParams;
    /// <summary>
    /// Sets the purpose of the uploaded file. This is a required field to define
    /// the intent or use of the file being uploaded.
    /// </summary>
    /// <param name="Value">
    /// A string that specifies the purpose of the file (e.g., "fine-tune" or other supported purposes).
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TUploadCreateParams</c> with the purpose set.
    /// </returns>
    function Purpose(const Value: string): TUploadCreateParams; overload;
    /// <summary>
    /// Sets the purpose of the uploaded file using an enumerated value. This method
    /// allows specifying the purpose from predefined purposes in the <c>TFilesPurpose</c> enumeration.
    /// </summary>
    /// <param name="Value">
    /// A <c>TFilesPurpose</c> enumeration value that specifies the purpose of the file.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TUploadCreateParams</c> with the purpose set.
    /// </returns>
    function Purpose(const Value: TFilesPurpose): TUploadCreateParams; overload;
    /// <summary>
    /// Sets the total size of the file in bytes. This value is required
    /// to ensure the uploaded parts match the intended file size.
    /// </summary>
    /// <param name="Value">
    /// An integer value representing the total size of the file in bytes.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TUploadCreateParams</c> with the file size set.
    /// </returns>
    function Bytes(const Value: Int64): TUploadCreateParams;
    /// <summary>
    /// Sets the MIME type of the file to be uploaded. The MIME type must
    /// correspond to the supported types for the specified file purpose.
    /// </summary>
    /// <param name="Value">
    /// A string representing the MIME type of the file (e.g., "application/json").
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TUploadCreateParams</c> with the MIME type set.
    /// </returns>
    function MimeType(const Value: string): TUploadCreateParams;
  end;

  /// <summary>
  /// Represents parameters for creating an upload part in a multipart form-data request.
  /// </summary>
  /// <remarks>
  /// This class provides methods to add data to the form-data structure, allowing the uploading
  /// of individual parts (chunks) of a file. It is specifically designed for use with APIs
  /// that handle large file uploads by splitting the file into smaller parts.
  /// </remarks>
  TUploadPartParams = class(TMultipartFormData)
  public
    constructor Create; reintroduce;
    /// <summary>
    /// Adds a file to the form-data as a part of the upload.
    /// </summary>
    /// <param name="Value">
    /// The path to the file that will be added as a data chunk for the upload.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TUploadPartParams</c> to allow method chaining.
    /// </returns>
    function Data(const Value: string): TUploadPartParams; overload;
    /// <summary>
    /// Adds a stream to the form-data as a part of the upload.
    /// </summary>
    /// <param name="Value">
    /// A <c>TStream</c> object that represents the data chunk to upload.
    /// </param>
    /// <param name="FileName">
    /// The name of the file associated with the stream data.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TUploadPartParams</c> to allow method chaining.
    /// </returns>
    /// <remarks>
    /// This method allows the uploading of data directly from a stream, which is useful
    /// for scenarios where the data is not stored in a file or needs to be processed dynamically.
    /// </remarks>
    function Data(const Value: TStream; const FileName: string): TUploadPartParams; overload;
  end;

  /// <summary>
  /// Represents parameters for completing an upload by specifying the order of parts and optional checksum validation.
  /// </summary>
  /// <remarks>
  /// This class provides methods to configure the finalization of a multipart upload by
  /// specifying the part IDs in the correct order and verifying the file's integrity using an MD5 checksum.
  /// </remarks>
  TUploadCompleteParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the list of part IDs in the order they should be assembled to complete the upload.
    /// </summary>
    /// <param name="Value">
    /// An array of strings representing the IDs of the uploaded parts, in the correct order for assembly.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TUploadCompleteParams</c> to allow method chaining.
    /// </returns>
    function PartIds(const Value: TArray<string>): TUploadCompleteParams;
    /// <summary>
    /// Sets the MD5 checksum for the uploaded file to ensure data integrity.
    /// </summary>
    /// <param name="Value">
    /// A string representing the MD5 checksum of the file contents. This value is optional
    /// and is used to verify that the assembled file matches the expected content.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TUploadCompleteParams</c> to allow method chaining.
    /// </returns>
    function Md5(const Value: string): TUploadCompleteParams;
  end;

  /// <summary>
  /// Represents the metadata and details of an upload, including its status, purpose, and associated file.
  /// </summary>
  /// <remarks>
  /// This class provides properties to access information about an upload object, such as its ID,
  /// filename, size, purpose, status, and expiration time. It also includes a reference to the
  /// associated file object once the upload is completed.
  /// </remarks>
  TUpload = class(TJSONFingerprint)
  private
    FId: string;
    [JsonNameAttribute('created_at')]
    FCreatedAt: TInt64OrNull;
    FFilename: string;
    FBytes: Int64;
    [JsonReflectAttribute(ctString, rtString, TFilesPurposeInterceptor)]
    FPurpose: TFilesPurpose;
    FStatus: string;
    [JsonNameAttribute('expires_at')]
    FExpiresAt: TInt64OrNull;
    FObject: string;
    FFile: TFile;
  private
    function GetCreatedAtAsString: string;
    function GetExpiresAtAsString: string;
    function GetCreatedAt: Int64;
    function GetExpiresAt: Int64;
  public
    /// <summary>
    /// Gets or sets the unique identifier of the upload.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Gets the Unix timestamp (in seconds) indicating when the upload was created.
    /// </summary>
    property CreatedAt: Int64 read GetCreatedAt;
    /// <summary>
    /// Gets the Unix timestamp a a string, indicating when the upload was created.
    /// </summary>
    property CreatedAtAsString: string read GetCreatedAtAsString;
    /// <summary>
    /// Gets or sets the name of the file being uploaded.
    /// </summary>
    property Filename: string read FFilename write FFilename;
    /// <summary>
    /// Gets or sets the intended size of the file being uploaded, in bytes.
    /// </summary>
    property Bytes: Int64 read FBytes write FBytes;
    /// <summary>
    /// Gets or sets the purpose of the upload. This indicates the intended usage of the uploaded file.
    /// </summary>
    property Purpose: TFilesPurpose read FPurpose write FPurpose;
    /// <summary>
    /// Gets or sets the current status of the upload (e.g., "pending", "completed", or "cancelled").
    /// </summary>
    property Status: string read FStatus write FStatus;
    /// <summary>
    /// Gets the Unix timestamp (in seconds) indicating when the upload will expire.
    /// </summary>
    property ExpiresAt: Int64 read GetExpiresAt;
    /// <summary>
    /// Gets the Unix timestamp as a string, indicating when the upload will expire.
    /// </summary>
    property ExpiresAtAsString: string read GetExpiresAtAsString;
    /// <summary>
    /// Gets or sets the object type, which is always "upload".
    /// </summary>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// Gets or sets the associated file object created after the upload is completed.
    /// </summary>
    property &File: TFile read FFile write FFile;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents metadata and details of a single upload part, including its ID, creation timestamp, and associated upload.
  /// </summary>
  /// <remarks>
  /// This class provides properties to access information about an upload part, such as its unique ID,
  /// creation time, and the ID of the parent upload to which it belongs.
  /// </remarks>
  TUploadPart = class(TJSONFingerprint)
  private
    FId: string;
    [JsonNameAttribute('created_at')]
    FCreatedAt: TInt64OrNull;
    [JsonNameAttribute('upload_id')]
    FUploadId: string;
    FObject: string;
  private
    function GetCreatedAtAsString: string;
    function GetCreatedAt: Int64;
  public
    /// <summary>
    /// Gets or sets the unique identifier of the upload part.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Gets the Unix timestamp (in seconds) indicating when the upload part was created.
    /// </summary>
    property CreatedAt: Int64 read GetCreatedAt;
    /// <summary>
    /// Gets the formatted creation time as a human-readable string.
    /// </summary>
    property CreatedAtAsString: string read GetCreatedAtAsString;
    /// <summary>
    /// Gets or sets the ID of the upload to which this part belongs.
    /// </summary>
    property UploadId: string read FUploadId write FUploadId;
    /// <summary>
    /// Gets or sets the object type, which is always "upload.part".
    /// </summary>
    property &Object: string read FObject write FObject;
  end;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TUpload</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynUpload</c> type extends the <c>TAsynParams&lt;TUpload&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynUpload = TAsynCallBack<TUpload>;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TUploadPart</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynUploadPart</c> type extends the <c>TAsynParams&lt;TUploadPart&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynUploadPart = TAsynCallBack<TUploadPart>;

  /// <summary>
  /// Manages routes for handling file uploads, including creating uploads, adding parts, completing uploads, and canceling uploads.
  /// </summary>
  /// <remarks>
  /// This class provides methods to interact with the upload API endpoints. It supports asynchronous and synchronous
  /// operations for creating an upload, adding parts to it, completing the upload, and canceling an upload.
  /// </remarks>
  TUploadsRoute = class(TGenAIRoute)
    /// <summary>
    /// Initiates an asynchronous operation to create a new upload.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the upload creation parameters, such as filename, purpose, size, and MIME type.
    /// </param>
    /// <param name="CallBacks">
    /// A function that specifies the callbacks for the asynchronous operation.
    /// </param>
    procedure AsynCreate(const ParamProc: TProc<TUploadCreateParams>; const CallBacks: TFunc<TAsynUpload>);
    /// <summary>
    /// Initiates an asynchronous operation to add a part to an existing upload.
    /// </summary>
    /// <param name="UploadId">
    /// The ID of the upload to which the part will be added.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure the upload part parameters, such as the data chunk.
    /// </param>
    /// <param name="CallBacks">
    /// A function that specifies the callbacks for the asynchronous operation.
    /// </param>
    procedure AsynAddPart(const UploadId: string; const ParamProc: TProc<TUploadPartParams>;
      const CallBacks: TFunc<TAsynUploadPart>);
    /// <summary>
    /// Initiates an asynchronous operation to complete an upload.
    /// </summary>
    /// <param name="UploadId">
    /// The ID of the upload to complete.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure the parameters for completing the upload, such as the part order and optional MD5 checksum.
    /// </param>
    /// <param name="CallBacks">
    /// A function that specifies the callbacks for the asynchronous operation.
    /// </param>
    procedure AsynComplete(const UploadId: string; const ParamProc: TProc<TUploadCompleteParams>;
      const CallBacks: TFunc<TAsynUpload>);
    /// <summary>
    /// Initiates an asynchronous operation to cancel an upload.
    /// </summary>
    /// <param name="UploadId">
    /// The ID of the upload to cancel.
    /// </param>
    /// <param name="CallBacks">
    /// A function that specifies the callbacks for the asynchronous operation.
    /// </param>
    procedure AsynCancel(const UploadId: string; const CallBacks: TFunc<TAsynUpload>);
    /// <summary>
    /// Creates a new upload synchronously.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the upload creation parameters, such as filename, purpose, size, and MIME type.
    /// </param>
    /// <returns>
    /// A <c>TUpload</c> object containing the metadata of the created upload.
    /// </returns>
    function Create(const ParamProc: TProc<TUploadCreateParams>): TUpload;
    /// <summary>
    /// Adds a part to an existing upload synchronously.
    /// </summary>
    /// <param name="UploadId">
    /// The ID of the upload to which the part will be added.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure the upload part parameters, such as the data chunk.
    /// </param>
    /// <returns>
    /// A <c>TUploadPart</c> object containing the metadata of the added part.
    /// </returns>
    function AddPart(const UploadId: string; const ParamProc: TProc<TUploadPartParams>): TUploadPart;
    /// <summary>
    /// Completes an upload synchronously.
    /// </summary>
    /// <param name="UploadId">
    /// The ID of the upload to complete.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure the parameters for completing the upload, such as the part order and optional MD5 checksum.
    /// </param>
    /// <returns>
    /// A <c>TUpload</c> object containing the metadata of the completed upload.
    /// </returns>
    function Complete(const UploadId: string; const ParamProc: TProc<TUploadCompleteParams>): TUpload;
    /// <summary>
    /// Cancels an upload synchronously.
    /// </summary>
    /// <param name="UploadId">
    /// The ID of the upload to cancel.
    /// </param>
    /// <returns>
    /// A <c>TUpload</c> object containing the metadata of the canceled upload.
    /// </returns>
    function Cancel(const UploadId: string): TUpload;
  end;

implementation

{ TUploadCreateParams }

function TUploadCreateParams.Bytes(const Value: Int64): TUploadCreateParams;
begin
  Result := TUploadCreateParams(Add('bytes', Value));
end;

function TUploadCreateParams.Filename(
  const Value: string): TUploadCreateParams;
begin
  Result := TUploadCreateParams(Add('filename', Value));
end;

function TUploadCreateParams.MimeType(
  const Value: string): TUploadCreateParams;
begin
  Result := TUploadCreateParams(Add('mime_type', Value));
end;

function TUploadCreateParams.Purpose(
  const Value: string): TUploadCreateParams;
begin
  Result := TUploadCreateParams(Add('purpose', TFilesPurpose.Create(Value).ToString));
end;

function TUploadCreateParams.Purpose(
  const Value: TFilesPurpose): TUploadCreateParams;
begin
  Result := TUploadCreateParams(Add('purpose', Value.ToString));
end;

{ TUpload }

destructor TUpload.Destroy;
begin
  if Assigned(FFile) then
    FFile.Free;
  inherited;
end;

function TUpload.GetCreatedAt: Int64;
begin
  Result := TInt64OrNull(FCreatedAt).ToInteger;
end;

function TUpload.GetCreatedAtAsString: string;
begin
  Result := TInt64OrNull(FCreatedAt).ToUtcDateString;
end;

function TUpload.GetExpiresAt: Int64;
begin
  Result := TInt64OrNull(FExpiresAt).ToInteger;
end;

function TUpload.GetExpiresAtAsString: string;
begin
  Result := TInt64OrNull(FExpiresAt).ToUtcDateString;
end;

{ TUploadsRoute }

function TUploadsRoute.AddPart(const UploadId: string;
  const ParamProc: TProc<TUploadPartParams>): TUploadPart;
begin
  Result := API.PostForm<TUploadPart, TUploadPartParams>('uploads/' + UploadId + '/parts' , ParamProc);
end;

procedure TUploadsRoute.AsynAddPart(const UploadId: string;
  const ParamProc: TProc<TUploadPartParams>;
  const CallBacks: TFunc<TAsynUploadPart>);
begin
  with TAsynCallBackExec<TAsynUploadPart, TUploadPart>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TUploadPart
      begin
        Result := Self.AddPart(UploadId, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TUploadsRoute.AsynCancel(const UploadId: string;
  const CallBacks: TFunc<TAsynUpload>);
begin
  with TAsynCallBackExec<TAsynUpload, TUpload>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TUpload
      begin
        Result := Self.Cancel(UploadId);
      end);
  finally
    Free;
  end;
end;

procedure TUploadsRoute.AsynComplete(const UploadId: string;
  const ParamProc: TProc<TUploadCompleteParams>;
  const CallBacks: TFunc<TAsynUpload>);
begin
  with TAsynCallBackExec<TAsynUpload, TUpload>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TUpload
      begin
        Result := Self.Complete(UploadId, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TUploadsRoute.AsynCreate(const ParamProc: TProc<TUploadCreateParams>;
  const CallBacks: TFunc<TAsynUpload>);
begin
  with TAsynCallBackExec<TAsynUpload, TUpload>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TUpload
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

function TUploadsRoute.Cancel(const UploadId: string): TUpload;
begin
  Result := API.Post<TUpload>('uploads/' + UploadId + '/cancel');
end;

function TUploadsRoute.Complete(const UploadId: string;
  const ParamProc: TProc<TUploadCompleteParams>): TUpload;
begin
  Result := API.Post<TUpload, TUploadCompleteParams>('uploads/' + UploadId + '/complete', ParamProc);
end;

function TUploadsRoute.Create(
  const ParamProc: TProc<TUploadCreateParams>): TUpload;
begin
  Result := API.Post<TUpload, TUploadCreateParams>('uploads', ParamProc);
end;

{ TUploadPartParams }

function TUploadPartParams.Data(const Value: string): TUploadPartParams;
begin
  AddFile('data', Value);
  Result := Self;
end;

constructor TUploadPartParams.Create;
begin
  inherited Create(true);
end;

function TUploadPartParams.Data(const Value: TStream;
  const FileName: string): TUploadPartParams;
begin
  {$IF RTLVersion > 35.0}
    AddStream('data', Value, True, FileName);
  {$ELSE}
    AddStream('data', Value, FileName);
  {$ENDIF}
  Result := Self;
end;

{ TUploadCompleteParams }

function TUploadCompleteParams.Md5(const Value: string): TUploadCompleteParams;
begin
  Result := TUploadCompleteParams(Add('md5',  Value));
end;

function TUploadCompleteParams.PartIds(
  const Value: TArray<string>): TUploadCompleteParams;
begin
  Result := TUploadCompleteParams(Add('part_ids',  Value));
end;

{ TUploadPart }

function TUploadPart.GetCreatedAt: Int64;
begin
  Result := TInt64OrNull(FCreatedAt).ToInteger;
end;

function TUploadPart.GetCreatedAtAsString: string;
begin
  Result := TInt64OrNull(FCreatedAt).ToUtxDateString;
end;

end.

unit GenAI.Vector;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Threading, System.JSON, REST.Json.Types,
  REST.JsonReflect, System.Net.URLClient,
  GenAI.API.Params, GenAI.API, GenAI.Consts, GenAI.Types, GenAI.Async.Support,
  GenAI.API.Lists, GenAI.API.Deletion, GenAI.Assistants;

type
  /// <summary>
  /// Represents URL parameters for configuring requests to manage vector stores in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// The <c>TVectorStoreUrlParam</c> class is designed to facilitate customization of query parameters
  /// when interacting with the vector stores API, such as listing or filtering vector stores.
  /// It extends the base <c>TUrlAdvancedParams</c> class, inheriting functionality for parameter management.
  /// </remarks>
  TVectorStoreUrlParam = class(TUrlAdvancedParams);

  /// <summary>
  /// Represents parameters for specifying the expiration policy of a vector store in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// The <c>TExpiresAfterParams</c> class is used to configure when a vector store should expire
  /// based on a specified anchor timestamp and the number of days after the anchor.
  /// This helps in automatically managing the lifecycle of vector stores.
  /// </remarks>
  TExpiresAfterParams = class(TJSONParam)
  public
    /// <summary>
    /// Specifies the anchor timestamp that determines when the expiration countdown starts.
    /// </summary>
    /// <param name="Value">
    /// A string representing the anchor, typically set to values like <c>last_active_at</c>.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TExpiresAfterParams</c>, enabling method chaining.
    /// </returns>
    function Anchor(const Value: string): TExpiresAfterParams;
    /// <summary>
    /// Specifies the number of days after the anchor timestamp when the vector store should expire.
    /// </summary>
    /// <param name="Value">
    /// An integer representing the number of days to wait after the anchor time before expiration.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TExpiresAfterParams</c>, enabling method chaining.
    /// </returns>
    function Days(const Value: Integer): TExpiresAfterParams;
  end;

  /// <summary>
  /// Represents the parameters required to create a new vector store in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// The <c>TVectorStoreCreateParams</c> class provides methods for setting parameters such as file IDs,
  /// expiration policies, chunking strategies, and metadata. These parameters are used when making
  /// API requests to create a vector store that can be utilized by tools like file search.
  /// </remarks>
  TVectorStoreCreateParams = class(TJSONParam)
  public
    /// <summary>
    /// Specifies the file IDs to be included in the vector store.
    /// </summary>
    /// <param name="Value">
    /// A string containing one or more file IDs that the vector store should use for its creation.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TVectorStoreCreateParams</c>, enabling method chaining.
    /// </returns>
    function FileIds(const Value: TArray<string>): TVectorStoreCreateParams;
    /// <summary>
    /// Sets the name of the vector store.
    /// </summary>
    /// <param name="Value">
    /// A string representing the desired name of the vector store.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TVectorStoreCreateParams</c>, enabling method chaining.
    /// </returns>
    function Name(const Value: string): TVectorStoreCreateParams;
    /// <summary>
    /// Configures the expiration policy for the vector store.
    /// </summary>
    /// <param name="Value">
    /// An instance of <c>TExpiresAfterParams</c> specifying the expiration conditions,
    /// such as the anchor timestamp and number of days before expiration.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TVectorStoreCreateParams</c>, enabling method chaining.
    /// </returns>
    function ExpiresAfter(const Value: TExpiresAfterParams): TVectorStoreCreateParams;
    /// <summary>
    /// Defines the chunking strategy to be used for processing the files in the vector store.
    /// </summary>
    /// <param name="Value">
    /// An instance of <c>TChunkingStrategyParams</c> specifying the chunk size and overlap settings.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TVectorStoreCreateParams</c>, enabling method chaining.
    /// </returns>
    function ChunkingStrategy(const Value: TChunkingStrategyParams): TVectorStoreCreateParams;
    /// <summary>
    /// Attaches metadata to the vector store as a set of key-value pairs.
    /// </summary>
    /// <param name="Value">
    /// A <c>TJSONObject</c> containing metadata that provides additional information about the vector store.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TVectorStoreCreateParams</c>, enabling method chaining.
    /// </returns>
    function Metadata(const Value: TJSONObject): TVectorStoreCreateParams;
  end;

  /// <summary>
  /// Represents the parameters required to update an existing vector store in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// The <c>TVectorStoreUpdateParams</c> class provides methods for updating properties such as
  /// the vector store name, expiration policy, and metadata. These parameters are used when making
  /// API requests to modify an existing vector store.
  /// </remarks>
  TVectorStoreUpdateParams = class(TJSONParam)
  public
    /// <summary>
    /// Updates the name of the vector store.
    /// </summary>
    /// <param name="Value">
    /// A string representing the new name of the vector store.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TVectorStoreUpdateParams</c>, enabling method chaining.
    /// </returns>
    function Name(const Value: string): TVectorStoreUpdateParams;
    /// <summary>
    /// Updates the expiration policy of the vector store.
    /// </summary>
    /// <param name="Value">
    /// An instance of <c>TExpiresAfterParams</c> specifying the new expiration conditions,
    /// including the anchor timestamp and number of days before expiration.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TVectorStoreUpdateParams</c>, enabling method chaining.
    /// </returns>
    function ExpiresAfter(const Value: TExpiresAfterParams): TVectorStoreUpdateParams;
    /// <summary>
    /// Updates the metadata associated with the vector store.
    /// </summary>
    /// <param name="Value">
    /// A <c>TJSONObject</c> containing updated metadata represented as key-value pairs.
    /// This metadata can store additional structured information about the vector store.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TVectorStoreUpdateParams</c>, enabling method chaining.
    /// </returns>
    function Metadata(const Value: TJSONObject): TVectorStoreUpdateParams;
  end;

  /// <summary>
  /// Represents the counts of files in various processing states within a vector store in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// The <c>TVectorFileCounts</c> class provides detailed counts of files associated with a vector store,
  /// including files that are being processed, successfully completed, failed, or canceled.
  /// This helps monitor the status and progress of file processing in a vector store.
  /// </remarks>
  TVectorFileCounts = class
  private
    [JsonNameAttribute('in_progress')]
    FInProgress: Int64;
    FCompleted: Int64;
    FFailed: Int64;
    FCancelled: Int64;
    FTotal: Int64;
  public
    /// <summary>
    /// Gets or sets the number of files currently being processed in the vector store.
    /// </summary>
    property InProgress: Int64 read FInProgress write FInProgress;
    /// <summary>
    /// Gets or sets the number of files that have been successfully processed and completed.
    /// </summary>
    property Completed: Int64 read FCompleted write FCompleted;
    /// <summary>
    /// Gets or sets the number of files that failed during processing.
    /// </summary>
    property Failed: Int64 read FFailed write FFailed;
    /// <summary>
    /// Gets or sets the number of files whose processing was canceled.
    /// </summary>
    property Cancelled: Int64 read FCancelled write FCancelled;
    /// <summary>
    /// Gets or sets the total number of files associated with the vector store.
    /// </summary>
    property Total: Int64 read FTotal write FTotal;
  end;

  /// <summary>
  /// Represents the expiration policy for a vector store in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// The <c>TExpiresAfter</c> class defines when a vector store will expire based on an anchor timestamp
  /// and the number of days after the anchor. This class is useful for managing the automatic cleanup
  /// or deactivation of vector stores.
  /// </remarks>
  TExpiresAfter = class
  private
    FAnchor: string;
    FDays: Int64;
  public
    /// <summary>
    /// Gets or sets the anchor timestamp that marks the starting point for expiration.
    /// </summary>
    /// <remarks>
    /// The anchor typically specifies the condition that triggers the expiration countdown,
    /// such as <c>last_active_at</c>.
    /// </remarks>
    property Anchor: string read FAnchor write FAnchor;
    /// <summary>
    /// Gets or sets the number of days after the anchor timestamp when the vector store should expire.
    /// </summary>
    /// <remarks>
    /// This value determines the time interval before the vector store expires.
    /// For example, if set to 30, the store will expire 30 days after the anchor date.
    /// </remarks>
    property Days: Int64 read FDays write FDays;
  end;

  TVectorStoreTimestamp = class(TJSONFingerprint)
  protected
    function GetCreatedAtAsString: string; virtual; abstract;
    function GetExpiresAtAsString: string; virtual; abstract;
    function GetLastActiveAtAsString: string; virtual; abstract;
  public
    property CreatedAtAsString: string read GetCreatedAtAsString;
    property ExpiresAtAsString: string read GetExpiresAtAsString;
    property LastActiveAtAsString: string read GetLastActiveAtAsString;
  end;

  /// <summary>
  /// Represents a vector store in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// The <c>TVectorStore</c> class encapsulates the properties and status of a vector store,
  /// including its name, creation timestamp, expiration settings, file usage, and metadata.
  /// A vector store is used to store and retrieve processed files for use by tools such as file search.
  /// </remarks>
  TVectorStore = class(TVectorStoreTimestamp)
  private
    FId: string;
    FObject: string;
    [JsonNameAttribute('created_at')]
    FCreatedAt: TInt64OrNull;
    FName: TStringOrNull;
    [JsonNameAttribute('usage_bytes')]
    FUsageBytes: Int64;
    [JsonNameAttribute('file_counts')]
    FFileCounts: TVectorFileCounts;
    [JsonReflectAttribute(ctString, rtString, TRunStatusInterceptor)]
    FStatus: TRunStatus;
    [JsonNameAttribute('expires_after')]
    FExpiresAfter: TExpiresAfter;
    [JsonNameAttribute('expires_at')]
    FExpiresAt: TInt64OrNull;
    [JsonNameAttribute('last_active_at')]
    FLastActiveAt: TInt64OrNull;
    [JsonReflectAttribute(ctString, rtString, TMetadataInterceptor)]
    FMetadata: string;
  private
    function GetName: string;
    function GetCreatedAt: Int64;
    function GetExpiresAt: Int64;
    function GetLastActiveAt: Int64;
  protected
    function GetCreatedAtAsString: string; override;
    function GetExpiresAtAsString: string; override;
    function GetLastActiveAtAsString: string; override;
  public
    /// <summary>
    /// Gets or sets the unique identifier of the vector store.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Gets or sets the object type, which is always <c>vector_store</c>.
    /// </summary>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// Gets the Unix timestamp (in seconds) for when the vector store was created.
    /// </summary>
    /// <remarks>
    /// If is null then resturns 0
    /// </remarks>
    property CreatedAt: Int64 read GetCreatedAt;
    /// <summary>
    /// Gets the name of the vector store.
    /// </summary>
    property Name: string read GetName;
    /// <summary>
    /// Gets or sets the total number of bytes used by the files in the vector store.
    /// </summary>
    property UsageBytes: Int64 read FUsageBytes write FUsageBytes;
    /// <summary>
    /// Gets or sets the file count details, including the number of completed, failed, or in-progress files.
    /// </summary>
    property FileCounts: TVectorFileCounts read FFileCounts write FFileCounts;
    /// <summary>
    /// Gets or sets the status of the vector store, which can be <c>expired</c>, <c>in_progress</c>, or <c>completed</c>.
    /// </summary>
    property Status: TRunStatus read FStatus write FStatus;
    /// <summary>
    /// Gets or sets the expiration policy for the vector store.
    /// </summary>
    property ExpiresAfter: TExpiresAfter read FExpiresAfter write FExpiresAfter;
    /// <summary>
    /// Gets the Unix timestamp (in seconds) for when the vector store will expire.
    /// </summary>
    /// <remarks>
    /// If null then returns 0.
    /// </remarks>
    property ExpiresAt: Int64 read GetExpiresAt;
    /// <summary>
    /// Gets the Unix timestamp (in seconds) for when the vector store was last active.
    /// </summary>
    /// <remarks>
    /// If null then returns 0
    /// </remarks>
    property LastActiveAt: Int64 read GetLastActiveAt;
    /// <summary>
    /// Gets or sets metadata associated with the vector store, represented as key-value pairs.
    /// </summary>
    property Metadata: string read FMetadata write FMetadata;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a collection of vector stores in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// The <c>TVectorStores</c> class is a list of <c>TVectorStore</c> objects, providing access to multiple
  /// vector stores. It allows iteration over the vector stores to retrieve details such as their status,
  /// usage, expiration policies, and metadata.
  /// </remarks>
  TVectorStores = TAdvancedList<TVectorStore>;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TVectorStore</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynVectorStore</c> type extends the <c>TAsynParams&lt;TVectorStore&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynVectorStore = TAsynCallBack<TVectorStore>;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TVectorStores</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynVectorStores</c> type extends the <c>TAsynParams&lt;TVectorStores&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynVectorStores = TAsynCallBack<TVectorStores>;

  /// <summary>
  /// Provides methods to manage vector stores in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// The <c>TVectorStoreRoute</c> class allows you to create, retrieve, update, list, and delete
  /// vector stores through various API endpoints. It supports both synchronous and asynchronous
  /// operations, making it flexible for different application needs.
  /// </remarks>
  TVectorStoreRoute = class(TGenAIRoute)
  protected
    /// <summary>
    /// Customizes headers for API requests related to vector stores.
    /// </summary>
    procedure HeaderCustomize; override;
  public
    /// <summary>
    /// Asynchronously creates a new vector store.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure for setting the parameters for the vector store, such as file IDs and expiration policy.
    /// </param>
    /// <param name="CallBacks">
    /// The callback functions to handle asynchronous execution and results.
    /// </param>
    procedure AsynCreate(const ParamProc: TProc<TVectorStoreCreateParams>;
      const CallBacks: TFunc<TAsynVectorStore>);
    /// <summary>
    /// Asynchronously retrieves a list of vector stores.
    /// </summary>
    /// <param name="CallBacks">
    /// The callback functions to handle asynchronous execution and results.
    /// </param>
    procedure AsynList(const CallBacks: TFunc<TAsynVectorStores>); overload;
    /// <summary>
    /// Asynchronously retrieves a filtered list of vector stores.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure filtering parameters for the vector store listing.
    /// </param>
    /// <param name="CallBacks">
    /// The callback functions to handle asynchronous execution and results.
    /// </param>
    procedure AsynList(const ParamProc: TProc<TVectorStoreUrlParam>;
      const CallBacks: TFunc<TAsynVectorStores>); overload;
    /// <summary>
    /// Asynchronously retrieves details of a specific vector store.
    /// </summary>
    /// <param name="VectorStoreId">
    /// The unique identifier of the vector store to retrieve.
    /// </param>
    /// <param name="CallBacks">
    /// The callback functions to handle asynchronous execution and results.
    /// </param>
    procedure AsynRetrieve(const VectorStoreId: string;
      const CallBacks: TFunc<TAsynVectorStore>);
    /// <summary>
    /// Asynchronously updates an existing vector store.
    /// </summary>
    /// <param name="VectorStoreId">
    /// The unique identifier of the vector store to update.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure for setting the update parameters, such as name, expiration policy, or metadata.
    /// </param>
    /// <param name="CallBacks">
    /// The callback functions to handle asynchronous execution and results.
    /// </param>
    procedure AsynUpdate(const VectorStoreId: string;
      const ParamProc: TProc<TVectorStoreUpdateParams>;
      const CallBacks: TFunc<TAsynVectorStore>);
    /// <summary>
    /// Asynchronously deletes an existing vector store.
    /// </summary>
    /// <param name="VectorStoreId">
    /// The unique identifier of the vector store to delete.
    /// </param>
    /// <param name="CallBacks">
    /// The callback functions to handle asynchronous execution and results.
    /// </param>
    procedure AsynDelete(const VectorStoreId: string;
      const CallBacks: TFunc<TAsynDeletion>);
    /// <summary>
    /// Synchronously creates a new vector store.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure for configuring the parameters of the new vector store.
    /// </param>
    /// <returns>
    /// A <c>TVectorStore</c> object representing the created vector store.
    /// </returns>
    function Create(const ParamProc: TProc<TVectorStoreCreateParams>): TVectorStore;
    /// <summary>
    /// Synchronously retrieves a list of vector stores.
    /// </summary>
    /// <returns>
    /// A list of <c>TVectorStore</c> objects representing the vector stores.
    /// </returns>
    function List: TVectorStores; overload;
    /// <summary>
    /// Synchronously retrieves a filtered list of vector stores.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure for setting the filtering parameters for the list request.
    /// </param>
    /// <returns>
    /// A list of <c>TVectorStore</c> objects that match the specified criteria.
    /// </returns>
    function List(const ParamProc: TProc<TVectorStoreUrlParam>): TVectorStores; overload;
    /// <summary>
    /// Synchronously retrieves details of a specific vector store.
    /// </summary>
    /// <param name="VectorStoreId">
    /// The unique identifier of the vector store to retrieve.
    /// </param>
    /// <returns>
    /// A <c>TVectorStore</c> object containing the details of the specified vector store.
    /// </returns>
    function Retrieve(const VectorStoreId: string): TVectorStore;
    /// <summary>
    /// Synchronously updates an existing vector store.
    /// </summary>
    /// <param name="VectorStoreId">
    /// The unique identifier of the vector store to update.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure for configuring the update parameters, such as name and expiration settings.
    /// </param>
    /// <returns>
    /// A <c>TVectorStore</c> object representing the updated vector store.
    /// </returns>
    function Update(const VectorStoreId: string; const ParamProc: TProc<TVectorStoreUpdateParams>): TVectorStore;
    /// <summary>
    /// Synchronously deletes a vector store.
    /// </summary>
    /// <param name="VectorStoreId">
    /// The unique identifier of the vector store to delete.
    /// </param>
    /// <returns>
    /// A <c>TDeletion</c> object indicating the status of the deletion.
    /// </returns>
    function Delete(const VectorStoreId: string): TDeletion;
  end;

implementation

{ TVectorStoreCreateParams }

function TVectorStoreCreateParams.ChunkingStrategy(
  const Value: TChunkingStrategyParams): TVectorStoreCreateParams;
begin
  Result := TVectorStoreCreateParams(Add('chunking_strategy', Value.Detach));
end;

function TVectorStoreCreateParams.ExpiresAfter(
  const Value: TExpiresAfterParams): TVectorStoreCreateParams;
begin
  Result := TVectorStoreCreateParams(Add('expires_after', Value.Detach));
end;

function TVectorStoreCreateParams.FileIds(const Value: TArray<string>): TVectorStoreCreateParams;
begin
  Result := TVectorStoreCreateParams(Add('file_ids', Value));
end;

function TVectorStoreCreateParams.Metadata(
  const Value: TJSONObject): TVectorStoreCreateParams;
begin
  Result := TVectorStoreCreateParams(Add('metadata', Value));
end;

function TVectorStoreCreateParams.Name(const Value: string): TVectorStoreCreateParams;
begin
  Result := TVectorStoreCreateParams(Add('name', Value));
end;

{ TExpiresAfterParams }

function TExpiresAfterParams.Anchor(const Value: string): TExpiresAfterParams;
begin
  Result := TExpiresAfterParams(Add('anchor', Value));
end;

function TExpiresAfterParams.Days(const Value: Integer): TExpiresAfterParams;
begin
  Result := TExpiresAfterParams(Add('days', Value));
end;

{ TVectorStore }

destructor TVectorStore.Destroy;
begin
  if Assigned(FFileCounts) then
    FFileCounts.Free;
  if Assigned(FExpiresAfter) then
    FExpiresAfter.Free;
  inherited;
end;

function TVectorStore.GetCreatedAt: Int64;
begin
  Result := TInt64OrNull(FCreatedAt).ToInteger;
end;

function TVectorStore.GetCreatedAtAsString: string;
begin
  Result := TInt64OrNull(FCreatedAt).ToUtcDateString;
end;

function TVectorStore.GetExpiresAt: Int64;
begin
  Result := TInt64OrNull(FExpiresAt).ToInteger;
end;

function TVectorStore.GetExpiresAtAsString: string;
begin
  Result := TInt64OrNull(FExpiresAt).ToUtcDateString;
end;

function TVectorStore.GetLastActiveAt: Int64;
begin
  Result := TInt64OrNull(FLastActiveAt).ToInteger;
end;

function TVectorStore.GetLastActiveAtAsString: string;
begin
  Result := TInt64OrNull(FLastActiveAt).ToUtcDateString;
end;

function TVectorStore.GetName: string;
begin
  Result := TStringOrNull(FName).ToString;
end;

{ TVectorStoreRoute }

procedure TVectorStoreRoute.AsynCreate(
  const ParamProc: TProc<TVectorStoreCreateParams>;
  const CallBacks: TFunc<TAsynVectorStore>);
begin
  with TAsynCallBackExec<TAsynVectorStore, TVectorStore>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TVectorStore
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TVectorStoreRoute.AsynDelete(const VectorStoreId: string;
  const CallBacks: TFunc<TAsynDeletion>);
begin
  with TAsynCallBackExec<TAsynDeletion, TDeletion>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TDeletion
      begin
        Result := Self.Delete(VectorStoreId);
      end);
  finally
    Free;
  end;
end;

procedure TVectorStoreRoute.AsynList(const CallBacks: TFunc<TAsynVectorStores>);
begin
  with TAsynCallBackExec<TAsynVectorStores, TVectorStores>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TVectorStores
      begin
        Result := Self.List;
      end);
  finally
    Free;
  end;
end;

procedure TVectorStoreRoute.AsynList(
  const ParamProc: TProc<TVectorStoreUrlParam>;
  const CallBacks: TFunc<TAsynVectorStores>);
begin
  with TAsynCallBackExec<TAsynVectorStores, TVectorStores>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TVectorStores
      begin
        Result := Self.List(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TVectorStoreRoute.AsynRetrieve(const VectorStoreId: string;
  const CallBacks: TFunc<TAsynVectorStore>);
begin
  with TAsynCallBackExec<TAsynVectorStore, TVectorStore>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TVectorStore
      begin
        Result := Self.Retrieve(VectorStoreId);
      end);
  finally
    Free;
  end;
end;

procedure TVectorStoreRoute.AsynUpdate(const VectorStoreId: string;
  const ParamProc: TProc<TVectorStoreUpdateParams>;
  const CallBacks: TFunc<TAsynVectorStore>);
begin
  with TAsynCallBackExec<TAsynVectorStore, TVectorStore>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TVectorStore
      begin
        Result := Self.Update(VectorStoreId, ParamProc);
      end);
  finally
    Free;
  end;
end;

function TVectorStoreRoute.Create(
  const ParamProc: TProc<TVectorStoreCreateParams>): TVectorStore;
begin
  HeaderCustomize;
  Result := API.Post<TVectorStore, TVectorStoreCreateParams>('vector_stores', ParamProc);
end;

function TVectorStoreRoute.Delete(
  const VectorStoreId: string): TDeletion;
begin
  HeaderCustomize;
  Result := API.Delete<TDeletion>('vector_stores/' + VectorStoreId);
end;

procedure TVectorStoreRoute.HeaderCustomize;
begin
  inherited;
  API.CustomHeaders := [TNetHeader.Create('OpenAI-Beta', 'assistants=v2')];
end;

function TVectorStoreRoute.List: TVectorStores;
begin
  HeaderCustomize;
  Result := API.Get<TVectorStores>('vector_stores');
end;

function TVectorStoreRoute.List(
  const ParamProc: TProc<TVectorStoreUrlParam>): TVectorStores;
begin
  HeaderCustomize;
  Result := API.Get<TVectorStores, TVectorStoreUrlParam>('vector_stores', ParamProc);
end;

function TVectorStoreRoute.Retrieve(const VectorStoreId: string): TVectorStore;
begin
  HeaderCustomize;
  Result := API.Get<TVectorStore>('vector_stores/' + VectorStoreId);
end;

function TVectorStoreRoute.Update(const VectorStoreId: string;
  const ParamProc: TProc<TVectorStoreUpdateParams>): TVectorStore;
begin
  HeaderCustomize;
  Result := API.Post<TVectorStore, TVectorStoreUpdateParams>('vector_stores/' + VectorStoreId, ParamProc);
end;

{ TVectorStoreUpdateParams }

function TVectorStoreUpdateParams.ExpiresAfter(
  const Value: TExpiresAfterParams): TVectorStoreUpdateParams;
begin
  Result := TVectorStoreUpdateParams(Add('expires_after', Value.Detach));
end;

function TVectorStoreUpdateParams.Metadata(
  const Value: TJSONObject): TVectorStoreUpdateParams;
begin
  Result := TVectorStoreUpdateParams(Add('metadata', Value));
end;

function TVectorStoreUpdateParams.Name(
  const Value: string): TVectorStoreUpdateParams;
begin
  Result := TVectorStoreUpdateParams(Add('name', Value));
end;

end.

unit GenAI.VectorBatch;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Threading, System.JSON, REST.Json.Types,
  REST.JsonReflect, System.Net.URLClient,
  GenAI.API.Params, GenAI.API, GenAI.Consts, GenAI.Types, GenAI.Async.Support,
  GenAI.API.Lists, GenAI.Assistants, GenAI.Runs, GenAI.Vector, GenAI.VectorFiles;

type
  /// <summary>
  /// Represents URL parameters for configuring requests related to file batches in a vector store using the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TVectorStoreFilesUrlParams</c> and provides the ability to customize the URL query parameters
  /// when listing or filtering batches of files associated with a specific vector store.
  /// It is useful for narrowing down results or retrieving batches with particular statuses.
  /// </remarks>
  TVectorStoreBatchUrlParams = TVectorStoreFilesUrlParams;

  /// <summary>
  /// Represents the parameters for creating file batches in a vector store using the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TVectorStoreFilesCreateParams</c> and allows users to define key parameters
  /// when creating a new batch of files in a vector store, including the file IDs and chunking strategy.
  /// These settings control how files are processed and chunked before being stored.
  /// </remarks>
  TVectorStoreBatchCreateParams = class(TJSONParam)
  public
    /// <summary>
    /// Specifies the ID of the file to be attached to the vector store.
    /// </summary>
    /// <param name="Value">
    /// A string representing the unique identifier of the file to be added to the vector store.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TVectorStoreBatchCreateParams</c>, enabling method chaining.
    /// </returns>
    /// <remarks>
    /// This method is essential for indicating which file should be chunked and processed
    /// when creating a new vector store entry.
    /// </remarks>
    function FileId(const Value: TArray<string>): TVectorStoreBatchCreateParams;
    /// <summary>
    /// Specifies the chunking strategy to be used when processing the file.
    /// </summary>
    /// <param name="Value">
    /// An instance of <c>TChunkingStrategyParams</c> that defines settings like maximum chunk size
    /// and token overlap for dividing the file into smaller chunks.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TVectorStoreBatchCreateParams</c>, enabling method chaining.
    /// </returns>
    /// <remarks>
    /// The chunking strategy determines how the file is split for efficient searching and retrieval
    /// within the vector store. Users can define static or auto chunking depending on their use case.
    /// </remarks>
    function ChunkingStrategy(const Value: TChunkingStrategyParams): TVectorStoreBatchCreateParams;
  end;

  /// <summary>
  /// Represents a batch of files attached to a vector store in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class provides details about a file batch within a vector store, including its creation timestamp,
  /// status, and the number of files processed. It is used to monitor and manage the batch processing of files
  /// for indexing and retrieval in the vector store.
  /// </remarks>
  TVectorStoreBatch = class(TJSONFingerprint)
  private
    FId: string;
    FObject: string;
    [JsonNameAttribute('created_at')]
    FCreatedAt: TInt64OrNull;
    [JsonNameAttribute('vector_store_id')]
    FVectorStoreId: string;
    [JsonReflectAttribute(ctString, rtString, TRunStatusInterceptor)]
    FStatus: TRunStatus;
    [JsonNameAttribute('file_counts')]
    FFileCounts: TVectorFileCounts;
  private
    function GetCreatedAtAsString: string;
    function GetCreatedAt: Int64;
  public
    /// <summary>
    /// Gets or sets the unique identifier of the file batch.
    /// </summary>
    /// <remarks>
    /// This identifier can be used to reference the file batch in API requests such as retrieving
    /// or canceling the batch.
    /// </remarks>
    property Id: string read FId write FId;
    /// <summary>
    /// Gets or sets the object type, which is always <c>vector_store.file_batch</c>.
    /// </summary>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// Gets Unix timestamp (in seconds) indicating when the file batch was created.
    /// </summary>
    property CreatedAt: Int64 read GetCreatedAt;
    /// <summary>
    /// Gets the human-readable representation of the creation timestamp.
    /// </summary>
    /// <remarks>
    /// This property converts the Unix timestamp into a readable date string to make it easier
    /// to understand when the batch was created.
    /// </remarks>
    property CreatedAtAsString: string read GetCreatedAtAsString;
    /// <summary>
    /// Gets or sets the identifier of the vector store to which this file batch belongs.
    /// </summary>
    property VectorStoreId: string read FVectorStoreId write FVectorStoreId;
    /// <summary>
    /// Gets or sets the current processing status of the file batch.
    /// </summary>
    /// <remarks>
    /// The status can be one of the following: <c>in_progress</c>, <c>completed</c>, <c>failed</c>,
    /// or <c>cancelled</c>. This status helps in monitoring the batch processing progress.
    /// </remarks>
    property Status: TRunStatus read FStatus write FStatus;
    /// <summary>
    /// Gets or sets the statistics of the files within the batch, including the counts of completed,
    /// failed, and in-progress files.
    /// </summary>
    property FileCounts: TVectorFileCounts read FFileCounts write FFileCounts;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a list of file batches attached to a vector store in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class extends <c>TAdvancedList&lt;TVectorStoreBatch&gt;</c> and provides an iterable
  /// collection of file batches within a vector store. Each batch contains information such as
  /// its status, creation timestamp, and file counts.
  /// </remarks>
  TVectorStoreBatches = TAdvancedList<TVectorStoreBatch>;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TVectorStoreBatch</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynVectorStoreBatch</c> type extends the <c>TAsynParams&lt;TVectorStoreBatch&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynVectorStoreBatch = TAsynCallBack<TVectorStoreBatch>;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TVectorStoreBatches</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynVectorStoreBatches</c> type extends the <c>TAsynParams&lt;TVectorStoreBatches&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynVectorStoreBatches = TAsynCallBack<TVectorStoreBatches>;

  /// <summary>
  /// Provides methods to manage file batches within a vector store using the OpenAI API.
  /// </summary>
  /// <remarks>
  /// This class allows users to create, retrieve, cancel, and list file batches associated
  /// with a specific vector store. It supports both synchronous and asynchronous operations,
  /// enabling flexible interaction with the API for managing batch processing.
  /// </remarks>
  TVectorStoreBatchRoute = class(TGenAIRoute)
  protected
    /// <summary>
    /// Customizes headers for API requests related to vector store batches.
    /// </summary>
    procedure HeaderCustomize; override;
  public
    /// <summary>
    /// Asynchronously creates a new file batch in the specified vector store.
    /// </summary>
    /// <param name="VectorStoreId">
    /// The unique identifier of the vector store where the file batch will be created.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure the parameters for creating the batch, such as the list of file IDs
    /// and chunking strategy.
    /// </param>
    /// <param name="CallBacks">
    /// The callback functions to handle asynchronous execution and results.
    /// </param>
    procedure AsynCreate(const VectorStoreId: string;
      const ParamProc: TProc<TVectorStoreBatchCreateParams>;
      const CallBacks: TFunc<TAsynVectorStoreBatch>);
    /// <summary>
    /// Asynchronously retrieves details of a specific file batch within a vector store.
    /// </summary>
    /// <param name="VectorStoreId">
    /// The unique identifier of the vector store containing the batch.
    /// </param>
    /// <param name="BatchId">
    /// The unique identifier of the file batch to be retrieved.
    /// </param>
    /// <param name="CallBacks">
    /// The callback functions to handle asynchronous execution and results.
    /// </param>
    procedure AsynRetrieve(const VectorStoreId: string;
      const BatchId: string;
      const CallBacks: TFunc<TAsynVectorStoreBatch>);
    /// <summary>
    /// Asynchronously cancels a file batch that is currently being processed.
    /// </summary>
    /// <param name="VectorStoreId">
    /// The unique identifier of the vector store containing the batch.
    /// </param>
    /// <param name="BatchId">
    /// The unique identifier of the file batch to be canceled.
    /// </param>
    /// <param name="CallBacks">
    /// The callback functions to handle asynchronous execution and results.
    /// </param>
    /// <remarks>
    /// Cancelling a batch stops the processing of any files in progress as soon as possible.
    /// </remarks>
    procedure AsynCancel(const VectorStoreId: string;
      const BatchId: string;
      const CallBacks: TFunc<TAsynVectorStoreBatch>);
    /// <summary>
    /// Asynchronously lists all files within a specific batch of the vector store.
    /// </summary>
    /// <param name="VectorStoreId">
    /// The unique identifier of the vector store containing the file batch.
    /// </param>
    /// <param name="BatchId">
    /// The unique identifier of the file batch.
    /// </param>
    /// <param name="CallBacks">
    /// The callback functions to handle asynchronous execution and results.
    /// </param>
    procedure AsynList(const VectorStoreId: string;
      const BatchId: string;
      const CallBacks: TFunc<TAsynVectorStoreBatches>); overload;
    /// <summary>
    /// Asynchronously lists files in the specified file batch using filters and URL parameters.
    /// </summary>
    /// <param name="VectorStoreId">
    /// The unique identifier of the vector store containing the file batch.
    /// </param>
    /// <param name="BatchId">
    /// The unique identifier of the file batch.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure filters or pagination options for the file listing.
    /// </param>
    /// <param name="CallBacks">
    /// The callback functions to handle asynchronous execution and results.
    /// </param>
    procedure AsynList(const VectorStoreId: string;
      const BatchId: string;
      const ParamProc: TProc<TVectorStoreBatchUrlParams>;
      const CallBacks: TFunc<TAsynVectorStoreBatches>); overload;
    /// <summary>
    /// Synchronously creates a new file batch in the specified vector store.
    /// </summary>
    /// <param name="VectorStoreId">
    /// The unique identifier of the vector store where the file batch will be created.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure the parameters for creating the batch, such as file IDs
    /// and chunking strategy.
    /// </param>
    /// <returns>
    /// A <c>TVectorStoreBatch</c> object representing the created batch.
    /// </returns>
    function Create(const VectorStoreId: string; const ParamProc: TProc<TVectorStoreBatchCreateParams>): TVectorStoreBatch;
    /// <summary>
    /// Synchronously retrieves details of a specific file batch within a vector store.
    /// </summary>
    /// <param name="VectorStoreId">
    /// The unique identifier of the vector store containing the batch.
    /// </param>
    /// <param name="BatchId">
    /// The unique identifier of the file batch to be retrieved.
    /// </param>
    /// <returns>
    /// A <c>TVectorStoreBatch</c> object containing details about the specified batch.
    /// </returns>
    function Retrieve(const VectorStoreId: string; const BatchId: string): TVectorStoreBatch;
    /// <summary>
    /// Synchronously cancels a file batch that is currently being processed.
    /// </summary>
    /// <param name="VectorStoreId">
    /// The unique identifier of the vector store containing the batch.
    /// </param>
    /// <param name="BatchId">
    /// The unique identifier of the file batch to be canceled.
    /// </param>
    /// <returns>
    /// A <c>TVectorStoreBatch</c> object representing the batch after cancellation.
    /// </returns>
    function Cancel(const VectorStoreId: string; const BatchId: string): TVectorStoreBatch;
    /// <summary>
    /// Synchronously lists all files within a specific batch of the vector store.
    /// </summary>
    /// <param name="VectorStoreId">
    /// The unique identifier of the vector store containing the file batch.
    /// </param>
    /// <param name="BatchId">
    /// The unique identifier of the file batch.
    /// </param>
    /// <returns>
    /// A list of file batches as a <c>TVectorStoreBatches</c> object.
    /// </returns>
    function List(const VectorStoreId: string; const BatchId: string): TVectorStoreBatches; overload;
    /// <summary>
    /// Synchronously lists files in the specified file batch using filters and URL parameters.
    /// </summary>
    /// <param name="VectorStoreId">
    /// The unique identifier of the vector store containing the file batch.
    /// </param>
    /// <param name="BatchId">
    /// The unique identifier of the file batch.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure filters or pagination options for the file listing.
    /// </param>
    /// <returns>
    /// A list of file batches as a <c>TVectorStoreBatches</c> object.
    /// </returns>
    function List(const VectorStoreId: string; const BatchId: string;
      const ParamProc: TProc<TVectorStoreBatchUrlParams>): TVectorStoreBatches; overload;
  end;

implementation

{ TVectorStoreBatch }

destructor TVectorStoreBatch.Destroy;
begin
  if Assigned(FFileCounts) then
    FFileCounts.Free;
  inherited;
end;

function TVectorStoreBatch.GetCreatedAt: Int64;
begin
  Result := TInt64OrNull(FCreatedAt).ToInteger;
end;

function TVectorStoreBatch.GetCreatedAtAsString: string;
begin
  Result := TInt64OrNull(FCreatedAt).ToUtcDateString;
end;

{ TVectorStoreBatchRoute }

procedure TVectorStoreBatchRoute.AsynCancel(const VectorStoreId,
  BatchId: string; const CallBacks: TFunc<TAsynVectorStoreBatch>);
begin
  with TAsynCallBackExec<TAsynVectorStoreBatch, TVectorStoreBatch>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TVectorStoreBatch
      begin
        Result := Self.Cancel(VectorStoreId, BatchId);
      end);
  finally
    Free;
  end;
end;

procedure TVectorStoreBatchRoute.AsynCreate(const VectorStoreId: string;
  const ParamProc: TProc<TVectorStoreBatchCreateParams>;
  const CallBacks: TFunc<TAsynVectorStoreBatch>);
begin
  with TAsynCallBackExec<TAsynVectorStoreBatch, TVectorStoreBatch>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TVectorStoreBatch
      begin
        Result := Self.Create(VectorStoreId, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TVectorStoreBatchRoute.AsynList(const VectorStoreId, BatchId: string;
  const ParamProc: TProc<TVectorStoreBatchUrlParams>;
  const CallBacks: TFunc<TAsynVectorStoreBatches>);
begin
  with TAsynCallBackExec<TAsynVectorStoreBatches, TVectorStoreBatches>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TVectorStoreBatches
      begin
        Result := Self.List(VectorStoreId, BatchId, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TVectorStoreBatchRoute.AsynList(const VectorStoreId, BatchId: string;
  const CallBacks: TFunc<TAsynVectorStoreBatches>);
begin
  with TAsynCallBackExec<TAsynVectorStoreBatches, TVectorStoreBatches>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TVectorStoreBatches
      begin
        Result := Self.List(VectorStoreId, BatchId);
      end);
  finally
    Free;
  end;
end;

procedure TVectorStoreBatchRoute.AsynRetrieve(const VectorStoreId,
  BatchId: string; const CallBacks: TFunc<TAsynVectorStoreBatch>);
begin
  with TAsynCallBackExec<TAsynVectorStoreBatch, TVectorStoreBatch>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TVectorStoreBatch
      begin
        Result := Self.Retrieve(VectorStoreId, BatchId);
      end);
  finally
    Free;
  end;
end;

function TVectorStoreBatchRoute.Cancel(const VectorStoreId,
  BatchId: string): TVectorStoreBatch;
begin
  HeaderCustomize;
  Result := API.Post<TVectorStoreBatch>('vector_stores/' + VectorStoreId + '/file_batches/' + BatchId + '/cancel');
end;

function TVectorStoreBatchRoute.Create(const VectorStoreId: string;
  const ParamProc: TProc<TVectorStoreBatchCreateParams>): TVectorStoreBatch;
begin
  HeaderCustomize;
  Result := API.Post<TVectorStoreBatch, TVectorStoreBatchCreateParams>('vector_stores/' + VectorStoreId + '/file_batches', ParamProc);
end;

procedure TVectorStoreBatchRoute.HeaderCustomize;
begin
  inherited;
  API.CustomHeaders := [TNetHeader.Create('OpenAI-Beta', 'assistants=v2')];
end;

function TVectorStoreBatchRoute.List(const VectorStoreId, BatchId: string;
  const ParamProc: TProc<TVectorStoreBatchUrlParams>): TVectorStoreBatches;
begin
  HeaderCustomize;
  Result := API.Get<TVectorStoreBatches, TVectorStoreBatchUrlParams>('vector_stores/' + VectorStoreId + '/file_batches/' + BatchId + '/files', ParamProc);
end;

function TVectorStoreBatchRoute.List(const VectorStoreId,
  BatchId: string): TVectorStoreBatches;
begin
  HeaderCustomize;
  Result := API.Get<TVectorStoreBatches>('vector_stores/' + VectorStoreId + '/file_batches/' + BatchId + '/files');
end;

function TVectorStoreBatchRoute.Retrieve(const VectorStoreId,
  BatchId: string): TVectorStoreBatch;
begin
  HeaderCustomize;
  Result := API.Get<TVectorStoreBatch>('vector_stores/' + VectorStoreId + '/file_batches/' + BatchId);
end;

{ TVectorStoreBatchCreateParams }

function TVectorStoreBatchCreateParams.ChunkingStrategy(
  const Value: TChunkingStrategyParams): TVectorStoreBatchCreateParams;
begin
  Result := TVectorStoreBatchCreateParams(Add('chunking_strategy', Value.Detach));
end;

function TVectorStoreBatchCreateParams.FileId(
  const Value: TArray<string>): TVectorStoreBatchCreateParams;
begin
  Result := TVectorStoreBatchCreateParams(Add('file_ids', Value));
end;

end.

unit GenAI.VectorFiles;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGenAI
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Threading, System.JSON, REST.Json.Types,
  REST.JsonReflect, System.Net.URLClient,
  GenAI.API.Params, GenAI.API, GenAI.Consts, GenAI.Types, GenAI.Async.Support,
  GenAI.API.Lists, GenAI.API.Deletion, GenAI.Assistants, GenAI.Runs;

type
  /// <summary>
  /// Represents URL parameters for configuring requests related to vector store files in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// The <c>TVectorStoreFilesUrlParams</c> class allows users to customize the URL query parameters
  /// when listing or filtering files associated with a specific vector store.
  /// This is useful when retrieving files with particular statuses or conditions.
  /// </remarks>
  TVectorStoreFilesUrlParams = class(TUrlAdvancedParams)
  public
    /// <summary>
    /// Filters the results of the vector store files request based on a given file status.
    /// </summary>
    /// <param name="Value">
    /// A string representing the file status to filter by. Supported values typically include
    /// statuses such as <c>in_progress</c>, <c>completed</c>, <c>failed</c>, or <c>cancelled</c>.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TVectorStoreFilesUrlParams</c>, enabling method chaining.
    /// </returns>
    /// <remarks>
    /// This method is useful for narrowing down the results to only those files with a particular
    /// status within the vector store, improving query efficiency and clarity of results.
    /// </remarks>
    function Filter(const Value: string): TVectorStoreFilesUrlParams;
  end;

  /// <summary>
  /// Represents parameters for creating vector store files in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// The <c>TVectorStoreFilesCreateParams</c> class allows users to specify key parameters such as
  /// the file ID and chunking strategy when adding a file to a vector store. These parameters
  /// determine how the file will be chunked and indexed within the vector store.
  /// </remarks>
  TVectorStoreFilesCreateParams = class(TJSONParam)
  public
    /// <summary>
    /// Specifies the ID of the file to be attached to the vector store.
    /// </summary>
    /// <param name="Value">
    /// A string representing the unique identifier of the file to be added to the vector store.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TVectorStoreFilesCreateParams</c>, enabling method chaining.
    /// </returns>
    /// <remarks>
    /// This method is essential for indicating which file should be chunked and processed
    /// when creating a new vector store entry.
    /// </remarks>
    function FileId(const Value: string): TVectorStoreFilesCreateParams;
    /// <summary>
    /// Specifies the chunking strategy to be used when processing the file.
    /// </summary>
    /// <param name="Value">
    /// An instance of <c>TChunkingStrategyParams</c> that defines settings like maximum chunk size
    /// and token overlap for dividing the file into smaller chunks.
    /// </param>
    /// <returns>
    /// Returns the current instance of <c>TVectorStoreFilesCreateParams</c>, enabling method chaining.
    /// </returns>
    /// <remarks>
    /// The chunking strategy determines how the file is split for efficient searching and retrieval
    /// within the vector store. Users can define static or auto chunking depending on their use case.
    /// </remarks>
    function ChunkingStrategy(const Value: TChunkingStrategyParams): TVectorStoreFilesCreateParams;
  end;

  /// <summary>
  /// Represents the static chunking strategy settings for dividing files into chunks in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// The <c>TChunkingStrategyStatic</c> class defines the static configuration for chunking a file
  /// into smaller, overlapping segments. This strategy is used when users want precise control over
  /// the size and overlap of the chunks.
  /// </remarks>
  TChunkingStrategyStatic = class
  private
    [JsonNameAttribute('max_chunk_size_tokens')]
    FMaxChunkSizeTokens: Int64;
    [JsonNameAttribute('chunk_overlap_tokens')]
    FChunkOverlapTokens: Int64;
  public
    /// <summary>
    /// Specifies the maximum number of tokens allowed in each chunk.
    /// </summary>
    /// <remarks>
    /// The default value is typically 800 tokens. The minimum value is 100, and the maximum
    /// value is 4096. This setting controls how large each chunk will be when splitting the file.
    /// </remarks>
    property MaxChunkSizeTokens: Int64 read FMaxChunkSizeTokens write FMaxChunkSizeTokens;
    /// <summary>
    /// Specifies the number of tokens that overlap between consecutive chunks.
    /// </summary>
    /// <remarks>
    /// The default value is 400 tokens. The overlap should not exceed half of
    /// <c>MaxChunkSizeTokens</c>. Overlapping tokens help preserve context between chunks
    /// and improve search accuracy within the vector store.
    /// </remarks>
    property ChunkOverlapTokens: Int64 read FChunkOverlapTokens write FChunkOverlapTokens;
  end;

  /// <summary>
  /// Represents the chunking strategy configuration used for splitting files into chunks in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// The <c>TChunkingStrategy</c> class defines how files are divided into chunks for indexing in a vector store.
  /// It supports both static and dynamic chunking strategies, depending on the configuration.
  /// </remarks>
  TChunkingStrategy = class
  private
    FType: string;
    FStatic: TChunkingStrategyStatic;
  public
    /// <summary>
    /// Specifies the type of chunking strategy being used.
    /// </summary>
    /// <remarks>
    /// The value of this property typically indicates the strategy type, such as <c>static</c>
    /// or <c>auto</c>. This helps determine how the chunking process is handled.
    /// </remarks>
    property &Type: string read FType write FType;
    /// <summary>
    /// Specifies the static chunking configuration for the vector store file.
    /// </summary>
    /// <remarks>
    /// This property contains settings for static chunking, including the maximum chunk size
    /// and token overlap. It is used when the chunking strategy is explicitly defined as static.
    /// </remarks>
    property Static: TChunkingStrategyStatic read FStatic write FStatic;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a file attached to a vector store in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// The <c>TVectorStoreFile</c> class encapsulates details about a file added to a vector store,
  /// including its ID, usage, creation timestamp, status, and chunking strategy. This information
  /// is used to monitor file processing and storage within the vector store.
  /// </remarks>
  TVectorStoreFile = class(TJSONFingerprint)
  private
    FId: string;
    FObject: string;
    [JsonNameAttribute('usage_bytes')]
    FUsageBytes: Int64;
    [JsonNameAttribute('created_at')]
    FCreatedAt: TInt64OrNull;
    [JsonNameAttribute('vector_store_id')]
    FVectorStoreId: string;
    [JsonReflectAttribute(ctString, rtString, TRunStatusInterceptor)]
    FStatus: TRunStatus;
    [JsonNameAttribute('last_error')]
    FLastError: TLastError;
    [JsonNameAttribute('chunking_strategy')]
    FChunkingStrategy: TChunkingStrategy;
  private
    function GetCreatedAt: Int64;
    function GetCreatedAtAsString: string;
  public
    /// <summary>
    /// Gets or sets the unique identifier of the vector store file.
    /// </summary>
    property Id: string read FId write FId;
    /// <summary>
    /// Gets or sets the object type, which is always <c>vector_store.file</c>.
    /// </summary>
    property &Object: string read FObject write FObject;
    /// <summary>
    /// Gets or sets the total usage of the file in bytes within the vector store.
    /// </summary>
    /// <remarks>
    /// This value represents the amount of storage the file consumes after being chunked and indexed.
    /// </remarks>
    property UsageBytes: Int64 read FUsageBytes write FUsageBytes;
    /// <summary>
    /// Gets or sets the Unix timestamp (in seconds) indicating when the file was added to the vector store.
    /// </summary>
    property CreatedAt: Int64 read GetCreatedAt;
    /// <summary>
    /// Gets the human-readable representation of the creation timestamp.
    /// </summary>
    property CreatedAtAsString: string read GetCreatedAtAsString;
    /// <summary>
    /// Gets or sets the identifier of the vector store that the file belongs to.
    /// </summary>
    property VectorStoreId: string read FVectorStoreId write FVectorStoreId;
    /// <summary>
    /// Gets or sets the current processing status of the vector store file.
    /// </summary>
    /// <remarks>
    /// The status can be one of the following: <c>in_progress</c>, <c>completed</c>, <c>failed</c>,
    /// or <c>cancelled</c>. This status helps in monitoring the file's processing progress.
    /// </remarks>
    property Status: TRunStatus read FStatus write FStatus;
    /// <summary>
    /// Gets or sets the details of the last error that occurred while processing the file.
    /// </summary>
    /// <remarks>
    /// This property contains information about any errors encountered during file processing.
    /// If no errors occurred, the value is <c>null</c>.
    /// </remarks>
    property LastError: TLastError read FLastError write FLastError;
    /// <summary>
    /// Gets or sets the chunking strategy used to split the file.
    /// </summary>
    /// <remarks>
    /// This property defines the settings used to divide the file into smaller, overlapping chunks
    /// for indexing and search efficiency within the vector store.
    /// </remarks>
    property ChunkingStrategy: TChunkingStrategy read FChunkingStrategy write FChunkingStrategy;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a list of files attached to a vector store in the OpenAI API.
  /// </summary>
  /// <remarks>
  /// The <c>TVectorStoreFiles</c> class is a collection of <c>TVectorStoreFile</c> objects,
  /// providing access to details about multiple files within a vector store. It supports
  /// iteration, allowing users to retrieve information about each file, such as its status,
  /// usage, and chunking strategy.
  /// </remarks>
  TVectorStoreFiles = TAdvancedList<TVectorStoreFile>;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TVectorStoreFile</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynVectorStoreFile</c> type extends the <c>TAsynParams&lt;TVectorStoreFile&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynVectorStoreFile = TAsynCallBack<TVectorStoreFile>;

  /// <summary>
  /// Manages asynchronous callBacks for a request using <c>TVectorStoreFiles</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynVectorStoreFiles</c> type extends the <c>TAsynParams&lt;TVectorStoreFiles&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking operations.
  /// </remarks>
  TAsynVectorStoreFiles = TAsynCallBack<TVectorStoreFiles>;

  /// <summary>
  /// Provides methods to manage files within a vector store using the OpenAI API.
  /// </summary>
  /// <remarks>
  /// The <c>TVectorStoreFilesRoute</c> class allows users to create, retrieve, list, and delete
  /// files associated with a vector store. It supports both synchronous and asynchronous
  /// operations, enabling flexible interaction with the API for managing file storage and processing.
  /// </remarks>
  TVectorStoreFilesRoute = class(TGenAIRoute)
  protected
    /// <summary>
    /// Customizes headers for API requests related to vector store files.
    /// </summary>
    procedure HeaderCustomize; override;
  public
    /// <summary>
    /// Asynchronously creates a new file in the specified vector store.
    /// </summary>
    /// <param name="VectorStoreId">
    /// The unique identifier of the vector store where the file will be added.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure that configures the parameters for creating the file, such as the file ID
    /// and chunking strategy.
    /// </param>
    /// <param name="CallBacks">
    /// The callback functions to handle asynchronous execution and results.
    /// </param>
    procedure AsynCreate(const VectorStoreId: string; const ParamProc: TProc<TVectorStoreFilesCreateParams>;
      const CallBacks: TFunc<TAsynVectorStoreFile>);
    /// <summary>
    /// Asynchronously retrieves a list of files from a specified vector store.
    /// </summary>
    /// <param name="VectorStoreId">
    /// The unique identifier of the vector store from which to retrieve the files.
    /// </param>
    /// <param name="CallBacks">
    /// The callback functions to handle asynchronous execution and results.
    /// </param>
    procedure AsynList(const VectorStoreId: string;
      const CallBacks: TFunc<TAsynVectorStoreFiles>); overload;
    /// <summary>
    /// Asynchronously retrieves a filtered list of files from a specified vector store.
    /// </summary>
    /// <param name="VectorStoreId">
    /// The unique identifier of the vector store from which to retrieve the files.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure filtering parameters for the list request, such as file status.
    /// </param>
    /// <param name="CallBacks">
    /// The callback functions to handle asynchronous execution and results.
    /// </param>
    procedure AsynList(const VectorStoreId: string;
      const ParamProc: TProc<TVectorStoreFilesUrlParams>;
      const CallBacks: TFunc<TAsynVectorStoreFiles>); overload;
    /// <summary>
    /// Asynchronously retrieves details of a specific file within a vector store.
    /// </summary>
    /// <param name="VectorStoreId">
    /// The unique identifier of the vector store containing the file.
    /// </param>
    /// <param name="FileId">
    /// The unique identifier of the file to be retrieved.
    /// </param>
    /// <param name="CallBacks">
    /// The callback functions to handle asynchronous execution and results.
    /// </param>
    procedure AsynRetrieve(const VectorStoreId: string; const FileId: string;
      const CallBacks: TFunc<TAsynVectorStoreFile>);
    /// <summary>
    /// Asynchronously deletes a file from the specified vector store.
    /// </summary>
    /// <param name="VectorStoreId">
    /// The unique identifier of the vector store from which to delete the file.
    /// </param>
    /// <param name="FileId">
    /// The unique identifier of the file to be deleted.
    /// </param>
    /// <param name="CallBacks">
    /// The callback functions to handle asynchronous execution and results.
    /// </param>
    procedure AsynDelete(const VectorStoreId: string; const FileId: string;
      const CallBacks: TFunc<TAsynDeletion>);
    /// <summary>
    /// Synchronously creates a new file in the specified vector store.
    /// </summary>
    /// <param name="VectorStoreId">
    /// The unique identifier of the vector store where the file will be added.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure that configures the parameters for creating the file, such as the file ID
    /// and chunking strategy.
    /// </param>
    /// <returns>
    /// A <c>TVectorStoreFile</c> object representing the created file.
    /// </returns>
    function Create(const VectorStoreId: string; const ParamProc: TProc<TVectorStoreFilesCreateParams>): TVectorStoreFile;
    /// <summary>
    /// Synchronously retrieves a list of files from a specified vector store.
    /// </summary>
    /// <param name="VectorStoreId">
    /// The unique identifier of the vector store from which to retrieve the files.
    /// </param>
    /// <returns>
    /// A <c>TVectorStoreFiles</c> list containing information about the files.
    /// </returns>
    function List(const VectorStoreId: string): TVectorStoreFiles; overload;
    /// <summary>
    /// Synchronously retrieves a filtered list of files from a specified vector store.
    /// </summary>
    /// <param name="VectorStoreId">
    /// The unique identifier of the vector store from which to retrieve the files.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to configure filtering parameters for the list request, such as file status.
    /// </param>
    /// <returns>
    /// A <c>TVectorStoreFiles</c> list containing information about the filtered files.
    /// </returns>
    function List(const VectorStoreId: string; const ParamProc: TProc<TVectorStoreFilesUrlParams>): TVectorStoreFiles; overload;
    /// <summary>
    /// Synchronously retrieves details of a specific file within a vector store.
    /// </summary>
    /// <param name="VectorStoreId">
    /// The unique identifier of the vector store containing the file.
    /// </param>
    /// <param name="FileId">
    /// The unique identifier of the file to be retrieved.
    /// </param>
    /// <returns>
    /// A <c>TVectorStoreFile</c> object containing the details of the specified file.
    /// </returns>
    function Retrieve(const VectorStoreId: string; const FileId: string): TVectorStoreFile;
    /// <summary>
    /// Synchronously deletes a file from the specified vector store.
    /// </summary>
    /// <param name="VectorStoreId">
    /// The unique identifier of the vector store from which to delete the file.
    /// </param>
    /// <param name="FileId">
    /// The unique identifier of the file to be deleted.
    /// </param>
    /// <returns>
    /// A <c>TDeletion</c> object indicating the status of the deletion.
    /// </returns>
    function Delete(const VectorStoreId: string; const FileId: string): TDeletion;
  end;

implementation

{ TVectorStoreFilesCreateParams }

function TVectorStoreFilesCreateParams.ChunkingStrategy(
  const Value: TChunkingStrategyParams): TVectorStoreFilesCreateParams;
begin
  Result := TVectorStoreFilesCreateParams(Add('chunking_strategy', Value.Detach));
end;

function TVectorStoreFilesCreateParams.FileId(
  const Value: string): TVectorStoreFilesCreateParams;
begin
  Result := TVectorStoreFilesCreateParams(Add('file_id', Value));
end;

{ TVectorStoreFile }

destructor TVectorStoreFile.Destroy;
begin
  if Assigned(FLastError) then
    FLastError.Free;
  if Assigned(FChunkingStrategy) then
    FChunkingStrategy.Free;
  inherited;
end;

function TVectorStoreFile.GetCreatedAt: Int64;
begin
  Result := TInt64OrNull(FCreatedAt).ToInteger;
end;

function TVectorStoreFile.GetCreatedAtAsString: string;
begin
  Result := TInt64OrNull(FCreatedAt).ToUtcDateString;
end;

{ TChunkingStrategy }

destructor TChunkingStrategy.Destroy;
begin
  if Assigned(FStatic) then
    FStatic.Free;
  inherited;
end;

{ TVectorStoreFilesRoute }

procedure TVectorStoreFilesRoute.AsynCreate(const VectorStoreId: string;
  const ParamProc: TProc<TVectorStoreFilesCreateParams>;
  const CallBacks: TFunc<TAsynVectorStoreFile>);
begin
  with TAsynCallBackExec<TAsynVectorStoreFile, TVectorStoreFile>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TVectorStoreFile
      begin
        Result := Self.Create(VectorStoreId, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TVectorStoreFilesRoute.AsynDelete(const VectorStoreId, FileId: string;
  const CallBacks: TFunc<TAsynDeletion>);
begin
  with TAsynCallBackExec<TAsynDeletion, TDeletion>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TDeletion
      begin
        Result := Self.Delete(VectorStoreId, FileId);
      end);
  finally
    Free;
  end;
end;

procedure TVectorStoreFilesRoute.AsynList(const VectorStoreId: string;
  const CallBacks: TFunc<TAsynVectorStoreFiles>);
begin
  with TAsynCallBackExec<TAsynVectorStoreFiles, TVectorStoreFiles>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TVectorStoreFiles
      begin
        Result := Self.List(VectorStoreId);
      end);
  finally
    Free;
  end;
end;

procedure TVectorStoreFilesRoute.AsynList(const VectorStoreId: string;
  const ParamProc: TProc<TVectorStoreFilesUrlParams>;
  const CallBacks: TFunc<TAsynVectorStoreFiles>);
begin
  with TAsynCallBackExec<TAsynVectorStoreFiles, TVectorStoreFiles>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TVectorStoreFiles
      begin
        Result := Self.List(VectorStoreId, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TVectorStoreFilesRoute.AsynRetrieve(const VectorStoreId,
  FileId: string; const CallBacks: TFunc<TAsynVectorStoreFile>);
begin
  with TAsynCallBackExec<TAsynVectorStoreFile, TVectorStoreFile>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TVectorStoreFile
      begin
        Result := Self.Retrieve(VectorStoreId, FileId);
      end);
  finally
    Free;
  end;
end;

function TVectorStoreFilesRoute.Create(const VectorStoreId: string;
  const ParamProc: TProc<TVectorStoreFilesCreateParams>): TVectorStoreFile;
begin
  HeaderCustomize;
  Result := API.Post<TVectorStoreFile, TVectorStoreFilesCreateParams>('vector_stores/' + VectorStoreId + '/files', ParamProc);
end;

function TVectorStoreFilesRoute.Delete(const VectorStoreId,
  FileId: string): TDeletion;
begin
  HeaderCustomize;
  Result := API.Delete<TDeletion>('vector_stores/' + VectorStoreId + '/files/' + FileId);
end;

procedure TVectorStoreFilesRoute.HeaderCustomize;
begin
  inherited;
  API.CustomHeaders := [TNetHeader.Create('OpenAI-Beta', 'assistants=v2')];
end;

function TVectorStoreFilesRoute.List(
  const VectorStoreId: string): TVectorStoreFiles;
begin
  HeaderCustomize;
  Result := API.Get<TVectorStoreFiles>('vector_stores/' + VectorStoreId + '/files');
end;

function TVectorStoreFilesRoute.List(const VectorStoreId: string;
  const ParamProc: TProc<TVectorStoreFilesUrlParams>): TVectorStoreFiles;
begin
  HeaderCustomize;
  Result := API.Get<TVectorStoreFiles, TVectorStoreFilesUrlParams>('vector_stores/' + VectorStoreId + '/files', ParamProc);
end;

function TVectorStoreFilesRoute.Retrieve(const VectorStoreId,
  FileId: string): TVectorStoreFile;
begin
  HeaderCustomize;
  Result := API.Get<TVectorStoreFile>('vector_stores/' + VectorStoreId + '/files/' + FileId);
end;

{ TVectorStoreFilesUrlParams }

function TVectorStoreFilesUrlParams.Filter(
  const Value: string): TVectorStoreFilesUrlParams;
begin
  Result := TVectorStoreFilesUrlParams(Add('filter', Value));
end;

end.


Une unité actuellement en développement, prévue pour être intégrée prochainement au projet. Elle permet de gérer les promesses de manière autonome, sans nécessiter l'ajout des unités fournies par les bibliothèques CerabraChain et SynkFlowAI.

 unit Manager.Async.Promise;

(*******************************************************************************

      Unit providing a generic implementation of Promises for handling
      asynchronous operations in Delphi.

      The ASync.Promise unit enables structured handling of asynchronous
      tasks using Promises, allowing for a clean and readable
      asynchronous programming model similar to JavaScript Promises.

      Primary components include:

        - TPromise<T>: A generic class representing a promise that can be
          resolved or rejected asynchronously.
        - TPromiseState: An enumeration indicating the state of a promise
          (Pending, Fulfilled, or Rejected).
        - TPromiseRegistry: An internal registry that tracks all pending
          promises to prevent premature destruction.
        - Chained methods for structured handling:
          - &Then<T>: Chains operations to execute after a promise resolves.
          - &Catch: Handles errors occurring within a promise chain.

      These abstractions allow a structured and reusable way to manage
      asynchronous execution without deeply nested callbacks, facilitating
      a cleaner approach to asynchronous programming in Delphi.

  Example Usage:

  ```delphi
  procedure ExampleAsyncProcess;
  begin
    var Promise := TPromise<string>.Create(
      procedure(Resolve: TProc<string>; Reject: TProc<Exception>)
      begin
        TThread.CreateAnonymousThread(
          procedure
          begin
            Sleep(2000); // Simulating asynchronous work
            if Random(2) = 0 then
              Resolve('Operation Successful')
            else
              Reject(Exception.Create('Operation Failed'));
          end
        ).Start;
      end);

    Promise
      .&Then(
        procedure(Value: string)
        begin
          ShowMessage('Success: ' + Value);
        end)
      .&Catch(
        procedure(E: Exception)
        begin
          ShowMessage('Error: ' + E.Message);
        end);
  end;
  ```

      The unit is designed to work seamlessly with other asynchronous
      programming modules, making it a powerful addition to any Delphi
      application requiring structured async execution.

*******************************************************************************)

interface

uses
  System.SysUtils, System.Generics.Collections, System.Classes, System.Threading;

type
  /// <summary>
  /// Represents the state of a Promise.
  /// </summary>
  TPromiseState = (
    /// <summary>
    /// The promise is pending and has not yet been resolved or rejected.
    /// </summary>
    psPending,
    /// <summary>
    /// The promise has been fulfilled with a value.
    /// </summary>
    psFulfilled,
    /// <summary>
    /// The promise has been rejected due to an error.
    /// </summary>
    psRejected
  );

  /// <summary>
  /// Abstract base class for promise implementations.
  /// </summary>
  /// <remarks>
  /// Provides a common interface for retrieving the current state
  /// of a promise. All concrete promise types must implement
  /// <see cref="GetState"/> to indicate whether they are pending,
  /// fulfilled, or rejected.
  /// </remarks>
  TPromiseBase = class abstract
  strict protected
    /// <summary>
    /// Returns the current state of the promise.
    /// </summary>
    /// <returns>
    /// A <see cref="TPromiseState"/> value indicating whether the
    /// promise is pending, fulfilled, or rejected.
    /// </returns>
    function GetState: TPromiseState; virtual; abstract;
  public
    /// <summary>
    /// Read-only property exposing the promise’s current state.
    /// </summary>
    /// <value>
    /// The <see cref="TPromiseState"/> of the promise.
    /// </value>
    property State: TPromiseState read GetState;
  end;

  /// <summary>
  /// A generic class that represents an asynchronous operation that may complete in the future.
  /// </summary>
  /// <typeparam name="T">The type of the value that the promise resolves with.</typeparam>
  TPromise<T> = class(TPromiseBase)
  public
    type
      /// <summary>
      /// Defines the executor procedure for a promise, providing callbacks
      /// to signal fulfillment or rejection of the asynchronous operation.
      /// </summary>
      /// <param name="Resolve">
      /// A callback that accepts a value of type T and transitions the promise
      /// into the fulfilled state with that value.
      /// </param>
      /// <param name="Reject">
      /// A callback that accepts an Exception and transitions the promise
      /// into the rejected state with that error.
      /// </param>
      TExecutor = reference to procedure(Resolve: TProc<T>; Reject: TProc<Exception>);
  private
    FState: TPromiseState;
    FValue: T;
    FError: Exception;
    FThenHandlers: TList<TProc<T>>;
    FCatchHandlers: TList<TProc<Exception>>;
    FHandlerLock: TObject;

    class function CloneException(E: Exception): Exception; static;

    /// <summary>
    /// Resolves the promise with a given value.
    /// </summary>
    /// <param name="AValue">The value to resolve the promise with.</param>
    procedure Resolve(const AValue: T);

    /// <summary>
    /// Rejects the promise with a given error.
    /// </summary>
    /// <param name="AError">The exception that caused the rejection.</param>
    procedure Reject(AError: Exception);

  strict protected
    /// <summary>
    /// Returns the current state of the promise.
    /// </summary>
    /// <returns>
    /// A <see cref="TPromiseState"/> value indicating whether the
    /// promise is pending, fulfilled, or rejected.
    /// </returns>
    function GetState: TPromiseState; override;

  public
    /// <summary>
    /// Initializes a new instance of the <see cref="TPromise{T}"/> class and starts the asynchronous operation.
    /// </summary>
    /// <param name="AExecutor">The executor function that starts the asynchronous task.</param>
    constructor Create(AExecutor: TExecutor);

    /// <summary>
    /// Destroys the promise instance and releases any associated resources.
    /// </summary>
    destructor Destroy; override;

    /// <summary>
    /// Attaches a fulfillment callback that is executed when the promise is resolved.
    /// </summary>
    /// <param name="AOnFulfill">A callback function executed upon fulfillment.</param>
    /// <returns>A new promise to allow method chaining.</returns>
    function &Then(AOnFulfill: TProc): TPromise<T>; overload;

    /// <summary>
    /// Attaches a fulfillment callback that receives the resolved value.
    /// </summary>
    /// <param name="AOnFulfill">A callback function that receives the resolved value.</param>
    /// <returns>A new promise to allow method chaining.</returns>
    function &Then(AOnFulfill: TProc<T>): TPromise<T>; overload;

    /// <summary>
    /// Attaches a fulfillment callback that returns a transformed value of a different type.
    /// </summary>
    /// <typeparam name="TResult">The type of the transformed result.</typeparam>
    /// <param name="AOnFulfill">A function that produces the transformed result.</param>
    /// <returns>A new promise that resolves with the transformed value.</returns>
    function &Then<TResult>(AOnFulfill: TFunc<TResult>): TPromise<TResult>; overload;

    /// <summary>
    /// Attaches a fulfillment callback that returns another promise of a different type.
    /// </summary>
    /// <typeparam name="TResult">The type of the new promise’s result.</typeparam>
    /// <param name="AOnFulfill">A function that returns a new promise.</param>
    /// <returns>A new promise that resolves with the value of the returned promise.</returns>
    function &Then<TResult>(AOnFulfill: TFunc<T, TPromise<TResult>>): TPromise<TResult>; overload;

    /// <summary>
    /// Attaches a fulfillment callback that returns another promise of the same type.
    /// </summary>
    /// <param name="AOnFulfill">A function that returns a new promise of the same type.</param>
    /// <returns>A new promise that resolves with the value of the returned promise.</returns>
    function &Then(AOnFulfill: TFunc<T, TPromise<T>>): TPromise<T>; overload;

    /// <summary>
    /// Attaches a fulfillment callback that transforms the resolved value into another type.
    /// </summary>
    /// <typeparam name="TResult">The type of the transformed value.</typeparam>
    /// <param name="AOnFulfill">A function that transforms the resolved value.</param>
    /// <returns>A new promise that resolves with the transformed value.</returns>
    function &Then<TResult>(AOnFulfill: TFunc<T, TResult>): TPromise<TResult>; overload;

    /// <summary>
    /// Attaches a rejection callback to handle errors if the promise is rejected.
    /// </summary>
    /// <param name="AOnReject">A callback function that handles the error.</param>
    /// <returns>A new promise to allow method chaining.</returns>
    function &Catch(AOnReject: TProc<Exception>): TPromise<T>;

    class function Resolved(const AValue: T): TPromise<T>;
  end;

  /// <summary>
  /// Maintains a global registry of all pending promises, ensuring they
  /// are kept alive until they are fulfilled or rejected.
  /// </summary>
  /// <remarks>
  /// This sealed class provides thread-safe methods to add and remove
  /// promises from the registry, as well as a manual cleanup routine
  /// to prune completed promises.  It is used internally by
  /// <see cref="TPromise{T}"/> to prevent premature destruction of
  /// promises that are still pending.
  /// </remarks>
  TPromiseRegistry = class sealed
  strict private
    class var FList : TObjectList<TObject>;
    class var FLock : TObject;
  public
    /// <summary>
    /// Initializes the promise registry and its internal lock.
    /// </summary>
    class constructor Create;

    /// <summary>
    /// Releases all resources held by the promise registry.
    /// </summary>
    class destructor  Destroy;

    /// <summary>
    /// Adds a promise instance to the registry, preventing it
    /// from being freed until it transitions out of the pending state.
    /// </summary>
    /// <param name="APromise">
    /// The promise instance to register.
    /// </param>
    class procedure Add(APromise: TObject);

    /// <summary>
    /// Removes a promise instance from the registry, allowing it
    /// to be freed if it is no longer referenced elsewhere.
    /// </summary>
    /// <param name="APromise">
    /// The promise instance to unregister.
    /// </param>
    class procedure Remove(APromise: TObject);

    /// <summary>
    /// Scans the registry and deletes any promises that are no longer
    /// pending (i.e., fulfilled or rejected), releasing their memory.
    /// </summary>
    /// <remarks>
    /// This method can be called manually if you need to force
    /// cleanup of completed promises before their <see cref="TPromise{T}"/>
    /// callbacks are all delivered.
    /// </remarks>
    class procedure Cleanup;

    /// <summary>
    /// Removes and frees all promises in the registry, regardless of their state.
    /// </summary>
    /// <remarks>
    /// Acquires the internal lock to ensure thread safety, then iterates through
    /// the list of registered promises and deletes each one.  This will release
    /// both pending and completed promises from memory.  Use with caution, as
    /// any still-pending promises will be destroyed immediately.
    /// </remarks>
    class procedure Clear;
  end;

implementation

{ TPromise<T> }

class function TPromise<T>.CloneException(E: Exception): Exception;
var
  ExClass: ExceptClass ;
begin
  ExClass := ExceptClass(E.ClassType);
  Result := ExClass.Create(E.Message);
end;

constructor TPromise<T>.Create(AExecutor: TExecutor);
begin
  inherited Create;
  FHandlerLock := TObject.Create;
  FState := psPending;
  TPromiseRegistry.Add(Self);
  FThenHandlers := TList<TProc<T>>.Create;
  FCatchHandlers := TList<TProc<Exception>>.Create;
  try
    {--- The executor function that starts the asynchronous task. }
    AExecutor(
      procedure(AValue: T)
      begin
        Self.Resolve(AValue);
      end,

      {--- OnReject — clone then free the original }
      procedure(E: Exception)
      begin
        var Cloned := CloneException(E);
        {--- releases the original exception }
        E.Free;
        Self.Reject(Cloned);
      end
    );
  except
    on E: Exception do
    begin
      var Cloned := CloneException(E);
      {--- E.Free; Do not release E here because Delphi takes care of it }
      Reject(Cloned);
    end;
  end;

//  TThread.Queue(nil,
//    procedure
//    begin
//      try
//        AExecutor(
//          procedure(AValue: T)
//          begin
//            Self.Resolve(AValue);
//          end,
//
//          procedure(E: Exception)
//          begin
//            var Cloned := CloneException(E);
//            E.Free;
//            Self.Reject(Cloned);
//          end
//        );
//      except
//        on E: Exception do
//          Self.Reject(CloneException(E));
//      end;
//    end
//  );

end;

destructor TPromise<T>.Destroy;
begin
  if Assigned(FError) then
    FError.Free;
  FThenHandlers.Free;
  FCatchHandlers.Free;
  FHandlerLock.Free;
  inherited;
end;

function TPromise<T>.GetState: TPromiseState;
begin
  Result := FState;
end;

procedure TPromise<T>.Resolve(const AValue: T);
var
  Handlers: TArray<TProc<T>>;
  Handler: TProc<T>;
begin
  if FState <> psPending then
    Exit;

  FState := psFulfilled;
  FValue := AValue;

  {--- Copy the locked callback list }
  TMonitor.Enter(FHandlerLock);
  try
    Handlers := FThenHandlers.ToArray;
  finally
    TMonitor.Exit(FHandlerLock);
  end;

  {--- Asynchronously call all “then” callbacks }
  for Handler in Handlers do
    TThread.Queue(nil,
      procedure
      begin
        Handler(FValue);
      end);

  {--- Empty locked lists }
  TMonitor.Enter(FHandlerLock);
  try
    FThenHandlers.Clear;
    FCatchHandlers.Clear;
  finally
    TMonitor.Exit(FHandlerLock);
  end;

  {--- Safe destruction because we are out of the register }
  TPromiseRegistry.Remove(Self);
end;

class function TPromise<T>.Resolved(const AValue: T): TPromise<T>;
begin
  Result := TPromise<T>.Create(
    procedure(Resolve: TProc<T>; Reject: TProc<Exception>)
    begin
      TTask.Run(
        procedure()
        begin
          TThread.Queue(nil,
            procedure
            begin
              Resolve(AValue);
            end)
        end)
    end);
end;

procedure TPromise<T>.Reject(AError: Exception);
var
  Handlers: TArray<TProc<Exception>>;
  Handler: TProc<Exception>;
begin
  if FState <> psPending then
    begin
      AError.Free;
      Exit;
    end;

  FState := psRejected;
  FError := AError;

  {--- Copy the locked callback list }
  TMonitor.Enter(FHandlerLock);
  try
    Handlers := FCatchHandlers.ToArray;
  finally
    TMonitor.Exit(FHandlerLock);
  end;

  {--- Call all “catch” callbacks }
  for Handler in Handlers do
    TThread.Queue(nil,
      procedure
      begin
        Handler(FError);
      end);

  {--- Empty locked lists }
  TMonitor.Enter(FHandlerLock);
  try
    FThenHandlers.Clear;
    FCatchHandlers.Clear;
  finally
    TMonitor.Exit(FHandlerLock);
  end;

  {--- Safe destruction because we are out of the register }
  TPromiseRegistry.Remove(Self);
end;

function TPromise<T>.&Then(AOnFulfill: TProc<T>): TPromise<T>;
begin
  {--- Version without transformation: we wrap the procedure in a function which returns the unchanged value }
  Result := &Then<T>(
    function(Value: T): T
    begin
      AOnFulfill(Value);
      Result := Value;
    end);
end;

function TPromise<T>.&Then<TResult>(AOnFulfill: TFunc<T, TResult>): TPromise<TResult>;
begin
  {--- Creation of a new promise that will be resolved when this one is resolved }
  Result := TPromise<TResult>.Create(
    procedure(Resolve: TProc<TResult>; Reject: TProc<Exception>)
    begin
      if FState = psFulfilled then
        begin
          try
            Resolve(AOnFulfill(FValue));
          except
            on E: Exception do
              Reject(CloneException(E));
          end;
        end
      else
      if FState = psRejected then
        begin
          Reject(CloneException(FError))
        end
      else
        begin
          {--- If the operation is not yet complete, we add callbacks for chaining }
          TMonitor.Enter(FHandlerLock);
          try
            FThenHandlers.Add(
              procedure(Value: T)
              begin
                try
                  Resolve(AOnFulfill(Value));
                except
                  on E: Exception do
                    Reject(CloneException(E));
                end;
              end);
            FCatchHandlers.Add(
              procedure(E: Exception)
              begin
                Reject(CloneException(E));
              end);
          finally
            TMonitor.Exit(FHandlerLock);
          end;
        end;
    end);
end;

function TPromise<T>.&Then(AOnFulfill: TFunc<T, TPromise<T>>): TPromise<T>;
begin
  Result := TPromise<T>.Create(
    procedure(Resolve: TProc<T>; Reject: TProc<Exception>)
    begin
      if FState = psFulfilled then
        begin
          try
            AOnFulfill(FValue)
              .&Then(
                procedure(NewValue: T)
                begin
                  Resolve(NewValue);
                end)
              .&Catch(
                procedure(E: Exception)
                begin
                  Reject(CloneException(E));
                end);
          except
            on E: Exception do
              Reject(CloneException(E));
          end;
        end
      else
      if FState = psRejected then
        begin
          Reject(CloneException(FError))
        end
      else
        begin
          TMonitor.Enter(FHandlerLock);
          try
            FThenHandlers.Add(
              procedure(Value: T)
              begin
                try
                  AOnFulfill(Value)
                    .&Then(
                      procedure(NewValue: T)
                      begin
                        Resolve(NewValue);
                      end)
                    .&Catch(
                    procedure(E: Exception)
                    begin
                      Reject(CloneException(E));
                    end);
                except
                  on E: Exception do
                    Reject(CloneException(E));
                end;
              end);
            FCatchHandlers.Add(
              procedure(E: Exception)
              begin
                Reject(CloneException(E));
              end);
          finally
            TMonitor.Exit(FHandlerLock);
          end;
        end;
    end);
end;

function TPromise<T>.&Then<TResult>(
  AOnFulfill: TFunc<TResult>): TPromise<TResult>;
begin
  Result := TPromise<TResult>.Create(
    procedure(Resolve: TProc<TResult>; Reject: TProc<Exception>)
    begin
      if FState = psFulfilled then
        begin
          try
            {--- Call the action without parameters and resolve with the result }
            Resolve(AOnFulfill());
          except
            on E: Exception do
              Reject(CloneException(E));
          end;
        end
    else
    if FState = psRejected then
      begin
        Reject(CloneException(FError));
      end
    else
      begin
        {--- If the promise is pending, we add callbacks }
        TMonitor.Enter(FHandlerLock);
        try
          FThenHandlers.Add(
            procedure(Value: T)
            begin
              try
                Resolve(AOnFulfill()); //ici
              except
                on E: Exception do
                  Reject(CloneException(E));
              end;
            end);
          FCatchHandlers.Add(
            procedure(E: Exception)
            begin
              Reject(CloneException(E));
            end);
        finally
          TMonitor.Exit(FHandlerLock);
        end;
      end;
    end);
end;

function TPromise<T>.&Then<TResult>(
  AOnFulfill: TFunc<T, TPromise<TResult>>): TPromise<TResult>;
begin
  Result := TPromise<TResult>.Create(
    procedure(Resolve: TProc<TResult>; Reject: TProc<Exception>)
    begin
      if FState = psFulfilled then
        begin
          try
            AOnFulfill(FValue)
              .&Then(
                procedure(NewValue: TResult)
                begin
                  Resolve(NewValue);
                end)
              .&Catch(
                procedure(E: Exception)
                begin
                  Reject(CloneException(E));
                end);
          except
            on E: Exception do
              Reject(CloneException(E));
          end;
        end
      else
      if FState = psRejected then
        begin
          Reject(CloneException(FError));
        end
      else
        begin
          TMonitor.Enter(FHandlerLock);
          try
            FThenHandlers.Add(
              procedure(Value: T)
              begin
                try
                  AOnFulfill(Value)
                    .&Then(
                      procedure(NewValue: TResult)
                      begin
                        Resolve(NewValue);
                      end)
                    .&Catch(
                      procedure(E: Exception)
                      begin
                        Reject(CloneException(E));
                      end);
                except
                  on E: Exception do
                    Reject(CloneException(E));
                end;
              end);
            FCatchHandlers.Add(
              procedure(E: Exception)
              begin
                Reject(CloneException(E));
              end);
          finally
            TMonitor.Exit(FHandlerLock);
          end;
        end;
    end);
end;

function TPromise<T>.&Then(AOnFulfill: TProc): TPromise<T>;
begin
  Result := TPromise<T>.Create(
    procedure(Resolve: TProc<T>; Reject: TProc<Exception>)
    begin
      if FState = psFulfilled then
        begin
          try
            {--- Calling the action without parameters }
            AOnFulfill();
            {--- Pass the initial value after the action is executed }
            Resolve(FValue);
          except
            on E: Exception do
              Reject(CloneException(E));
          end;
        end
      else
      if FState = psRejected then
        begin
          Reject(CloneException(FError))
        end
      else
        begin
          {--- If the operation is not yet completed, add callbacks for chaining }
          TMonitor.Enter(FHandlerLock);
          try
            FThenHandlers.Add(
              procedure(Value: T)
              begin
                try
                  AOnFulfill();
                  Resolve(Value);
                except
                  on E: Exception do
                    Reject(CloneException(E));
                end;
              end);
            FCatchHandlers.Add(
              procedure(E: Exception)
              begin
                Reject(CloneException(E));
              end);
          finally
            TMonitor.Exit(FHandlerLock);
          end;
        end;
    end);
end;

function TPromise<T>.&Catch(AOnReject: TProc<Exception>): TPromise<T>;
begin
  {--- Create a new promise that passes the value or handles the error with AOnReject }
  Result := TPromise<T>.Create(
    procedure(Resolve: TProc<T>; Reject: TProc<Exception>)
    begin
      if FState = psFulfilled then
        begin
          Resolve(FValue);
        end
      else
      if FState = psRejected then
        begin
          AOnReject(FError);
          Reject(CloneException(FError));
        end
      else
        begin
          TMonitor.Enter(FHandlerLock);
          try
            FThenHandlers.Add(
              procedure(Value: T)
              begin
                Resolve(Value);
              end);
            FCatchHandlers.Add(
              procedure(E: Exception)
              begin
                AOnReject(E);
                Reject(CloneException(E));
              end);
          finally
            TMonitor.Exit(FHandlerLock);
          end;
        end;
    end);
end;

{ TPromiseRegistry }

class procedure TPromiseRegistry.Add(APromise: TObject);
begin
  TMonitor.Enter(FLock);
  try
    FList.Add(APromise);
  finally
    TMonitor.Exit(FLock);
  end;
end;

class procedure TPromiseRegistry.Cleanup;
begin
  TMonitor.Enter(FLock);
  try
    for var I := FList.Count - 1 downto 0 do
      {--- Remove the promise from the list as soon as it moves to the final state. }
      if TObject(FList[I]) is TPromiseBase then
        with TPromiseBase(FList[I]) do
          if State <> psPending then
            {--- releases the object }
            FList.Delete(I);
  finally
    TMonitor.Exit(FLock);
  end;
end;

class procedure TPromiseRegistry.Clear;
begin
  TMonitor.Enter(FLock);
  try
    for var I := FList.Count - 1 downto 0 do
      {--- Remove the promise from the list as soon as it moves to the final state. }
      if TObject(FList[I]) is TPromiseBase then
        with TPromiseBase(FList[I]) do
            {--- releases the object }
            FList.Delete(I);
  finally
    TMonitor.Exit(FLock);
  end;
end;

class constructor TPromiseRegistry.Create;
begin
  {--- simple critical section }
  FLock := TObject.Create;

  {--- OwnsObjects = True }
  FList := TObjectList<TObject>.Create(True);
end;

class destructor TPromiseRegistry.Destroy;
begin
  FList.Free;
  FLock.Free;
end;

class procedure TPromiseRegistry.Remove(APromise: TObject);
begin
  TMonitor.Enter(FLock);
  try
    {--- releases the object }
    var Index := FList.IndexOf(APromise);
    if Index >= 0 then
      FList.Delete(Index);
  finally
    TMonitor.Exit(FLock);
  end;
end;

initialization
finalization
  {--- Delete pending promises }
  TPromiseRegistry.Clear;
end.



Ainsi qu'une unité prenant en charge l'inversion de contrôle (IoC) pour favoriser une architecture de code moderne et maintenable.

/// <summary>
/// The <c>Manager.IoC</c> unit implements a basic Inversion of Control (IoC) container that
/// provides dependency injection capabilities for Delphi applications.
/// </summary>
/// <remarks>
/// <para>
/// This unit defines key components for managing dependency registrations and resolutions:
/// </para>
/// <para>
/// - <c>TLifetime</c>: An enumeration that specifies whether an instance should be created as a transient object
/// or maintained as a singleton throughout the application's lifetime.
/// </para>
/// <para>
/// - <c>TRegistrationInfo</c>: A record that stores registration details for a type, including the factory method,
/// the instance (for singletons), and the lifetime setting.
/// </para>
/// <para>
/// - <c>TIoCContainer</c>: The main container class that maintains a registry of dependencies and provides methods
/// to register and resolve interface implementations based on their type and an optional identifier.
/// </para>
/// <para>
/// This IoC container enables decoupled and modular design by allowing objects to be instantiated and managed
/// at runtime. It supports both transient and singleton lifetimes, facilitating flexible dependency management
/// across the application.
/// </para>
/// </remarks>
unit Manager.IoC;

interface

uses
  System.SysUtils, System.Classes, System.TypInfo, System.Generics.Collections;

type
  /// <summary>
  /// Definition of the lifecycle.
  /// </summary>
  TLifetime = (
    /// <summary>
    /// Instances can be recreated if needed.
    /// </summary>
    Transient,
    /// <summary>
    /// Remains constant throughout the application.
    /// </summary>
    Singleton
  );

  /// <summary>
  /// Storage structure for a registration record.
  /// </summary>
  TRegistrationInfo = record
    Instance: IInterface;               // For singletons
    FactoryMethod: TFunc<IInterface>;   // Function returning an interface
    Lifetime: TLifetime;
  end;

  /// <summary>
  /// The <c>TIoCContainer</c> class implements a simple Inversion of Control (IoC) container
  /// for managing dependency registrations and resolutions in Delphi applications.
  /// </summary>
  /// <remarks>
  /// <para>
  /// TIoCContainer maintains an internal registry that maps interface types (optionally keyed
  /// by a name) to registration records containing factory methods and lifetime settings. This allows
  /// for flexible creation and management of object instances at runtime.
  /// </para>
  /// <para>
  /// The container supports two lifetimes:
  /// <c>Transient</c>: A new instance is created every time the dependency is resolved.
  /// <c>Singleton</c>: A single instance is created and shared throughout the application's lifetime.
  /// </para>
  /// <para>
  /// Use the <c>RegisterType</c> methods to register a dependency, and the <c>Resolve</c> method to retrieve
  /// an instance of a registered dependency.
  /// </para>
  /// </remarks>
  TIoCContainer = class
  private
    // Using a key of type string combining the interface name and an optional identifier
    FRegistry: TDictionary<string, TRegistrationInfo>;
    /// <summary>
    /// Generates a unique registration key for the given interface type and an optional identifier.
    /// </summary>
    /// <typeparam name="T">
    /// The interface type for which the key is generated.
    /// </typeparam>
    /// <param name="AName">
    /// An optional name to differentiate multiple registrations of the same interface.
    /// </param>
    /// <returns>
    /// A string representing the unique key for the registration.
    /// </returns>
    function GetRegistrationKey<T>(const AName: string): string;
  public
    constructor Create;
    destructor Destroy; override;
    /// <summary>
    /// Registers a dependency for the interface type T using a factory lambda function.
    /// </summary>
    /// <typeparam name="T">
    /// The interface type to register.
    /// </typeparam>
    /// <param name="AName">
    /// An optional identifier to differentiate multiple registrations for the same interface.
    /// </param>
    /// <param name="AFactory">
    /// A lambda function that creates and returns an instance of type T.
    /// </param>
    /// <param name="ALifetime">
    /// Specifies the lifetime of the instance; use <c>Transient</c> for a new instance on each resolve,
    /// or <c>Singleton</c> to share a single instance.
    /// </param>
    procedure RegisterType<T: IInterface>(const AName: string; AFactory: TFunc<T>; ALifetime: TLifetime = TLifetime.Transient); overload;
    /// <summary>
    /// Registers a dependency for the interface type T using a factory lambda function.
    /// This overload does not require an identifier.
    /// </summary>
    /// <typeparam name="T">
    /// The interface type to register.
    /// </typeparam>
    /// <param name="AFactory">
    /// A lambda function that creates and returns an instance of type T.
    /// </param>
    /// <param name="ALifetime">
    /// Specifies the lifetime of the instance; use <c>Transient</c> for a new instance on each resolve,
    /// or <c>Singleton</c> to share a single instance.
    /// </param>
    procedure RegisterType<T: IInterface>(AFactory: TFunc<T>; ALifetime: TLifetime = TLifetime.Transient); overload;
    /// <summary>
    /// Resolves an instance of the registered interface type T.
    /// </summary>
    /// <typeparam name="T">
    /// The interface type to resolve.
    /// </typeparam>
    /// <param name="AName">
    /// An optional identifier that must match the one used during registration.
    /// </param>
    /// <returns>
    /// An instance of type T. If the dependency was registered as a singleton, the same instance is returned
    /// on subsequent calls. For transient registrations, a new instance is created.
    /// </returns>
    function Resolve<T: IInterface>(const AName: string = ''): T;
  end;

var
  /// <summary>
  /// A global instance of the <c>TIoCContainer</c> used for dependency injection across the application.
  /// </summary>
  /// <remarks>
  /// This variable holds the container that manages registrations and resolutions of dependencies.
  /// It is instantiated during application initialization and released during finalization,
  /// ensuring that all registered services are available throughout the application's lifetime.
  /// </remarks>
  IoC: TIoCContainer;

implementation

{ TIoCContainer }

constructor TIoCContainer.Create;
begin
  inherited Create;
  FRegistry := TDictionary<string, TRegistrationInfo>.Create;
end;

destructor TIoCContainer.Destroy;
begin
  FRegistry.Free;
  inherited;
end;

function TIoCContainer.GetRegistrationKey<T>(const AName: string): string;
begin
  Result := GetTypeName(TypeInfo(T));
  if not AName.Trim.IsEmpty then
    Result := Result + '|' + AName;
end;

procedure TIoCContainer.RegisterType<T>(const AName: string; AFactory: TFunc<T>; ALifetime: TLifetime);
var
  RegistrationKey: string;
  Registration: TRegistrationInfo;
begin
  RegistrationKey := GetRegistrationKey<T>(AName);

  Registration.Lifetime := ALifetime;
  Registration.Instance := nil;
  {--- Wrapping the lambda to return an IInterface }
  Registration.FactoryMethod := function: IInterface
  begin
    Result := AFactory();
  end;

  FRegistry.Add(RegistrationKey, Registration);
end;

procedure TIoCContainer.RegisterType<T>(AFactory: TFunc<T>;
  ALifetime: TLifetime);
begin
  RegisterType<T>(EmptyStr, AFactory, ALifetime);
end;

function TIoCContainer.Resolve<T>(const AName: string): T;
var
  RegistrationKey: string;
  Registration: TRegistrationInfo;
  Intf: IInterface;
begin
  RegistrationKey := GetRegistrationKey<T>(AName);

  if not FRegistry.TryGetValue(RegistrationKey, Registration) then
    raise Exception.CreateFmt('Type %s not registered in the IoC container with the name "%s"', [GetTypeName(TypeInfo(T)), AName]);

  case Registration.Lifetime of
    TLifetime.Singleton:
      begin
        if Registration.Instance = nil then
        begin
          Registration.Instance := Registration.FactoryMethod();
          {--- Update the record in the dictionary }
          FRegistry[RegistrationKey] := Registration;
        end;
        Intf := Registration.Instance;
      end;
    TLifetime.Transient:
      Intf := Registration.FactoryMethod();
  end;

  {--- Convert to type T (ensures the object supports the interface) }
  Result := T(Intf);
end;

initialization
  IoC := TIoCContainer.Create;
finalization
  IoC.Free;
end.

Un point important est la présence de TutorialHub avec la wrapper/ Une question qui est souvent posée à son sujet :

Question : Avec GenAI il y a TutorialHub qui est fourni tu pourrais me dire en quoi c'est pertinent ainsi que ton avis 
sur son utilité ?

Réponse: 
 
Le composant **TutorialHub** fourni avec la librairie GenAI (Delphi Wrapper for OpenAI) est une infrastructure de support conçue pour faciliter la mise en œuvre et l'utilisation des fonctionnalités proposées par GenAI. Voici en quoi il est pertinent et son utilité, ainsi que mon avis :\n\n### Pertinence et utilité de TutorialHub\n\n1. **Simplification de l’intégration**\n   - TutorialHub fournit des classes d’aide spécifiques à la plateforme (par exemple, `TVCLTutorialHub` pour VCL et `TFMXTutorialHub` pour FMX), qui simplifient le branchement des contrôles visuels (comme des `TMemo`, `TImage`, `TButton`, etc.) directement à des requêtes ou résultats d’API OpenAI.  \n   - Cela facilite l’affichage, le debug et l’interaction utilisateur sans avoir à coder beaucoup de gestion d’interface et d’événements manuellement.\n\n2. **Gestion des interactions asynchrones**\n   - Il permet de gérer proprement les appels asynchrones à l’API OpenAI avec des hooks sur les événements clés (`OnStart`, `OnSuccess`, `OnError`, etc.), rendant le code plus structuré et plus lisible.\n\n3. **Exemples pédagogiques**\n   - TutorialHub sert de hub central pour présenter des exemples concrets et pratiques (extraction, complétions, génération d’image, modération, fine tuning, etc.), ce qui est un excellent moyen d’apprentissage et de prise en main rapide.\n   - En fait, dans la documentation, on voit qu’il est utilisé dans quasiment toutes les démos d’appels API, ce qui le rend indispensable pour comprendre et tester rapidement chaque fonctionnalité.\n\n4. **Réduction de la complexité de l’appel API**\n   - En encapsulant le client API et les retours dans une structure standard, TutorialHub permet d’éviter d’avoir à dupliquer du code à chaque nouvelle fonction testée.\n   - Il gère aussi le passage des paramètres et leur affichage dans une interface textuelle ou visuelle.\n\n5. **Support multi-plateforme**\n   - Comme il existe des versions adaptées à VCL (Windows) et FMX (multi-plateforme), TutorialHub permet d’utiliser la même approche avec des langages d’interface variés.\n\n---\n\n### Mon avis\n\n- Pour un **développeur Delphi de niveau débutant à intermédiaire**, TutorialHub est **extrêmement utile** car il fournit un cadre prêt à l’emploi pour expérimenter rapidement OpenAI sans devoir implémenter tous les détails bas niveau.\n- Pour un développeur **plus avancé ou expert**, TutorialHub reste un bon point de départ rapide, mais il pourra très vite vouloir gérer lui-même les appels pour intégrer la librairie de façon plus fine ou personnalisée dans ses propres applications.\n- En résumé, TutorialHub n’est pas seulement un simple exemple, c’est une **boîte à outils pédagogique** qui illustre les meilleures pratiques d’utilisation de `GenAI` avec Delphi.\n- Dans un contexte professionnel, il facilite le prototypage rapide et peut être adapté comme base pour des applications réelles, notamment dans les scénarios qui nécessitent une interface utilisateur Delphi classique.\n\n---\n\n### Illustration rapide du fonctionnement\nDans la documentation, on voit que l’on instancie TutorialHub par exemple ainsi (version VCL) :\n\n```delphi\n\/\/uses GenAI.Tutorial.VCL;\nTutorialHub := TVCLTutorialHub.Create(Client, Memo1, Memo2, Memo3, Image1, Button1, MediaPlayer1);\n```\n\nPuis ce composant sert d’expéditeur et récepteur des données API, simplifiant ainsi les manipulations et affichages dans les contrôles Delphi.\n\n---\n\n### Conclusion\n\nTutorialHub est donc une surcouche très pertinente qui aide à :\n\n- Comprendre rapidement comment interagir avec l’API OpenAI en Delphi,\n- Simplifier la gestion asynchrone et le rendu visuel,\n- Proposer des exemples concrets de code réutilisable,\n- Et potentiellement servir de base pour des développements plus avancés.\n\nSi tu utilises GenAI, je te recommande d’utiliser TutorialHub pour tester et comprendre d’abord le fonctionnement avant d’intégrer la librairie dans un projet plus complexe.

Pour continuer, vous trouverez l'ensemble de la documentation sur le dépôt GitHub, avec des exemples de code synchrones et asynchrones prêts à l'emploi, à condition que le support TutorialHub soit correctement déclaré dans votre version de test de GenAI.
Le fichier README.md que l'on trouve à cette adresse: https://github.com/MaxiDonkey/DelphiGenAI

# **Delphi GenAI - Optimized OpenAI Integration**


Welcome to `GenAI`, a powerful and flexible **Delphi library** integrating the latest innovations from `OpenAI` APIs. Designed for comprehensive support, it enables content generation, dialogue management, vision and speech processing, as well as audio interactions with precise control.
Built on advanced models with reasoning capabilities, such as `o1`, `o3` and `o4`, it provides tools for data manipulation, batch processing, function calling, file management, and content moderation. It also supports the `GPT-4.1` models, the teminaison points `v1/chat/completion`, `v1/responses` and offers seamless agent construction.
Additionally, `GenAI` streamlines assistant orchestration, message management, threads, and execution (runs), meeting the demands of modern projects. <br> <br>
Integrating OpenAI APIs into your Delphi apps has never been easier: enjoy streamlined network‑call management, built‑in unit testing, and a modular JSON‑configuration approach.
Check out the full [GenAI project](https://github.com/MaxiDonkey/DelphiGenAI/blob/main/GenAI.md)
___
![GitHub](https://img.shields.io/badge/IDE%20Version-Delphi%2010.3/11/12-yellow)
![GitHub](https://img.shields.io/badge/platform-all%20platforms-green)
![GitHub](https://img.shields.io/badge/Updated%20on%20april%2019,%202025-blue)

<br>

NEW: 
- [Gpt-image-1 model](#gpt-image-1-model)
- [Responses vs. Chat Completions](#responses-vs-chat-completions)
- [Responses](https://github.com/MaxiDonkey/DelphiGenAI/blob/main/Responses.md)
- [How do you structure advanced reasoning using Promises and pipelines?](#how-do-you-structure-advanced-reasoning-using-promises-and-pipelines)
___

<br>

- [Introduction](#introduction)
- [Documentation Overview](#documentation-overview)
- [TIPS for using the tutorial effectively](#tips-for-using-the-tutorial-effectively)
    - [Obtain an api key](#obtain-an-api-key)
    - [Strategies for quickly using the code examples](#strategies-for-quickly-using-the-code-examples)
- [Quick Start Guide](#quick-start-guide)
    - [Responses vs. Chat Completions](#responses-vs-chat-completions)
        - [Functional differences between the two endpoints](#functional-differences-between-the-two-endpoints)
        - [Chat completion](#chat-completion)
        - [Responses](#responses)
    - [Models](#models)
        - [List of models](#list-of-models)
        - [Retrieve a model](#retrieve-a-model)
        - [Delete a model](#delete-a-model)
    - [Image generation](#image-generation)
        - [Dall-e-3 model](#dall-e-3-model)
        - [Gpt-image-1 model](#gpt-image-1-model)
        - [Create image edit with gpt-image-1](#create-image-edit-with-gpt-image-1)
    - [Text to speech](#text-to-speech)
    - [Speech to text](#speech-to-text)
    - [Embeddings](#embeddings)
    - [Moderation](#moderation)
        - [Modarate text inputs](#modarate-text-inputs)
        - [Modarate images and text](#modarate-images-and-text)
    - [Files](#files)
        - [Files list](#files-list)
        - [File upload](#file-upload)
        - [File retrieve](#file-retrieve)
        - [File retrieve content](#file-retrieve-content)
        - [File Deletion](#file-deletion)
- [Beyond the Basics Advanced Usage](#beyond-the-basics-advanced-usage)  
- [Legacy](#legacy)
    - [Completion](#completion)
    - [Streamed completion](#streamed-completion)
- [Tips and tricks](#tips-and-tricks)
    - [How to prevent an error when closing an application while requests are still in progress?](#how-to-prevent-an-error-when-closing-an-application-while-requests-are-still-in-progress)
    - [How to execute multiple background requests to process a batch of responses?](#how-to-execute-multiple-background-requests-to-process-a-batch-of-responses)
    - [How to structure a chain of thought and develop advanced processing with GenAI?](#how-to-structure-a-chain-of-thought-and-develop-advanced-processing-with-genai)
    - [How do you structure advanced reasoning using Promises and pipelines?](#how-do-you-structure-advanced-reasoning-using-promises-and-pipelines)
- [GenAI functional coverage](#genai-functional-coverage)
- [Contributing](#contributing)
- [License](#license)

___

<br>

# Introduction

Following the development of several wrappers integrating solutions from [Anthropic (Claude)](https://github.com/MaxiDonkey/DelphiAnthropic), [Google (Gemini)](https://github.com/MaxiDonkey/DelphiGemini), [Mistral](https://github.com/MaxiDonkey/DelphiMistralAI), [GroqCloud](https://github.com/MaxiDonkey/DelphiStabilityAI), [Hugging Face](https://github.com/MaxiDonkey/DelphiHuggingFace), and [Deepseek](https://github.com/MaxiDonkey/DelphiDeepseek), `GenAI` now benefits from extensive feedback and experience. This feedback has enabled the creation of an optimized and advanced framework, specifically designed to meet the demands of large-scale projects developed using **Delphi**.

In its latest version, `GenAI` has been primarily optimized to fully leverage OpenAI’s endpoints while remaining easily adaptable for the integration of the other aforementioned wrappers.

<br>

**Comprehensive Integration with OpenAI** <br>
- `GenAI` is designed to support the **gpt-4o**, **chatgpt-4o**, **gpt-4.1**, **o1-pro**, **o3** and **o4** models, along with the latest developments in `OpenAI’s APIs`. This extensive coverage ensures maximum flexibility for projects leveraging the latest advancements in OpenAI's offerings.

<br>

**Document Structure** <br>
- This document is divided into two main sections:

   1. **Quick Start Guide** <br>
   A practical introduction to generating text or audio responses from various types of inputs:
      - Plain text
      - Image/text combinations
      - Document-based inputs (text)
      - Audio and audio/text data

  2. **Advanced Features in a Cookbook Format**
      - A detailed guide showcasing advanced features available through OpenAI, complete with practical code examples for easy integration into your applications.

<br>

**Technical Support and Code Examples**<br>
- Two support units, **VCL** and **FMX**, are included in the provided sources. These units simplify the implementation of the code examples and facilitate learning, with a focus on best practices for using `GenAI`.

For more information about the architecture of GenAI, please refer to [the dedicated page](https://github.com/MaxiDonkey/DelphiGenAI/blob/main/GenAI.md). 

<br>

> [!IMPORTANT]
>
> This is an unofficial library. **OpenAI** does not provide any official library for `Delphi`.
> This repository contains `Delphi` implementation over [OpenAI](https://openai.com/) public API.

<br>

___

# Documentation Overview

Comprehensive Project Documentation Reference

- [Changelog](https://github.com/MaxiDonkey/DelphiGenAI/blob/main/Changelog.md)
- [About this project](https://github.com/MaxiDonkey/DelphiGenAI/blob/main/GenAI.md)
- [Chat completion](https://github.com/MaxiDonkey/DelphiGenAI/blob/main/ChatCompletion.md)
- [Responses](https://github.com/MaxiDonkey/DelphiGenAI/blob/main/Responses.md)
- [Beyond the Basics Advanced Usage](https://github.com/MaxiDonkey/DelphiGenAI/blob/main/BeyondBasics.md)

<br>

# TIPS for using the tutorial effectively

## Obtain an api key

To initialize the API instance, you need to obtain an [API key from OpenAI](https://platform.openai.com/settings/organization/api-keys)

Once you have a token, you can initialize IGenAI interface, which is an entry point to the API.

>[!NOTE]
>```Delphi
>//uses GenAI, GenAI.Types;
>
>//Declare 
>//  Client: IGenAI;
>
>  Client := TGenAIFactory.CreateInstance(api_key);
>```

To streamline the use of the API wrapper, the process for declaring units has been simplified. Regardless of the methods being utilized, you only need to reference the following two core units:
`GenAI` and `GenAI.Types`.

<br>

>[!TIP]
> To effectively use the examples in this tutorial, particularly when working with asynchronous methods, it is recommended to define the client interfaces with the broadest possible scope. For optimal implementation, these clients should be declared in the application's `OnCreate` method.
>

<br>

## Strategies for quickly using the code examples

To streamline the implementation of the code examples provided in this tutorial, two support units have been included in the source code: `Deepseek.Tutorial.VCL` and `Deepseek.Tutorial.FMX` Based on the platform selected for testing the provided examples, you will need to initialize either the `TVCLTutorialHub` or `TFMXTutorialHub` class within the application's OnCreate event, as illustrated below:

>[!NOTE]
>```Delphi
>//uses GenAI.Tutorial.VCL;
>TutorialHub := TVCLTutorialHub.Create(Client, Memo1, Memo2, Memo3, Image1, Button1, MediaPlayer1);
>```

or

>[!NOTE]
>```Delphi
>//uses GenAI.Tutorial.FMX;
>TutorialHub := TFMXTutorialHub.Create(Client, Memo1, Memo2, Memo3, Image1, Button1, MediaPlayer1);
>```

Make sure to add a three ***TMemo***, a ***TImage***, a ***TButton*** and a ***TMediaPlayer*** components to your form beforehand.

The TButton will allow the interruption of any streamed reception.

<br>

___

# Quick Start Guide

## Responses vs. Chat Completions

The `v1/responses` API is the new core API, designed as an agentic primitive that combines the simplicity of chat completions with the power of action execution. It natively includes several built‑in tools:
- Web search
- File search
- Computer control

With these integrated capabilities, you can build more autonomous, agent‑oriented applications that not only generate text but also interact with their environment.

The `v1/responses` endpoint is intended to gradually replace `v1/chat/completions`, as it embodies a synthesis of current best practices in AI—especially for those looking to adopt an agentic approach.

To help you get up to speed on both endpoints, the two following documents provide detailed documentation, complete with numerous request examples and use cases:
- [v1/chat/completion](https://github.com/MaxiDonkey/DelphiGenAI/blob/main/ChatCompletion.md#chat-completion)
- [v1/responses](https://github.com/MaxiDonkey/DelphiGenAI/blob/main/Responses.md)

>[!NOTE]
>If you're a new user, we recommend using the Responses API.

<br>

### Functional differences between the two endpoints

|Capabilities | Chat Completions API | Responses API |
|--- |:---: | :---: |
|Text generation | <div align="center"><span style="color: green;">●</span></div> | <div align="center"><span style="color: green;">●</span></div> |
| Audio  | <div align="center"><span style="color: green;">●</span></div> | Coming soon | 
| Vision | <div align="center"><span style="color: green;">●</span></div> | <div align="center"><span style="color: green;">●</span></div> |
| Structured Outputs | <div align="center"><span style="color: green;">●</span></div> | <div align="center"><span style="color: green;">●</span></div> |
| Function calling | <div align="center"><span style="color: green;">●</span></div> | <div align="center"><span style="color: green;">●</span></div> |
| Web search | <div align="center"><span style="color: green;">●</span></div> | <div align="center"><span style="color: green;">●</span></div> |
| File search |  | <div align="center"><span style="color: green;">●</span></div> |
| Computer use |  | <div align="center"><span style="color: green;">●</span></div> |
| Code interpreter |  | Coming soon |

>[!WARNING]
> [Note from OpenAI](https://platform.openai.com/docs/guides/responses-vs-chat-completions#the-chat-completions-api-is-not-going-away) <br>
> The Chat Completions API is an industry standard for building AI applications, and we intend to continue supporting this API indefinitely. We're introducing the Responses API to simplify workflows involving tool use, code execution, and state management. We believe this new API primitive will allow us to more effectively enhance the OpenAI platform into the future.

<br>

### Chat completion

Check out the full [documentation](https://github.com/MaxiDonkey/DelphiGenAI/blob/main/ChatCompletion.md#chat-completion)

[Text generation (Non streamed, Streamed, Multi-turn conversations), Generating Audio Responses with Chat (Audio and Text to Text, Audio to Audio, Audio multi-turn conversations), Vision (Analyze single source, Analyze multi-source, Low or high fidelity image understanding), Reasoning with o1, o3 or o4,  Web search...](https://github.com/MaxiDonkey/DelphiGenAI/blob/main/ChatCompletion.md#chat-completion)

<br>

### Responses

Check out the full [documentation](https://github.com/MaxiDonkey/DelphiGenAI/blob/main/Responses.md)

[Text generation (Non streamed, Streamed, Multi-turn conversations), Vision (Analyze single source, Analyze multi-source, Low or high fidelity image understanding), Reasoning with o1, o3 or o4, Web search, File search...](https://github.com/MaxiDonkey/DelphiGenAI/blob/main/Responses.md)


<br>

___

## Models

Refert to [official documentation](https://platform.openai.com/docs/models).

### List of models

The list of available models can be retrieved from the Models API response. The models are ordered by release date, with the most recently published appearing first.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;

  //Asynchronous example
  Client.Models.AsynList(
    function : TAsynModels
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Models.List;
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br/>

### Retrieve a model

Retrieve a model using its ID.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;
  TutorialHub.ModelId := '...the id tio retrieve...';

  //Asynchronous example
  Client.Models.AsynRetrieve(TutorialHub.ModelId,
    function : TAsynModel
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Models.Retrieve(TutorialHub.ModelId);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br/>

### Delete a model

Deleting a model is only possible if the model is one of your fine-tuned models.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;
  TutorialHub.ModelId := '...Id of the model to delete...';

  //Asynchronous example
  Client.Models.AsynDelete(TutorialHub.ModelId,
    function : TAsynDeletion
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Models.Delete(TutorialHub.ModelId);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br/>

___

## Image generation

Refer to [official documentation](https://platform.openai.com/docs/guides/images).

### Dall-e-3 model

Generation of an image using `dall-e-3`.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.FileName := 'Dalle3_01.png';

  //Asynchronous example
  Client.Images.AsynCreate(
    procedure (Params: TImageCreateParams)
    begin
      Params.Model('dall-e-3');
      Params.Prompt('A quarter dollar on a wooden floor close up.');
      Params.N(1);
      Params.Size('1024x1024');
      Params.Style('vivid');
      Params.ResponseFormat(TResponseFormat.url);
    end,
    function : TAsynGeneratedImages
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Images.Create(
//    procedure (Params: TImageCreateParams)
//    begin
//      Params.Model('dall-e-3');
//      Params.Prompt('A quarter dollar on a wooden floor close up.');
//      Params.N(1);
//      Params.Size('1024x1024');
//      Params.Style('vivid');
//      Params.ResponseFormat(url);
//      TutorialHub.JSONResponse := Value.JSONResponse;
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

Let’s take a closer look at how the `Display` method handles output to understand how the model’s response is managed.

```Delphi
procedure Display(Sender: TObject; Value: TGeneratedImages);
begin
  {--- Load image when url is not null. }
  if not TutorialHub.FileName.IsEmpty then
    begin
      if not Value.Data[0].Url.IsEmpty then
        Value.Data[0].Download(TutorialHub.FileName) else
        Value.Data[0].SaveToFile(TutorialHub.FileName);
    end;

  {--- Load image into a stream }
  var Stream := Value.Data[0].GetStream;
  try
    {--- Display the JSON response. }
    TutorialHub.JSONResponse := Value.JSONResponse;

    {--- Display the revised prompt. }
    Display(Sender, Value.Data[0].RevisedPrompt);

    {--- Load the stream into the TImage. }
    TutorialHub.Image.Picture.LoadFromStream(Stream);
  finally
    Stream.Free;
  end;
end;
```

`GenAI` offers optimized methods for managing image responses generated by the model. The `SaveToFile`, `Download`, and `GetStream` methods enable efficient handling of the received image content.

<br>

![Preview](https://github.com/MaxiDonkey/DelphiGenAI/blob/main/images/DallePreview.png?raw=true "Preview")

<br>


### Gpt-image-1 model

Since May 5, 2025, OpenAI has offered the `gpt-image-1` model for image creation and editing. This new model delivers higher quality compared to `dall-e-2` and `dall-e-3`.

In the configuration, you now have four additional parameters for image generation:
- **background:** Allows you to set the transparency of the generated image’s background. Only supported by `gpt-image-1`. Must be one of `transparent`, `opaque`, or `auto` (default).

- **moderation:** Controls the content-moderation level for images generated by `gpt-image-1`. Must be either` low` (less restrictive filtering) or `auto` (default).

- **output_compression:** Specifies the compression level (0–100%) for the generated images. Only supported by `gpt-image-1` when using the `webp` or `jpeg` output formats; defaults to 100.

- **output_format:** Determines the format in which generated images are returned. Only supported by `gpt-image-1`. Must be one of `png`, `jpeg`, or `webp`.

<br>

Additionally, several existing parameters have been extended with new values for `gpt-image-1`:

quality: Supports `high`, `medium`, and `low`.

size: Supports `1536×1024` (landscape), `1024×1536` (portrait), or `auto` (default).

prompt: Allows up to 32,000 characters for `gpt-image-1` (versus 1,000 for `dall-e-2` and 4,000 for `dall-e-3`).

<br>

An example of image creation with gpt-image-1 (Asynchronous because response times are much longer):

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.FileName := 'GptImage1.png';

  //Increased reception timeout (ms) as the model takes longer
  Client.API.HttpClient.ResponseTimeout := 120000;

  //Asynchronous example
  Client.Images.AsynCreate(
    procedure (Params: TImageCreateParams)
    begin
      Params.Model('gpt-image-1'); //'dall-e-3');
      Params.Prompt('A realistic photo of a coffee cup with saucer on a transparent background');
      Params.N(1);
      Params.Size('1536x1024');
      Params.BackGround('transparent');
      Params.Moderation('low');
      Params.OutputFormat('png');
      Params.Quality('high');
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynGeneratedImages
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br>

![Preview](https://github.com/MaxiDonkey/DelphiGenAI/blob/main/images/CreationGpt-image-1.png?raw=true "Preview")

<br>

>[!NOTE]
>We can notice in the returned JSON the usage values ​​which are not provided with the dall-e-2 and dall-e-3 models.

<br>

### Create image edit with gpt-image-1

Previously, I hadn’t gone into detail about the image-editing process, because the only model available at OpenAI—`DALL·E 2`—produced rather unconvincing results.

However, with `gpt-image-1`, the output quality is significantly higher.

To perform an edit:

1. Prepare your base image
     - Open the image you wish to modify and erase the area to be reworked using a transparency tool (brush or selection).

2. Generate the mask
     - The erased (transparent) region becomes the mask that you’ll supply to the model.

3. Compose your extended prompt
     - In your request, describe exactly what the model should insert into the masked area. You now have up to 32,000 tokens for a fully detailed description.

4. Execute the edit
     - Provide the model with both the masked image and your prompt; it will then know precisely where and how to apply the changes.

Below, you’ll find an example of the code to send to gpt-image-1 to initiate the edit.

<br>

```Delphi
  TutorialHub.FileName := 'Image-gpt-edit.png';

  //Increased reception timeout (ms) as the model takes longer
  Client.API.HttpClient.ResponseTimeout := 120000;

  //Asynchronous example
  Client.Images.AsynEdit(
    procedure (Params: TImageEditParams)
    begin
      Params.Model('gpt-image-1');
      Params.Image('Dalle05.png');          //<--- Unmodified image
      Params.Mask('Dalle05Mask.png');       //<--- Modified image with masked part
      Params.Prompt('Add a pink elephant'); //<--- Replace the mask by building this
      Params.Size('1024x1024');
    end,
    function : TAsynGeneratedImages
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br>

- Result with the hidden section:

![Preview](https://github.com/MaxiDonkey/DelphiGenAI/blob/main/images/GptImageMask.png?raw=true "Preview")

- Result after editing:

![Preview](https://github.com/MaxiDonkey/DelphiGenAI/blob/main/images/GptImageEditResult.png?raw=true "Preview")

___

## Text to speech

Convert a text into an audio file. Refer to [official documentation](https://platform.openai.com/docs/guides/text-to-speech)

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;
  TutorialHub.FileName := 'Speech.mp3';

  //Asynchronous example
  Client.Audio.AsynSpeech(
    procedure (Params: TSpeechParams)
    begin
      Params.Model('tts-1');
      Params.Input('Hi! what are you doing ?');
      Params.Voice('fable');
      Params.ResponseFormat(TSpeechFormat.mp3);
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynSpeechResult
    begin
      Result.Sender := TutorialHub;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Audio.Speech(
//    procedure (Params: TSpeechParams)
//    begin
//      Params.Model('tts-1');
//      Params.Input('Hi! what are you doing ?');
//      Params.Voice(alloy);
//      Params.ResponseFormat(mp3);
//      TutorialHub.JSONResponse := Value.JSONResponse;
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;  
```
<br>

Let’s take a closer look at how the `Display` method handles output to understand how the model’s response is managed.

```Delphi
procedure Display(Sender: TObject; Value: TSpeechResult);
begin
  {--- Display the JSON response }
  TutorialHub.JSONResponse := Value.JSONResponse;

  {--- The file name can not be null }
  if TutorialHub.FileName.IsEmpty then
    raise Exception.Create('Set filename value in HFTutorial instance');

  {--- Save the audio into a file. }
  Value.SaveToFile(TutorialHub.FileName);

  {--- Play the audio result }
  TutorialHub.PlayAudio;
end;
```

`GenAI` provides methods to handle audio responses generated by the model. The `SaveToFile` and `GetStream` methods enable the manipulation of received audio content.

<br>

___

## Speech to text

Convert data audio into a text. Refer to [official documentation](https://platform.openai.com/docs/guides/speech-to-text) or this [page](https://platform.openai.com/docs/guides/audio).

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequest := 'multipart';

  //Asynchronous example
  Client.Audio.AsynTranscription(
    procedure (Params: TTranscriptionParams)
    begin
      Params.&File('SpeechRecorded.wav');
      Params.Model('whisper-1');
      Params.ResponseFormat(TTranscriptionResponseFormat.verbose_json);
    end,
    function : TAsynTranscription
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Audio.Transcription(
//    procedure (Params: TTranscriptionParams)
//    begin
//      Params.&File('SpeechRecorded.wav');
//      Params.Model('whisper-1');
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

## Embeddings

**OpenAI’s** text embeddings evaluate how closely related different text strings are. These embeddings serve as a powerful tool for various applications, including:

- **Search:** Ranking results based on their relevance to a given query.
- **Clustering:** Grouping similar text strings together based on shared characteristics.
- **Recommendations:** Suggesting items that share similar text content.
- **Anomaly detection:** Identifying outliers by finding text strings with minimal similarity to the rest.
- **Diversity measurement:** Analyzing the distribution of similarities within a dataset.
- **Classification:** Assigning text strings to the category or label they closely align with.

An embedding is represented as a vector, or a list of floating-point numbers. The relatedness between two text strings is determined by measuring the distance between their respective vectors: smaller distances indicate strong similarity, while larger distances imply weaker relatedness.

Refer to [official documentation](https://platform.openai.com/docs/guides/embeddings).

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;

  //Asynchronous example
  Client.Embeddings.ASynCreate(
    procedure (Params: TEmbeddingsParams)
    begin
      Params.Input(['Hello', 'how', 'are you?']);
      Params.Model('text-embedding-3-large');
      Params.Dimensions(5);
      Params.EncodingFormat(TEncodingFormat.float);
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynEmbeddings
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Embeddings.Create(
//    procedure (Params: TEmbeddingsParams)
//    begin
//      Params.Input(['Hello', 'how', 'are you?']);
//      Params.Model('text-embedding-3-large');
//      Params.Dimensions(5);
//      Params.EncodingFormat(TEncodingFormat.float);
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

## Moderation

The moderation endpoint is a valuable resource for detecting potentially harmful text or images. When harmful content is identified, developers can take appropriate measures, such as filtering the content or managing user accounts responsible for the violations. This service is provided free of charge.

Available models for the moderation endpoint include:

- **omni-moderation-latest:** The most advanced model, supporting a wider range of content categorization and multi-modal inputs (both text and images).

- **text-moderation-latest (Legacy):** An older model designed exclusively for text-based inputs with limited categorization options. For new projects, the omni-moderation model is recommended due to its superior capabilities and broader input support.

Refer to the [official documentation](https://platform.openai.com/docs/guides/moderation).

<br>

### Modarate text inputs

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  //Asynchronous example
  Client.Moderation.AsynEvaluate(
    procedure (Params: TModerationParams)
    begin
      Params.Input('...text to classify goes here...');
      Params.Model('omni-moderation-latest');
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynModeration
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Moderation.Evaluate(
//    procedure (Params: TModerationParams)
//    begin
//      Params.Input('...text to classify goes here...');
//      Params.Model('omni-moderation-latest');
//      TutorialHub.JSONRequest := Params.ToFormat();
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

### Modarate images and text

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  var Ref := 'https://example.com/image.png';

  //Asynchronous example
  Client.Moderation.AsynEvaluate(
    procedure (Params: TModerationParams)
    begin
      Params.Input(['...text to classify goes here...', Ref]);
      Params.Model('omni-moderation-latest');
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynModeration
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Moderation.Evaluate(
//    procedure (Params: TModerationParams)
//    begin
//      Params.Input(['...text to classify goes here...', Ref]);
//      Params.Model('omni-moderation-latest');
//      TutorialHub.JSONRequest := Params.ToFormat();
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```
<br>

`GenAI` offers an efficient and streamlined approach for handling categories and scores generated by the moderation process. Specifically, the display method is designed for simplicity and ease of use, as demonstrated in the example below.

```Delphi
procedure Display(Sender: TObject; Value: TModerationResult);
begin
 {--- GenAI built the FlaggedDetail property which contains only active moderation categories. }
  for var Item in Value.FlaggedDetail do
    Display(Sender, [
      EmptyStr,
      F(Item.Category.ToString, Item.Score.ToString(ffNumber, 3, 3))
    ]);
  Display(Sender);
end;

procedure Display(Sender: TObject; Value: TModeration);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Results do
    Display(Sender, Item);
  Display(Sender);
end;
```

<br>

___

## Files

Files are used to upload documents that can be used with features like **Assistants**, **Fine-tuning**, and **Batch API**.

<br/>

### Files list

Example without parameters

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  //Asynchronous example
  Client.Files.AsynList(
    function : TAsynFiles
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Files.List;
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

Example using parameters

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  //Asynchronous example
  Client.Files.AsynList(
    procedure (Params: TFileUrlParams)
    begin
      Params.Purpose('batch');
      Params.Limit(10);
    end,
    function : TAsynFiles
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Files.List(
//    procedure (Params: TFileUrlParams)
//    begin
//      Params.Purpose('batch');
//      Params.Limit(10);
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

Refer to [parameters documentation](https://platform.openai.com/docs/api-reference/files/list).

<br/>

### File upload

You can upload files for use across multiple endpoints. Each file can be as large as 512 MB, with a maximum combined storage limit of 100 GB per organization.

The Assistants API accommodates files containing up to 2 million tokens and accepts specific file formats. For more information, refer to the [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools).

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  //Asynchronous example
  Client.Files.AsynUpload(
    procedure (Params: TFileUploadParams)
    begin
      Params.&File('BatchExample.jsonl');
      Params.Purpose(TFilesPurpose.batch);
    end,
    function : TAsynFile
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Files.Upload(
//    procedure (Params: TFileUploadParams)
//    begin
//      Params.&File('BatchExample.jsonl');
//      Params.Purpose(fp_batch);
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```
Example with batch file.

<br/>

### File retrieve

Returns information about a specific file.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.Id := '...Id file to retrieve...';

  //Asynchronous example
  Client.Files.AsynRetrieve(TutorialHub.Id,
    function : TAsynFile
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Files.Retrieve(TutorialHub.Id);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br/>

### File retrieve content

Returns the contents of the specified file.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.Id := '...Id of the file to retrieve content...';

  //Asynchronous example
  Client.Files.AsynRetrieveContent(TutorialHub.Id,
    function : TAsynFileContent
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Files.RetrieveContent(TutorialHub.Id);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br/>

### File Deletion

Delete a file.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.Id := '...Id file to delete...';

  //Synchronous example
  var Value := Client.Files.Delete(TutorialHub.Id);
  try
    Display(TutorialHub, F('Deleted', BoolToStr(Value.Deleted, True)));
  finally
    Value.Free;
  end;
```

<br/>

# Beyond the Basics Advanced Usage

[This section](https://github.com/MaxiDonkey/DelphiGenAI/blob/main/BeyondBasics.md) covers the advanced use of OpenAI's APIs, including key features such as `upload` management, `batch` processing, `vector` stores, and the use of `assistants`, `threads`, `messages`, and `runs`. It also addresses model `fine-tuning` and includes a note on `distillation`.

<br>

___

# Legacy

For practical purposes, **completion APIs** can be utilized through `GenAI`, enabling the use of models such as ***gpt-3.5-turbo-instruct***, among others. However, the assistant system in Beta 1 is not supported by `GenAI`.

<br>

## Completion

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  //Asynchronous example
  Client.Completion.AsynCreate(
    procedure (Params: TCompletionParams)
    begin
      Params.Model('gpt-3.5-turbo-instruct');
      Params.Prompt('Give a simple explanation of what curiosity is, in one short sentence.');
      Params.Logprobs(5);
      Params.MaxTokens(96);
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynCompletion
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Completion.Create(
//    procedure (Params: TCompletionParams)
//    begin
//      Params.Model('gpt-3.5-turbo-instruct');
//      Params.Prompt('Give a simple explanation of what curiosity is, in one short sentence.');
//      Params.Logprobs(5);
//      Params.MaxTokens(96);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```
<br>

___

## Streamed completion

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  //Asynchronous example
  Client.Completion.AsynCreateStream(
    procedure (Params: TCompletionParams)
    begin
      Params.Model('gpt-3.5-turbo-instruct');
      Params.Prompt('Say this is a test');
      Params.MaxTokens(96);
      Params.Stream;
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynCompletionStream
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnProgress := DisplayStream;
      Result.OnError := Display;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
    end);

  //Synchronous example
//  var Value := Client.Completion.CreateStream(
//    procedure (Params: TCompletionParams)
//    begin
//      Params.Model('gpt-3.5-turbo-instruct');
//      Params.Prompt('Say this is a test');
//      Params.MaxTokens(96);
//      Params.Stream;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    procedure (var Data: TCompletion; IsDone: Boolean; var Cancel: Boolean)
//    begin
//      if Assigned(Data) and not IsDone then
//        DisplayStream(TutorialHub, Data);
//    end);
```

<br>

___

# Tips and tricks

- #### How to prevent an error when closing an application while requests are still in progress?

Starting from version ***1.0.1 of GenAI***, the `GenAI.Monitoring` unit is **responsible for monitoring ongoing HTTP requests.**

The `Monitoring` interface is accessible by including the `GenAI.Monitoring` unit in the `uses` clause. <br>
Alternatively, you can access it via the `HttpMonitoring` function, declared in the `GenAI` unit.

**Usage Example**

```Delphi
//uses GenAI;

procedure TForm1.FormCloseQuery(Sender: TObject; var CanClose: Boolean);
begin
  CanClose := not HttpMonitoring.IsBusy;
  if not CanClose then
    MessageDLG(
      'Requests are still in progress. Please wait for them to complete before closing the application."',
      TMsgDlgType.mtInformation, [TMsgDlgBtn.mbOK], 0);
end;

```

<br>

- #### How to execute multiple background requests to process a batch of responses?

In the `GenAI.Chat` unit, the `CreateParallel` method allows for executing multiple prompts asynchronously in the background ***(since the version 1.0.1 of GenAI)***.

Among the method's parameters, you can specify the model to be used for the entire batch of prompts. However, assigning a different model to each prompt individually is not supported.

**Usage Example**

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  Client.Chat.CreateParallel(
    procedure (Params: TBundleParams)
    begin
      Params.Prompts([
        'How many television channels were there in France in 1980?',
        'How many TV channels were there in Germany in 1980?.'
      ]);
      Params.System('Write the text in capital letters.');
      Params.Model('gpt-4o-mini');
    end,
    function : TAsynBundleList
    begin
      Result.Sender := TutorialHub;

      Result.OnStart :=
        procedure (Sender: TObject)
        begin
          Display(Sender, 'Start the job' + sLineBreak);
        end;

      Result.OnSuccess :=
        procedure (Sender: TObject; Bundle: TBundleList)
        begin
          // Background bundle processing
          for var Item in Bundle.Items do
            begin
              Display(Sender, 'Index : ' + Item.Index.ToString);
              Display(Sender, 'FinishIndex : ' + Item.FinishIndex.ToString);
              Display(Sender, Item.Prompt + sLineBreak);
              Display(Sender, Item.Response + sLineBreak + sLineBreak);
              // or Display(Sender, TChat(Item.Chat).Choices[0].Message.Content);
            end;
        end;

      Result.OnError := Display;
    end);
```

>[!TIP]
> The provided example is somewhat simplified. It would be better to adopt this approach with ***JSON-formatted outputs***, as this allows for the implementation of more complex and tailored processing during the final stages. 

<br>

- #### How to structure a chain of thought and develop advanced processing with GenAI?

To achieve this, it is recommended to use a Promise-based pattern to efficiently construct a chain of thought with GenAI. The [CerebraChain](https://github.com/MaxiDonkey/CerebraChainAI) project offers a method that can be used with GenAI.

<br>

- #### How do you structure advanced reasoning using Promises and pipelines?

Orchestrate AI thought chains elegantly and efficiently. By leveraging a dynamic pipeline model, a configurable sequential scheduler, and Promises, you can meet the complex requirements of working with modern AI models like OpenAI. Check out the [SynkFlow repository](https://github.com/MaxiDonkey/SynkFlowAI).

<br>

___

# GenAI functional coverage

Below, the table succinctly summarizes all OpenAI endpoints supported by the GenAI.

|End point | supported | 
|--- |:---: | 
| /assistants | <div align="center"><span style="color: green;">●</span></div> |
| /audio/speech | <div align="center"><span style="color: green;">●</span></div> |
| /audio/transcriptions | <div align="center"><span style="color: green;">●</span></div> |
| /audio/translations | <div align="center"><span style="color: green;">●</span></div> |
| /batches | <div align="center"><span style="color: green;">●</span></div> |
| /chat/completions | <div align="center"><span style="color: green;">●</span></div> |
| /completions | <div align="center"><span style="color: green;">●</span></div> |
| /embeddings | <div align="center"><span style="color: green;">●</span></div> |
| /evals |  |
| /files | <div align="center"><span style="color: green;">●</span></div> |
| /fine_tuning/ | <div align="center"><span style="color: green;">●</span></div> |
| /images | <div align="center"><span style="color: green;">●</span></div> |
| /models | <div align="center"><span style="color: green;">●</span></div> |
| /moderations | <div align="center"><span style="color: green;">●</span></div> |
| /organization |  |
| /realtime |  |
| /responses | <div align="center"><span style="color: green;">●</span></div> |
| /threads | <div align="center"><span style="color: green;">●</span></div> |
| /uploads | <div align="center"><span style="color: green;">●</span></div> |
| /vector_stores | <div align="center"><span style="color: green;">●</span></div> |

<br>

___

# Contributing

Pull requests are welcome. If you're planning to make a major change, please open an issue first to discuss your proposed changes.

<br>

___

# License

This project is licensed under the [MIT](https://choosealicense.com/licenses/mit/) License.

<br>

Le fichier markdown avec la documentation sur le point de terminaison v1/chat/completiion que l'on trouve à cette adresse : https://github.com/MaxiDonkey/DelphiGenAI/blob/main/ChatCompletion.md#chat-completion

# Chat completion

- [Text generation](#text-generation)
    - [Non streamed](#non-streamed) 
    - [Streamed](#streamed)
    - [Multi-turn conversations](#multi-turn-conversations) 
    - [Parallel method for generating text](#parallel-method-for-generating-text)
    - [CRUD operations on saved chat completions](#crud-operations-on-saved-chat-completions)
        - [Get chat completion](#get-chat-completion)
        - [Get chat messages](#get-chat-messages)
        - [List chat completions](#list-chat-completions)
        - [Update chat completion](#update-chat-completion)
        - [Delete chat completion](#delete-chat-completion)
- [Generating Audio Responses with Chat](#generating-audio-responses-with-chat)
- [Input Audio for Chat](#input-audio-for-chat)
    - [Audio and Text to Text](#audio-and-text-to-text)
    - [Audio to Audio](#audio-to-audio)
    - [Audio multi-turn conversations](#audio-multi-turn-conversations)
- [Vision](#vision)
    - [Analyze single source](#analyze-single-source)
    - [Analyze multi-source](#analyze-multi-source)
    - [Low or high fidelity image understanding](#low-or-high-fidelity-image-understanding)
- [Reasoning with o1, o3 or o4](#reasoning-with-o1-o3-or-o4)
- [Web search](#web-search)
- [Function calling](#function-calling)

<br>

___

## Text generation

You can send a structured list of input messages containing only text content, and the model will generate the next message in the conversation.

The Chat API can be used for both single-turn requests and multi-turn, stateless conversations.

### Non streamed

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;

  //Asynchronous example
  Client.Chat.AsynCreate(
    procedure (Params: TChatParams)
    begin
      Params.Model('gpt-4o');
      Params.Messages([
        FromSystem('You are a comedian looking for jokes for your new show.'),
        FromUser('What is the difference between a mathematician and a physicist?')
      ]);
      //Params.Store(True);  // to store chat completion
      TutorialHub.JSONRequest := Params.ToFormat(); //to display JSON Request
    end,
    function : TAsynChat
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Chat.Create(
//    procedure (Params: TChatParams)
//    begin
//      Params.Model('gpt-4o');
//      Params.Messages([
//        FromSystem('You are a comedian looking for jokes for your new show.'),
//        FromUser('What is the difference between a mathematician and a physicist?')
//      ]);
//      //Params.Store(True);  // to store chat completion
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```
<br>

>[!IMPORTANT]
> - Param.store to store the chat completion (Refer to [CRUD section](#crud-operations-on-saved-chat-completions)) 
> - Stored completions can be retrieved from the [Plateform Dashboard](https://platform.openai.com/logs?api=chat-completions)

<br>

By using the GenAI.Tutorial.VCL unit along with the initialization described [above](#Strategies-for-quickly-using-the-code-examples), you can achieve results similar to the example shown below.

![Preview](https://github.com/MaxiDonkey/DelphiGenAI/blob/main/images/GenAIChatRequest.png?raw=true "Preview")

<br>

### Streamed

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;

  //Asynchronous example
  Client.Chat.AsynCreateStream(
    procedure(Params: TChatParams)
    begin
      Params.Model('gpt-4.1-mini');
      Params.Messages([
          FromSystem('You are a comedian looking for jokes for your new show.'),
          FromUser('What is the difference between a mathematician and a physicist?')]);
      //Params.Store(True);  // to store chat completion
      Params.Stream;
      TutorialHub.JSONRequest := Params.ToFormat(); //to display JSON Request
    end,
    function : TAsynChatStream
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnProgress := DisplayStream;
      Result.OnError := Display;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
    end);

  //Synchronous example
//  Client.Chat.CreateStream(
//    procedure (Params: TChatParams)
//    begin
//      Params.Model('gpt-4.1-mini');
//      Params.Messages([
//          Payload.System('You are a comedian looking for jokes for your new show.'),
//          Payload.User('What is the difference between a mathematician and a physicist?')]);
//      //Params.Store(True);  // to store chat completion
//      Params.Stream;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    procedure (var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
//    begin
//      if (not IsDone) and Assigned(Chat) then
//        begin
//          DisplayStream(TutorialHub, Chat);
//        end;
//    end);
```

![Preview](https://github.com/MaxiDonkey/DelphiGenAI/blob/main/images/GenAIChatStreamedRequest.png?raw=true "Preview")

<br>

### Multi-turn conversations

The `GenAI Chat API` enables the creation of interactive chat experiences tailored to your users' needs. Its chat functionality supports multiple rounds of questions and answers, allowing users to gradually work toward solutions or receive help with complex, multi-step issues. This capability is especially useful for applications requiring ongoing interaction, such as:

- **Chatbots**
- **Educational tools**
- **Customer support assistants**

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;

  //Asynchronous example
  Client.Chat.AsynCreateStream(
    procedure(Params: TChatParams)
    begin
      Params.Model('gpt-4.1-nano');
      Params.Messages([
          FromDeveloper('You are a funny domestic assistant.'),
          FromUser('Hello'),
          FromAssistant('Great to meet you. What would you like to know?'),
          FromUser('I have two dogs in my house. How many paws are in my house?') ]);
      Params.MaxCompletionTokens(1024);
      Params.Stream;
      TutorialHub.JSONRequest := Params.ToFormat(); //to display JSON Request
    end,
    function : TAsynChatStream
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnProgress := DisplayStream;
      Result.OnError := Display;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
    end);

  //Synchronous example
//  Client.Chat.CreateStream(
//    procedure (Params: TChatParams)
//    begin
//      Params.Model('gpt-4.1-nano');
//      Params.Messages([
//          FromDeveloper('You are a funny domestic assistant.'),
//          FromUser('Hello'),
//          FromAssistant('Great to meet you. What would you like to know?'),
//          FromUser('I have two dogs in my house. How many paws are in my house?') ]);
//      Params.MaxCompletionTokens(1024);
//      Params.Stream;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    procedure (var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
//    begin
//      if (not IsDone) and Assigned(Chat) then
//        begin
//          DisplayStream(TutorialHub, Chat);
//        end;
//    end);
```

>[!TIP]
>The `FromUser` and `FromAssistant` methods simplify role management and enhance code readability, eliminating the need to use **TMessagePayload** (e.g., **TMessagePayload.User('Hello'))**. Similarly, `FromDeveloper`, `FromSystem`, and `FromTool` improve code clarity. For details on these methods and their configurations, refer to the `GenAI.pas` unit.
>

<br>

### Parallel method for generating text

This approach enables the simultaneous execution of multiple prompts, provided they are all processed by the same model. It also supports parallel web requests.

#### Example 1 : Two prompts processed in parallel.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

    Client.Chat.CreateParallel(
    procedure (Params: TBundleParams)
    begin
      Params.Prompts([
        'How many television channels were there in France in 1980?',
        'How many TV channels were there in Germany in 1980?.'
      ]);
      Params.System('Write the response in capital letters.');
      Params.Model('gpt-4o-mini');
    end,
    function : TAsynBundleList
    begin
      Result.Sender := TutorialHub;

      Result.OnStart :=
        procedure (Sender: TObject)
        begin
          Display(Sender, 'Start the job' + sLineBreak);
        end;

      Result.OnSuccess :=
        procedure (Sender: TObject; Bundle: TBundleList)
        begin
          // Background bundle processing
          for var Item in Bundle.Items do
            begin
              Display(Sender, 'Index : ' + Item.Index.ToString);
              Display(Sender, 'FinishIndex : ' + Item.FinishIndex.ToString);
              Display(Sender, Item.Prompt + sLineBreak);
              Display(Sender, Item.Response + sLineBreak + sLineBreak);
              // or Display(Sender, TChat(Item.Chat).Choices[0].Message.Content);
            end;
        end;

      Result.OnError := Display;
    end)
```

You can also use reasoning models in parallel processing: <br> 

```Delphi
...
   Params.Prompts([
        'How many television channels were there in France in 1980?',
        'How many TV channels were there in Germany in 1980?.'
      ]);
      Params.Model('o4-mini');
      Params.ReasoningEffort('high');
    end,
...
```

<br>

#### Example 2 : Three web search processed in parallel.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

    Client.Chat.CreateParallel(
    procedure (Params: TBundleParams)
    begin
      Params.Prompts([
        'What is the current date and time in Paris, France?',
        'What''s the news in the USA today?',
        'What''s new in Berlin today?'
      ]);
      Params.Model('gpt-4o-search-preview');
      Params.SearchSize('medium');
      Params.Country('FR');
      Params.City('Reims');
    end,
    function : TAsynBundleList
    begin
      Result.Sender := TutorialHub;

      Result.OnStart :=
        procedure (Sender: TObject)
        begin
          Display(Sender, 'Start the job' + sLineBreak);
        end;

      Result.OnSuccess :=
        procedure (Sender: TObject; Bundle: TBundleList)
        begin
          // Background bundle processing
          for var Item in Bundle.Items do
            begin
              Display(Sender, 'Index : ' + Item.Index.ToString);
              Display(Sender, 'FinishIndex : ' + Item.FinishIndex.ToString);
              Display(Sender, Item.Prompt + sLineBreak);
              Display(Sender, Item.Response + sLineBreak + sLineBreak);
              // or Display(Sender, TChat(Item.Chat).Choices[0].Message.Content);
            end;
        end;

      Result.OnError := Display;
    end)
```
<br>

### CRUD operations on saved chat completions

>
>CRUD = `C`reate `R`ead `U`pdate `D`elete
>

#### Why CRUD on chat completions ?

- **Traceability and Auditing:**  Being able to save, update, and delete responses directly from your wrapper makes it easier to manage the conversation history on both the client and server sides.

- **Business Scenarios:** For example, in a support assistant integrated into a Delphi application, it’s a real advantage to have an identifier—and the ability to correct or annotate—each generated response.

<br>

#### Get chat completion

Get a stored chat completion. Only [Chat Completions](https://github.com/MaxiDonkey/DelphiGenAI/blob/main/ChatCompletion.md#text-generation) that have been created with the `store` parameter set to `true` will be returned. Refer to [official documentation.](https://platform.openai.com/docs/api-reference/chat/get)

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;

  //Asynchronous example
  Client.Chat.AsynGetCompletion('completion_id',   //e.g. 'chatcmpl-BO9ybVceB3aXFyMRKR3MKUEzWcFqE'
    function : TAsynChat
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Chat.GetCompletion('completion_id');   //e.g. 'chatcmpl-BO9ybVceB3aXFyMRKR3MKUEzWcFqE'
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

#### Get chat messages

Get the messages in a stored chat completion. Only [Chat Completions](https://github.com/MaxiDonkey/DelphiGenAI/blob/main/ChatCompletion.md#text-generation) that have been created with the `store` parameter set to `true` will be returned. Refer to [official documentation.](https://platform.openai.com/docs/api-reference/chat/getMessages)

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;

  //Asynchronous example
  Client.Chat.AsynGetMessages('completion_id',   //e.g. 'chatcmpl-BO9ybVceB3aXFyMRKR3MKUEzWcFqE'
    procedure (Param: TUrlChatParams)
    begin
      Param.Limit(15);
      Param.Order('asc');
    end,
    function : TAsynChatMessages
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Chat.GetMessages('completion_id',   //e.g. 'chatcmpl-BO9ybVceB3aXFyMRKR3MKUEzWcFqE'
//    procedure (Param: TUrlChatParams)
//    begin
//      Param.Limit(15);
//      Param.Order('asc')
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

#### List chat completions

List stored Chat Completions. Only [Chat Completions](https://github.com/MaxiDonkey/DelphiGenAI/blob/main/ChatCompletion.md#text-generation) that have been stored with the `store` parameter set to `true` will be returned. Refer to [official documentation.](https://platform.openai.com/docs/api-reference/chat/list)

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;

  //Asynchronous example
  Client.Chat.AsynList(
    procedure (Params: TUrlChatListParams)
    begin
      Params.Limit(15);
    end,
    function : TAsynChatCompletion
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);


  //Synchronous example
//  var Value := Client.Chat.List(
//    procedure (Params: TUrlChatListParams)
//    begin
//      Params.Limit(15)
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

#### Update chat completion

Modify a stored chat completion. Only [Chat Completions](https://github.com/MaxiDonkey/DelphiGenAI/blob/main/ChatCompletion.md#text-generation) that have been created with the `store` parameter set to `true` can be modified. Currently, the only supported modification is to update the `metadata` field. Refer to [official documentation.](https://platform.openai.com/docs/api-reference/chat/update)

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;

  //Asynchronous example
  Client.Chat.AsynUpdate('completion_id',   //e.g. 'chatcmpl-BO9ybVceB3aXFyMRKR3MKUEzWcFqE'
    procedure (Params: TChatUpdateParams)
    begin
      Params.Metadata(TJSONObject.Create.AddPair('foo', 'bar'));
    end,
    function : TAsynChat
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Chat.Update('completion_id',   //e.g. 'chatcmpl-BO9ybVceB3aXFyMRKR3MKUEzWcFqE'
//    procedure (Params: TChatUpdateParams)
//    begin
//      Params.Metadata(TJSONObject.Create.AddPair('foo', 'bar'));
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

#### Delete chat completion

Delete a stored chat completion. Only [Chat Completions](https://github.com/MaxiDonkey/DelphiGenAI/blob/main/ChatCompletion.md#text-generation) that have been created with the `store` parameter set to `true` can be deleted. Refer to [official documentation.](https://platform.openai.com/docs/api-reference/chat/delete)

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;

  //Asynchronous example
  Client.Chat.AsynDelete('completion_id',   //e.g. 'chatcmpl-BO9ybVceB3aXFyMRKR3MKUEzWcFqE'
    function : TAsynChatDelete
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Chat.Delete('completion_id');   //e.g. 'chatcmpl-BO9ybVceB3aXFyMRKR3MKUEzWcFqE'
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

## Generating Audio Responses with Chat

Beyond generating text and images, certain models enable the creation of spoken audio responses from prompts and the use of audio inputs to interact with the model. Audio inputs can provide richer information than text alone, allowing the model to capture tone, inflection, and other nuances.

These audio features can be leveraged to:

- Produce a spoken audio summary from a text body (text input, audio output)
- Conduct sentiment analysis on an audio recording (audio input, text output)
- Facilitate asynchronous speech-to-speech interactions with the model (audio input, audio output)

For example, the `GPT-4o-Audio-Preview` model can process audio both as input and output. Please note, this model does not have vision capability.

Refer to official [documentation](https://platform.openai.com/docs/guides/audio?example=audio-out).

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;
  
  TutorialHub.JSONRequestClear;
  TutorialHub.FileName := 'AudioResponse.mp3';

  //Asynchronous example
  Client.Chat.AsynCreate(
    procedure (Params: TChatParams)
    begin
      Params.Model('gpt-4o-audio-preview');
      Params.Modalities(['text', 'audio']);
      Params.Audio('ballad', 'mp3');
      Params.Messages([
        FromUser('Is a golden retriever a good family dog?')
      ]);
      Params.MaxCompletionTokens(1024);
      TutorialHub.JSONRequest := Params.ToFormat(); //to display JSON Request
    end,
    function : TAsynChat
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := DisplayAudio;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Chat.Create(
//    procedure (Params: TChatParams)
//    begin
//      Params.Model('gpt-4o-audio-preview');
//      Params.Modalities(['text', 'audio']);
//      Params.Audio('ash', 'mp3');
//      Params.Messages([
//        FromUser('Is a golden retriever a good family dog?')
//      ]);
//      Params.MaxCompletionTokens(1024)
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    DisplayAudio(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

>[!NOTE]
>  The **Params.Audio('ash', 'mp3')** function allows you to select the output voice and specify the desired audio data format.
>
>  About **Params.Modalities(['text', 'audio'])**; modalities supported by gpt-4o-audio-preview**
>   - text in → text + audio out
>   - audio in → text + audio out
>   - audio in → text out
>   - text + audio in → text + audio out
>   - text + audio in → text out 

<br>

Let’s take a closer look at how the `DisplayAudio` method handles output to understand how the model’s response is managed.

```Delphi
procedure DisplayAudio(Sender: TObject; Value: TChat);
begin
  {--- Display the JSON response }
  TutorialHub.JSONResponse := Value.JSONResponse;

  {--- We need an audio filename for the tutorial }
  if TutorialHub.FileName.IsEmpty then
    raise Exception.Create('Set filename value in HFTutorial instance');

  {--- Store the audio Id. }
  TutorialHub.AudioId := Value.Choices[0].Message.Audio.Id;

  {--- Store the audio transcript. }
  TutorialHub.Transcript := Value.Choices[0].Message.Audio.Transcript;

  {--- The audio response is stored in a file. }
  Value.Choices[0].Message.Audio.SaveToFile(TutorialHub.FileName);

  {--- Display the textual response. }
  Display(Sender, Value.Choices[0].Message.Audio.Transcript);

  {--- Play audio response. }
  TutorialHub.PlayAudio;
  Display(Sender, sLineBreak);
end;
```

`GenAI` provides methods to handle audio responses generated by the model. The `SaveToFile` and `GetStream` methods enable the manipulation of received audio content.

<br>

___

## Input Audio for Chat

Refer to official [documentation](https://platform.openai.com/docs/guides/audio?example=audio-in).

### Audio and Text to Text

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;
  var Ref := 'https://cdn.openai.com/API/docs/audio/alloy.wav';

  //Asynchronous example
  Client.Chat.ASynCreate(
    procedure (Params: TChatParams)
    begin
      Params.Model('gpt-4o-audio-preview');
      Params.Modalities(['text']); 
      Params.Messages([
        FromUser('What is in this recording?', [Ref])
      ]);
      Params.MaxCompletionTokens(1024);
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynChat
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display; 
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Chat.Create(
//    procedure (Params: TChatParams)
//    begin
//      Params.Model('gpt-4o-audio-preview');
//      Params.Modalities(['text']);
//      Params.Messages([
//        FromUser('What is in this recording?', [Ref])
//      ]);
//      Params.MaxCompletionTokens(1024);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

### Audio to Audio

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;
  TutorialHub.FileName := 'Response.mp3';

  //Asynchronous example
  Client.Chat.ASynCreate(
    procedure (Params: TChatParams)
    begin
      Params.Model('gpt-4o-audio-preview');
      Params.Modalities(['text', 'audio']);
      Params.Audio('ash', 'mp3');
      Params.Messages([
        FromUser(['SpeechRecorded.mp3'])
      ]);
      Params.MaxCompletionTokens(1024);
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynChat
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := DisplayAudio;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Chat.Create(
//    procedure (Params: TChatParams)
//    begin
//      Params.Model('gpt-4o-audio-preview');
//      Params.Modalities(['text', 'audio']);
//      Params.Audio('ash', 'mp3');
//      Params.Messages([
//        FromUser(['SpeechRecorded.mp3'])
//      ]);
//      Params.MaxCompletionTokens(1024);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    DisplayAudio(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

>[!WARNING]
> OpenAI provides other models for simple speech to text and text to speech - when your task requires those conversions (and not dynamic content from a model), the `TTS` and `STT` models will be more performant and cost-efficient.

<br>

### Audio multi-turn conversations

TutorialHub retains the ID of the most recent audio response. To proceed, simply construct the message as follows:

```Delphi
  ...
    procedure (Params: TChatParams)
    begin
      Params.Model('gpt-4o-audio-preview');
      Params.Modalities(['text', 'audio']);
      Params.Audio('ash', 'mp3');
      Params.Messages([
        FromUser('Is a golden retriever a good family dog?'),
        FromAssistantAudioId(TutorialHub.AudioId),   //or FromAssistantAudioId(TutorialHub.Transcript),
        FromUser('Why do you say they are loyal?')
      ]);
  ...
```

The `message.audio.id` value above provides an identifier that you can use in an assistant message for a new `/chat/completions` request, as in the example above.

It is also possible to omit the audio ID and use the associated text via `Message.Audio.Transcript` instead. However, the model will not be able to analyze the emotions contained in the audio portion of the message.

>[!CAUTION]
>Of course, this is just a simple example. TutorialHub is designed solely to showcase `GenAI`. In a more general scenario, it would be necessary to maintain a history of **audio IDs** to accurately build the conversation history.

<br>

___

## Vision

Refer to the [official documentation](https://platform.openai.com/docs/guides/vision).

### Analyze single source

`GenAI` processes images from both web sources and local files uniformly. It manages the submission of the source to the API, thereby simplifying the developer's task. Therefore, in this example, we will handle sources in the form of a ***URL*** and ***base-64 encoded*** data.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  var Url := 'https://upload.wikimedia.org/wikipedia/commons/thumb/d/dd/Gfp-wisconsin-madison-the-nature-boardwalk.jpg/2560px-Gfp-wisconsin-madison-the-nature-boardwalk.jpg';
  //var Ref := 'D:\My_folder\Images\My_image.png'; //This content will be encoded in base-64 by GenAI
  TutorialHub.JSONRequestClear;

  //Asynchronous example
  Client.Chat.AsynCreateStream(
    procedure (Params: TChatParams)
    begin
      Params.Model('gpt-4o-mini');
      Params.Messages([
        FromUser('What is in this image?', [Url])
        //FromUser('What is in this image?', [Ref])
      ]);
      Params.MaxCompletionTokens(1024);
      Params.Stream;
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynChatStream
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnProgress := DisplayStream;
      Result.OnError := Display;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
    end);

  //Synchronous example
//  var Value := Client.Chat.CreateStream(
//    procedure (Params: TChatParams)
//    begin
//      Params.Model('gpt-4o-mini');
//      Params.Messages([
//        FromUser('What is in this image?', [Url])
//        //FromUser('What is in this image?', [Ref])
//      ]);
//      Params.MaxCompletionTokens(1024);
//      Params.Stream;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    procedure (var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
//    begin
//      if Assigned(Chat) and not IsDone then
//        DisplayStream(TutorialHub, Chat);
//    end);
```
This example uses streaming. The non-streamed version is straightforward to implement, so it is not covered here.

<br>

### Analyze multi-source

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  var Url1 := 'https://tripfixers.com/wp-content/uploads/2019/11/eiffel-tower-with-snow.jpeg';
  var Url2 := 'https://assets.visitorscoverage.com/production/wp-content/uploads/2024/04/AdobeStock_626542468-min-1024x683.jpeg';
  TutorialHub.JSONRequestClear;

  //Asynchronous example
  Client.Chat.AsynCreateStream(
    procedure (Params: TChatParams)
    begin
      Params.Model('gpt-4o-mini');
      Params.Messages([
        FromUser('What are the differences between two images?', [Url1, Url2])
      ]);
      Params.MaxCompletionTokens(1024);
      Params.Stream;
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynChatStream
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnProgress := DisplayStream;
      Result.OnError := Display;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
    end);

  //Synchronous example
//  var Value := Client.Chat.CreateStream(
//    procedure (Params: TChatParams)
//    begin
//      Params.Model('gpt-4o-mini');
//      Params.Messages([
//        FromUser('What are the differences between two images?', [Url1, Url2])
//      ]);
//      Params.MaxCompletionTokens(1024);
//      Params.Stream;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    procedure (var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
//    begin
//      if Assigned(Chat) and not IsDone then
//        DisplayStream(TutorialHub, Chat);
//    end);
```

<br>

### Low or high fidelity image understanding

The detail parameter, which includes three options—**low**, **high**, and **auto**—allows you to customize how the model interprets the image and generates its textual representation. By default, the **auto** setting is applied, where the model evaluates the input image size and automatically selects either the **low** or **high** mode.

- **low mode** activates "low resolution" processing, where the model works with a 512px x 512px version of the image, represented using 85 tokens. This option is ideal for applications where speed and efficiency are prioritized over high detail, as it reduces response time and token consumption.

- **high mode** activates "high resolution" processing. Initially, the model examines the low-resolution image using 85 tokens, then refines its understanding by analyzing detailed segments of the image, dedicating 170 tokens per 512px x 512px tile. This mode is suited for cases requiring precise image details.

`GenAI` allows the addition of `detail=high` or `detail=low` directly in the URL, thereby simplifying the activation of the detail option as follows:

```Delphi
  var Url1 := 'https://tripfixers.com/.../eiffel-tower-with-snow.jpeg detail=high';
  //or
  var Url1 := 'https://tripfixers.com/.../eiffel-tower-with-snow.jpeg detail=low';
```

The same process is applied to the local file paths.

<br>

___

## Reasoning with o1, o3 or o4

**Advanced models for reasoning and problem-solving.**
Reasoning models, such as **OpenAI’s** `o1`, `o3` `o4-mini`, are large language models trained using reinforcement learning to handle complex reasoning tasks. These models “think” before generating a response by forming a detailed internal chain of reasoning. This approach allows them to excel in areas like advanced problem-solving, coding, scientific analysis, and multi-step planning within agent-driven workflows.

Similar to GPT models, they offer two options: a smaller, faster, and more cost-effective model (`o4-mini`) and a larger model (`o1`, `o3`) that, while slower and more expensive per token, often produces higher-quality responses for challenging tasks and demonstrates stronger generalization across various domains.

Since these models can require response times ranging from a few seconds to several tens of seconds, it is more prudent and efficient to use asynchronous methods when using them.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;

  //Asynchronous example
  Client.Chat.AsynCreateStream(
    procedure(Params: TChatParams)
    begin
      Params.Model('o4-mini');
      Params.Messages([
        FromUser('Write a bash script that takes a matrix represented as a string with format \"[1,2],[3,4],[5,6]\" and prints the transpose in the same format.')
      ]);
      Params.ReasoningEffort(TReasoningEffort.high);  //or Params.ReasoningEffort('high');
      Params.Stream;
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynChatStream
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnProgress := DisplayStream;
      Result.OnError := Display;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
    end);
```

<br>

The OpenAI `o1`, `o3` and `o4` series models are highly capable across several advanced tasks, including:

- **Implementing complex algorithms and generating code:** For example, a prompt can instruct the o1 model to refactor a React component based on specific requirements.

- **Developing multi-step plans:** The models can create detailed plans, such as generating a complete filesystem structure and providing Python code that fulfills the given use case.

- **Supporting STEM research:** The models have demonstrated strong performance in scientific and technical research tasks, with prompts designed for basic research yielding highly effective results.

For more information, consult the [official documentation](https://platform.openai.com/docs/guides/reasoning).

<br>

___

## Web search

Now you can now search the web for the latest information before generating a response. With the chat completion API, you gain access to the same models and tools optimized for web search in ChatGPT.

When a request is sent via chat completion, the model automatically retrieves online information before formulating its response. However, if you want the web_search_preview tool to be used only when necessary, you should use the responses API instead.

Currently, only specific models support web search through chat completion:
- `gpt-4o-search-preview`
- `gpt-4o-mini-search-preview`

These models incorporate web search to deliver more accurate and up-to-date responses.

### Web search : code sample 1

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;

  //Asynchronous example
  Client.Chat.AsynCreate(
    procedure (Params: TChatParams)
    begin
      Params.Model('gpt-4o-search-preview');
      Params.Messages([
        FromUser('What was a positive news story from today?')
      ]);
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynChat
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Chat.Create(
//    procedure (Params: TChatParams)
//    begin
//      Params.Model('gpt-4o-search-preview');
//      Params.Messages([
//        FromUser('What was a positive news story from today?')
//      ]);
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;  
```

<br>

### Output and citations

The choices element in the API response includes:
- **message.content:** The text generated by the model, with embedded citations referencing the sources.
- **annotations:** A list detailing the cited URLs.

By default, the model automatically incorporates citations from web search results. Additionally, each url_citation annotation provides specific details about the referenced source, including the URL, the page title, and the start and end character positions in the response where the citation appears.

```JSON
 [
        {
            "index": 0,
            "message": {
                "role": "assistant",
                "content": "As of March 12, 2025, a notable positive news story is the agreement between the United States and Ukraine on a 30-day ceasefire in the conflict with Russia. This development, announced on March 11, 2025, includes the resumption of U.S. military aid and intelligence sharing with Ukraine. U.S. Secretary of State Marco Rubio expressed hope that Russia would respond positively to the proposal, aiming for a swift transition to comprehensive negotiations. ([straitstimes.com](https:\/\/www.straitstimes.com\/world\/while-you-were-sleeping-5-stories-you-might-have-missed-march-12-2025?utm_source=openai))\n\nAdditionally, in Indonesia, authorities rescued a critically endangered two-month-old male Sumatran elephant that had become separated from its mother in a palm oil plantation. The calf was found in Riau province on Sumatra island and is now under the care of local conservation agencies. With only about 2,400-2,800 Sumatran elephants remaining, this rescue is a significant step toward the species' conservation. ([straitstimes.com](https:\/\/www.straitstimes.com\/world\/while-you-were-sleeping-5-stories-you-might-have-missed-march-12-2025?utm_source=openai))\n\nThese stories highlight ongoing efforts toward conflict resolution and wildlife conservation, reflecting positive developments in international relations and environmental protection. ",
                "refusal": null,
                "annotations": [
                    {
                        "type": "url_citation",
                        "url_citation": {
                            "end_index": 599,
                            "start_index": 455,
                            "title": "While You Were Sleeping: 5 stories you might have missed, March 12, 2025 | The Straits Times",
                            "url": "https:\/\/www.straitstimes.com\/world\/while-you-were-sleeping-5-stories-you-might-have-missed-march-12-2025?utm_source=openai"
                        }
                    },
                    {
                        "type": "url_citation",
                        "url_citation": {
                            "end_index": 1160,
                            "start_index": 1016,
                            "title": "While You Were Sleeping: 5 stories you might have missed, March 12, 2025 | The Straits Times",
                            "url": "https:\/\/www.straitstimes.com\/world\/while-you-were-sleeping-5-stories-you-might-have-missed-march-12-2025?utm_source=openai"
                        }
                    }
                ]
            },
            "finish_reason": "stop"
        }
 ]

```

<br>

### User location

To enhance search relevance based on geographic location, you can provide an approximate user location using details such as country, city, region, or timezone.
- **City and Region:** These are open-text fields where you can input values like *San Francisco* for the city and *California* for the region.
- **Country:** This follows the ISO 3166-1 alpha-2 standard, meaning it should be a two-letter country code like *FR* for France or *JP* for Japan.
- **Timezone:** Uses the IANA format, such as *Europe/Paris* or *Asia/Tokyo*, to specify the user's local time zone.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;
  
  TutorialHub.JSONRequestClear;

  //Asynchronous example
  Client.Chat.AsynCreate(
    procedure (Params: TChatParams)
    begin
      Params.Model('gpt-4o-search-preview');
      Params.Messages([
        FromUser('What was a positive news story from today?')
      ]);
      Params.WebSearchOptions(
          TUserLocationApproximate.Create
            .City('London')
            .Country('GB')
            .Region('London')
        );
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynChat
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Chat.Create(
//    procedure (Params: TChatParams)
//    begin
//      Params.Model('gpt-4o-search-preview');
//      Params.Messages([
//        FromUser('What was a positive news story from today?')
//      ]);
//      Params.WebSearchOptions(
//          TUserLocationApproximate.Create
//            .City('London')
//            .Country('GB')
//            .Region('London')
//        );
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

### Search context size

The search_context_size parameter determines how much web context is retrieved to enhance responses. It does not affect the main model's token usage or carry over between interactions—its sole purpose is to generate the tool's reply.

Impact of Context Size:
- **Cost:** Larger contexts are more expensive. See pricing details.
- **Quality:** More context improves accuracy and depth.
- **Latency:** Bigger context means longer processing times.

Available Options:
- ***high*** – Most detailed, highest cost, slower.
- ***medium*** (default) – Balanced cost, speed, and quality.
- ***low*** – Fastest, cheapest, but may reduce accuracy.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;

  //Asynchronous example
  Client.Chat.AsynCreate(
    procedure (Params: TChatParams)
    begin
      Params.Model('gpt-4o-search-preview');
      Params.Messages([
        FromUser('What was a positive news story from today?')
      ]);
      Params.WebSearchOptions('high'); //or TSearchWebOptions.high
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynChat
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Chat.Create(
//    procedure (Params: TChatParams)
//    begin
//      Params.Model('gpt-4o-search-preview');
//      Params.Messages([
//        FromUser('What was a positive news story from today?')
//      ]);
//      Params.WebSearchOptions('high'); //or TSearchWebOptions.high
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

>[!NOTE]
> Context size and localization can be used simultaneously :
> ```Delphi
>    Params.WebSearchOptions(
>      'low',
>      TUserLocationApproximate.Create
>        .City('London')
>        .Country('GB')
>        .Region('London')
>    );
> ```

>[!WARNING]
> Web search can also be used with APIs designed for streaming. However, annotation data is not included in the returned chunks.

<br>

___

## Function calling

Allow models to access data and execute actions. <br/>
Function calling offers a robust and versatile method for OpenAI models to interact with your code or external services, serving two main purposes:

- **Data Retrieval:** Access real-time information to enhance the model's responses (RAG). This is particularly beneficial for searching knowledge bases and extracting specific data from APIs (e.g., obtaining the current weather).

- **Action Execution:** Carry out tasks such as form submissions, API calls, updating the application state (UI/frontend or backend), or executing agent-driven workflows (e.g., transferring a conversation).

Refer to the [official documentation](https://platform.openai.com/docs/guides/function-calling?example=get-weather).

<br/>

#### How build a plugin

Use case : **What’s the weather in Paris?**

In the `GenAI.Functions.Example` unit, there is a class that defines a function which OpenAI can choose to use or not, depending on the options provided. This class inherits from a parent class defined in the `GenAI.Functions.Core` unit. To create new functions, you can derive from the `TFunctionCore` class and define a new plugin.

#### Use a schema

In this unit, this schema will be used for function calls.
```Json
{
    "type": "object",
    "properties": {
         "location": {
             "type": "string",
             "description": "The city and department, e.g. Marseille, 13"
         },
         "unit": {
             "type": "string",
             "enum": ["celsius", "fahrenheit"]
         }
     },
     "required": ["location"],
     "additionalProperties": false
}
```

<br/>

We will use the TWeatherReportFunction plugin defined in the `GenAI.Functions.Example` unit.

```Delphi
  var Weather := TWeatherReportFunction.CreateInstance;
  //or
  var Weather := TWeatherReportFunction.CreateInstance(True);  //To activate `Strict` option

  //See step : Main method
```
<br/>

#### Methods to display result

We then define a method to display the result of the query using the Weather tool.

With this tutorial, a method is defined within TutorialHub. Let’s take a closer look at how this method works.

##### Display a stream text

```Delphi
procedure TVCLTutorialHub.DisplayWeatherStream(const Value: string);
begin
  //Asynchronous example
  Client.Chat.AsynCreateStream(
    procedure(Params: TChatParams)
    begin
      Params.Model('gpt-4o');
      Params.Messages([
          FromSystem('You are a weather presenter on a prime time TV channel.'),
          FromUser(Value)]);
      Params.MaxCompletionTokens(1024);
      Params.Stream;
    end,
    function : TAsynChatStream
    begin
      Result.Sender := TutorialHub;
      Result.OnProgress := DisplayStream;
      Result.OnError := Display;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
    end);
end;
```

<br/>

##### Use audio with response

```Delphi
procedure TVCLTutorialHub.DisplayWeatherAudio(const Value: string);
begin
  FileName := 'AudioWeather.mp3';

  //Asynchronous example
  Client.Chat.AsynCreate(
    procedure (Params: TChatParams)
    begin
      Params.Model('gpt-4o-audio-preview');
      Params.Modalities(['text', 'audio']);
      Params.Audio('verse', 'mp3');
      Params.Messages([
        FromSystem('You are a weather presenter on a prime time TV channel.'),
        FromUser(Value)
      ]);
      Params.MaxCompletionTokens(1024);
    end,
    function : TAsynChat
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := DisplayAudio;
      Result.OnError := Display;
    end);
end;
```

<br/>

#### Main method

Building the query using the Weather tool. (Simply copy/paste this last code to test the usage of the functions.)

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL, GenAI.Functions.Example;

  TutorialHub.JSONRequestClear;
  var Weather := TWeatherReportFunction.CreateInstance(False);
//  TutorialHub.ToolCall := TutorialHub.DisplayWeatherStream;
// or
  TutorialHub.ToolCall := TutorialHub.DisplayWeatherAudio;
  TutorialHub.Tool := Weather;

  //Synchronous example
  var Value := Client.Chat.Create(
    procedure (Params: TChatParams)
    begin
      Params.Model('gpt-4o');
      Params.Messages([
        FromUser('What is the weather in Paris?')
      ]);
      Params.Tools([Weather]);
      Params.ToolChoice(TToolChoice.auto);
      Params.MaxCompletionTokens(1024);
      TutorialHub.JSONRequest := Params.ToFormat();
    end);
  try
    Display(TutorialHub, Value);
  finally
    Value.Free;
  end;
```

#### FinishReason

Let's look at how the display method handles the function call.

```Delphi
procedure Display(Sender: TObject; Value: TChat);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Choices do
    {--- Examine FinishReason }
    if Item.FinishReason = TFinishReason.tool_calls then
      begin
        if Assigned(TutorialHub.ToolCall) then
          begin
            for var Func in Item.Message.ToolCalls do
              begin
                Display(Sender, Func.&function.Arguments);
                var Evaluation := TutorialHub.Tool.Execute(Func.&function.Arguments);
                Display(Sender, Evaluation);
                Display(Sender);
                TutorialHub.ToolCall(Evaluation);
              end;
          end;
      end
    else
      begin
        Display(Sender, Item.Message.Content);
      end;
  Display(Sender, sLineBreak);
end;
```

<br/>

>[!WARNING]
>Ensure user confirmation for actions like sending emails or making purchases to avoid unintended consequences.

<br/>


Maintenant le fichier avec la documentation du point de terminaison v1/response que l'on trouve à cette adresse : https://github.com/MaxiDonkey/DelphiGenAI/blob/main/Responses.md

Remarque: D'ailleurs il faut privilégier ce point de terminaison car c'est le plus récent, le plus complet et le plus adapté à l'approche agentic. Il faut donc construire des exemples exploitant ce point de terminaison bien avant v1/chat/completion et surtout v1/completion qui lui est legacy.

# Responses

- [Text generation](#text-generation)
    - [Non streamed](#non-streamed) 
    - [Streamed](#streamed)
    - [Multi-turn conversations](#multi-turn-conversations) 
    - [Parallel method for generating text](#parallel-method-for-generating-text)
    - [CRUD operations on saved responses](#crud-operations-on-saved-responses)
        - [Get a model response](#get-a-model-response)
        - [Delete a model response](#delete-a-model-response)
        - [List input items](#list-input-items)
- [Vision](#vision)
    - [Analyze single source](#analyze-single-source)
    - [Analyze multi-source](#analyze-multi-source)
    - [Low or high fidelity image understanding](#low-or-high-fidelity-image-understanding)
- [PDF file inputs](#pdf-file-inputs)
- [Reasoning with o1, o3 or o4](#reasoning-with-o1-o3-or-o4)
- [Web search](#web-search)
    - [User location](#user-location)
    - [Web_search code exemple](#web-search-code-exemple)
    - [Limitations](#limitations)
- [File search](#file-search)
- [Function calling](#function-calling)

<br>

___

## Text generation

This interface represents OpenAI’s most advanced environment for driving model-generated responses. It supports both text and image inputs and outputs, and enables chaining interactions by automatically feeding the results of one turn back into the next. A suite of built-in tools (file exploration, web searches, system command execution, etc.) enhances the model’s capabilities. Additionally, function calls allow access to external systems and data to enrich interactions. Note: if the `store` parameter is not specified in the request, its default value is `true`.

### Non streamed

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

    TutorialHub.JSONRequestClear;

  //Asynchronous example
  Client.Responses.AsynCreate(
    procedure (Params: TResponsesParams)
    begin
      Params.Model('gpt-4.1-mini');
      Params.Input('What is the difference between a mathematician and a physicist?');
      //Params.Store(False);  // Response not stored
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynResponse
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess :=
        procedure (Sender: TObject; Response: TResponse)
        begin
          Display(Sender, Response);
          Ids.Add(Response.Id);
        end;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Responses.Create(
//    procedure (Params: TResponsesParams)
//    begin
//      Params.Model('gpt-4.1-mini');
//      Params.Input('What is the difference between a mathematician and a physicist?');
//      //Params.Store(False);  // Response not stored
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

>[!IMPORTANT]
> - Param.store to store the response (Refer to [CRUD section](#crud-operations-on-saved-chat-completions)) 
> - Stored response can be retrieved from the [Plateform Dashboard](https://platform.openai.com/logs?api=responses)

<br>

By using the GenAI.Tutorial.VCL unit along with the initialization described [above](#Strategies-for-quickly-using-the-code-examples), you can achieve results similar to the example shown below.

![Preview](/../main/images/GenAIResponseRequest.png?raw=true "Preview")

<br>

### Streamed

When you create a Response with `stream` set to `true`, the server will emit server-sent events to the client as the Response is generated. This section contains the events that are emitted by the server. [Learn more.](https://platform.openai.com/docs/guides/streaming-responses?api-mode=responses)

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;

  //Asynchronous example
  Client.Responses.AsynCreateStream(
    procedure(Params: TResponsesParams)
    begin
      Params.Model('gpt-4.1-nano');
      Params.Input('What is the difference between a mathematician and a physicist?');
      //Params.Store(False);  // Response not stored
      Params.Stream;
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynResponseStream
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnProgress := DisplayStream;
      Result.OnError := Display;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
    end);

  //Synchronous example
//  Client.Responses.CreateStream(
//    procedure (Params: TResponsesParams)
//    begin
//      Params.Model('gpt-4.1-nano');
//      Params.Input('What is the difference between a mathematician and a physicist?');
//      //Params.Store(False);  // Response not stored
//      Params.Stream;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    procedure (var Chat: TResponseStream; IsDone: Boolean; var Cancel: Boolean)
//    begin
//      if (not IsDone) and Assigned(Chat) then
//        begin
//          DisplayStream(TutorialHub, Chat);
//        end;
//    end);
```

![Preview](/../main/images/GenAIResponseStreamedRequest.png?raw=true "Preview")

<br>


### Multi-turn conversations

The `GenAI Response API` enables the creation of interactive chat experiences tailored to your users' needs. Its chat functionality supports multiple rounds of questions and answers, allowing users to gradually work toward solutions or receive help with complex, multi-step issues. This capability is especially useful for applications requiring ongoing interaction, such as:

- **Chatbots**
- **Educational tools**
- **Customer support assistants**

APIs automate the handling of conversation history, so you don’t have to manually resend messages at every step.

To include the context from earlier responses, use the `previous_response_id` parameter. It lets you link messages together and keep the conversation flowing.

Refer to the [official documentation](https://platform.openai.com/docs/guides/conversation-state?api-mode=responses).

In the example below, we assume that one of the previous requests (streamed or non‑streamed) was executed with `store` set to `True`. Once the call completes, the response ID is returned (for example: `resp_67ffb72044648191b4faddb8254c79cf002f1563a5487ec4`). You then simply assign this value to the `PreviousResponseId` field when preparing the next conversation turn, as shown in the following code snippet:

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  //Asynchronous example
  Client.Responses.AsynCreate(
    procedure (Params: TResponsesParams)
    begin
      Params.Model('gpt-4.1-mini');
      Params.Input('question : second tour');
      Params.PreviousResponseId('resp_67ffb72044648191b4faddb8254c79cf002f1563a5487ec4');
      Params.Store(False);
    end 
  ...
```

Simply include the previous response’s ID with each turn. Thanks to CRUD operations, retrieving, processing, and deleting saved responses is straightforward. For more details, see the [CRUD operations on saved Responses](#crud-operations-on-saved-responses).

<br>

### Parallel method for generating text

This approach enables the simultaneous execution of multiple prompts, provided they are all processed by the same model. It also supports parallel web requests.

#### Example 1 : Two prompts processed in parallel.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  Client.Responses.CreateParallel(
    procedure (Params: TBundleParams)
    begin
      Params.Prompts([
        'How many television channels were there in France in 1980?',
        'How many TV channels were there in Germany in 1980?.'
      ]);
      Params.System('Write the response in capital letters.');
      Params.Model('gpt-4.1-mini');
    end,
    function : TAsynBundleList
    begin
      Result.Sender := TutorialHub;

      Result.OnStart :=
        procedure (Sender: TObject)
        begin
          Display(Sender, 'Start the job' + sLineBreak);
        end;

      Result.OnSuccess :=
        procedure (Sender: TObject; Bundle: TBundleList)
        begin
          // Background bundle processing
          for var Item in Bundle.Items do
            begin
              Display(Sender, 'Index : ' + Item.Index.ToString);
              Display(Sender, 'FinishIndex : ' + Item.FinishIndex.ToString);
              Display(Sender, Item.Prompt + sLineBreak);
              Display(Sender, Item.Response + sLineBreak + sLineBreak);
               // or Display(Sender, TResponse(Item.Chat).Output[0].Content[0].Text);
            end;
        end;

      Result.OnError := Display;
    end)
```


You can also use reasoning models in parallel processing: <br> 

```Delphi
...
   Params.Prompts([
        'How many television channels were there in France in 1980?',
        'How many TV channels were there in Germany in 1980?.'
      ]);
      Params.Model('o4-mini');
      Params.ReasoningEffort('high');
    end,
...
```

<br>

#### Example 2 : Three web search processed in parallel.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  Client.Chat.CreateParallel(
    procedure (Params: TBundleParams)
    begin
      Params.Prompts([
        'What is the current date and time in Paris, France?',
        'What''s the news in the USA today?',
        'What''s new in Berlin today?'
      ]);
      Params.Model('gpt-4.1-mini');
      Params.SearchSize('medium');
      Params.Country('FR');
      Params.City('Reims');
    end,
    function : TAsynBundleList
    begin
      Result.Sender := TutorialHub;

      Result.OnStart :=
        procedure (Sender: TObject)
        begin
          Display(Sender, 'Start the job' + sLineBreak);
        end;

      Result.OnSuccess :=
        procedure (Sender: TObject; Bundle: TBundleList)
        begin
          // Background bundle processing
          for var Item in Bundle.Items do
            begin
              Display(Sender, 'Index : ' + Item.Index.ToString);
              Display(Sender, 'FinishIndex : ' + Item.FinishIndex.ToString);
              Display(Sender, Item.Prompt + sLineBreak);
              Display(Sender, Item.Response + sLineBreak + sLineBreak);
              // or Display(Sender, TResponse(Item.Chat).Output[0].Content[0].Text);
            end;
        end;

      Result.OnError := Display;
    end)
```

To perform a web search, use the `gpt-4.1` or `gpt-4.1-mini` models with the `responses` endpoint. However, web search is not supported with these models when using the `chat/completion` endpoint; in that case, you should use the `gpt-4o-search-preview` model. Lastly, the `gpt-4.1-nano` model does not support web search, regardless of the endpoint used.

<br>
 
### CRUD operations on saved responses

>
>CRUD = `C`reate `R`ead `U`pdate `D`elete
>

#### Why CRUD on Responses ?

- **Traceability and Auditing:**  Being able to save, update, and delete responses directly from your wrapper makes it easier to manage the conversation history on both the client and server sides.

- **Business Scenarios:** For example, in a support assistant integrated into a Delphi application, it’s a real advantage to have an identifier—and the ability to correct or annotate—each generated response.


<br>

#### Get a model response

Retrieves a model response with the given ID. Refer to the [official documentation.](https://platform.openai.com/docs/api-reference/responses/get)

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;

  //Asynchronous example
  Client.Responses.AsynRetrieve('Response_ID',
    function : TAsynResponse
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Responses.Retrieve('Response_ID');
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

#### Delete a model response

Deletes a model response with the given ID. Refer to the [official documentation.](https://platform.openai.com/docs/api-reference/responses/delete)

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;

  Client.Responses.AsynDelete('Response_ID',
    function : TAsynResponseDelete
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Responses.Delete('Response_ID');
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

#### List input items

Returns a list of input items for a given response. Refer to the [official documentation.](https://platform.openai.com/docs/api-reference/responses/input-items)

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;

  //Asynchronous example
  Client.Responses.AsynList('Response_ID',
    procedure (Params: TUrlResponseListParams)
    begin
      Params.Order('asc');
      Params.Limit(15);
    end,
    function : TAsynResponses
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end
  );

  //Synchronous example
//  var Value := Client.Responses.List('Response_ID',
//    procedure (Params: TUrlResponseListParams)
//    begin
//      Params.Limit(50);
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br>

___

## Vision

Refer to the [official documentation](https://platform.openai.com/docs/guides/vision).

<br>

### Analyze single source

`GenAI` processes images from both web sources and local files uniformly. It manages the submission of the source to the API, thereby simplifying the developer's task. Therefore, in this example, we will handle sources in the form of a ***URL*** and ***base-64 encoded*** data.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;
   var Url := 'https://upload.wikimedia.org/wikipedia/commons/thumb/d/dd/Gfp-wisconsin-madison-the-nature-boardwalk.jpg/2560px-Gfp-wisconsin-madison-the-nature-boardwalk.jpg';
  //var Ref := 'D:\My_folder\Images\My_image.png'; //This content will be encoded in base-64 by GenAI

  //Asynchronous example
  Client.Responses.AsynCreateStream(
    procedure (Params: TResponsesParams)
    begin
      Params.Model('gpt-4.1-mini');
      Params.Input('What is in this image?', [Url]);
     // Params.Input('What is in this image?', [Ref]);
      Params.Store(False);
      Params.Stream;
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynResponseStream
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnProgress := DisplayStream;
      Result.OnError := Display;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
    end);

  //Synchronous example
//  var Value := Client.Responses.CreateStream(
//      procedure (Params: TResponsesParams)
//      begin
//        Params.Model('gpt-4.1-mini');
//        Params.Input('What is in this image?', [Url]);
//        // Params.Input('What is in this image?', [Ref]);
//        Params.Store(False);
//        Params.Stream;
//        TutorialHub.JSONRequest := Params.ToFormat();
//      end,
//      procedure (var Chat: TResponseStream; IsDone: Boolean; var Cancel: Boolean)
//      begin
//        if (not IsDone) and Assigned(Chat) then
//          begin
//            DisplayStream(TutorialHub, Chat);
//          end;
//      end);
```
This example uses streaming. The non-streamed version is straightforward to implement, so it is not covered here.

<br>

### Analyze multi-source

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;
  var Ref1 := 'https://tripfixers.com/wp-content/uploads/2019/11/eiffel-tower-with-snow.jpeg';
  var Ref2 := 'https://cdn.pixabay.com/photo/2015/10/06/18/26/eiffel-tower-975004_1280.jpg';

  //Asynchronous example
  Client.Responses.AsynCreateStream(
    procedure (Params: TResponsesParams)
    begin
      Params.Model('gpt-4.1-mini');
      Params.Input('Compare images', [Ref1, Ref2]);
      Params.Store(False);
      Params.Stream;
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynResponseStream
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnProgress := DisplayStream;
      Result.OnError := Display;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
    end);

  //Synchronous example
//  var Value := Client.Responses.CreateStream(
//      procedure (Params: TResponsesParams)
//      begin
//        Params.Model('gpt-4.1-mini');
//        Params.Input('Compare les images', [Ref1, Ref2]);
//        Params.Store(False);
//        Params.Stream;
//        TutorialHub.JSONRequest := Params.ToFormat();
//      end,
//      procedure (var Chat: TResponseStream; IsDone: Boolean; var Cancel: Boolean)
//      begin
//        if (not IsDone) and Assigned(Chat) then
//          begin
//            DisplayStream(TutorialHub, Chat);
//          end;
//      end);
```

<br>

### Low or high fidelity image understanding

The detail parameter, which includes three options—**low**, **high**, and **auto**—allows you to customize how the model interprets the image and generates its textual representation. By default, the **auto** setting is applied, where the model evaluates the input image size and automatically selects either the **low** or **high** mode.

- **low mode** activates "low resolution" processing, where the model works with a 512px x 512px version of the image, represented using 85 tokens. This option is ideal for applications where speed and efficiency are prioritized over high detail, as it reduces response time and token consumption.

- **high mode** activates "high resolution" processing. Initially, the model examines the low-resolution image using 85 tokens, then refines its understanding by analyzing detailed segments of the image, dedicating 170 tokens per 512px x 512px tile. This mode is suited for cases requiring precise image details.

`GenAI` allows the addition of `detail=high` or `detail=low` directly in the URL, thereby simplifying the activation of the detail option as follows:

```Delphi
  var Url1 := 'https://tripfixers.com/.../eiffel-tower-with-snow.jpeg detail=high';
  //or
  var Url1 := 'https://tripfixers.com/.../eiffel-tower-with-snow.jpeg detail=low';
```

<br>

___

## PDF file inputs

OpenAI models with vision capabilities can process PDF files as input. These files can be submitted either as Base64-encoded data or by using a file ID obtained after uploading the file via the dashboard or the `/v1/files` endpoint of the API. [Refer to file upload](https://github.com/MaxiDonkey/DelphiGenAI?tab=readme-ov-file#file-upload)

How it works
To help models understand the content of a PDF, each page is represented both as extracted text and as an image. These two formats are included in the model's context, allowing it to use both visual and textual information to generate responses. This is especially useful when important details—such as those found in diagrams or charts—are not present in the text alone.

Refer to the [official documentation](https://platform.openai.com/docs/guides/pdf-files)

However, with GenAI, it is possible to directly provide a local path or a URL pointing to the PDF files to be analyzed.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;
  var Ref := 'http://www.mysite.com/my_file.pdf';
//  var Ref := 'D:\my_folder\my_file.pdf';

  //Asynchronous example
  Client.Responses.AsynCreateStream(
    procedure (Params: TResponsesParams)
    begin
      Params.Model('gpt-4.1-mini');
      Params.Input('Summarize the document', [Ref]); 
      Params.Store(False);
      Params.Stream;
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynResponseStream
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnProgress := DisplayStream;
      Result.OnError := Display;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
    end);

  //Synchronous example
//  var Value := Client.Responses.CreateStream(
//      procedure (Params: TResponsesParams)
//      begin
//        Params.Model('gpt-4.1-mini');
//        Params.Input('Summarize the document', [Ref]);
//        Params.Store(False);
//        Params.Stream;
//        TutorialHub.JSONRequest := Params.ToFormat();
//      end,
//      procedure (var Response: TResponseStream; IsDone: Boolean; var Cancel: Boolean)
//      begin
//        if (not IsDone) and Assigned(Response) then
//          begin
//            DisplayStream(TutorialHub, Response);
//          end;
//      end);
```
You can also submit multiple PDF files at once to perform analysis across a group of documents.

**File Size Limitations**
The API allows up to 100 pages and a total of 32MB per request, even when multiple files are included.

**Supported Models**
Only models that can handle both text and image inputs—such as gpt-4o, gpt-4o-mini, or o1—are able to accept PDF files as input. You can check the available model features [here].


<br>

>[!NOTE]
>It is possible to submit both image files and PDF documents simultaneously for a unified analysis.

<br>
___

## Reasoning with o1, o3 or o4

**Advanced models for reasoning and problem-solving.**
Reasoning models, such as **OpenAI’s** `o1`, `o3` `o4-mini`, are large language models trained using reinforcement learning to handle complex reasoning tasks. These models “think” before generating a response by forming a detailed internal chain of reasoning. This approach allows them to excel in areas like advanced problem-solving, coding, scientific analysis, and multi-step planning within agent-driven workflows.

Similar to GPT models, they offer two options: a smaller, faster, and more cost-effective model (`o4-mini`) and a larger model (`o1`, `o3`) that, while slower and more expensive per token, often produces higher-quality responses for challenging tasks and demonstrates stronger generalization across various domains.

Since these models can require response times ranging from a few seconds to several tens of seconds, it is more prudent and efficient to use asynchronous methods when using them.


```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;

 //Asynchronous example
  Client.Responses.AsynCreateStream(
    procedure (Params: TResponsesParams)
    begin
      Params.Model('o4-mini');
      Params.Instructions('You are an expert in bash script.');
      Params.Input('Write a bash script that takes a matrix represented as a string with format \"[1,2],[3,4],[5,6]\" and prints the transpose in the same format.');
      //Simplified
      Params.Reasoning('high' );
      //or deailled
      //Params.Reasoning(
      //  TReasoningParams.New.Effort('high').Summary('concise')
      //);
      Params.Stream;
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynResponseStream
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnProgress := DisplayStream;
      Result.OnError := Display;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
    end);tion := Cancellation;
    end);
```

<br>

The OpenAI `o1`, `o3` and `o4` series models are highly capable across several advanced tasks, including:

- **Implementing complex algorithms and generating code:** For example, a prompt can instruct the o1 model to refactor a React component based on specific requirements.

- **Developing multi-step plans:** The models can create detailed plans, such as generating a complete filesystem structure and providing Python code that fulfills the given use case.

- **Supporting STEM research:** The models have demonstrated strong performance in scientific and technical research tasks, with prompts designed for basic research yielding highly effective results.

For more information, consult the [official documentation](https://platform.openai.com/docs/guides/reasoning).

<br>

___

## Web search

[The official documentation.](https://platform.openai.com/docs/guides/tools-web-search?api-mode=responses#user-location)

Models can be given access to real-time web data to enhance the relevance and accuracy of their responses.
To enable this capability, you can configure the web search function within the tools array of your API request when generating content through the Responses API. The model will then determine—based on the input prompt—whether or not it needs to perform an online search, just as it would with any other available tool.

If you want to ensure the model uses the web search function, you can enforce this behavior by setting the tool_choice parameter to `{type: "web_search_preview"}`. This can help deliver faster and more predictable results.

```Delphi
  procedure(Params: TResponsesParams)
    begin
      Params.Model('gpt-4.1-mini');
      ....
      Params.Tools([web_search_preview('high')]);
      ... 
```

<br>

### User location

To fine‑tune search results by geography, you can supply an approximate location for the user—country, city, region, and/or time zone.
- **City and region:** free‑text fields where you enter any string (e.g., Minneapolis for the city, Minnesota for the region).
- **Country:** a two‑letter ISO code such as US.
- **Time zone:** an IANA identifier like America/Chicago.

```Delphi
  procedure(Params: TResponsesParams)
    begin
      Params.Model('gpt-4.1-mini');
      ....
      Params.Tools([web_search_preview('high').UserLocation(Locate.City('Reims').Country('FR'))]);
      ... 
```

<br>

### Web_search code exemple

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;

  //Asynchronous example
  Client.Responses.AsynCreateStream(
    procedure(Params: TResponsesParams)
    begin
      Params.Model('gpt-4.1-mini');
      Params.Input('What are the cultural news in France today?');
      Params.Tools([web_search_preview('high').UserLocation(Locate.City('Reims').Country('FR'))]); //Search context size : one of low, medium or High
      Params.Store(False);
      Params.Stream;
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynResponseStream
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnProgress := DisplayStream;
      Result.OnError := Display;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
    end);

  //Synchronous example
//  Client.Responses.CreateStream(
//    procedure (Params: TResponsesParams)
//    begin
//      Params.Model('gpt-4.1');
//      Params.Input('What are the cultural news in France today?');
//      Params.Tools([web_search_preview('high').UserLocation(Locate.City('Reims').Country('FR'))]);
//      Params.Store(False);
//      Params.Stream;
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end,
//    procedure (var Response: TResponseStream; IsDone: Boolean; var Cancel: Boolean)
//    begin
//      if (not IsDone) and Assigned(Response) then
//        begin
//          DisplayStream(TutorialHub, Response);
//        end;
//    end);
```

<br>

### Limitations

Here are the key points to know before using the web search feature:
- **Model Compatibility :** The `gpt-4.1-nano` model does not support web search.
- **“Search‑Preview” Variant Restrictions :** 
    - The `gpt-4o-search-preview` and `gpt-4o-mini-search-preview` models, available in the Chat Completions API, only accept a subset of the usual parameters.
    - Check each model’s spec sheet for its rate limits and supported features.
- **Rate Limits in the Responses API :** When web search is used as a tool via the Responses API, it adheres to the same rate‑limit tiers as the ***search‑preview*** models mentioned above. 
- **Maximum Context Size :** The context window for web search is capped at ***128,000 tokens***, even when using the `gpt-4.1` and `gpt-4.1-mini` models.
- **Data Handling :** For details on data processing, residency, and retention, refer to the [dedicated guide](https://platform.openai.com/docs/guides/your-data).

<br>

___

## File search

### Let your models query your own files before generating a response

#### 1. Overview

The Responses API includes a document‑search tool that lets the model draw—prior to answering—from a knowledge base made up of files you have previously uploaded. This search blends both keyword matching and semantic retrieval within a vector database.

#### 2. How it works

- **Create a vector database**  
        - Build a vector store and upload your documents. Refer to [Files upload](https://github.com/MaxiDonkey/DelphiGenAI?tab=readme-ov-file#file-upload), [vector store](https://github.com/MaxiDonkey/DelphiGenAI/blob/main/BeyondBasics.md#vector-store) and [vector store file.](https://github.com/MaxiDonkey/DelphiGenAI/blob/main/BeyondBasics.md#vector-store-files) <br>
        - These files expand the model’s built‑in knowledge, allowing it to rely on your private sources. 

- **Model‑triggered retrieval**  
        - When the model decides it’s helpful to consult your base, it automatically calls the tool. <br>
        - The tool then queries the vector database, fetches the relevant passages, and returns them to the model, which weaves them into its reply. 

- **No infrastructure to manage**  
       - The tool is fully hosted and managed by OpenAI, so no additional code is required on your end.

#### 3. Learn more

Want a deeper dive into vector storage and semantic search? See our Information [Retrieval Guide.](https://platform.openai.com/docs/guides/retrieval)

<br>

#### 4. Use case

To demonstrate how this tool works, we will create a vector store from a PDF file, which will then be accessed via the `/responses` endpoint.
This approach allows the model to be enriched with specific information, thereby enhancing the relevance and contextual accuracy of the responses it generates.
In other words, it enables the model’s behavior to be refined ***without requiring an explicit fine-tuning phase.***

>[!NOTE]
> The PDF file used is written in French. However, thanks to the `file_search` tool, the content can be queried regardless of the document’s language, allowing for efficient multilingual search.

<br>

##### [--STEP 1--] Upload

**Upload the PDF file and retrieve the upload ID.**

The first step is to upload the PDF file, which returns a unique identifier. This `ID` will be used to reference the document in subsequent requests.

The PDF file is located in the sample directory of this repository.
The file is named `File_Search_file.pdf`.

[Supported file by Mime type](https://platform.openai.com/docs/assistants/tools/file-search#supported-files)

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  var Value := Client.Files.Upload(
    procedure (Params: TFileUploadParams)
    begin
      Params.&File('File_Search_file.pdf');
      Params.Purpose(TFilesPurpose.user_data);
    end);
  try
    File_ID := Value.Id; //Retrieving the ID and then providing it to the file vector store
  finally
    Value.Free;
  end;
```

Result
```Json
{
    "object": "file",
    "id": "file-WNEwgxSLvUgXMk56HhyzAY",
    "purpose": "user_data",
    "filename": "File_Search_file.pdf",
    "bytes": 334640,
    "created_at": 1745216687,
    "expires_at": null,
    "status": "processed",
    "status_details": null
}
```

<br>

##### [--STEP 2--] Create store

**We now need to create a vector store and retrieve its ID.**

This step initializes a vector storage space, which will later be used to index the contents of the uploaded PDF file.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  var Value := Client.VectorStore.Create(
    procedure (Params: TVectorStoreCreateParams)
    begin
      Params.Name('PDF Data for the tutorial');
      TutorialHub.JSONRequest := Params.ToFormat();
    end);
  try
    Display(TutorialHub, Value);
  finally
    Value.Free;
  end;
```

Result
```Json
{
    "id": "vs_6805e821210081919a4aabae08c63a14",
    "object": "vector_store",
    "created_at": 1745217569,
    "name": "PDF Data for the tutorial",
    "usage_bytes": 0,
    "file_counts": {
        "in_progress": 0,
        "completed": 0,
        "failed": 0,
        "cancelled": 0,
        "total": 0
    },
    "status": "completed",
    "expires_after": null,
    "expires_at": null,
    "last_active_at": 1745217569,
    "metadata": {
    }
}
```

<br>

##### [--STEP 3--] Link File

To complete the vector store setup, we will now attach the uploaded file to the vector store by providing both the `file ID` and the vector `store ID`.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  var Value := Client.VectorStoreFiles.Create('vs_6805e821210081919a4aabae08c63a14',
    procedure (Params: TVectorStoreFilesCreateParams)
    begin
      Params.FileId('file-WNEwgxSLvUgXMk56HhyzAY');
      TutorialHub.JSONRequest := Params.ToFormat();
    end);
  try
    Display(TutorialHub, Value);
  finally
    Value.Free;
  end;
```

Result
```Json
{
    "id": "file-WNEwgxSLvUgXMk56HhyzAY",
    "object": "vector_store.file",
    "usage_bytes": 0,
    "created_at": 1745218347,
    "vector_store_id": "vs_6805e821210081919a4aabae08c63a14",
    "status": "in_progress",
    "last_error": null,
    "chunking_strategy": {
        "type": "static",
        "static": {
            "max_chunk_size_tokens": 800,
            "chunk_overlap_tokens": 400
        }
    },
    "attributes": {
    }
}
```

<br>

##### [--STEP 4--] Exploit Store

We will now leverage our vector store to allow the model to optionally use the information extracted from the PDF when generating its response.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;

  //Asynchronous example
  Client.Responses.AsynCreateStream(
    procedure(Params: TResponsesParams)
    begin
      Params.Model('gpt-4.1-mini');
      Params.Input('Identify all the conjectures and provide guidance or evidence to support their validation or refutation.');
      Params.Tools([file_search(['vs_6805e821210081919a4aabae08c63a14'])]);
//      Params.ToolChoice(TToolChoice.auto);
//  or   
//      Params.ToolChoice(THostedToolParams.New('file_search'));
      Params.Store(False);
      Params.Stream;
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynResponseStream
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnProgress := DisplayStream;
      Result.OnError := Display;
      Result.OnDoCancel := DoCancellation;
      Result.OnCancellation := Cancellation;
    end);
```

<br>

#### Note 1 : Tool_choice

```Delphi
   Params.ToolChoice(TToolChoice.auto); //none or required
//or
   Params.ToolChoice(THostedToolParams.New('file_search'));  //web_search_preview or  computer_use_preview
```
Refer to the [official documentation](https://platform.openai.com/docs/api-reference/responses/create#responses-create-tool_choice)

<br>

#### Note 2 : Include search results in the response

```Delphi
  Params.Include([TOutputIncluding.file_search_result]);
```

Refer to the [official documentation](https://platform.openai.com/docs/guides/tools-file-search#include-search-results-in-the-response)

<br>

#### 5. Final thoughts

Just like the `search_web` tool, the `file_search` tool stands out for both its precision and its practical value, making it a particularly powerful component.
Moreover, using the `/responses` endpoint proves to be a more effective approach than `/chat/completion`, as it significantly simplifies the integration of tools into queries.
 
We will not cover the `computer_use` tool here, as it requires implementing all the methods to handle the passed actions — a level of complexity that goes beyond the intended scope of this wrapper.

A GitHub repository may be shared in the future if the need to leverage this functionality becomes compelling.

___

## Function calling

Allow models to access data and execute actions. <br/>
Function calling offers a robust and versatile method for OpenAI models to interact with your code or external services, serving two main purposes:

- **Data Retrieval:** Access real-time information to enhance the model's responses (RAG). This is particularly beneficial for searching knowledge bases and extracting specific data from APIs (e.g., obtaining the current weather).

- **Action Execution:** Carry out tasks such as form submissions, API calls, updating the application state (UI/frontend or backend), or executing agent-driven workflows (e.g., transferring a conversation).

Refer to the [official documentation](https://platform.openai.com/docs/guides/function-calling?example=get-weather).

#### How build a plugin

Use case : **What’s the weather in Paris?**

In the `GenAI.Functions.Example` unit, there is a class that defines a function which OpenAI can choose to use or not, depending on the options provided. This class inherits from a parent class defined in the `GenAI.Functions.Core` unit. To create new functions, you can derive from the `TFunctionCore` class and define a new plugin.

#### Use a schema

In this unit, this schema will be used for function calls.
```Json
{
    "type": "object",
    "properties": {
         "location": {
             "type": "string",
             "description": "The city and department, e.g. Marseille, 13"
         },
         "unit": {
             "type": "string",
             "enum": ["celsius", "fahrenheit"]
         }
     },
     "required": ["location"],
     "additionalProperties": false
}
```

<br/>

We will use the TWeatherReportFunction plugin defined in the `GenAI.Functions.Example` unit.

```Delphi
  var Weather := TWeatherReportFunction.CreateInstance;
  //or
  var Weather := TWeatherReportFunction.CreateInstance(True);  //To activate `Strict` option

  //See step : Main method
```
<br/>

#### Methods to display result

Next, we define a method to display the results obtained using the Weather tool.

We will use a method defined in TutorialHub whose purpose is to handle the data returned from the function call; however, this is not the main concept to focus on. For final information processing, we will use only the voice-based method. This method uses the *chat/completion* endpoint, which is perfectly suitable in this context.

However, our primary focus will be on the method that triggers the function call via the `/responses` endpoint.

<br>

#### Main method

Building the query using the Weather tool. (Simply copy/paste this last code to test the usage of the functions.)

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL, GenAI.Functions.Example;
  
  TutorialHub.JSONRequestClear;
  var Weather := TWeatherReportFunction.CreateInstance(False);
//  TutorialHub.ToolCall := TutorialHub.DisplayWeatherStream;
  TutorialHub.ToolCall := TutorialHub.DisplayWeatherAudio;
  TutorialHub.Tool := Weather;

  //Synchronous example
  var Value := Client.Responses.Create(
    procedure (Params: TResponsesParams)
    begin
      Params.Model('gpt-4.1');
      Params.Input('What is the weather in Paris?');
      Params.Tools([TResponseFunctionParams.New(Weather)]);
      Params.ToolChoice(TToolChoice.required);
      TutorialHub.JSONRequest := Params.ToFormat();
    end);
  try
    Display(TutorialHub, Value); //see below
  finally
    Value.Free;
  end;
```

Result
```Json
{
    "id": "resp_6806368aff1c81918a2af800894a5ae405b956e8d8bc9a97",
    "object": "response",
    "created_at": 1745237643,
    "status": "completed",
    "error": null,
    "incomplete_details": null,
    "instructions": null,
    "max_output_tokens": null,
    "model": "gpt-4.1-2025-04-14",
    "output": [
        {
            "id": "fc_6806368b70c88191bf8a10a576d24f1905b956e8d8bc9a97",
            "type": "function_call",
            "status": "completed",
            "arguments": "{\"location\":\"paris\",\"unit\":\"celsius\"}",
            "call_id": "call_eo97T3wRgwvxZhUJ2nTat3jf",
            "name": "get_weather"
        }
...
```

It is important to review the `display(TutorialHub, Value);` method here, as it is responsible for handling the function call.

```Delphi
  procedure Display(Sender: TObject; Value: TResponse);
begin
  TutorialHub.JSONResponse := Value.JSONResponse;
  for var Item in Value.Output do
    begin
      if Item.&Type = TResponseTypes.function_call then  //identifies the request as a function call
        begin
           Display(Sender, Item.Arguments);
           var Evaluation := TutorialHub.Tool.Execute(Item.Arguments);
           Display(Sender, Evaluation);
           Display(Sender);
           TutorialHub.ToolCall(Evaluation);
        end
      else
        begin
          for var SubItem in Item.Content do
            Display(Sender, SubItem.Text);
        end;
    end;
  Display(Sender);
end;
```

<br/>

>[!WARNING]
>Ensure user confirmation for actions like sending emails or making purchases to avoid unintended consequences.

Pour aller plus loin et explorer les fonctionnalités avancées de GenAI avec les options avancées d'OpenAI, nous nous appuierons sur le fichier BeyondBasics.md, disponible à l'adresse suivante : https://github.com/MaxiDonkey/DelphiGenAI/blob/main/BeyondBasics.md


# Beyond the Basics Advanced Usage

- [Uploads](#Uploads)
    - [Upload create](#upload-create)
    - [Upload cancel](#upload-cancel)
    - [Upload add part](#upload-add-part)
    - [Upload complete](#upload-complete)
- [Batch](#batch)
    - [Batch create](#batch-create)
    - [Batch List](#batch-List)
    - [Batch retrieve](#batch-retrieve)
    - [Batch cancel](#batch-cancel)
    - [Batch output viewer](#batch-output-viewer)
- [Fine tuning](#fine-tuning)
    - [Fine tuning create](#fine-tuning-create)
    - [Fine tuning list](#fine-tuning-list)
    - [Fine tuning cancel](#fine-tuning-cancel)
    - [Fine tuning events](#fine-tuning-events)
    - [Fine tuning check point](#fine-tuning-check-point)
    - [Fine tuning retrieve](#fine-tuning-retrieve)
    - [Difference Between Supervised and DPO](#difference-Between-Supervised-and-DPO)
- [Vector store](#vector-store)
    - [Vector store create](#vector-store-create) 
    - [Vector store list](#vector-store-list) 
    - [Vector store retrieve](#vector-store-retrieve) 
    - [Vector store modify](#vector-store-modify) 
    - [Vector store delete](#vector-store-delete) 
- [Vector store files](#vector-store-files)
    - [Vsf create](#vsf-create)
    - [Vsf list](#vsf-list)
    - [Vsf retrieve](#vsf-retrieve)
    - [Vsf delete](#vsf-delete)
- [Vector store batches](#vector-store-batches)
    - [Vsb create](#vsb-create)
    - [Vsb list](#vsb-list)
    - [Vsb retrieve](#vsb-retrieve)
    - [Vsb cancel](#vsb-cancel)
- [Assistants](#assistants)
    - [Create assistant](#create-assistant)
    - [List assistants](#list-assistants)
    - [Retrieve assistant](#retrieve-assistant)
    - [Modify assistant](#modify-assistant)
    - [Delete assistant](#delete-assistant)
- [Threads](#threads)
    - [Create thread](#create-thread)
    - [Retrieve thread](#retrieve-thread)
    - [Modify thread](#modify-thread)
    - [Delete thread](#delete-thread)
- [Messages](#messages)
    - [Create message](#create-message)
    - [List messages](#list-messages)
    - [Retrieve message](#retrieve-message)
    - [Modify message](#modify-message)
    - [Delete message](#delete-message)
- [Runs](#runs)
    - [Create run](#create-run)
    - [Create thread and run](#create-thread-and-run)
    - [List runs](#list-runs)
    - [Retrieve run](#retrieve-run)
    - [Modify run](#modify-run)
    - [Submit tool outputs](#submit-tool-outputs)
    - [Cancel run](#cancel-run)
- [Runs steps](#runs-steps)
    - [List run steps](#list-run-steps)
    - [Retrieve run steps](#retrieve-run-steps)
- [Model distilation](#model-distilation)
___

## Uploads

Allows you to upload large files in multiple parts.

<br/>

### Upload create

An intermediate [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object is created, allowing you to attach multiple [parts](https://platform.openai.com/docs/api-reference/uploads/part-object). The maximum size for an Upload is 8 GB, and it will automatically expire one hour after creation.

Once the Upload is finalized, a [File](https://platform.openai.com/docs/api-reference/files/object) object is generated, incorporating all the uploaded parts. This File object can then be used seamlessly across our platform, functioning like any regular file.

For certain `purposes`, specifying the correct `mime_type` is essential. Be sure to consult the documentation to identify the supported MIME types that suit your use case.

Guidance for [Assistants](https://platform.openai.com/docs/assistants/tools/file-search#supported-files):
For details on selecting the appropriate file extensions for different scenarios, refer to the documentation on [File creation](https://platform.openai.com/docs/api-reference/files/create).

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  //Asynchronous example
  Client.Uploads.AsynCreate(
    procedure (Params: TUploadCreateParams)
    begin
      Params.Purpose('fine-tune');
      Params.Filename('BatchExample.jsonl');
      Params.bytes(FileSize('BatchExample.jsonl'));
      Params.MimeType('text/jsonl');
    end,
    function : TAsynUpload
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Uploads.Create(
//    procedure (Params: TUploadCreateParams)
//    begin
//      Params.Purpose('fine-tune');
//      Params.Filename('BatchExample.jsonl');
//      Params.bytes(FileSize('BatchExample.jsonl'));
//      Params.MimeType('text/jsonl');
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br/>

### Upload cancel

Cancels the Upload. No Parts may be added after an Upload is cancelled.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.Id := 'upload_679207849ec8819086bc0e54f5c66d62';

  //Asynchronous example
  Client.Uploads.AsynCancel(TutorialHub.Id,
    function : TAsynUpload
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Uploads.Cancel(TutorialHub.Id);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br/>

### Upload add part

Adds a [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object. A Part represents a chunk of bytes from the file you are trying to upload.

Each Part can be at most 64 MB, and you can add Parts until you hit the Upload maximum of 8 GB.

It is possible to add multiple Parts in parallel. You can decide the intended order of the Parts when you [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.Id := 'upload_679207849ec8819086bc0e54f5c66d62';

  //Asynchronous example
  Client.Uploads.AsynAddPart(TutorialHub.Id,
    procedure (Params: TUploadPartParams)
    begin
      Params.Data('BatchExample.jsonl');
    end,
    function : TAsynUploadPart
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Asynchronous example
//  var Value := Client.Uploads.AddPart(TutorialHub.Id,
//    procedure (Params: TUploadPartParams)
//    begin
//      Params.Data('BatchExample.jsonl');
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br/>

### Upload complete

Completes the [Upload](https://platform.openai.com/docs/api-reference/uploads/object).

Within the returned Upload object, there is a nested [File](https://platform.openai.com/docs/api-reference/files/object) object that is ready to use in the rest of the platform.

You can specify the order of the Parts by passing in an ordered list of the Part IDs.

The number of bytes uploaded upon completion must match the number of bytes initially specified when creating the Upload object. No Parts may be added after an Upload is completed.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.Id := 'upload_679207849ec8819086bc0e54f5c66d62';

  //Asynchronous example
  Client.Uploads.AsynComplete(TutorialHub.Id,
    procedure (Params: TUploadCompleteParams)
    begin
      Params.PartIds(['BatchExample.jsonl'])
    end,
    function : TAsynUpload
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Asynchronous example
//  var Value := Client.Uploads.Complete(TutorialHub.Id,
//    procedure (Params: TUploadCompleteParams)
//    begin
//      Params.PartIds(['BatchExample.jsonl'])
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br/>

___

## Batch

Create large batches of API requests for asynchronous processing. The Batch API returns completions within 24 hours for a 50% discount. Related guide: [Batch](https://platform.openai.com/docs/guides/batch)

<br/>

### Batch create

Creates and executes a batch from an uploaded file of requests.

For our example, the contents of the batch JSONL file are as follows :

BatchExample.jsonl
```JSON
{"custom_id": "request-1", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o-mini", "messages": [{"role": "system", "content": "You are a helpful assistant."}, {"role": "user", "content": "What is 2+2?"}]}}
{"custom_id": "request-2", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4o-mini", "messages": [{"role": "system", "content": "You are a helpful assistant."}, {"role": "user", "content": "What is the topology definition?"}]}}
```

Use the [File upload](#File-upload) method and get the ID referring to the JSONL file.

<br/>

Now create the batch as follow :

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.Id := '...id of BatchExample.jsonl...';

 {--- If needed, then create metadata }
  var MetaData := TJSONObject.Create
    .AddPair('customer_id', 'user_123456789')
    .AddPair('batch_description', 'Nightly eval job');

  //Asynchronous example
  Client.Batch.AsynCreate(
    procedure (Params: TBatchCreateParams)
    begin
      Params.InputFileId(TutorialHub.Id);
      Params.Endpoint('/v1/chat/completions');
      Params.CompletionWindow('24h');
      Params.Metadata(MetaData);
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynBatch
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);


  //Synchronous example
//  var Value := Client.Batch.Create(
//    procedure (Params: TBatchCreateParams)
//    begin
//      Params.InputFileId(TutorialHub.Id);
//      Params.Endpoint('/v1/chat/completions');
//      Params.CompletionWindow('24h');
//      Params.Metadata(MetaData);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

>[!TIP]
> `GenAI` provides, through the `IBatchJSONBuilder` interface (available in the `GenAI.Batch.Interfaces` unit and implemented in the `GenAI.Batch.Builder` unit), powerful tools to easily build batch files from collected data. For further details, refer to the two units mentioned above.


<br/>

### Batch List

List your organization's batches.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  //Asynchronous example
  Client.Batch.AsynList(
    procedure (Params: TUrlPaginationParams)
    begin
      Params.Limit(4);
    end,
    function : TAsynBatches
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Batch.List(
//    procedure (Params: TUrlPaginationParams)
//    begin
//      Params.Limit(4);
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

With out request parameters

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  //Asynchronous example
  Client.Batch.AsynList(
    function : TAsynBatches
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Batch.List;
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

Refer to [parameters documentation](https://platform.openai.com/docs/api-reference/batch/list).

<br/>

### Batch retrieve

Retrieves a batch using its ID.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.Id := '...Id of batch to retrieve...';

  //Asynchronous example
  Client.Batch.AsynRetrieve(TutorialHub.Id,
    function : TAsynBatch
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Batch.Retrieve(TutorialHub.Id);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br/>

### Batch cancel

Cancels an in-progress batch. The batch will be in status `cancelling` for up to 10 minutes, before changing to `cancelled`, where it will have partial results (if any) available in the output file.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.Id := '...Id of batch to cancel...';

  //Asynchronous example
  Client.Batch.AsynCancel(TutorialHub.Id,
    function : TAsynBatch
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Batch.Cancel(TutorialHub.Id);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br/>

### Batch output viewer

Open and view the results obtained after processing the batch.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.Id := '...Id of batch...';
  var Output := EmptyStr;

  var Value := Client.Files.RetrieveContent(TutorialHub.Id);
  try
    Output := Value.Content;
  finally
    Value.Free;
  end;

  for var Item in JSONLChatReader.Deserialize(Output) do
    try
      Display(TutorialHub, Item.Response.Body);
    finally
      Item.Free;
    end;
```

>[!TIP]
> `GenAI` provides, through the `IJSONLReader` interface (available in the `GenAI.Batch.Interfaces` unit and implemented in the `GenAI.Batch.Reader` unit), powerful tools to easily read batch files content. For further details, refer to the two units mentioned above.

<br/>

___

## Fine tuning

Handle fine-tuning tasks to customize a model according to your specific training dataset. Relevant guide: [Model fine-tuning](https://platform.openai.com/docs/guides/fine-tuning).

After determining that fine-tuning is the appropriate approach (meaning you’ve already optimized your prompt to its full potential and identified remaining issues with the model), the next step is to prepare the training data. You’ll need to create a varied collection of sample conversations that resemble the types of interactions the model will handle during inference in production.

<br/>

### Fine tuning create

#### Preparing your dataset

Each data sample should follow the format used by the ***Chat Completions API***, consisting of a list of messages where each message includes a role, content, and an optional name. Some of these training examples should specifically address situations where the current model's responses are inadequate, with the assistant messages in the dataset reflecting the ideal outcomes you want the model to generate.

Example format

```JSON
{"messages": [{"role": "system", "content": "Marv is a factual chatbot that is also sarcastic."}, {"role": "user", "content": "What's the capital of France?"}, {"role": "assistant", "content": "Paris, as if everyone doesn't know that already."}]}
{"messages": [{"role": "system", "content": "Marv is a factual chatbot that is also sarcastic."}, {"role": "user", "content": "Who wrote 'Romeo and Juliet'?"}, {"role": "assistant", "content": "Oh, just some guy named William Shakespeare. Ever heard of him?"}]}
{"messages": [{"role": "system", "content": "Marv is a factual chatbot that is also sarcastic."}, {"role": "user", "content": "How far is the Moon from Earth?"}, {"role": "assistant", "content": "Around 384,400 kilometers. Give or take a few, like that really matters."}]}
```

Multi-turn chat examples

```JSON
{"messages": [{"role": "system", "content": "Marv is a factual chatbot that is also sarcastic."}, {"role": "user", "content": "What's the capital of France?"}, {"role": "assistant", "content": "Paris", "weight": 0}, {"role": "user", "content": "Can you be more sarcastic?"}, {"role": "assistant", "content": "Paris, as if everyone doesn't know that already.", "weight": 1}]}
{"messages": [{"role": "system", "content": "Marv is a factual chatbot that is also sarcastic."}, {"role": "user", "content": "Who wrote 'Romeo and Juliet'?"}, {"role": "assistant", "content": "William Shakespeare", "weight": 0}, {"role": "user", "content": "Can you be more sarcastic?"}, {"role": "assistant", "content": "Oh, just some guy named William Shakespeare. Ever heard of him?", "weight": 1}]}
{"messages": [{"role": "system", "content": "Marv is a factual chatbot that is also sarcastic."}, {"role": "user", "content": "How far is the Moon from Earth?"}, {"role": "assistant", "content": "384,400 kilometers", "weight": 0}, {"role": "user", "content": "Can you be more sarcastic?"}, {"role": "assistant", "content": "Around 384,400 kilometers. Give or take a few, like that really matters.", "weight": 1}]}
```

To fine-tune a model, you need to provide at least 10 examples. Generally, noticeable improvements can be observed with fine-tuning using 50 to 100 training examples, especially with gpt-4o-mini and gpt-3.5-turbo. However, the appropriate number of examples can vary significantly depending on the specific use case.

>[!NOTE]
> After collecting the initial dataset, it is recommended to split it into a training set and a test set. When submitting a fine-tuning task with these two sets, statistics will be provided throughout the training process for both files. This information will serve as the first indicator of the model’s improvement. Additionally, creating a test set from the start will allow you to assess the model’s performance after training by generating samples from the test set.

<br/>

#### Upload dataset

Once the training and test files have been created, they must be uploaded using the File API. The purpose property should be set to `finetune` (refer to the enumerated type `TFilesPurpose`). Please see the [example](#File-upload) above for detailed steps on uploading the files.

#### Create the fine-tuning job

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  //Synchronous example
  var Value := Client.FineTuning.Create(
    procedure (Params: TFineTuningJobParams)
    begin
      Params.TrainingFile('...Id of file training...');
      Params.ValidationFile('...Id of file test...');
      Params.Model('gpt-4o-2024-08-06');
      //when use DPO, add
      //Params.Method(TJobMethodParams.NewDpo(THyperparametersParams.Create.Beta(0.1)));
    end);
  try
    TutorialHub.JSONResponse := Value.JSONResponse;
    //display the ID of the fine-tuning job
    Display(TutorialHub, Value.Id);
  finally
    Value.Free;
  end;
```

e.g. return values
```JSON
{
  "object": "fine_tuning.job",
  "id": "ftjob-abc123",
  "model": "gpt-4o-mini-2024-07-18",
  "created_at": 1721764800,
  "fine_tuned_model": null,
  "organization_id": "org-123",
  "result_files": [],
  "status": "queued",
  "validation_file": null,
  "training_file": "file-abc123",
  "method": {
    "type": "supervised",
    "supervised": {
      "hyperparameters": {
        "batch_size": "auto",
        "learning_rate_multiplier": "auto",
        "n_epochs": "auto",
      }
    }
  }
}
```

<br/>

### Fine tuning list

List your organization's fine-tuning jobs. Refer to [parameters documentation](https://platform.openai.com/docs/api-reference/fine-tuning/list).

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  //Asynchronous example
  Client.FineTuning.AsynList(
    procedure (Params: TUrlPaginationParams)
    begin
      Params.Limit(1);
    end,
    function : TAsynFineTuningJobs
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess :=
        procedure (Sender: TObject; Value: TFineTuningJobs)
        begin
          TutorialHub.JSONResponse := Value.JSONResponse;
          for var Item in Value.Data do
            Display(TutorialHub, Item.Id);
          Display(TutorialHub, F('hasmore',VarToStr(Value.HasMore)));
        end;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.FineTuning.List(
//    procedure (Params: TUrlPaginationParams)
//    begin
//      Params.Limit(1);
//    end);
//  try
//    TutorialHub.JSONResponse := Value.JSONResponse;
//    for var Item in Value.Data do
//      Display(TutorialHub, Item.Id);
//    Display(TutorialHub, F('hasmore',VarToStr(Value.HasMore)));
//  finally
//    Value.Free;
//  end;
```

<br/>

### Fine tuning cancel

Immediately cancel a fine-tune job.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.Id := '...Id of fine-tuning job';

  //Synchronous example
  var Value := Client.FineTuning.Cancel(TutorialHub.Id);
  try
    TutorialHub.JSONResponse := Value.JSONResponse;
    Display(TutorialHub, Value.Status.ToString);
  finally
    Value.Free;
  end;
```

<br/>

### Fine tuning events

Get status updates for a fine-tuning job.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.Id := '...Id of fine-tuning job';

  //Synchronous example
  var Value := Client.FineTuning.Events(TutorialHub.Id);
  try
    TutorialHub.JSONResponse := Value.JSONResponse;
    for var Item in value.Data do
      Display(TutorialHub, [Item.&Object,
        F('id', Item.Id),
        F('message', Item.Message)]);
  finally
    Value.Free;
  end;
```

e.g. return values
```JSON
{
  "object": "list",
  "data": [
    {
      "object": "fine_tuning.job.event",
      "id": "ft-event-ddTJfwuMVpfLXseO0Am0Gqjm",
      "created_at": 1721764800,
      "level": "info",
      "message": "Fine tuning job successfully completed",
      "data": null,
      "type": "message"
    },
    {
      "object": "fine_tuning.job.event",
      "id": "ft-event-tyiGuB72evQncpH87xe505Sv",
      "created_at": 1721764800,
      "level": "info",
      "message": "New fine-tuned model created: ft:gpt-4o-mini:openai::7p4lURel",
      "data": null,
      "type": "message"
    }
  ],
  "has_more": true
}  
```

<br/>

### Fine tuning check point

List checkpoints for a fine-tuning job.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.Id := '...Id of fine-tuning job';

  //Synchronous example
  var Value := Client.FineTuning.Checkpoints(TutorialHub.Id);
  try
    TutorialHub.JSONResponse := Value.JSONResponse;
    for var Item in value.Data do
      Display(TutorialHub, [Item.&Object,
        F('id', Item.Id),
        F('step_number', Item.StepNumber.ToString)]);
  finally
    Value.Free;
  end;
```

e.g. return values
```JSON
{
  "object": "list"
  "data": [
    {
      "object": "fine_tuning.job.checkpoint",
      "id": "ftckpt_zc4Q7MP6XxulcVzj4MZdwsAB",
      "created_at": 1721764867,
      "fine_tuned_model_checkpoint": "ft:gpt-4o-mini-2024-07-18:my-org:custom-suffix:96olL566:ckpt-step-2000",
      "metrics": {
        "full_valid_loss": 0.134,
        "full_valid_mean_token_accuracy": 0.874
      },
      "fine_tuning_job_id": "ftjob-abc123",
      "step_number": 2000,
    },
    {
      "object": "fine_tuning.job.checkpoint",
      "id": "ftckpt_enQCFmOTGj3syEpYVhBRLTSy",
      "created_at": 1721764800,
      "fine_tuned_model_checkpoint": "ft:gpt-4o-mini-2024-07-18:my-org:custom-suffix:7q8mpxmy:ckpt-step-1000",
      "metrics": {
        "full_valid_loss": 0.167,
        "full_valid_mean_token_accuracy": 0.781
      },
      "fine_tuning_job_id": "ftjob-abc123",
      "step_number": 1000,
    },
  ],
  "first_id": "ftckpt_zc4Q7MP6XxulcVzj4MZdwsAB",
  "last_id": "ftckpt_enQCFmOTGj3syEpYVhBRLTSy",
  "has_more": true
}  
```
<br/>

### Fine tuning retrieve

Get info about a fine-tuning job.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.Id := '...Id of fine-tuning job';

  //Synchronous example
  var Value := Client.FineTuning.Retrieve(TutorialHub.Id);
  try
    TutorialHub.JSONResponse := Value.JSONResponse;
    Display(TutorialHub, [Value.&Object,
        F('id', Value.Id),
        F('status', Value.Status.ToString)]);
  finally
    Value.Free;
  end;
```

<br/>

### Difference Between Supervised and DPO

<br/>

#### SUPERVISED Fine-Tuning Method

The supervised method  is a classic fine-tuning approach  where the model is trained on a labeled dataset to learn  how to map specific inputs  (prompts)  to target outputs  (ideal responses).

**Key Features:** 
   - The model learns solely from the examples provided in the training data.
   - Each training example contains a prompt and a corresponding target response.
   - The goal is to minimize the error (loss) between the model's output and the target response in the training data.

**Advantages:**
   - Easy to implement: Requires only a well-annotated training dataset.
   - Ideal for specific tasks: Works well for well-defined tasks where high-quality labeled data is
     available (e.g., classification, translation, summarization).

**Limitations:**
   - Can be prone to overfitting if the training data is not diverse enough.
   - Does not account for human preferences or comparisons between multiple potential responses.

**When to use it:**
   - When you have a labeled dataset containing specific examples of what the model should produce.
   - When you aim to train the model  for a specific, well-defined task  (e.g., answering questions or generating structured summaries).

<br/>

#### DPO (Direct Preference Optimization) Method


he DPO method is a more advanced approach  that incorporates human preferences into the training process. Instead  of  focusing  on  "ideal"  responses,  this method  uses  pairs of responses to indicate which one is preferred (based on human or automated evaluations).

**Key Features:**
   - The dataset includes comparisons between two responses generated for the same prompt, with one response marked as preferred.
   - The model is optimized to replicate these preferences.
   - This method is often used to fine-tune a model to align its responses with subjective or human preferences.

**Advantages:**
   - Captures human preferences: Improves response quality based on subjective  or context-specific criteria.
   - Resilient to data  uncertainty:  Useful when  traditional  labeled  data  is  unavailable, but preference judgments are feasible.

**Limitations:**
   - Requires a dataset with comparison data, which can be costly or time-consuming to create.
   - More complex to implement and train than the supervised method.

**When to use it:**
   - When you want the model to produce responses that reflect subjective or human preferences, for example:
       - Generating more fluent or engaging text.
       - Aligning responses  with specific criteria  (e.g., avoiding  bias  or  generating  content tailored to a specific domain).
   - When  you  have a dataset containing  response  comparisons  (e.g., human ratings  of response quality between two options).

<br/>

#### Choosing Between the Two Methods


 |    Criteria       |         Supervised               |                 DPO                      |
 | --- | --- |--- |
 | Data Availability                           | Requires data with clear target outputs  | Requires comparisons between responses  (preferences)  |
 | Implementation  Complexity   | Simpler                                                               | More complex, needs well-collected preferences      |
 | Human Alignment                       | Limited                                                               | Strong alignment due to human preference incorporation |
 | Primary Use Cases                      | Well-defined, objective tasks                      | Subjective tasks or those requiring fine-tuned alignment  |
 
<br/>

#### Recommendations

- **Use the supervised method if:**
    - You have a  labeled  dataset  with ideal responses  for your prompts.   
    - Your task is  well-defined and does  not require subjective adjustments  or alignment with human preferences.

- **Use the DPO method if:**
    - You want the model to generate responses that align with human or specific subjective preferences.
    - You have a dataset with comparisons between multiple responses.
    - You  aim  to  improve  response  quality  for  creative  or  open-ended  tasks  where preferences  are  key.

In summary, the  supervised method  is ideal for  well-defined tasks, while  DPO is more suitable when human preferences or subjective criteria are central to your project.

 <br/>

___

## Vector store

Vector stores are used to store files for use by the [`file_search`](https://platform.openai.com/docs/assistants/tools/file-search) tool.

### Vector store create

Create a vector store. [Refer to documentation](https://platform.openai.com/docs/api-reference/vector-stores/create)

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;
  
  TutorialHub.JSONRequestClear;
  
  //Asynchronous example
  Client.VectorStore.AsynCreate(
    procedure (Params: TVectorStoreCreateParams)
    begin
      Params.Name('Support FAQ');
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynVectorStore
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.VectorStore.Create(
//    procedure (Params: TVectorStoreCreateParams)
//    begin
//      Params.Name('Support FAQ');
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

The Json response.
```JSON
{
  "id": "vs_abc123",
  "object": "vector_store",
  "created_at": 1699061776,
  "name": "Support FAQ",
  "bytes": 139920,
  "file_counts": {
    "in_progress": 0,
    "completed": 3,
    "failed": 0,
    "cancelled": 0,
    "total": 3
  }
}
```


<br/>

### Vector store list

Returns a list of vector stores.  

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;

  //Asynchronous example
  Client.VectorStore.AsynList(
    function : TAsynVectorStores
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.VectorStore.List;
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

Example using [parameter](https://platform.openai.com/docs/api-reference/vector-stores/list).

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;

  //Asynchronous example
  Client.VectorStore.AsynList(
    procedure (Params: TVectorStoreUrlParam)
    begin
      Params.Limit(3);
    end,
    function : TAsynVectorStores
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.VectorStore.List(
//    procedure (Params: TVectorStoreUrlParam)
//    begin
//      Params.Limit(3);
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br/>

### Vector store retrieve

Retrieves a vector store by its ID.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.Id := 'vs_abc123';

  //Asynchronous example
  Client.VectorStore.AsynRetrieve(TutorialHub.Id,
    function : TAsynVectorStore
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.VectorStore.Retrieve(TutorialHub.Id);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br/>

### Vector store modify

Modifies a vector store by its ID.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.Id := 'vs_abc123';

  var MetaData := TJSONObject.Create
    .AddPair('customer_id', 'user_123456789')
    .AddPair('vector_description', 'vector store user');

  //Asynchronous example
  Client.VectorStore.AsynUpdate(TutorialHub.Id,
    procedure (Params: TVectorStoreUpdateParams)
    begin
      Params.Name('Support FAQ user');
      Params.Metadata(Metadata);
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynVectorStore
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.VectorStore.Update(TutorialHub.Id,
//    procedure (Params: TVectorStoreUpdateParams)
//    begin
//      Params.Name('Support FAQ user');
//      Params.Metadata(Metadata);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br/>

### Vector store delete

Delete a vector store by its ID.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.Id := 'vs_abc123';

  //Asynchronous example
  Client.VectorStore.AsynDelete(TutorialHub.Id,
    function : TAsynDeletion
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.VectorStore.Delete(TutorialHub.Id);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

The JSON response.
```JSON
{
    "id": "vs_abc123",
    "object": "vector_store.deleted",
    "deleted": true
}
```

<br/>

___

## Vector store files

Vector store files represent files inside a vector store.

Related guide: [File Search](https://platform.openai.com/docs/assistants/tools/file-search)

<br/>

### Vsf create

Create a vector store file by attaching a [File](https://platform.openai.com/docs/api-reference/files) to a [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).

<br/>

#### Create a vector store

To create the vector store, it is advisable to refer to the example provided [at this location](#Vector-store-create) . Once the creation is complete, it is essential to retrieve the vector store ID. 

<br/>

#### Upload files en get Ids

To link the files to the vector store created in the previous step, it is necessary to [upload](#File-upload) them first, as described earlier. Additionally, it is essential to retrieve the file IDs after the upload, just like in the previous step.

Let’s consider the upload of two files, ***file1*** and ***file2***, ensuring that the `purpose` field is set to `assistant`. This will provide the corresponding file IDs, ***fileId1*** and ***fileId2***, respectively.

<br/>

#### Create the vector store files

To create the file store containing ***file1*** and ***file2***, the provided code will need to be executed twice, once for each identifier: ***fileId1*** and ***fileId2***. Upon completion of these operations, calling the file store will grant access to both associated files.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;
  TutorialHub.Id := 'vs_abc123';  //Id of vector store
  var Id1 := 'file-123';
  var Id2 := 'file-456';

  //Asynchronous example
  Client.VectorStoreFiles.AsynCreate(TutorialHub.id,
    procedure (Params: TVectorStoreFilesCreateParams)
    begin
      Params.FileId(Id1);  // or Params.FileId(Id2);
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynVectorStoreFile
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.VectorStoreFiles.Create(TutorialHub.id,
//    procedure (Params: TVectorStoreFilesCreateParams)
//    begin
//      Params.FileId(Id1); // or Params.FileId(Id2);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

The JSON response:
```JSON
{
    "id": "file-124",
    "object": "vector_store.file",
    "usage_bytes": 62353,
    "created_at": 1738906505,
    "vector_store_id": "vs_abc123",
    "status": "completed",
    "last_error": null,
    "chunking_strategy": {
        "type": "static",
        "static": {
            "max_chunk_size_tokens": 800,
            "chunk_overlap_tokens": 400
        }
    }
}  
```

<br/>

### Vsf list

Returns a list of vector store files.

<br/>

#### Without parameters

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;
 
  TutorialHub.JSONRequestClear;
  TutorialHub.Id := 'vs_abc123';

  //Asynchronous example
  Client.VectorStoreFiles.AsynList(TutorialHub.Id,
    function : TAsynVectorStoreFiles
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.VectorStoreFiles.List(TutorialHub.Id);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br/>

#### with parameters

Refert to [parameters documentation](https://platform.openai.com/docs/api-reference/vector-stores-files/listFiles).

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;
  TutorialHub.Id := 'vs_abc123';

  //Asynchronous example
  Client.VectorStoreFiles.AsynList(TutorialHub.Id,
    procedure (Params: TVectorStoreFilesUrlParams)
    begin
      Params.Limit(5);
      Params.Filter('completed');
    end,
    function : TAsynVectorStoreFiles
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.VectorStoreFiles.List(TutorialHub.Id,
//    procedure (Params: TVectorStoreFilesUrlParams)
//    begin
//      Params.Limit(5);
//      Params.Filter('completed');
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

The JSON response:
```JSON
{
    "object": "list",
    "data": [
        {
            "id": "file-123",
            "object": "vector_store.file",
            "usage_bytes": 62353,
            "created_at": 1738906505,
            "vector_store_id": "vs_abc123",
            "status": "completed",
            "last_error": null,
            "chunking_strategy": {
                "type": "static",
                "static": {
                    "max_chunk_size_tokens": 800,
                    "chunk_overlap_tokens": 400
                }
            },
            "metadata": {
            }
        },
        {
            "id": "file-456",
            "object": "vector_store.file",
            "usage_bytes": 1601511,
            "created_at": 1738902946,
            "vector_store_id": "vs_abc123",
            "status": "completed",
            "last_error": null,
            "chunking_strategy": {
                "type": "static",
                "static": {
                    "max_chunk_size_tokens": 800,
                    "chunk_overlap_tokens": 400
                }
            },
            "metadata": {
            }
        }
    ],
    "first_id": "file-123",
    "last_id": "file-456",
    "has_more": false
}
```

<br/>

### Vsf retrieve

Retrieves a vector store file.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;
  TutorialHub.Id := 'vs_abc123';
  var Id1 := 'file-123';

  //Asynchronous example
  Client.VectorStoreFiles.AsynRetrieve(
    TutorialHub.Id,
    Id1,
    function : TAsynVectorStoreFile
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.VectorStoreFiles.Retrieve(
//                 TutorialHub.Id,
//                 Id1);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

The JSON response:
```JSON
{
    "id": "file-123",
    "object": "vector_store.file",
    "usage_bytes": 1601511,
    "created_at": 1738902946,
    "vector_store_id": "vs_abc123",
    "status": "completed",
    "last_error": null,
    "chunking_strategy": {
        "type": "static",
        "static": {
            "max_chunk_size_tokens": 800,
            "chunk_overlap_tokens": 400
        }
    }
}
```

<br/>

### Vsf delete

Remove a vector store file. This action will detach the file from the vector store without deleting the file itself. To permanently delete the file, use the [delete file](#File-Deletion) endpoint.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;
  TutorialHub.Id := 'vs_abc123';
  var Id1 := 'file-123';

  //Asynchronous example
  Client.VectorStoreFiles.AsynDelete(
    TutorialHub.Id,
    Id1,
    function : TAsynDeletion
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);


  //Synchronous example
//  var Value := Client.VectorStoreFiles.Delete(
//                 TutorialHub.Id,
//                 Id1);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

The JSON response:
```JSON
{
    "id": "file-123",
    "object": "vector_store.file.deleted",
    "deleted": true
}
```

<br/>

___

## Vector store batches

Vector store file batches represent operations to add multiple files to a vector store. Related guide: [File Search](https://platform.openai.com/docs/assistants/tools/file-search)

<br/>

### Vsb create

<br/>

#### Create a vector store

To create the vector store, it is advisable to refer to the example provided [at this location](#Vector-store-create) . Once the creation is complete, it is essential to retrieve the vector store ID. 

<br/>

#### Upload files en get Ids

To link the files to the vector store created in the previous step, it is necessary to [upload](#File-upload) them first, as described earlier. Additionally, it is essential to retrieve the file IDs after the upload, just like in the previous step.

Let’s consider the upload of two files, ***file1*** and ***file2***, ensuring that the `purpose` field is set to `assistant`. This will provide the corresponding file IDs, ***fileId1*** and ***fileId2***, respectively.

<br/>

#### Create the vector store batches

To create the batch store containing ***file1*** and ***file2***, uses example bellow.


```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;
  TutorialHub.Id := 'vs_cde456';
  var Id1 := 'file-123';
  var Id2 := 'file-456';

  //Asynchronous example
  Client.VectorStoreBatch.AsynCreate(TutorialHub.id,
    procedure (Params: TVectorStoreBatchCreateParams)
    begin
      Params.FileId([Id1, Id2]);
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynVectorStoreBatch
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.VectorStoreBatch.Create(TutorialHub.id,
//    procedure (Params: TVectorStoreBatchCreateParams)
//    begin
//      Params.FileId([Id1, Id2]);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

The JSON response:
```JSON
{
    "id": "vsfb_123",
    "object": "vector_store.file_batch",
    "created_at": 1738956347,
    "status": "in_progress",
    "vector_store_id": "vs_cde456",
    "file_counts": {
        "in_progress": 2,
        "completed": 0,
        "failed": 0,
        "cancelled": 0,
        "total": 2
    }
}
```

<br/>

### Vsb list

Returns a list of vector store files in a batch.

#### Without parameters

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;
 
  TutorialHub.JSONRequestClear;
  TutorialHub.Id := 'vs_cde456';
  var BatchId := 'vsfb_789';

  //Asynchronous example
  Client.VectorStoreBatch.AsynList(
    TutorialHub.Id,
    BatchId,
    function : TAsynVectorStoreBatches
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.VectorStoreBatch.List(TutorialHub.Id, BatchId);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br/>

#### with parameters

Refert to [parameters documentation](https://platform.openai.com/docs/api-reference/vector-stores-files/listFiles).

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;
  TutorialHub.Id := 'vs_cde456';
  var BatchId := 'vsfb_789';

  //Asynchronous example
  Client.VectorStoreBatch.AsynList(
    TutorialHub.Id,
    BatchId,
    procedure (Params: TVectorStoreFilesUrlParams)
    begin
      Params.Limit(5);
      Params.Filter('completed');
    end,
    function : TAsynVectorStoreBatches
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.VectorStoreBatch.List(TutorialHub.Id, BatchId,
//    procedure (Params: TVectorStoreFilesUrlParams)
//    begin
//      Params.Limit(5);
//      Params.Filter('completed');
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

The JSON response:
```JSON
{
    "object": "list",
    "data": [
        {
            "id": "file-123",
            "object": "vector_store.file",
            "created_at": 1738955835,
            "vector_store_id": "vs_cde456",
            "status": "completed",
            "last_error": null
        },
        {
            "id": "file-456",
            "object": "vector_store.file",
            "created_at": 1738902946,
            "vector_store_id": "vs_cde456",
            "status": "completed",
            "last_error": null
        }
    ],
    "first_id": "file-123",
    "last_id": "file-456",
    "has_more": false
}
```

<br/>

### Vsb retrieve

Returns a list of vector store files in a batch.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;
  TutorialHub.Id := 'vs_cde456';
  var BatchId := 'vsfb_7891';

  //Asynchronous example
  Client.VectorStoreBatch.AsynRetrieve(
    TutorialHub.Id,
    BatchId,
    function : TAsynVectorStoreBatch
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.VectorStoreBatch.Retrieve(
//                 TutorialHub.Id,
//                 BatchId);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

The JSON response:
```JSON
{
    "id": "vsfb_789",
    "object": "vector_store.file_batch",
    "created_at": 1738958063,
    "status": "completed",
    "vector_store_id": "vs_cde456",
    "file_counts": {
        "in_progress": 0,
        "completed": 2,
        "failed": 0,
        "cancelled": 0,
        "total": 2
    }
}
```

<br/>

### Vsb cancel

Cancel a vector store file batch. This attempts to cancel the processing of files in this batch as soon as possible.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;
  TutorialHub.Id := 'vs_cde456';
  var BatchId := 'vsfb_789';

  //Asynchronous example
  Client.VectorStoreBatch.AsynRetrieve(
    TutorialHub.Id,
    BatchId,
    function : TAsynVectorStoreBatch
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.VectorStoreBatch.Cancel(
//                 TutorialHub.Id,
//                 BatchId);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

The JSON response:
```JSON
{
    "id": "vsfb_789",
    "object": "vector_store.file_batch",
    "created_at": 1738958063,
    "status": "completed",
    "vector_store_id": "vs_cde456",
    "file_counts": {
        "in_progress": 0,
        "completed": 2,
        "failed": 0,
        "cancelled": 0,
        "total": 2
    }
}
```

<br/>

___

## Assistants

Build assistants that can call models and use tools to perform tasks.

The version of assistants integrated by `GenAI` is version 2, currently offered in beta by **OpenAI**.

[Get started with the Assistants API](https://platform.openai.com/docs/assistants)

<br/>

### Create assistant

<br/>

#### Code interpreter

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;

  //Asynchronous example
 Client.Assistants.AsynCreate(
    procedure (Params: TAssistantsParams)
    begin
      Params.Model('gpt-4o');
      Params.Instructions('You are an HR bot, and you have access to files to answer employee questions about company policies.');
      Params.Name('HR Bot');

      // ---> Change github documentation

      Params.Tools([file_search]);
      Params.ToolResources(file_search_storeId);
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynAssistant
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Assistants.Create(
//    procedure (Params: TAssistantsParams)
//    begin
//      Params.Model('gpt-4o');
//      Params.Instructions('You are an HR bot, and you have access to files to answer employee questions about company policies.');
//      Params.Name('HR Bot');
//      Params.Tools([file_search]);
//      Params.ToolResources(file_search_storeId);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

The JSON response:
```JSON
{
    "id": "asst_4FYKxWZ3CFprvgLKe4E8CZGl",
    "object": "assistant",
    "created_at": 1738960690,
    "name": "Math Tutor",
    "description": null,
    "model": "gpt-4o",
    "instructions": "You are a personal math tutor. When asked a question, write and run Python code to answer the question.",
    "tools": [
    ],
    "top_p": 1.0,
    "temperature": 1.0,
    "reasoning_effort": null,
    "tool_resources": {
    },
    "metadata": {
    },
    "response_format": "auto"
}
```

<br/>

#### File search

To fully utilize this feature offered by the `assistants`, you must be comfortable managing file stores. For further details, you can refer to the sections [vector store files](#Vector-store-files) outlined above.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;
  var FilesId := 'vs_123';  //Id of a vector store files

  //Asynchronous example
  Client.Assistants.AsynCreate(
    procedure (Params: TAssistantsParams)
    begin
      Params.Model('gpt-4o');
      Params.Instructions('You are an HR bot, and you have access to files to answer employee questions about company policies.');
      Params.Name('HR Bot');
      Params.Tools([File_search]);
      Params.ToolResources(File_search([FilesId]));
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynAssistant
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Assistants.Create(
//    procedure (Params: TAssistantsParams)
//    begin
//      Params.Model('gpt-4o');
//      Params.Instructions('You are an HR bot, and you have access to files to answer employee questions about company policies.');
//      Params.Name('HR Bot');
//      Params.Tools([File_search]);
//      Params.ToolResources(File_search([FilesId]));
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

The JSON response:
```JSON
{
  "id": "asst_abc123",
  "object": "assistant",
  "created_at": 1738963996,
  "name": "HR Helper",
  "description": null,
  "model": "gpt-4o",
  "instructions": "You are an HR bot, and you have access to files to answer employee questions about company policies.",
  "tools": [
    {
      "type": "file_search"
    }
  ],
  "tool_resources": {
    "file_search": {
      "vector_store_ids": ["vs_123"]
    }
  },
  "metadata": {},
  "top_p": 1.0,
  "temperature": 1.0,
  "response_format": "auto"
}
```

<br/>

### List assistants

Returns a list of assistants.

Consult the [official documentation](https://platform.openai.com/docs/api-reference/assistants/listAssistants) for details on list parameters.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;

  //Asynchronous example
  Client.Assistants.AsynList(
    procedure (Params: TUrlAdvancedParams)
    begin
      Params.Limit(5);
    end,
    function : TAsynAssistants
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Assistants.List(
//    procedure (Params: TUrlAdvancedParams)
//    begin
//      Params.Limit(5);
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br/>

### Retrieve assistant

Retrieves an assistant by its ID.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;
  TutorialHub.Id := 'asst_abc123';

  //Asynchronous example
  Client.Assistants.AsynRetrieve(TutorialHub.Id,
    function : TAsynAssistant
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Assistants.Retrieve(TutorialHub.Id);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br/>

### Modify assistant

Modifies an assistant by its ID.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;
  TutorialHub.Id := 'asst_abc123';

  //Asynchronous example
  Client.Assistants.AsynUpdate(TutorialHub.Id,
    procedure (Params: TAssistantsParams)
    begin
      Params.Model('o3-mini');
      Params.ReasoningEffort(TReasoningEffort.medium);
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynAssistant
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Assistants.Update(TutorialHub.Id,
//    procedure (Params: TAssistantsParams)
//    begin
//      Params.Model('o3-mini');
//      Params.ReasoningEffort(TReasoningEffort.medium);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

The JSON response
```JSON
{
    "id": "asst_abc123",
    "object": "assistant",
    "created_at": 1738963996,
    "name": "HR Bot",
    "description": null,
    "model": "o3-mini",
    "instructions": "You are an HR bot, and you have access to files to answer employee questions about company policies.",
    "tools": [
        {
            "type": "file_search",
            "file_search": {
                "ranking_options": {
                    "ranker": "default_2024_08_21",
                    "score_threshold": 0.0
                }
            }
        }
    ],
    "top_p": 1.0,
    "temperature": 1.0,
    "reasoning_effort": "medium",
    "tool_resources": {
        "file_search": {
            "vector_store_ids": [
                "vs_123"
            ]
        }
    },
    "metadata": {
    },
    "response_format": "auto"
}
```

<br/>

### Delete assistant

Delete an assistant by its ID.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;
  
  TutorialHub.JSONRequestClear;
  TutorialHub.Id := 'asst_abc123';

  //Asynchronous example
  Client.Assistants.AsynDelete(TutorialHub.Id,
    function : TAsynDeletion
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Assistants.Delete(TutorialHub.Id);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br/>

___

## Threads

Create threads that assistants can interact with.

Related guide: [Assistants](https://platform.openai.com/docs/assistants/overview)

<br/>

### Create thread

Create a thread.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;

  //Synchronous example
  Client.Threads.AsynCreate(
    function : TAsynThreads
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Threads.Create;
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br/>

### Retrieve thread

Retrieves a thread by its ID.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.Id := 'thread_xyz321';

  //Synchronous example
  Client.Threads.AsynRetrieve(TutorialHub.Id,
    function : TAsynThreads
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Threads.Retrieve(TutorialHub.Id);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br/>

### Modify thread

Modifies a thread by its ID.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.Id := 'thread_xyz321';

  var MetaData := TJSONObject.Create
    .AddPair('customer_id', 'user_12345')
    .AddPair('batch_description', 'Nightly eval job');

  //Synchronous example
  Client.Threads.AsynModify(TutorialHub.Id,
    procedure (Params: TThreadsModifyParams)
    begin
      Params.Metadata(Metadata);
    end,
    function : TAsynThreads
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Threads.Modify(TutorialHub.Id,
//    procedure (Params: TThreadsModifyParams)
//    begin
//      Params.Metadata(Metadata);
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

The JSON response:
```JSON
{
    "id": "thread_xyz321",
    "object": "thread",
    "created_at": 1738969338,
    "metadata": {
        "customer_id": "user_12345",
        "batch_description": "Nightly eval job"
    },
    "tool_resources": {
    }
}
```

<br/>

### Delete thread

Delete a thread by its ID.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.Id := 'thread_xyz321';

  //Synchronous example
  Client.Threads.AsynDelete(TutorialHub.Id,
    function : TAsynDeletion
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Threads.Delete(TutorialHub.Id);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br/>

___

## Messages

Create messages within threads

Related guide: [Assistants](https://platform.openai.com/docs/assistants/overview)

<br/>

### Create message

Create a message.

To take full advantage of this feature provided by Messages, it is essential to be proficient in managing Threads. For more information, please refer to the [Threads sections](#Threads) mentioned earlier.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;
  var ThreadId := 'thread_123abc';

  //Asynchronous example
  Client.Messages.AsynCreate(ThreadId,
    procedure (Params: TThreadsMessageParams)
    begin
      Params.Role('user');
      Params.Content('How does AI work? Explain it in simple terms.');
    end,
    function : TAsynMessages
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Messages.Create(ThreadId,
//    procedure (Params: TThreadsMessageParams)
//    begin
//      Params.Role('user');
//      Params.Content('How does AI work? Explain it in simple terms.');
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

The JSON response:
```JSON
{
    "id": "msg_456xyz",
    "object": "thread.message",
    "created_at": 1738971461,
    "assistant_id": null,
    "thread_id": "thread_123abc",
    "run_id": null,
    "role": "user",
    "content": [
        {
            "type": "text",
            "text": {
                "value": "How does AI work? Explain it in simple terms.",
                "annotations": [
                ]
            }
        }
    ],
    "attachments": [
    ],
    "metadata": {
    }
}
```

<br/>

### List messages

Returns a list of messages for a given thread.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;
  TutorialHub.Id := 'thread_123abc';

  //Asynchronous example
  Client.Messages.AsynList(TutorialHub.Id,
    procedure (Params: TAssistantsUrlParams)
    begin
      Params.Limit(5);
    end,
    function : TAsynMessagesList
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Messages.List(TutorialHub.Id,
//    procedure (Params: TAssistantsUrlParams)
//    begin
//      Params.Limit(5);
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

The JSON response:
```JSON
{
    "object": "list",
    "data": [
        {
            "id": "msg_456xyz",
            "object": "thread.message",
            "created_at": 1738972475,
            "assistant_id": null,
            "thread_id": "thread_123abc",
            "run_id": null,
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": {
                        "value": "How does AI work? Explain it in simple terms.",
                        "annotations": [
                        ]
                    }
                }
            ],
            "attachments": [
            ],
            "metadata": {
            }
        }
    ],
    "first_id": "msg_456xyz",
    "last_id": "msg_456xyz",
    "has_more": false
}
```

<br/>

### Retrieve message

Retrieve a message by its ID.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;
  TutorialHub.Id := 'thread_123abc';
  var MessageId := 'msg_456xyz';

  //Asynchronous example
  Client.Messages.AsynRetrieve(TutorialHub.Id, MessageId,
    function : TAsynMessages
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Messages.Retrieve(TutorialHub.Id, MessageId);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

The JSON response:
```JSON
{
    "id": "msg_456xyz",
    "object": "thread.message",
    "created_at": 1738972475,
    "assistant_id": null,
    "thread_id": "thread_123abc",
    "run_id": null,
    "role": "user",
    "content": [
        {
            "type": "text",
            "text": {
                "value": "How does AI work? Explain it in simple terms.",
                "annotations": [
                ]
            }
        }
    ],
    "attachments": [
    ],
    "metadata": {
    }
}
```

<br/>

### Modify message

Modifies a message by its ID.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;
  TutorialHub.Id := 'thread_123abc';
  var MessageId := 'msg_456xyz';

  var MetaData := TJSONObject.Create
    .AddPair('customer_id', 'user_123456789')
    .AddPair('message_description', 'Eval job');

  //Asynchronous example
  Client.Messages.AsynUpdate(TutorialHub.Id, MessageId,
    procedure (Params: TMessagesUpdateParams)
    begin
      Params.Metadata(Metadata);
    end,
    function : TAsynMessages
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Messages.Update(TutorialHub.Id, MessageId,
//    procedure (Params: TMessagesUpdateParams)
//    begin
//      Params.Metadata(Metadata);
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

The JSON response:
```JSON
{
    "id": "msg_456xyz",
    "object": "thread.message",
    "created_at": 1738972475,
    "assistant_id": null,
    "thread_id": "thread_123abc",
    "run_id": null,
    "role": "user",
    "content": [
        {
            "type": "text",
            "text": {
                "value": "How does AI work? Explain it in simple terms.",
                "annotations": [
                ]
            }
        }
    ],
    "file_ids": [
    ],
    "metadata": {
        "customer_id": "user_123456789",
        "message_description": "Eval job"
    }
}
```

<br/>

### Delete message

Deletes a message by its ID.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;
  TutorialHub.Id := 'thread_123abc';
  var MessageId := 'msg_456xyz';

  //Asynchronous example
  Client.Messages.AsynDelete(TutorialHub.Id, MessageId,
    function : TAsynDeletion
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Messages.Delete(TutorialHub.Id, MessageId);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

The JSON response:
```JSON
{
    "id": "msg_456xyz",
    "object": "thread.message.deleted",
    "deleted": true
}
```

<br/>

___

## Runs

Represents an execution run on a thread.

Related guide: [Assistants](https://platform.openai.com/docs/assistants/overview)

<br/>

### Create run

Create a run.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;
  var ThreadId := 'thread_abc123';
  var AssistantId := 'asst_abc123';

  //Asynchronous example
  Client.Runs.AsynCreate(ThreadId,
    procedure (Params: TRunsParams)
    begin
      Params.AssistantId(AssistantId);
    end,
    function : TAsynRun
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Runs.Create(ThreadId,
//    procedure (Params: TRunsParams)
//    begin
//      Params.AssistantId(AssistantId);
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

```JSON
{
  "id": "run_abc123",
  "object": "thread.run",
  "created_at": 1699063290,
  "assistant_id": "asst_abc123",
  "thread_id": "thread_abc123",
  "status": "queued",
  "started_at": 1699063290,
  "expires_at": null,
  "cancelled_at": null,
  "failed_at": null,
  "completed_at": 1699063291,
  "last_error": null,
  "model": "gpt-4o",
  "instructions": null,
  "incomplete_details": null,
  "tools": [
    {
      "type": "code_interpreter"
    }
  ],
  "metadata": {},
  "usage": null,
  "temperature": 1.0,
  "top_p": 1.0,
  "max_prompt_tokens": 1000,
  "max_completion_tokens": 1000,
  "truncation_strategy": {
    "type": "auto",
    "last_messages": null
  },
  "response_format": "auto",
  "tool_choice": "auto",
  "parallel_tool_calls": true
}
```

<br/>

Create a thread and run it in one request.

### Create thread and run

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;
  var AssistantId := 'asst_abc123';

  //Asynchronous example
  Client.Runs.AsynCreateAndRun(
    procedure (Params: TCreateRunsParams)
    begin
      Params.AssistantId(AssistantId);
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynRun
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Runs.CreateAndRun(
//    procedure (Params: TCreateRunsParams)
//    begin
//      Params.AssistantId(AssistantId);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

```JSON
{
  "id": "run_abc123",
  "object": "thread.run",
  "created_at": 1699076792,
  "assistant_id": "asst_abc123",
  "thread_id": "thread_abc123",
  "status": "queued",
  "started_at": null,
  "expires_at": 1699077392,
  "cancelled_at": null,
  "failed_at": null,
  "completed_at": null,
  "required_action": null,
  "last_error": null,
  "model": "gpt-4o",
  "instructions": "You are a helpful assistant.",
  "tools": [],
  "tool_resources": {},
  "metadata": {},
  "temperature": 1.0,
  "top_p": 1.0,
  "max_completion_tokens": null,
  "max_prompt_tokens": null,
  "truncation_strategy": {
    "type": "auto",
    "last_messages": null
  },
  "incomplete_details": null,
  "usage": null,
  "response_format": "auto",
  "tool_choice": "auto",
  "parallel_tool_calls": true
}
```

<br/>

### List runs

Returns a list of runs belonging to a thread.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  var ThreadId := 'thread_abc123';
  
  //Asynchronous example
  Client.Runs.AsynList(ThreadId,
    procedure (Params: TRunsUrlParams)
    begin
      Params.Limit(5);
    end,
    function : TAsynRuns
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Runs.List(ThreadId,
//    procedure (Params: TRunsUrlParams)
//    begin
//      Params.Limit(5);
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

<br/>

### Retrieve run

Retrieves a run by its ID.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;
  TutorialHub.Id := 'thread_abc123';
  var RunId := 'asst_abc123';

  //Asynchronous example
  Client.Runs.AsynRetrieve(TutorialHub.Id, RunId,
    function : TAsynRun
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Runs.Retrieve(TutorialHub.Id, RunId);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

```JSON
{
  "id": "run_abc123",
  "object": "thread.run",
  "created_at": 1699075072,
  "assistant_id": "asst_abc123",
  "thread_id": "thread_abc123",
  "status": "completed",
  "started_at": 1699075072,
  "expires_at": null,
  "cancelled_at": null,
  "failed_at": null,
  "completed_at": 1699075073,
  "last_error": null,
  "model": "gpt-4o",
  "instructions": null,
  "incomplete_details": null,
  "tools": [
    {
      "type": "code_interpreter"
    }
  ],
  "metadata": {},
  "usage": {
    "prompt_tokens": 123,
    "completion_tokens": 456,
    "total_tokens": 579
  },
  "temperature": 1.0,
  "top_p": 1.0,
  "max_prompt_tokens": 1000,
  "max_completion_tokens": 1000,
  "truncation_strategy": {
    "type": "auto",
    "last_messages": null
  },
  "response_format": "auto",
  "tool_choice": "auto",
  "parallel_tool_calls": true
}
```

<br/>

### Modify run

Modifies a run by its ID.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;
  TutorialHub.Id := 'thread_abc123';
  var RunId := 'run_abc123';

  var MetaData := TJSONObject.Create
    .AddPair('user_id', 'user_abc123');

  //Asynchronous example
  Client.Runs.AsynUpdate(TutorialHub.Id, RunId,
    procedure (Params: TRunUpdateParams)
    begin
      Params.Metadata(MetaData);
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynRun
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Runs.Update(TutorialHub.Id, RunId,
//    procedure (Params: TRunUpdateParams)
//    begin
//      Params.Metadata(MetaData);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

```JSON
{
  "id": "run_abc123",
  "object": "thread.run",
  "created_at": 1699075072,
  "assistant_id": "asst_abc123",
  "thread_id": "thread_abc123",
  "status": "completed",
  "started_at": 1699075072,
  "expires_at": null,
  "cancelled_at": null,
  "failed_at": null,
  "completed_at": 1699075073,
  "last_error": null,
  "model": "gpt-4o",
  "instructions": null,
  "incomplete_details": null,
  "tools": [
    {
      "type": "code_interpreter"
    }
  ],
  "tool_resources": {
    "code_interpreter": {
      "file_ids": [
        "file-abc123",
        "file-abc456"
      ]
    }
  },
  "metadata": {
    "user_id": "user_abc123"
  },
  "usage": {
    "prompt_tokens": 123,
    "completion_tokens": 456,
    "total_tokens": 579
  },
  "temperature": 1.0,
  "top_p": 1.0,
  "max_prompt_tokens": 1000,
  "max_completion_tokens": 1000,
  "truncation_strategy": {
    "type": "auto",
    "last_messages": null
  },
  "response_format": "auto",
  "tool_choice": "auto",
  "parallel_tool_calls": true
}
```

<br/>

### Submit tool outputs

When a run has the `status: "requires_action"` and `required_action.type` is `submit_tool_outputs`, this endpoint can be used to submit the outputs from the tool calls once they're all completed. All outputs must be submitted in a single request.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;
  TutorialHub.Id := 'thread_123';
  var RunId := 'run_123';

  //Asynchronous example
  Client.Runs.AsynSubmitTool(TutorialHub.Id, RunId,
    procedure (Params: TSubmitToolParams)
    begin
      Params.ToolOutputs([
        TToolOutputParam.Create.ToolCallId('call_001').Output('70 degrees and sunny.')
      ]);
      TutorialHub.JSONRequest := Params.ToFormat();
    end,
    function : TAsynRun
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Runs.SubmitTool(TutorialHub.Id, RunId,
//    procedure (Params: TSubmitToolParams)
//    begin
//      Params.ToolOutputs([
//        TToolOutputParam.Create.ToolCallId('call_001').Output('70 degrees and sunny.')
//      ]);
//      TutorialHub.JSONRequest := Params.ToFormat();
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

```JSON
{
  "id": "run_123",
  "object": "thread.run",
  "created_at": 1699075592,
  "assistant_id": "asst_123",
  "thread_id": "thread_123",
  "status": "queued",
  "started_at": 1699075592,
  "expires_at": 1699076192,
  "cancelled_at": null,
  "failed_at": null,
  "completed_at": null,
  "last_error": null,
  "model": "gpt-4o",
  "instructions": null,
  "tools": [
    {
      "type": "function",
      "function": {
        "name": "get_current_weather",
        "description": "Get the current weather in a given location",
        "parameters": {
          "type": "object",
          "properties": {
            "location": {
              "type": "string",
              "description": "The city and state, e.g. San Francisco, CA"
            },
            "unit": {
              "type": "string",
              "enum": ["celsius", "fahrenheit"]
            }
          },
          "required": ["location"]
        }
      }
    }
  ],
  "metadata": {},
  "usage": null,
  "temperature": 1.0,
  "top_p": 1.0,
  "max_prompt_tokens": 1000,
  "max_completion_tokens": 1000,
  "truncation_strategy": {
    "type": "auto",
    "last_messages": null
  },
  "response_format": "auto",
  "tool_choice": "auto",
  "parallel_tool_calls": true
}
```

<br/>

### Cancel run

Cancels a run that is `in_progress`.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;
  TutorialHub.Id := 'thread_abc123';
  var RunId := 'run_abc123';

  //Asynchronous example
  Client.Runs.AsynCancel(TutorialHub.Id, RunId,
    function : TAsynRun
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.Runs.Cancel(TutorialHub.Id, RunId);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

```JSON
{
  "id": "run_abc123",
  "object": "thread.run",
  "created_at": 1699076126,
  "assistant_id": "asst_abc123",
  "thread_id": "thread_abc123",
  "status": "cancelling",
  "started_at": 1699076126,
  "expires_at": 1699076726,
  "cancelled_at": null,
  "failed_at": null,
  "completed_at": null,
  "last_error": null,
  "model": "gpt-4o",
  "instructions": "You summarize books.",
  "tools": [
    {
      "type": "file_search"
    }
  ],
  "tool_resources": {
    "file_search": {
      "vector_store_ids": ["vs_123"]
    }
  },
  "metadata": {},
  "usage": null,
  "temperature": 1.0,
  "top_p": 1.0,
  "response_format": "auto",
  "tool_choice": "auto",
  "parallel_tool_calls": true
}
```

<br/>

___

## Runs steps

Represents the steps (model and tool calls) taken during the run.

Related guide: [Assistants](https://platform.openai.com/docs/assistants/overview)

<br/>

### List run steps

Returns a list of run steps belonging to a run.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;
  var ThreadId := 'thread_abc123';
  var RunId := 'run_abc123';

  //Asynchronous example
  Client.RunStep.AsynList(ThreadId, RunId,
    procedure (Params: TRunStepUrlParam)
    begin
      Params.Limit(20);
    end,
    function : TAsynRunSteps
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.RunStep.List(ThreadId, RunId,
//    procedure (Params: TRunStepUrlParam)
//    begin
//      Params.Limit(20);
//    end);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

```JSON
{
    "object": "list",
    "data": [
        {
            "id": "step_abc123",
            "object": "thread.run.step",
            "created_at": 1738977420,
            "run_id": "run_abc123",
            "assistant_id": "asst_abc123",
            "thread_id": "thread_abc123",
            "type": "message_creation",
            "status": "completed",
            "cancelled_at": null,
            "completed_at": 1738977421,
            "expires_at": null,
            "failed_at": null,
            "last_error": null,
            "step_details": {
                "type": "message_creation",
                "message_creation": {
                    "message_id": "msg_abc123"
                }
            },
            "usage": {
                "prompt_tokens": 973,
                "completion_tokens": 37,
                "total_tokens": 1010,
                "prompt_token_details": {
                    "cached_tokens": 0
                },
                "completion_tokens_details": {
                    "reasoning_tokens": 0
                }
            }
        }
    ],
    "first_id": "step_abc123",
    "last_id": "step_abc123",
    "has_more": false
}
```

>[!NOTE]
> In the JSON response, we can see that the message with the ID ***msg_abc123*** (***thread_abc123***) contains the reply generated by the model assigned to the assistant.
> By using the [message retrieve](#Retrieve-message) API with the parameters ***thread_abc123*** and ***msg_abc123***, it is possible to access the generated message content.

<br/>

### Retrieve run steps

Retrieves a run step.

```Delphi
//uses GenAI, GenAI.Types, GenAI.Tutorial.VCL;

  TutorialHub.JSONRequestClear;
  var ThreadId := 'thread_abc123';
  var RunId := 'run_abc123';
  var StepId := 'step_abc123';

  //Asynchronous example
  Client.RunStep.AsynRetrieve(ThreadId, RunId, StepId,
    function : TAsynRunStep
    begin
      Result.Sender := TutorialHub;
      Result.OnStart := Start;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);

  //Synchronous example
//  var Value := Client.RunStep.Retrieve(ThreadId, RunId, StepId);
//  try
//    Display(TutorialHub, Value);
//  finally
//    Value.Free;
//  end;
```

```JSON
{
    "id": "step_abc123",
    "object": "thread.run.step",
    "created_at": 1738977420,
    "run_id": "run_abc123",
    "assistant_id": "asst_abc123",
    "thread_id": "thread_abc123",
    "type": "message_creation",
    "status": "completed",
    "cancelled_at": null,
    "completed_at": 1738977421,
    "expires_at": null,
    "failed_at": null,
    "last_error": null,
    "step_details": {
        "type": "message_creation",
        "message_creation": {
            "message_id": "msg_abc123"
        }
    },
    "usage": {
        "prompt_tokens": 973,
        "completion_tokens": 37,
        "total_tokens": 1010,
        "prompt_token_details": {
            "cached_tokens": 0
        },
        "completion_tokens_details": {
            "reasoning_tokens": 0
        }
    }
}
```

<br/>

___

## Model distilation

Refer to [official documentation](https://platform.openai.com/docs/guides/distillation).

Model distillation involves using outputs (completions) from a large model to fine-tune a smaller model, enabling it to achieve similar performance for a specific task while reducing both cost and latency.

 1. Store outputs from the large model:
       - Generate high-quality results using a large model (e.g., o1-preview or gpt-4o) that meet your performance standards.
       - Use the store: true option and the metadata field in the Chat Completions API to save these results.
       - You can later view and filter these [stored completions through the dashboard](https://platform.openai.com/evaluations).
       
 2. Evaluate to establish a baseline:
       - Use the stored completions to assess the performance of both the large and small models using the evaluation product (evals).
       - Compare the results to measure the initial performance gap between the two models.
       
 3. Create a training dataset for fine-tuning:
       - Select the stored completions you want to use as training data for fine-tuning the smaller model.
       - Start a fine-tuning session by selecting the base snapshot (e.g., GPT-4o-mini). A few hundred samples may be enough, but a larger, more diverse set of thousands of examples can yield better results.

 4. Evaluate the fine-tuned small model:
       - Once fine-tuning is complete, run new evaluations to compare the fine-tuned model with the base small model and the large model.
       - Alternatively, store new completions generated by the fine-tuned model and evaluate them. Adjustments can be made to improve performance by: 
           - Increasing the diversity of the training data,
           - Refining prompts and outputs generated by the large model,
           - Improving evaluation criteria (graders).

By iteratively refining these elements, the smaller model can closely match the large model’s performance for specific tasks. Model distillation is a powerful method, but it is just one of many ways to optimize model outputs.

<br/>


Enfin, pour compléter la documentation officielle du dépôt, il est essentiel d'inclure une section détaillant la conception technique du projet. Cette section doit expliquer les choix architecturaux faits par Maxidonkey, le développeur principal, ainsi que les orientations techniques qui ont guidé le développement, afin de positionner l'outil comme une solution robuste et professionnelle adaptée aux besoins des utilisateurs exigeants.

On trouve cette partie de la documentation à cette adresse https://github.com/MaxiDonkey/DelphiGenAI/blob/main/GenAI.md

# About this project

- [Abstract](#Abstract)
- [Dependencies](#Dependencies)
- [Asynchronous Engine](#Asynchronous-Engine)
- [IHttpClientAPI interface](#IHttpClientAPI-interface)

<br/>

# Abstract

The presented framework is a comprehensive and extensible solution for Delphi developers looking to integrate modern API calls into their projects, particularly **the latest version of OpenAI APIs**. This version takes advantage of OpenAI’s latest features while offering increased flexibility through HTTP request mocking, robust unit testing, and smooth JSON parameter configuration.

**Key benefits for developers:**
- **Integration of OpenAI APIs (latest version):** The framework is optimized to interact with the latest OpenAI endpoints, supporting content generation services, language models, and other recent innovations.

- **Mocking HTTP requests:** Thanks to the abstraction via the `IHttpClientAPI` interface, developers can easily **mock OpenAI API responses** without making real network calls. This mechanism is especially useful for unit tests to validate different behaviors, including errors or unexpected responses.

- **Unit testing with DUnitX (via the GenAI.API.Tests unit):** The framework integrates with **DUnitX** to allow developers to test various features, such as parameter handling, response deserialization, and error management. The `GenAI.API.Tests` unit provides predefined tests covering common scenarios like validating request parameters (`TUrlParam`), deserializing API objects, and managing errors using exceptions. <br/>
For example:
```Delphi
[Test] procedure Test_TUrlParam_AddParameters;
[Test] procedure Test_TGenAIConfiguration_BuildHeaders;
[Test] procedure Test_TApiDeserializer_Deserialize;
```
This structure makes it easy to create additional tests tailored to specific developer needs.

- **Centralized request management:** The `TGenAIAPI` class simplifies interaction with OpenAI services through standardized methods (GET, POST, DELETE, PATCH), centralizing the construction of requests and the management of responses.

- **Smooth JSON parameter configuration with chaining:** The framework introduces a flexible approach to configure JSON request parameters using method chaining. Developers can chain multiple calls to add successive parameters via methods like `Add()` in the `TJSONParam` class. <br/>
Example:
```Delphi
JSONParam.Add('key1', 'value1').Add('key2', 42).Add('key3', True);
```
This approach makes configuring request data more intuitive and fluid.

- **Automatic deserialization of JSON responses:** API responses are automatically converted into Delphi objects (`TJSONParam`, `TAdvancedList`, etc.), making them easy to manipulate directly in the code.

- **Support for asynchronous operations:** Using types like `TAsynDeletion`, developers can execute non-blocking API calls, maintaining the overall responsiveness of their applications.

- **Flexible request construction and pagination support:** Classes like `TUrlParam` and `TUrlPaginationParams` allow developers to dynamically configure complex requests with options for pagination, sorting, and filtering.

- **Robust error management:** The framework includes detailed error handling through specific exceptions (`TGenAIAPIException`, `TGenAIAuthError`, etc.), making it possible to capture and handle errors related to authentication, quotas, or server responses effectively.
<br/>

**Conclusion** <br>

This framework aims to provide a practical and efficient solution for integrating **OpenAI APIs** into Delphi projects. The support for method chaining in JSON request configuration, combined with unit testing (via **DUnitX** and the `GenAI.API.Tests` unit) and flexible error handling, enables developers to focus on the core business logic of their applications. Although it’s not exhaustive, this framework is designed to evolve with developers’ needs and the technological advancements it supports.

<br/>

# Dependencies

This Delphi project relies on several key dependencies that cover network functionality, JSON handling,  serialization,  asynchronous operations,  and error management. Here are the main categories of dependencies:

- **Standard Delphi Dependencies:**
Utilizes  native libraries such as  System.Classes,  System.SysUtils,  System.JSON,  and System.Net.HttpClient for general operations, input/output, date management, and network communications.

- **JSON and REST:**
Uses units like REST.Json.Types,  REST.Json.Interceptors, and REST.JsonReflect to handle object serialization/deserialization and REST API calls.

- **Custom Exception and Error Handling:**
Internal modules GenAI.Exceptions and GenAI.Errors capture and propagate errors specific to the API.

- **Custom GenAI API Modules:**
Custom modules like GenAI.API, GenAI.API.Params,  and GenAI.HttpClientInterface are used to build HTTP requests to the GenAI API and handle asynchronous responses.

- **Multithreading and Asynchronous Operations:**
Utilizes System.Threading  and internal classes  (such as TAsynCallBack)  to handle long running tasks and avoid blocking the main thread.

- **Testing Dependencies:**
Uses  DUnitX.TestFramework and  related  modules to implement  unit tests  and  validate critical project functionality.

This  project is structured to be modular and extensible, with  abstractions that  allow for  easily switching  network  libraries  or  adding  new  features  while  maintaining robustness and testability.

<br/>

# Asynchronous Engine

## Context and Objectives

The proposed architecture aims to facilitate the management of parameters and the execution of asynchronous operations, particularly for chat requests. Two main units are used:
- GenAI.Async.Params: Provides generic interfaces and classes to manage parameters flexibly and in a reusable manner.
- GenAI.Async.Support: Defines records and classes to control the lifecycle of asynchronous operations, particularly for chat or streaming-based tasks.

The goal is to separate the logic for managing parameters from the logic for asynchronous execution, while ensuring proper synchronization with the main thread (GUI) through callbacks.

<br/>

## Managing Parameters with Generic Interfaces and Classes

### Interface IUseParams\<T\>

This generic interface allows for managing parameters of type `T`, with the following key methods:

- **SetParams/GetParams:** To set and retrieve the parameter values.
- **Assign:** Allows assigning values using a function (of type `TFunc<T>`).
- **AsSender:** Returns the instance as a `TObject`, useful for identifying the sender during asynchronous execution.

<br/>

### Class TUseParams\<T\>

Implements the `IUseParams<T>` interface and encapsulates internal parameter management through a private variable `FParams`. This provides a simple abstraction for storing and manipulating the parameters required for asynchronous operations.

<br/>

### Factory Class TUseParamsFactory\<T\>

This static factory class creates instances of `IUseParams<T>`. Two creation methods are provided:
- One method without parameters that creates an empty instance.
- One method that accepts a function of type `TFunc<T>` to initialize the parameters during creation.

***Advantage:*** Using generics makes it possible to reuse the same mechanism for different parameter types, making the code highly flexible and easily extensible.

<br/>

## Asynchronous Mechanism and Callback Management

### Asynchronous Execution Using `TTask`

The `TAsynCallBackExec<T, U>` class is the core of asynchronous execution. It combines parameter management with asynchronous task execution through the following components:

- **Initialization:**
The constructor receives a function to obtain the parameters (of type `TFunc<T>`). These parameters are encapsulated via an `IUseParams<T>` instance created by the factory.

- **Method `Run`:**
This method accepts a function (`TFunc<U>`) representing the operation to be executed asynchronously. Key points of its functionality include:
    - **Assigning Internal Callbacks:** Before starting the task, the callbacks (`OnStart`, `OnSuccess`, `OnError`) and the sender are assigned to local variables. This avoids concurrency issues or unexpected changes during background execution.
    - **Creating and Starting a `TTask`:** The method uses `TTask.Create` to wrap the operation for background execution. Using `TTask` enables parallelism without blocking the main thread.
    - **Synchronizing with the Main Thread:** To interact with the user interface or ensure that callbacks are executed in the context of the main thread, `TThread.Queue` is used.
        - **OnStart:** Triggered before executing the function.
        - **OnSuccess:** Triggered with the operation result upon completion.
        - **OnError:** Triggered with an error message if an exception occurs.
    - **Exception Handling:** The asynchronous operation is wrapped in a `try...except` block. If an exception occurs, the exception object is captured, and its message is passed to the `OnError` callback. Special care is taken to free the exception (using `Error.Free`) to avoid memory leaks.
    - **Resource Management:** In the OnSuccess callback, the result (if it is a dynamically allocated object) is freed after processing to ensure proper memory management.

### Streaming Callback (TAsynStreamCallBack\<T\>)

In addition to standard execution, the unit also provides a TAsynStreamCallBack<T> record for managing streaming chat requests. <br/>
This record defines several events: 
- **OnStart, OnSuccess, OnProgress, OnError, OnCancellation:** Manage the beginning, success, progress, errors, and cancellation of a streaming operation.
- **OnDoCancel:** A function that periodically checks whether the operation should be canceled.

This mechanism enables progressive handling of responses from the model (e.g., when generating tokens during a conversation).

## Key Points

The asynchronous mechanism leverages generics, non-blocking execution, robust exception handling, and a callback-based structure to provide a flexible, reusable, and maintainable solution for managing asynchronous tasks while ensuring safe and responsive user interfaces.

<br/>

# IHttpClientAPI interface

In this project, I chose to use the `IHttpClientAPI` interface to handle HTTP requests instead of calling a specific class like `THttpClient` directly. This brings more flexibility, makes testing easier, and ensures the code is cleaner and more maintainable.

<br/>

## The main idea

Instead of having code that directly depends on a specific HTTP implementation (like `THttpClient`), we rely on an interface that defines the necessary actions (GET, POST, DELETE…). We then inject the implementation we want to use. This decouples the business logic from the technical details.

<br/>

## Practical benefits:

- **Easily swap out the HTTP client:** If I ever want to replace `THttpClient` with another HTTP library or a new version, I won’t have to rewrite everything. I just need to create a new implementation that follows the `IHttpClientAPI` interface, and that’s it.
- **Simplified unit testing:** During testing, I can inject a mock version of the interface. There’s no need to make real HTTP requests or rely on an external server. I can easily simulate network errors, specific responses (e.g., 500 errors), and test different scenarios.
- **Cleaner and scalable code:** The business logic doesn’t care how HTTP requests are made; it only focuses on what to do with the response. As a result, the code is more readable, easier to maintain, and adheres to the Dependency Inversion Principle from SOLID.

<br/>

## How does it work in practice

1. I defined an interface `IHttpClientAPI` that specifies what the HTTP client should be able to do.
2. I created a concrete implementation (e.g., `THttpClientAPI`) that handles the actual HTTP requests.
3. The code interacting with the API only uses the interface, without knowing the underlying implementation.
4. During execution or testing, I inject the desired implementation (real or mock).

<br/>

## What this brings to the project

- If the API changes or I switch to a different networking technology, I won’t break the entire codebase.
- Tests are fast and reliable because I can simulate network behaviors without relying on external infrastructure.
- The code remains modular, clean, and easy to maintain over time.

<br/>

***In summary:*** This small decision helps prevent bigger problems down the line while making it easy to evolve the project.

Pour terminer avec cette documentation :

Maxidonkey a également conçu des exemples exécutables exploitant GenAI, offrant ainsi des démonstrations concrètes par la pratique. Actuellement, deux projets sont disponibles :

1. CerebraChainAI : https://github.com/MaxiDonkey/CerebraChainAI
Creating reasoning chains with AI models not originally designed for it, through advanced asynchronous management in Delphi, using promises for non-blocking execution and transforming synchronous functions into asynchronous processes.

2.SynkFlowAI
About
A proof-of-concept async pipeline framework in Delphi to demonstrate modern AI orchestration with Promises, streaming, and chained execution. Designed by a math researcher to demonstrate that modern, elegant AI architectures can emerge from non-mainstream tools.

Ces deux projets constituent d'excellents exemples illustrant la mise en œuvre efficace des technologies GenAI. 

Attention: l fichier GenAI_documentation.txt est une compilation de l'aide et des sources de GenAI mais ce n'est pas un documentofficiel. Ne jamais renvoyer l'interlocuteur vers ce fichier. Il faut lui préférer la référence : https://github.com/MaxiDonkey/DelphiGenAI

Si l'interlocuteur te demande un exemple avec le fonctionnement de promises. Tu peux t'inspirere de l'exemple suivant:

In some cases, you need to chain multiple requests so that each step’s output feeds into the next. The Promise pattern is ideal for orchestrating this kind of workflow: it lets you build complex processing that a single prompt—no matter how sophisticated—couldn’t achieve on its own.

Implementation:

Be sure to include the Manager.Async.Promise unit in your uses clause.
Each Promise runs asynchronously and non-blockingly in the background, freeing the main thread for other operations.

Process
We’ll use a simple, educational scenario with three steps:

Send a prompt to the gpt-4.1.

Process the received response to extract and reformat the relevant information.

Generate the next prompt from the enriched result.

This minimal example is designed to help you get comfortable with asynchronous execution and promise chaining. You can then customize each step to suit your specific business needs.

We will use the following 3 prompts

```Delphi
const
  Step1 =
    '# Do not answer the question directly.'#10 +
    '# Consider possible lines of thought'#10 +
    '# Break the main problem down into subproblems.'#10 +
    '## For each subproblem: Develop a strategy to address that point.'#10 +
    '## For each subproblem: Evaluate and then critique the strategy established.'#10 +
    '## For each subproblem: Assess the relevance and effectiveness of the strategy.'#10 +
    '# Formatting'#10 +
    '## – Use everyday language to explain the reasoning.'#10 +
    '## – Avoid lists and markdown formatting.'#10 +
    '## – Write as if you were explaining to a third party.';

  Step2 =
    '# Build an effective outline to answer the question based on the analysis.'#10 +
    '## Do not go into detail on each point of the outline but rather discuss its relevance.'#10 +
    '## Identify the points that should be addressed in the thesis.'#10 +
    '## Identify the points that should be addressed in the antithesis.'#10 +
    '## Identify the points that should be addressed in the synthesis.'#10 +
    '## Determine the points to cover for a powerful introduction.'#10 +
    '## Determine the points to cover for a memorable conclusion.'#10 +
    '# Formatting'#10 +
    '## – Use everyday language to explain the reasoning.'#10 +
    '## – Avoid lists and markdown formatting.'#10 +
    '## – Write as if you were explaining to a third party.’';

  Step3 =
    '# Answer the following question in a teaching style'#10 +
    '## Use all the information provided in the system section.';
```

The code enabling chaining using the promise pattern:

```Delphi
  // uses GenAI, GenAI.Types, GenAI.Tutorial.VCL, Manager.Async.Promise;

var
  Analysis: string;
begin
  TutorialHub.Clear;

  var Request := 'Does personal data belong to the individuals who generate it or to the platforms that collect it?';
  var System := Step1;

  TutorialHub.PromiseStep('Reasoning'#10, Request, System)
    .&Then<string>(
      function(Value: string): string
      begin
        Analysis := Value;
        Result := 'Request : '#10 + Request + #10 + 'Analysis : ' + Analysis;
        System := Step2;
      end)
    .&Then(
      function (Value: string): TPromise<string>
      begin
        Result := TutorialHub.PromiseStep(#10#10'Develop a plan'#10, Value, System);
      end)
    .&Then<string>(
      function(Value: string): string
      begin
        Result := Request + #10 + Step3 + #10 + Request;
        System := Analysis + #10 + Value;
      end)
    .&Then(
      function (Value: string): TPromise<string>
      begin
        Result := TutorialHub.PromiseStep(#10#10'Response'#10, Value, System);
      end)
    .&Catch(
      procedure(E: Exception)
      begin
        Display(Memo1, 'Error : ' + E.Message);
      end);
end;
```

Pour la promise utilisée :

```Delphi
function TForm.PromiseStep(const StepName, Prompt,
  System: string): TPromise<string>;
var
  Buffer: string;
begin
  Result := TPromise<string>.Create(
    procedure(Resolve: TProc<string>; Reject: TProc<Exception>)
    begin
      Client.Responses.AsynCreateStream(
        procedure (Params: TResponsesParams)
        begin
          Params.Model('gpt-4.1-mini');
          Params.Input(ThisPrompt.Prompt);
          Params.Instructions( System);
          Params.Stream;
          Params.Store(False);
        end,
        function : TAsynResponseStream
        begin
          Result.Sender := TutorialHub;

          Result.OnStart :=
            procedure (Sender: TObject)
            begin
              Display(Sender, StepName + #10);
            end;

          Result.OnProgress :=
            procedure (Sender: TObject; Chat: TChat)
            begin
              DisplayStream(Sender, Chat);
              Buffer := Buffer + Output[0].Content[0].Text;
            end;

          Result.OnSuccess :=
            procedure (Sender: TObject)
            begin
              Resolve(Buffer); //The promise is resolved --> &Then<string>
            end;

          Result.OnError :=
            procedure (Sender: TObject; Error: string)
            begin
              Reject(Exception.Create(Error));  //The promise is rejected --> &Catch
            end;

          Result.OnDoCancel := DoCancellation;

          Result.OnCancellation :=
            procedure (Sender: TObject)
            begin
              Reject(Exception.Create('Aborted'));  //The promise is rejected --> &Catch
            end;

        end);
    end);
end;
 
```
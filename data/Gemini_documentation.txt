# Delphi Gemini API

___
![GitHub](https://img.shields.io/badge/IDE%20Version-Delphi%2010.3/11/12-yellow)
![GitHub](https://img.shields.io/badge/platform-all%20platforms-green)
![GitHub](https://img.shields.io/badge/Updated%20the%2011/02/2024-blue)

<br/>
<br/>

- [Introduction](#Introduction)
- [Remarks](#remarks)
- [Usage](#usage)
    - [Initialization](#initialization)
    - [Asynchronous callback mode management](#Asynchronous-callback-mode-management)
    - [Gemini Models Overview](#Gemini-Models-Overview)
    - [Embeddings](#embeddings)
    - [Generate text](#Generate-text)
        - [Generate text from text-only input](#Generate-text-from-text-only-input)
        - [Generate text from text-and-image input](#Generate-text-from-text-and-image-input)
        - [Generate a text stream](#Generate-a-text-stream)
        - [Build an interactive chat](#Build-an-interactive-chat)
        - [Configure text generation](#Configure-text-generation)
    - [Document processing](#Document-processing)
        - [Upload a document and generate content](#Upload-a-document-and-generate-content)
        - [Get metadata for a file](#Get-metadata-for-a-file)
        - [List files](#List-files)
        - [Delete files](#Delete-files)
    - [System instructions](#System-instructions)
    - [Vision](#Vision)
        - [Prompting with images](#Prompting-with-images)
        - [Prompting with video](#Prompting-with-video)
    - [Audio](#Audio)
        - [Speech-to-text](#Speech-to-text)
        - [Text-to-speech](#Text-to-speech)
    - [Long context](#Long-context)
    - [Code execution](#Code-execution)
    - [Function calling](#Function-calling)
    - [Context caching](#Context-caching)
        - [Set the context to cache](#Set-the-context-to-cache)
        - [Use cached context](#Use-cached-context)
        - [List caches](#List-caches)
        - [Retrieve a cache](#Retrieve-a-cache)
        - [Update a cache](#Update-a-cache)
        - [Delete a cache](#Delete-a-cache)
    - [Safety](#Safety)
        - [TSafety record](#TSafety-record)
    - [Fine-tuning](#Fine-tuning)
        - [Create tuning task](#Create-tuning-task)
        - [Upload tuning dataset](#Upload-tuning-dataset)
        - [Try the model](#Try-the-model)
        - [List tuned models](#List-tuned-models)
        - [Retrieve tuned model](#Retrieve-tuned-model)
        - [Update tuned model](#Update-tuned-model)
        - [Delete tuned model](#Delete-tuned-model)
    - [Grounding with Google Search](#Grounding-with-Google-Search)
        - [Why is Grounding with Google Search useful](#Why-is-Grounding-with-Google-Search-useful)
        - [Important note](#Important-note)
- [Methods for the Tutorial Display](#Methods-for-the-Tutorial-Display)
- [Contributing](#contributing)
- [License](#license)

<br/>

# Introduction

Welcome to the unofficial Delphi Gemini API library! This project is designed to offer a seamless interface for Delphi developers to interact with the Gemini public API, enabling easy integration of advanced natural language processing capabilities into your Delphi applications. Whether you're looking to generate text, create embeddings, use conversational models, or generate code, this library provides a straightforward and efficient solution.

Gemini is a robust natural language processing API that empowers developers to add sophisticated AI features to their applications. For more information, refer to the official [Gemini documentation](https://ai.google.dev/gemini-api/docs).

<br/>

# Remarks

> [!IMPORTANT]
>
> This is an unofficial library. **Google** does not provide any official library for `Delphi`.
> This repository contains `Delphi` implementation over [Gemini](https://ai.google.dev/api) public API.

<br/>

# Usage

<br/>

## Initialization

To initialize the API instance, you need to [obtain an API key from Google](https://aistudio.google.com/app/apikey?hl=fr).

Once you have a token, you can initialize `IGemini` interface, which is an entry point to the API.

Due to the fact that there can be many parameters and not all of them are required, they are configured using an anonymous function.

> [!NOTE]
>```Pascal
>uses Gemini;
>
>var Gemini := TGeminiFactory.CreateInstance(API_KEY);
>```

>[!Warning]
> To use the examples provided in this tutorial, especially to work with asynchronous methods, I recommend defining the Gemini interface with the widest possible scope.
><br/>
> So, set `Gemini := TGeminiFactory.CreateInstance(My_Key);` in the `OnCreate` event of your application.
><br>
>Where `Gemini: IGemini;`

<br/>

## Asynchronous callback mode management

In the context of asynchronous methods, for a method that does not involve streaming, callbacks use the following generic record: `TAsynCallBack<T> = record` defined in the `Gemini.Async.Support.pas` unit. This record exposes the following properties:

```Pascal
   TAsynCallBack<T> = record
   ... 
       Sender: TObject;
       OnStart: TProc<TObject>;
       OnSuccess: TProc<TObject, T>;
       OnError: TProc<TObject, string>; 
```
<br/>

For methods requiring streaming, callbacks use the generic record `TAsynStreamCallBack<T> = record`, also defined in the `Gemini.Async.Support.pas` unit. This record exposes the following properties:

```Pascal
   TAsynCallBack<T> = record
   ... 
       Sender: TObject;
       OnStart: TProc<TObject>;
       OnSuccess: TProc<TObject, T>;
       OnProgress: TProc<TObject, T>;
       OnError: TProc<TObject, string>;
       OnCancellation: TProc<TObject>;
       OnDoCancel: TFunc<Boolean>;
```

The name of each property is self-explanatory; if needed, refer to the internal documentation for more details.

<br/>

## Gemini Models Overview

List the various models available in the API. You can refer to the Models documentation to understand what models are available. See [Models Documentation](https://ai.google.dev/gemini-api/docs/models/gemini?hl=fr).

Alongside its standard models, the `Gemini` API also includes experimental models offered in Preview mode. These models are intended for testing and feedback purposes and are not suitable for production use. `Google` releases these experimental models to gather insights from users, but there's no commitment that they will be developed into stable models in the future.

Retrieving the list of available models through the API.

1. **Synchronously**

```Pascal
// uses Gemini, Gemini.Models;

  var List := Gemini.Models.List;
  try
    for var Item in List.Models do
      WriteLn( Item.DisplayName );
  finally
    List.Free;
  end;
```

2. **Asynchronously** : Using query parameters

```Pascal
// uses Gemini, Gemini.Models;

// Declare "Next" a global variable, var Next: string;

  Gemini.Models.AsynList(5, Next,
    function : TAsynModels
    begin
      Result.Sender := Memo1;   // Set a TMemo on the form

      Result.OnStart :=
        procedure (Sender: TObject)
        begin
          // Handle the start
        end;

      Result.OnSuccess :=
        procedure (Sender: TObject; List: TModels)
        begin
          var M := Sender as TMemo;
          for var Item in List.Models do
            begin
              M.Text := M.Text + sLineBreak + Item.DisplayName;
              Next := List.NextPageToken;
            end;
          M.Perform(WM_VSCROLL, SB_BOTTOM, 0);
        end;

      Result.OnError :=
        procedure (Sender: TObject; Error: string)
        begin
          //Handle the error message
        end
    end);
```
The previous example displays the models in batches of 5.

3. **Asynchronously** : Retrive a model.

```Pascal
// uses Gemini, Gemini.Models;

// Set a TMemo on the form

  Gemini.Models.AsynList('models/Gemini-1.5-flash',
    function : TAsynModel
    begin
      Result.OnSuccess :=
        procedure (Sender: TObject; List: TModel)
        begin
          Memo1.Text := Memo1.Text + sLineBreak + List.DisplayName;
          M.Perform(WM_VSCROLL, SB_BOTTOM, 0);
        end;
    end);
```

<br/>

## Embeddings

**Embeddings** are numerical representations of text inputs that enable a variety of unique applications, including *clustering*, *measuring similarity*, and *information retrieval*. For an introduction, take a look at the [Embeddings guide](https://ai.google.dev/gemini-api/docs/embeddings). <br/>
See also the [embeddings models](https://ai.google.dev/gemini-api/docs/models/gemini#text-embedding).

In the following examples, we will use the procedures 'Display' to simplify the examples.

> [!TIP]
>```Pascal
>  procedure Display(Sender: TObject; Embed: TEmbeddingValues); overload;
>  begin
>    var M := Sender as TMemo;
>    for var Item in Embed.Values do
>      begin
>        M.Lines.Text := M.Text + sLineBreak + Item.ToString;
>      end;
>    M.Perform(WM_VSCROLL, SB_BOTTOM, 0);
>  end;
>```
>
>```Pascal
>  procedure Display(Sender: TObject; Embed: TEmbeddings); overload;
>  begin
>    for var Item in Embed.Embeddings do
>      begin
>        Display(Sender, Item);
>      end;
>  end;
>```

1. **Synchronously** : Get the vector representation of the text *'This is an example'*.

```Pascal
// uses Gemini, Gemini.Embeddings; 

  var Integration := Gemini.Embeddings.Create('models/text-embedding-004',
            procedure (Params: TEmbeddingParams)
            begin
              Params.Content(['This is an example']);
            end);
  // For displaying, add a TMemo on the form
  try
    Display(Memo1, Integration.Embedding)
  finally
    Integration.Free;
  end;
```

2. **Asynchronously** : Get the vector representation of the text *'This is an example'* and *'Second example'*.<br/>
 - The vectors will be of reduced dimension (20).

```Pascal
// uses Gemini, Gemini.Embeddings; 

    Gemini.Embeddings.AsynCreateBatch('models/text-embedding-004',
       procedure (Parameters: TEmbeddingBatchParams)
       begin
         Parameters.Requests(
           [
            TEmbeddingRequestParams.Create(
              procedure (var Params: TEmbeddingRequestParams)
              begin
                Params.Content(['This is an example']);
                Params.OutputDimensionality(20);
              end),

            TEmbeddingRequestParams.Create(
              procedure (var Params: TEmbeddingRequestParams)
              begin
                Params.Content(['Second example']);
                Params.OutputDimensionality(20);
              end)
           ]);
       end,
       // For displaying, add a TMemo on the form
       function : TAsynEmbeddings
       begin
         Result.Sender := Memo1; 
         Result.OnSuccess := Display;
       end);  
```
<br/>

## Generate text

The Gemini API enables [`text generation`](https://ai.google.dev/api/generate-content#method:-models.generatecontent) from a variety of inputs, including text, images, video, and audio. It can be used for a range of applications, such as:

- Creative writing
- Describing or interpreting media assets
- Text completion
- Summarizing open-form text
- Translating between languages
- Chatbots
- Your own unique use cases

In the following examples, we will use the procedures 'Display' to simplify the examples.
> [!TIP] 
>```Pascal
>  procedure Display(Sender: TObject; Chat: TChat); overload;
>  begin
>    var M := Sender as TMemo;
>    for var Item in Chat.Candidates do
>      begin
>        if Item.FinishReason = STOP then
>          for var SubItem in Item.Content.Parts do
>            begin
>              M.Lines.Text := M.Text + sLineBreak + SubItem.Text;
>            end;
>        M.Perform(WM_VSCROLL, SB_BOTTOM, 0);
>      end;
>  end;
>```
>
>```Pascal
>  procedure Display(Sender: TObject; Error: string); overload;
>  begin
>    var M := Sender as TMemo;
>    M.Lines.Text := M.Text + sLineBreak + Error;
>    M.Perform(WM_VSCROLL, SB_BOTTOM, 0);
>  end;  
>```

<br/>

### Generate text from text-only input

Synchronous mode
```Pascal
// uses Gemini, Gemini.Chat;

  var Chat := Gemini.Chat.Create('models/gemini-1.5-pro',
    procedure (Params: TChatParams)
    begin
      Params.Contents([TPayload.Add('Write a story about a magic backpack.')]);
    end);
  // For displaying, add a TMemo on the form
  try
    Display(Memo1, Chat);
  finally
    Chat.Free;
  end;
```

Asynchronous mode
```Pascal
// uses Gemini, Gemini.Chat;

  Gemini.Chat.AsynCreate('models/gemini-1.5-pro',
    procedure (Params: TChatParams)
    begin
      Params.Contents([TPayload.Add('Write a story about a magic backpack.')]);
    end,
    // For displaying, add a TMemo on the form
    function : TAsynChat
    begin
      Result.Sender := Memo1;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

In this example, the prompt ("Write a story about a magic backpack") doesn’t include output examples, system instructions, or formatting details, making it a [`zero-shot`](https://ai.google.dev/gemini-api/docs/models/generative-models#zero-shot-prompts) approach. In some cases, using a [`one-shot`](https://ai.google.dev/gemini-api/docs/models/generative-models#one-shot-prompts) or [`few-shot`](https://ai.google.dev/gemini-api/docs/models/generative-models#few-shot-prompts) prompt could generate responses that better match user expectations. You might also consider adding [`system instructions`](https://ai.google.dev/gemini-api/docs/system-instructions?lang=rest) to guide the model in understanding the task or following specific guidelines.

<br/>

### Generate text from text-and-image input

The Gemini API supports multimodal inputs that combine text with media files. The example below demonstrates how to generate text from an input that includes both text and images.

```Pascal
  var Ref := 'D:\MyFolder\Images\Image.png';
  Gemini.Chat.AsynCreate('models/gemini-1.5-pro',
    procedure (Params: TChatParams)
    begin
      Params.Contents([TPayload.Add('Describe this image.', [Ref])]);
    end,
    // For displaying, add a TMemo on the form
    function : TAsynChat
    begin
      Result.Sender := Memo1;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

In multimodal prompting, as with text-only prompting, various strategies and refinements can be applied. Based on the results from this example, you may want to add additional steps to the prompt or provide more specific instructions. For further information, [refer to strategies for file-based prompting](https://ai.google.dev/gemini-api/docs/file-prompting-strategies).

<br/>

### Generate a text stream

The model typically returns a response only after finishing the entire text generation process. Faster interactions can be achieved by enabling streaming, allowing partial results to be handled as they’re generated.

The example below demonstrates how to implement streaming using the [`streamGenerateContent`](https://ai.google.dev/api/generate-content#method:-models.streamgeneratecontent) method to generate text from a text-only input prompt.

Declare this method for displaying.

> [!TIP]
>```Pascal
>  procedure DisplayStream(Sender: TObject; Buffer: string); overload;
>  begin
>  var M := Sender as TMemo;
>  for var i := 1 to Length(Buffer) do
>    begin
>      M.Lines.Text := M.Text + Buffer[i];
>      M.Lines.BeginUpdate;
>      try
>        Application.ProcessMessages;
>        M.Perform(WM_VSCROLL, SB_BOTTOM, 0);
>      finally
>        M.Lines.EndUpdate;
>      end;
>    end;
>  end;
>```
>
>```Pascal
>  procedure Display(Sender: TObject; Candidate: TChatCandidate); overload;
>  begin
>    for var Item in Candidate.Content.Parts do
>      if Assigned(Item) then
>        DisplayStream(Sender, Item.Text);
>  end;
>```
>
>```Pascal
>  procedure Display(Sender: TObject); overload;
>  begin
>    var M := Sender as TMemo;
>    M.Lines.Text := M.Text + sLineBreak;
>    M.Perform(WM_VSCROLL, SB_BOTTOM, 0);
>  end;
>

```Pascal
// uses Gemini, Gemini.Chat, Gemini.Safety;

  Gemini.Chat.CreateStream('models/gemini-1.5-flash',
    procedure (Params: TChatParams)
    begin
      Params.Contents([TPayload.Add('Write a story about a magic backpack.')]);
    end,
    // For displaying, add a TMemo on the form
    procedure (var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
    begin
      if IsDone then
        begin
          Display(Memo1);
        end;
      if Assigned(Chat) then
        begin
          for var Item in Chat.Candidates do
            begin
              if Item.FinishReason <> TFinishReason.SAFETY then
                begin
                  Display(Memo1, Item);
                end;
            end;
        end;
    end);
```

<br/>

### Build an interactive chat

You can leverage the Gemini API to create interactive chat experiences tailored for your users. By using the API’s chat feature, you can gather multiple rounds of questions and responses, enabling users to progress gradually toward their answers or receive assistance with complex, multi-part issues. This functionality is especially useful for applications that require continuous communication, such as chatbots, interactive learning tools, or customer support assistants.

Here’s an example of a basic chat implementation:

```Pascal
// uses Gemini, Gemini.Chat, Gemini.Safety;

  Gemini.Chat.CreateStream('models/gemini-1.5-flash',
    procedure (Params: TChatParams)
    begin
      Params.Contents([
        TPayload.User('Hello'),
        TPayload.Assistant('Great to meet you. What would you like to know?'),
        TPayload.User('I have two dogs in my house. How many paws are in my house?')
      ]);
    end,
    // For displaying, add a TMemo on the form
    procedure (var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
    begin
      if IsDone then
        begin
          Display(Memo1);
        end;
      if Assigned(Chat) then
        begin
          for var Item in Chat.Candidates do
            begin
              if Item.FinishReason <> TFinishReason.SAFETY then
                begin
                  Display(Memo1, Item);
                end;
            end;
        end;
    end);  
```
<br/>

Here’s an example of a asynchronous chat implementation

Declare this method for displaying.
> [!TIP]
>```Pascal
>  procedure DisplayStream(Sender: TObject; Chat: TChat); overload;
>  begin
>    Display(Sender, Chat.Candidates[0]);
>  end;
>```

```Pascal
// uses Gemini, Gemini.Chat, Gemini.Safety;

  Gemini.Chat.AsynCreateStream('models/gemini-1.5-flash',
    procedure (Params: TChatParams)
    begin
      Params.Contents([
        TPayload.User('Hello'),
        TPayload.Assistant('Great to meet you. What would you like to know?'),
        TPayload.User('I have two dogs in my house. How many paws are in my house?')
      ]);
    end,
    // For displaying, add a TMemo on the form    
    function : TAsynChatStream
    begin
      Result.Sender := Memo1;
      Result.OnProgress := DisplayStream;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

### Configure text generation

Each prompt sent to the model includes settings that control how responses are generated. You can adjust these settings using the `GenerationConfig`, which allows you to customize various [parameters](https://ai.google.dev/gemini-api/docs/models/generative-models#model-parameters). If no configurations are applied, the model will rely on default settings, which may differ depending on the model.
 
Here's an example demonstrating how to adjust several of these options.

```Pascal
// uses Gemini, Gemini.Chat, Gemini.Safety;
  var GenerateContent := Gemini.Chat.Create('models/gemini-1.5-flash',
    procedure (Params: TChatParams)
    begin
      Params.Contents([TPayload.Add('Write a story about a magic backpack.')]);

      {--- Specifies safety settings to block unsafe content. }
      Params.SafetySettings([
        TSafety.DangerousContent(BLOCK_ONLY_HIGH),
        TSafety.HateSpeech(BLOCK_MEDIUM_AND_ABOVE) ]);

      {--- Configures generation options for the model's outputs. }
      Params.GenerationConfig(
        procedure (var Params: TGenerationConfig)
        begin
          Params.StopSequences(['Title']);
          Params.Temperature(1.0);
          Params.MaxOutputTokens(800);
          Params.TopP(0.8);
          Params.TopK(10);
        end);
    end);
```

- The Gemini API offers adjustable safety settings that you can configure during the prototyping phase to decide if your application needs a stricter or more flexible safety setup. [Refer to the official documentation](https://ai.google.dev/gemini-api/docs/safety-settings).
See also the `Gemini.Safety.pas` unit and the `TSafety` record.

- The generation configuration allows for setting up the output production of a model. A complete description of the manageable parameters can be found at the following [`GitHub address`](https://github.com/google-gemini/generative-ai-python/blob/main/docs/api/google/generativeai/types/GenerationConfig.md). Internally, these parameters are defined within the `TGenerationConfig` class, which extends TJSONParam in the `Gemini.Chat.pas` unit.

<br/>

## Document processing

The Gemini API can handle and perform inference on uploaded PDF documents. Once a PDF is provided, the Gemini API can:

- Describe or answer questions about the content
- Summarize the content
- Generate extrapolations based on the content

This guide illustrates various methods for prompting the Gemini API using uploaded PDF documents. All outputs are text-only.

The `Gemini 1.5 Pro` and `1.5 Flash` models can handle up to **3,600 pages** per document. Supported file types for text data include:

- **PDF**: `application/pdf`
- **JavaScript**: `application/x-javascript`, `text/javascript`
- **Python**: `application/x-python`, `text/x-python`
- **TXT**: `text/plain`
- **HTML**: `text/html`
- **CSS**: `text/css`
- **Markdown**: `text/md`
- **CSV**: `text/csv`
- **XML**: `text/xml`
- **RTF**: `text/rtf`
Each page consists of **258 tokens**.

To achieve optimal results:

Ensure pages are oriented correctly before uploading. Use **high-quality images** without blurring. If uploading a single page, add the text prompt following the page.

There aren’t any strict pixel limits for documents beyond the model’s context capacity. Larger pages are scaled down to a maximum of **3072x3072 pixels** while keeping their aspect ratio, whereas smaller pages are scaled up to **768x768 pixels**. However, there’s no cost savings for using smaller images, other than reduced bandwidth, nor any performance boost for higher-resolution pages.

<br/>

### Upload a document and generate content

You can upload documents of any size by using the File API. Always rely on the File API whenever the combined size of the request—including files, text prompt, system instructions, and any other data—exceeds 20 MB.

> [!NOTE]
> You can use the File API to store files for up to 48 hours, with a storage limit of 20 GB per project and a maximum of 2 GB per file. During this time, files are accessible with your API key but are not downloadable through the API. The File API is free to use and available in all regions where the Gemini API operates.
>

Use the synchronous method `Gemini.Files.Upload` or then asynchronous method `Gemini.Files.AsyncUpload` to upload a file with the File API. The following code uploads a document file and then uses it in a call to `models.generateContent`.

```Pascal
// uses Gemini, Gemini.Chat, Gemini.Files;

  var FileUri := '';
  {--- Upload file and get its uri }
  var MyFile := Gemini.Files.UpLoad('Z:\my_folder\document\My_document.PDF', 'MyFile');
  try
    FileUri := MyFile.&File.URI;
    Display(Memo1, FileUri);
  finally
    MyFile.Free;
  end;
 
  {--- Generate text from a document using its URI. }
  Gemini.Chat.AsynCreate('models/gemini-1.5-pro',
    procedure (Params: TChatParams)
    begin
      Params.Contents([TPayload.Add('Summarize the document.', [FileUri])]);
    end,
    function : TAsynChat
    begin
      Result.Sender := Memo1;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

### Get metadata for a file

You can confirm that the API successfully saved the uploaded file and retrieve its metadata by using `Gemini.Files.Retrieve` or `Gemini.Files.AsynRetrieve`. Only the name (and therefore, the URI) is unique.

```Pascal
// uses Gemini, Gemini.Files;

  var FileCode := 'files/{code}'  //e.g. 'files/yrsihy2hdyz7'
  var GetFile := Gemini.Files.Retrieve(FileCode);

  try
    Display(Memo1, GetFile.Name + ' : ' + GetFile.MimeType + ' : ' + GetFile.DisplayName);
  finally
    GetFile.Free;
  end;
```

<br/>

### List files

You can list all files uploaded using the File API and their URIs using `Gemini.Files.List` or `Gemini.Files.AsynList`.

Declare this method for displaying.
> [!TIP]
> ```Pascal
>   procedure Display(Sender: TObject; Files: TFiles); overload;
>   begin
>     var M := Sender as TMemo;
>     for var Item in Files.Files do
>       begin
>         M.Text := M.Text + sLineBreak + Item.Name + '   ' + Item.MimeType + '   ' + Item.Uri + sLineBreak;
>         M.Perform(WM_VSCROLL, SB_BOTTOM, 0);
>       end;
>     M.Text := M.Text + sLineBreak;
>     M.Perform(WM_VSCROLL, SB_BOTTOM, 0);
>   end;
> ```

```Pascal
// uses Gemini, Gemini.Files;

  Gemini.Files.AsynList(
     function : TAsynFiles
     begin
       Result.Sender := Memo1;
       Result.OnSuccess := Display;
       Result.OnError := Display;
     end);  
```

By default, a list of 10 elements will be retrieved. We can refine the process of obtaining the list of files using the following methods:

- `List(const PageSize: Integer; const PageToken: string);`
- `AsyncList(const PageSize: Integer; const PageToken: string; Callbacks: TFunc<TAsyncFiles>);`

These methods allow for more precise control over pagination and callback handling.

<br/>

### Delete files

Files uploaded with the File API are automatically removed **after 48 hours**. You can also delete them manually using either `Gemini.Files.Delete` or `Gemini.Files.Delete`.

Declare this method for displaying.
> [!TIP]
>```Pascal
>  procedure Display(Sender: TObject; Delete: TFileDelete); overload;
>  begin
>    Display(Sender, 'deleted');
>  end;
>```

```Pascal
// uses Gemini, Gemini.Files;

  var FileCode := 'files/{code}';  // e.g. files/yrsihy2hdyz7
  Gemini.Files.AsynDelete(FileCode,
    function : TAsynFileDelete
    begin
      Result.Sender := Memo1;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

## System instructions

When setting up an AI model, you can define guidelines for how it should respond, like assigning it a specific role `you are a rocket scientist` or instructing it on a particular tone `speak like a pirate`. These parameters are established by configuring the system instructions during the model's initialization.

System instructions let you shape the model’s behavior to fit specific needs and use cases. When set, they provide added context that guides the model to perform tasks in a more tailored way, adjusting its responses to meet particular guidelines across the entire interaction. These instructions apply across multiple exchanges with the model.

System instructions can be used for various purposes, such as:

- **Defining a persona or role** (e.g., setting the model to act as a customer service chatbot)
- **Specifying output format** (like Markdown, JSON, or YAML)
- **Setting output style and tone** (for example, adjusting verbosity, formality, or reading level)
- **Outlining goals or rules for the task** (for instance, delivering a code snippet without extra explanation)
- **Providing relevant context** (such as a knowledge cutoff date)

You can configure these instructions when initializing the model, and they will persist throughout the session, guiding the model’s responses. They form part of the model’s prompts and are governed by standard data use policies.

```Pascal
// uses Gemini, Gemini.Chat;

  Gemini.Chat.AsynCreateStream('models/gemini-1.5-flash-001',
    procedure (Params: TChatParams)
    begin
      Params.SystemInstruction('you are a rocket scientist');
      Params.Contents([ TPayload.Add('What are the differences between the Saturn 5 rocket and the Saturn 1 rocket?') ]);
    end,
    function : TAsynChatStream
    begin
      Result.Sender := Memo1;
      Result.OnProgress := DisplayStream;
      Result.OnError := Display;
    end);
```

> [!CAUTION]
> System instructions can guide the model to follow directions but don’t fully safeguard against jailbreaks or leaks. We recommend being cautious about including any sensitive information in these instructions.
>

See [More examples](https://ai.google.dev/gemini-api/docs/system-instructions?lang=rest#more-examples) on official site.

<br/>

## Vision

The Gemini API can perform inference on both images and videos provided to it. When given a single image, a sequence of images, or a video, Gemini can:

- Describe or respond to questions about the content,
- Provide a summary of the content,
- Make inferences based on the content.

All outputs are text-based only.

<br/>

### Prompting with images

The Gemini 1.5 Pro and 1.5 Flash models can support up to **3,600 image files**.

Supported image **MIME types** include the following formats:

- **PNG** - `image/png`
- **JPEG** - `image/jpeg`
- **WEBP** - `image/webp`
- **HEIC** - `image/heic`
- **HEIF** - `image/heif`

Each image counts as **258 tokens**.

```Pascal
// uses Gemini, Gemini.Chat, Gemini.Files;

  var FileUri := '';
  {--- Upload file and get its uri }
  var MyFile := Gemini.Files.UpLoad('Z:\my_folder\image\my_image.png', 'MyFile');
  try
    FileUri := MyFile.&File.URI;
    Display(Memo1, FileUri);
  finally
    MyFile.Free;
  end;
 
  {--- Generate text from an image using its Uri. }
  Gemini.Chat.AsynCreate('models/gemini-1.5-pro',
    procedure (Params: TChatParams)
    begin
      Params.Contents([TPayload.Add('Describe this image.', [FileUri])]);
    end,
    function : TAsynChat
    begin
      Result.Sender := Memo1;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

### Prompting with video

Gemini 1.5 Pro and Flash can process up to about one hour of video content.

Supported video formats include the following MIME types:

- `video/mp4`
- `video/mpeg`
- `video/mov`
- `video/avi`
- `video/x-flv`
- `video/mpg`
- `video/webm`
- `video/wmv`
- `video/3gpp`

Through the File API service, frames are extracted from videos at a rate of 1 frame per second (FPS), and audio is extracted at 1Kbps in single-channel mode, with timestamps marked every second. These rates may be adjusted in the future to enhance processing capabilities.

```Pascal
// uses Gemini, Gemini.Chat, Gemini.Files;

  var FileUri := '';
  {--- Upload file and get its uri }
  var MyFile := Gemini.Files.UpLoad('Z:\my_folder\video\my_video.mp4', 'MyFile');
  try
    FileUri := MyFile.&File.URI;
    Display(Memo1, FileUri);
  finally
    MyFile.Free;
  end;
 
  {--- Generate text from a video using its Uri. }
  Gemini.Chat.AsynCreate('models/gemini-1.5-pro',
    procedure (Params: TChatParams)
    begin
      Params.Contents([TPayload.Add('Describe this video clip.', [FileUri])]);
    end,
    function : TAsynChat
    begin
      Result.Sender := Memo1;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

## Audio

Gemini can handle audio prompts by:

- Describing, summarizing, or answering questions about audio content
- Providing a transcription of the audio
- Offering answers or a transcription for a specific part of the audio

> [!IMPORTANT]
> The Gemini API doesn't support audio output generation.
>

Gemini is compatible with the following audio format MIME types:

- **WAV**: `audio/wav`
- **MP3**: `audio/mp3`
- **AIFF**: `audio/aiff`
- **AAC**: `audio/aac`
- **OGG** `Vorbis: audio/ogg`
- **FLAC**: `audio/flac`

Gemini processes audio by breaking it down into **25 tokens per second**, so one minute of audio translates to **1,500 tokens**. The system currently only interprets spoken English but can recognize non-verbal sounds like birdsong or sirens. For a single input, Gemini supports a maximum audio length of **9.5 hours**. While there’s no restriction on the number of files per prompt, their total length combined cannot exceed 9.5 hours. All audio is downsampled to a **16 Kbps data rate**, and if the audio has multiple channels, they’re merged into a single channel.

<br/>

```Pascal
// uses Gemini, Gemini.Chat, Gemini.Files;

  var FileUri := '';
  {--- Upload file and get its uri }
  var MyFile := Gemini.Files.UpLoad('Z:\my_folder\sound\my_sound.wav', 'MyFile');
  try
    FileUri := MyFile.&File.URI;
    Display(Memo1, FileUri);
  finally
    MyFile.Free;
  end;
 
  {--- Generate text from an audio record using its Uri. }
  Gemini.Chat.AsynCreate('models/gemini-1.5-pro',
    procedure (Params: TChatParams)
    begin
      Params.Contents([TPayload.Add('Describe this audio clip.', [FileUri])]);
    end,
    function : TAsynChat
    begin
      Result.Sender := Memo1;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

### Speech-to-text

The primary purpose of speech-to-text technology is to provide a text transcription of a voice recording, which is inherently temporary in nature. Therefore, uploading this audio file is unnecessary, as it will be used only once for transcription.

To perform the transcription, simply follow the example below, assuming the audio file has already been provided through a prior recording process.

```Pascal
// uses Gemini, Gemini.Chat;

  var SpeechSource := 'Z:\my_folder\sound\my_speech.wav';
  {--- Transcribe the audio recording into a text. }
  Gemini.Chat.AsynCreate('models/gemini-1.5-pro',
    procedure (Params: TChatParams)
    begin
      Params.Contents([TPayload.Add('Transcribe the audio recording into English.', [SpeechSource])]);
    end,
    function : TAsynChat
    begin
      Result.Sender := Memo1;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);
```

<br/>

### Text-to-speech

As stated above, the Gemini API doesn't support audio output generation, and the Gemini APIs do not provide any method to transcribe text into an audio file. On the other hand, Google Cloud offers an alternative, which you can find [here](https://cloud.google.com/text-to-speech/?utm_source=google&utm_medium=cpc&utm_campaign=emea-gb-all-en-dr-bkws-all-all-trial-%7Bmatchtype%7D-gcp-1707574&utm_content=text-ad-none-any-DEV_%7Bdevice%7D-CRE_%7Bcreative%7D-ADGP_%7B_dsadgroup%7D-KWID_%7B_dstrackerid%7D-%7Btargetid%7D-userloc_%7Bloc_physical_ms%7D&utm_term=KW_%7Bkeyword%7D-NET_%7Bnetwork%7D-PLAC_%7Bplacement%7D&%7B_dsmrktparam%7D%7Bignore%7D&%7B_dsmrktparam%7D&gclsrc=aw.ds&gad_source=1&gclid=Cj0KCQjw1Yy5BhD-ARIsAI0RbXZf2NNU_LQ_rYqNEeTpm3Q0QPI83Jap8PAIl6ZFzulFAD3cY-z487oaAvk0EALw_wcB&gclsrc=aw.ds&hl=en).

<br/>

## Long context

See the [official documentation](https://ai.google.dev/gemini-api/docs/long-context).

<br/>

## Code execution

The Gemini API’s code execution feature allows the model to generate and execute Python code, enabling it to learn iteratively from the results until it reaches a final output. This capability can be applied to build applications that benefit from code-based reasoning and produce text-based results. For instance, code execution could be utilized in applications designed for solving equations or text processing.

Code execution is available in both AI Studio and the Gemini API. In AI Studio, it can be enabled within Advanced settings. With the Gemini API, code execution functions as a tool similar to function calling, allowing the model to decide when to use it.

> [!NOTE]
> The code execution environment has the NumPy and SymPy libraries available. You aren’t able to install additional libraries.
>
<br/>

Declare this method for displaying.
> [!TIP]
> ```Pascal
>  procedure DisplayCode(Sender: TObject; Chat: TChat); 
>  begin
>  for var Candidate in Chat.Candidates do
>    begin
>      for var Part in Candidate.Content.Parts do
>        begin
>          if Assigned(Part.ExecutableCode) then
>            DisplayStream(Sender, Part.ExecutableCode.Code)
>          else
>            DisplayStream(Sender, Part.Text);
>        end;
>    end;
>  end;
> ```

```Pascal
// uses Gemini, Gemini.Chat;

  Gemini.Chat.ASynCreateStream('models/gemini-1.5-flash',
    procedure (Params: TChatParams)
    begin
      Params.Contents([TPayload.Add('What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.')]);
      Params.Tools(CodeExecution);  // Enable code execution
    end,
    function : TAsynChatStream
    begin
      Result.Sender := Memo1;
      Result.OnProgress := DisplayCode;
      Result.OnError := Display;
    end);
```

Code execution and function calling are similar features with distinct use cases:

Code execution allows the model to run code directly in the API backend within a controlled, isolated environment. Function calling enables running functions that the model requests in a separate, customizable environment of your choice.

Generally, code execution is preferable if it meets your requirements, as it’s simpler to enable and completes within a single GenerateContent request, resulting in a single charge. In contrast, function calling requires an additional GenerateContent request to return each function’s output, leading to multiple charges.

Typically, use function calling if you need to run custom functions locally. For cases where the API should generate and execute Python code and deliver results, code execution is often the best fit.

<br/>

## Function calling

The Gemini API’s function calling feature allows you to define custom functions that the model can suggest, providing structured output that includes the function name and recommended arguments. While the model doesn’t execute these functions directly, it outputs suggestions, allowing you to trigger an external API call with those parameters. This approach enables you to bring real-time data from external sources, such as databases, CRM systems, or document repositories, into the conversation, allowing the model to deliver more contextually relevant and actionable responses.

Please refer to the [official documentation](https://ai.google.dev/gemini-api/docs/function-calling#how_it_works) for more information.

```Pascal
// uses Gemini, Gemini.Chat, Gemini.tools, Gemini.Functions.Core, Gemini.Functions.Example;

  var Weather := TWeatherReportFunction.CreateInstance;

  var Chat := Gemini.Chat.Create('models/gemini-1.5-flash',
    procedure (Params: TChatParams)
    begin
      Params.Contents([TPayload.User('What is the weather like in Paris?')]);
      Params.Tools([Weather]);
      Params.ToolConfig(AUTO);
    end);
  try
    for var Item in Chat.Candidates do
      begin
        for var SubItem in Item.Content.Parts do
          begin
            if Assigned(SubItem.FunctionCall) then
              CallFunction(SubItem.FunctionCall, Weather) else
              DisplayStream(Memo1, SubItem.Text);
          end;
      end;
  finally
    Chat.Free;
  end;

...

  procedure TForm.CallFunction(const Value: TFunctionCall; Func: IFunctionCore);
  begin
    var ArgResult := Func.Execute(Value.Args);
    Gemini.Chat.ASynCreateStream('models/gemini-1.5-flash',
      procedure (Params: TChatParams)
      begin
        Params.Contents([TPayload.Add(ArgResult)]);
      end,
      function : TAsynChatStream
      begin
        Result.Sender := Memo1;
        Result.OnProgress := DisplayStream;
        Result.OnError := Display;
      end);
  end;
```

<br/>

## Context caching

In many AI workflows, you may need to send the same input tokens repeatedly to a model. With the Gemini API’s context caching feature, you can submit content once, store the input tokens in a cache, and reference these cached tokens for future requests. At certain usage volumes, this method is more cost-effective than repeatedly submitting the same tokens.

When you cache tokens, you can specify a duration for how long they remain stored before automatic deletion. This duration is known as the time to live `TTL`, and if not specified, it defaults to 1 hour. The cost of caching varies based on the input token size and the desired `TTL`.

> [!NOTE]
> Context caching is available only for stable models with fixed versions (such as `gemini-1.5-pro-001`). Be sure to include the version suffix (like the -001 in `gemini-1.5-pro-001`).
>

To utilize the code examples, please download the file titled Apollo 11 Conversation available at the following link: https://storage.googleapis.com/generativeai-downloads/data/a11.txt.

<br/>

### Set the context to cache

```Pascal
// uses Gemini, Gemini.Chat, Gemini.Caching;

  var CacheName := '';  // Variable to store the name of the obtained cache

  var a11 := 'Z:\Download\Text\a11.txt';

  Gemini.Caching.ASynCreate(
    procedure (Params: TCacheParams)
    begin
      Params.Contents([TPayload.User([a11])]);
      Params.SystemInstruction('You are an expert on the history of space exploration.');
      Params.ttl('800s');
      Params.Model('models/gemini-1.5-flash-001');
    end,

    function : TAsynCache
    begin
      Result.Sender := Memo1;
      Result.OnSuccess :=
        procedure (Sender: TObject; Cache: TCache)
        begin
          CacheName := Cache.Name;
          DisplayStream(Sender, Cache.Name)
        end;
      Result.OnError := Display;
    end);
```

<br/>

### Use cached context

```Pascal
// uses Gemini, Gemini.Chat, Gemini.Caching;

  Gemini.Chat.AsynCreateStream('models/gemini-1.5-flash-001',
    procedure (Params: TChatParams)
    begin
      Params.Contents([ TPayload.User('Please summarize this transcript') ]);
      Params.CachedContent(CacheName);  // cachedContents/{code} e.g. cachedContents/phd5r5zz767u
    end,
    function : TAsynChatStream
    begin
      Result.Sender := Memo1;
      Result.OnProgress := DisplayStream;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);  
```

<br/>

### List caches

**It's not possible to access or view cached content directly**, but you can retrieve cache metadata, including the name, model, display name, usage metadata, creation time, update time, and expiration time.

Declare this method for displaying.
> [!TIP]
> ```Pascal
>  procedure Display(Sender: TObject; Cache: TCacheContents); overload;
>  begin
>    var M := Sender as TMemo;
>    if Length(Cache.CachedContents) > 0 then
>      begin
>        for var Item in Cache.CachedContents do
>          begin
>            M.Text := M.Text + Item.Name + '  Expire at : ' +  Item.expireTime + sLineBreak;
>            M.Perform(WM_VSCROLL, SB_BOTTOM, 0);
>          end;
>      end
>    else
>      M.Text := M.Text + 'No items cached' + sLineBreak;
>    M.Perform(WM_VSCROLL, SB_BOTTOM, 0);
>  end;
>``` 

```Pascal
// uses Gemini, Gemini.Chat, Gemini.Caching;

  // Declare Next as string

  Gemini.Caching.ASynList(20, Next,
    function : TAsynCacheContents
    begin
      Result.Sender := Memo1;
      Result.OnSuccess := Display;
      Result.OnError := Display;
    end);  
```

<br/>

### Retrieve a cache

Reads CachedContent resource.

```Pascal
// uses Gemini, Gemini.Chat, Gemini.Caching;

  var CacheName := 'cachedContents/{code}';  //e.g. cachedContents/phd5r5zz767u

  Gemini.Caching.ASynRetrieve(CacheName,
    function : TAsynCache
    begin
      Result.Sender := Memo1;
      Result.OnSuccess :=
        procedure (Sender: TObject; Cache: TCache)
        begin
          Display(Sender, Cache.Name + '  Expire at : ' + Cache.ExpireTime);
        end;
      Result.OnError := Display;
    end);
```


<br/>

### Update a cache

You can update the `TTL` or expiration time for a cache, but modifying any other cache settings isn’t allowed.

Here’s an example of how to update a cache’s `TTL`.

```Pascal
// uses Gemini, Gemini.Chat, Gemini.Caching;

  var CacheName := 'cachedContents/{code}';  //e.g. cachedContents/phd5r5zz767u

  Gemini.Caching.ASynUpdate(CacheName, '2300s',
    function : TAsynCache
    begin
      Result.Sender := Memo1;
      Result.OnSuccess :=
        procedure (Sender: TObject; Cache: TCache)
        begin
          Display(Sender, Cache.Name + '  Expire at : ' + Cache.ExpireTime);
        end;
      Result.OnError := Display;
    end);
```

<br/>

### Delete a cache

The caching service includes a delete function that allows users to manually remove content from the cache. The example below demonstrates how to delete a cache.

```Pascal
// uses Gemini, Gemini.Chat, Gemini.Caching;

  var CacheName := 'cachedContents/{code}';  //e.g. cachedContents/phd5r5zz767u

  Gemini.Caching.ASynDelete(CacheName,
    function : TAsynCacheDelete
    begin
      Result.Sender := Memo1;
      Result.OnSuccess :=
        procedure (Sender: TObject; EmptyCache: TCacheDelete)
        begin
          Display(Sender, CacheName + ' deleted');
        end;
      Result.OnError := Display;
    end);
```

<br/>

## Safety

The Gemini API offers adjustable safety settings, allowing you to tailor the level of restriction during the prototyping phase. You can modify these settings across four filtering categories to control the types of content allowed or restricted, depending on your application's needs.

Refer to [Safety filters](https://ai.google.dev/gemini-api/docs/safety-settings#safety-filters) in the officiel documentation.

<br/>

Generative AI models are highly versatile tools, yet they come with certain limitations. While their broad applicability offers great potential, it can also lead to unpredictable outcomes, including outputs that may be inaccurate, biased, or even offensive. To mitigate these risks, careful post-processing and thorough manual evaluation are crucial steps in ensuring the safety and reliability of these models.

Refer to [Safety guidance](https://ai.google.dev/gemini-api/docs/safety-guidance) in the officiel documentation.

<br/>

### TSafety record

The `TSafety` record is defined in the `Gemini.Safety.pas` unit is designed to configure safety rules by setting blocking thresholds for various categories of potentially harmful content. Here’s a summary of its capabilities:

<br/>

1. Safety Categories Configuration:
     
     The record allows setting specific blocking rules for categories of content, including:
     - `HARM_CATEGORY_HARASSMENT` (Harassment)
     - `HARM_CATEGORY_HATE_SPEECH` (Hate Speech)
     - `HARM_CATEGORY_SEXUALLY_EXPLICIT` (Sexually Explicit Content)
     - `HARM_CATEGORY_DANGEROUS_CONTENT` (Dangerous Content)
     - `HARM_CATEGORY_CIVIC_INTEGRITY` (Civic Integrity)

<br/>

2. Blocking Thresholds (THarmBlockThreshold):
     
     You can specify different blocking levels based on the probability of content being harmful:
     - `BLOCK_LOW_AND_ABOVE`: Blocks content with a low probability of harm or higher.
     - `BLOCK_MEDIUM_AND_ABOVE`: Blocks content with a medium probability of harm or higher.
     - `BLOCK_ONLY_HIGH`: Only blocks content with a high probability of harm.
     - `BLOCK_NONE`: Does not block any content.
     - `OFF`: Completely disables the safety filter.

<br/>

3. Methods for Setting Specific Rules:
     
     - `SexuallyExplicit`, `HateSpeech`, `Harassment`, `DangerousContent`, `CivicIntegrity`: These methods create a TSafety object for each content category with a specified blocking threshold.
     - `DontBlock`: Returns an array of `TSafety` configurations where each category is set to not block any content (`BLOCK_NONE`).

<br/>

4. JSON Conversion:
     
     The `ToJson` method converts the defined safety settings in a `TSafety` object to JSON format, with fields `category` (content category) and `threshold` (blocking threshold), facilitating export and storage.

<br/>

5. Fluent Creation Methods:
     
     Category and `Threshold`: These methods allow updating the category and blocking threshold for the current instance, enabling a fluent API style for chainable configuration.

<br/>

In summary, `TSafety` provides a flexible interface for setting up and adjusting safety filters in a Delphi application, based on different harm categories and probability thresholds, with convenient methods for category-specific configuration and easy JSON conversion.

<br/>

## Fine-tuning

When **few-shot prompting** does not yield the desired results, **fine-tuning** can enhance model performance on specific tasks. This process allows the model to better adhere to particular output requirements by using a curated set of examples that demonstrate the desired outcomes when instructions alone are insufficient. **Fine-tuning** thus helps to align the model's responses more closely with specific expectations.

Refer to [official documentation](https://ai.google.dev/gemini-api/docs/model-tuning#how-model).

<br/>

### Create tuning task

A training task comprises [***hyperparameter***](https://ai.google.dev/gemini-api/docs/model-tuning#advanced-settings)  values and ***training data*** represented as a list of input texts and corresponding response texts. 

The hyperparameters include `LearningRate`, `EpochCount`, and `BatchSize`. Training values can be directly specified within the dataset or imported from a `JSONL` or `CSV` file (using a semicolon as a separator).

> [!NOTE]
> For a comprehensive introduction to these hyperparameters, refer to the section ["Hyperparameters in Linear Regression"](https://developers.google.com/machine-learning/crash-course/linear-regression/hyperparameters?hl=fr) in the [Machine Learning Crash Course](https://developers.google.com/machine-learning/crash-course?hl=fr).
>

<br/>

- Example 1 :

```Pascal
// uses Gemini, Gemini.Chat, Gemini.FineTunings;

  var TuningTask := TTuningTaskParams.Create
    .Hyperparameters(
       procedure (var Params : THyperparametersParams)
       begin
         Params.LearningRate(0.001);
         Params.EpochCount(4);
         Params.BatchSize(2);
       end)
    .TrainingData([
       Example.AddItem('1', '2'),
       Example.AddItem('2', '3'),
       Example.AddItem('-3', '-2'),
       Example.AddItem('twenty two', 'twenty three'),
       Example.AddItem('two hundred', 'two hundred one'),
       Example.AddItem('ninety nine', 'one hundred'),
       Example.AddItem('8', '9'),
       Example.AddItem('-98', '-97'),
       Example.AddItem('1,000', '1,001'),
       Example.AddItem('10,100,000', '10,100,001'),
       Example.AddItem('thirteen', 'fourteen'),
       Example.AddItem('eighty', 'eighty one'),
       Example.AddItem('one', 'two'),
       Example.AddItem('three', 'four'),
       Example.AddItem('seven', 'eight')
     ]);
  Display(Memo1, TuningTask.ToFormat(True));
```

- Example 2 : You have chosen to implement a ***TrainingData.jsonl*** file in `JSONL` format, structured as follows.

```Jsonl
{"text_input": "1","output": "2"}
{"text_input": "3","output": "4"}
{"text_input": "-3","output": "-2"}
{"text_input": "twenty two","output": "twenty three"}
{"text_input": "two hundred","output": "two hundred one"}
{"text_input": "ninety nine","output": "one hundred"}
{"text_input": "8","output": "9"}
{"text_input": "-98","output": "-97"}
{"text_input": "1,000","output": "1,001"}
{"text_input": "10,100,000","output": "10,100,001"}
{"text_input": "thirteen","output": "fourteen"}
{"text_input": "eighty","output": "eighty one"}
{"text_input": "one","output": "two"}
{"text_input": "three","output": "four"}
{"text_input": "seven","output": "eight"}
```

```Pascal
// uses Gemini, Gemini.Chat, Gemini.FineTunings;

  var TuningTask := TTuningTaskParams.Create
    .Hyperparameters(
       procedure (var Params : THyperparametersParams)
       begin
         Params.LearningRate(0.001);
         Params.EpochCount(4);
         Params.BatchSize(2);
       end)
    .TrainingData('TrainingData.jsonl');
  Display(Memo1, TuningTask.ToFormat(True));
```

- Example 3 : You have chosen to implement a ***TrainingData.csv*** file in `csv` format, structured as follows.

```Csv
text_input;output
1;2
3;4
-3;-2
twenty two;twenty three
two hundred;two hundred one
ninety nine;one hundred
8;9
-98;-97
"1,000";"1,001"
"10,100,000";"10,100,001"
thirteen;fourteen
eighty;eighty one
one;two hundred one
three;fourteen
seven;eight
```

```Pascal
// uses Gemini, Gemini.Chat, Gemini.FineTunings;

  var TuningTask := TTuningTaskParams.Create
    .Hyperparameters(
       procedure (var Params : THyperparametersParams)
       begin
         Params.LearningRate(0.001);
         Params.EpochCount(4);
         Params.BatchSize(2);
       end)
    .TrainingData('TrainingData.csv');
  Display(Memo1, TuningTask.ToFormat(True));
```

<br/>

### Upload tuning dataset

This example shows how to create a tuned model. Check intermediate tuning progress (if any) through the google.longrunning.Operations service.

```Pascal
// uses Gemini, Gemini.Chat, Gemini.FineTunings;

  var TuningTask := TTuningTaskParams.Create
    .Hyperparameters(
       procedure (var Params : THyperparametersParams)
       begin
         Params.LearningRate(0.001);
         Params.EpochCount(4);
         Params.BatchSize(2);
       end)
    .TrainingData('TrainingData.jsonl');

  var TuningDataSet := TTunedModelParams.Create
    .DisplayName('number generator model')
    .BaseModel('models/gemini-1.0-pro-001')
    .TuningTask(TuningTask);

  var Tuning := Gemini.FineTune.Create(TuningDataSet.Detach);
  try
    Display(Memo1, Tuning.Name + sLineBreak + Tuning.Metadata);
  finally
    Tuning.Free;
  end;
```

<br/>

### Try the model

You can utilize methods defined in the `Gemini.Chat.pas` unit and specify the name of the fine-tuned model to evaluate its performance.

<br/>

### List tuned models

This example shows how to create a list of tuned models.

```Pascal
// uses Gemini, Gemini.Chat, Gemini.FineTunings;

  var List := Gemini.FineTune.List(20, Next, '');
  try
    for var Item in List.TunedModels do
      begin
        Display(Memo1, Item.Name + ' - ' + Item.State.ToString);
      end;
  finally
    List.Free;
  end;
```

<br/>

### Retrieve tuned model

This example shows how to get information about a specific TunedModel.

```Pascal
// uses Gemini, Gemini.Chat, Gemini.FineTunings;

  var TunedModelName := 'tunedModels/{code}'; //e.g. tunedModels/number-generator-model-fc2ml58m7qc8

  var Retrieved := Gemini.FineTune.Retrieve(TunedModelName);
  try
    Display(Memo1, Retrieved.Name + ' - ' + Retrieved.BaseModel);
  finally
    Retrieved.Free;
  end;
```

<br/>

### Update tuned model

This example shows how to update a tuned model.

```Pascal
// uses Gemini, Gemini.Chat, Gemini.FineTunings;

  var TunedModelName := 'tunedModels/{code}'; //e.g. tunedModels/number-generator-model-fc2ml58m7qc8

  var TuningTask := TTuningTaskParams.Create
    .Hyperparameters(
       procedure (var Params : THyperparametersParams)
       begin
         Params.LearningRate(0.001);
         Params.EpochCount(4);
         Params.BatchSize(2);
       end)
    .TrainingData('TrainingData.csv');

  var TuningDataSet := TTunedModelParams.Create
    .DisplayName('new number generator model')
    .Description('Update test de nouveau')
    .BaseModel('models/gemini-1.0-pro-001')
    .TuningTask(TuningTask);

  var Updated := Gemini.FineTune.Update(TunedModelName, 'displayName,description', TuningDataSet.Detach);
  try
    Display(Memo1, Updated.DisplayName + ' - ' + Updated.Description);
  finally
    Updated.Free;
  end;
```

<br/>

### Delete tuned model

This example shows how to delete a tuned model.

```Pascal
// uses Gemini, Gemini.Chat, Gemini.FineTunings;

  var TunedModelName := 'tunedModels/{code}'; //e.g. tunedModels/number-generator-model-fc2ml58m7qc8

  var Deleted := Gemini.FineTune.Delete(TunedModelName);
  try
    Display(Memo1, TunedModelName + ' - Deleted');
  finally
    Deleted.Free;
  end;
```

<br/>

## Grounding with Google Search

> [!IMPORTANT]
> **Note from Google**<br/>
> We're launching Grounding with Google Search! This is an initial launch. The EEA, UK, and CH regions will be supported at a later date. <br/>
> Please review the updated [Gemini API Additional Terms of Service](https://ai.google.dev/gemini-api/terms), which include new feature terms and updates for clarity. 
>

The Grounding with Google Search feature in the Gemini API and AI Studio can enhance the accuracy and timeliness of model responses. When this feature is enabled, the Gemini API provides more factual responses along with grounding sources (online supporting links) and [Google Search suggestions](https://ai.google.dev/gemini-api/docs/grounding?lang=rest#search-suggestions) alongside the content of the response. These search suggestions guide users to search results related to the grounded response.

Grounding with Google Search supports only text-based prompts; it does not accommodate multimodal prompts, such as those combining text with images or audio. Additionally, Grounding with Google Search is available in all [languages supported](https://ai.google.dev/gemini-api/docs/models/gemini#available-languages) by Gemini models.

The following example demonstrates how to set up a model to utilize grounding through Google Search:

Declare this method for displaying.
> [!TIP]
>```Pascal
>  procedure DisplayGoogleSearch(Sender: TObject; Chat: TChat);
>  begin
>  var M := Sender as TMemo;
>  for var Item in Chat.Candidates do
>    begin
>      if Item.FinishReason = STOP then
>        begin
>          for var SubItem in Item.Content.Parts do
>            begin
>              M.Lines.Text := M.Text + sLineBreak + SubItem.Text;
>            end;
>          if Assigned(Item.GroundingMetadata) then
>            begin
>              for var Chunk in Item.GroundingMetadata.GroundingChunks do
>                begin
>                  M.Lines.Text := M.Text + sLineBreak + Chunk.Web.Title + sLineBreak;
>                  M.Lines.Text := M.Text + sLineBreak + Chunk.Web.Uri + sLineBreak;
>                end;
>              M.Lines.Text := M.Text + sLineBreak + Item.GroundingMetadata.WebSearchQueries[0];
>            end;
>        end;
>      M.Perform(WM_VSCROLL, SB_BOTTOM, 0);
>    end;
>  end;
>```


```Pascal
// uses Gemini, Gemini.Chat;

  Gemini.Chat.AsynCreate('models/gemini-1.5-pro',
    procedure (Params: TChatParams)
    begin
      Params.Contents([TPayload.Add('What is the current Google stock price?')]);
      Params.Tools(GoogleSearch, 0.1);
    end,
    function : TAsynChat
    begin
      Result.Sender := Memo1;
      Result.OnSuccess := DisplayGoogleSearch;
      Result.OnError := Display;
    end);
```

`Params.Tools(GoogleSearch, Threshold)` : **Threshold** is a floating-point number between 0 and 1, with a default value of 0.7. When the threshold is set to zero, the response is always based on Google Search grounding.

For any other threshold value, the following applies:
- If the prediction score meets or exceeds the threshold, the response is grounded with Google Search.
- Lower thresholds mean that more prompts will be answered using Google Search grounding.
-If the prediction score is below the threshold, the model may still generate a response, but it won't be grounded with Google Search.


<br/>

### Why is Grounding with Google Search useful

Refer to the [official documentation](https://ai.google.dev/gemini-api/docs/grounding?lang=rest#why-grounding).

<br/>

### Important note

> [!CAUTION]
> The provided URIs must be directly accessible by the end users and must not be queried programmatically through automated means. If automated access is detected, the grounded answer generation service might stop providing the redirection URIs.
>

<br/>

# Methods for the Tutorial Display

> [!TIP]
>```Pascal
>  interface 
>
>    procedure Display(Sender: TObject); overload;
>
>    procedure Display(Sender: TObject; Chat: TChat); overload;
>    procedure Display(Sender: TObject; S: string); overload;
>    procedure Display(Sender: TObject; Candidate: TChatCandidate); overload;
>    procedure Display(Sender: TObject; Embed: TEmbeddingValues); overload;
>    procedure Display(Sender: TObject; Embed: TEmbeddings); overload;
>    procedure Display(Sender: TObject; Files: TFiles); overload;
>    procedure Display(Sender: TObject; Delete: TFileDelete); overload;
>    procedure Display(Sender: TObject; Cache: TCacheContents); overload;
>
>    procedure DisplayStream(Sender: TObject; Buffer: string); overload;
>    procedure DisplayStream(Sender: TObject; Chat: TChat); overload;
>
>    procedure DisplayCode(Sender: TObject; Chat: TChat);
>
>    procedure DisplayGoogleSearch(Sender: TObject; Chat: TChat);
>...
>```

<br/>

# Contributing

Pull requests are welcome. If you're planning to make a major change, please open an issue first to discuss your proposed changes.

# License

This project is licensed under the [MIT](https://choosealicense.com/licenses/mit/) License.

unit Gemini.API.Params;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGemini
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.Classes, System.JSON, System.SysUtils, System.Types, System.RTTI,
  REST.JsonReflect, REST.Json.Interceptors, System.Generics.Collections,
  System.Threading;

type
  /// <summary>
  /// Represents a reference to a procedure that takes a single argument of type T and returns no value.
  /// </summary>
  /// <param name="T">
  /// The type of the argument that the referenced procedure will accept.
  /// </param>
  /// <remarks>
  /// This type is useful for defining callbacks or procedures that operate on a variable of type T, allowing for more flexible and reusable code.
  /// </remarks>
  TProcRef<T> = reference to procedure(var Arg: T);

  TJSONInterceptorStringToString = class(TJSONInterceptor)
    constructor Create; reintroduce;
  protected
    RTTI: TRttiContext;
  end;

  TJSONParam = class
  private
    FJSON: TJSONObject;
    procedure SetJSON(const Value: TJSONObject);
    function GetCount: Integer;

  public
    constructor Create; virtual;
    destructor Destroy; override;
    function Add(const Key: string; const Value: string): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: Integer): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: Extended): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: Boolean): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: TDateTime; Format: string): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: TJSONValue): TJSONParam; overload; virtual;
    function Add(const Key: string; const Value: TJSONParam): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<string>): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<Integer>): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<Extended>): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<TJSONValue>): TJSONParam; overload; virtual;
    function Add(const Key: string; Value: TArray<TJSONParam>): TJSONParam; overload; virtual;
    function GetOrCreateObject(const Name: string): TJSONObject;
    function GetOrCreate<T: TJSONValue, constructor>(const Name: string): T;
    procedure Delete(const Key: string); virtual;
    procedure Clear; virtual;
    property Count: Integer read GetCount;
    function Detach: TJSONObject;
    property JSON: TJSONObject read FJSON write SetJSON;
    function ToJsonString(FreeObject: Boolean = False): string; virtual;
    function ToFormat(FreeObject: Boolean = False): string;
    function ToStringPairs: TArray<TPair<string, string>>;
    function ToStream: TStringStream;
  end;

const
  DATE_FORMAT = 'YYYY-MM-DD';
  TIME_FORMAT = 'HH:NN:SS';
  DATE_TIME_FORMAT = DATE_FORMAT + ' ' + TIME_FORMAT;

implementation

uses
  System.DateUtils;

{ TJSONInterceptorStringToString }

constructor TJSONInterceptorStringToString.Create;
begin
  ConverterType := ctString;
  ReverterType := rtString;
end;

{ Fetch }

type
  Fetch<T> = class
    type
      TFetchProc = reference to procedure(const Element: T);
  public
    class procedure All(const Items: TArray<T>; Proc: TFetchProc);
  end;

{ Fetch<T> }

class procedure Fetch<T>.All(const Items: TArray<T>; Proc: TFetchProc);
var
  Item: T;
begin
  for Item in Items do
    Proc(Item);
end;

{ TJSONParam }

function TJSONParam.Add(const Key, Value: string): TJSONParam;
begin
  Delete(Key);
  FJSON.AddPair(Key, Value);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: TJSONValue): TJSONParam;
begin
  Delete(Key);
  FJSON.AddPair(Key, Value);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: TJSONParam): TJSONParam;
begin
  Add(Key, TJSONValue(Value.JSON.Clone));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: TDateTime; Format: string): TJSONParam;
begin
  if Format.IsEmpty then
    Format := DATE_TIME_FORMAT;
  Add(Key, FormatDateTime(Format, System.DateUtils.TTimeZone.local.ToUniversalTime(Value)));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: Boolean): TJSONParam;
begin
  Add(Key, TJSONBool.Create(Value));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: Integer): TJSONParam;
begin
  Add(Key, TJSONNumber.Create(Value));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; const Value: Extended): TJSONParam;
begin
  Add(Key, TJSONNumber.Create(Value));
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<TJSONValue>): TJSONParam;
var
  JArr: TJSONArray;
begin
  JArr := TJSONArray.Create;
  Fetch<TJSONValue>.All(Value, JArr.AddElement);
  Add(Key, JArr);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<TJSONParam>): TJSONParam;
var
  JArr: TJSONArray;
  Item: TJSONParam;
begin
  JArr := TJSONArray.Create;
  for Item in Value do
  try
    JArr.AddElement(Item.JSON);
    Item.JSON := nil;
  finally
    Item.Free;
  end;
  Add(Key, JArr);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<Extended>): TJSONParam;
var
  JArr: TJSONArray;
  Item: Extended;
begin
  JArr := TJSONArray.Create;
  for Item in Value do
    JArr.Add(Item);
  Add(Key, JArr);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<Integer>): TJSONParam;
var
  JArr: TJSONArray;
  Item: Integer;
begin
  JArr := TJSONArray.Create;
  for Item in Value do
    JArr.Add(Item);
  Add(Key, JArr);
  Result := Self;
end;

function TJSONParam.Add(const Key: string; Value: TArray<string>): TJSONParam;
var
  JArr: TJSONArray;
  Item: string;
begin
  JArr := TJSONArray.Create;
  for Item in Value do
    JArr.Add(Item);
  Add(Key, JArr);
  Result := Self;
end;

procedure TJSONParam.Clear;
begin
  FJSON.Free;
  FJSON := TJSONObject.Create;
end;

constructor TJSONParam.Create;
begin
  FJSON := TJSONObject.Create;
end;

procedure TJSONParam.Delete(const Key: string);
var
  Item: TJSONPair;
begin
  Item := FJSON.RemovePair(Key);
  if Assigned(Item) then
    Item.Free;
end;

destructor TJSONParam.Destroy;
begin
  if Assigned(FJSON) then
    FJSON.Free;
  inherited;
end;

function TJSONParam.GetCount: Integer;
begin
  Result := FJSON.Count;
end;

function TJSONParam.GetOrCreate<T>(const Name: string): T;
begin
  if not FJSON.TryGetValue<T>(Name, Result) then
  begin
    Result := T.Create;
    FJSON.AddPair(Name, Result);
  end;
end;

function TJSONParam.GetOrCreateObject(const Name: string): TJSONObject;
begin
  Result := GetOrCreate<TJSONObject>(Name);
end;

function TJSONParam.Detach: TJSONObject;
begin
  Result := JSON;
  JSON := nil;
  var Task: ITask := TTask.Create(
    procedure()
    begin
      Sleep(30);
      TThread.Queue(nil,
      procedure
      begin
        Self.Free;
      end);
    end
  );
  Task.Start;
end;

procedure TJSONParam.SetJSON(const Value: TJSONObject);
begin
  FJSON := Value;
end;

function TJSONParam.ToFormat(FreeObject: Boolean): string;
begin
  Result := FJSON.Format(4);
  if FreeObject then
    Free;
end;

function TJSONParam.ToJsonString(FreeObject: Boolean): string;
begin
  Result := FJSON.ToJSON;
  if FreeObject then
    Free;
end;

function TJSONParam.ToStream: TStringStream;
begin
  Result := TStringStream.Create;
  try
    Result.WriteString(ToJsonString);
    Result.Position := 0;
  except
    Result.Free;
    raise;
  end;
end;

function TJSONParam.ToStringPairs: TArray<TPair<string, string>>;
begin
  for var Pair in FJSON do
    Result := Result + [TPair<string, string>.Create(Pair.JsonString.Value, Pair.JsonValue.AsType<string>)];
end;

end.

unit Gemini.API;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGemini
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Net.HttpClient, System.Net.URLClient,
  System.Net.Mime, System.JSON, System.SyncObjs, Gemini.API.Params, Gemini.Errors;

type
  GeminiException = class(Exception)
  private
    FCode: Int64;
    FMsg: string;
    FStatus: string;
  public
    constructor Create(const ACode: Int64; const AError: TErrorCore); reintroduce; overload;
    constructor Create(const ACode: Int64; const Value: string); reintroduce; overload;
    property Code: Int64 read FCode write FCode;
    property Msg: string read FMsg write FMsg;
    property Status: string read FStatus write FStatus;
  end;

  /// <summary>
  /// The `GeminiExceptionAPI` class represents a generic API-related exception.
  /// It is thrown when there is an issue with the API configuration or request process,
  /// such as a missing API token, invalid base URL, or other configuration errors.
  /// This class serves as a base for more specific API exceptions.
  /// </summary>
  GeminiExceptionAPI = class(Exception);

  /// <summary>
  /// The request body is malformed.
  /// <para>
  /// There is a typo, or a missing required field in your request.
  /// </para>
  /// </summary>
  /// <remarks>
  /// Check the API reference for request format, examples, and supported versions. Using features from a newer API version with an older endpoint can cause errors.
  /// </remarks>
  GeminiExceptionInvalidArgument = class(GeminiException);

  /// <summary>
  /// The API key doesn't have the required permissions.
  /// <para>
  /// Wrong API key is used; trying to use a tuned model without going through proper authentication.
  /// </para>
  /// </summary>
  /// <remarks>
  /// Check that the API key is set and has the right access. And make sure to go through proper authentication to use tuned models.
  /// </remarks>
  GeminiExceptionPermissionDenied = class(GeminiException);

  /// <summary>
  /// The requested resource wasn't found.
  /// <para>
  /// An image, audio, or video file referenced in your request was not found.
  /// </para>
  /// </summary>
  /// <remarks>
  /// Check if all parameters in your request are valid for your API version.
  /// </remarks>
  GeminiExceptionNotFound = class(GeminiException);

  /// <summary>
  /// The rate limit have been exceeded.
  /// <para>
  /// Too many requests per minute with the free tier Gemini API.
  /// </para>
  /// </summary>
  /// <remarks>
  /// Ensure you're within the model's rate limit. Request a quota increase if needed.
  /// </remarks>
  GeminiExceptionResourceExhausted = class(GeminiException);

  /// <summary>
  /// An unexpected error occurred on Google's side.
  /// <para>
  /// The input context is too long.
  /// </para>
  /// </summary>
  /// <remarks>
  /// Reduce your input context or temporarily switch to another model (e.g. from Gemini 1.5 Pro to Gemini 1.5 Flash) and see if it works. Or wait a bit and retry your request. If the issue persists after retrying, please report it using the Send feedback button in Google AI Studio.
  /// </remarks>
  GeminiExceptionInternal = class(GeminiException);

  /// <summary>
  /// The service may be temporarily overloaded or down.
  /// <para>
  /// The service is temporarily running out of capacity.
  /// </para>
  /// </summary>
  /// <remarks>
  /// Temporarily switch to another model (e.g. from Gemini 1.5 Pro to Gemini 1.5 Flash) and see if it works. Or wait a bit and retry your request. If the issue persists after retrying, please report it using the Send feedback button in Google AI Studio.
  /// </remarks>
  GeminiExceptionUnavailable = class(GeminiException);

  /// <summary>
  /// The service is unable to finish processing within the deadline.
  /// <para>
  /// The prompt (or context) is too large to be processed in time.
  /// </para>
  /// </summary>
  /// <remarks>
  /// Set a larger 'timeout' in your client request to avoid this error.
  /// </remarks>
  GeminiExceptionDeadlineExceeded = class(GeminiException);

  /// <summary>
  /// An `InvalidResponse` error occurs when the API response is either empty or not in the expected format.
  /// This error indicates that the API did not return a valid response that can be processed, possibly due to a server-side issue,
  /// a malformed request, or unexpected input data.
  /// </summary>
  /// <remarks>
  /// Check if all parameters in your request are valid for your API version.
  /// </remarks>
  GeminiExceptionInvalidResponse = class(GeminiException);

  TGeminiAPI = class
  public
    const
      URL_BASE = 'https://generativelanguage.googleapis.com';
      VERSION_BASE = 'v1beta';
  private
    FHTTPClient: THTTPClient;
    FToken: string;
    FBaseUrl: string;
    FVersion: string;
    FOrganization: string;
    FCustomHeaders: TNetHeaders;
    procedure SetToken(const Value: string);
    procedure SetBaseUrl(const Value: string);
    procedure SetVersion(const Value: string);
    procedure SetOrganization(const Value: string);
    procedure RaiseError(Code: Int64; Error: TErrorCore);
    procedure ParseError(const Code: Int64; const ResponseText: string);
    procedure SetCustomHeaders(const Value: TNetHeaders);

  private
    function ToStringValueFor(const Value: string): string; overload;
    function ToStringValueFor(const Value: string; const Field: string): string; overload;
    function ToStringValueFor(const Value: string; const Field: TArray<string>): string; overload;

  protected
    function GetHeaders: TNetHeaders;
    function GetFilesURL(const Path: string): string;
    function GetRequestURL(const Path: string): string; overload;
    function GetRequestURL(const Path, Params: string): string; overload;
    function GetRequestFilesURL(const Path: string): string;
    function GetPatchURL(const Path, Params: string): string;
    function Get(const Path, Params: string; Response: TStringStream): Integer; overload;
    function Delete(const Path: string; Response: TStringStream): Integer; overload;
    function Patch(const Path: string; Body: TJSONObject; Response: TStringStream; OnReceiveData: TReceiveDataCallback = nil): Integer; overload;
    function Patch(const Path, UriParams: string; Body: TJSONObject; Response: TStringStream; OnReceiveData: TReceiveDataCallback = nil): Integer; overload;
    function Post(const Path: string; Response: TStringStream): Integer; overload;
    function Post(const Path: string; Body: TJSONObject; Response: TStringStream; OnReceiveData: TReceiveDataCallback = nil): Integer; overload;
    function Post(const Path: string; Body: TMultipartFormData; Response: TStringStream): Integer; overload;
    function Post(const Path: string; Body: TJSONObject; var ResponseHeader: TNetHeaders): Integer; overload;
    function ParseResponse<T: class, constructor>(const Code: Int64; const ResponseText: string): T;
    procedure CheckAPI;

  public
    function Find<TParams: TJSONParam>(const Path: string; KeyName: string; ParamProc: TProc<TParams>): string;
    function Get<TResult: class, constructor>(const Path: string; const Params: string = ''): TResult; overload;
    function Get(const Path: string; const Params: string = ''): string; overload;
    procedure GetFile(const Path: string; Response: TStream); overload;
    function Delete<TResult: class, constructor>(const Path: string): TResult; overload;
    function Patch<TResult: class, constructor; TParams: TJSONParam>(const Path: string; ParamProc: TProc<TParams>): TResult; overload;
    function Patch<TResult: class, constructor; TParams: TJSONParam>(const Path, UriParams: string; ParamProc: TProc<TParams>): TResult; overload;
    function Patch<TResult: class, constructor>(const Path, Params: string; ParamJSON: TJSONObject): TResult; overload;
    function Patch<TResult: class, constructor>(const Path: string; ParamJSON: TJSONObject): TResult; overload;
    function Post<TParams: TJSONParam>(const Path: string; ParamProc: TProc<TParams>; Response: TStringStream; Event: TReceiveDataCallback): Boolean; overload;
    function Post<TResult: class, constructor; TParams: TJSONParam>(const Path: string; ParamProc: TProc<TParams>): TResult; overload;
    function Post<TResult: class, constructor>(const Path: string; ParamJSON: TJSONObject): TResult; overload;
    function Post<TResult: class, constructor>(const Path: string): TResult; overload;
    function PostForm<TResult: class, constructor; TParams: TMultipartFormData, constructor>(const Path: string; ParamProc: TProc<TParams>): TResult; overload;
    function UploadRaw<TResult: class, constructor>(const Path: string; const FileName: string): TResult;

  public
    constructor Create; overload;
    constructor Create(const AToken: string); overload;
    destructor Destroy; override;
    property Token: string read FToken write SetToken;
    property BaseUrl: string read FBaseUrl write SetBaseUrl;
    property Version: string read FVersion write SetVersion;
    property Organization: string read FOrganization write SetOrganization;
    property Client: THTTPClient read FHTTPClient;
    property CustomHeaders: TNetHeaders read FCustomHeaders write SetCustomHeaders;
  end;

  /// <summary>
  /// The <c>TGeminiAPIModel</c> class manages the configuration and state
  /// related to the language models used within the Gemini API framework.
  /// </summary>
  /// <remarks>
  /// This class handles the current model selection, ensures that model names
  /// adhere to the required formatting standards, and provides thread-safe
  /// access to the model configuration through the use of a critical section.
  /// It serves as a foundational class for managing model-specific operations
  /// within the Gemini API.
  /// </remarks>
  TGeminiAPIModel = class
    /// <summary>
    /// Holds the name of the currently active model used for embedding requests.
    /// </summary>
    /// <remarks>
    /// This class variable ensures that all embedding operations reference the
    /// correct model, maintaining consistency across API requests.
    /// </remarks>
    class var CurrentModel: string;
    /// <summary>
    /// A critical section object that ensures thread-safe access to model-related
    /// operations and variables.
    /// </summary>
    /// <remarks>
    /// The <c>GeminiLock</c> ensures that changes to the model configuration
    /// are performed atomically, preventing race conditions in multi-threaded
    /// environments.
    /// </remarks>
    class var GeminiLock: TCriticalSection;
  protected
    /// <summary>
    /// Sets the active model name after validating its format.
    /// </summary>
    /// <param name="ModelName">
    /// The name of the model to be set as active.
    /// </param>
    /// <param name="Supp">
    /// An optional supplementary string to append to the model name.
    /// </param>
    /// <returns>
    /// The finalized model name after formatting and appending the supplementary string.
    /// </returns>
    /// <remarks>
    /// This method not only sets the current model but also ensures that any
    /// supplementary information is correctly appended, maintaining the integrity
    /// of the model name within the API framework.
    /// </remarks>
    function SetModel(const ModelName: string; const Supp: string = ''): string;

  public
    /// <summary>
    /// Initializes the <c>TGeminiAPIModel</c> class by creating necessary
    /// synchronization objects.
    /// </summary>
    /// <remarks>
    /// The class constructor sets up the critical section used for thread-safe
    /// operations related to model management.
    /// </remarks>
    class constructor Create;
    /// <summary>
    /// Finalizes the <c>TGeminiAPIModel</c> class by releasing allocated resources.
    /// </summary>
    /// <remarks>
    /// The class destructor frees the critical section object, ensuring that
    /// all resources are properly released when the application terminates.
    /// </remarks>
    class destructor Destroy;
  end;

  /// <summary>
  /// Provides methods for building route parameters related to model retrieval in API requests.
  /// </summary>
  /// <remarks>
  /// The <c>TModelsRouteParams</c> class is responsible for constructing query parameters such as
  /// pagination settings, including page size and page token, for API calls that retrieve model data.
  /// This class extends <c>TGeminiAPIRoute</c> and is designed to be used by derived classes that
  /// perform specific API requests.
  /// </remarks>
  TGeminiAPIRequestParams = class(TGeminiAPIModel)
  protected
    /// <summary>
    /// Builds the query string parameters for pagination when fetching models.
    /// </summary>
    /// <param name="PageSize">
    /// The number of models to retrieve per page.
    /// </param>
    /// <param name="PageToken">
    /// An optional token used for fetching the next page of results.
    /// </param>
    /// <returns>
    /// A string containing the formatted query parameters, including the page size and optional page token.
    /// </returns>
    /// <remarks>
    /// The <c>ParamsBuilder</c> method constructs the query string for paginated model requests.
    /// The page size is mandatory, and the page token is optional but will be included in the query if provided.
    /// </remarks>
    function ParamsBuilder(const PageSize: Integer; const PageToken: string = ''): string; overload;
    /// <summary>
    /// Builds the query string parameters for pagination when fetching models, including an optional filter.
    /// </summary>
    /// <param name="PageSize">
    /// The number of models to retrieve per page.
    /// </param>
    /// <param name="PageToken">
    /// An optional token used for fetching the next page of results.
    /// </param>
    /// <param name="Filter">
    /// An optional filter string used to refine the results based on specific criteria.
    /// </param>
    /// <returns>
    /// A string containing the formatted query parameters, including the page size, optional page token, and filter.
    /// </returns>
    /// <remarks>
    /// The <c>ParamsBuilder</c> method constructs the query string for paginated model requests with an optional filter.
    /// The page size is mandatory, while the page token and filter are optional but will be included in the query if provided.
    /// </remarks>
    function ParamsBuilder(const PageSize: Integer; const PageToken, Filter: string): string; overload;
  end;

  /// <summary>
  /// The <c>TGeminiAPIRoute</c> class represents a specific API route within
  /// the Gemini framework, encapsulating the necessary API client and route-specific
  /// configurations.
  /// </summary>
  /// <remarks>
  /// Inheriting from <c>TGeminiAPIModel</c>, this class leverages model management
  /// capabilities to handle route-specific operations. It manages an instance of
  /// <c>TGeminiAPI</c>, allowing for the execution of API requests tailored to
  /// the defined route.
  /// </remarks>
  TGeminiAPIRoute = class(TGeminiAPIRequestParams)
  private
    /// <summary>
    /// The instance of <c>TGeminiAPI</c> used to perform API requests for this route.
    /// </summary>
    /// <remarks>
    /// This field holds the reference to the API client, enabling the route to
    /// execute HTTP requests with the appropriate configurations and headers.
    /// </remarks>
    FAPI: TGeminiAPI;
    /// <summary>
    /// Sets the <c>FAPI</c> field to a new <c>TGeminiAPI</c> instance.
    /// </summary>
    /// <param name="Value">
    /// The new <c>TGeminiAPI</c> instance to be associated with this route.
    /// </param>
    /// <remarks>
    /// This method allows for updating the API client used by the route, providing
    /// flexibility in managing different API configurations or tokens.
    /// </remarks>
    procedure SetAPI(const Value: TGeminiAPI);
  public
    /// <summary>
    /// Gets or sets the <c>TGeminiAPI</c> instance associated with this route.
    /// </summary>
    /// <remarks>
    /// This property provides access to the API client, enabling the execution
    /// of API calls specific to the route's configuration.
    /// </remarks>
    property API: TGeminiAPI read FAPI write SetAPI;
    /// <summary>
    /// Creates a new instance of <c>TGeminiAPIRoute</c> associated with the specified API client.
    /// </summary>
    /// <param name="AAPI">
    /// The <c>TGeminiAPI</c> instance to be used by this route for API requests.
    /// </param>
    /// <remarks>
    /// The constructor initializes the route with the provided API client, ensuring
    /// that all subsequent API calls made through this route utilize the correct
    /// configurations and authentication tokens.
    /// </remarks>
    constructor CreateRoute(AAPI: TGeminiAPI); reintroduce;
    /// <summary>
    /// Destroys the <c>TGeminiAPIRoute</c> instance, releasing any associated resources.
    /// </summary>
    /// <remarks>
    /// The destructor ensures that all resources tied to the route, including the
    /// API client reference, are properly released to prevent memory leaks.
    /// </remarks>
    destructor Destroy; override;
  end;

implementation

uses
  REST.Json;

const
  FieldsToString : TArray<string> = ['"args": {', '"response": {', '"metadata": {'];

constructor TGeminiAPI.Create;
begin
  inherited Create;
  FHTTPClient := THTTPClient.Create;
  FToken := EmptyStr;
  FBaseUrl := URL_BASE;
  FVersion := VERSION_BASE;
end;

constructor TGeminiAPI.Create(const AToken: string);
begin
  Create;
  Token := AToken;
end;

destructor TGeminiAPI.Destroy;
begin
  FHTTPClient.Free;
  inherited;
end;

function TGeminiAPI.Post(const Path: string; Body: TJSONObject; Response: TStringStream; OnReceiveData: TReceiveDataCallback): Integer;
var
  Headers: TNetHeaders;
  Stream: TStringStream;
begin
  CheckAPI;
  Headers := GetHeaders;
  Stream := TStringStream.Create;
  FHTTPClient.ReceiveDataCallBack := OnReceiveData;
  try
    Stream.WriteString(Body.ToJSON);
    Stream.Position := 0;
    Result := FHTTPClient.Post(GetRequestURL(Path), Stream, Response, Headers).StatusCode;
  finally
    FHTTPClient.ReceiveDataCallBack := nil;
    Stream.Free;
  end;
end;

function TGeminiAPI.Get(const Path, Params: string; Response: TStringStream): Integer;
var
  Headers: TNetHeaders;
begin
  CheckAPI;
  Headers := GetHeaders;
  Result := FHTTPClient.Get(GetRequestURL(Path, Params), Response, Headers).StatusCode;
end;

function TGeminiAPI.Post(const Path: string; Body: TMultipartFormData; Response: TStringStream): Integer;
var
  Headers: TNetHeaders;
begin
  CheckAPI;
  Headers := GetHeaders;
  Result := FHTTPClient.Post(GetFilesURL(Path), Body, Response, Headers).StatusCode;
end;

function TGeminiAPI.Post(const Path: string; Body: TJSONObject;
  var ResponseHeader: TNetHeaders): Integer;
begin
  CheckAPI;
  var Headers := GetHeaders;
  var Stream: TStringStream := nil;
  try
    if Assigned(Body) then
      begin
        Stream := TStringStream.Create;
        Stream.WriteString(Body.ToJSON);
        Stream.Position := 0;
      end;
    var response := FHTTPClient.Post(GetRequestFilesURL(Path), Stream, nil, Headers);
    Result := Response.StatusCode;
    case Result of
       200..299:
         ResponseHeader := Response.Headers;
       else
         raise Exception.Create('Error on response headers');
    end;
  finally
    FHTTPClient.OnReceiveData := nil;
    Stream.Free;
  end;
end;

function TGeminiAPI.Find<TParams>(const Path: string;
  KeyName: string; ParamProc: TProc<TParams>): string;
var
  ResponseHeader: TNetHeaders;
begin
  var Params: TParams := nil;
  try
    if Assigned(ParamProc) then
      begin
        Params := TParams.Create;
        ParamProc(Params);
        Post(Path, Params.JSON, ResponseHeader);
      end
    else
      Post(Path, nil, ResponseHeader);
    for var Item in ResponseHeader do
      begin
        if Item.Name.ToLower = KeyName then
          begin
            Result := Item.Value;
            Break;
          end;
      end;
  finally
    Params.Free;
  end;
end;

function TGeminiAPI.Post(const Path: string; Response: TStringStream): Integer;
var
  Headers: TNetHeaders;
  Stream: TStringStream;
begin
  CheckAPI;
  Headers := GetHeaders;
  Stream := nil;
  try
    Result := FHTTPClient.Post(GetRequestURL(Path), Stream, Response, Headers).StatusCode;
  finally
  end;
end;

function TGeminiAPI.Post<TResult, TParams>(const Path: string; ParamProc: TProc<TParams>): TResult;
var
  Response: TStringStream;
  Params: TParams;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    Code := Post(Path, Params.JSON, Response);
    Result := ParseResponse<TResult>(Code, ToStringValueFor(Response.DataString));
  finally
    Params.Free;
    Response.Free;
  end;
end;

function TGeminiAPI.Post<TResult>(const Path: string;
  ParamJSON: TJSONObject): TResult;
var
  Response: TStringStream;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Code := Post(Path, ParamJSON, Response);
    Result := ParseResponse<TResult>(Code, ToStringValueFor(Response.DataString));
  finally
    Response.Free;
  end;
end;

function TGeminiAPI.Post<TParams>(const Path: string; ParamProc: TProc<TParams>;
  Response: TStringStream; Event: TReceiveDataCallback): Boolean;
var
  Params: TParams;
  Code: Integer;
begin
  Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    Code := Post(Path, Params.JSON, Response, Event);
    case Code of
      200..299:
        Result := True;
    else
      begin
        Result := False;
        var Recieved := TStringStream.Create;
        try
          Response.Position := 0;
          Recieved.LoadFromStream(Response);
          ParseError(Code, Recieved.DataString);
        finally
          Recieved.Free;
        end;
      end;
    end;
  finally
    Params.Free;
  end;
end;

function TGeminiAPI.Post<TResult>(const Path: string): TResult;
var
  Response: TStringStream;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Code := Post(Path, Response);
    Result := ParseResponse<TResult>(Code, Response.DataString);
  finally
    Response.Free;
  end;
end;

function TGeminiAPI.Delete(const Path: string; Response: TStringStream): Integer;
var
  Headers: TNetHeaders;
begin
  CheckAPI;
  Headers := GetHeaders;
  Result := FHTTPClient.Delete(GetRequestURL(Path), Response, Headers).StatusCode;
end;

function TGeminiAPI.Delete<TResult>(const Path: string): TResult;
var
  Response: TStringStream;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Code := Delete(Path, Response);
    Result := ParseResponse<TResult>(Code, Response.DataString);
  finally
    Response.Free;
  end;
end;

function TGeminiAPI.PostForm<TResult, TParams>(const Path: string; ParamProc: TProc<TParams>): TResult;
var
  Response: TStringStream;
  Params: TParams;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    Code := Post(Path, Params, Response);
    Result := ParseResponse<TResult>(Code, Response.DataString);
  finally
    Params.Free;
    Response.Free;
  end;
end;

procedure TGeminiAPI.RaiseError(Code: Int64; Error: TErrorCore);
begin
  case Code of
    400:
      raise GeminiExceptionInvalidArgument.Create(Code, Error);
    403:
      raise GeminiExceptionPermissionDenied.Create(Code, Error);
    404:
      raise GeminiExceptionNotFound.Create(Code, Error);
    429:
      raise GeminiExceptionResourceExhausted.Create(Code, Error);
    500:
      raise GeminiExceptionInternal.Create(Code, Error);
    503:
      raise GeminiExceptionUnavailable.Create(Code, Error);
    504:
      raise GeminiExceptionDeadlineExceeded.Create(Code, Error);
  else
    raise GeminiException.Create(Code, Error);
  end;
end;

function TGeminiAPI.Get(const Path: string; const Params: string): string;
var
  Response: TStringStream;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Code := Get(Path, Params, Response);
    case Code of
      200..299: ; //Success
    end;
    Result := Response.DataString;
  finally
    Response.Free;
  end;
end;

function TGeminiAPI.Get<TResult>(const Path: string; const Params: string): TResult;
var
  Response: TStringStream;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Code := Get(Path, Params, Response);
    Result := ParseResponse<TResult>(Code, Response.DataString);
  finally
    Response.Free;
  end;
end;

procedure TGeminiAPI.GetFile(const Path: string; Response: TStream);
var
  Headers: TNetHeaders;
  Code: Integer;
begin
  CheckAPI;
  Headers := GetHeaders;
  Code := FHTTPClient.Get(GetRequestURL(Path), Response, Headers).StatusCode;
  case Code of
    200..299:
      ; {success}
  else
    var Recieved := TStringStream.Create;
    try
      Response.Position := 0;
      Recieved.LoadFromStream(Response);
      ParseError(Code, Recieved.DataString);
    finally
      Recieved.Free;
    end;
  end;
end;

function TGeminiAPI.GetFilesURL(const Path: string): string;
begin
  Result := Format('%s/%s', [FBaseURL, Path]);
end;

function TGeminiAPI.GetHeaders: TNetHeaders;
begin
  Result := FCustomHeaders + [TNetHeader.Create('Content-Type', 'application/json')];
end;

function TGeminiAPI.GetPatchURL(const Path, Params: string): string;
begin
  Result := Format('%s/%s/%s?key=%s&&updateMask=%s', [FBaseURL, Fversion, Path, Token, Params]);
end;

function TGeminiAPI.GetRequestURL(const Path, Params: string): string;
begin
  Result := Format('%s/%s/%s?key=%s%s', [FBaseURL, FVersion, Path, Token, Params]);
end;

function TGeminiAPI.GetRequestFilesURL(const Path: string): string;
begin
  Result := Format('%s/%s?key=%s', [FBaseURL, Path, Token]);
end;

function TGeminiAPI.GetRequestURL(const Path: string): string;
begin
  Result := Format('%s/%s/%s?key=%s', [FBaseURL, FVersion, Path, Token]);
end;

procedure TGeminiAPI.CheckAPI;
begin
  if FToken.IsEmpty then
    raise GeminiExceptionAPI.Create('Token is empty!');
  if FBaseUrl.IsEmpty then
    raise GeminiExceptionAPI.Create('Base url is empty!');
end;

procedure TGeminiAPI.ParseError(const Code: Int64; const ResponseText: string);
var
  Error: TErrorCore;
begin
  Error := nil;
  try
    try
      Error := TJson.JsonToObject<TError>(ResponseText);
    except
      Error := nil;
    end;
    if Assigned(Error) then
      RaiseError(Code, Error);
  finally
    if Assigned(Error) then
      Error.Free;
  end;
end;

function TGeminiAPI.ParseResponse<T>(const Code: Int64; const ResponseText: string): T;
begin
  Result := nil;
  case Code of
    200..299:
      try
        Result := TJson.JsonToObject<T>(ResponseText);
      except
        Result := nil;
      end;
    else
      ParseError(Code, ResponseText);
  end;
  if not Assigned(Result) then
    raise GeminiExceptionInvalidResponse.Create(Code, 'Empty or invalid response');
end;

function TGeminiAPI.Patch(const Path: string; Body: TJSONObject;
  Response: TStringStream; OnReceiveData: TReceiveDataCallback): Integer;
var
  Headers: TNetHeaders;
  Stream: TStringStream;
begin
  CheckAPI;
  Headers := GetHeaders;
  Stream := TStringStream.Create;
  FHTTPClient.ReceiveDataCallBack := OnReceiveData;
  try
    Stream.WriteString(Body.ToJSON);
    Stream.Position := 0;
    Result := FHTTPClient.Patch(GetRequestURL(Path), Stream, Response, Headers).StatusCode;
  finally
    FHTTPClient.ReceiveDataCallBack := nil;
    Stream.Free;
  end;
end;

function TGeminiAPI.Patch(const Path, UriParams: string; Body: TJSONObject;
  Response: TStringStream; OnReceiveData: TReceiveDataCallback): Integer;
var
  Headers: TNetHeaders;
  Stream: TStringStream;
begin
  CheckAPI;
  Headers := GetHeaders;
  Stream := TStringStream.Create;
  FHTTPClient.ReceiveDataCallBack := OnReceiveData;
  try
    Stream.WriteString(Body.ToJSON);
    Stream.Position := 0;
    Result := FHTTPClient.Patch(GetPatchURL(Path, UriParams), Stream, Response, Headers).StatusCode;
  finally
    FHTTPClient.ReceiveDataCallBack := nil;
    Stream.Free;
  end;
end;

function TGeminiAPI.Patch<TResult, TParams>(const Path, UriParams: string;
  ParamProc: TProc<TParams>): TResult;
var
  Response: TStringStream;
  Params: TParams;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    Code := Patch(Path, UriParams, Params.JSON, Response);
    Result := ParseResponse<TResult>(Code, ToStringValueFor(Response.DataString));
  finally
    Params.Free;
    Response.Free;
  end;
end;

function TGeminiAPI.Patch<TResult>(const Path: string;
  ParamJSON: TJSONObject): TResult;
var
  Response: TStringStream;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Code := Patch(Path, ParamJSON, Response);
    Result := ParseResponse<TResult>(Code, ToStringValueFor(Response.DataString));
  finally
    Response.Free;
  end;
end;

function TGeminiAPI.Patch<TResult>(const Path, Params: string;
  ParamJSON: TJSONObject): TResult;
var
  Response: TStringStream;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Code := Patch(Path, Params, ParamJSON, Response);
    Result := ParseResponse<TResult>(Code, ToStringValueFor(Response.DataString));
  finally
    Response.Free;
  end;
end;

function TGeminiAPI.Patch<TResult, TParams>(const Path: string;
  ParamProc: TProc<TParams>): TResult;
var
  Response: TStringStream;
  Params: TParams;
  Code: Integer;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  Params := TParams.Create;
  try
    if Assigned(ParamProc) then
      ParamProc(Params);
    Code := Patch(Path, Params.JSON, Response);
    Result := ParseResponse<TResult>(Code, ToStringValueFor(Response.DataString));
  finally
    Params.Free;
    Response.Free;
  end;
end;

procedure TGeminiAPI.SetBaseUrl(const Value: string);
begin
  FBaseUrl := Value;
end;

procedure TGeminiAPI.SetCustomHeaders(const Value: TNetHeaders);
begin
  FCustomHeaders := Value;
end;

procedure TGeminiAPI.SetOrganization(const Value: string);
begin
  FOrganization := Value;
end;

procedure TGeminiAPI.SetToken(const Value: string);
begin
  FToken := Value;
end;

procedure TGeminiAPI.SetVersion(const Value: string);
begin
  FVersion := Value;
end;

function TGeminiAPI.ToStringValueFor(const Value: string): string;
begin
  Result := ToStringValueFor(Value, FieldsToString);
end;

function TGeminiAPI.ToStringValueFor(const Value, Field: string): string;
begin
  Result := Value;
  var i := Pos(Field, Result);
  while (i > 0) and (i < Result.Length) do
    begin
      i := i + Field.Length - 1;
      Result[i] := '"';
      Inc(i);
      var j := 0;
      while (j > 0) or ((j = 0) and not (Result[i] = '}')) do
        begin
          case Result[i] of
            '{':
              Inc(j);
            '}':
              j := j - 1;
            '"':
              Result[i] := '`';
          end;
          Inc(i);
          if i > Result.Length then
            raise Exception.Create('Invalid JSON string');
        end;
      Result[i] := '"';
      i := Pos(Field, Result);
    end;
end;

function TGeminiAPI.ToStringValueFor(const Value: string;
  const Field: TArray<string>): string;
begin
  Result := Value;
  if Length(Field) > 0 then
    begin
      for var Item in Field do
        Result := ToStringValueFor(Result, Item);
    end;
end;

function TGeminiAPI.UploadRaw<TResult>(const Path, FileName: string): TResult;
var
  Headers: TNetHeaders;
  Response: TStringStream;
  Code: integer;
begin
  CheckAPI;
  Headers := GetHeaders;
  var FileStream := TFileStream.Create(FileName, fmOpenRead);
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    Code := FHTTPClient.Post(Path, FileStream, Response, Headers).StatusCode;
    Result := ParseResponse<TResult>(Code, Response.DataString);
  finally
    FileStream.Free;
    Response.Free;
  end;
end;

{ GeminiException }

constructor GeminiException.Create(const ACode: Int64; const AError: TErrorCore);
begin
  Code := ACode;
  Msg := (AError as TError).Error.Message;
  Status := (AError as TError).Error.Status;

  inherited Create(Format('error (%d) %s: '+ sLineBreak + '     %s', [Code, Status, Msg]));
end;

constructor GeminiException.Create(const ACode: Int64; const Value: string);
begin
  Code := ACode;
  Msg := Value;
  inherited Create(Format('error %d: %s', [ACode, Msg]));
end;

{ TGeminiAPIRoute }

constructor TGeminiAPIRoute.CreateRoute(AAPI: TGeminiAPI);
begin
  inherited Create;
  FAPI := AAPI;
end;

destructor TGeminiAPIRoute.Destroy;
begin
  inherited;
end;

procedure TGeminiAPIRoute.SetAPI(const Value: TGeminiAPI);
begin
  FAPI := Value;
end;


{ TGeminiAPIModel }

class constructor TGeminiAPIModel.Create;
begin
  GeminiLock := TCriticalSection.Create;
end;

class destructor TGeminiAPIModel.Destroy;
begin
  GeminiLock.Free;
end;

function TGeminiAPIModel.SetModel(const ModelName: string; const Supp: string): string;
begin
  if ModelName.Trim.IsEmpty then
    raise Exception.Create('Error: Unknown model name provided.');
  Result := ModelName.Trim;
  CurrentModel := Result;
  if not Supp.Trim.IsEmpty then
    Result := Result + Supp;
end;

{ TGeminiAPIRequestParams }

function TGeminiAPIRequestParams.ParamsBuilder(const PageSize: Integer;
  const PageToken: string): string;
begin
  Result := Format('&&pageSize=%d', [PageSize]);
  if not PageToken.IsEmpty then
    Result := Format('%s&&pageToken=%s', [Result, PageToken]);
end;

function TGeminiAPIRequestParams.ParamsBuilder(const PageSize: Integer;
  const PageToken, Filter: string): string;
begin
  Result := ParamsBuilder(PageSize, PageToken);
  if not Filter.IsEmpty then
    Result := Format('%s&&filter=%s', [Result, Filter]);
end;

end.

unit Gemini.Async.Params;

{-------------------------------------------------------------------------------

      Unit containing generic interfaces and classes for managing parameters
      across  various  asynchronous  operations.

      The Gemini.Async.Params  unit  provides  a set of tools for creating
      and managing  parameter  instances  using  generic  types. The primary
      components include:

      - IUseParams<T>: A generic interface for managing parameters of type T.
      - TUseParams<T>: A class  implementing  the IUseParams<T>  interface to
        encapsulate  parameter  handling.
      - TUseParamsFactory<T>: A  factory  class  for  creating  instances  of
        IUseParams<T>.

      These abstractions allow for  a flexible and  reusable  way  to  handle
      parameters  across  different  modules  and  contexts,  particularly in
      asynchronous  scenarios  such  as  chat  operations.

      Note  that  This  unit  is  designed   to  work   seamlessly  with  the
      Gemini.Chat.AsyncEvents unit,  which  relies  on  IUseParams<T> and
      TUseParamsFactory<T>  to  manage   parameters   for  asynchronous  chat
      requests.

        Github repository :  https://github.com/MaxiDonkey/DelphiGemini
        Visit the Github repository for the documentation and use examples

-------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes;

type
  /// <summary>
  /// Generic interface for managing parameters of type <c>T</c>.
  /// </summary>
  /// <typeparam name="T">
  /// The type of the parameters.
  /// </typeparam>
  IUseParams<T> = interface
    ['{18566F2C-F2D9-4257-A460-D9AE8F053357}']
    /// <summary>
    /// Sets the parameters.
    /// </summary>
    /// <param name="Value">
    /// The value of the parameters to be set.
    /// </param>
    procedure SetParams(const Value: T);
    /// <summary>
    /// Gets the current parameters.
    /// </summary>
    /// <returns>
    /// The current parameters of type <c>T</c>.
    /// </returns>
    function GetParams: T;
    /// <summary>
    /// Assigns the parameters using a function.
    /// </summary>
    /// <param name="Value">
    /// A function that returns parameters of type <c>T</c>.
    /// </param>
    procedure Assign(Value: TFunc<T>);
    /// <summary>
    /// Returns the current instance as an object of type <c>TObject</c>.
    /// </summary>
    /// <returns>
    /// The instance cast to <c>TObject</c>.
    /// </returns>
    function AsSender: TObject;
    /// <summary>
    /// Provides access to the parameters as a property.
    /// </summary>
    property Param: T read GetParams write SetParams;
  end;

  /// <summary>
  /// A factory class for creating instances of <c>IUseParams</c>.
  /// </summary>
  /// <param name="T">
  /// The type of the parameters for which the instance is created.
  /// </param>
  TUseParamsFactory<T> = class
    /// <summary>
    /// Creates and returns a new instance of <c>IUseParams</c> for the specified type <c>T</c>.
    /// </summary>
    /// <returns>
    /// A new instance of <c>IUseParams&lt;T&gt;</c>.
    /// </returns>
    class function CreateInstance: IUseParams<T>; overload;
    /// <summary>
    /// Creates and returns a new instance of <c>IUseParams</c> for the specified type <c>T</c>, using the provided function.
    /// </summary>
    /// <param name="Value">
    /// A function that provides the parameter values for the instance.
    /// </param>
    /// <returns>
    /// A new instance of <c>IUseParams&lt;T&gt;</c>.
    /// </returns>
    class function CreateInstance(Value: TFunc<T>): IUseParams<T>; overload;
  end;

  /// <summary>
  /// A generic class implementing the <c>IUseParams</c> interface to manage parameters of type <c>T</c>.
  /// </summary>
  /// <param name="T">
  /// The type of the parameters.
  /// </param>
  TUseParams<T> = class(TInterfacedObject, IUseParams<T>)
  private
    FParams: T;
    /// <summary>
    /// Sets the parameters to the provided value.
    /// </summary>
    /// <param name="Value">
    /// The new parameters value.
    /// </param>
    procedure SetParams(const Value: T);
    /// <summary>
    /// Retrieves the current parameters value.
    /// </summary>
    /// <returns>
    /// The current parameters.
    /// </returns>
    function GetParams: T;
  protected
    /// <summary>
    /// Casts the instance as a <c>TObject</c> for use as the sender of events.
    /// </summary>
    /// <returns>
    /// The current instance cast to <c>TObject</c>.
    /// </returns>
    function AsSender: TObject;
    /// <summary>
    /// Assigns the parameters using a function that returns type <c>T</c>.
    /// </summary>
    /// <param name="Value">
    /// A function that sets the parameters.
    /// </param>
    procedure Assign(Value: TFunc<T>);
  public
    /// <summary>
    /// Property to get or set the parameters.
    /// </summary>
    property Params: T read GetParams write SetParams;
  end;

implementation

{ TUseParams<T> }

function TUseParams<T>.AsSender: TObject;
begin
  Result := Self;
end;

procedure TUseParams<T>.Assign(Value: TFunc<T>);
begin
  if Assigned(Value) then
    begin
      Params := Value();
    end;
end;

function TUseParams<T>.GetParams: T;
begin
  Result := FParams;
end;

procedure TUseParams<T>.SetParams(const Value: T);
begin
  FParams := Value;
end;

{ TUseParamsFactory<T> }

class function TUseParamsFactory<T>.CreateInstance: IUseParams<T>;
begin
  Result := TUseParams<T>.Create;
end;

class function TUseParamsFactory<T>.CreateInstance(
  Value: TFunc<T>): IUseParams<T>;
begin
  Result := CreateInstance;
  Result.Assign(Value);
end;

end.

unit Gemini.Async.Support;

{-------------------------------------------------------------------------------

      Unit containing  records for managing  asynchronous events related to
      chat requests.

      The  Gemini.Chat.AsyncEvents  unit  provides  definitions for the
      TAsyncParams<T>  and  TAsynStreamParams<T>  records, which  are  used
      to  handle  the lifecycle  of asynchronous chat operations, including
      starting, progressing, succeeding, and handling errors.
      These records enable non-blocking operations for chat functionalities
      and can be reused across multiple modules.

      This unit depends  on Gemini.Async.Params  for parameter management.
      The IUseParams<T>  and  TUseParamsFactory<T>  interfaces  and  classes
      from  Gemini.Params.Core  are  utilized  to  create and manage the
      parameter  instances  for  asynchronous  operations.

        Github repository :  https://github.com/MaxiDonkey/DelphiGemini
        Visit the Github repository for the documentation and use examples

-------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, system.Classes, System.Threading, Gemini.Async.Params;

type
  /// <summary>
  /// Record used to handle asynchronous request events.
  /// </summary>
  /// <remarks>
  /// <c>TAsynCallBack</c> manages the lifecycle of an asynchronous request.
  /// It provides callbacks for different stages of the request, such as start, successful completion, or error.
  /// </remarks>
  TAsynCallBack<T> = record
  private
    FSender: TObject;
    FOnStart: TProc<TObject>;
    FOnSuccess: TProc<TObject, T>;
    FOnError: TProc<TObject, string>;
  public
    /// <summary>
    /// Object representing the sender of the asynchronous operation.
    /// </summary>
    /// <remarks>
    /// The <c>Sender</c> property is used to identify or store a reference to the object that initiated the request.
    /// This can be useful for providing context in the callback procedures.
    /// </remarks>
    property Sender: TObject read FSender write FSender;
    /// <summary>
    /// Event triggered at the start of the asynchronous request.
    /// </summary>
    /// <remarks>
    /// The <c>OnStart</c> event is called when the request begins.
    /// It can be used to initialize any required state or display a loading indicator to the user.
    /// <code>
    /// OnStart :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // Code executed at the start of the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnStart: TProc<TObject> read FOnStart write FOnStart;
    /// <summary>
    /// Event triggered at the end of the asynchronous request.
    /// </summary>
    /// <param name="Sender">
    /// Object that initiated the request, generally used for context.
    /// </param>
    /// <param name="Result">
    /// The result of type <c>T</c> returned at the end of the request.
    /// This event is used to process the final result of the asynchronous operation.
    /// </param>
    /// <remarks>
    /// The <c>OnSuccess</c> event is invoked when the process completes successfully.
    /// It can be used to perform final actions based on the received result.
    /// <code>
    /// OnSuccess :=
    ///    procedure (Sender: TObject; Result: T)
    ///    begin
    ///      // Code executed at the end of the request with the obtained result
    ///    end;
    /// </code>
    /// </remarks>
    property OnSuccess: TProc<TObject, T> read FOnSuccess write FOnSuccess;
    /// <summary>
    /// Event triggered when an error occurs during the asynchronous request.
    /// </summary>
    /// <param name="Sender">
    /// Object that initiated the request, generally used for context.
    /// </param>
    /// <param name="ErrorMessage">
    /// The error message received, which can be logged or displayed to the user.
    /// </param>
    /// <remarks>
    /// The <c>OnError</c> event is called when an error occurs during the asynchronous operation.
    /// It can be used to handle failures, display error messages, or perform any necessary cleanup actions.
    /// <code>
    /// OnError :=
    ///    procedure (Sender: TObject; ErrorMessage: string)
    ///    begin
    ///      // Code executed when an error occurs during the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnError: TProc<TObject, string> read FOnError write FOnError;
  end;

  /// <summary>
  /// Class used to manage asynchronous execution with callback events.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynCallBackExec&lt;T, U&gt;</c> class allows you to execute asynchronous operations with specified callbacks for start, completion, and error events.
  /// It encapsulates the asynchronous execution logic, handling thread management and exception handling, providing an easy way to manage the lifecycle of an asynchronous request.
  /// </remarks>
  TAsynCallBackExec<T; U: class> = class
  private
    FUse: IUseParams<T>;
    FSender: TObject;
    FOnStart: TProc<TObject>;
    FOnSuccess: TProc<TObject, U>;
    FOnError: TProc<TObject, string>;
  public
    /// <summary>
    /// Gets the <c>IUseParams&lt;T&gt;</c> interface instance used by this class.
    /// </summary>
    /// <value>
    /// An instance of <c>IUseParams&lt;T&gt;</c> that provides parameter management functionality.
    /// </value>
    property Use: IUseParams<T> read FUse;
    /// <summary>
    /// The object representing the sender of the asynchronous operation.
    /// </summary>
    /// <value>
    /// An instance of <c>TObject</c> identifying the originator of the operation.
    /// </value>
    /// <remarks>
    /// This property can be set to identify the object that initiated the asynchronous operation, which is useful in callback methods.
    /// </remarks>
    property Sender: TObject read FSender write FSender;
    /// <summary>
    /// Event triggered when the asynchronous operation starts.
    /// </summary>
    /// <value>
    /// A procedure of type <c>TProc&lt;TObject&gt;</c> to handle any setup or UI updates when the operation begins.
    /// </value>
    /// <remarks>
    /// Assign a procedure to this event to perform actions at the start of the asynchronous operation.
    /// <code>
    /// OnStart :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // Code executed at the start of the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnStart: TProc<TObject> read FOnStart write FOnStart;
    /// <summary>
    /// Event triggered when the asynchronous operation completes successfully.
    /// </summary>
    /// <value>
    /// A procedure of type <c>TProc&lt;TObject, U&gt;</c> to handle the result of the operation.
    /// </value>
    /// <remarks>
    /// Assign a procedure to this event to process the result returned by the operation.
    /// <code>
    /// OnSuccess :=
    ///    procedure (Sender: TObject; Result: T)
    ///    begin
    ///      // Code executed at the end of the request with the obtained result
    ///    end;
    /// </code>
    /// </remarks>
    property OnSuccess: TProc<TObject, U> read FOnSuccess write FOnSuccess;
    /// <summary>
    /// Event triggered when an error occurs during the asynchronous operation.
    /// </summary>
    /// <value>
    /// A procedure of type <c>TProc&lt;TObject, string&gt;</c> to handle exceptions or errors.
    /// </value>
    /// <remarks>
    /// Assign a procedure to this event to handle any exceptions or errors that occur during execution.
    /// <code>
    /// OnError :=
    ///    procedure (Sender: TObject; ErrorMessage: string)
    ///    begin
    ///      // Code executed when an error occurs during the request
    ///    end;
    /// </code>
    /// </remarks>
    property OnError: TProc<TObject, string> read FOnError write FOnError;
    /// <summary>
    /// Executes the specified function asynchronously.
    /// </summary>
    /// <param name="Value">
    /// A function of type <c>TFunc&lt;U&gt;</c> representing the operation to execute asynchronously.
    /// </param>
    /// <remarks>
    /// This method creates and starts an asynchronous task that executes the provided function.
    /// It invokes the <c>OnStart</c> event before execution, the <c>OnSuccess</c> event upon successful completion, and the <c>OnError</c> event if an exception occurs during execution.
    /// </remarks>
    procedure Run(Value: TFunc<U>);
    /// <summary>
    /// Initializes a new instance of the <c>TAsynCallBackExec&lt;T, U&gt;</c> class with the specified parameter function.
    /// </summary>
    /// <param name="Value">
    /// A function of type <c>TFunc&lt;T&gt;</c> used to create an instance of <c>IUseParams&lt;T&gt;</c>.
    /// </param>
    /// <remarks>
    /// The constructor initializes the internal <c>IUseParams&lt;T&gt;</c> interface using the provided function.
    /// </remarks>
    constructor Create(const Value: TFunc<T>);
  end;

  /// <summary>
  /// Record used to manage asynchronous events for a streaming chat request.
  /// </summary>
  /// <remarks>
  /// <c>TAsynChatStreamParams</c> allows you to handle the lifecycle of a chat request in streaming mode.
  /// It provides callbacks for different stages such as when the request starts, progresses, succeeds, encounters an error, or needs to be canceled.
  /// </remarks>
  TAsynStreamCallBack<T> = record
  private
    FSender: TObject;
    FOnStart: TProc<TObject>;
    FOnSuccess: TProc<TObject>;
    FOnProgress: TProc<TObject, T>;
    FOnError: TProc<TObject, string>;
    FOnCancellation: TProc<TObject>;
    FOnDoCancel: TFunc<Boolean>;
  public
    /// <summary>
    /// The object representing the sender of the asynchronous operation.
    /// </summary>
    /// <remarks>
    /// The <c>Sender</c> property is used to identify or store a reference to the object that initiated the chat request,
    /// which can be useful for context within the callback procedures.
    /// </remarks>
    property Sender: TObject read FSender write FSender;
    /// <summary>
    /// Event triggered when the asynchronous chat request starts.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="Chat">
    /// The <c>TChat</c> object representing the current response chunk received from the model.
    /// This event can be used to update the user interface as new tokens are streamed in.
    /// </param>
    /// <remarks>
    /// The <c>OnStart</c> event is called when the chat request begins. It can be used to set up any initial state or display a loading indicator to the user.
    /// <code>
    /// OnStart :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // code when chat request begin
    ///    end;
    /// </code>
    /// </remarks>
    property OnStart: TProc<TObject> read FOnStart write FOnStart;
    /// <summary>
    /// Event triggered when the asynchronous chat request completes successfully.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="Chat">
    /// The <c>TChat</c> object representing the current response chunk received from the model.
    /// This event can be used to update the user interface as new tokens are streamed in.
    /// </param>
    /// <remarks>
    /// The <c>OnSuccess</c> event is invoked when the streaming process finishes successfully.
    /// It does not provide additional data, as the result is expected to have been handled progressively via the <c>OnProgress</c> event.
    /// <code>
    /// OnSuccess :=
    ///    procedure (Sender: TObject; Chat: TChat)
    ///    begin
    ///      // code when the streaming process finishes successfully
    ///    end;
    /// </code>
    /// </remarks>
    property OnSuccess: TProc<TObject> read FOnSuccess write FOnSuccess;
    /// <summary>
    /// Event triggered to handle progress during the streaming chat request.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="Chat">
    /// The <c>TChat</c> object representing the current response chunk received from the model.
    /// This event can be used to update the user interface as new tokens are streamed in.
    /// </param>
    /// <remarks>
    /// The <c>OnProgress</c> event is fired every time a new chunk of data is received during the streaming process.
    /// This allows the application to handle the response progressively as it is generated by the model.
    /// <code>
    /// OnProgress :=
    ///    procedure (Sender: TObject; Chat: TChat)
    ///    begin
    ///      // code to handle the response progressively
    ///    end;
    /// </code>
    /// </remarks>
    property OnProgress: TProc<TObject, T> read FOnProgress write FOnProgress;
    /// <summary>
    /// Event triggered when an error occurs during the asynchronous chat request.
    /// </summary>
    /// <param name="Sender">
    /// The object that initiated the request, typically used for context.
    /// </param>
    /// <param name="ErrorMessage">
    /// The error message received, which can be logged or displayed to the user.
    /// </param>
    /// <remarks>
    /// The <c>OnError</c> event is called when an error occurs during the streaming process.
    /// This can be used to handle failures, show error messages, or perform any necessary clean-up actions.
    /// <code>
    /// OnError :=
    ///    procedure (Sender: TObject; message: string)
    ///    begin
    ///      // code to handle an error occurs during the streaming process
    ///    end;
    /// </code>
    /// </remarks>
    property OnError: TProc<TObject, string> read FOnError write FOnError;
    /// <summary>
    /// Event triggered when the asynchronous chat request has been canceled.
    /// </summary>
    /// <remarks>
    /// The <c>OnCancellation</c> event is fired when the chat request is canceled by the user or the application.
    /// This can be used to perform clean-up operations or notify the user that the request has been terminated.
    /// <code>
    /// OnCancellation :=
    ///    procedure (Sender: TObject)
    ///    begin
    ///      // code to handle chat request cancellation
    ///    end;
    /// </code>
    /// </remarks>
    property OnCancellation: TProc<TObject> read FOnCancellation write FOnCancellation;
    /// <summary>
    /// Function called to determine if the asynchronous chat request should be canceled.
    /// </summary>
    /// <returns>
    /// A <c>Boolean</c> value indicating whether the request should be canceled (<c>True</c>) or allowed to continue (<c>False</c>).
    /// </returns>
    /// <remarks>
    /// The <c>OnDoCancel</c> function is periodically invoked to check whether the user or application has requested to cancel the chat request.
    /// If the function returns <c>True</c>, the streaming process will be aborted.
    /// <code>
    /// OnDoCancel :=
    ///    function : Boolean
    ///    begin
    ///      Result := ... // True to stop the streaming process
    ///    end;
    /// </code>
    /// </remarks>
    property OnDoCancel: TFunc<Boolean> read FOnDoCancel write FOnDoCancel;
  end;

implementation

{ TAsynCallBackExec<T, U> }

constructor TAsynCallBackExec<T, U>.Create(const Value: TFunc<T>);
begin
  inherited Create;
  FUse := TUseParamsFactory<T>.CreateInstance(Value);
end;

procedure TAsynCallBackExec<T, U>.Run(Value: TFunc<U>);
begin
  {--- Assign callback values to internal variables for asynchrony to work properly }
  var InternalSender := Sender;
  var InternalOnStart := OnStart;
  var InternalOnSuccess := OnSuccess;
  var InternalOnError := OnError;

  var Task: ITask := TTask.Create(
          procedure()
          begin
            try
              {--- Pass the instance of the current class in case no value was specified. }
              if not Assigned(InternalSender) then
                InternalSender := Self;

              {--- Trigger OnStart callback }
              if Assigned(InternalOnStart) then
                TThread.Queue(nil,
                  procedure
                  begin
                    InternalOnStart(InternalSender);
                  end);

              {--- Processing }
              var Result := Value();

              {--- Trigger OnEnd callback when the process is done }
              TThread.Queue(nil,
                  procedure
                  begin
                    try
                      if Assigned(InternalOnSuccess) then
                        InternalOnSuccess(InternalSender, Result);
                    finally
                      {--- Makes sure to release the instance containing the data obtained
                           following processing}
                      if Assigned(Result) then
                        Result.Free;
                    end;
                  end);

            except
              on E: Exception do
                begin
                  var Error := AcquireExceptionObject;
                  try
                    var ErrorMsg := (Error as Exception).Message;

                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(InternalOnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        InternalOnError(InternalSender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
          end);
  Task.Start;
end;

end.

unit Gemini.Caching;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGemini
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.JSON, Gemini.API.Params, Gemini.API,
  Gemini.Tools, Gemini.Async.Support, Gemini.Chat, Gemini.Functions.Core;

type
  /// <summary>
  /// Represents parameters for configuring cached content in the caching API.
  /// </summary>
  /// <remarks>
  /// Use this class to set various parameters when creating or updating cached content.
  /// Supports method chaining for setting multiple parameters in a fluent style.
  /// </remarks>
  TCacheParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the content of the current conversation with the model.
    /// </summary>
    /// <param name="Value">
    /// An array of <c>TContentPayload</c> instances representing the messages exchanged in the conversation, including both user and assistant messages.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TCacheParams</c> instance, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// For single-turn queries, this array contains a single message. For multi-turn conversations, include the entire conversation history and the latest message.
    /// </remarks>
    function Contents(const Value: TArray<TContentPayload>): TCacheParams;
    /// <summary>
    /// Specifies a list of tools that the model may use to generate the next response.
    /// </summary>
    /// <param name="Value">
    /// An array of <c>IFunctionCore</c> instances representing the tools available to the model.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TCacheParams</c> instance, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// A tool is a piece of code that allows the model to interact with external systems or perform actions outside its knowledge base.
    /// Supported tools include functions and code execution capabilities. Refer to the Function Calling and Code Execution guides for more information.
    /// </remarks>
    function Tools(const Value: TArray<IFunctionCore>): TCacheParams; overload;
    /// <summary>
    /// Specifies whether code execution is available as a tool for the model.
    /// </summary>
    /// <param name="CodeExecution">
    /// A boolean value where <c>True</c> enables code execution as a tool, and <c>False</c> disables it.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TCacheParams</c> instance, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// When enabled, the model can generate code that can be executed to perform tasks.
    /// </remarks>
    function Tools(const CodeExecution: Boolean): TCacheParams; overload;
    /// <summary>
    /// Configures the tool settings for any tools specified in the request.
    /// </summary>
    /// <param name="Value">
    /// A <c>TToolMode</c> value specifying the mode in which tools are used by the model.
    /// </param>
    /// <param name="AllowedFunctionNames">
    /// Optional. An array of strings representing the names of functions that the model is allowed to use.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TCacheParams</c> instance, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// Use this method to specify how the model should use the available tools, including restricting which functions can be called.
    /// Refer to the Function Calling guide for usage examples.
    /// <para>
    /// - This config is shared for all tools.
    /// </para>
    /// </remarks>
    function ToolConfig(const Value: TToolMode; AllowedFunctionNames: TArray<string> = []): TCacheParams;
    /// <summary>
    /// Input only. New TTL for this resource, input only.
    /// </summary>
    /// <param name="Value">
    /// A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
    /// </param>
    /// <returns>
    /// Returns the updated <c>TCacheParams</c> instance, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// The JSON representation for Duration is a String that ends in s to indicate seconds and is preceded by the number of seconds, with nanoseconds expressed as fractional seconds.
    /// </remarks>
    function ttl(const Value: string): TCacheParams;
    /// <summary>
    /// Optional. Identifier. The resource name referring to the cached content.
    /// </summary>
    /// <param name="Value">
    /// Format: cachedContents/{id}
    /// </param>
    /// <returns>
    /// Returns the updated <c>TCacheParams</c> instance, allowing for method chaining.
    /// </returns>
    function Name(const Value: string): TCacheParams;
    /// <summary>
    /// Optional. Immutable. The user-generated meaningful display name of the cached content.
    /// </summary>
    /// <param name="Value">
    /// Maximum 128 Unicode characters.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TCacheParams</c> instance, allowing for method chaining.
    /// </returns>
    function DisplayName(const Value: string): TCacheParams;
    /// <summary>
    /// Required. Immutable. The name of the Model to use for cached content
    /// </summary>
    /// <param name="Value">
    /// Format: models/{model}
    /// </param>
    /// <returns>
    /// Returns the updated <c>TCacheParams</c> instance, allowing for method chaining.
    /// </returns>
    function Model(const Value: string): TCacheParams;
    /// <summary>
    /// Optional. Input only. Immutable. Developer set system instruction.
    /// </summary>
    /// <param name="Value">
    /// Currently text only.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TCacheParams</c> instance, allowing for method chaining.
    /// </returns>
    function SystemInstruction(const Value: string): TCacheParams;
    /// <summary>
    /// Creates a new <c>TCacheParams</c> instance and allows configuration through a procedure reference.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure reference that receives a <c>TCacheParams</c> instance to configure its properties.
    /// </param>
    /// <returns>
    /// Returns a new configured <c>TCacheParams</c> instance.
    /// </returns>
    class function New(ParamProc: TProcRef<TCacheParams>): TCacheParams; static;
  end;

  /// <summary>
  /// Updates CachedContent resource.
  /// </summary>
  /// <remarks>
  /// Only expiration is updatable
  /// </remarks>
  TCacheUpdateParams = class(TJSONParam)
  public
    /// <summary>
    /// Input only. New TTL for this resource, input only.
    /// </summary>
    /// <param name="Value">
    /// A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
    /// </param>
    /// <returns>
    /// Returns the updated <c>TCacheUpdateParams</c> instance, allowing for method chaining.
    /// </returns>
    function ttl(const Value: string): TCacheParams;
    /// <summary>
    /// Optional. Identifier. The resource name referring to the cached content.
    /// </summary>
    /// <param name="Value">
    /// Format: cachedContents/{id}
    /// </param>
    /// <returns>
    /// Returns the updated <c>TCacheUpdateParams</c> instance, allowing for method chaining.
    /// </returns>
    function Name(const Value: string): TCacheParams;
  end;

  /// <summary>
  /// Content that has been preprocessed and can be used in subsequent request to GenerativeService.
  /// </summary>
  /// <remarks>
  /// Cached content can be only used with model it was created for.
  /// </remarks>
  TCache = class
  private
    FCreateTime: string;
    FUpdateTime: string;
    FUsageMetadata: TUsageMetadata;
    FExpireTime: string;
    FName: string;
    FDisplayName: string;
    FModel: string;
  public
    /// <summary>
    /// Creation time of the cache entry.
    /// </summary>
    /// <remarks>
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    /// </remarks>
    property CreateTime: string read FCreateTime write FCreateTime;
    /// <summary>
    /// When the cache entry was last updated in UTC time.
    /// </summary>
    /// <remarks>
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    /// </remarks>
    property UpdateTime: string read FUpdateTime write FUpdateTime;
    /// <summary>
    /// Metadata on the usage of the cached content.
    /// </summary>
    property UsageMetadata: TUsageMetadata read FUsageMetadata write FUsageMetadata;
    /// <summary>
    /// Timestamp in UTC of when this resource is considered expired. This is always provided on output, regardless of what was sent on input.
    /// </summary>
    /// <remarks>
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    /// </remarks>
    property ExpireTime: string read FExpireTime write FExpireTime;
    /// <summary>
    /// Identifier. The resource name referring to the cached content.
    /// </summary>
    /// <remarks>
    /// Format: cachedContents/{id}
    /// </remarks>
    property Name: string read FName write FName;
    /// <summary>
    /// Optional. Immutable. The user-generated meaningful display name of the cached content.
    /// </summary>
    /// <remarks>
    /// Maximum 128 Unicode characters.
    /// </remarks>
    property DisplayName: string read FDisplayName write FDisplayName;
    /// <summary>
    /// Required. Immutable. The name of the Model to use for cached content.
    /// </summary>
    /// <remarks>
    /// Format: models/{model}
    /// </remarks>
    property Model: string read FModel write FModel;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Lists CachedContents.
  /// </summary>
  TCacheContents = class
  private
    FCachedContents: TArray<TCache>;
    FNextPageToken: string;
  public
    /// <summary>
    /// List of cached contents.
    /// </summary>
    property CachedContents: TArray<TCache> read FCachedContents write FCachedContents;
    /// <summary>
    /// A token, which can be sent as pageToken to retrieve the next page.
    /// </summary>
    /// <remarks>
    /// If this field is omitted, there are no subsequent pages.
    /// </remarks>
    property NextPageToken: string read FNextPageToken write FNextPageToken;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Class defined for compatibility with asynchrony handling.
  /// </summary>
  TCacheDelete = class
  end;

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TCache</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynCache</c> type extends the <c>TAsynParams&lt;TCache&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynCache = TAsynCallBack<TCache>;

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TCacheContents</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynCacheContents</c> type extends the <c>TAsynParams&lt;TCacheContents&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynCacheContents = TAsynCallBack<TCacheContents>;

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TCacheDelete</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynCacheDelete</c> type extends the <c>TAsynParams&lt;TCacheDelete&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynCacheDelete = TAsynCallBack<TCacheDelete>;

  /// <summary>
  /// Provides methods to interact with the caching API for creating, retrieving, updating, listing, and deleting cached content both asynchronously and synchronously.
  /// </summary>
  TCachingRoute = class(TGeminiAPIRoute)
    /// <summary>
    /// Asynchronously creates a new cached content using specified parameters.
    /// </summary>
    /// <param name="ParamProc">A procedure to configure the cache parameters.</param>
    /// <param name="CallBacks">A function that returns asynchronous callbacks for handling the operation's lifecycle.</param>
    /// <remarks>
    /// This method initiates an asynchronous operation to create cached content.
    /// The provided callbacks will be invoked to handle success, error, and progress updates.
    /// <para>
    /// Example :
    /// </para>
    /// <code>
    ///   ASynCreate(
    ///    procedure (Params: TCacheParams)
    ///    begin
    ///      // Set parameters
    ///    end,
    ///
    ///    function : TAsynCache
    ///    begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject)
    ///        begin
    ///           // Trigger the start method
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Cache: TCache)
    ///        begin
    ///          // Trigger the success method
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Trigger the error method
    ///        end;
    ///    end);
    /// </code>
    /// </remarks>
    procedure ASynCreate(ParamProc: TProc<TCacheParams>; CallBacks: TFunc<TAsynCache>); overload;
    /// <summary>
    /// Asynchronously creates a new cached content from a JSON object.
    /// </summary>
    /// <param name="Value">A JSON object containing the cache parameters.</param>
    /// <param name="CallBacks">A function that returns asynchronous callbacks for handling the operation's lifecycle.</param>
    /// <remarks>
    /// Use this method when you have the cache parameters prepared in a JSON format.
    /// The method takes ownership of the provided JSON object and will free it after use.
    /// <para>
    /// Example :
    /// </para>
    /// <code>
    ///   ASynCreate(Value,
    ///    function : TAsynCache
    ///    begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject)
    ///        begin
    ///           // Trigger the start method
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Cache: TCache)
    ///        begin
    ///          // Trigger the success method
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Trigger the error method
    ///        end;
    ///    end);
    /// </code>
    /// </remarks>
    procedure ASynCreate(const Value: TJSONObject; CallBacks: TFunc<TAsynCache>); overload;
    /// <summary>
    /// Asynchronously lists cached contents with pagination support.
    /// </summary>
    /// <param name="PageSize">The maximum number of cached contents to return per page.</param>
    /// <param name="PageToken">The token for the page of results to retrieve.</param>
    /// <param name="CallBacks">A function that returns asynchronous callbacks for handling the operation's lifecycle.</param>
    /// <remarks>
    /// If <c>PageToken</c> is empty, the first page is returned.
    /// The provided callbacks will be invoked as the operation progresses.
    /// <para>
    /// Example :
    /// </para>
    /// <code>
    ///   // Declare the variable "Next" as a string type earlier in the code.
    ///   ASynList(PageSize, Next
    ///    function : TAsynCacheContents
    ///    begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject)
    ///        begin
    ///           // Trigger the start method
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; CacheContents: TCacheContents)
    ///        begin
    ///          // Trigger the success method
    ///          Next := CacheContents.NextPageToken;
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Trigger the error method
    ///        end;
    ///    end);
    /// </code>
    /// </remarks>
    procedure ASynList(const PageSize: Integer; const PageToken: string;
      CallBacks: TFunc<TAsynCacheContents>);
    /// <summary>
    /// Asynchronously retrieves a cached content by its name.
    /// </summary>
    /// <param name="CacheName">The unique name of the cached content to retrieve, in the format 'cachedContents/{id}'.</param>
    /// <param name="CallBacks">A function that returns asynchronous callbacks for handling the operation's lifecycle.</param>
    /// <remarks>
    /// <code>
    ///   ASynRetrieve('CacheName_to_retrieve',
    ///    function : TAsynCache
    ///    begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject)
    ///        begin
    ///           // Trigger the start method
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Cache: TCache)
    ///        begin
    ///          // Trigger the success method
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Trigger the error method
    ///        end;
    ///    end);
    /// </code>
    /// </remarks>
    procedure ASynRetrieve(const CacheName: string; CallBacks: TFunc<TAsynCache>);
    /// <summary>
    /// Asynchronously updates the TTL (Time To Live) of a cached content.
    /// </summary>
    /// <param name="CacheName">The unique name of the cached content to update.</param>
    /// <param name="ttl">The new TTL value, specified as a duration string (e.g., '3600s' for one hour).</param>
    /// <param name="CallBacks">A function that returns asynchronous callbacks for handling the operation's lifecycle.</param>
    /// <remarks>
    /// This overload simplifies updating the TTL without the need to specify other parameters.
    /// <para>
    /// Example :
    /// </para>
    /// <code>
    ///   ASynUpdate(CacheName, '2500s',
    ///    function : TAsynCache
    ///    begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject)
    ///        begin
    ///           // Trigger the start method
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Cache: TCache)
    ///        begin
    ///          // Trigger the success method
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Trigger the error method
    ///        end;
    ///    end);
    /// </code>
    /// </remarks>
    procedure ASynUpdate(const CacheName: string; const ttl: string;
      CallBacks: TFunc<TAsynCache>); overload;
    /// <summary>
    /// Asynchronously updates a cached content using specified parameters.
    /// </summary>
    /// <param name="CacheName">The unique name of the cached content to update.</param>
    /// <param name="ParamProc">A procedure to configure the update parameters.</param>
    /// <param name="CallBacks">A function that returns asynchronous callbacks for handling the operation's lifecycle.</param>
    /// <remarks>
    /// Only the TTL can be updated for a cached content.
    /// <para>
    /// Example :
    /// </para>
    /// <code>
    ///   ASynUpdate(CacheName,
    ///    procedure (Params: TCacheUpdateParams)
    ///    begin
    ///      // Set parameters
    ///    end,
    ///    function : TAsynCache
    ///    begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject)
    ///        begin
    ///           // Trigger the start method
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Cache: TCache)
    ///        begin
    ///          // Trigger the success method
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Trigger the error method
    ///        end;
    ///    end);
    /// </code>
    /// </remarks>
    procedure ASynUpdate(const CacheName: string; ParamProc: TProc<TCacheUpdateParams>;
      CallBacks: TFunc<TAsynCache>); overload;
    /// <summary>
    /// Asynchronously deletes a cached content by its name.
    /// </summary>
    /// <param name="CacheName">The unique name of the cached content to delete.</param>
    /// <param name="CallBacks">A function that returns asynchronous callbacks for handling the operation's lifecycle.</param>
    /// <remarks>
    /// Upon successful deletion, the callbacks will be invoked with the result.
    /// <para>
    /// Example :
    /// </para>
    /// <code>
    ///   ASynDelete(CacheName,
    ///    function : TAsynCacheDelete
    ///    begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject)
    ///        begin
    ///           // Trigger the start method
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Cache: TCacheDelete)
    ///        begin
    ///          // Trigger the success method
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Trigger the error method
    ///        end;
    ///    end);
    /// </code>
    /// </remarks>
    procedure ASynDelete(const CacheName: string; CallBacks: TFunc<TAsynCacheDelete>);
    /// <summary>
    /// Synchronously creates a new cached content from a JSON object.
    /// </summary>
    /// <param name="Value">A <c>TJSONObject</c> containing the cache parameters.</param>
    /// <returns>The created <c>TCache</c> object representing the cached content.</returns>
    /// <remarks>
    /// The method takes ownership of the provided JSON object and will free it after use.
    /// </remarks>
    function Create(const Value: TJSONObject): TCache; overload;
    /// <summary>
    /// Synchronously creates a new cached content using specified parameters.
    /// </summary>
    /// <param name="ParamProc">A procedure to configure the cache parameters.</param>
    /// <returns>The created <c>TCache</c> object representing the cached content.</returns>
    /// <remarks>
    /// This method blocks until the cached content is created.
    /// <para>
    /// Example
    /// </para>
    /// <code>
    ///   var Cache := Create(
    ///     procedure (Params: TCacheParams)
    ///     begin
    ///       // Set parameters
    ///     end);
    ///   try
    ///     // Do something
    ///   finally
    ///     Cache.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Create(ParamProc: TProc<TCacheParams>): TCache; overload;
    /// <summary>
    /// Synchronously lists cached contents with pagination support.
    /// </summary>
    /// <param name="PageSize">The maximum number of cached contents to return per page.</param>
    /// <param name="PageToken">The token for the page of results to retrieve.</param>
    /// <returns>A <c>TCacheContents</c> object containing the list of cached contents and a next page token, if any.</returns>
    /// <remarks>
    /// If <c>PageToken</c> is empty, the first page is returned.
    /// </remarks>
    function List(const PageSize: Integer; const PageToken: string): TCacheContents; overload;
    /// <summary>
    /// Synchronously retrieves a cached content by its name.
    /// </summary>
    /// <param name="CacheName">The unique name of the cached content to retrieve.</param>
    /// <returns>The retrieved <c>TCache</c> object representing the cached content.</returns>
    function Retrieve(const CacheName: string): TCache;
    /// <summary>
    /// Synchronously updates a cached content from a JSON object.
    /// </summary>
    /// <param name="CacheName">The unique name of the cached content to update.</param>
    /// <param name="Value">A <c>TJSONObject</c> containing the update parameters.</param>
    /// <returns>The updated <c>TCache</c> object representing the cached content.</returns>
    /// <remarks>
    /// The method takes ownership of the provided JSON object and will free it after use.
    /// </remarks>
    function Update(const CacheName: string; const Value: TJSONObject): TCache; overload;
    /// <summary>
    /// Synchronously updates the TTL (Time To Live) of a cached content.
    /// </summary>
    /// <param name="CacheName">The unique name of the cached content to update.</param>
    /// <param name="ttl">The new TTL value, specified as a duration string (e.g., '3600s' for one hour).</param>
    /// <returns>The updated <c>TCache</c> object representing the cached content.</returns>
    /// <remarks>
    /// This overload simplifies updating the TTL without the need to specify other parameters.
    /// </remarks>
    function Update(const CacheName: string; const ttl: string): TCache; overload;
    /// <summary>
    /// Synchronously updates a cached content using specified parameters.
    /// </summary>
    /// <param name="CacheName">The unique name of the cached content to update.</param>
    /// <param name="ParamProc">A procedure to configure the update parameters.</param>
    /// <returns>The updated <c>TCache</c> object representing the cached content.</returns>
    /// <remarks>
    /// Only the TTL can be updated for a cached content.
    /// <para>
    /// Example
    /// </para>
    /// <code>
    ///   var Cache := Create(
    ///     procedure (Params: TCacheUpdateParams)
    ///     begin
    ///       // Set parameters
    ///     end);
    ///   try
    ///     // Do something
    ///   finally
    ///     Cache.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Update(const CacheName: string; ParamProc: TProc<TCacheUpdateParams>): TCache; overload;
    /// <summary>
    /// Synchronously deletes a cached content by its name.
    /// </summary>
    /// <param name="CacheName">The unique name of the cached content to delete.</param>
    /// <returns>A <c>TCacheDelete</c> object indicating the result of the deletion.</returns>
    function Delete(const CacheName: string): TCacheDelete;
  end;

implementation

{ TCacheParams }

function TCacheParams.Contents(
  const Value: TArray<TContentPayload>): TCacheParams;
begin
  var JSONContents := TJSONArray.Create;
  for var Item in Value do
    JSONContents.Add(Item.Detach);
  Result := TCacheParams(Add('contents', JSONContents));
end;

function TCacheParams.DisplayName(const Value: string): TCacheParams;
begin
  Result := TCacheParams(Add('displayName', Value));
end;

function TCacheParams.Model(const Value: string): TCacheParams;
begin
  Result := TCacheParams(Add('model', Value));
end;

function TCacheParams.Name(const Value: string): TCacheParams;
begin
  Result := TCacheParams(Add('name', Value));
end;

class function TCacheParams.New(ParamProc: TProcRef<TCacheParams>): TCacheParams;
begin
  Result := TCacheParams.Create;
  if Assigned(ParamProc) then
    ParamProc(Result);
end;

function TCacheParams.SystemInstruction(const Value: string): TCacheParams;
begin
  var PartsJSON := TJSONObject.Create.AddPair('parts', TJSONObject.Create.AddPair('text', Value));
  Result := TCacheParams(Add('systemInstruction', PartsJSON));
end;

function TCacheParams.ToolConfig(const Value: TToolMode;
  AllowedFunctionNames: TArray<string>): TCacheParams;
begin
  var JSONResult := TJSONObject.Create.AddPair('mode', Value.ToString);
  if Length(AllowedFunctionNames) > 0 then
    begin
      var JSONArray := TJSONArray.Create;
      for var Item in AllowedFunctionNames do
        begin
          JSONArray.Add(Item);
        end;
      JSONResult.AddPair('allowedFunctionNames', JSONArray);
    end;
  Result := TCacheParams(Add('toolConfig',
              TJSONObject.Create.AddPair('function_calling_config', JSONResult)));
end;

function TCacheParams.Tools(const CodeExecution: Boolean): TCacheParams;
begin
  if not CodeExecution then
    Exit(Self);
  var JSONCodeExecution := TJSONObject.Create.AddPair('codeExecution', TJSONObject.Create);
  Result := TCacheParams(Add('tools', TJSONArray.Create.Add(JSONCodeExecution)));
end;

function TCacheParams.Tools(
  const Value: TArray<IFunctionCore>): TCacheParams;
begin
  var JSONFuncs := TJSONArray.Create;
  for var Item in value do
    begin
      JSONFuncs.Add(TToolPluginParams.Add(Item).ToJson);
    end;
  var JSONDeclaration := TJSONObject.Create.AddPair('function_declarations', JSONFuncs);
  Result := TCacheParams(Add('tools', TJSONArray.Create.Add(JSONDeclaration)));
end;

function TCacheParams.ttl(const Value: string): TCacheParams;
begin
  Result := TCacheParams(Add('ttl', Value));
end;

{ TCache }

destructor TCache.Destroy;
begin
  if Assigned(FUsageMetadata) then
    FUsageMetadata.Free;
  inherited;
end;

{ TCachingRoute }

procedure TCachingRoute.ASynCreate(ParamProc: TProc<TCacheParams>;
  CallBacks: TFunc<TAsynCache>);
begin
  with TAsynCallBackExec<TAsynCache, TCache>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TCache
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TCachingRoute.ASynCreate(const Value: TJSONObject;
  CallBacks: TFunc<TAsynCache>);
begin
  with TAsynCallBackExec<TAsynCache, TCache>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TCache
      begin
        Result := Self.Create(Value);
      end);
  finally
    Free;
  end;
end;

procedure TCachingRoute.ASynDelete(const CacheName: string;
  CallBacks: TFunc<TAsynCacheDelete>);
begin
  with TAsynCallBackExec<TAsynCacheDelete, TCacheDelete>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TCacheDelete
      begin
        Result := Self.Delete(CacheName);
      end);
  finally
    Free;
  end;
end;

procedure TCachingRoute.ASynList(const PageSize: Integer;
  const PageToken: string; CallBacks: TFunc<TAsynCacheContents>);
begin
  with TAsynCallBackExec<TAsynCacheContents, TCacheContents>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TCacheContents
      begin
        Result := Self.List(PageSize, PageToken);
      end);
  finally
    Free;
  end;
end;

procedure TCachingRoute.ASynRetrieve(const CacheName: string;
  CallBacks: TFunc<TAsynCache>);
begin
  with TAsynCallBackExec<TAsynCache, TCache>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TCache
      begin
        Result := Self.Retrieve(CacheName);
      end);
  finally
    Free;
  end;
end;

procedure TCachingRoute.ASynUpdate(const CacheName, ttl: string;
  CallBacks: TFunc<TAsynCache>);
begin
  with TAsynCallBackExec<TAsynCache, TCache>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TCache
      begin
        Result := Self.Update(CacheName, ttl);
      end);
  finally
    Free;
  end;
end;

procedure TCachingRoute.ASynUpdate(const CacheName: string;
  ParamProc: TProc<TCacheUpdateParams>; CallBacks: TFunc<TAsynCache>);
begin
  with TAsynCallBackExec<TAsynCache, TCache>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TCache
      begin
        Result := Self.Update(CacheName, ParamProc);
      end);
  finally
    Free;
  end;
end;

function TCachingRoute.Create(const Value: TJSONObject): TCache;
begin
  try
    Result := API.Post<TCache>('cachedContents', Value);
  finally
    Value.Free;
  end;
end;

function TCachingRoute.Create(ParamProc: TProc<TCacheParams>): TCache;
begin
  Result := API.Post<TCache, TCacheParams>('cachedContents', ParamProc);
end;

function TCachingRoute.Delete(const CacheName: string): TCacheDelete;
begin
  Result := API.Delete<TCacheDelete>(CacheName);
end;

function TCachingRoute.List(const PageSize: Integer;
  const PageToken: string): TCacheContents;
begin
  Result := API.Get<TCacheContents>('cachedContents', ParamsBuilder(PageSize, PageToken));
end;

function TCachingRoute.Retrieve(const CacheName: string): TCache;
begin
  Result := API.Get<TCache>(CacheName);
end;

function TCachingRoute.Update(const CacheName: string;
  const Value: TJSONObject): TCache;
begin
  Result := API.Patch<TCache>(CacheName, Value);
end;

function TCachingRoute.Update(const CacheName, ttl: string): TCache;
begin
  var Cache := TCacheUpdateParams.Create.ttl(ttl);
  try
    Result := Update(CacheName, Cache.JSON)
  finally
    Cache.Free;
  end;
end;

function TCachingRoute.Update(const CacheName: string;
  ParamProc: TProc<TCacheUpdateParams>): TCache;
begin
  Result := API.Patch<TCache, TCacheUpdateParams>(CacheName, ParamProc);
end;

{ TCacheContents }

destructor TCacheContents.Destroy;
begin
  for var Item in FCachedContents do
    Item.Free;
  inherited;
end;

{ TCacheUpdateParams }

function TCacheUpdateParams.Name(const Value: string): TCacheParams;
begin
  Result := TCacheParams(Add('name', Value));
end;

function TCacheUpdateParams.ttl(const Value: string): TCacheParams;
begin
  Result := TCacheParams(Add('ttl', Value));
end;

end.

unit Gemini.Chat;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGemini
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, System.Threading,
  REST.Json.Types, Gemini.API.Params, Gemini.API, Gemini.Safety, Gemini.Schema,
  Gemini.Tools, Gemini.Async.Support, Gemini.Functions.Core, Gemini.GoogleSearch;

type
  /// <summary>
  /// Kind of tool call
  /// </summary>
  TToolKind = (
    /// <summary>
    /// Enable code execution
    /// </summary>
    CodeExecution,
    /// <summary>
    /// Enable google search
    /// </summary>
    GoogleSearch
  );

  /// <summary>
  /// Type of message role
  /// </summary>
  TMessageRole = (
    /// <summary>
    /// User message
    /// </summary>
    user,
    /// <summary>
    /// Assistant message
    /// </summary>
    model
  );

  /// <summary>
  /// Helper record for the <c>TMessageRole</c> enumeration, providing utility methods for converting
  /// between <c>TMessageRole</c> values and their string representations.
  /// </summary>
  TMessageRoleHelper = record helper for TMessageRole
    /// <summary>
    /// Converts the current <c>TMessageRole</c> value to its corresponding string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>TMessageRole</c> value.
    /// </returns>
    function ToString: string;
    /// <summary>
    /// Converts a string representation of a <c>TMessageRole</c> into its corresponding enumeration value.
    /// </summary>
    /// <param name="Value">
    /// The string representing a <c>TMessageRole</c>.
    /// </param>
    /// <returns>
    /// The <c>TMessageRole</c> enumeration value that corresponds to the provided string.
    /// </returns>
    class function Create(const Value: string): TMessageRole; static;
  end;

  /// <summary>
  /// Interceptor class for converting <c>TMessageRole</c> values to and from their string representations in JSON serialization and deserialization.
  /// </summary>
  /// <remarks>
  /// This class is used to facilitate the conversion between the <c>TMessageRole</c> enum and its string equivalents during JSON processing.
  /// It extends the <c>TJSONInterceptorStringToString</c> class to override the necessary methods for custom conversion logic.
  /// </remarks>
  TMessageRoleInterceptor = class(TJSONInterceptorStringToString)
    /// <summary>
    /// Converts the <c>TMessageRole</c> value of the specified field to a string during JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be converted.
    /// </param>
    /// <param name="Field">
    /// The field name representing the <c>TMessageRole</c> value.
    /// </param>
    /// <returns>
    /// The string representation of the <c>TMessageRole</c> value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string back to a <c>TMessageRole</c> value for the specified field during JSON deserialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be set.
    /// </param>
    /// <param name="Field">
    /// The field name where the <c>TMessageRole</c> value will be set.
    /// </param>
    /// <param name="Arg">
    /// The string representation of the <c>TMessageRole</c> to be converted back.
    /// </param>
    /// <remarks>
    /// This method converts the string argument back to the corresponding <c>TMessageRole</c> value and assigns it to the specified field in the object.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Defines the reason why the model stopped generating tokens.
  /// </summary>
  TFinishReason = (
    /// <summary>
    /// Default value. This value is unused.
    /// </summary>
    FINISH_REASON_UNSPECIFIED,
    /// <summary>
    /// Natural stop point of the model or provided stop sequence.
    /// </summary>
    STOP,
    /// <summary>
    /// The maximum number of tokens as specified in the request was reached.
    /// </summary>
    MAX_TOKENS,
    /// <summary>
    /// The response candidate content was flagged for safety reasons.
    /// </summary>
    SAFETY,
    /// <summary>
    /// The response candidate content was flagged for recitation reasons.
    /// </summary>
    RECITATION,
    /// <summary>
    /// The response candidate content was flagged for using an unsupported language.
    /// </summary>
    LANGUAGE,
    /// <summary>
    ///  Unknown reason.
    /// </summary>
    OTHER,
    /// <summary>
    /// Token generation stopped because the content contains forbidden terms.
    /// </summary>
    BLOCKLIST,
    /// <summary>
    /// Token generation stopped for potentially containing prohibited content.
    /// </summary>
    PROHIBITED_CONTENT,
    /// <summary>
    /// Token generation stopped because the content potentially contains Sensitive Personally Identifiable Information (SPII).
    /// </summary>
    SPII,
    /// <summary>
    /// The function call generated by the model is invalid.
    /// </summary>
    MALFORMED_FUNCTION_CALL
  );

  /// <summary>
  /// Helper record for the <c>TFinishReason</c> enumeration, providing utility methods for converting
  /// between <c>TFinishReason</c> values and their string representations.
  /// </summary>
  TFinishReasonHelper = record helper for TFinishReason
    /// <summary>
    /// Converts the current <c>TFinishReason</c> value to its string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>TFinishReason</c> value.
    /// </returns>
    function ToString: string;
    /// <summary>
    /// Creates a <c>TFinishReason</c> value from its corresponding string representation.
    /// </summary>
    /// <param name="Value">
    /// The string value representing a <c>TFinishReason</c>.
    /// </param>
    /// <returns>
    /// The corresponding <c>TFinishReason</c> enumeration value for the provided string.
    /// </returns>
    /// <remarks>
    /// This method throws an exception if the input string does not match any valid <c>TFinishReason</c> values.
    /// </remarks>
    class function Create(const Value: string): TFinishReason; static;
  end;

  /// <summary>
  /// Interceptor class for converting <c>TFinishReason</c> values to and from their string representations in JSON serialization and deserialization.
  /// </summary>
  /// <remarks>
  /// This class is used to facilitate the conversion between the <c>TFinishReason</c> enum and its string equivalents during JSON processing.
  /// It extends the <c>TJSONInterceptorStringToString</c> class to override the necessary methods for custom conversion logic.
  /// </remarks>
  TFinishReasonInterceptor = class(TJSONInterceptorStringToString)
    /// <summary>
    /// Converts the <c>TFinishReason</c> value of the specified field to a string during JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be converted.
    /// </param>
    /// <param name="Field">
    /// The field name representing the <c>TFinishReason</c> value.
    /// </param>
    /// <returns>
    /// The string representation of the <c>TFinishReason</c> value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string back to a <c>TFinishReason</c> value for the specified field during JSON deserialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be set.
    /// </param>
    /// <param name="Field">
    /// The field name where the <c>TFinishReason</c> value will be set.
    /// </param>
    /// <param name="Arg">
    /// The string representation of the <c>TFinishReason</c> to be converted back.
    /// </param>
    /// <remarks>
    /// This method converts the string argument back to the corresponding <c>TFinishReason</c> value and assigns it to the specified field in the object.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Supported programming languages for the generated code.
  /// </summary>
  TLangueType = (
    /// <summary>
    /// Language not specified. This value should not be used.
    /// </summary>
    LANGUAGE_UNSPECIFIED,
    /// <summary>
    /// Python >= 3.10, with numpy and simpy available
    /// </summary>
    PYTHON
  );

  /// <summary>
  /// Helper record for the <c>TLangueType</c> enumeration, providing utility methods for conversion between string representations and <c>TLangueType</c> values.
  /// </summary>
  TLangueTypeHelper = record helper for TLangueType
    /// <summary>
    /// Converts the current <c>TLangueType</c> value to its string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>TLangueType</c> value.
    /// </returns>
    function ToString: string;
    /// <summary>
    /// Creates a <c>TLangueType</c> value from its corresponding string representation.
    /// </summary>
    /// <param name="Value">
    /// The string value representing a <c>TLangueType</c>.
    /// </param>
    /// <returns>
    /// The corresponding <c>TLangueType</c> enumeration value for the provided string.
    /// </returns>
    /// <remarks>
    /// This method throws an exception if the input string does not match any valid <c>TLangueType</c> values.
    /// </remarks>
    class function Create(const Value: string): TLangueType; static;
  end;

  /// <summary>
  /// Interceptor class for converting <c>TLangueType</c> values to and from their string representations in JSON serialization and deserialization.
  /// </summary>
  /// <remarks>
  /// This class is used to facilitate the conversion between the <c>TLangueType</c> enum and its string equivalents during JSON processing.
  /// It extends the <c>TJSONInterceptorStringToString</c> class to override the necessary methods for custom conversion logic.
  /// </remarks>
  TLangueTypeInterceptor = class(TJSONInterceptorStringToString)
    /// <summary>
    /// Converts the <c>TLangueType</c> value of the specified field to a string during JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be converted.
    /// </param>
    /// <param name="Field">
    /// The field name representing the <c>TLangueType</c> value.
    /// </param>
    /// <returns>
    /// The string representation of the <c>TLangueType</c> value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string back to a <c>TLangueType</c> value for the specified field during JSON deserialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be set.
    /// </param>
    /// <param name="Field">
    /// The field name where the <c>TLangueType</c> value will be set.
    /// </param>
    /// <param name="Arg">
    /// The string representation of the <c>TLangueType</c> to be converted back.
    /// </param>
    /// <remarks>
    /// This method converts the string argument back to the corresponding <c>TLangueType</c> value and assigns it to the specified field in the object.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Enumeration of possible outcomes of the code execution.
  /// </summary>
  TOutcomeType = (
    /// <summary>
    /// State not specified. This value should not be used.
    /// </summary>
    OUTCOME_UNSPECIFIED,
    /// <summary>
    /// The code execution was successful.
    /// </summary>
    OUTCOME_OK,
    /// <summary>
    /// Code execution completed, but with failure. stderr should contain the reason.
    /// </summary>
    OUTCOME_FAILED,
    /// <summary>
    /// Code execution took too long and was canceled. Partial output may or may not be present.
    /// </summary>
    OUTCOME_DEADLINE_EXCEEDED
  );

  /// <summary>
  /// Helper record for the <c>TOutcomeType</c> enumeration, providing utility methods for conversion between string representations and <c>TOutcomeType</c> values.
  /// </summary>
  TOutcomeTypeHelper = record helper for TOutcomeType
    /// <summary>
    /// Converts the current <c>TOutcomeType</c> value to its string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>TOutcomeType</c> value.
    /// </returns>
    function ToString: string;
    /// <summary>
    /// Creates a <c>TOutcomeType</c> value from its corresponding string representation.
    /// </summary>
    /// <param name="Value">
    /// The string value representing a <c>TOutcomeType</c>.
    /// </param>
    /// <returns>
    /// The corresponding <c>TOutcomeType</c> enumeration value for the provided string.
    /// </returns>
    /// <remarks>
    /// This method throws an exception if the input string does not match any valid <c>TOutcomeType</c> values.
    /// </remarks>
    class function Create(const Value: string): TOutcomeType; static;
  end;

  /// <summary>
  /// Interceptor class for converting <c>TOutcomeType</c> values to and from their string representations in JSON serialization and deserialization.
  /// </summary>
  /// <remarks>
  /// This class is used to facilitate the conversion between the <c>TOutcomeType</c> enum and its string equivalents during JSON processing.
  /// It extends the <c>TJSONInterceptorStringToString</c> class to override the necessary methods for custom conversion logic.
  /// </remarks>
  TOutcomeTypeInterceptor = class(TJSONInterceptorStringToString)
    /// <summary>
    /// Converts the <c>TOutcomeType</c> value of the specified field to a string during JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be converted.
    /// </param>
    /// <param name="Field">
    /// The field name representing the <c>TOutcomeType</c> value.
    /// </param>
    /// <returns>
    /// The string representation of the <c>TOutcomeType</c> value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string back to a <c>TOutcomeType</c> value for the specified field during JSON deserialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be set.
    /// </param>
    /// <param name="Field">
    /// The field name where the <c>TOutcomeType</c> value will be set.
    /// </param>
    /// <param name="Arg">
    /// The string representation of the <c>TOutcomeType</c> to be converted back.
    /// </param>
    /// <remarks>
    /// This method converts the string argument back to the corresponding <c>TOutcomeType</c> value and assigns it to the specified field in the object.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Raw media bytes.
  /// </summary>
  /// <remarks>
  /// Text should not be sent as raw bytes, use the 'text' field.
  /// </remarks>
  TInlineData = class(TJSONParam)
    /// <summary>
    /// The IANA standard MIME type of the source data.
    /// </summary>
    /// <remarks>
    /// Examples: - image/png - image/jpeg If an unsupported MIME type is provided, an error will be returned.
    /// </remarks>
    function MimeType(const Value: string): TInlineData;
    /// <summary>
    /// Raw bytes for media formats.
    /// </summary>
    /// <remarks>
    /// A base64-encoded string.
    /// </remarks>
    function Data(const Value: string): TInlineData;
  end;

  /// <summary>
  /// URI based data.
  /// </summary>
  TFileData = class(TJSONParam)
    /// <summary>
    /// The IANA standard MIME type of the source data.
    /// </summary>
    function MimeType(const Value: string): TFileData;
    /// <summary>
    /// Uri of thsdata
    /// </summary>
    function FileUri(const Value: string): TFileData;
  end;

  /// <summary>
  /// Inline text setter class.
  /// </summary>
  TTextData = class(TJSONParam)
    /// <summary>
    /// Inline text.
    /// </summary>
    function Text(const Value: string): TTextData;
  end;

  /// <summary>
  /// Represents the content payload of a chat message, including the message sender's role and its content parts.
  /// </summary>
  /// <remarks>
  /// The <c>TContentPayload</c> class allows you to construct messages with various content parts, specify the role of the message sender (user or assistant), and attach any additional data such as files or media.
  /// This class is essential for building messages in a chat application, particularly when interacting with AI models that require structured message input.
  /// </remarks>
  TContentPayload = class(TJSONParam)
  public
    /// <summary>
    /// Sets the role of the message sender.
    /// </summary>
    /// <param name="Value">
    /// The role of the message sender, specified as a <c>TMessageRole</c> enumeration value (either <c>user</c> or <c>model</c>).
    /// </param>
    /// <returns>
    /// Returns the updated <c>TContentPayload</c> instance, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// Setting the role is useful for multi-turn conversations to distinguish between messages from the user and responses from the model.
    /// If not set, the role can be left blank or unset for single-turn conversations.
    /// </remarks>
    function Role(const Value: TMessageRole): TContentPayload;
    /// <summary>
    /// Adds content parts to the message with specified text and attachments.
    /// </summary>
    /// <param name="Value">
    /// The text content of the message to be included as a part.
    /// </param>
    /// <param name="Attached">
    /// An array of strings representing attached data or file URIs to be included as parts.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TContentPayload</c> instance, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// Each part of the message may have different MIME types.
    /// This method allows combining text and attachments into a single message payload.
    /// </remarks>
    function Parts(const Value: string; const Attached: TArray<string>): TContentPayload; overload;
    /// <summary>
    /// Adds content parts to the message with specified attachments.
    /// </summary>
    /// <param name="Attached">
    /// An array of strings representing attached data or file URIs to be included as parts.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TContentPayload</c> instance, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// Each part of the message may have different MIME types.
    /// This method is useful when the message consists only of attachments without any text content.
    /// </remarks>
    function Parts(const Attached: TArray<string>): TContentPayload; overload;
    /// <summary>
    /// Creates a new <c>TContentPayload</c> instance with specified text content and optional attachments.
    /// </summary>
    /// <param name="Text">
    /// The text content of the message.
    /// </param>
    /// <param name="Attached">
    /// Optional. An array of strings representing attached data or file URIs to be included as parts.
    /// </param>
    /// <returns>
    /// Returns a new <c>TContentPayload</c> instance containing the specified text and attachments.
    /// </returns>
    class function Add(const Text: string; const Attached: TArray<string> = []): TContentPayload; reintroduce; overload;
    /// <summary>
    /// Creates a new <c>TContentPayload</c> instance with a specified role and optional attachments.
    /// </summary>
    /// <param name="Role">
    /// The role of the message sender, specified as a <c>TMessageRole</c> enumeration value (either <c>user</c> or <c>model</c>).
    /// </param>
    /// <param name="Attached">
    /// Optional. An array of strings representing attached data or file URIs to be included as parts.
    /// </param>
    /// <returns>
    /// Returns a new <c>TContentPayload</c> instance with the specified role and attachments.
    /// </returns>
    class function Add(const Role: TMessageRole;
      const Attached: TArray<string> = []): TContentPayload; reintroduce; overload;
    /// <summary>
    /// Creates a new <c>TContentPayload</c> instance with specified role, text content, and optional attachments.
    /// </summary>
    /// <param name="Role">
    /// The role of the message sender, specified as a <c>TMessageRole</c> enumeration value (either <c>user</c> or <c>model</c>).
    /// </param>
    /// <param name="Text">
    /// The text content of the message.
    /// </param>
    /// <param name="Attached">
    /// Optional. An array of strings representing attached data or file URIs to be included as parts.
    /// </param>
    /// <returns>
    /// Returns a new <c>TContentPayload</c> instance containing the specified role, text, and attachments.
    /// </returns>
    class function Add(const Role: TMessageRole; const Text: string;
      const Attached: TArray<string> = []): TContentPayload; reintroduce; overload;
    /// <summary>
    /// Creates a new <c>TContentPayload</c> instance representing the assistant's message with specified text content and optional attachments.
    /// </summary>
    /// <param name="Value">
    /// The text content of the assistant's message.
    /// </param>
    /// <param name="Attached">
    /// Optional. An array of strings representing attached data or file URIs to be included as parts.
    /// </param>
    /// <returns>
    /// Returns a new <c>TContentPayload</c> instance representing the assistant's message.
    /// </returns>
    class function Assistant(const Value: string; const Attached: TArray<string> = []): TContentPayload; overload;
    /// <summary>
    /// Creates a new <c>TContentPayload</c> instance representing the assistant's message with specified attachments.
    /// </summary>
    /// <param name="Attached">
    /// An array of strings representing attached data or file URIs to be included as parts.
    /// </param>
    /// <returns>
    /// Returns a new <c>TContentPayload</c> instance representing the assistant's message with attachments.
    /// </returns>
    class function Assistant(const Attached: TArray<string>): TContentPayload; overload;
    /// <summary>
    /// Creates a new <c>TContentPayload</c> instance representing the user's message with specified text content and optional attachments.
    /// </summary>
    /// <param name="Value">
    /// The text content of the user's message.
    /// </param>
    /// <param name="Attached">
    /// Optional. An array of strings representing attached data or file URIs to be included as parts.
    /// </param>
    /// <returns>
    /// Returns a new <c>TContentPayload</c> instance representing the user's message.
    /// </returns>
    class function User(const Value: string; const Attached: TArray<string> = []): TContentPayload; overload;
    /// <summary>
    /// Creates a new <c>TContentPayload</c> instance representing the user's message with specified attachments.
    /// </summary>
    /// <param name="Attached">
    /// An array of strings representing attached data or file URIs to be included as parts.
    /// </param>
    /// <returns>
    /// Returns a new <c>TContentPayload</c> instance representing the user's message with attachments.
    /// </returns>
    class function User(const Attached: TArray<string>): TContentPayload; overload;
    /// <summary>
    /// Creates a new <c>TContentPayload</c> instance and allows configuration through a procedure reference.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure reference that receives a <c>TContentPayload</c> instance to configure its properties.
    /// </param>
    /// <returns>
    /// Returns a new configured <c>TContentPayload</c> instance.
    /// </returns>
    class function New(const ParamProc: TProcRef<TContentPayload>): TContentPayload; static;
  end;

  /// <summary>
  /// Represents the content payload of a chat message, including the message sender's role and its content parts.
  /// </summary>
  /// <remarks>
  /// The <c>TPayLoad</c> class allows you to construct messages with various content parts, specify the role of the message sender (user or assistant), and attach any additional data such as files or media.
  /// This class is essential for building messages in a chat application, particularly when interacting with AI models that require structured message input.
  /// </remarks>
  TPayLoad = TContentPayload;

  /// <summary>
  /// Represents the configuration options for generating model outputs in a chat or completion request.
  /// </summary>
  /// <remarks>
  /// The <c>TGenerationConfig</c> class allows you to specify various parameters that control the behavior of the AI model during text generation.
  /// These settings can influence the randomness, length, and format of the generated responses.
  /// Not all parameters are configurable for every model; some models may ignore certain settings.
  /// </remarks>
  TGenerationConfig = class(TJSONParam)
  public
    /// <summary>
    /// Specifies a set of character sequences that will stop the output generation.
    /// </summary>
    /// <param name="Value">
    /// An array of strings representing the stop sequences. The API will stop generating further tokens when any of these sequences are encountered.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TGenerationConfig</c> instance, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// You can specify up to 5 stop sequences. If a stop sequence is encountered, it will not be included in the response.
    /// </remarks>
    function StopSequences(const Value: TArray<string>): TGenerationConfig;
    /// <summary>
    /// Sets the MIME type of the generated candidate text.
    /// </summary>
    /// <param name="Value">
    /// A string representing the MIME type of the response content. Supported MIME types include:
    /// <para>
    /// - <c>text/plain</c> (default): Text output.
    /// </para>
    /// <para>
    /// - <c>application/json</c>: JSON response in the response candidates.
    /// </para>
    /// <para>
    /// - <c>text/x.enum</c>: ENUM as a string response in the response candidates.
    /// </para>
    /// Refer to the documentation for a complete list of supported MIME types.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TGenerationConfig</c> instance, allowing for method chaining.
    /// </returns>
    function ResponseMimeType(const Value: string): TGenerationConfig;
    /// <summary>
    /// Specifies the output schema of the generated candidate text using a <c>TSchemaParams</c> instance.
    /// </summary>
    /// <param name="Value">
    /// A <c>TSchemaParams</c> instance representing the desired output schema for the response.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TGenerationConfig</c> instance, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// Schemas must be a subset of the OpenAPI schema and can be objects, primitives, or arrays.
    /// If set, a compatible <c>ResponseMimeType</c> must also be specified. Compatible MIME types include <c>application/json</c>.
    /// Refer to the JSON text generation guide for more details.
    /// </remarks>
    function ResponseSchema(const Value: TSchemaParams): TGenerationConfig; overload;
    /// <summary>
    /// Specifies the output schema of the generated candidate text using a JSON object.
    /// </summary>
    /// <param name="Value">
    /// A <c>TJSONObject</c> instance representing the desired output schema for the response.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TGenerationConfig</c> instance, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// Schemas must be a subset of the OpenAPI schema and can be objects, primitives, or arrays.
    /// If set, a compatible <c>ResponseMimeType</c> must also be specified. Compatible MIME types include <c>application/json</c>.
    /// Refer to the JSON text generation guide for more details.
    /// </remarks>
    function ResponseSchema(const Value: TJSONObject): TGenerationConfig; overload;
    /// <summary>
    /// Specifies the output schema of the generated candidate text using a procedure to configure <c>TSchemaParams</c>.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure reference that receives a <c>TSchemaParams</c> instance to configure the desired output schema.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TGenerationConfig</c> instance, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// Schemas must be a subset of the OpenAPI schema and can be objects, primitives, or arrays.
    /// If set, a compatible <c>ResponseMimeType</c> must also be specified. Compatible MIME types include <c>application/json</c>.
    /// Refer to the JSON text generation guide for more details.
    /// </remarks>
    function ResponseSchema(const ParamProc: TProcRef<TSchemaParams>): TGenerationConfig; overload;
    /// <summary>
    /// Sets the number of generated response candidates to return.
    /// </summary>
    /// <param name="Value">
    /// An integer specifying the number of response candidates. Currently, this value can only be set to 1.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TGenerationConfig</c> instance, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// If not set, this defaults to 1.
    /// </remarks>
    function CandidateCount(const Value: Integer): TGenerationConfig;
    /// <summary>
    /// Specifies the maximum number of tokens to include in a response candidate.
    /// </summary>
    /// <param name="Value">
    /// An integer representing the maximum number of tokens for the response.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TGenerationConfig</c> instance, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// The default value varies by model. Refer to the model's <c>output_token_limit</c> attribute returned from the <c>getModel</c> function.
    /// </remarks>
    function MaxOutputTokens(const Value: Integer): TGenerationConfig;
    /// <summary>
    /// Controls the randomness of the output by setting the temperature parameter.
    /// </summary>
    /// <param name="Value">
    /// A double value ranging from 0.0 to 2.0, where higher values produce more random outputs, and lower values make the output more deterministic.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TGenerationConfig</c> instance, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// The default value varies by model. Refer to the model's <c>temperature</c> attribute returned from the <c>getModel</c> function.
    /// </remarks>
    function Temperature(const Value: Double): TGenerationConfig;
    /// <summary>
    /// Sets the maximum cumulative probability of tokens to consider when sampling, known as nucleus sampling (Top-p).
    /// </summary>
    /// <param name="Value">
    /// A double value between 0.0 and 1.0 representing the cumulative probability threshold.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TGenerationConfig</c> instance, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// The model uses a combination of Top-k and Top-p sampling. Tokens are considered based on their cumulative probability until the threshold is reached.
    /// The default value varies by model and is specified by the model's <c>top_p</c> attribute returned from the <c>getModel</c> function.
    /// </remarks>
    function TopP(const Value: Double): TGenerationConfig;
    /// <summary>
    /// Sets the maximum number of tokens to consider when sampling, known as Top-k sampling.
    /// </summary>
    /// <param name="Value">
    /// An integer specifying the number of top tokens to consider during sampling.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TGenerationConfig</c> instance, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// Some models may not support Top-k sampling. The default value varies by model and is specified by the model's <c>top_k</c> attribute returned from the <c>getModel</c> function.
    /// </remarks>
    function TopK(const Value: Integer): TGenerationConfig;
    /// <summary>
    /// Applies a presence penalty to the next token's log probabilities if the token has already appeared in the response.
    /// </summary>
    /// <param name="Value">
    /// A double value representing the penalty. Positive values discourage repetition, while negative values encourage it.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TGenerationConfig</c> instance, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// This penalty is binary (on/off) and does not depend on the number of times the token has been used after the first occurrence.
    /// Use <c>FrequencyPenalty</c> for a penalty that increases with each use.
    /// </remarks>
    function PresencePenalty(const Value: Double): TGenerationConfig;
    /// <summary>
    /// Applies a frequency penalty to the next token's log probabilities, proportional to the number of times each token has been used in the response so far.
    /// </summary>
    /// <param name="Value">
    /// A double value representing the penalty. Positive values discourage repetition proportionally to frequency; negative values encourage repetition.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TGenerationConfig</c> instance, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// Caution: Negative values can cause the model to start repeating tokens excessively, potentially leading to outputs like "the the the...".
    /// </remarks>
    function FrequencyPenalty(const Value: Double): TGenerationConfig;
    /// <summary>
    /// Specifies whether to include log probabilities of tokens in the response.
    /// </summary>
    /// <param name="Value">
    /// A boolean value where <c>True</c> indicates that log probabilities should be included in the response.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TGenerationConfig</c> instance, allowing for method chaining.
    /// </returns>
    function ResponseLogprobs(const Value: Boolean): TGenerationConfig;
    /// <summary>
    /// Sets the number of top log probabilities to return at each decoding step.
    /// </summary>
    /// <param name="Value">
    /// An integer specifying the number of top tokens to include in the log probabilities.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TGenerationConfig</c> instance, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// Only valid if <c>ResponseLogprobs</c> is set to <c>True</c>. This parameter determines the number of top tokens for which log probabilities are returned in each decoding step.
    /// </remarks>
    function Logprobs(const Value: Integer): TGenerationConfig;
    /// <summary>
    /// Creates a new <c>TGenerationConfig</c> instance and allows configuration through a procedure reference.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure reference that receives a <c>TGenerationConfig</c> instance to configure its properties.
    /// </param>
    /// <returns>
    /// Returns a new configured <c>TGenerationConfig</c> instance.
    /// </returns>
    class function New(const ParamProc: TProcRef<TGenerationConfig>): TGenerationConfig; overload;
  end;

  /// <summary>
  /// Represents the set of parameters used to configure a chat interaction with an AI model.
  /// </summary>
  /// <remarks>
  /// The <c>TChatParams</c> class allows you to define various settings that control how the AI model behaves during a chat session.
  /// You can specify the messages to send, tools the model can use, safety settings, system instructions, and generation configurations.
  /// By customizing these parameters, you can fine-tune the AI's responses to better suit your application's needs.
  /// </remarks>
  TChatParams = class(TJSONParam)
    /// <summary>
    /// Sets the content of the current conversation with the model.
    /// </summary>
    /// <param name="Value">
    /// An array of <c>TContentPayload</c> instances representing the messages exchanged in the conversation, including both user and assistant messages.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TChatParams</c> instance, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// For single-turn queries, this array contains a single message. For multi-turn conversations, include the entire conversation history and the latest message.
    /// </remarks>
    function Contents(const Value: TArray<TContentPayload>): TChatParams;
    /// <summary>
    /// Specifies a list of tools that the model may use to generate the next response.
    /// </summary>
    /// <param name="Value">
    /// An array of <c>IFunctionCore</c> instances representing the tools available to the model.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TChatParams</c> instance, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// A tool is a piece of code that allows the model to interact with external systems or perform actions outside its knowledge base.
    /// Supported tools include functions and code execution capabilities. Refer to the Function Calling and Code Execution guides for more information.
    /// </remarks>
    function Tools(const Value: TArray<IFunctionCore>): TChatParams; overload;
    /// <summary>
    /// Enables a specific tool for the chat interaction based on the provided tool kind and threshold.
    /// </summary>
    /// <param name="Value">
    /// Specifies the type of tool to enable. This can be either <c>TToolKind.CodeExecution</c> to allow code execution capabilities or <c>TToolKind.GoogleSearch</c> to enable Google search functionality.
    /// </param>
    /// <param name="Threshold">
    /// An optional parameter that sets the activation threshold for the specified tool. The default value is <c>0.7</c>.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TChatParams</c> instance, facilitating method chaining for configuring multiple parameters.
    /// </returns>
    /// <remarks>
    /// This method allows you to specify additional functionalities that the AI model can utilize during the chat session.
    /// <para>
    /// - <c>TToolKind.CodeExecution</c>: Enables the model to generate and execute code snippets, which can be useful for tasks requiring computational operations or automation.
    /// </para>
    /// <para>
    /// - <c>TToolKind.GoogleSearch</c>: Allows the model to perform Google searches to fetch real-time information, enhancing its ability to provide up-to-date responses.
    /// </para>
    /// The <c>Threshold</c> parameter determines the sensitivity or confidence level required for the tool to be activated. Adjusting this value can help control how often the tool is utilized based on the context of the conversation.
    /// </remarks>
    function Tools(const Value: TToolKind; const Threshold: Double = 0.7): TChatParams; overload;
    /// <summary>
    /// Configures the tool settings for any tools specified in the request.
    /// </summary>
    /// <param name="Value">
    /// A <c>TToolMode</c> value specifying the mode in which tools are used by the model.
    /// </param>
    /// <param name="AllowedFunctionNames">
    /// Optional. An array of strings representing the names of functions that the model is allowed to use.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TChatParams</c> instance, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// Use this method to specify how the model should use the available tools, including restricting which functions can be called.
    /// Refer to the Function Calling guide for usage examples.
    /// </remarks>
    function ToolConfig(const Value: TToolMode; AllowedFunctionNames: TArray<string> = []): TChatParams;
    /// <summary>
    /// Specifies safety settings to block unsafe content.
    /// </summary>
    /// <param name="Value">
    /// An array of <c>TSafety</c> instances representing safety settings for different harm categories.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TChatParams</c> instance, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// These settings are enforced on both the request and the response.
    /// There should not be more than one setting for each safety category.
    /// The API will block any content that fails to meet the thresholds set by these settings.
    /// This list overrides the default settings for each specified category.
    /// If a category is not specified, the API uses the default safety setting for that category.
    /// Supported harm categories include <c>HARM_CATEGORY_HATE_SPEECH</c>, <c>HARM_CATEGORY_SEXUALLY_EXPLICIT</c>, <c>HARM_CATEGORY_DANGEROUS_CONTENT</c>, and <c>HARM_CATEGORY_HARASSMENT</c>.
    /// Refer to the documentation for detailed information on available safety settings and how to incorporate safety considerations into your application.
    /// </remarks>
    function SafetySettings(const Value: TArray<TSafety>): TChatParams;
    /// <summary>
    /// Sets developer-defined system instructions for the model.
    /// </summary>
    /// <param name="Value">
    /// A string containing the system instruction text.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TChatParams</c> instance, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// Use this to provide guidelines or constraints for the model's behavior during the chat session.
    /// </remarks>
    function SystemInstruction(const Value: string): TChatParams;
    /// <summary>
    /// Configures generation options for the model's outputs.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure reference that receives a <c>TGenerationConfig</c> instance to configure various generation settings.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TChatParams</c> instance, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// Use this method to specify parameters such as temperature, maximum tokens, response format, and other generation options.
    /// Not all parameters are configurable for every model.
    /// </remarks>
    function GenerationConfig(const ParamProc: TProcRef<TGenerationConfig>): TChatParams;
    /// <summary>
    /// Specifies the name of the cached content to use as context for the prediction.
    /// </summary>
    /// <param name="Value">
    /// A string representing the name of the cached content in the format <c>"cachedContents/{cachedContent}"</c>.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TChatParams</c> instance, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// Use this to provide additional context to the model by referencing pre-cached content.
    /// </remarks>
    function CachedContent(const Value: string): TChatParams;
    /// <summary>
    /// Creates a new <c>TChatParams</c> instance and allows configuration through a procedure reference.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure reference that receives a <c>TChatParams</c> instance to configure its properties.
    /// </param>
    /// <returns>
    /// Returns a new configured <c>TChatParams</c> instance.
    /// </returns>
    class function New(const ParamProc: TProcRef<TChatParams>): TChatParams; overload;
  end;

  /// <summary>
  /// Interceptor class for converting <c>args</c> and <c>response</c> values into JSON string format in JSON deserialization.
  /// </summary>
  /// <remarks>
  /// This class is used to facilitate the conversion between the <c>args</c>, <c>response</c> and theirs string equivalent during JSON processing.
  /// It extends the <c>TJSONInterceptorStringToString</c> class to override the necessary methods for custom conversion logic.
  /// </remarks>
  TArgsFixInterceptor = class(TJSONInterceptorStringToString)
  public
    /// <summary>
    /// When JSON deserialization, converts <c>args</c>, <c>response<c/> values into JSON string to retrieve arguments made by the tool.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be set.
    /// </param>
    /// <param name="Field">
    /// The field name where the <c>input</c> value will be set.
    /// </param>
    /// <param name="Arg">
    /// The string representation of the <c>args</c> or <c>response</c> to be converted back.
    /// </param>
    /// <remarks>
    /// This method converts the string argument back to the corresponding <c>args</c> or <c>response</c> value and assigns it to the specified field in the object.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// A predicted FunctionCall returned from the model that contains a string representing the FunctionDeclaration.name with the arguments and their values.
  /// </summary>
  TFunctionCall = class
  private
    FName: string;
    [JsonReflectAttribute(ctString, rtString, TArgsFixInterceptor)]
    FArgs: string;
  public
    /// <summary>
    /// Required. The name of the function to call. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 63.
    /// </summary>
    property Name: string read FName write FName;
    /// <summary>
    /// Optional. The function parameters and values in JSON object format.
    /// </summary>
    property Args: string read FArgs write FArgs;
  end;

  /// <summary>
  /// Raw media bytes.
  /// </summary>
  /// <remarks>
  /// Text should not be sent as raw bytes, use the 'text' field.
  /// </remarks>
  TInlineDataPart = class
  private
    FMimeType: string;
    FData: string;
  public
    /// <summary>
    /// The IANA standard MIME type of the source data.
    /// </summary>
    property MimeType: string read FMimeType write FMimeType;
    /// <summary>
    /// Raw bytes for media formats.
    /// </summary>
    property Data: string read FData write FData;
  end;

  /// <summary>
  /// URI based data.
  /// </summary>
  TFileDataPart = class
  private
    FMimeType: string;
    FFileUri: string;
  public
    /// <summary>
    /// The IANA standard MIME type of the source data.
    /// </summary>
    property MimeType: string read FMimeType write FMimeType;
    /// <summary>
    /// Uri of the data
    /// </summary>
    property FileUri: string read FFileUri write FFileUri;
  end;

  /// <summary>
  /// The result output from a FunctionCall that contains a string representing the FunctionDeclaration.name and a structured JSON object containing any output from the function is used as context to the model.
  /// </summary>
  /// <remarks>
  /// This should contain the result of aFunctionCall made based on model prediction.
  /// </remarks>
  TFunctionResponsePart = class
  private
    FName: string;
    [JsonReflectAttribute(ctString, rtString, TArgsFixInterceptor)]
    FResponse: string;
  public
    /// <summary>
    /// Required. The name of the function to call.
    /// </summary>
    /// <remarks>
    /// Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 63.
    /// </remarks>
    property Name: string read FName write FName;
    /// <summary>
    /// Required. The function response in JSON object format.
    /// </summary>
    property Response: string read FResponse write FResponse;
  end;

  /// <summary>
  /// Code generated by the model that is meant to be executed, and the result returned to the model.
  /// </summary>
  /// <remarks>
  /// Only generated when using the CodeExecution tool, in which the code will be automatically executed, and a corresponding CodeExecutionResult will also be generated.
  /// </remarks>
  TExecutableCodePart = class
  private
    [JsonReflectAttribute(ctString, rtString, TLangueTypeInterceptor)]
    FLanguage: TLangueType;
    FCode: string;
  public
    /// <summary>
    /// Required. Programming language of the code.
    /// </summary>
    property Language: TLangueType read FLanguage write FLanguage;
    /// <summary>
    /// Required. The code to be executed.
    /// </summary>
    property Code: string read FCode write FCode;
  end;

  /// <summary>
  /// Result of executing the ExecutableCode.
  /// </summary>
  /// <remarks>
  /// Only generated when using the CodeExecution, and always follows a part containing the ExecutableCode.
  /// </remarks>
  TCodeExecutionResult = class
  private
    [JsonReflectAttribute(ctString, rtString, TOutcomeTypeInterceptor)]
    FOutcome: TOutcomeType;
    FOutput: string;
  public
    /// <summary>
    /// Required. Outcome of the code execution.
    /// </summary>
    property Outcome: TOutcomeType read FOutcome write FOutcome;
    /// <summary>
    /// Optional. Contains stdout when code execution is successful, stderr or other description otherwise.
    /// </summary>
    property Output: string read FOutput write FOutput;
  end;

  /// <summary>
  /// A datatype containing media that is part of a multi-part Content message.
  /// </summary>
  /// <remarks>
  /// <para>
  /// - A Part consists of data which has an associated datatype. A Part can only contain one of the accepted types in Part.data.
  /// </para>
  /// <para>
  /// - A Part must have a fixed IANA MIME type identifying the type and subtype of the media if the inlineData field is filled with raw bytes.
  /// </para>
  /// <para>
  /// Data can be only one of the following field of the class
  /// </para>
  /// </remarks>
  TChatPart = class
  private
    FText: string;
    FFunctionCall: TFunctionCall;
    FFunctionResponse: TFunctionResponsePart;
    FInlineData: TInlineDataPart;
    FFileData: TFileDataPart;
    FExecutableCode: TExecutableCodePart;
    FCodeExecutionResult: TCodeExecutionResult;
  public
    /// <summary>
    /// Inline text.
    /// </summary>
    property Text: string read FText write FText;
    /// <summary>
    /// A predicted FunctionCall returned from the model that contains a string representing the FunctionDeclaration.name with the arguments and their values.
    /// </summary>
    property FunctionCall: TFunctionCall read FFunctionCall write FFunctionCall;
    /// <summary>
    /// The result output of a FunctionCall that contains a string representing the FunctionDeclaration.name and a structured JSON object containing any output from the function is used as context to the model.
    /// </summary>
    property FunctionResponse: TFunctionResponsePart read FFunctionResponse write FFunctionResponse;
    /// <summary>
    /// Inline media bytes.
    /// </summary>
    property InlineData: TInlineDataPart read FInlineData write FInlineData;
    /// <summary>
    /// URI based data.
    /// </summary>
    property FileData: TFileDataPart read FFileData write FFileData;
    /// <summary>
    /// Code generated by the model that is meant to be executed.
    /// </summary>
    property ExecutableCode: TExecutableCodePart read FExecutableCode write FExecutableCode;
    /// <summary>
    /// Result of executing the ExecutableCode.
    /// </summary>
    property CodeExecutionResult: TCodeExecutionResult read FCodeExecutionResult write FCodeExecutionResult;
    destructor Destroy; override;
  end;

  /// <summary>
  /// The base structured datatype containing multi-part content of a message.
  /// </summary>
  /// <remarks>
  /// A Content includes a role field designating the producer of the Content and a parts field containing multi-part data that contains the content of the message turn.
  /// </remarks>
  TChatContent = class
  private
    FParts: TArray<TChatPart>;
    [JsonReflectAttribute(ctString, rtString, TMessageRoleInterceptor)]
    FRole: TMessageRole;
  public
    /// <summary>
    /// Ordered Parts that constitute a single message. Parts may have different MIME types.
    /// </summary>
    property Parts: TArray<TChatPart> read FParts write FParts;
    /// <summary>
    /// Optional. The producer of the content. Must be either 'user' or 'model'.
    /// </summary>
    /// <remarks>
    /// Useful to set for multi-turn conversations, otherwise can be left blank or unset.
    /// </remarks>
    property Role: TMessageRole read FRole write FRole;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Safety rating for a piece of content.
  /// </summary>
  /// <remarks>
  /// The safety rating contains the category of harm and the harm probability level in that category for a piece of content. Content is classified for safety across a number of harm categories and the probability of the harm classification is included here.
  /// </remarks>
  TSafetyRatings = class
  private
    [JsonReflectAttribute(ctString, rtString, THarmCategoryInterceptor)]
    FCategory: THarmCategory;
    [JsonReflectAttribute(ctString, rtString, THarmProbabilityInterceptor)]
    FProbability: THarmProbability;
    FBlocked: Boolean;
  public
    /// <summary>
    /// Required. The category for this rating.
    /// </summary>
    property Category: THarmCategory read FCategory write FCategory;
    /// <summary>
    /// Required. The probability of harm for this content.
    /// </summary>
    property Probability: THarmProbability read FProbability write FProbability;
    /// <summary>
    /// Was this content blocked because of this rating?
    /// </summary>
    property Blocked: Boolean read FBlocked write FBlocked;
  end;

  /// <summary>
  /// A citation to a source for a portion of a specific response.
  /// </summary>
  TCitationSource = class
  private
    FStartIndex: Int64;
    FEndIndex: Int64;
    FUri: string;
    FLicense: string;
  public
    /// <summary>
    /// Optional. Start of segment of the response that is attributed to this source.
    /// </summary>
    /// <remarks>
    /// Index indicates the start of the segment, measured in bytes
    /// </remarks>
    property StartIndex: Int64 read FStartIndex write FStartIndex;
    /// <summary>
    /// Optional. End of the attributed segment, exclusive.
    /// </summary>
    property EndIndex: Int64 read FEndIndex write FEndIndex;
    /// <summary>
    /// Optional. URI that is attributed as a source for a portion of the text.
    /// </summary>
    property Uri: string read FUri write FUri;
    /// <summary>
    /// Optional. License for the GitHub project that is attributed as a source for segment.
    /// </summary>
    /// <remarks>
    /// License info is required for code citations.
    /// </remarks>
    property License: string read FLicense write FLicense;
  end;

  /// <summary>
  /// A collection of source attributions for a piece of content.
  /// </summary>
  TCitationMetadata = class
  private
    FCitationSources: TArray<TCitationSource>;
  public
    /// <summary>
    /// Citations to sources for a specific response.
    /// </summary>
    property CitationSources: TArray<TCitationSource> read FCitationSources write FCitationSources;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Candidate for the logprobs token and score.
  /// </summary>
  TCandidate = class
  private
    FToken: string;
    FTokenId: Int64;
    FLogProbability: Double;
  public
    /// <summary>
    /// The candidate’s token string value.
    /// </summary>
    property Token: string read FToken write FToken;
    /// <summary>
    /// The candidate’s token id value.
    /// </summary>
    property TokenId: Int64 read FTokenId write FTokenId;
    /// <summary>
    /// The candidate's log probability.
    /// </summary>
    property LogProbability: Double read FLogProbability write FLogProbability;
  end;

  /// <summary>
  /// Candidates with top log probabilities at each decoding step.
  /// </summary>
  TTopCandidates = class
  private
    FCandidates: TArray<TCandidate>;
  public
    /// <summary>
    /// Sorted by log probability in descending order.
    /// </summary>
    property Candidates: TArray<TCandidate> read Fcandidates write Fcandidates;
  end;

  /// <summary>
  /// Logprobs Result
  /// </summary>
  TLogprobsResult = class
  private
    FTopCandidates: TArray<TTopCandidates>;
    FChosenCandidates: TArray<TCandidate>;
  public
    /// <summary>
    /// Length = total number of decoding steps.
    /// </summary>
    property TopCandidates: TArray<TTopCandidates> read FTopCandidates write FTopCandidates;
    /// <summary>
    /// Length = total number of decoding steps. The chosen candidates may or may not be in topCandidates.
    /// </summary>
    property ChosenCandidates: TArray<TCandidate> read FChosenCandidates write FChosenCandidates;
    destructor Destroy; override;
  end;

  /// <summary>
  /// A response candidate generated from the model.
  /// </summary>
  TChatCandidate = class
  private
    FContent: TChatContent;
    [JsonReflectAttribute(ctString, rtString, TFinishReasonInterceptor)]
    FFinishReason: TFinishReason;
    FSafetyRatings: TArray<TSafetyRatings>;
    FCitationMetadata: TCitationMetadata;
    FTokenCount: Int64;
    FAvgLogprobs: Double;
    FLogprobsResult: TLogprobsResult;
    FGroundingMetadata: TGroundingMetadata;
    FIndex: Int64;
  public
    /// <summary>
    /// Output only. Generated content returned from the model.
    /// </summary>
    property Content: TChatContent read FContent write FContent;
    /// <summary>
    /// Optional. Output only. The reason why the model stopped generating tokens.
    /// </summary>
    /// <remarks>
    /// If empty, the model has not stopped generating tokens.
    /// </remarks>
    property FinishReason: TFinishReason read FFinishReason write FFinishReason;
    /// <summary>
    /// List of ratings for the safety of a response candidate.
    /// </summary>
    /// <remarks>
    /// There is at most one rating per category.
    /// </remarks>
    property SafetyRatings: TArray<TSafetyRatings> read FSafetyRatings write FSafetyRatings;
    /// <summary>
    /// Output only. Citation information for model-generated candidate.
    /// </summary>
    /// <summary>
    /// This field may be populated with recitation information for any text included in the content. These are passages that are "recited" from copyrighted material in the foundational LLM's training data.
    /// </summary>
    property CitationMetadata: TCitationMetadata read FCitationMetadata write FCitationMetadata;
    /// <summary>
    /// Output only. Token count for this candidate.
    /// </summary>
    property TokenCount: Int64 read FTokenCount write FTokenCount;
    /// <summary>
    /// Output only.
    /// </summary>
    property AvgLogprobs: Double read FAvgLogprobs write FAvgLogprobs;
    /// <summary>
    /// Output only. Log-likelihood scores for the response tokens and top tokens
    /// </summary>
    property LogprobsResult: TLogprobsResult read FLogprobsResult write FLogprobsResult;
    /// <summary>
    /// Contains metadata related to the grounding of the chat candidate's content.
    /// </summary>
    /// <remarks>
    /// The <c>GroundingMetadata</c> property provides detailed information about the sources and contextual grounding of the generated content.
    /// <para><c>SearchEntryPoint</c>: The initial point or context from which the search was conducted.</para>
    /// <para><c>GroundingChunks</c>: A collection of web sources that support the generated content, each containing a URI and title.</para>
    /// <para><c>WebSearchQueries</c>: The specific search queries used to retrieve information relevant to the content.</para>
    /// This metadata enhances transparency by linking the generated responses to their original sources, facilitating verification and trust in the content provided by the model.
    /// </remarks>
    property GroundingMetadata: TGroundingMetadata read FGroundingMetadata write FGroundingMetadata;
    /// <summary>
    /// Output only. Index of the candidate in the list of response candidates.
    /// </summary>
    property Index: Int64 read FIndex write FIndex;
    destructor Destroy; override;
  end;

  /// <summary>
  /// A set of the feedback metadata the prompt specified in GenerateContentRequest.content.
  /// </summary>
  TPromptFeedback = class
  private
    [JsonReflectAttribute(ctString, rtString, TBlockReasonInterceptor)]
    FBlockReason: TBlockReason;
    FSafetyRatings: TArray<TsafetyRatings>;
  public
    /// <summary>
    /// Optional. If set, the prompt was blocked and no candidates are returned. Rephrase the prompt.
    /// </summary>
    property BlockReason: TBlockReason read FBlockReason write FBlockReason;
    /// <summary>
    /// Ratings for safety of the prompt. There is at most one rating per category.
    /// </summary>
    property SafetyRatings: TArray<TsafetyRatings> read FSafetyRatings write FSafetyRatings;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Contains metadata about the token usage in a generation request.
  /// </summary>
  /// <remarks>
  /// The <c>TUsageMetadata</c> class provides detailed information regarding the number of tokens used during a request to the AI model.
  /// This includes counts for the prompt, any cached content, the generated response candidates, and the total tokens used.
  /// This information is valuable for monitoring and optimizing token usage, which can impact both performance and cost.
  /// </remarks>
  TUsageMetadata = class
  private
    FPromptTokenCount: Int64;
    FCachedContentTokenCount: Int64;
    FCandidatesTokenCount: Int64;
    FTotalTokenCount: Int64;
  public
    /// <summary>
    /// Gets or sets the number of tokens used in the prompt.
    /// </summary>
    /// <remarks>
    /// When <c>CachedContent</c> is set, this value still represents the total effective prompt size, including the tokens in the cached content.
    /// </remarks>
    property PromptTokenCount: Int64 read FPromptTokenCount write FPromptTokenCount;
    /// <summary>
    /// Gets or sets the number of tokens in the cached part of the prompt (the cached content).
    /// </summary>
    property CachedContentTokenCount: Int64 read FCachedContentTokenCount write FCachedContentTokenCount;
    /// <summary>
    /// Gets or sets the total number of tokens across all the generated response candidates.
    /// </summary>
    property CandidatesTokenCount: Int64 read FCandidatesTokenCount write FCandidatesTokenCount;
    /// <summary>
    /// Gets or sets the total token count for the generation request, including both the prompt and the response candidates.
    /// </summary>
    property TotalTokenCount: Int64 read FTotalTokenCount write FTotalTokenCount;
  end;

  /// <summary>
  /// Response from the model supporting multiple candidate responses.
  /// </summary>
  /// <remarks>
  /// Safety ratings and content filtering are reported for both prompt in GenerateContentResponse.prompt_feedback and for each candidate in finishReason and in safetyRatings. The API: - Returns either all requested candidates or none of them - Returns no candidates at all only if there was something wrong with the prompt (check promptFeedback) - Reports feedback on each candidate in finishReason and safetyRatings.
  /// </remarks>
  TChat = class
  private
    FCandidates: TArray<TChatCandidate>;
    FPromptFeedback: TPromptFeedback;
    FUsageMetadata: TUsageMetadata;
  public
    /// <summary>
    /// Candidate responses from the model.
    /// </summary>
    property Candidates: TArray<TChatCandidate> read FCandidates write FCandidates;
    /// <summary>
    /// Returns the prompt's feedback related to the content filters.
    /// </summary>
    property PromptFeedback: TPromptFeedback read FPromptFeedback write FPromptFeedback;
    /// <summary>
    /// Output only. Metadata on the generation requests' token usage.
    /// </summary>
    property UsageMetadata: TUsageMetadata read FUsageMetadata write FUsageMetadata;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a callback procedure used during the reception of responses from a chat request in streaming mode.
  /// </summary>
  /// <param name="Chat">
  /// The <c>TChat</c> object containing the current information about the response generated by the model.
  /// If this value is <c>nil</c>, it indicates that the data stream is complete.
  /// </param>
  /// <param name="IsDone">
  /// A boolean flag indicating whether the streaming process is complete.
  /// If <c>True</c>, it means the model has finished sending all response data.
  /// </param>
  /// <param name="Cancel">
  /// A boolean flag that can be set to <c>True</c> within the callback to cancel the streaming process.
  /// If set to <c>True</c>, the streaming will be terminated immediately.
  /// </param>
  /// <remarks>
  /// This callback is invoked multiple times during the reception of the response data from the model.
  /// It allows for real-time processing of received messages and interaction with the user interface or other systems
  /// based on the state of the data stream.
  /// When the <c>IsDone</c> parameter is <c>True</c>, it indicates that the model has finished responding,
  /// and the <c>Chat</c> parameter will be <c>nil</c>.
  /// </remarks>
  TChatEvent = reference to procedure(var Chat: TChat; IsDone: Boolean; var Cancel: Boolean);

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TChat</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynChat</c> type extends the <c>TAsynParams&lt;TChat&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynChat = TAsynCallBack<TChat>;

  /// <summary>
  /// Manages asynchronous streaming chat callBacks for a chat request using <c>TChat</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynChatStream</c> type extends the <c>TAsynStreamParams&lt;TChat&gt;</c> record to support the lifecycle of an asynchronous streaming chat operation.
  /// It provides callbacks for different stages, including when the operation starts, progresses with new data chunks, completes successfully, or encounters an error.
  /// This structure is ideal for handling scenarios where the chat response is streamed incrementally, providing real-time updates to the user interface.
  /// </remarks>
  TAsynChatStream = TAsynStreamCallBack<TChat>;

  /// <summary>
  /// The <c>TChatRoute</c> class inherits from <c>TGeminiAPIRoute</c> and provides an interface for managing various interactions with the chat API.
  /// It supports creating chat completion requests in synchronous, asynchronous, and streaming modes, offering mechanisms to handle responses generated by the model.
  /// </summary>
  /// <remarks>
  /// This class facilitates sending messages to a chat model, receiving responses, and managing them, whether synchronously or asynchronously.
  /// The primary methods in the class are:
  /// <para>
  /// - <c>Create</c> : Sends a chat request and waits for a full response.
  /// </para>
  /// <para>
  /// - <c>AsynCreate</c> : Performs an asynchronous chat completion request with event handling.
  /// </para>
  /// <para>
  /// - <c>CreateStream</c> : Initiates a chat completion request in streaming mode, receiving tokens progressively.
  /// </para>
  /// <para>
  /// - <c>ASynCreateStream</c> : Performs an asynchronous request in streaming mode with event handling.
  /// </para>
  /// Each method allows configuring model parameters, setting input messages, managing token limits, and including callbacks for processing responses or errors.
  /// </remarks>
  TChatRoute = class(TGeminiAPIRoute)
  public
    /// <summary>
    /// Create an asynchronous completion for chat message
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure to configure the parameters for the chat request, such as model selection, messages, and other parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a record containing event handlers for the asynchronous chat completion, such as on success and on error.
    /// </param>
    /// <remarks>
    /// This procedure initiates an asynchronous request to generate a chat completion based on the provided parameters. The response or error is handled by the provided callBacks.
    /// <code>
    /// // WARNING - Move the following line into the main OnCreate
    /// //var Gemini := TGeminiFactory.CreateInstance(BaererKey);
    /// Gemini.Chat.AsynCreate(
    ///   procedure (Params: TChatParams)
    ///   begin
    ///     // Define chat parameters
    ///   end,
    ///   function: TAsynChat
    ///   begin
    ///     Result.Sender := Memo1;  // Instance passed to callback parameter
    ///
    ///     Result.OnStart := nil;   // If nil then; Can be omitted
    ///
    ///     Result.OnSuccess := procedure (Sender: TObject; Chat: TChat)
    ///     begin
    ///       var M := Sender as TMemo; // Because Result.Sender = Memo1
    ///       // Handle success operation
    ///     end;
    ///
    ///     Result.OnError := procedure (Sender: TObject; Value: string)
    ///     begin
    ///       // Handle error message
    ///     end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsynCreate(const ModelName: string; ParamProc: TProc<TChatParams>;
      CallBacks: TFunc<TAsynChat>);
    /// <summary>
    /// Creates an asynchronous streaming chat completion request.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the chat request, including the model, messages, and additional options such as max tokens and streaming mode.
    /// </param>
    /// <param name="CallBacks">
    /// A function that returns a <c>TAsynChatStream</c> record which contains event handlers for managing different stages of the streaming process: progress updates, success, errors, and cancellation.
    /// </param>
    /// <remarks>
    /// This procedure initiates an asynchronous chat operation in streaming mode, where tokens are progressively received and processed.
    /// The provided event handlers allow for handling progress (i.e., receiving tokens in real time), detecting success, managing errors, and enabling cancellation logic.
    /// <code>
    /// CheckBox1.Checked := False;  //Click to stop the streaming
    /// // WARNING - Move the following line into the main OnCreate
    /// //var Gemini := TGeminiFactory.CreateInstance(BaererKey);
    /// Gemini.Chat.AsynCreateStream(
    ///   procedure(Params: TChatParams)
    ///   begin
    ///     // Define chat parameters
    ///   end,
    ///
    ///   function: TAsynChatStream
    ///   begin
    ///     Result.Sender := Memo1; // Instance passed to callback parameter
    ///     Result.OnProgress :=
    ///         procedure (Sender: TObject; Chat: TChat)
    ///         begin
    ///           // Handle progressive updates to the chat response
    ///         end;
    ///     Result.OnSuccess :=
    ///         procedure (Sender: TObject)
    ///         begin
    ///           // Handle success when the operation completes
    ///         end;
    ///     Result.OnError :=
    ///         procedure (Sender: TObject; Value: string)
    ///         begin
    ///           // Handle error message
    ///         end;
    ///     Result.OnDoCancel :=
    ///         function: Boolean
    ///         begin
    ///           Result := CheckBox1.Checked; // Click on checkbox to cancel
    ///         end;
    ///     Result.OnCancellation :=
    ///         procedure (Sender: TObject)
    ///         begin
    ///           // Processing when process has been canceled
    ///         end;
    ///   end);
    /// </code>
    /// </remarks>
    procedure AsynCreateStream(const ModelName: string; ParamProc: TProc<TChatParams>;
      CallBacks: TFunc<TAsynChatStream>);
    /// <summary>
    /// Creates a completion for the chat message using the provided parameters.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the chat request, such as selecting the model, providing messages, setting token limits, etc.
    /// </param>
    /// <returns>
    /// Returns a <c>TChat</c> object that contains the chat response, including the choices generated by the model.
    /// </returns>
    /// <exception cref="GeminiExceptionAPI">
    /// Thrown when there is an error in the communication with the API or other underlying issues in the API call.
    /// </exception>
    /// <exception cref="GeminiExceptionInvalidRequestError">
    /// Thrown when the request is invalid, such as when required parameters are missing or values exceed allowed limits.
    /// </exception>
    /// <remarks>
    /// The <c>Create</c> method sends a chat completion request and waits for the full response. The returned <c>TChat</c> object contains the model's generated response, including multiple choices if available.
    ///
    /// Example usage:
    /// <code>
    ///   var Gemini := TGeminiFactory.CreateInstance(BaererKey);
    ///   var Chat := Gemini.Chat.Create(
    ///     procedure (Params: TChatParams)
    ///     begin
    ///       // Define chat parameters
    ///     end);
    ///   try
    ///     for var Item in Chat.Candidates do
    ///       WriteLn(Item.Text);
    ///   finally
    ///     Chat.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Create(const ModelName: string; ParamProc: TProc<TChatParams>): TChat;
    /// <summary>
    /// Creates a chat message completion with a streamed response.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure used to configure the parameters for the chat request, such as selecting the model, providing messages, and adjusting other settings like token limits or temperature.
    /// </param>
    /// <param name="Event">
    /// A callback of type <c>TChatEvent</c> that is triggered with each chunk of data received during the streaming process. It includes the current state of the <c>TChat</c> object, a flag indicating if the stream is done, and a boolean to handle cancellation.
    /// </param>
    /// <returns>
    /// Returns <c>True</c> if the streaming process started successfully, <c>False</c> otherwise.
    /// </returns>
    /// <remarks>
    /// This method initiates a chat request in streaming mode, where the response is delivered incrementally in real-time.
    /// The <c>Event</c> callback will be invoked multiple times as tokens are received.
    /// When the response is complete, the <c>IsDone</c> flag will be set to <c>True</c>, and the <c>Chat</c> object will be <c>nil</c>.
    /// The streaming process can be interrupted by setting the <c>Cancel</c> flag to <c>True</c> within the event.
    ///
    /// Example usage:
    /// <code>
    ///   var Gemini := TGeminiFactory.CreateInstance(BaererKey);
    ///   Gemini.Chat.CreateStream(
    ///     procedure (Params: TChatParams)
    ///     begin
    ///       // Define chat parameters
    ///       Params.Stream(True);
    ///     end,
    ///
    ///     procedure(var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
    ///     begin
    ///       // Handle displaying
    ///     end
    ///   );
    /// </code>
    /// </remarks>
    function CreateStream(const ModelName: string; ParamProc: TProc<TChatParams>; Event: TChatEvent): Boolean;
  end;

implementation

uses
  System.StrUtils, System.Math, System.Rtti, Rest.Json, Gemini.Async.Params,
  Gemini.NetEncoding.Base64;

type
  TAttachedManager = record
  private
    function IsUri(const FilePath: string): Boolean;
    function GetMimeType(const FilePath: string): string;
    function GetEncoded(const FilePath: string): string;
  public
    function ToJson(const FilePath: string): TJSONObject;
  end;

{ TChatRoute }

procedure TChatRoute.AsynCreate(const ModelName: string;
  ParamProc: TProc<TChatParams>; CallBacks: TFunc<TAsynChat>);
begin
  with TAsynCallBackExec<TAsynChat, TChat>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TChat
      begin
        Result := Self.Create(ModelName, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TChatRoute.AsynCreateStream(const ModelName: string;
  ParamProc: TProc<TChatParams>; CallBacks: TFunc<TAsynChatStream>);
begin
  var CallBackParams := TUseParamsFactory<TAsynChatStream>.CreateInstance(CallBacks);

  var Sender := CallBackParams.Param.Sender;
  var OnStart := CallBackParams.Param.OnStart;
  var OnSuccess := CallBackParams.Param.OnSuccess;
  var OnProgress := CallBackParams.Param.OnProgress;
  var OnError := CallBackParams.Param.OnError;
  var OnCancellation := CallBackParams.Param.OnCancellation;
  var OnDoCancel := CallBackParams.Param.OnDoCancel;

  var Task: ITask := TTask.Create(
        procedure()
        begin
            {--- Pass the instance of the current class in case no value was specified. }
            if not Assigned(Sender) then
              Sender := Self;

            {--- Trigger OnStart callback }
            if Assigned(OnStart) then
              TThread.Queue(nil,
                procedure
                begin
                  OnStart(Sender);
                end);
            try
              var Stop := False;

              {--- Processing }
              CreateStream(ModelName, ParamProc,
                procedure (var Chat: TChat; IsDone: Boolean; var Cancel: Boolean)
                begin
                  {--- Check that the process has not been canceled }
                  if Assigned(OnDoCancel) then
                    TThread.Queue(nil,
                        procedure
                        begin
                          Stop := OnDoCancel();
                        end);
                  if Stop then
                    begin
                      {--- Trigger when processus was stopped }
                      if Assigned(OnCancellation) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnCancellation(Sender)
                        end);
                      Cancel := True;
                      Exit;
                    end;
                  if not IsDone and Assigned(Chat) then
                    begin
                      var LocalChat := Chat;
                      Chat := nil;

                      {--- Triggered when processus is progressing }
                      if Assigned(OnProgress) then
                        TThread.Synchronize(TThread.Current,
                        procedure
                        begin
                          try
                            OnProgress(Sender, LocalChat);
                          finally
                            {--- Makes sure to release the instance containing the data obtained
                                 following processing}
                            LocalChat.Free;
                          end;
                        end);
                    end
                  else
                  if IsDone then
                    begin
                      {--- Trigger OnEnd callback when the process is done }
                      if Assigned(OnSuccess) then
                        TThread.Queue(nil,
                        procedure
                        begin
                          OnSuccess(Sender);
                        end);
                    end;
                end);
            except
              on E: Exception do
                begin
                  var Error := AcquireExceptionObject;
                  try
                    var ErrorMsg := (Error as Exception).Message;

                    {--- Trigger OnError callback if the process has failed }
                    if Assigned(OnError) then
                      TThread.Queue(nil,
                      procedure
                      begin
                        OnError(Sender, ErrorMsg);
                      end);
                  finally
                    {--- Ensures that the instance of the caught exception is released}
                    Error.Free;
                  end;
                end;
            end;
        end);
  Task.Start;
end;

function TChatRoute.Create(const ModelName: string; ParamProc: TProc<TChatParams>): TChat;
begin
  GeminiLock.Acquire;
  try
    Result := API.Post<TChat, TChatParams>(SetModel(ModelName, ':generateContent'), ParamProc);
  finally
    GeminiLock.Release;
  end;
end;

function TChatRoute.CreateStream(const ModelName: string; ParamProc: TProc<TChatParams>;
  Event: TChatEvent): Boolean;
var
  Response: TStringStream;
  RetPos: Integer;
  Prev: Integer;
  Starting: Boolean;
begin
  Response := TStringStream.Create('', TEncoding.UTF8);
  try
    RetPos := 0;
    Prev := 0;
    Starting := True;
    Result := API.Post<TChatParams>(SetModel(ModelName, ':streamGenerateContent'), ParamProc, Response,
      procedure(const Sender: TObject; AContentLength: Int64; AReadCount: Int64; var AAbort: Boolean)
      var
        IsDone: Boolean;
        Data: string;
        Chat: TChat;
        TextBuffer: string;
        Line: string;
        Ret: Integer;
      begin
        try
          TextBuffer := Response.DataString;
        except
          on E: EEncodingError do
            Exit;
        end;

        Ret := TextBuffer.Length - 1;
        Line := TextBuffer.Substring(RetPos, Ret - RetPos);
        RetPos := Ret + 1;

        Chat := nil;
        Data := Line.Trim([' ', #13, #10]);
        Data := Copy(Data, 2, Data.Length-1);

        IsDone := not Starting and Data.IsEmpty;
        Starting := False;

        if not IsDone then
          try
            Chat := TJson.JsonToObject<TChat>(Data);
            Prev := RetPos;
          except
            Chat := nil;
            RetPos := Prev;
          end;

        try
          Event(Chat, IsDone, AAbort);
        finally
          Chat.Free;
        end;
      end);
  finally
    Response.Free;
  end;
end;

{ TChatParams }

function TChatParams.CachedContent(const Value: string): TChatParams;
begin
  Result := TChatParams(Add('cachedContent', Value));
end;

function TChatParams.Contents(
  const Value: TArray<TContentPayload>): TChatParams;
begin
  var JSONContents := TJSONArray.Create;
  for var Item in Value do
    JSONContents.Add(Item.Detach);
  Result := TChatParams(Add('contents', JSONContents));
end;

function TChatParams.GenerationConfig(const ParamProc: TProcRef<TGenerationConfig>): TChatParams;
begin
  if Assigned(ParamProc) then
    begin
      var Value := TGenerationConfig.Create;
      ParamProc(Value);
      Result := TChatParams(Add('generationConfig', Value.Detach));
    end
  else Result := Self;
end;

class function TChatParams.New(
  const ParamProc: TProcRef<TChatParams>): TChatParams;
begin
  Result := TChatParams.Create;
  if Assigned(ParamProc) then
    begin
      ParamProc(Result);
    end;
end;

function TChatParams.SafetySettings(
  const Value: TArray<TSafety>): TChatParams;
begin
  var JSONSafetySettings := TJSONArray.Create;
  for var Item in Value do
    JSONSafetySettings.Add(Item.ToJson);
  Result := TChatParams(Add('safetySettings', JSONSafetySettings));
end;

function TChatParams.SystemInstruction(const Value: string): TChatParams;
begin
  var PartsJSON := TJSONObject.Create.AddPair('parts', TJSONObject.Create.AddPair('text', Value));
  Result := TChatParams(Add('system_instruction', PartsJSON));
end;

function TChatParams.ToolConfig(const Value: TToolMode; AllowedFunctionNames: TArray<string>): TChatParams;
begin
  var Temp := TJSONObject.Create.AddPair('mode', Value.ToString);
  if Length(AllowedFunctionNames) > 0 then
    begin
      var JSONArray := TJSONArray.Create;
      for var Item in AllowedFunctionNames do
        begin
          JSONArray.Add(Item);
        end;
      Temp.AddPair('allowedFunctionNames', JSONArray);
    end;
  Result := TChatParams(Add('toolConfig',
              TJSONObject.Create.AddPair('function_calling_config', Temp)));
end;

function TChatParams.Tools(const Value: TArray<IFunctionCore>): TChatParams;
begin
  var JSONFuncs := TJSONArray.Create;
  for var Item in value do
    begin
      JSONFuncs.Add(TToolPluginParams.Add(Item).ToJson);
    end;
  var JSONDeclaration := TJSONObject.Create.AddPair('function_declarations', JSONFuncs);
  Result := TChatParams(Add('tools', TJSONArray.Create.Add(JSONDeclaration)));
end;

function TChatParams.Tools(const Value: TToolKind; const Threshold: Double): TChatParams;
begin
  case Value of
    CodeExecution:
      begin
        var JSONCodeExecution := TJSONObject.Create.AddPair('codeExecution', TJSONObject.Create);
        Result := TChatParams(Add('tools', TJSONArray.Create.Add(JSONCodeExecution)));
      end;
    GoogleSearch:
      begin
        var JSONValue := TGoogleSearchRetrieval.Create.DynamicRetrievalConfig('MODE_DYNAMIC', Threshold);
        Result := TChatParams(Add('tools', TJSONObject.Create.AddPair('google_search_retrieval', JSONValue.Detach)));
      end;
    else
      Result := Self;
  end;
end;

{ TMessageRoleHelper }

class function TMessageRoleHelper.Create(const Value: string): TMessageRole;
begin
  var index := IndexStr(AnsiLowerCase(Value), ['user', 'model']);
  if index = -1 then
    raise Exception.Create('String role value not correct');
  Result := TMessageRole(index);
end;

function TMessageRoleHelper.ToString: string;
begin
  case Self of
    user:
      Exit('user');
    model:
      Exit('model');
  end;
end;

{ TChat }

destructor TChat.Destroy;
begin
  for var Item in FCandidates do
    Item.Free;
  if Assigned(FPromptFeedback) then
    FPromptFeedback.Free;
  if Assigned(FUsageMetadata) then
    FUsageMetadata.Free;
  inherited;
end;

{ TChatCandidate }

destructor TChatCandidate.Destroy;
begin
  if Assigned(FContent) then
    FContent.Free;
  for var Item in FSafetyRatings do
    Item.Free;
  if Assigned(FCitationMetadata) then
    FCitationMetadata.Free;
  if Assigned(FlogprobsResult) then
    FlogprobsResult.Free;
  if Assigned(FGroundingMetadata) then
    FGroundingMetadata.Free;
  inherited;
end;

{ TChatContent }

destructor TChatContent.Destroy;
begin
  for var Item in FParts do
    Item.Free;
  inherited;
end;

{ TPromptFeedback }

destructor TPromptFeedback.Destroy;
begin
  for var Item in FSafetyRatings do
    Item.Free;
  inherited;
end;

{ TFinishReasonHelper }

class function TFinishReasonHelper.Create(const Value: string): TFinishReason;
begin
  var Index := IndexStr(AnsiUpperCase(Value), [
         'FINISH_REASON_UNSPECIFIED', 'STOP', 'MAX_TOKENS', 'SAFETY',
         'RECITATION', 'LANGUAGE', 'OTHER', 'BLOCKLIST', 'PROHIBITED_CONTENT',
         'SPII', 'MALFORMED_FUNCTION_CALL']);
  if Index = -1 then
    raise Exception.CreateFmt('"FinishReason" unknown : %s', [Value]);
  Result := TFinishReason(Index);
end;

function TFinishReasonHelper.ToString: string;
begin
  case Self of
    FINISH_REASON_UNSPECIFIED:
      Exit('FINISH_REASON_UNSPECIFIED');
    STOP:
      Exit('STOP');
    MAX_TOKENS:
      Exit('MAX_TOKENS');
    SAFETY:
      Exit('SAFETY');
    RECITATION:
      Exit('RECITATION');
    LANGUAGE:
      Exit('LANGUAGE');
    OTHER:
      Exit('OTHER');
    BLOCKLIST:
      Exit('BLOCKLIST');
    PROHIBITED_CONTENT:
      Exit('PROHIBITED_CONTENT');
    SPII:
      Exit('SPII');
    MALFORMED_FUNCTION_CALL:
      Exit('MALFORMED_FUNCTION_CALL');
  end;
end;

{ TFinishReasonInterceptor }

function TFinishReasonInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TFinishReason>.ToString;
end;

procedure TFinishReasonInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TFinishReason.Create(Arg)));
end;

{ TCitationMetadata }

destructor TCitationMetadata.Destroy;
begin
  for var Item in FCitationSources do
    Item.Free;
  inherited;
end;

{ TLogprobsResult }

destructor TLogprobsResult.Destroy;
begin
  for var Item in FTopCandidates do
    Item.Free;
  for var Item in FChosenCandidates do
    Item.Free;
  inherited;
end;

{ TGenerationConfig }

function TGenerationConfig.CandidateCount(
  const Value: Integer): TGenerationConfig;
begin
  Result := TGenerationConfig(Add('candidateCount', Value));
end;

function TGenerationConfig.FrequencyPenalty(
  const Value: Double): TGenerationConfig;
begin
  Result := TGenerationConfig(Add('frequencyPenalty', Value));
end;

function TGenerationConfig.Logprobs(const Value: Integer): TGenerationConfig;
begin
  Result := TGenerationConfig(Add('logprobs', Value));
end;

function TGenerationConfig.MaxOutputTokens(const Value: Integer): TGenerationConfig;
begin
  Result := TGenerationConfig(Add('maxOutputTokens', Value));
end;

class function TGenerationConfig.New(
  const ParamProc: TProcRef<TGenerationConfig>): TGenerationConfig;
begin
  Result := TGenerationConfig.Create;
  if Assigned(ParamProc) then
    begin
      ParamProc(Result);
    end;
end;

function TGenerationConfig.PresencePenalty(
  const Value: Double): TGenerationConfig;
begin
  Result := TGenerationConfig(Add('presencePenalty', Value));
end;

function TGenerationConfig.ResponseLogprobs(
  const Value: Boolean): TGenerationConfig;
begin
  Result := TGenerationConfig(Add('responseLogprobs', Value));
end;

function TGenerationConfig.ResponseMimeType(const Value: string): TGenerationConfig;
begin
  Result := TGenerationConfig(Add('responseMimeType', Value));
end;

function TGenerationConfig.ResponseSchema(
  const Value: TJSONObject): TGenerationConfig;
begin
  Result := TGenerationConfig(Add('responseSchema', Value));
end;

function TGenerationConfig.ResponseSchema(
  const ParamProc: TProcRef<TSchemaParams>): TGenerationConfig;
begin
  if Assigned(ParamProc) then
    begin
      var Value := TSchemaParams.Create;
      ParamProc(Value);
      Result := TGenerationConfig(Add('responseSchema', Value.Detach));
    end
  else Result := Self;
end;

function TGenerationConfig.ResponseSchema(
  const Value: TSchemaParams): TGenerationConfig;
begin
  Result := TGenerationConfig(Add('responseSchema', Value.Detach));
end;

function TGenerationConfig.StopSequences(
  const Value: TArray<string>): TGenerationConfig;
begin
  if Length(Value) = 0 then
    Exit(Self);
  Result := TGenerationConfig(Add('stopSequences', Value));
end;

function TGenerationConfig.Temperature(const Value: Double): TGenerationConfig;
begin
  Result := TGenerationConfig(Add('temperature', Value));
end;

function TGenerationConfig.TopK(const Value: Integer): TGenerationConfig;
begin
  Result := TGenerationConfig(Add('topK', Value));
end;

function TGenerationConfig.TopP(const Value: Double): TGenerationConfig;
begin
  Result := TGenerationConfig(Add('topP', Value));
end;

{ TMessageRoleInterceptor }

function TMessageRoleInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TMessageRole>.ToString;
end;

procedure TMessageRoleInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TMessageRole.Create(Arg)));
end;

{ TChatPart }

destructor TChatPart.Destroy;
begin
  if Assigned(FFunctionCall) then
    FFunctionCall.Free;
  if Assigned(FFunctionResponse) then
    FFunctionResponse.Free;
  if Assigned(FInlineData) then
    FInlineData.Free;
  if Assigned(FFileData) then
    FFileData.Free;
  if Assigned(FExecutableCode) then
    FExecutableCode.Free;
  if Assigned(FCodeExecutionResult) then
    FCodeExecutionResult.Free;
  inherited;
end;

{ TArgsFixInterceptor }

procedure TArgsFixInterceptor.StringReverter(Data: TObject; Field, Arg: string);
begin
  Arg := Format('{%s}', [Trim(Arg.Replace('`', '"').Replace(#10, ''))]);
  while Arg.Contains(', ') do Arg := Arg.Replace(', ', ',');
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, Arg.Replace(',', ', '));
end;

{ TContentPayload }

class function TContentPayload.Add(const Role: TMessageRole;
  const Text: string; const Attached: TArray<string>): TContentPayload;
begin
  Result := TContentPayload.Create.Role(Role).Parts(Text, Attached);
end;

class function TContentPayload.Assistant(
  const Attached: TArray<string>): TContentPayload;
begin
  Result := Add(TMessageRole.model, Attached);
end;

class function TContentPayload.Assistant(const Value: string;
  const Attached: TArray<string>): TContentPayload;
begin
  Result := Add(Value, Attached).Role(TMessageRole.model);
end;

class function TContentPayload.Add(const Role: TMessageRole;
  const Attached: TArray<string>): TContentPayload;
begin
  Result := TContentPayload.Create.Role(Role).Parts(Attached);
end;

class function TContentPayload.New(
  const ParamProc: TProcRef<TContentPayload>): TContentPayload;
begin
  Result := TContentPayload.Create;
  if Assigned(ParamProc) then
    begin
      ParamProc(Result);
    end;
end;

function TContentPayload.Parts(const Attached: TArray<string>): TContentPayload;
var
  Convert: TAttachedManager;
begin
  var JSONParts := TJSONArray.Create;
  for var Item in Attached do
    JSONParts.Add(Convert.ToJson(Item));
  Result := TContentPayload(Add('parts', JSONParts));
end;

class function TContentPayload.Add(const Text: string;
  const Attached: TArray<string>): TContentPayload;
begin
  Result := TContentPayload.Create.Parts(Text, Attached);
end;

function TContentPayload.Role(const Value: TMessageRole): TContentPayload;
begin
  Result := TContentPayload(Add('role', Value.ToString));
end;

class function TContentPayload.User(
  const Attached: TArray<string>): TContentPayload;
begin
  Result := Add(TMessageRole.user, Attached);
end;

class function TContentPayload.User(const Value: string;
  const Attached: TArray<string>): TContentPayload;
begin
  Result := Add(Value, Attached).Role(TMessageRole.user);
end;

function TContentPayload.Parts(const Value: string;
  const Attached: TArray<string>): TContentPayload;
var
  Convert: TAttachedManager;
begin
  var JSONParts := TJSONArray.Create;
  if not Value.IsEmpty then
    JSONParts.Add(TTextData.Create.Text(Value).Detach);
  for var Item in Attached do
    JSONParts.Add(Convert.ToJson(Item));
  Result := TContentPayload(Add('parts', JSONParts));
end;

{ TTextData }

function TTextData.Text(const Value: string): TTextData;
begin
  Result := TTextData(Add('text', Value));
end;

{ TInlineData }

function TInlineData.Data(const Value: string): TInlineData;
begin
  Result := TInlineData(Add('data', Value));
end;

function TInlineData.MimeType(const Value: string): TInlineData;
begin
  Result := TInlineData(Add('mime_type', Value));
end;

{ TFileData }

function TFileData.FileUri(const Value: string): TFileData;
begin
  Result := TFileData(Add('file_uri', Value));
end;

function TFileData.MimeType(const Value: string): TFileData;
begin
  Result := TFileData(Add('mime_type', Value));
end;

{ TAttachedManager }

function TAttachedManager.GetEncoded(const FilePath: string): string;
begin
  Result := EncodeBase64(FilePath);
end;

function TAttachedManager.GetMimeType(const FilePath: string): string;
begin
  Result := EmptyStr;
  if not IsUri(FilePath) then
    begin
      Result := ResolveMimeType(FilePath);
    end;
end;

function TAttachedManager.IsUri(const FilePath: string): Boolean;
begin
  Result := FilePath.ToLower.StartsWith('http');
end;

function TAttachedManager.ToJson(const FilePath: string): TJSONObject;
begin
  if IsUri(FilePath) then
    begin
      Result := TFileData.Create.FileUri(FilePath).Detach;
      Result := TJSONObject.Create.AddPair('file_data', Result);
    end
  else
    begin
      Result := TInlineData.Create.MimeType(GetMimeType(FilePath)).Data(GetEncoded(FilePath)).Detach;
      Result := TJSONObject.Create.AddPair('inline_data', Result);
    end;
end;

{ TLangueTypeHelper }

class function TLangueTypeHelper.Create(const Value: string): TLangueType;
begin
  var Index := IndexStr(AnsiUpperCase(Value), ['LANGUAGE_UNSPECIFIED', 'PYTHON']);
  if Index = -1 then
    raise Exception.CreateFmt('"Langue type" unknown : %s', [Value]);
  Result := TLangueType(Index);
end;

function TLangueTypeHelper.ToString: string;
begin
  case Self of
    LANGUAGE_UNSPECIFIED:
      Exit('LANGUAGE_UNSPECIFIED');
    PYTHON:
      Exit('PYTHON');
  end;
end;

{ TLangueTypeInterceptor }

function TLangueTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TLangueType>.ToString;
end;

procedure TLangueTypeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TLangueType.Create(Arg)));
end;

{ TOutcomeTypeHelper }

class function TOutcomeTypeHelper.Create(
  const Value: string): TOutcomeType;
begin
  var Index := IndexStr(AnsiUpperCase(Value), [
    'OUTCOME_UNSPECIFIED', 'OUTCOME_OK', 'OUTCOME_FAILED', 'OUTCOME_DEADLINE_EXCEEDED']);
  if Index = -1 then
    raise Exception.CreateFmt('"Code result type" unknown : %s', [Value]);
  Result := TOutcomeType(Index);
end;

function TOutcomeTypeHelper.ToString: string;
begin
  case Self of
    OUTCOME_UNSPECIFIED:
      Exit('OUTCOME_UNSPECIFIED');
    OUTCOME_OK:
      Exit('OUTCOME_OK');
    OUTCOME_FAILED:
      Exit('OUTCOME_FAILED');
    OUTCOME_DEADLINE_EXCEEDED:
      Exit('OUTCOME_DEADLINE_EXCEEDED');
  end;
end;

{ TOutcomeTypeInterceptor }

function TOutcomeTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TOutcomeType>.ToString;
end;

procedure TOutcomeTypeInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TOutcomeType.Create(Arg)));
end;

end.

unit Gemini.Embeddings;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGemini
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.Threading, REST.Json.Types, System.JSON,
  Gemini.API.Params, Gemini.API, Gemini.Async.Params, Gemini.Async.Support;

type
  /// <summary>
  /// Type of task for which the embedding will be used.
  /// </summary>
  TTaskType = (
    /// <summary>
    /// Unset value, which will default to one of the other enum values.
    /// </summary>
    TASK_TYPE_UNSPECIFIED,
    /// <summary>
    /// Specifies the given text is a query in a search/retrieval setting.
    /// </summary>
    RETRIEVAL_QUERY,
    /// <summary>
    /// Specifies the given text is a document from the corpus being searched.
    /// </summary>
    RETRIEVAL_DOCUMENT,
    /// <summary>
    /// Specifies the given text will be used for STS.
    /// </summary>
    SEMANTIC_SIMILARITY,
    /// <summary>
    /// Specifies that the given text will be classified.
    /// </summary>
    CLASSIFICATION,
    /// <summary>
    /// Specifies that the embeddings will be used for clustering.
    /// </summary>
    CLUSTERING,
    /// <summary>
    /// Specifies that the given text will be used for question answering.
    /// </summary>
    QUESTION_ANSWERING,
    /// <summary>
    /// Specifies that the given text will be used for fact verification.
    /// </summary>
    FACT_VERIFICATION,
    /// <summary>
    /// Internal value
    /// </summary>
    NONE
  );

  /// <summary>
  /// Helper record for the <c>TTaskType</c> enumeration, providing utility methods for converting
  /// between <c>TTaskType</c> values and their string representations.
  /// </summary>
  TTaskTypeHelper = record helper for TTaskType
    /// Converts the current <c>TTaskType</c> value to its corresponding string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>TTaskType</c> value.
    /// </returns>
    function ToString: string;
  end;

  /// <summary>
  /// Represents the parameters required to create an embedding request.
  /// </summary>
  /// <remarks>
  /// This record encapsulates all necessary information for generating embeddings, including the model to use,
  /// the content to embed, the type of task, an optional title, and the desired output dimensionality.
  /// </remarks>
  TEmbeddingRequestParams = record
  private
    FModel: string;
    FContent: TArray<string>;
    FTaskType: TTaskType;
    FTitle: string;
    FOutputDimensionality: Integer;
  public
    /// <summary>
    /// The content to embed.
    /// </summary>
    /// <remarks>
    /// Required. Only the parts.text fields will be counted.
    /// </remarks>
    function Content(const Value: TArray<string>): TEmbeddingRequestParams;
    /// <summary>
    /// Optional task type for which the embeddings will be used. Can only be set for models/embedding-001.
    /// </summary>
    /// <remarks>
    /// Optional
    /// </remarks>
    function TaskType(const Value: TTaskType): TEmbeddingRequestParams;
    /// <summary>
    /// An optional title for the text.
    /// </summary>
    /// <remarks>
    /// Optional. Only applicable when TaskType is RETRIEVAL_DOCUMENT.
    /// <para>
    /// - Note: Specifying a title for RETRIEVAL_DOCUMENT provides better quality embeddings for retrieval.
    /// </para>
    /// </remarks>
    function Title(const Value: string): TEmbeddingRequestParams;
    /// <summary>
    /// Optional reduced dimension for the output embedding.
    /// </summary>
    /// <remarks>
    /// If set, excessive values in the output embedding are truncated from the end.
    /// <para>
    /// - Supported by newer models since 2024 only.
    /// </para>
    /// </remarks>
    function OutputDimensionality(const Value: Integer): TEmbeddingRequestParams;
    /// <summary>
    /// Converts the embedding request parameters to a JSON object.
    /// </summary>
    /// <returns>
    /// A <c>TJSONObject</c> representing the embedding request parameters.
    /// </returns>
    function ToJson: TJSONObject;
    /// <summary>
    /// Creates a new instance of <c>TEmbeddingRequestParams</c> with specified settings.
    /// </summary>
    /// <param name="Params">
    /// A procedure reference used to configure the embedding request parameters.
    /// </param>
    /// <returns>
    /// A fully initialized instance of <c>TEmbeddingRequestParams</c>.
    /// </returns>
    class function Create(Params: TProcRef<TEmbeddingRequestParams>): TEmbeddingRequestParams; static;
  end;

  /// <summary>
  /// Represents the parameters required for a batch embedding request.
  /// </summary>
  /// <remarks>
  /// This class encapsulates a collection of embedding requests, allowing for the processing of multiple inputs
  /// in a single API call. Each request in the batch must conform to the specified model.
  /// </remarks>
  TEmbeddingBatchParams = class(TJSONParam)
  public
    /// <summary>
    /// Embed requests for the batch.
    /// </summary>
    /// <param name="Value">
    /// An array of <c>TEmbeddingRequestParams</c> representing the individual embedding requests.
    /// Each request must match the model specified in the <c>TEmbeddingRequestParams</c>.
    /// </param>
    /// <returns>
    /// The current instance of <c>TEmbeddingBatchParams</c> to allow for method chaining.
    /// </returns>
    /// <remarks>
    /// This method is required to specify the requests to be included in the batch embedding process.
    /// </remarks>
    function Requests(const Value: TArray<TEmbeddingRequestParams>): TEmbeddingBatchParams;
  end;

  /// <summary>
  /// Represents the parameters required to create an embedding request.
  /// </summary>
  /// <remarks>
  /// This class encapsulates all necessary information for generating embeddings, including the model to use,
  /// the content to embed, the type of task, an optional title, and the desired output dimensionality.
  /// </remarks>
  TEmbeddingParams = class(TJSONParam)
  public
    /// <summary>
    /// The content to embed.
    /// </summary>
    /// <param name="Value">
    /// An array of strings representing the text content to be embedded.
    /// </param>
    /// <returns>
    /// The current instance of <c>TEmbeddingParams</c> to allow for method chaining.
    /// </returns>
    /// <remarks>
    /// This parameter is required and only the parts.text fields will be counted.
    /// </remarks>
    function Content(const Value: TArray<string>): TEmbeddingParams;
    /// <summary>
    /// Optional task type for which the embeddings will be used.
    /// </summary>
    /// <param name="Value">
    /// The type of task to be performed with the embeddings, specified as a <c>TTaskType</c> value.
    /// </param>
    /// <returns>
    /// The current instance of <c>TEmbeddingParams</c> to allow for method chaining.
    /// </returns>
    /// <remarks>
    /// This parameter is optional and can only be set for models/embedding-001.
    /// </remarks>
    function TaskType(const Value: TTaskType): TEmbeddingParams;
    /// <summary>
    /// An optional title for the text.
    /// </summary>
    /// <param name="Value">
    /// A string representing the title to be associated with the text content.
    /// </param>
    /// <returns>
    /// The current instance of <c>TEmbeddingParams</c> to allow for method chaining.
    /// </returns>
    /// <remarks>
    /// This parameter is optional and only applicable when <c>TaskType</c> is <c>RETRIEVAL_DOCUMENT</c>.
    /// Specifying a title can enhance the quality of embeddings for retrieval.
    /// </remarks>
    function Title(const Value: string): TEmbeddingParams;
    /// <summary>
    /// Optional reduced dimension for the output embedding.
    /// </summary>
    /// <param name="Value">
    /// An integer representing the desired dimensionality for the output embedding.
    /// </param>
    /// <returns>
    /// The current instance of <c>TEmbeddingParams</c> to allow for method chaining.
    /// </returns>
    /// <remarks>
    /// If set, excessive values in the output embedding are truncated from the end.
    /// This feature is supported by newer models since 2024 only.
    /// </remarks>
    function OutputDimensionality(const Value: Integer): TEmbeddingParams;
  end;

  /// <summary>
  /// Represents the content embedding generated from input text.
  /// </summary>
  /// <remarks>
  /// This class encapsulates the embedding values produced by an embedding model,
  /// allowing for access to the numerical representation of the content.
  /// </remarks>
  TEmbeddingValues = class
  private
    FValues: TArray<Double>;
  public
    /// <summary>
    /// The embedding values.
    /// </summary>
    property Values: TArray<Double> read FValues write FValues;
  end;

  /// <summary>
  /// Represents an embedding generated from input content.
  /// </summary>
  /// <remarks>
  /// The <c>TEmbedding</c> class encapsulates a numerical representation of text content,
  /// generated by an embedding model. It can be used for various tasks, such as search, retrieval,
  /// and natural language processing.
  /// </remarks>
  TEmbedding = class
  private
    FEmbedding: TEmbeddingValues;
  public
    /// <summary>
    /// The embedding generated from the input content.
    /// </summary>
    property Embedding: TEmbeddingValues read FEmbedding write FEmbedding;
    /// <summary>
    /// Destructor to free resources associated with the embedding.
    /// </summary>
    /// <remarks>
    /// This destructor ensures that the memory allocated for the <c>TEmbeddingValues</c>
    /// instance is properly released when the <c>TEmbedding</c> instance is destroyed.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents the embedding generated from input content.
  /// </summary>
  /// <remarks>
  /// This class encapsulates the embedding result, providing access to the generated
  /// content embedding, which can be utilized for various applications such as search,
  /// retrieval, and natural language processing tasks.
  /// </remarks>
  TEmbeddings = class
  private
    FEmbeddings: TArray<TEmbeddingValues>;
  public
    /// <summary>
    /// The embeddings for each request, in the same order as provided in the batch request.
    /// </summary>
    property Embeddings: TArray<TEmbeddingValues> read FEmbeddings write FEmbeddings;
    /// <summary>
    /// Destructor to free resources associated with the embedding.
    /// </summary>
    /// <remarks>
    /// This destructor ensures that the memory allocated for the <c>TEmbeddingValues</c>
    /// instance is properly released when the <c>TEmbedding</c> instance is destroyed.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous callbacks for a model search request using <c>TEmbedding</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynEmbedding</c> type extends the <c>TAsynParams&lt;TEmbedding&gt;</c> record to handle the lifecycle of an asynchronous model operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking model search operations and is specifically tailored for scenarios where multiple model choices are required.
  /// </remarks>
  TAsynEmbedding = TAsynCallBack<TEmbedding>;

  /// <summary>
  /// Manages asynchronous callbacks for a model search request using <c>TEmbeddings</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynEmbeddings</c> type extends the <c>TAsynParams&lt;TEmbeddings&gt;</c> record to handle the lifecycle of an asynchronous model operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking model search operations and is specifically tailored for scenarios where multiple model choices are required.
  /// </remarks>
  TAsynEmbeddings = TAsynCallBack<TEmbeddings>;

  /// <summary>
  /// Represents the route for embedding operations in the Gemini API.
  /// </summary>
  /// <remarks>
  /// This class provides methods for performing both synchronous and asynchronous embedding requests
  /// using various models. It manages the currently used model and facilitates embedding operations
  /// by allowing users to set parameters and handle results through callbacks.
  /// </remarks>
  TEmbeddingsRoute = class(TGeminiAPIRoute)
  public
    /// <summary>
    /// Performs an asynchronous embedding request and invokes a callback with the result.
    /// </summary>
    /// <param name="ModelName">
    /// The name of the model.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to set up the embedding parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that will be called with an instance of <c>TAsynEmbedding</c> containing the embedding results once the request is complete.
    /// </param>
    /// <remarks>
    /// Use this method to perform an embedding request that returns immediately, allowing other operations to continue while waiting for the response.
    /// <code>
    ///  Gemini.Embeddings.AsynCreate('model_name',
    ///    procedure (Params: TEmbeddingParams)
    ///    begin
    ///      Params.Content(['Str1']);
    ///    end,
    ///    function : TAsynEmbedding
    ///    begin
    ///      Result.Sender := Obj;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject)
    ///        begin
    ///           // Handle the start of the process
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Integration: TEmbedding)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; ErrorMsg: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///
    ///    end);
    /// </code>
    /// </remarks>
    procedure AsynCreate(const ModelName: string; ParamProc: TProc<TEmbeddingParams>;
      CallBacks: TFunc<TAsynEmbedding>); overload;
    /// <summary>
    /// Performs an asynchronous embedding request and invokes a callback with the result.
    /// </summary>
    /// <param name="ModelName">
    /// The name of the model.
    /// </param>
    /// <param name="Value">
    /// An array of string
    /// </param>
    /// <param name="CallBacks">
    /// A function that will be called with an instance of <c>TAsynEmbedding</c> containing the embedding results once the request is complete.
    /// </param>
    /// <remarks>
    /// Use this method to perform an embedding request that returns immediately, allowing other operations to continue while waiting for the response.
    /// <code>
    ///  Gemini.Embeddings.AsynCreate('model_name',
    ///    procedure (Params: TEmbeddingParams)
    ///    begin
    ///      Params.Content(['Str1']);
    ///    end,
    ///    function : TAsynEmbedding
    ///    begin
    ///      Result.Sender := Obj;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject)
    ///        begin
    ///           // Handle the start of the process
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Integration: TEmbedding)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; ErrorMsg: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///
    ///    end);
    /// </code>
    /// </remarks>
    procedure AsynCreate(const ModelName: string; Value: TArray<string>;
      CallBacks: TFunc<TAsynEmbedding>); overload;
    /// <summary>
    /// Performs an asynchronous embedding request for batch and invokes a callback with the result.
    /// </summary>
    /// <param name="ModelName">
    /// The name of the model.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to set up the embedding parameters.
    /// </param>
    /// <param name="CallBacks">
    /// A function that will be called with an instance of <c>TAsynEmbeddings</c> containing the embedding results once the request is complete.
    /// </param>
    /// <remarks>
    /// Use this method to perform an embedding request that returns immediately, allowing other operations to continue while waiting for the response.
    /// <code>
    ///  Gemini.Embeddings.AsynCreateBatch('model_name',
    ///    procedure (Params: TEmbeddingBatchParams)
    ///    begin
    ///      Params.Content(['Str1']);
    ///    end,
    ///    function : TAsynEmbeddings
    ///    begin
    ///      Result.Sender := Obj;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject)
    ///        begin
    ///           // Handle the start of the process
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Integration: TEmbeddings)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; ErrorMsg: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///
    ///    end);
    /// </code>
    /// </remarks>
    procedure AsynCreateBatch(const ModelName: string; ParamProc: TProc<TEmbeddingBatchParams>;
      CallBacks: TFunc<TAsynEmbeddings>);
    /// <summary>
    /// Performs a synchronous embedding request and returns the result.
    /// </summary>
    /// <param name="ModelName">
    /// The name of the model
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to set up the embedding parameters.
    /// </param>
    /// <returns>
    /// An instance of <c>TEmbedding</c> containing the embedding results.
    /// </returns>
    /// <remarks>
    /// Use this method to perform an embedding request that blocks until the response is received.
    /// <code>
    ///   // Example usage:
    ///  var Integration := Gemini.Embeddings.Create('model_name',
    ///          procedure (Params: TEmbeddingParams)
    ///          begin
    ///            Params.Content(['str1']);
    ///          end);
    ///  try
    ///     // Use Embeddings as needed
    ///  finally
    ///    Embeddings.Free;
    ///  end;
    /// </code>
    /// </remarks>
    function Create(const ModelName: string; ParamProc: TProc<TEmbeddingParams>): TEmbedding; overload;
    /// <summary>
    /// Performs a synchronous embedding request and returns the result.
    /// </summary>
    /// <param name="ModelName">
    /// The name of the model
    /// </param>
    /// <param name="Value">
    /// An array of string
    /// </param>
    /// <returns>
    /// An instance of <c>TEmbedding</c> containing the embedding results.
    /// </returns>
    /// <remarks>
    /// Use this method to perform an embedding request that blocks until the response is received.
    /// <code>
    ///   // Example usage:
    ///  var Integration := Gemini.Embeddings.Create('mon_model', ['Str1']);
    ///  try
    ///     // Use Embeddings as needed
    ///  finally
    ///    Embeddings.Free;
    ///  end;
    /// </code>
    /// </remarks>
    function Create(const ModelName: string; Value: TArray<string>): TEmbedding; overload;
    /// <summary>
    /// Performs a synchronous embedding request for a batch and returns the result.
    /// </summary>
    /// <param name="ModelName">
    /// The name of the model
    /// </param>
    /// <param name="ParamProc">
    /// A procedure to set up the embedding parameters.
    /// </param>
    /// <returns>
    /// An instance of <c>TEmbeddings</c> containing the embedding results.
    /// </returns>
    /// <remarks>
    /// Use this method to perform an embedding request that blocks until the response is received.
    /// <code>
    ///   // Example usage:
    ///  var Integration := Gemini.Embeddings.CreateBatch('model_name',
    ///     procedure (Parameters: TEmbeddingBatchParams)
    ///     begin
    ///       Parameters.Requests(
    ///         [
    ///          TEmbeddingRequestParams.Create(
    ///             procedure (var Params: TEmbeddingRequestParams)
    ///             begin
    ///               Params.Content(['str1', 'str2']);
    ///               Params.OutputDimensionality(10); //Optional
    ///             end)
    ///         ]);
    ///     end);
    ///  try
    ///    // Use Embeddings as needed
    ///  finally
    ///    Embeddings.Free;
    ///  end;
    /// </code>
    /// </remarks>
    function CreateBatch(const ModelName: string; ParamProc: TProc<TEmbeddingBatchParams>): TEmbeddings;
  end;

implementation

uses
  System.StrUtils, System.Rtti, Rest.Json;

{ TTaskTypeHelper }

function TTaskTypeHelper.ToString: string;
begin
  case Self of
    TASK_TYPE_UNSPECIFIED:
      Exit('TASK_TYPE_UNSPECIFIED');
    RETRIEVAL_QUERY:
      Exit('RETRIEVAL_QUERY');
    RETRIEVAL_DOCUMENT:
      Exit('RETRIEVAL_DOCUMENT');
    SEMANTIC_SIMILARITY:
      Exit('SEMANTIC_SIMILARITY');
    CLASSIFICATION:
      Exit('CLASSIFICATION');
    CLUSTERING:
      Exit('CLUSTERING');
    QUESTION_ANSWERING:
      Exit('QUESTION_ANSWERING');
    FACT_VERIFICATION:
      Exit('FACT_VERIFICATION');
    NONE:
      Exit('NONE');
  end;
end;

{ TEmbeddings }

destructor TEmbeddings.Destroy;
begin
  for var Item in FEmbeddings do
    Item.Free;
  inherited;
end;

{ TEmbeddingsRoute }

function TEmbeddingsRoute.Create(const ModelName: string;
  ParamProc: TProc<TEmbeddingParams>): TEmbedding;
begin
  GeminiLock.Acquire;
  try
    Result := API.Post<TEmbedding, TEmbeddingParams>(SetModel(ModelName, ':embedContent'), ParamProc);
  finally
    GeminiLock.Release;
  end;
end;

procedure TEmbeddingsRoute.AsynCreate(const ModelName: string;
  ParamProc: TProc<TEmbeddingParams>; CallBacks: TFunc<TAsynEmbedding>);
begin
  with TAsynCallBackExec<TAsynEmbedding, TEmbedding>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TEmbedding
      begin
        Result := Self.Create(ModelName, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TEmbeddingsRoute.AsynCreate(const ModelName: string;
  Value: TArray<string>; CallBacks: TFunc<TAsynEmbedding>);
begin
  with TAsynCallBackExec<TAsynEmbedding, TEmbedding>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TEmbedding
      begin
        Result := Self.Create(ModelName, Value);
      end);
  finally
    Free;
  end;
end;

procedure TEmbeddingsRoute.AsynCreateBatch(const ModelName: string;
  ParamProc: TProc<TEmbeddingBatchParams>; CallBacks: TFunc<TAsynEmbeddings>);
begin
  with TAsynCallBackExec<TAsynEmbeddings, TEmbeddings>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TEmbeddings
      begin
        Result := Self.CreateBatch(ModelName, ParamProc);
      end);
  finally
    Free;
  end;
end;

function TEmbeddingsRoute.Create(const ModelName: string;
  Value: TArray<string>): TEmbedding;
begin
  Result := Create(ModelName,
    procedure (Params: TEmbeddingParams)
    begin
      Params.Content(Value);
    end);
end;

function TEmbeddingsRoute.CreateBatch(const ModelName: string;
  ParamProc: TProc<TEmbeddingBatchParams>): TEmbeddings;
begin
  GeminiLock.Acquire;
  try
    Result := API.Post<TEmbeddings, TEmbeddingBatchParams>(SetModel(ModelName, ':batchEmbedContents'), ParamProc);
  finally
    GeminiLock.Release;
  end;
end;

{ TEmbeddingBatchParams }

function TEmbeddingBatchParams.Requests(
  const Value: TArray<TEmbeddingRequestParams>): TEmbeddingBatchParams;
begin
  var RequestsJSON := TJSONArray.Create;
  for var Item in Value do
    begin
      RequestsJSON.Add(Item.ToJson);
    end;
  Result := TEmbeddingBatchParams(Add('requests', RequestsJSON));
end;

{ TEmbeddingRequestParams }

function TEmbeddingRequestParams.Content(const Value: TArray<string>): TEmbeddingRequestParams;
begin
  FContent := Value;
  Result := Self;
end;

class function TEmbeddingRequestParams.Create(
  Params: TProcRef<TEmbeddingRequestParams>): TEmbeddingRequestParams;
begin
  Result.FModel := TEmbeddingsRoute.CurrentModel;
  Result.FOutputDimensionality := 768;
  Result.FTaskType := NONE;
  Result.FTitle := EmptyStr;
  if Assigned(Params) then
    Params(Result);
end;

function TEmbeddingRequestParams.OutputDimensionality(
  const Value: Integer): TEmbeddingRequestParams;
begin
  FOutputDimensionality := Value;
  Result := Self;
end;

function TEmbeddingRequestParams.TaskType(const Value: TTaskType): TEmbeddingRequestParams;
begin
  if FModel <> 'models/embedding-001' then
    FTaskType := Value;
  Result := Self;
end;

function TEmbeddingRequestParams.Title(const Value: string): TEmbeddingRequestParams;
begin
  if FModel <> 'models/embedding-001' then
    FTitle := Value;
  Result := Self;
end;

function TEmbeddingRequestParams.ToJson: TJSONObject;
begin
  var PartsJSON := TJSONArray.Create;
  for var Item in FContent do
    begin
      PartsJSON.add(TJSONObject.Create.AddPair('text', Item));
    end;
  var ContentJSON := TJSONObject.Create.AddPair('parts', PARTSJSON);

  Result := TJSONObject.Create;

  if not FModel.IsEmpty then
    Result := Result.AddPair('model', FModel);

  Result := Result.AddPair('content', ContentJSON);

  {--- Optional }
  if FTaskType <> none then
    Result := Result.AddPair('taskType', FTaskType.ToString);

  {--- Optional }
  if not FTitle.IsEmpty and (FTaskType = RETRIEVAL_DOCUMENT) then
    Result := Result.AddPair('title', FTitle);

  {--- Optional }
  if (FOutputDimensionality <> 768) then 
    Result := Result.AddPair('outputDimensionality', FOutputDimensionality);
end;

{ TEmbedding }

destructor TEmbedding.Destroy;
begin
  if Assigned(FEmbedding) then
    FEmbedding.Free;
  inherited;
end;

{ TEmbeddingParams }

function TEmbeddingParams.Content(
  const Value: TArray<string>): TEmbeddingParams;
begin
  var PartsJSON := TJSONArray.Create;
  for var Item in Value do
    begin
      PartsJSON.Add(TJSONObject.Create.AddPair('text', Item));
    end;
  var ContentJSON := TJSONObject.Create;
  ContentJSON.AddPair('parts', PartsJSON);

  Result := TEmbeddingParams(
    Add('model', TEmbeddingsRoute.CurrentModel).
    Add('content', ContentJSON));
end;

function TEmbeddingParams.OutputDimensionality(
  const Value: Integer): TEmbeddingParams;
begin
  Result := TEmbeddingParams(Add('outputDimensionality', Value));
end;

function TEmbeddingParams.TaskType(const Value: TTaskType): TEmbeddingParams;
begin
  Result := TEmbeddingParams(Add('taskType', Value.ToString));
end;

function TEmbeddingParams.Title(const Value: string): TEmbeddingParams;
begin
  Result := TEmbeddingParams(Add('title', Value));
end;

end.

unit Gemini.Errors;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGemini
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  REST.Json.Types;

type
  TErrorCore = class abstract
  end;

  TErrorObject = class
  private
    FCode: Int64;
    FMessage: string;
    FStatus: string;
  public
    property Code: Int64 read FCode write FCode;
    property Message: string read FMessage write FMessage;
    property Status: string read FStatus write FStatus;
  end;

  TError = class(TErrorCore)
  private
    FError: TErrorObject;
  public
    property Error: TErrorObject read FError write FError;
    destructor Destroy; override;
  end;

implementation

{ TError }

destructor TError.Destroy;
begin
  if Assigned(FError) then
    FError.Free;
  inherited;
end;

end.

unit Gemini.Files;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGemini
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, System.Net.URLClient,
  Gemini.API.Params, Gemini.API, Gemini.Async.Support;

type
  /// <summary>
  /// States for the lifecycle of a File, representing its readiness for use and the outcome of processing.
  /// </summary>
  /// <remarks>
  /// The `TStateType` enumeration describes the current status of a file in the Gemini API.
  /// Files typically transition through these states sequentially, from `PROCESSING` to `ACTIVE`,
  /// or, in case of errors, to `FAILED`.
  /// <para>
  /// Detailed State Descriptions:
  /// </para>
  /// <para>
  /// - `STATE_UNSPECIFIED`: The default state used when no other state has been specified.
  ///   This may indicate that the file is new and has not yet been submitted for processing.
  /// </para>
  /// <para>
  /// - `PROCESSING`: The file is currently undergoing processing and is not yet available for inference.
  ///   In this state, the file is temporarily inaccessible for operations until processing is complete.
  /// </para>
  /// <para>
  /// - `ACTIVE`: The file has been successfully processed and is ready for inference or other actions.
  ///   This state indicates that the file is fully functional and available.
  /// </para>
  /// <para>
  /// - `FAILED`: An error occurred during processing, and the file is unavailable for further use.
  ///   This state is final, and the file may need to be deleted or re-uploaded for reprocessing.
  /// </para>
  /// Note: Transitioning between states is typically managed by the server, based on processing
  /// results. Developers should account for possible delays when a file is in `PROCESSING`,
  /// especially when building synchronous operations dependent on the file's availability.
  /// </remarks>
  TStateType = (
    /// <summary>
    /// The default value. This value is used if the state is omitted.
    /// </summary>
    STATE_UNSPECIFIED,
    /// <summary>
    /// File is being processed and cannot be used for inference yet.
    /// </summary>
    PROCESSING,
    /// <summary>
    /// File is processed and available for inference.
    /// </summary>
    ACTIVE,
    /// <summary>
    /// File failed processing.
    /// </summary>
    FAILED
  );

  /// <summary>
  /// Helper record for the <c>TStateType</c> enumeration, providing utility methods for converting
  /// between <c>TStateType</c> values and their string representations.
  /// </summary>
  TStateTypeHelper = record helper for TStateType
    /// <summary>
    /// Converts the current <c>TStateType</c> value to its corresponding string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>TStateType</c> value.
    /// </returns>
    function ToString: string;
    /// <summary>
    /// Converts a string representation of a <c>TStateType</c> into its corresponding enumeration value.
    /// </summary>
    /// <param name="Value">
    /// The string representing a <c>TStateType</c>.
    /// </param>
    /// <returns>
    /// The <c>TStateType</c> enumeration value that corresponds to the provided string.
    /// </returns>
    class function Create(const Value: string): TStateType; static;
  end;

  /// <summary>
  /// Interceptor class for converting <c>TStateType</c> values to and from their string representations in JSON serialization and deserialization.
  /// </summary>
  /// <remarks>
  /// This class is used to facilitate the conversion between the <c>TStateType</c> enum and its string equivalents during JSON processing.
  /// It extends the <c>TJSONInterceptorStringToString</c> class to override the necessary methods for custom conversion logic.
  /// </remarks>
  TStateTypeInterceptor = class(TJSONInterceptorStringToString)
    /// <summary>
    /// Converts the <c>TStateType</c> value of the specified field to a string during JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be converted.
    /// </param>
    /// <param name="Field">
    /// The field name representing the <c>TStateType</c> value.
    /// </param>
    /// <returns>
    /// The string representation of the <c>TStateType</c> value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string back to a <c>TStateType</c> value for the specified field during JSON deserialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be set.
    /// </param>
    /// <param name="Field">
    /// The field name where the <c>TStateType</c> value will be set.
    /// </param>
    /// <param name="Arg">
    /// The string representation of the <c>TStateType</c> to be converted back.
    /// </param>
    /// <remarks>
    /// This method converts the string argument back to the corresponding <c>TStateType</c> value and assigns it to the specified field in the object.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// The class <c>TFileParams</c>managing the parameters provided in the request to obtain the download URI for a file.
  /// </summary>
  TFileParams = class(TJSONParam)
  public
    /// <summary>
    /// Optional. The human-readable display name for the File.
    /// </summary>
    /// <param name="Value">
    /// The display name must be no more than 512 characters in length, including spaces. Example: "Welcome Image"
    /// </param>
    /// <returns>
    /// The string representation of the <c>TFileParams</c> value.
    /// </returns>
    function DisplayName(const Value: string): TFileParams;
  end;

  /// <summary>
  /// The Status class <c>TStatus</c> defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by gRPC. Each Status message contains three pieces of data: error code, error message, and error details.
  /// </summary>
  /// <remarks>
  /// You can find out more about this error model and how to work with it in the API Design Guide.
  /// <para>
  /// - https://google.aip.dev/193
  /// </para>
  /// </remarks>
  TStatus = class
  private
    FCode: Int64;
    FMessage: string;
    FDetails: TArray<string>;
  public
    /// <summary>
    /// The status code, which should be an enum value of google.rpc.Code.
    /// </summary>
    /// <remarks>
    /// https://github.com/grpc
    /// </remarks>
    property Code: Int64 read FCode write FCode;
    /// <summary>
    /// A developer-facing error message, which should be in English.
    /// </summary>
    /// <remarks>
    /// Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
    /// </remarks>
    property Message: string read FMessage write FMessage;
    /// <summary>
    /// A list of messages that carry the error details. There is a common set of message types for APIs to use.
    /// </summary>
    /// <remarks>
    /// An object containing fields of an arbitrary type. An additional field "@type" contains a URI identifying the type. Example: { "id": 1234, "@type": "types.example.com/standard/id" }.
    /// </remarks>
    property Details: TArray<string> read FDetails write FDetails;
  end;

  /// <summary>
  /// The <c>TFileContent</c> class is responsible for handling files uploaded to the API.
  /// </summary>
  TFileContent = class
  private
    FName: string;
    FDisplayName: string;
    FMimeType: string;
    FSizeBytes: string;
    FCreateTime: string;
    FUpdateTime: string;
    FExpirationTime: string;
    FSha256Hash: string;
    FUri: string;
    [JsonReflectAttribute(ctString, rtString, TStateTypeInterceptor)]
    FState: TStateType;
    FError: TStatus;
  public
    /// <summary>
    /// Immutable. Identifier. The File resource name.
    /// </summary>
    /// <remarks>
    /// The ID (name excluding the "files/" prefix) can contain up to 40 characters that are lowercase alphanumeric or dashes (-).
    /// <para>
    /// The ID cannot start or end with a dash. If the name is empty on create, a unique name will be generated. Example: files/123-456
    /// </para>
    /// </remarks>
    property Name: string read FName write FName;
    /// <summary>
    /// Optional. The human-readable display name for the File.
    /// </summary>
    /// <remarks>
    /// The display name must be no more than 512 characters in length, including spaces. Example: "Welcome Image"
    /// </remarks>
    property DisplayName: string read FDisplayName write FDisplayName;
    /// <summary>
    /// Output only. MIME type of the file.
    /// </summary>
    property MimeType: string read FMimeType write FMimeType;
    /// <summary>
    /// Output only. Size of the file in bytes.
    /// </summary>
    property SizeBytes: string read FSizeBytes write FSizeBytes;
    /// <summary>
    /// Output only. The timestamp of when the File was created.
    /// </summary>
    /// <remarks>
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    /// </remarks>
    property CreateTime: string read FCreateTime write FCreateTime;
    /// <summary>
    /// Output only. The timestamp of when the File was last updated.
    /// </summary>
    /// <remarks>
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    /// </remarks>
    property UpdateTime: string read FUpdateTime write FUpdateTime;
    /// <summary>
    /// Output only. The timestamp of when the File will be deleted. Only set if the File is scheduled to expire.
    /// </summary>
    /// <remarks>
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    /// </remarks>
    property ExpirationTime: string read FExpirationTime write FExpirationTime;
    /// <summary>
    /// Output only. SHA-256 hash of the uploaded bytes.
    /// </summary>
    /// <remarks>
    /// A base64-encoded string.
    /// </remarks>
    property Sha256Hash: string read FSha256Hash write FSha256Hash;
    /// <summary>
    /// Output only. The uri of the File.
    /// </summary>
    property Uri: string read FUri write FUri;
    /// <summary>
    /// Output only. Processing state of the File.
    /// </summary>
    property State: TStateType read FState write FState;
    /// <summary>
    /// Output only. Error status if File processing failed.
    /// </summary>
    property Error: TStatus read FError write FError;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a file entity within the Gemini API, encapsulating the file's metadata and content.
  /// </summary>
  /// <remarks>
  /// The <c>TFile</c> class contains a <c>TFileContent</c> object which holds detailed information about the file, such as its name, size, MIME type, and processing state.
  /// Used to manage file operations, such as uploading, retrieving, listing, and deleting files via the Gemini API.
  /// </remarks>
  TFile = class
  private
    FFile: TFileContent;
  public
    /// <summary>
    /// Gets or sets the metadata content of the file.
    /// </summary>
    /// <value>
    /// An instance of <c>TFileContent</c> containing the file's metadata.
    /// </value>
    property &File: TFileContent read FFile write FFile;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a collection of file entities retrieved from the Gemini API, including pagination support.
  /// </summary>
  /// <remarks>
  /// The <c>TFiles</c> class contains an array of <c>TFileContent</c> objects, each representing the metadata and content of a file.
  /// Additionally, it includes a <c>NextPageToken</c> property to handle pagination when listing multiple files.
  /// This class is used to manage and navigate through the list of files available in the Gemini API.
  /// </remarks>
  TFiles = class
  private
    FFiles: TArray<TFileContent>;
    FNextPageToken: string;
  public
    /// <summary>
    /// An array of <c>TFileContent</c> objects representing the files retrieved from the API.
    /// </summary>
    /// <value>
    /// Each element in the array contains metadata such as the file's name, size, MIME type, and processing state.
    /// </value>
    property Files: TArray<TFileContent> read FFiles write FFiles;
    /// <summary>
    /// A token used to retrieve the next page of results in a paginated list of files.
    /// </summary>
    /// <remarks>
    /// Use this token in subsequent API requests to continue listing files from where the previous request left off.
    /// </remarks>
    property NextPageToken: string read FNextPageToken write FNextPageToken;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Class defined for compatibility with asynchrony handling.
  /// </summary>
  TFileDelete = class
  end;

  /// <summary>
  /// Manages API routes for file operations within the Gemini API, including uploading and retrieving files.
  /// </summary>
  /// <remarks>
  /// The <c>TFilesRes</c> class inherits from <c>TGeminiAPIRoute</c> and provides methods for constructing necessary HTTP headers,
  /// extracting upload URIs from API responses, and performing raw file uploads. It serves as a foundational class for handling
  /// lower-level file operations, facilitating the interaction between the application and the Gemini API for file management tasks.
  /// </remarks>
  TFilesRes = class(TGeminiAPIRoute)
  strict private
    /// <summary>
    /// Constructs the HTTP headers required to obtain the upload URI for a specified file.
    /// </summary>
    /// <param name="FilePath">
    /// The local filesystem path to the file for which the upload URI is being requested.
    /// </param>
    /// <returns>
    /// An array of <c>TNetHeader</c> objects containing the necessary headers for the URI request.
    /// </returns>
    function GetUriHeaders(const FilePath: string): TNetHeaders;
    /// <summary>
    /// Constructs the HTTP headers required to perform the actual file upload.
    /// </summary>
    /// <param name="FilePath">
    /// The local filesystem path to the file that is to be uploaded.
    /// </param>
    /// <returns>
    /// An array of <c>TNetHeader</c> objects containing the necessary headers for the upload request.
    /// </returns>
    function GetUploadHeaders(const FilePath: string): TNetHeaders;
    /// <summary>
    /// Extracts the upload URI from the API response headers after initiating a file upload.
    /// </summary>
    /// <remarks>
    /// This method first constructs and sets the necessary custom headers to initiate a URI request
    /// for the specified file. It sends this request to the 'upload/v1beta/files' endpoint.
    /// If successful, the URI is extracted from the response header 'x-goog-upload-url', and any
    /// newline characters are removed. If no URI is provided by the server, this function will
    /// return an empty string, indicating the operation was unsuccessful.
    ///
    /// Use cases:
    /// - This method is called internally when attempting to upload a file, and a successful response
    ///   indicates that the server has provided a valid upload URI for the file.
    /// - If a display name is provided in the `ParamProc` parameter, it will be included as a
    ///   parameter in the URI request, which can be useful for descriptive logging and retrieval purposes.
    ///
    /// </remarks>
    /// <param name="FilePath">
    /// The local filesystem path to the file for which the upload URI is being requested.
    /// </param>
    /// <param name="ParamProc">
    /// An optional procedure to configure additional file parameters, such as a display name,
    /// before extracting the URI.
    /// </param>
    /// <returns>
    /// A string representing the upload URI extracted from the API response headers. If the
    /// request is unsuccessful, it returns an empty string.
    /// </returns>
    function ExtractUriFromHeaders(const FilePath: string; const ParamProc: TProc<TFileParams>): string;
    /// <summary>
    /// Attempts to obtain the upload URI for a specified file, optionally including a display name.
    /// </summary>
    /// <param name="FilePath">
    /// The local filesystem path to the file for which the upload URI is being requested.
    /// </param>
    /// <param name="DisplayName">
    /// An optional human-readable name for the file. If provided, it will be included in the URI request parameters.
    /// </param>
    /// <returns>
    /// A string representing the obtained upload URI. If the display name is provided, it will be included in the URI parameters.
    /// </returns>
    function TryToObtainUriValue(const FilePath: string; const DisplayName: string = ''): string;
  protected
    /// <summary>
    /// Uploads a file to the Gemini API using the specified file path and display name.
    /// </summary>
    /// <param name="FilePath">
    /// The local path to the file to be uploaded.
    /// </param>
    /// <param name="DisplayName">
    /// An optional human-readable name for the file. If provided, it will be used as the display name in the API.
    /// </param>
    /// <returns>
    /// An instance of <c>TFile</c> representing the uploaded file's metadata.
    /// </returns>
    function UploadRaw(const FilePath: string; const DisplayName: string = ''): TFile;
  end;

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TFile</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynFile</c> type extends the <c>TAsynParams&lt;TFile&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynFile = TAsynCallBack<TFile>;

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TFiles</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynFiles</c> type extends the <c>TAsynParams&lt;TFiles&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynFiles = TAsynCallBack<TFiles>;

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TFileDelete</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynFileDelete</c> type extends the <c>TAsynParams&lt;TFileDelete&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynFileDelete = TAsynCallBack<TFileDelete>;

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TFileContent</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynFileContent</c> type extends the <c>TAsynParams&lt;TFileContent&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynFileContent = TAsynCallBack<TFileContent>;

  /// <summary>
  /// Provides high-level API routes for managing files within the Gemini API, including uploading, listing, deleting, and retrieving files both synchronously and asynchronously.
  /// </summary>
  /// <remarks>
  /// The <c>TFilesRoute</c> class inherits from <c>TFilesRes</c> and extends its functionality by offering both synchronous and asynchronous methods for file operations.
  /// It facilitates interactions with the Gemini API by encapsulating the complexities of API calls, allowing developers to easily perform file management tasks such as uploading files with optional display names, listing files with pagination support, deleting specific files, and retrieving file content.
  /// The asynchronous methods leverage callbacks to handle operations without blocking the main thread, enhancing the application's responsiveness.
  /// </remarks>
  TFilesRoute = class(TFilesRes)
  public
    /// <summary>
    /// Asynchronously uploads a file to the Gemini API with an optional display name.
    /// </summary>
    /// <param name="FilePath">
    /// The local filesystem path to the file that is to be uploaded.
    /// </param>
    /// <param name="DisplayName">
    /// An optional human-readable name for the file. If provided, it will be used as the display name in the API.
    /// </param>
    /// <param name="CallBacks">
    /// A callback function that handles the asynchronous response encapsulated in a <c>TAsynFile</c> object.
    /// </param>
    /// <remarks>
    /// <code>
    /// AsynUpLoad('File_Path', 'display_name',
    ///    function : TAsynFile
    ///    begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject)
    ///        begin
    ///           // Trigger the start method
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Uploaded: TFile)
    ///        begin
    ///          // Trigger the success method
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Trigger the error method
    ///        end;
    ///    end);
    /// </code>
    /// </remarks>
    procedure AsynUpload(const FilePath: string; const DisplayName: string;
      CallBacks: TFunc<TAsynFile>); overload;
    /// <summary>
    /// Asynchronously uploads a file to the Gemini API without specifying a display name.
    /// </summary>
    /// <param name="FilePath">
    /// The local filesystem path to the file that is to be uploaded.
    /// </param>
    /// <param name="CallBacks">
    /// A callback function that handles the asynchronous response encapsulated in a <c>TAsynFile</c> object.
    /// </param>
    /// <remarks>
    /// <code>
    /// AsynUpLoad('File_Path',
    ///    function : TAsynFile
    ///    begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject)
    ///        begin
    ///           // Trigger the start method
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Uploaded: TFile)
    ///        begin
    ///          // Trigger the success method
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Trigger the error method
    ///        end;
    ///    end);
    /// </code>
    /// </remarks>
    procedure AsynUpload(const FilePath: string; CallBacks: TFunc<TAsynFile>); overload;
    /// <summary>
    /// Asynchronously retrieves a list of files from the Gemini API.
    /// </summary>
    /// <param name="CallBacks">
    /// A callback function that handles the asynchronous response encapsulated in a <c>TAsynFiles</c> object.
    /// </param>
    /// <remarks>
    /// <code>
    ///   AsynList(
    ///    function : TAsynFiles
    ///    begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject)
    ///        begin
    ///           // Trigger the start method
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Uploaded: TFiles)
    ///        begin
    ///          // Trigger the success method
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Trigger the error method
    ///        end;
    ///    end);
    /// </code>
    /// </remarks>
    procedure AsynList(CallBacks: TFunc<TAsynFiles>); overload;
    /// <summary>
    /// Asynchronously retrieves a paginated list of files from the Gemini API.
    /// </summary>
    /// <param name="PageSize">
    /// The maximum number of files to return in the response.
    /// </param>
    /// <param name="PageToken">
    /// A token identifying the page of results to retrieve. This is typically obtained from a previous list response.
    /// </param>
    /// <param name="CallBacks">
    /// A callback function that handles the asynchronous response encapsulated in a <c>TAsynFiles</c> object.
    /// </param>
    /// <remarks>
    /// <code>
    ///  // Declare the variable "Next" as a string type earlier in the code.
    ///   AsynList(20, Next,
    ///    function : TAsynFiles
    ///    begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject)
    ///        begin
    ///           // Trigger the start method
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Uploaded: TFiles)
    ///        begin
    ///          // Trigger the success method
    ///          Next := Uploaded.NextPageToken;
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Trigger the error method
    ///        end;
    ///    end);
    /// </code>
    /// </remarks>
    procedure AsynList(const PageSize: Integer; const PageToken: string;
      CallBacks: TFunc<TAsynFiles>); overload;
    /// <summary>
    /// Asynchronously deletes a specified file from the Gemini API.
    /// </summary>
    /// <param name="FileName">
    /// Example: files/abc-123 It takes the form files/{filename}.
    /// </param>
    /// <param name="CallBacks">
    /// A callback function that handles the asynchronous response encapsulated in a <c>TAsynFileDelete</c> object.
    /// </param>
    /// <remarks>
    /// <code>
    ///   AsynDelete('FileName_to_delete',
    ///    function : TAsynFileDelete
    ///    begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject)
    ///        begin
    ///           // Trigger the start method
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Uploaded: TFileDelete)
    ///        begin
    ///          // Trigger the success method
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Trigger the error method
    ///        end;
    ///    end);
    /// </code>
    /// </remarks>
    procedure AsynDelete(const FileName: string; CallBacks: TFunc<TAsynFileDelete>);
    /// <summary>
    /// Asynchronously retrieves the content and metadata of a specified file from the Gemini API.
    /// </summary>
    /// <param name="FileName">
    /// Example: files/abc-123 It takes the form files/{filename}.
    /// </param>
    /// <param name="CallBacks">
    /// A callback function that handles the asynchronous response encapsulated in a <c>TAsynFileContent</c> object.
    /// </param>
    /// <remarks>
    /// <code>
    ///   AsynRetrieve('FileName_to_retrieve',
    ///    function : TAsynFileContent
    ///    begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject)
    ///        begin
    ///           // Trigger the start method
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Uploaded: TFileContent)
    ///        begin
    ///          // Trigger the success method
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Trigger the error method
    ///        end;
    ///    end);
    /// </code>
    /// </remarks>
    procedure AsynRetrieve(const FileName: string; CallBacks: TFunc<TAsynFileContent>);
    /// <summary>
    /// Synchronously uploads a file to the Gemini API with an optional display name.
    /// </summary>
    /// <param name="FilePath">
    /// The local filesystem path to the file that is to be uploaded.
    /// </param>
    /// <param name="DisplayName">
    /// An optional human-readable name for the file. If provided, it will be used as the display name in the API.
    /// </param>
    /// <returns>
    /// An instance of <c>TFile</c> representing the uploaded file's metadata.
    /// </returns>
    function Upload(const FilePath: string; const DisplayName: string = ''): TFile;
    /// <summary>
    /// Synchronously retrieves a list of all files from the Gemini API.
    /// </summary>
    /// <returns>
    /// An instance of <c>TFiles</c> containing an array of <c>TFileContent</c> objects and a pagination token.
    /// </returns>
    function List: TFiles; overload;
    /// <summary>
    /// Synchronously retrieves a paginated list of files from the Gemini API.
    /// </summary>
    /// <param name="PageSize">
    /// The maximum number of files to return in the response.
    /// </param>
    /// <param name="PageToken">
    /// A token identifying the page of results to retrieve. This is typically obtained from a previous list response.
    /// </param>
    /// <returns>
    /// An instance of <c>TFiles</c> containing an array of <c>TFileContent</c> objects and a pagination token.
    /// </returns>
    function List(const PageSize: Integer; const PageToken: string): TFiles; overload;
    /// <summary>
    /// Synchronously deletes a specified file from the Gemini API.
    /// </summary>
    /// <param name="FileName">
    /// Example: files/abc-123 It takes the form files/{filename}.
    /// </param>
    /// <returns>
    /// An instance of <c>TFileDelete</c> representing the result of the delete operation.
    /// </returns>
    function Delete(const FileName: string): TFileDelete;
    /// <summary>
    /// Synchronously retrieves the content and metadata of a specified file from the Gemini API.
    /// </summary>
    /// <param name="FileName">
    /// Example: files/abc-123 It takes the form files/{filename}.
    /// </param>
    /// <returns>
    /// An instance of <c>TFileContent</c> containing the file's metadata and content.
    /// </returns>
    function Retrieve(const FileName: string): TFileContent;
  end;

implementation

uses
  System.StrUtils, Gemini.NetEncoding.Base64, System.Rtti, Rest.Json;

{ TFilesRoute }

function TFilesRoute.List: TFiles;
begin
  Result := API.Get<TFiles>('files');
end;

procedure TFilesRoute.AsynList(CallBacks: TFunc<TAsynFiles>);
begin
  with TAsynCallBackExec<TAsynFiles, TFiles>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TFiles
      begin
        Result := Self.List;
      end);
  finally
    Free;
  end;
end;

procedure TFilesRoute.AsynDelete(const FileName: string;
  CallBacks: TFunc<TAsynFileDelete>);
begin
  with TAsynCallBackExec<TAsynFileDelete, TFileDelete>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TFileDelete
      begin
        Result := Self.Delete(FileName);
      end);
  finally
    Free;
  end;
end;

procedure TFilesRoute.AsynList(const PageSize: Integer; const PageToken: string;
  CallBacks: TFunc<TAsynFiles>);
begin
  with TAsynCallBackExec<TAsynFiles, TFiles>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TFiles
      begin
        Result := Self.List(PageSize, PageToken);
      end);
  finally
    Free;
  end;
end;

procedure TFilesRoute.AsynRetrieve(const FileName: string;
  CallBacks: TFunc<TAsynFileContent>);
begin
  with TAsynCallBackExec<TAsynFileContent, TFileContent>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TFileContent
      begin
        Result := Self.Retrieve(FileName);
      end);
  finally
    Free;
  end;
end;

procedure TFilesRoute.AsynUpload(const FilePath: string;
  CallBacks: TFunc<TAsynFile>);
begin
  AsynUpload(FilePath, EmptyStr, CallBacks);
end;

procedure TFilesRoute.AsynUpload(const FilePath, DisplayName: string;
  CallBacks: TFunc<TAsynFile>);
begin
  with TAsynCallBackExec<TAsynFile, TFile>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TFile
      begin
        Result := Self.Upload(FilePath, DisplayName);
      end);
  finally
    Free;
  end;
end;

function TFilesRoute.Delete(const FileName: string): TFileDelete;
begin
  Result := API.Delete<TFileDelete>(FileName);
end;

function TFilesRoute.List(const PageSize: Integer;
  const PageToken: string): TFiles;
begin
  Result := API.Get<TFiles>('files', ParamsBuilder(PageSize, PageToken));
end;

function TFilesRoute.Retrieve(const FileName: string): TFileContent;
begin
  Result := API.Get<TFileContent>(FileName);
end;

function TFilesRoute.Upload(const FilePath, DisplayName: string): TFile;
begin
  Result := UploadRaw(FilePath, DisplayName);
end;

{ TFileParams }

function TFileParams.DisplayName(const Value: string): TFileParams;
begin
  Result := TFileParams(Add('file', TJSONObject.Create.AddPair('display_name', Value)));
end;

{ TStateTypeHelper }

class function TStateTypeHelper.Create(const Value: string): TStateType;
begin
  var index := IndexStr(AnsiUpperCase(Value), [
        'STATE_UNSPECIFIED', 'PROCESSING', 'ACTIVE', 'FAILED']);
  if index = -1 then
    raise Exception.CreateFmt('"TStateType" unknown : %s', [Value]);
  Result := TStateType(index);
end;

function TStateTypeHelper.ToString: string;
begin
  case Self of
    STATE_UNSPECIFIED:
      Exit('STATE_UNSPECIFIED');
    PROCESSING:
      Exit('PROCESSING');
    ACTIVE:
      Exit('ACTIVE');
    FAILED:
      Exit('FAILED');
  end;
end;

{ TStateTypeInterceptor }

function TStateTypeInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TStateType>.ToString;
end;

procedure TStateTypeInterceptor.StringReverter(Data: TObject; Field, Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TStateType.Create(Arg)));
end;

{ TFilesRes }

function TFilesRes.ExtractUriFromHeaders(const FilePath: string;
  const ParamProc: TProc<TFileParams>): string;
begin
  API.CustomHeaders := GetUriHeaders(FilePath);
  try
    var Path := 'upload/v1beta/files';
    var Name := 'x-goog-upload-url';
    Result := API.Find<TFileParams>(Path, Name, ParamProc).Replace(#10, '').Replace(#13, '');
  finally
    API.CustomHeaders := [];
  end;
end;

function TFilesRes.GetUploadHeaders(const FilePath: string): TNetHeaders;
begin
  Result :=
    [TNetHeader.Create('Content-Length', FileSize(FilePath).ToString)] +
    [TNetHeader.Create('X-Goog-Upload-Offset', 0.ToString)] +
    [TNetHeader.Create('X-Goog-Upload-Command', 'upload, finalize')];
end;

function TFilesRes.GetUriHeaders(const FilePath: string): TNetHeaders;
begin
  Result :=
    [TNetHeader.Create('X-Goog-Upload-Protocol', 'resumable')] +
    [TNetHeader.Create('X-Goog-Upload-Command', 'start')] +
    [TNetHeader.Create('X-Goog-Upload-Header-Content-Length', FileSize(FilePath).ToString)] +
    [TNetHeader.Create('X-Goog-Upload-Header-Content-Type', ResolveMimeType(FilePath))];
end;

function TFilesRes.TryToObtainUriValue(const FilePath,
  DisplayName: string): string;
begin
  if Trim(DisplayName).IsEmpty then
    Result := ExtractUriFromHeaders(FilePath, nil)
  else
    Result := ExtractUriFromHeaders(FilePath,
      procedure (Params: TFileParams)
      begin
        Params.DisplayName(DisplayName);
      end);
end;

function TFilesRes.UploadRaw(const FilePath, DisplayName: string): TFile;
begin
  API.CustomHeaders := [];

  {--- Try to obtain an URI }
  var URI := TryToObtainUriValue(FilePath, DisplayName);
  if URI.IsEmpty then
    raise Exception.Create('The server has not provided a URI as expected.');

  {--- Upload the file using a URI }
  API.CustomHeaders := GetUploadHeaders(FilePath);
  try
    Result := API.UploadRaw<TFile>(URI, FilePath);
  finally
    API.CustomHeaders := [];
  end;
end;

{ TFile }

destructor TFile.Destroy;
begin
  if Assigned(FFile) then
    FFile.Free;
  inherited;
end;

{ TFileContent }

destructor TFileContent.Destroy;
begin
  if Assigned(FError) then
    FError.Free;
  inherited;
end;

{ TFiles }

destructor TFiles.Destroy;
begin
  for var Item in FFiles do
    Item.Free;
  inherited;
end;

end.

unit Gemini.FineTunings;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGemini
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.JSON, REST.JsonReflect, REST.Json.Types,
  Gemini.API.Params, Gemini.API, Gemini.Async.Support, Gemini.Chat;

type
  /// <summary>
  /// The state of the tuned model.
  /// </summary>
  TModelState = (
    /// <summary>
    /// Default value. This value is not used.
    /// </summary>
    STATE_UNSPECIFIED,
    /// <summary>
    /// The model is being created.
    /// </summary>
    CREATING,
    /// <summary>
    /// The model is ready to use.
    /// </summary>
    ACTIVE,
    /// <summary>
    /// Failed to create model.
    /// </summary>
    FAILED
  );

  /// <summary>
  /// Helper record for the <c>TModelState</c> enumeration, providing utility methods for converting
  /// between <c>TModelState</c> values and their string representations.
  /// </summary>
  TModelStateHelper = record helper for TModelState
    /// <summary>
    /// Converts the current <c>TModelState</c> value to its corresponding string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>TModelState</c> value.
    /// </returns>
    function ToString: string;
    /// <summary>
    /// Converts a string representation of a <c>TModelState</c> into its corresponding enumeration value.
    /// </summary>
    /// <param name="Value">
    /// The string representing a <c>TModelState</c>.
    /// </param>
    /// <returns>
    /// The <c>TModelState</c> enumeration value that corresponds to the provided string.
    /// </returns>
    class function Create(const Value: string): TModelState; static;
  end;

  /// <summary>
  /// Interceptor class for converting <c>TModelState</c> values to and from their string representations in JSON serialization and deserialization.
  /// </summary>
  /// <remarks>
  /// This class is used to facilitate the conversion between the <c>TModelState</c> enum and its string equivalents during JSON processing.
  /// It extends the <c>TJSONInterceptorStringToString</c> class to override the necessary methods for custom conversion logic.
  /// </remarks>
  TModelStateInterceptor = class(TJSONInterceptorStringToString)
    /// <summary>
    /// Converts the <c>TModelState</c> value of the specified field to a string during JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be converted.
    /// </param>
    /// <param name="Field">
    /// The field name representing the <c>TModelState</c> value.
    /// </param>
    /// <returns>
    /// The string representation of the <c>TModelState</c> value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string back to a <c>TModelState</c> value for the specified field during JSON deserialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be set.
    /// </param>
    /// <param name="Field">
    /// The field name where the <c>TModelState</c> value will be set.
    /// </param>
    /// <param name="Arg">
    /// The string representation of the <c>TModelState</c> to be converted back.
    /// </param>
    /// <remarks>
    /// This method converts the string argument back to the corresponding <c>TModelState</c> value and assigns it to the specified field in the object.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// <c>THyperparametersParams</c> class controlling the tuning process.
  /// </summary>
  /// <remarks>
  /// Read more at https://ai.google.dev/docs/model_tuning_guidance
  /// </remarks>
  THyperparametersParams = class(TJSONParam)
  public
    /// <summary>
    /// Optional. Immutable. The learning rate hyperparameter for tuning.
    /// </summary>
    /// <remarks>
    /// If not set, a default of 0.001 or 0.0002 will be calculated based on the number of training examples.
    /// </remarks>
    function LearningRate(const Value: Double): THyperparametersParams;
    /// <summary>
    /// Optional. Immutable. The learning rate multiplier is used to calculate a final learningRate based on the default (recommended) value
    /// </summary>
    /// <remarks>
    /// Actual learning rate := learningRateMultiplier * default learning rate Default learning rate is dependent on base model and dataset size. If not set, a default of 1.0 will be used.
    /// </remarks>
    function LearningRateMultiplier(const Value: Double): THyperparametersParams;
    /// <summary>
    /// Immutable. The number of training epochs.
    /// </summary>
    /// <remarks>
    /// An epoch is one pass through the training data. If not set, a default of 5 will be used.
    /// </remarks>
    function EpochCount(const Value: Integer): THyperparametersParams;
    /// <summary>
    /// Immutable. The batch size hyperparameter for tuning.
    /// </summary>
    /// <remarks>
    /// If not set, a default of 4 or 16 will be used based on the number of training examples.
    /// </remarks>
    function BatchSize(const Value: Integer): THyperparametersParams;
  end;

  /// <summary>
  /// <c>TTuningExample</c> class controling a single example for tuning.
  /// </summary>
  TTuningExample = class(TJSONParam)
  public
    /// <summary>
    /// Required. The expected model output.
    /// </summary>
    function Output(const Value: string): TTuningExample;
    /// <summary>
    /// Optional. Text model input.
    /// </summary>
    function TextInput(const Value: string): TTuningExample;
    class function AddItem(const Input, Output: string): TTuningExample;
  end;

  /// <summary>
  /// <c>TTuningExample</c> class controling a single example for tuning.
  /// </summary>
  Example = TTuningExample;

  /// <summary>
  /// Provides utility methods for handling tuning tasks, including converting training data to JSON formats.
  /// </summary>
  /// <remarks>
  /// The <c>TTuningTaskHelper</c> record contains static methods that assist in transforming training data from various sources
  /// into JSON structures required by the Gemini API. It facilitates the preparation of training examples and the parsing of JSONL files.
  /// </remarks>
  TTuningTaskHelper = record
    /// <summary>
    /// Converts the contents of a CSV file into a <c>TJSONArray</c>.
    /// </summary>
    /// <param name="FileName">
    /// The file path of the CSV file containing the data.
    /// </param>
    /// <param name="Separator">
    /// The character used as the delimiter between columns in the CSV file. Default is ';'.
    /// </param>
    /// <returns>
    /// A <c>TJSONArray</c> representing the array of JSON objects parsed from the CSV file.
    /// </returns>
    /// <exception cref="Exception">
    /// Thrown if the specified CSV file does not exist or cannot be read.
    /// </exception>
    class function LoadFromCSV(const FileName: string; Separator: Char = ';'): TJSONArray; static;
    /// <summary>
    /// Converts the contents of a JSONL (JSON Lines) file into a <c>TJSONArray</c>.
    /// </summary>
    /// <param name="FileName">
    /// The file path of the JSONL file containing the data.
    /// </param>
    /// <returns>
    /// A <c>TJSONArray</c> representing the array of JSON objects parsed from the JSONL file.
    /// </returns>
    /// <exception cref="Exception">
    /// Thrown if the specified JSONL file does not exist or cannot be read.
    /// </exception>
    class function LoadFromJSONL(const FileName: string): TJSONArray; static;
    /// <summary>
    /// Converts the contents of a CSV or JSONL file into a <c>TJSONArray</c>, based on the file extension.
    /// </summary>
    /// <param name="FileName">
    /// The file path of the data file. Must be a CSV or JSONL file.
    /// </param>
    /// <returns>
    /// A <c>TJSONArray</c> representing the array of JSON objects parsed from the file.
    /// </returns>
    /// <exception cref="Exception">
    /// Thrown if the specified file does not exist, is not readable, or is of an unsupported format.
    /// </exception>
    class function FileDataToJSONArray(const FileName: string): TJSONArray; static;
    /// <summary>
    /// Builds a <c>TJSONObject</c> containing training examples from an array of <c>TTuningExample</c> instances.
    /// </summary>
    /// <param name="Value">
    /// An array of <c>TTuningExample</c> instances representing individual training examples.
    /// </param>
    /// <returns>
    /// A <c>TJSONObject</c> with a single pair where the key is "examples" and the value is a <c>TJSONArray</c> of the provided examples.
    /// </returns>
    class function ExamplesBuilder(const Value: TArray<TTuningExample>): TJSONObject; overload; static;
    /// <summary>
    /// Builds a <c>TJSONObject</c> containing training examples by reading from a JSONL file.
    /// </summary>
    /// <param name="JSONLFileName">
    /// The file path of the JSONL file containing training data.
    /// </param>
    /// <returns>
    /// A <c>TJSONObject</c> with a single pair where the key is "examples" and the value is a <c>TJSONArray</c> of the parsed examples.
    /// </returns>
    /// <exception cref="Exception">
    /// Thrown if the specified JSONL file does not exist or cannot be parsed.
    /// </exception>
    class function ExamplesBuilder(const FileName: string): TJSONObject; overload; static;
  end;

  /// <summary>
  /// <c>TTuningTaskParams</c> controls the training data for a tuned models.
  /// </summary>
  TTuningTaskParams = class(TJSONParam)
  public
    /// <summary>
    /// Required. Input only. Immutable. The model training data.
    /// </summary>
    function TrainingData(const JSONLFileName: string): TTuningTaskParams; overload;
    /// <summary>
    /// Required. Input only. Immutable. The model training data.
    /// </summary>
    function TrainingData(const Value: TArray<TTuningExample>): TTuningTaskParams; overload;
    /// <summary>
    /// Required. Input only. Immutable. The model training data.
    /// </summary>
    function TrainingData(const Value: TJSONObject): TTuningTaskParams; overload;
    /// <summary>
    /// Immutable. Hyperparameters controlling the tuning process.
    /// </summary>
    /// <remarks>
    /// If not provided, default values will be used.
    /// </remarks>
    function Hyperparameters(ParamProc: TProcRef<THyperparametersParams>): TTuningTaskParams;
  end;

  /// <summary>
  /// <c>TTunedModelParams</c> control the creation of a tuned model.
  /// </summary>
  /// <remarks>
  /// Check intermediate tuning progress (if any) through the google.longrunning.Operations service.
  /// </remarks>
  TTunedModelParams = class(TJSONParam)
  public
    /// <summary>
    /// Optional. The name to display for this model in user interfaces.
    /// </summary>
    /// <param name="Value">
    /// The display name must be up to 40 characters including spaces.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TTunedModelParams</c> instance, allowing for method chaining.
    /// </returns>
    function DisplayName(const Value: string): TTunedModelParams;
    /// <summary>
    /// A short description of this model.
    /// </summary>
    /// <param name="Value">
    /// A string to briefly describe the model.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TTunedModelParams</c> instance, allowing for method chaining.
    /// </returns>
    function Description(const Value: string): TTunedModelParams;
    /// <summary>
    /// Required. The tuning task that creates the tuned model.
    /// </summary>
    /// <param name="Value">
    /// <c>TTuningTaskParams</c> instance representing a tuning tasks that create tuned models.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TTunedModelParams</c> instance, allowing for method chaining.
    /// </returns>
    function TuningTask(const Value: TTuningTaskParams): TTunedModelParams; overload;
    /// <summary>
    /// Optional. List of project numbers that have read access to the tuned model.
    /// </summary>
    /// <param name="Value">
    /// An array of integers where each item represents a project number.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TTunedModelParams</c> instance, allowing for method chaining.
    /// </returns>
    function ReaderProjectNumbers(const Value: TArray<Integer>): TTunedModelParams;
    /// <summary>
    /// Optional. TunedModel to use as the starting point for training the new model.
    /// </summary>
    /// <param name="Value">
    /// Example: tunedModels/my-tuned-model
    /// </param>
    /// <returns>
    /// Returns the updated <c>TTunedModelParams</c> instance, allowing for method chaining.
    /// </returns>
    function TunedModelSource(const Value: string): TTunedModelParams;
    /// <summary>
    /// Immutable. The name of the Model to tune.
    /// </summary>
    /// <param name="Value">
    /// Example: models/gemini-1.5-flash-001
    /// </param>
    /// <returns>
    /// Returns the updated <c>TTunedModelParams</c> instance, allowing for method chaining.
    /// </returns>
    function BaseModel(const Value: string): TTunedModelParams;
    /// <summary>
    /// Optional. Controls the randomness of the output.
    /// </summary>
    /// <param name="Value">
    /// Values can range over [0.0,1.0], inclusive. A value closer to 1.0 will produce responses that are more varied, while a value closer to 0.0 will typically result in less surprising responses from the model.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TTunedModelParams</c> instance, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// This value specifies default to be the one used by the base model while creating the model.
    /// </remarks>
    function Temperature(const Value: Double): TTunedModelParams;
    /// <summary>
    /// Optional. For Nucleus sampling.
    /// </summary>
    /// <param name="Value">
    /// Nucleus sampling considers the smallest set of tokens whose probability sum is at least topP.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TTunedModelParams</c> instance, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// This value specifies default to be the one used by the base model while creating the model.
    /// </remarks>
    function TopP(const Value: Double): TTunedModelParams;
    /// <summary>
    /// Optional. For Top-k sampling.
    /// </summary>
    /// <param name="Value">
    /// Top-k sampling considers the set of topK most probable tokens. This value specifies default to be used by the backend while making the call to the model.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TTunedModelParams</c> instance, allowing for method chaining.
    /// </returns>
    /// <remarks>
    /// This value specifies default to be the one used by the base model while creating the model.
    /// </remarks>
    function TopK(const Value: Integer): TTunedModelParams;
  end;

  /// <summary>
  /// The <c>TModelTraining</c> class allows to use the information returned after processing to fine-tune a model.
  /// </summary>
  TModelTraining = class
  private
    FName: string;
    [JsonReflectAttribute(ctString, rtString, TArgsFixInterceptor)]
    FMetadata: string;
    FDone: Boolean;
    [JsonReflectAttribute(ctString, rtString, TArgsFixInterceptor)]
    FResponse: string;
  public
    /// <summary>
    /// The server-assigned name, which is only unique within the same service that originally returns it.
    /// </summary>
    /// <remarks>
    /// you use the default HTTP mapping, the name should be a resource name ending with operations/{unique_id}.
    /// </remarks>
    property Name: string read FName write FName;
    /// <summary>
    /// Service-specific metadata associated with the operation.
    /// </summary>
    /// <remarks>
    /// It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
    /// <para>
    /// An object containing fields of an arbitrary type. An additional field "@type" contains a URI identifying the type. Example: { "id": 1234, "@type": "types.example.com/standard/id" }.
    /// </para>
    /// </remarks>
    property Metadata: string read FMetadata write FMetadata;
    /// <summary>
    /// If the value is false, it means the operation is still in progress.
    /// </summary>
    /// <remarks>
    /// If true, the operation is completed, and either error or response is available.
    /// </remarks>
    property Done: Boolean read FDone write FDone;
    /// <summary>
    /// The normal, successful response of the operation.
    /// </summary>
    /// <remarks>
    /// If the original method returns no data on success, such as Delete, the response is google.protobuf.Empty. If the original method is standard Get/Create/Update, the response should be the resource. For other methods, the response should have the type XxxResponse, where Xxx is the original method name. For example, if the original method name is TakeSnapshot(), the inferred response type is TakeSnapshotResponse.
    /// <para>
    /// An object containing fields of an arbitrary type. An additional field "@type" contains a URI identifying the type. Example: { "id": 1234, "@type": "types.example.com/standard/id" }.
    /// </para>
    /// </remarks>
    property Response: string read FResponse write FResponse;
  end;

  /// <summary>
  /// The <c>TTuningSnapshot</c> class allows you to utilize the information returned from a single tuning step.
  /// </summary>
  TTuningSnapshot = class
  private
    FStep: Integer;
    FEpoch: Integer;
    FMeanLoss: Double;
    FComputeTime: string;
  public
    /// <summary>
    /// Output only. The tuning step.
    /// </summary>
    property Step: Integer read FStep write FStep;
    /// <summary>
    /// Output only. The epoch this step was part of.
    /// </summary>
    property Epoch: Integer read FEpoch write FEpoch;
    /// <summary>
    /// Output only. The mean loss of the training examples for this step.
    /// </summary>
    property MeanLoss: Double read FMeanLoss write FMeanLoss;
    /// <summary>
    /// Output only. The timestamp when this metric was computed.
    /// </summary>
    /// <remarks>
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    /// </remarks>
    property ComputeTime: string read FComputeTime write FComputeTime;
  end;

  /// <summary>
  /// <c>Hyperparameters</c> class controlling the tuning process.
  /// </summary>
  THyperParameters = class
  private
    FLearningRate: Double;
    FLearningRateMultiplier: Double;
    FEpochCount: Integer;
    FBatchSize: Integer;
  public
    /// <summary>
    /// Optional. Immutable. The learning rate hyperparameter for tuning.
    /// </summary>
    /// <remarks>
    /// If not set, a default of 0.001 or 0.0002 will be calculated based on the number of training examples.
    /// </remarks>
    property LearningRate: Double read FLearningRate write FLearningRate;
    /// <summary>
    /// Optional. Immutable. The learning rate multiplier is used to calculate a final learningRate based on the default (recommended) value.
    /// </summary>
    /// <remarks>
    /// Actual learning rate := learningRateMultiplier * default learning rate Default learning rate is dependent on base model and dataset size. If not set, a default of 1.0 will be used.
    /// </remarks>
    property LearningRateMultiplier: Double read FLearningRateMultiplier write FLearningRateMultiplier;
    /// <summary>
    /// Immutable. The number of training epochs.
    /// </summary>
    /// <remarks>
    /// An epoch is one pass through the training data. If not set, a default of 5 will be used.
    /// </remarks>
    property EpochCount: Integer read FEpochCount write FEpochCount;
    /// <summary>
    /// Immutable. The batch size hyperparameter for tuning.
    /// </summary>
    /// <remarks>
    /// If not set, a default of 4 or 16 will be used based on the number of training examples.
    /// </remarks>
    property BatchSize: Integer read FBatchSize write FBatchSize;
  end;

  /// <summary>
  /// The <c>TTuningTask</c> class controls tuning tasks that create tuned models.
  /// </summary>
  TTuningTask = class
  private
    FStartTime: string;
    FCompleteTime: string;
    FSnapshots: TArray<TTuningSnapshot>;
    FHyperparameters: THyperParameters;
  public
    /// <summary>
    /// Output only. The timestamp when tuning this model started.
    /// </summary>
    /// <remarks>
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    /// </remarks>
    property StartTime: string read FStartTime write FStartTime;
    /// <summary>
    /// Output only. The timestamp when tuning this model completed.
    /// </summary>
    /// <remarks>
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    /// </remarks>
    property CompleteTime: string read FCompleteTime write FCompleteTime;
    /// <summary>
    /// Output only. Metrics collected during tuning.
    /// </summary>
    property Snapshots: TArray<TTuningSnapshot> read Fsnapshots write Fsnapshots;
    /// <summary>
    /// Immutable. Hyperparameters controlling the tuning process. If not provided, default values will be used.
    /// </summary>
    property Hyperparameters: THyperParameters read FHyperparameters write FHyperparameters;
    destructor Destroy; override;
  end;

  /// <summary>
  /// The <TTunedModelSource> class controls a tuned model as a source for training a new model.
  /// </summary>
  TTunedModelSource = class
  private
    FTunedModel: string;
    FBaseModel: string;
  public
    /// <summary>
    /// Immutable. The name of the TunedModel to use as the starting point for training the new model.
    /// </summary>
    /// <remarks>
    /// Example: tunedModels/my-tuned-model
    /// </remarks>
    property TunedModel: string read FTunedModel write FTunedModel;
    /// <summary>
    /// Output only. The name of the base Model this TunedModel was tuned from.
    /// </summary>
    /// <remarks>
    /// Example: models/gemini-1.5-flash-001
    /// </remarks>
    property BaseModel: string read FBaseModel write FBaseModel;
  end;

  /// <summary>
  /// The <c>TTunedModel</c> class allows to utilize the information from created fine-tuned model.
  /// </summary>
  TTunedModel = class
  private
    FName: string;
    FDisplayName: string;
    FDescription: string;
    [JsonReflectAttribute(ctString, rtString, TModelStateInterceptor)]
    FState: TModelState;
    FCreateTime: string;
    FUpdateTime: string;
    FTuningTask: TTuningTask;
    FReaderProjectNumbers: TArray<Int64>;
    FTunedModelSource: TTunedModelSource;
    FBaseModel: string;
    FTemperature: Double;
    FTopP: Double;
    FTopK: Integer;
  public
    /// <summary>
    /// Output only. The tuned model name.
    /// </summary>
    /// <summary>
    /// A unique name will be generated on create. Example: tunedModels/az2mb0bpw6i If displayName is set on create, the id portion of the name will be set by concatenating the words of the displayName with hyphens and adding a random portion for uniqueness.
    /// <para>
    /// Example: displayName = Sentence Translator; name = tunedModels/sentence-translator-u3b7m
    /// </para>
    /// </summary>
    property Name: string read FName write FName;
    /// <summary>
    /// Optional. The name to display for this model in user interfaces.
    /// </summary>
    /// <remarks>
    /// The display name must be up to 40 characters including spaces.
    /// </remarks>
    property DisplayName: string read FDisplayName write FDisplayName;
    /// <summary>
    /// Optional. A short description of this model.
    /// </summary>
    property Description: string read FDescription write FDescription;
    /// <summary>
    /// Output only. The state of the tuned model.
    /// </summary>
    property State: TModelState read FState write FState;
    /// <summary>
    /// Output only. The timestamp when this model was created.
    /// </summary>
    /// <remarks>
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    /// </remarks>
    property CreateTime: string read FCreateTime write FCreateTime;
    /// <summary>
    /// Output only. The timestamp when this model was updated.
    /// </summary>
    /// <remarks>
    /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
    /// </remarks>
    property UpdateTime: string read FUpdateTime write FUpdateTime;
    /// <summary>
    /// Required. The tuning task that creates the tuned model.
    /// </summary>
    property TuningTask: TTuningTask read FTuningTask write FTuningTask;
    /// <summary>
    /// Optional. List of project numbers that have read access to the tuned model.
    /// </summary>
    property ReaderProjectNumbers: TArray<Int64> read FReaderProjectNumbers write FReaderProjectNumbers;
    /// <summary>
    /// Optional. TunedModel to use as the starting point for training the new model.
    /// </summary>
    property TunedModelSource: TTunedModelSource read FTunedModelSource write FTunedModelSource;
    /// <summary>
    /// Immutable. The name of the Model to tune.
    /// </summary>
    /// <remarks>
    /// Example: models/gemini-1.5-flash-001
    /// </remarks>
    property BaseModel: string read FBaseModel write FBaseModel;
    /// <summary>
    /// Optional. Controls the randomness of the output.
    /// </summary>
    /// <remarks>
    /// Values can range over [0.0,1.0], inclusive. A value closer to 1.0 will produce responses that are more varied, while a value closer to 0.0 will typically result in less surprising responses from the model.
    /// This value specifies default to be the one used by the base model while creating the model.
    /// </remarks>
    property Temperature: Double read FTemperature write FTemperature;
    /// <summary>
    /// Optional. For Nucleus sampling.
    /// </summary>
    /// <remarks>
    /// Nucleus sampling considers the smallest set of tokens whose probability sum is at least topP.
    /// This value specifies default to be the one used by the base model while creating the model.
    /// </remarks>
    property TopP: Double read FTopP write FTopP;
    /// <summary>
    /// Optional. For Top-k sampling.
    /// </summary>
    /// <remarks>
    /// Top-k sampling considers the set of topK most probable tokens. This value specifies default to be used by the backend while making the call to the model.
    /// This value specifies default to be the one used by the base model while creating the model.
    /// </remarks>
    property TopK: Integer read FTopK write FTopK;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents a collection of tuned models along with pagination information.
  /// </summary>
  /// <remarks>
  /// The <c>TTunedModels</c> class contains a list of <c>TTunedModel</c> instances and a token for fetching the next page of results.
  /// This is typically used when listing tuned models with support for pagination.
  /// </remarks>
  TTunedModels = class
  private
    FTunedModels: TArray<TTunedModel>;
    FNextPageToken: string;
  public
    /// <summary>
    /// Gets or sets the array of tuned models.
    /// </summary>
    /// <value>
    /// An array of <c>TTunedModel</c> instances representing the tuned models.
    /// </value>
    property TunedModels: TArray<TTunedModel> read FTunedModels write FTunedModels;
    /// <summary>
    /// Gets or sets the token used to retrieve the next page of tuned models.
    /// </summary>
    /// <value>
    /// A string token that can be used to fetch the next page of results. If empty, there are no more pages.
    /// </value>
    property NextPageToken: string read FNextPageToken write FNextPageToken;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Class defined for compatibility with asynchrony handling.
  /// </summary>
  TModelDelete = class
  end;

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TModelTraining</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynModelTraining</c> type extends the <c>TAsynParams&lt;TModelTraining&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynModelTraining = TAsynCallBack<TModelTraining>;

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TTunedModel</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynTunedModel</c> type extends the <c>TAsynParams&lt;TTunedModel&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynTunedModel = TAsynCallBack<TTunedModel>;

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TTunedModels</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynTunedModels</c> type extends the <c>TAsynParams&lt;TTunedModels&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynTunedModels = TAsynCallBack<TTunedModels>;

  /// <summary>
  /// Manages asynchronous chat callBacks for a chat request using <c>TModelDelete</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynModelDelete</c> type extends the <c>TAsynParams&lt;TModelDelete&gt;</c> record to handle the lifecycle of an asynchronous chat operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking chat operations and is specifically tailored for scenarios where multiple choices from a chat model are required.
  /// </remarks>
  TAsynModelDelete = TAsynCallBack<TModelDelete>;

  /// <summary>
  /// Provides methods for managing fine-tuned models, including creation, listing, retrieval, updating, and deletion.
  /// </summary>
  /// <remarks>
  /// The <c>TFineTuneRoute</c> class extends <c>TGeminiAPIRoute</c> and interacts with the Gemini API to perform operations related to fine-tuning models.
  /// It supports both synchronous and asynchronous operations, allowing for flexible integration into various application workflows.
  /// </remarks>
  TFineTuneRoute = class(TGeminiAPIRoute)
    /// <summary>
    /// Asynchronously creates a new model training operation using a JSON object.
    /// </summary>
    /// <param name="Value">
    /// A <c>TJSONObject</c> containing the parameters for the model training.
    /// </param>
    /// <param name="CallBacks">
    /// A callback function that handles the asynchronous response of type <c>TAsynModelTraining</c>.
    /// </param>
    /// <remarks>
    /// <code>
    ///   ASynCreate('JSONObject',
    ///    function : TAsynModelTraining
    ///    begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject)
    ///        begin
    ///           // Trigger the start method
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Model: TModelTraining)
    ///        begin
    ///          // Trigger the success method
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Trigger the error method
    ///        end;
    ///    end);
    /// </code>
    /// </remarks>
    procedure ASynCreate(const Value: TJSONObject; CallBacks: TFunc<TAsynModelTraining>); overload;
    /// <summary>
    /// Asynchronously creates a new model training operation using a parameter procedure.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure that configures <c>TTunedModelParams</c> for the model training.
    /// </param>
    /// <param name="CallBacks">
    /// A callback function that handles the asynchronous response of type <c>TAsynModelTraining</c>.
    /// </param>
    /// <remarks>
    /// <code>
    ///   ASynCreate('JSONObject',
    ///    procedure (Params: TTunedModelParams)
    ///    begin
    ///      // Set parameters
    ///    end,
    ///
    ///    function : TAsynModelTraining
    ///    begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject)
    ///        begin
    ///           // Trigger the start method
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Model: TModelTraining)
    ///        begin
    ///          // Trigger the success method
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Trigger the error method
    ///        end;
    ///    end);
    /// </code>
    /// </remarks>
    procedure ASynCreate(ParamProc: TProc<TTunedModelParams>; CallBacks: TFunc<TAsynModelTraining>); overload;
    /// <summary>
    /// Asynchronously retrieves a list of tuned models with pagination support.
    /// </summary>
    /// <param name="PageSize">
    /// The maximum number of tuned models to return in the response.
    /// </param>
    /// <param name="PageToken">
    /// A token identifying the page of results to retrieve.
    /// </param>
    /// <param name="Filter">
    /// A filter string to constrain the results.
    /// </param>
    /// <param name="CallBacks">
    /// A callback function that handles the asynchronous response of type <c>TAsynTunedModels</c>.
    /// </param>
    /// <remarks>
    /// <code>
    ///   // Declare the variable "Next" as a string type earlier in the code.
    ///   ASynList(PageSize, Next
    ///    function : TAsynTunedModels
    ///    begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject)
    ///        begin
    ///           // Trigger the start method
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Models: TTunedModels)
    ///        begin
    ///          // Trigger the success method
    ///          Next := Models.NextPageToken;
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Trigger the error method
    ///        end;
    ///    end);
    /// </code>
    /// </remarks>
    procedure ASynList(const PageSize: Integer; const PageToken, Filter: string;
      CallBacks: TFunc<TAsynTunedModels>);
    /// <summary>
    /// Asynchronously retrieves a specific tuned model by its name.
    /// </summary>
    /// <param name="TunedModelName">
    /// The unique name of the tuned model to retrieve.
    /// </param>
    /// <param name="CallBacks">
    /// A callback function that handles the asynchronous response of type <c>TAsynTunedModel</c>.
    /// </param>
    /// <remarks>
    /// <code>
    ///   ASynRetrieve('FileName_to_retrieve',
    ///    function : TAsynTunedModel
    ///    begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject)
    ///        begin
    ///           // Trigger the start method
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Model: TTunedModel)
    ///        begin
    ///          // Trigger the success method
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Trigger the error method
    ///        end;
    ///    end);
    /// </code>
    /// </remarks>
    procedure ASynRetrieve(const TunedModelName: string; CallBacks: TFunc<TAsynTunedModel>);
    /// <summary>
    /// Asynchronously updates a tuned model using a JSON object.
    /// </summary>
    /// <param name="TunedModelName">
    /// The unique name of the tuned model to update.
    /// </param>
    /// <param name="UpdateMask">
    /// A mask specifying which fields to update.
    /// </param>
    /// <param name="Value">
    /// A <c>TJSONObject</c> containing the updated values for the tuned model.
    /// </param>
    /// <param name="CallBacks">
    /// A callback function that handles the asynchronous response of type <c>TAsynTunedModel</c>.
    /// </param>
    /// <remarks>
    /// <code>
    ///   ASynUpdate(TunedModelName, UpdateMask, Value,
    ///    function : TAsynTunedModel
    ///    begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject)
    ///        begin
    ///           // Trigger the start method
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Model: TTunedModel)
    ///        begin
    ///          // Trigger the success method
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Trigger the error method
    ///        end;
    ///    end);
    /// </code>
    /// </remarks>
    procedure ASynUpdate(const TunedModelName: string; const UpdateMask: string; const Value: TJSONObject;
      CallBacks: TFunc<TAsynTunedModel>); overload;
    /// <summary>
    /// Asynchronously updates a tuned model using a parameter procedure.
    /// </summary>
    /// <param name="TunedModelName">
    /// The unique name of the tuned model to update.
    /// </param>
    /// <param name="UpdateMask">
    /// A mask specifying which fields to update.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure that configures <c>TTunedModelParams</c> with the updated values.
    /// </param>
    /// <param name="CallBacks">
    /// A callback function that handles the asynchronous response of type <c>TAsynTunedModel</c>.
    /// </param>
    /// <remarks>
    /// <code>
    ///   ASynUpdate(TunedModelName, UpdateMask,
    ///    procedure (Params: TTunedModelParams)
    ///    begin
    ///      // Set parameters
    ///    end,
    ///    function : TAsynTunedModel
    ///    begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject)
    ///        begin
    ///           // Trigger the start method
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Model: TTunedModel)
    ///        begin
    ///          // Trigger the success method
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Trigger the error method
    ///        end;
    ///    end);
    /// </code>
    procedure ASynUpdate(const TunedModelName: string; const UpdateMask: string; ParamProc: TProc<TTunedModelParams>;
      CallBacks: TFunc<TAsynTunedModel>); overload;
    /// <summary>
    /// Asynchronously deletes a tuned model by its name.
    /// </summary>
    /// <param name="TunedModelName">
    /// The unique name of the tuned model to delete.
    /// </param>
    /// <param name="CallBacks">
    /// A callback function that handles the asynchronous response of type <c>TAsynModelDelete</c>.
    /// </param>
    /// <remarks>
    /// <code>
    ///   ASynDelete(TunedModelName,
    ///    function : TAsynModelDelete
    ///    begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject)
    ///        begin
    ///           // Trigger the start method
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; Model: TModelDelete)
    ///        begin
    ///          // Trigger the success method
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Trigger the error method
    ///        end;
    ///    end);
    /// </code>
    /// </remarks>
    procedure ASynDelete(const TunedModelName: string; CallBacks: TFunc<TAsynModelDelete>);
    /// <summary>
    /// Creates a new model training operation using a JSON object.
    /// </summary>
    /// <param name="Value">
    /// A <c>TJSONObject</c> containing the parameters for the model training.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TModelTraining</c> representing the training operation.
    /// </returns>
    /// <remarks>
    /// <code>
    ///   var ModelTraining := Create(
    ///     procedure (Params: TTunedModelParams)
    ///     begin
    ///       // Set parameters
    ///     end);
    ///   try
    ///     // Do something
    ///   finally
    ///     ModelTraining.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Create(ParamProc: TProc<TTunedModelParams>): TModelTraining; overload;
    /// <summary>
    /// Retrieves a list of tuned models with pagination support.
    /// </summary>
    /// <param name="PageSize">
    /// The maximum number of tuned models to return in the response.
    /// </param>
    /// <param name="PageToken">
    /// A token identifying the page of results to retrieve.
    /// </param>
    /// <param name="Filter">
    /// A filter string to constrain the results.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TTunedModels</c> containing the list of tuned models and pagination information.
    /// </returns>
    function Create(const Value: TJSONObject): TModelTraining; overload;
    /// <summary>
    /// Creates a new model training operation using a parameter procedure.
    /// </summary>
    /// <param name="ParamProc">
    /// A procedure that configures <c>TTunedModelParams</c> for the model training.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TModelTraining</c> representing the training operation.
    /// </returns>
    function List(const PageSize: Integer; const PageToken, Filter: string): TTunedModels;
    /// <summary>
    /// Retrieves a specific tuned model by its name.
    /// </summary>
    /// <param name="TunedModelName">
    /// The unique name of the tuned model to retrieve.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TTunedModel</c> representing the retrieved tuned model.
    /// </returns>
    function Retrieve(const TunedModelName: string): TTunedModel;
    /// <summary>
    /// Updates a tuned model using a parameter procedure.
    /// </summary>
    /// <param name="TunedModelName">
    /// The unique name of the tuned model to update.
    /// </param>
    /// <param name="UpdateMask">
    /// A mask specifying which fields to update.
    /// </param>
    /// <param name="ParamProc">
    /// A procedure that configures <c>TTunedModelParams</c> with the updated values.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TTunedModel</c> representing the updated tuned model.
    /// </returns>
    /// <remarks>
    /// <code>
    ///   var TunedModel := Update(TunedModelName, UpdateMask,
    ///     procedure (Params: TTunedModelParams)
    ///     begin
    ///       // Set parameters
    ///     end);
    ///   try
    ///     // Do something
    ///   finally
    ///     TunedModel.Free;
    ///   end;
    /// </code>
    /// </remarks>
    function Update(const TunedModelName: string; const UpdateMask: string; ParamProc: TProc<TTunedModelParams>): TTunedModel; overload;
    /// <summary>
    /// Updates a tuned model using a JSON object.
    /// </summary>
    /// <param name="TunedModelName">
    /// The unique name of the tuned model to update.
    /// </param>
    /// <param name="UpdateMask">
    /// A mask specifying which fields to update.
    /// </param>
    /// <param name="Value">
    /// A <c>TJSONObject</c> containing the updated values for the tuned model.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TTunedModel</c> representing the updated tuned model.
    /// </returns>
    function Update(const TunedModelName: string; const UpdateMask: string; const Value: TJSONObject): TTunedModel; overload;
    /// <summary>
    /// Deletes a tuned model by its name.
    /// </summary>
    /// <param name="TunedModelName">
    /// The unique name of the tuned model to delete.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>TModelDelete</c> representing the delete operation.
    /// </returns>
    function Delete(const TunedModelName: string): TModelDelete;
  end;

implementation

uses
  System.StrUtils, System.IOUtils, System.Rtti, Rest.Json;

{ TModelStateHelper }

class function TModelStateHelper.Create(const Value: string): TModelState;
begin
  var Index := IndexStr(AnsiUpperCase(Value), [
         'STATE_UNSPECIFIED', 'CREATING', 'ACTIVE', 'FAILED']);
  if Index = -1 then
    raise Exception.CreateFmt('"Model state" unknown : %s', [Value]);
  Result := TModelState(Index);
end;

function TModelStateHelper.ToString: string;
begin
  case Self of
    STATE_UNSPECIFIED:
      Exit('STATE_UNSPECIFIED');
    CREATING:
      Exit('CREATING');
    ACTIVE:
      Exit('ACTIVE');
    FAILED:
      Exit('FAILED');
  end;
end;

{ TModelStateInterceptor }

function TModelStateInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TModelState>.ToString;
end;

procedure TModelStateInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TModelState.Create(Arg)));
end;

{ TTunedModelParams }

function TTunedModelParams.BaseModel(const Value: string): TTunedModelParams;
begin
  Result := TTunedModelParams(Add('baseModel', Value));
end;

function TTunedModelParams.Description(const Value: string): TTunedModelParams;
begin
  Result := TTunedModelParams(Add('description', Value));
end;

function TTunedModelParams.DisplayName(const Value: string): TTunedModelParams;
begin
  Result := TTunedModelParams(Add('displayName', Value));
end;

function TTunedModelParams.ReaderProjectNumbers(
  const Value: TArray<Integer>): TTunedModelParams;
begin
  Result := TTunedModelParams(Add('readerProjectNumbers', Value));
end;

function TTunedModelParams.Temperature(const Value: Double): TTunedModelParams;
begin
  Result := TTunedModelParams(Add('temperature', Value));
end;

function TTunedModelParams.TopK(const Value: Integer): TTunedModelParams;
begin
  Result := TTunedModelParams(Add('topK', Value));
end;

function TTunedModelParams.TopP(const Value: Double): TTunedModelParams;
begin
  Result := TTunedModelParams(Add('topP', Value));
end;

function TTunedModelParams.TunedModelSource(
  const Value: string): TTunedModelParams;
begin
  Result := TTunedModelParams(Add('tunedModelSource', TJSONObject.Create.AddPair('tunedModel', Value)));
end;

function TTunedModelParams.TuningTask(
  const Value: TTuningTaskParams): TTunedModelParams;
begin
  Result := TTunedModelParams(Add('tuningTask', Value.Detach));
end;

{ TTuningExample }

class function TTuningExample.AddItem(const Input,
  Output: string): TTuningExample;
begin
  Result := TTuningExample.Create.TextInput(Input).Output(Output);
end;

function TTuningExample.Output(const Value: string): TTuningExample;
begin
  Result := TTuningExample(Add('output', Value));
end;

function TTuningExample.TextInput(
  const Value: string): TTuningExample;
begin
  Result := TTuningExample(Add('textInput', Value));
end;

{ THyperparametersParams }

function THyperparametersParams.BatchSize(const Value: Integer): THyperparametersParams;
begin
  Result := THyperparametersParams(Add('batchSize', Value));
end;

function THyperparametersParams.EpochCount(const Value: Integer): THyperparametersParams;
begin
  Result := THyperparametersParams(Add('epochCount', Value));
end;

function THyperparametersParams.LearningRate(const Value: Double): THyperparametersParams;
begin
  Result := THyperparametersParams(Add('learningRate', Value));
end;

function THyperparametersParams.LearningRateMultiplier(
  const Value: Double): THyperparametersParams;
begin
  Result := THyperparametersParams(Add('learningRateMultiplier', Value));
end;

{ TTuningTask }

function TTuningTaskParams.Hyperparameters(
  ParamProc: TProcRef<THyperparametersParams>): TTuningTaskParams;
begin
  var Params := THyperparametersParams.Create;
  if Assigned(ParamProc) then
    ParamProc(Params);
  Result := TTuningTaskParams(Add('hyperparameters', Params.Detach));
end;

function TTuningTaskParams.TrainingData(
  const JSONLFileName: string): TTuningTaskParams;
begin
  Result := TTuningTaskParams(Add('training_data', TTuningTaskHelper.ExamplesBuilder(JSONLFileName)));
end;

function TTuningTaskParams.TrainingData(
  const Value: TArray<TTuningExample>): TTuningTaskParams;
begin
  Result := TTuningTaskParams(Add('training_data', TTuningTaskHelper.ExamplesBuilder(Value)));
end;

function TTuningTaskParams.TrainingData(
  const Value: TJSONObject): TTuningTaskParams;
begin
  Result := TTuningTaskParams(Add('training_data', Value));
end;

{ TTuningTaskHelper }

class function TTuningTaskHelper.ExamplesBuilder(
  const Value: TArray<TTuningExample>): TJSONObject;
begin
  {--- Add examples to a JSON array }
  var JSONArray := TJSONArray.Create;
  for var Item in Value do
    JSONArray.Add(Item.Detach);

  {--- Building the JSON string for the API request }
  Result := TJSONObject.Create.AddPair('examples', TJSONObject.Create.AddPair('examples', JSONArray));
end;

class function TTuningTaskHelper.ExamplesBuilder(
  const FileName: string): TJSONObject;
begin
  {--- Check the existence of the file.}
  if not FileExists(FileName) then
    raise Exception.CreateFmt('Training file not found : %s', [FileName]);

  {--- Try to load the data from the file to a JSON array }
  var JSONArray := FileDataToJSONArray(FileName);
  if not Assigned(JSONArray) then
    raise Exception.CreateFmt('Error importing training file : %s', [FileName]);

  {--- Building the JSON string for the API request }
  Result := TJSONObject.Create.AddPair('examples', TJSONObject.Create.AddPair('examples', JSONArray));
end;

class function TTuningTaskHelper.FileDataToJSONArray(
  const FileName: string): TJSONArray;
begin
  case IndexStr(ExtractFileExt(FileName).ToLower, ['.csv', '.jsonl']) of
    0 : Result := LoadFromCSV(FileName);
    1 : Result := LoadFromJSONL(FileName);
    else
      raise Exception.Create('Trainig examples: Only CSV (using `;` as a separator) or JSONL files are supported');
  end;
end;

class function TTuningTaskHelper.LoadFromCSV(
  const FileName: string; Separator: Char): TJSONArray;
begin
  Result := TJSONArray.Create;
  var CSVFile := TFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  var Reader := TStreamReader.Create(CSVFile, TEncoding.UTF8);
  try
    try
      var Index := 0;
      while not Reader.EndOfStream do
        begin
          Inc(Index);
          if Index = 1 then
            Continue;
          var Fields := Reader.ReadLine.Split([Separator]);
          if Length(Fields) = 2 then
            begin
              Result.Add( TJSONOBject.Create
                .AddPair('text_input', Fields[0].Trim)
                .AddPair('output', Fields[1].Trim));
            end;
        end;
    except
      FreeAndNil(Result);
    end;
  finally
    Reader.Free;
    CSVFile.Free;
  end;
end;

class function TTuningTaskHelper.LoadFromJSONL(
  const FileName: string): TJSONArray;
begin
  Result := TJSONArray.Create;
  var JSONLFile := TFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  var StreamReader := TStreamReader.Create(JSONLFile, TEncoding.UTF8);
  try
    try
      while not StreamReader.EndOfStream do
        begin
          Result.Add(TJSONObject.ParseJSONValue(StreamReader.ReadLine) as TJSONObject)
        end;
    except
      FreeAndNil(Result);
    end;
  finally
    StreamReader.Free;
    JSONLFile.Free;
  end;
end;

{ TFineTuneRoute }

procedure TFineTuneRoute.ASynCreate(const Value: TJSONObject;
  CallBacks: TFunc<TAsynModelTraining>);
begin
  with TAsynCallBackExec<TAsynModelTraining, TModelTraining>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TModelTraining
      begin
        Result := Self.Create(Value);
      end);
  finally
    Free;
  end;
end;

procedure TFineTuneRoute.ASynCreate(ParamProc: TProc<TTunedModelParams>;
  CallBacks: TFunc<TAsynModelTraining>);
begin
  with TAsynCallBackExec<TAsynModelTraining, TModelTraining>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TModelTraining
      begin
        Result := Self.Create(ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TFineTuneRoute.ASynDelete(const TunedModelName: string;
  CallBacks: TFunc<TAsynModelDelete>);
begin
  with TAsynCallBackExec<TAsynModelDelete, TModelDelete>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TModelDelete
      begin
        Result := Self.Delete(TunedModelName);
      end);
  finally
    Free;
  end;
end;

procedure TFineTuneRoute.ASynList(const PageSize: Integer; const PageToken,
  Filter: string; CallBacks: TFunc<TAsynTunedModels>);
begin
  with TAsynCallBackExec<TAsynTunedModels, TTunedModels>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TTunedModels
      begin
        Result := Self.List(PageSize, PageToken, Filter);
      end);
  finally
    Free;
  end;
end;

procedure TFineTuneRoute.ASynRetrieve(const TunedModelName: string;
  CallBacks: TFunc<TAsynTunedModel>);
begin
  with TAsynCallBackExec<TAsynTunedModel, TTunedModel>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TTunedModel
      begin
        Result := Self.Retrieve(TunedModelName);
      end);
  finally
    Free;
  end;
end;

procedure TFineTuneRoute.ASynUpdate(const TunedModelName, UpdateMask: string;
  ParamProc: TProc<TTunedModelParams>; CallBacks: TFunc<TAsynTunedModel>);
begin
  with TAsynCallBackExec<TAsynTunedModel, TTunedModel>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TTunedModel
      begin
        Result := Self.Update(TunedModelName, UpdateMask, ParamProc);
      end);
  finally
    Free;
  end;
end;

procedure TFineTuneRoute.ASynUpdate(const TunedModelName, UpdateMask: string;
  const Value: TJSONObject; CallBacks: TFunc<TAsynTunedModel>);
begin
  with TAsynCallBackExec<TAsynTunedModel, TTunedModel>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TTunedModel
      begin
        Result := Self.Update(TunedModelName, UpdateMask, Value);
      end);
  finally
    Free;
  end;
end;

function TFineTuneRoute.Create(
  ParamProc: TProc<TTunedModelParams>): TModelTraining;
begin
  Result := API.Post<TModelTraining, TTunedModelParams>('tunedModels', ParamProc);
end;

function TFineTuneRoute.Create(
  const Value: TJSONObject): TModelTraining;
begin
  try
    Result := API.Post<TModelTraining>('tunedModels', Value);
  finally
    Value.Free;
  end;
end;

function TFineTuneRoute.Delete(const TunedModelName: string): TModelDelete;
begin
  Result := API.Delete<TModelDelete>(TunedModelName);
end;

function TFineTuneRoute.List(const PageSize: Integer;
  const PageToken, Filter: string): TTunedModels;
begin
  Result := API.Get<TTunedModels>('tunedModels', ParamsBuilder(PageSize, PageToken, Filter));
end;

function TFineTuneRoute.Retrieve(const TunedModelName: string): TTunedModel;
begin
  Result := API.Get<TTunedModel>(TunedModelName);
end;

function TFineTuneRoute.Update(const TunedModelName, UpdateMask: string;
  ParamProc: TProc<TTunedModelParams>): TTunedModel;
begin
  Result := API.Patch<TTunedModel, TTunedModelParams>(TunedModelName, UpdateMask, ParamProc);
end;

function TFineTuneRoute.Update(const TunedModelName: string;
  const UpdateMask: string; const Value: TJSONObject): TTunedModel;
begin
  try
    Result := API.Patch<TTunedModel>(TunedModelName, UpdateMask, Value);
  finally
    Value.Free;
  end;
end;

{ TTuningTask }

destructor TTuningTask.Destroy;
begin
  for var Item in FSnapshots do
    Item.Free;
  if Assigned(FHyperparameters) then
    FHyperparameters.Free;
  inherited;
end;

{ TTunedModel }

destructor TTunedModel.Destroy;
begin
  if Assigned(FTuningTask) then
    FTuningTask.Free;
  if Assigned(FTunedModelSource) then
    FTunedModelSource.Free;
  inherited;
end;

{ TTunedModels }

destructor TTunedModels.Destroy;
begin
  for var Item in FTunedModels do
    Item.Free;
  inherited;
end;

end.

unit Gemini.Functions.Core;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGemini
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.JSON;

type
  /// <summary>
  /// Interface defining the core structure and functionality of a function in the system.
  /// </summary>
  /// <remarks>
  /// This interface outlines the basic properties and methods that any function implementation must include.
  /// </remarks>
  IFunctionCore = interface
    ['{D318078A-BA04-4131-A0E9-C95F0330C984}']
    /// <summary>
    /// Retrieves the description of the function.
    /// </summary>
    function GetDescription: string;
    /// <summary>
    /// Retrieves the name of the function.
    /// </summary>
    function GetName: string;
    /// <summary>
    /// Retrieves the InputSchema required by the function, represented as a JSON schema.
    /// </summary>
    function GetInputSchema: string;
    /// <summary>
    /// Executes the function with the provided arguments and returns the result as a string.
    /// </summary>
    /// <param name="Arguments">The arguments passed to the function in JSON format.</param>
    /// <returns>The result of the function execution as a string.</returns>
    function Execute(const Arguments: string): string;
     /// <summary>
    /// Converts the TFunctionCore instance to a JSON object that contains its type and representation.
    /// </summary>
    /// <returns>A JSON object representing the function instance.</returns>
    function ToJson: TJSONObject;
    /// <summary>
    /// Creates a string representation of the TFunctionCore instance in JSON format, including its description, name, and InputSchema.
    /// </summary>
    /// <returns>A string representation of the function in JSON format.</returns>
    function ToString: string;
    /// <summary>
    /// A brief description of the function's purpose, used by the model to determine when and how to call the function.
    /// </summary>
    property Description: string read GetDescription;
    /// <summary>
    /// The unique identifier of the function that will be called. It must only contain characters from a-z, A-Z, 0-9, underscores, or dashes, and should not exceed 64 characters in length.
    /// </summary>
    property Name: string read GetName;
    //// <summary>
    /// The InputSchema required by the function, specified as a JSON schema. If no InputSchema are required, use the schema: {"type": "object", "properties": {}}.
    /// </summary>
    property InputSchema: string read GetInputSchema;
  end;

  /// <summary>
  /// Abstract base class for implementing core function behavior.
  /// </summary>
  /// <remarks>
  /// This class provides basic implementations for some methods and defines the structure that derived classes must follow.
  /// </remarks>
  TFunctionCore = class abstract(TinterfacedObject, IFunctionCore)
  protected
    /// <summary>
    /// Retrieves the description of the function. Derived classes must implement this method.
    /// </summary>
    function GetDescription: string; virtual; abstract;
     /// <summary>
    /// Retrieves the name of the function. Derived classes must implement this method.
    /// </summary>
    function GetName: string; virtual; abstract;
    /// <summary>
    /// Retrieves the InputSchema required by the function, represented as a JSON schema. Derived classes must implement this method.
    /// </summary>
    function GetInputSchema: string; virtual; abstract;
  public
    /// <summary>
    /// Executes the function with the provided arguments and returns the result as a string. Derived classes must implement this method.
    /// </summary>
    /// <param name="Arguments">The arguments passed to the function in JSON format.</param>
    /// <returns>The result of the function execution as a string.</returns>
    function Execute(const Arguments: string): string; virtual; abstract;
    /// <summary>
    /// Converts the TFunctionCore instance to a JSON object that contains its type and representation.
    /// </summary>
    /// <returns>A JSON object representing the function instance.</returns>
    function ToJson: TJSONObject;
    /// <summary>
    /// Creates a string representation of the TFunctionCore instance in JSON format, including its description, name, and InputSchema.
    /// </summary>
    /// <returns>A string representation of the function in JSON format.</returns>
    function ToString: string; override;
    /// <summary>
    /// A brief description of the function's purpose, used by the model to determine when and how to call the function.
    /// </summary>
    property Description: string read GetDescription;
    /// <summary>
    /// The unique identifier of the function that will be called. It must only contain characters from a-z, A-Z, 0-9, underscores, or dashes, and should not exceed 64 characters in length.
    /// </summary>
    property Name: string read GetName;
    /// <summary>
    /// The InputSchema required by the function, specified as a JSON schema. If no InputSchema are required, use the schema: {"type": "object", "properties": {}}.
    /// </summary>
    property InputSchema: string read GetInputSchema;
  end;

implementation

{ TFunctionCore }

function TFunctionCore.ToJson: TJSONObject;
begin
  Result := TJSONObject.Create;
  try
    Result.AddPair('name', Name);
    Result.AddPair('description', Description);
    Result.AddPair('parameters', TJSONObject.ParseJSONValue(InputSchema));
  except
    on E: Exception do
      begin
        Result.Free;
        raise;
      end;
  end;
end;

function TFunctionCore.ToString: string;
begin
  with TStringWriter.Create do
    try
      Write('"name": "%s"', [Name]);
      Write(',"description": "%s"', [Description]);
      Write(',"parameters": %s', [InputSchema]);
      Result := Format('{%s}', [ToString]);
    finally
      Free;
    end;

  {--- Format output }
  var JSON := TJSONObject.ParseJSONValue(Result);
  try
    Result := JSON.Format();
  finally
    JSON.Free;
  end;
end;

end.

unit Gemini.Functions.Example;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGemini
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, Gemini.Functions.Core, Gemini.Schema;

type
  TWeatherReportFunction = class(TFunctionCore)
  protected
    function GetDescription: string; override;
    function GetName: string; override;
    function GetInputSchema: string; override;
  public
    function Execute(const Arguments: string): string; override;
    class function CreateInstance: IFunctionCore;
  end;

implementation

uses
  System.StrUtils, System.JSON;

{ TWeatherReportFunction }

class function TWeatherReportFunction.CreateInstance: IFunctionCore;
begin
  Result := TWeatherReportFunction.create;
end;

function TWeatherReportFunction.Execute(const Arguments: string): string;

  procedure AddToReport(const Value: TJSONObject;
    Temperature: Integer; UnitType: string; Forecast: TArray<string>);
  begin
    Value.AddPair('temperature', TJSONString.Create(Temperature.ToString + UnitType));
    Value.AddPair('forecast', TJSONArray.Create(Forecast[0], Forecast[1]));
  end;

begin
  Result := EmptyStr;
  var Location := EmptyStr;
  var TempUnit := EmptyStr;
  var index := -1;

  {--- Parse arguments to retrieve parameters }
  var JSON := TJSONObject.ParseJSONValue(Arguments) as TJSONObject;
  try
    if Assigned(JSON) then
    try
      Location := JSON.GetValue('location', '');
      TempUnit := JSON.GetValue('unit', '');
    finally
      JSON.Free;
    end;
  except
    Location := EmptyStr;
  end;

  {--- Stop the treatment if location is empty }
  if Location.IsEmpty then
    Exit;

  {--- Build the response }
  JSON := TJSONObject.Create;
  try
    JSON.AddPair('location', Location);
    if Location.ToLower.Contains('san francisco') then
      index := 0 else
    if Location.ToLower.Contains('paris') then
      index := 1;
    case index of
      0 :
        AddToReport(JSON, 21, '°' + TempUnit, [
          'sunny',
          'windy']);
      1 :
        AddToReport(JSON, 7, '°' + TempUnit, [
          'rainy',
          'low visibility but sunny in the late afternoon or early evening']);
    end;
    Result := JSON.ToJSON;
  finally
    JSON.Free;
  end;
end; {Execute}

function TWeatherReportFunction.GetDescription: string;
begin
  Result := 'Get the current weather or meteo in a given location';
end;

function TWeatherReportFunction.GetName: string;
begin
  Result := 'get_weather';
end;

function TWeatherReportFunction.GetInputSchema: string;
begin
//  Result :=
//    '{'+
//    '"type": "object",'+
//    '"properties": {'+
//         '"location": {'+
//             '"type": "string",'+
//             '"description": "The city and state, e.g. San Francisco, CA"'+
//           '},'+
//         '"unit": {'+
//             '"type": "string",'+
//             '"enum": ["celsius", "fahrenheit"]'+
//           '}'+
//     '},'+
//     '"required": ["location"]'+
//    '}';

  {--- If we use the TSchemaParams class defined in the Gemini.Schema unit }
  var Schema := TSchemaParams.New(
    procedure (var Params: TSchemaParams)
    begin
      Params.&Type(stOBJECT);
      Params.Properties('properties',
        procedure (var Params: TSchemaParams)
        begin
          Params.Properties('location',
            procedure (var Params: TSchemaParams)
            begin
              Params.&Type(stSTRING);
              Params.Description('The city and state, e.g. San Francisco, CA');
            end);
          Params.Properties('unit',
            procedure (var Params: TSchemaParams)
            begin
              Params.&Type(stSTRING);
              Params.Enum(['celsius', 'fahrenheit']);
            end);
        end);
      Params.Required(['location', 'unit']);
    end);
  Result := Schema.ToJsonString(True);
end;

end.

unit Gemini.GoogleSearch;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGemini
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.JSON, REST.JsonReflect, REST.Json.Types,
  Gemini.API.Params, Gemini.API;

type
  /// <summary>
  /// Configures dynamic retrieval settings for Google Search operations.
  /// </summary>
  TDynamicRetrievalConfig = class(TJSONParam)
  public
    /// <summary>
    /// Sets the mode for dynamic retrieval.
    /// </summary>
    /// <param name="Value">
    /// A string representing the retrieval mode. For example, "MODE_DYNAMIC".
    /// </param>
    /// <returns>
    /// Returns the updated <c>TDynamicRetrievalConfig</c> instance for method chaining.
    /// </returns>
    function Mode(const Value: string): TDynamicRetrievalConfig;
    /// <summary>
    /// Sets the dynamic threshold for retrieval confidence.
    /// </summary>
    /// <param name="Value">
    /// A double representing the threshold value. Defaults to <c>0.7</c> if not specified.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TDynamicRetrievalConfig</c> instance for method chaining.
    /// </returns>
    function DynamicThreshold(const Value: Double): TDynamicRetrievalConfig;
  end;

  /// <summary>
  /// Configures Google Search retrieval settings within chat parameters.
  /// </summary>
  TGoogleSearchRetrieval = class(TJSONParam)
  public
    /// <summary>
    /// Configures dynamic retrieval settings for Google Search.
    /// </summary>
    /// <param name="Mode">
    /// A string specifying the retrieval mode, such as "MODE_DYNAMIC".
    /// </param>
    /// <param name="DynamicThreshold">
    /// A double indicating the confidence threshold for dynamic retrieval. Defaults to <c>0.7</c>.
    /// </param>
    /// <returns>
    /// Returns the updated <c>TGoogleSearchRetrieval</c> instance for method chaining.
    /// </returns>
    function DynamicRetrievalConfig(const Mode: string; const DynamicThreshold: Double): TGoogleSearchRetrieval;
  end;

  /// <summary>
  /// Represents a web source with a URI and title.
  /// </summary>
  TWeb = class
  private
    FUri: string;
    FTitle: string;
  public
    /// <summary>
    /// The URI of the web source.
    /// </summary>
    property Uri: string read FUri write FUri;
    /// <summary>
    /// The title of the web source.
    /// </summary>
    property Title: string read FTitle write FTitle;
  end;

  /// <summary>
  /// Represents a grounding chunk containing web information.
  /// </summary>
  TGroundingChunksItem = class
  private
    FWeb: TWeb;
  public
    /// <summary>
    /// The web source associated with this grounding chunk.
    /// </summary>
    property Web: TWeb read FWeb write FWeb;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Represents the entry point of a search within grounding metadata.
  /// </summary>
  TSearchEntryPoint = class
  private
    FRenderedContent: string;
  public
    /// <summary>
    /// The rendered content of the search entry point, typically containing HTML or styled text.
    /// </summary>
    property RenderedContent: string read FRenderedContent write FRenderedContent;
  end;

  /// <summary>
  /// Represents a text segment within grounding metadata.
  /// </summary>
  TSegment = class
  private
    FStartIndex: Int64;
    FEndIndex: Int64;
    FText: string;
  public
    /// <summary>
    /// The starting index of the text segment.
    /// </summary>
    property StartIndex: Int64 read FStartIndex write FStartIndex;
    /// <summary>
    /// The ending index of the text segment.
    /// </summary>
    property EndIndex: Int64 read FEndIndex write FEndIndex;
    /// <summary>
    /// The textual content of the segment.
    /// </summary>
    property Text: string read FText write FText;
  end;

  /// <summary>
  /// Represents the support details for a grounding segment.
  /// </summary>
  TGroundingSupportsItem = class
  private
    FSegment: TSegment;
    FGroundingChunkIndices: TArray<Int64>;
    FConfidenceScores: TArray<Double>;
  public
    /// <summary>
    /// The text segment associated with this grounding support.
    /// </summary>
    property Segment: TSegment read FSegment write FSegment;
    /// <summary>
    /// Indices referencing the grounding chunks that support this segment.
    /// </summary>
    property GroundingChunkIndices: TArray<Int64> read FGroundingChunkIndices write FGroundingChunkIndices;
    /// <summary>
    /// Confidence scores corresponding to each grounding chunk index.
    /// </summary>
    property ConfidenceScores: TArray<Double> read FConfidenceScores write FConfidenceScores;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Contains metadata related to grounding information from Google Search.
  /// </summary>
  TGroundingMetadata = class
  private
    FSearchEntryPoint: TSearchEntryPoint;
    FGroundingChunks: TArray<TGroundingChunksItem>;
    FWebSearchQueries: TArray<string>;
  public
    /// <summary>
    /// The entry point of the search, containing rendered content.
    /// </summary>
    property SearchEntryPoint: TSearchEntryPoint read FSearchEntryPoint write FSearchEntryPoint;
    /// <summary>
    /// A collection of grounding chunks providing detailed web sources.
    /// </summary>
    property GroundingChunks: TArray<TGroundingChunksItem> read FGroundingChunks write FGroundingChunks;
    /// <summary>
    /// The search queries used to retrieve grounding information.
    /// </summary>
    property WebSearchQueries: TArray<string> read FWebSearchQueries write FWebSearchQueries;
    destructor Destroy; override;
  end;

implementation

{ TDynamicRetrievalConfig }

function TDynamicRetrievalConfig.DynamicThreshold(
  const Value: Double): TDynamicRetrievalConfig;
begin
  Result := TDynamicRetrievalConfig(Add('dynamic_threshold', Value));
end;

function TDynamicRetrievalConfig.Mode(
  const Value: string): TDynamicRetrievalConfig;
begin
  Result := TDynamicRetrievalConfig(Add('mode', Value));
end;

{ TGoogleSearchRetrieval }

function TGoogleSearchRetrieval.DynamicRetrievalConfig(const Mode: string;
  const DynamicThreshold: Double): TGoogleSearchRetrieval;
begin
  var Value := TDynamicRetrievalConfig.Create.Mode(Mode).DynamicThreshold(DynamicThreshold);
  Result := TGoogleSearchRetrieval(Add('dynamic_retrieval_config', Value.Detach));
end;

{ TGroundingMetadata }

destructor TGroundingMetadata.Destroy;
begin
  if Assigned(FSearchEntryPoint) then
    FSearchEntryPoint.Free;
  for var Item in FGroundingChunks do
      Item.Free;
  inherited;
end;

{ TGroundingChunksItem }

destructor TGroundingChunksItem.Destroy;
begin
  if Assigned(FWeb) then
    FWeb.Free;
  inherited;
end;

{ TGroundingSupportsItem }

destructor TGroundingSupportsItem.Destroy;
begin
  if Assigned(FSegment) then
    FSegment.Free;
  inherited;
end;

end.

unit Gemini.Models;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGemini
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, Gemini.API, Gemini.API.Params, Gemini.Async.Support;

type
  /// <summary>
  /// Represents a model with various properties used in text generation and processing tasks.
  /// </summary>
  /// <remarks>
  /// The <c>TModel</c> class encapsulates various attributes and parameters of a model used for text generation.
  /// This includes properties like the model's resource name, version, description, token limits, and more.
  /// <para>
  /// - <c>Name</c>: The unique resource identifier for the model, formatted as models/{baseModelId}-{version}. This is used to distinguish between different models and their variants.
  /// </para>
  /// <para>
  /// - <c>BaseModelId</c>: The identifier of the base model. It is required when making generation requests to the backend. For example, "gemini-1.5-flash" is a possible base model ID.
  /// </para>
  /// <para>
  /// - <c>Version</c>: Indicates the version of the model, such as "1.0" or "1.5". This property reflects the major version of the model used for generation tasks.
  /// </para>
  /// <para>
  /// - <c>DisplayName</c>: A human-readable name for the model (e.g., "Gemini 1.5 Flash"). This is primarily used for display purposes and can include any UTF-8 characters, up to 128 in length.
  /// </para>
  /// <para>
  /// - <c>Description</c>: A brief explanation of the model’s functionality and purpose. This helps users understand the model’s capabilities at a glance.
  /// </para>
  /// <para>
  /// - <c>InputTokenLimit</c> and <c>OutputTokenLimit</c>: These properties define the maximum number of tokens that can be processed as input and generated as output, respectively. They set constraints on the model's input and output capacities.
  /// </para>
  /// <para>
  /// - <c>SupportedGenerationMethods</c>: Lists the generation methods supported by the model. These are usually defined as Pascal-case strings, such as "generateMessage" or "generateContent". These methods define the various ways the model can be used.
  /// </para>
  /// <para>
  /// - <c>Temperature</c> and <c>MaxTemperature</c>: These parameters control the randomness and variability of the model's responses. A higher temperature results in more diverse outputs, while lower values make responses more deterministic. The temperature value can range between 0.0 and <c>MaxTemperature</c>.
  /// </para>
  /// <para>
  /// - <c>TopP</c>: This property is used for nucleus sampling, which considers the smallest set of tokens whose cumulative probability is at least the value of <c>TopP</c>. This helps ensure more focused and coherent responses by limiting the selection to the most probable tokens.
  /// </para>
  /// <para>
  /// - <c>TopK</c>: Controls top-k sampling, where only the top K most probable tokens are considered during generation. If this property is not set, the model will not use top-k sampling for generating responses.
  /// </para>
  /// This class serves as a foundational data structure to configure and manage various aspects of a model's behavior in AI-driven text generation systems.
  /// </remarks>
  TModel = class
  private
    FName: string;
    FBaseModelId: string;
    FVersion: string;
    FDisplayName: string;
    FDescription: string;
    FInputTokenLimit: string;
    FOutputTokenLimit: string;
    FSupportedGenerationMethods: TArray<string>;
    FTemperature: double;
    FMaxTemperature: double;
    FTopP: double;
    FTopK: integer;
  public
    /// <summary>
    /// The resource name of the Model.
    /// </summary>
    /// <remarks>
    /// Refer to Model variants for all allowed values.
    /// Format: models/{model} with a {model} naming convention of:
    ///   "{baseModelId}-{version}"
    /// </remarks>
    property Name: string read FName write FName;
    /// <summary>
    /// he name of the base model, pass this to the generation request.
    /// </summary>
    /// <remarks>
    /// Examples: gemini-1.5-flash
    /// </remarks>
    property BaseModelId: string read FBaseModelId write FBaseModelId;
    /// <summary>
    /// The version number of the model.
    /// </summary>
    /// <remarks>
    /// This represents the major version (1.0 or 1.5)
    /// </remarks>
    property Version: string read FVersion write FVersion;
    /// <summary>
    /// The human-readable name of the model. E.g. "Gemini 1.5 Flash".
    /// </summary>
    /// <remarks>
    /// The name can be up to 128 characters long and can consist of any UTF-8 characters.
    /// </remarks>
    property DisplayName: string read FDisplayName write FDisplayName;
    /// <summary>
    /// A short description of the model.
    /// </summary>
    property Description: string read FDescription write FDescription;
    /// <summary>
    /// Maximum number of input tokens allowed for this model.
    /// </summary>
    property InputTokenLimit: string read FInputTokenLimit write FInputTokenLimit;
    /// <summary>
    /// Maximum number of output tokens available for this model.
    /// </summary>
    property OutputTokenLimit: string read FOutputTokenLimit write FOutputTokenLimit;
    /// <summary>
    /// The model's supported generation methods.
    /// </summary>
    /// <remarks>
    /// The corresponding API method names are defined as Pascal case strings, such as generateMessage and generateContent.
    /// </remarks>
    property SupportedGenerationMethods: TArray<string> read FSupportedGenerationMethods write FSupportedGenerationMethods;
    /// <summary>
    /// Controls the randomness of the output.
    /// </summary>
    /// <remarks>
    /// Values can range over [0.0,maxTemperature], inclusive. A higher value will produce responses that are more varied, while a value closer to 0.0 will typically result in less surprising responses from the model. This value specifies default to be used by the backend while making the call to the model.
    /// </remarks>
    property Temperature: double read FTemperature write FTemperature;
    /// <summary>
    /// The maximum temperature this model can use.
    /// </summary>
    property MaxTemperature: double read FMaxTemperature write FMaxTemperature;
    /// <summary>
    /// For Nucleus sampling.
    /// </summary>
    /// <remarks>
    /// Nucleus sampling considers the smallest set of tokens whose probability sum is at least topP. This value specifies default to be used by the backend while making the call to the model.
    /// </remarks>
    property TopP: double read FTopP write FTopP;
    /// <summary>
    /// For Top-k sampling.
    /// </summary>
    /// <remarks>
    /// Top-k sampling considers the set of topK most probable tokens. This value specifies default to be used by the backend while making the call to the model. If empty, indicates the model doesn't use top-k sampling, and topK isn't allowed as a generation parameter.
    /// </remarks>
    property TopK: integer read FTopK write FTopK;
  end;

  /// <summary>
  /// Represents a collection of models, along with pagination support for retrieving additional models.
  /// </summary>
  /// <remarks>
  /// The <c>TModels</c> class manages an array of <c>TModel</c> instances and includes pagination capabilities.
  /// It allows easy access to a list of models and handles memory management by freeing individual models when
  /// the instance of the class is destroyed.
  /// </remarks>
  TModels = class
  private
    FModels: TArray<TModel>;
    FNextPageToken: string;
  public
    /// <summary>
    /// Gets or sets the array of models.
    /// </summary>
    /// <remarks>
    /// The <c>Models</c> property contains a list of model instances that can be accessed or modified.
    /// Each item in this array represents an individual model with its own properties and settings.
    /// </remarks>
    property Models: TArray<TModel> read FModels write FModels;
    /// <summary>
    /// Gets or sets the pagination token for retrieving the next page of models.
    /// </summary>
    /// <remarks>
    /// If the model list is paginated, this token can be used in subsequent requests to retrieve the next
    /// set of models. This token is managed by the API and allows efficient handling of large datasets.
    /// </remarks>
    property NextPageToken: string read FNextPageToken write FNextPageToken;
    /// <summary>
    /// Destructor for the <c>TModels</c> class. Frees the memory associated with each model in the array.
    /// </summary>
    /// <remarks>
    /// The destructor ensures that all models in the <c>FModels</c> array are properly freed before
    /// the <c>TModels</c> instance is destroyed, thus preventing memory leaks.
    /// </remarks>
    destructor Destroy; override;
  end;

  /// <summary>
  /// Manages asynchronous callbacks for a model search request using <c>TModel</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynModel</c> type extends the <c>TAsynParams&lt;TModel&gt;</c> record to handle the lifecycle of an asynchronous model operation.
  /// It provides event handlers that trigger at various stages, such as when the operation starts, completes successfully, or encounters an error.
  /// This structure facilitates non-blocking model search operations and is specifically tailored for scenarios where multiple model choices are required.
  /// </remarks>
  TAsynModel = TAsynCallBack<TModel>;

  /// <summary>
  /// Manages asynchronous callbacks for a model search request that returns a collection of models using <c>TModels</c> as the response type.
  /// </summary>
  /// <remarks>
  /// The <c>TAsynModels</c> type extends the <c>TAsynCallBack&lt;TModels&gt;</c> record to handle the lifecycle of an asynchronous operation
  /// involving multiple models. This includes event handlers that trigger at key points in the process, such as when the operation begins,
  /// completes successfully, or encounters an error.
  /// This structure is designed for non-blocking operations that return a collection of models. The <c>TModels</c> type represents
  /// a collection of <c>TModel</c> instances, making this type useful when working with multiple model objects in asynchronous requests.
  /// </remarks>
  TAsynModels = TAsynCallBack<TModels>;

  /// <summary>
  /// Handles API routes related to model retrieval and provides methods to list or fetch specific models.
  /// </summary>
  /// <remarks>
  /// The <c>TModelsRoute</c> class extends <c>TModelsRouteParams</c> and offers methods to retrieve models from the API.
  /// It includes overloaded <c>List</c> methods that allow for listing all models, fetching paginated results, or retrieving a specific model by name.
  /// This class interacts with the underlying API to fetch model data and returns instances of <c>TModels</c> or <c>TModel</c>.
  /// </remarks>
  TModelsRoute = class(TGeminiAPIRoute)
  public
    /// <summary>
    /// Asynchronously retrieves the list of all available models.
    /// </summary>
    /// <param name="CallBacks">
    /// A <c>TFunc&lt;TAsynModels&gt;</c> representing the callback to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// This method sends a request to the API to fetch all available models asynchronously.
    /// The <paramref name="CallBacks"/> function is invoked when the operation completes,
    /// either successfully or with an error.
    /// <code>
    /// Gemini.Models.AsynList(
    ///    function : TAsynModels
    ///    begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; List: TModels)
    ///        begin
    ///          // Handle the display
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///    end);
    /// </code>
    /// </remarks>
    procedure AsynList(CallBacks: TFunc<TAsynModels>); overload;
    /// <summary>
    /// Asynchronously retrieves a paginated list of models.
    /// </summary>
    /// <param name="PageSize">
    /// The number of models to return per page.
    /// </param>
    /// <param name="PageToken">
    /// A token used to retrieve the next page of models.
    /// </param>
    /// <param name="CallBacks">
    /// A <c>TFunc&lt;TAsynModels&gt;</c> representing the callback to handle the asynchronous result.
    /// </param>
    /// <remarks>
    /// This method allows for paginated retrieval of models asynchronously. The <paramref name="PageSize"/>
    /// parameter specifies how many models to return per request, while the <paramref name="PageToken"/> helps
    /// retrieve the next set of models. If no token is provided, the first page is returned.
    /// <code>
    ///
    /// //Declare global variable var Next: string;
    ///
    /// Gemini.Models.AsynList(5, Next,
    ///    function : TAsynModels
    ///    begin
    ///      Result.Sender := my_display_component;
    ///
    ///      Result.OnStart :=
    ///        procedure (Sender: TObject);
    ///        begin
    ///          // Handle the start
    ///        end;
    ///
    ///      Result.OnSuccess :=
    ///        procedure (Sender: TObject; List: TModels)
    ///        begin
    ///          // Handle the display
    ///          Next := List.NextPageToken;
    ///        end;
    ///
    ///      Result.OnError :=
    ///        procedure (Sender: TObject; Error: string)
    ///        begin
    ///          // Handle the error message
    ///        end;
    ///    end);
    /// </code>
    /// </remarks>
    procedure AsynList(const PageSize: Integer; const PageToken: string;
      CallBacks: TFunc<TAsynModels>); overload;
    /// <summary>
    /// Asynchronously retrieves a specific model by its name.
    /// </summary>
    /// <param name="ModelName">
    /// The name of the model to retrieve. If the model name does not already start with 'models/',
    /// it will be prefixed with 'models/'.
    /// </param>
    /// <param name="CallBacks">
    /// A <c>TFunc&lt;TAsynModel&gt;</c> representing the callback to handle the asynchronous result, including
    /// the start, success, and error handling processes.
    /// </param>
    /// <remarks>
    /// This method sends a request to the API to asynchronously retrieve a specific model by its name.
    /// The <paramref name="ModelName"/> parameter is required and can be automatically adjusted with the
    /// <c>LowerCase</c> flag. The model name will be properly formatted to ensure compatibility with the
    /// LLM Gemini framework.
    /// <code>
    /// Gemini.Models.AsynList('models/Gemini-1.5-flash',
    ///     function : TAsynModel
    ///     begin
    ///       Result.Sender := my_display_component;
    ///
    ///       Result.OnStart :=
    ///         procedure (Sender: TObject)
    ///         begin
    ///           // Handle the start
    ///         end;
    ///
    ///       Result.OnSuccess :=
    ///         procedure (Sender: TObject; List: TModel)
    ///         begin
    ///           var M := Sender as TMemo;
    ///           // Handle the display
    ///         end;
    ///
    ///       Result.OnError :=
    ///         procedure (Sender: TObject; Error: string)
    ///         begin
    ///           // Handle the error message
    ///         end
    ///     end);
    /// </code>
    /// </remarks>
    procedure AsynList(const ModelName: string; CallBacks: TFunc<TAsynModel>); overload;
    /// <summary>
    /// Retrieves the list of all available models.
    /// </summary>
    /// <returns>
    /// A <c>TModels</c> object containing the list of models.
    /// </returns>
    /// <remarks>
    /// This method sends a request to the API to fetch all available models without pagination or filtering.
    /// It returns a <c>TModels</c> object containing the collection of models.
    /// <code>
    /// var List := Gemini.Models.List;
    /// try
    ///   for var Item in List.Models do
    ///     WriteLn( Item.DisplayName );
    /// finally
    ///   List.Free;
    /// end;
    /// </code>
    /// </remarks>
    function List: TModels; overload;
    /// <summary>
    /// Retrieves a paginated list of models.
    /// </summary>
    /// <param name="PageSize">
    /// The number of models to return per page.
    /// </param>
    /// <param name="PageToken">
    /// A token used to retrieve the next page of models.
    /// </param>
    /// <returns>
    /// A <c>TModels</c> object containing the list of models for the specified page.
    /// </returns>
    /// <remarks>
    /// This overloaded <c>List</c> method allows for paginated retrieval of models.
    /// The page size specifies how many models to return per request, while the page token
    /// helps retrieve the next set of models. If no page token is provided, the first page is returned.
    /// <code>
    ///
    /// //Declare global variable var Next: string;
    ///
    /// var List := Gemini.Models.List(5, Next);
    /// try
    ///   for var Item in List.Models do
    ///     WriteLn( Item.DisplayName );
    ///   Next := List.NextPageToken;
    /// finally
    ///   List.Free;
    /// end;
    /// </code>
    /// </remarks>
    function List(const PageSize: Integer; const PageToken: string): TModels; overload;
    /// <summary>
    /// Retrieves a specific model by its name.
    /// </summary>
    /// <param name="ModelName">
    /// The name of the model to retrieve. If the model name does not already start with 'models/', it will be prefixed with 'models/'.
    /// </param>
    /// <returns>
    /// A <c>TModel</c> object representing the requested model.
    /// </returns>
    /// <remarks>
    /// This method sends a request to the API to retrieve a model by its unique name. The <c>ModelName</c>
    /// parameter is required and can be automatically adjusted with the <c>LowerCase</c> flag. The model name
    /// will be properly formatted to ensure compatibility with the LLM Gemini framework.
    /// <code>
    /// var Model := Gemini.Models.List('models/Gemini-1.5-flash');
    /// try
    ///   WriteLn( Model.DisplayName );
    /// finally
    ///   Model.Free;
    /// end;
    /// </code>
    /// </remarks>
    function List(const ModelName: string): TModel; overload;
  end;

implementation

{ TModels }

destructor TModels.Destroy;
begin
  for var Item in FModels do
    Item.Free;
  inherited;
end;

{ TModelsRoute }

procedure TModelsRoute.AsynList(CallBacks: TFunc<TAsynModels>);
begin
  with TAsynCallBackExec<TAsynModels, TModels>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TModels
      begin
        Result := Self.List;
      end);
  finally
    Free;
  end;
end;

procedure TModelsRoute.AsynList(const PageSize: Integer;
  const PageToken: string; CallBacks: TFunc<TAsynModels>);
begin
  with TAsynCallBackExec<TAsynModels, TModels>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TModels
      begin
        Result := Self.List(PageSize, PageToken);
      end);
  finally
    Free;
  end;
end;

procedure TModelsRoute.AsynList(const ModelName: string;
  CallBacks: TFunc<TAsynModel>);
begin
  with TAsynCallBackExec<TAsynModel, TModel>.Create(CallBacks) do
  try
    Sender := Use.Param.Sender;
    OnStart := Use.Param.OnStart;
    OnSuccess := Use.Param.OnSuccess;
    OnError := Use.Param.OnError;
    Run(
      function: TModel
      begin
        Result := List(ModelName);
      end);
  finally
    Free;
  end;
end;

function TModelsRoute.List: TModels;
begin
  Result := API.Get<TModels>('models');
end;

function TModelsRoute.List(const PageSize: Integer;
  const PageToken: string): TModels;
begin
  Result := API.Get<TModels>('models', ParamsBuilder(PageSize, PageToken));
end;

function TModelsRoute.List(const ModelName: string): TModel;
begin
  Result := API.Get<TModel>(ModelName);
end;

end.

unit Gemini.NetEncoding.Base64;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGemini
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, System.NetEncoding, System.Net.Mime, System.IOUtils;

  /// <summary>
  /// Encodes the content of a file into a Base64-encoded string.
  /// </summary>
  /// <param name="FileLocation">The full path to the file that will be encoded.</param>
  /// <returns>A Base64-encoded string representing the content of the file.</returns>
  /// <exception cref="Exception">Thrown if the specified file does not exist at the provided location.</exception>
  /// <remarks>
  /// This method reads the file from the specified location and converts it to a Base64 string.
  /// It uses different encoding methods depending on the version of the RTL.
  /// For RTL version 35.0 and later, it uses <c>TNetEncoding.Base64String.Encode</c>,
  /// and for earlier versions, it uses <c>TNetEncoding.Base64.Encode</c>.
  /// </remarks>
  function EncodeBase64(FileLocation : string) : WideString;
  /// <summary>
  /// Retrieves the MIME type of the specified file based on its location.
  /// </summary>
  /// <param name="FileLocation">The full path to the file whose MIME type is to be resolved.</param>
  /// <returns>
  /// A string representing the MIME type of the file.
  /// If the file does not exist, an exception will be raised.
  /// </returns>
  /// <exception cref="Exception">
  /// Thrown if the specified file cannot be found at the provided location.
  /// </exception>
  /// <remarks>
  /// This method checks if the specified file exists and retrieves its MIME type
  /// using the <c>TMimeTypes.Default.GetFileInfo</c> method.
  /// Ensure the provided path is valid before calling this function.
  /// </remarks>
  function ResolveMimeType(const FileLocation: string): string;
  /// <summary>
  /// Retrieves the size of the specified file in bytes.
  /// </summary>
  /// <param name="FileLocation">
  /// The full path to the file whose size is to be determined.
  /// </param>
  /// <returns>
  /// An <c>Int64</c> value representing the file size in bytes.
  /// </returns>
  /// <exception cref="Exception">
  /// Raised if the specified file cannot be accessed or does not exist at the provided location.
  /// </exception>
  /// <remarks>
  /// This function verifies the existence of the specified file and, if accessible, retrieves its size
  /// using the <c>TFile.GetSize</c> method. Ensure that the file path is valid and accessible
  /// before calling this function.
  /// </remarks>
  function FileSize(const FileLocation: string): Int64;


implementation

function EncodeBase64(FileLocation : string): WideString;
begin
  if not FileExists(FileLocation) then
    raise Exception.CreateFmt('File not found : %s', [FileLocation]);

  var Stream := TMemoryStream.Create;
  var StreamOutput := TStringStream.Create('', TEncoding.UTF8);
  try
    Stream.LoadFromFile(FileLocation);
    Stream.Position := 0;
    {$IF RTLVersion >= 35.0}
    TNetEncoding.Base64String.Encode(Stream, StreamOutput);
    {$ELSE}
    TNetEncoding.Base64.Encode(Stream, StreamOutput);
    {$ENDIF}
    Result := StreamOutput.DataString;
  finally
    Stream.Free;
    StreamOutput.Free;
  end;
end;

function ResolveMimeType(const FileLocation: string): string;
begin
  if not FileExists(FileLocation) then
    raise Exception.CreateFmt('File not found: %s', [FileLocation]);

  var LKind: TMimeTypes.TKind;
  TMimeTypes.Default.GetFileInfo(FileLocation, Result, LKind);
end;

function FileSize(const FileLocation: string): Int64;
begin
  try
    FileSize := TFile.GetSize(FileLocation);
  except
    raise;
  end;
end;

end.

unit Gemini;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGemini
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, Gemini.API, System.Net.URLClient,
  Gemini.Chat, Gemini.Models, Gemini.Embeddings, Gemini.Files, Gemini.Caching,
  Gemini.FineTunings;

type
  /// <summary>
  /// The <c>IGemini</c> interface provides access to the various features and routes of the Gemini AI API.
  /// This interface allows interaction with different services such as agents, chat, code completion,
  /// embeddings, file management, fine-tuning, and model information.
  /// </summary>
  /// <remarks>
  /// This interface should be implemented by any class that wants to provide a structured way of accessing
  /// the Gemini AI services. It includes methods and properties for authenticating with an API key,
  /// configuring the base URL, and accessing different API routes.
  ///
  /// To use this interface, instantiate a class that implements it, set the required properties such as
  /// <see cref="Token"/> and <see cref="BaseURL"/>, and call the relevant methods for the desired operations.
  /// <code>
  ///   var Gemini: IGemini := TGemini.Create(API_TOKEN);
  /// </code>
  /// <seealso cref="TGemini"/>
  /// </remarks>
  IGemini = interface
    ['{7E69221E-3C24-4B38-9AE9-894714CA9A47}']
    function GetAPI: TGeminiAPI;
    procedure SetToken(const Value: string);
    function GetToken: string;
    function GetBaseUrl: string;
    procedure SetBaseUrl(const Value: string);
    function GetChatRoute: TChatRoute;
    function GetModelsRoute: TModelsRoute;
    function GetEmbeddingsRoute: TEmbeddingsRoute;
    function GetFilesRoute: TFilesRoute;
    function GetCachingRoute: TCachingRoute;
    function GetFineTuneRoute : TFineTuneRoute;

    /// <summary>
    /// the main API object used for making requests.
    /// </summary>
    /// <returns>
    /// An instance of TGeminiAPI for making API calls.
    /// </returns>
    property API: TGeminiAPI read GetAPI;
    /// Sets or retrieves the API token for authentication.
    /// </summary>
    /// <param name="Value">
    /// The API token as a string.
    /// </param>
    /// <returns>
    /// The current API token.
    /// </returns>
    property Token: string read GetToken write SetToken;
    /// <summary>
    /// Sets or retrieves the base URL for API requests.
    /// Default is https://api.Gemini.com/v1
    /// </summary>
    /// <param name="Value">
    /// The base URL as a string.
    /// </param>
    /// <returns>
    /// The current base URL.
    /// </returns>
    property BaseURL: string read GetBaseUrl write SetBaseUrl;
    /// <summary>
    /// Provides access to the chat completion API.
    /// Allows for interaction with models fine-tuned for instruction-based dialogue.
    /// </summary>
    /// <returns>
    /// An instance of TChatRoute for chat-related operations.
    /// </returns>
    property Chat: TChatRoute read GetChatRoute;
    /// <summary>
    /// Provides access to the models API.
    /// Allows for retrieving and managing available models, including those fine-tuned for specific tasks.
    /// </summary>
    /// <returns>
    /// An instance of TModelsRoute for model-related operations.
    /// </returns>
    property Models: TModelsRoute read GetModelsRoute;
    /// <summary>
    /// Provides access to the embeddings API.
    /// Allows for generating vector embeddings from text input, useful for tasks like semantic search and similarity comparisons.
    /// </summary>
    /// <returns>
    /// An instance of TEmbeddingsRoute for embedding-related operations.
    /// </returns>
    property Embeddings: TEmbeddingsRoute read GetEmbeddingsRoute;
    /// <summary>
    /// Provides access to the file management API.
    /// </summary>
    /// <returns>
    /// An instance of TFilesRoute for file-related operations.
    /// </returns>
    property Files: TFilesRoute read GetFilesRoute;
    /// <summary>
    /// Provides access to the caching management API.
    /// </summary>
    /// <returns>
    /// An instance of TFilesRoute for file-related operations.
    /// </returns>
    property Caching: TCachingRoute read GetCachingRoute;
    /// <summary>
    /// Provides access to fine-tuning API for user and organization.
    /// Allows managing fine-tuning jobs.
    /// </summary>
    /// <returns>
    /// An instance of TFineTuningRoute for fine-tuning operations.
    /// </returns>
    property FineTune: TFineTuneRoute read GetFineTuneRoute;
  end;

  /// <summary>
  /// The <c>TGeminiFactory</c> class is responsible for creating instances of
  /// the <see cref="IGemini"/> interface. It provides a factory method to instantiate
  /// the interface with a provided API token and optional header configuration.
  /// </summary>
  /// <remarks>
  /// This class provides a convenient way to initialize the <see cref="IGemini"/> interface
  /// by encapsulating the necessary configuration details, such as the API token and header options.
  /// By using the factory method, users can quickly create instances of <see cref="IGemini"/> without
  /// manually setting up the implementation details.
  /// </remarks>
  TGeminiFactory = class
    /// <summary>
    /// Creates an instance of the <see cref="IGemini"/> interface with the specified API token
    /// and optional header configuration.
    /// </summary>
    /// <param name="AToken">
    /// The API token as a string, required for authenticating with Gemini API services.
    /// </param>
    /// <param name="Option">
    /// An optional header configuration of type <see cref="THeaderOption"/> to customize the request headers.
    /// The default value is <c>THeaderOption.none</c>.
    /// </param>
    /// <returns>
    /// An instance of <see cref="IGemini"/> initialized with the provided API token and header option.
    /// </returns>
    class function CreateInstance(const AToken: string): IGemini;
  end;

  /// <summary>
  /// The TGemini class provides access to the various features and routes of the Gemini AI API.
  /// This class allows interaction with different services such as agents, chat, code completion,
  /// embeddings, file management, fine-tuning, and model information.
  /// </summary>
  /// <remarks>
  /// This class should be implemented by any class that wants to provide a structured way of accessing
  /// the Gemini AI services. It includes methods and properties for authenticating with an API key,
  /// configuring the base URL, and accessing different API routes.
  /// <seealso cref="TGemini"/>
  /// </remarks>
  TGemini = class(TInterfacedObject, IGemini)
  strict private

  private
    FAPI: TGeminiAPI;

    FChatRoute: TChatRoute;
    FModelsRoute: TModelsRoute;
    FEmbeddingsRoute: TEmbeddingsRoute;
    FFilesRoute: TFilesRoute;
    FCachingRoute: TCachingRoute;
    FFineTuneRoute: TFineTuneRoute;

    function GetAPI: TGeminiAPI;
    function GetToken: string;
    procedure SetToken(const Value: string);
    function GetBaseUrl: string;
    procedure SetBaseUrl(const Value: string);

    function GetChatRoute: TChatRoute;
    function GetModelsRoute: TModelsRoute;
    function GetEmbeddingsRoute: TEmbeddingsRoute;
    function GetFilesRoute: TFilesRoute;
    function GetCachingRoute: TCachingRoute;
    function GetFineTuneRoute: TFineTuneRoute;

  public
    /// <summary>
    /// the main API object used for making requests.
    /// </summary>
    /// <returns>
    /// An instance of TGeminiAPI for making API calls.
    /// </returns>
    property API: TGeminiAPI read GetAPI;
    /// <summary>
    /// Sets or retrieves the API token for authentication.
    /// </summary>
    /// <param name="Value">
    /// The API token as a string.
    /// </param>
    /// <returns>
    /// The current API token.
    /// </returns>
    property Token: string read GetToken write SetToken;
    /// <summary>
    /// Sets or retrieves the base URL for API requests.
    /// Default is https://api.Gemini.com/v1.
    /// </summary>
    /// <param name="Value">
    /// The base URL as a string.
    /// </param>
    /// <returns>
    /// The current base URL.
    /// </returns>
    property BaseURL: string read GetBaseUrl write SetBaseUrl;

  public
    /// <summary>
    /// Provides access to the chat completion API.
    /// Allows for interaction with models fine-tuned for instruction-based dialogue.
    /// </summary>
    /// <returns>
    /// An instance of TChatRoute for chat-related operations.
    /// </returns>
    property Chat: TChatRoute read GetChatRoute;
    /// <summary>
    /// Provides access to the models API.
    /// Allows for retrieving and managing available models, including those fine-tuned for specific tasks.
    /// </summary>
    /// <returns>
    /// An instance of TModelsRoute for model-related operations.
    /// </returns>
    property Models: TModelsRoute read GetModelsRoute;
    /// <summary>
    /// Provides access to the embeddings API.
    /// Allows for generating vector embeddings from text input, useful for tasks like semantic search and similarity comparisons.
    /// </summary>
    /// <returns>
    /// An instance of TEmbeddingsRoute for embedding-related operations.
    /// </returns>
    property Embeddings: TEmbeddingsRoute read GetEmbeddingsRoute;
    /// <summary>
    /// Provides access to the file management API.
    /// </summary>
    /// <returns>
    /// An instance of TFilesRoute for file-related operations.
    /// </returns>
    property Files: TFilesRoute read GetFilesRoute;
    /// <summary>
    /// Provides access to the caching management API.
    /// </summary>
    /// <returns>
    /// An instance of TFilesRoute for file-related operations.
    /// </returns>
    property Caching: TCachingRoute read GetCachingRoute;
    /// <summary>
    /// Provides access to fine-tuning API for user and organization.
    /// Allows managing fine-tuning jobs.
    /// </summary>
    /// <returns>
    /// An instance of TFineTuningRoute for fine-tuning operations.
    /// </returns>
    property FineTune: TFineTuneRoute read GetFineTuneRoute;
  public
    /// <summary>
    /// Initializes a new instance of the <see cref="TGemini"/> class with optional header configuration.
    /// </summary>
    /// <param name="Option">
    /// An optional parameter of type <see cref="THeaderOption"/> to configure the request headers.
    /// The default value is <c>THeaderOption.none</c>.
    /// </param>
    /// <remarks>
    /// This constructor is typically used when no API token is provided initially.
    /// The token can be set later via the <see cref="Token"/> property.
    /// </remarks>
    constructor Create; overload;
    /// <summary>
    /// Initializes a new instance of the <see cref="TGemini"/> class with the provided API token and optional header configuration.
    /// </summary>
    /// <param name="AToken">
    /// The API token as a string, required for authenticating with the Gemini AI API.
    /// </param>
    /// <param name="Option">
    /// An optional parameter of type <see cref="THeaderOption"/> to configure the request headers.
    /// The default value is <c>THeaderOption.none</c>.
    /// </param>
    /// <remarks>
    /// This constructor allows the user to specify an API token at the time of initialization.
    /// </remarks>
    constructor Create(const AToken: string); overload;
    /// <summary>
    /// Releases all resources used by the current instance of the <see cref="TGemini"/> class.
    /// </summary>
    /// <remarks>
    /// This method is called to clean up any resources before the object is destroyed.
    /// It overrides the base <see cref="TInterfacedObject.Destroy"/> method.
    /// </remarks>
    destructor Destroy; override;
  end;

implementation

{ TGemini }

constructor TGemini.Create;
begin
  inherited Create;
  FAPI := TGeminiAPI.Create;
end;

constructor TGemini.Create(const AToken: string);
begin
  Create;
  Token := AToken;
end;

destructor TGemini.Destroy;
begin
  FChatRoute.Free;
  FModelsRoute.Free;
  FEmbeddingsRoute.Free;
  FFilesRoute.Free;
  FCachingRoute.Free;
  FFineTuneRoute.Free;
  FAPI.Free;
  inherited;
end;

function TGemini.GetAPI: TGeminiAPI;
begin
  Result := FAPI;
end;

function TGemini.GetBaseUrl: string;
begin
  Result := FAPI.BaseURL;
end;

function TGemini.GetCachingRoute: TCachingRoute;
begin
  if not Assigned(FCachingRoute) then
    FCachingRoute := TCachingRoute.CreateRoute(API);
  Result := FCachingRoute;
end;

function TGemini.GetChatRoute: TChatRoute;
begin
  if not Assigned(FChatRoute) then
    FChatRoute := TChatRoute.CreateRoute(API);
  Result := FChatRoute;
end;

function TGemini.GetEmbeddingsRoute: TEmbeddingsRoute;
begin
  if not Assigned(FEmbeddingsRoute) then
    FEmbeddingsRoute := TEmbeddingsRoute.CreateRoute(API);
  Result := FEmbeddingsRoute;
end;

function TGemini.GetFilesRoute: TFilesRoute;
begin
  if not Assigned(FFilesRoute) then
    FFilesRoute := TFilesRoute.CreateRoute(API);
  Result := FFilesRoute;
end;

function TGemini.GetFineTuneRoute: TFineTuneRoute;
begin
  if not Assigned(FFineTuneRoute) then
    FFineTuneRoute := TFineTuneRoute.CreateRoute(API);
  Result := FFineTuneRoute;
end;

function TGemini.GetModelsRoute: TModelsRoute;
begin
  if not Assigned(FModelsRoute) then
    FModelsRoute := TModelsRoute.CreateRoute(API);
  Result := FModelsRoute;
end;

function TGemini.GetToken: string;
begin
  Result := FAPI.Token;
end;

procedure TGemini.SetBaseUrl(const Value: string);
begin
  FAPI.BaseURL := Value;
end;

procedure TGemini.SetToken(const Value: string);
begin
  FAPI.Token := Value;
end;

{ TGeminiFactory }

class function TGeminiFactory.CreateInstance(const AToken: string): IGemini;
begin
  Result := TGemini.Create(AToken);
end;

end.

unit Gemini.Safety;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGemini
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, REST.Json.Types,
  Gemini.API.Params;

type
  /// <summary>
  /// Block at and beyond a specified harm probability.
  /// </summary>
  THarmBlockThreshold = (
    /// <summary>
    /// Threshold is unspecified.
    /// </summary>
    HARM_BLOCK_THRESHOLD_UNSPECIFIED,
    /// <summary>
    /// Content with NEGLIGIBLE will be allowed.
    /// </summary>
    BLOCK_LOW_AND_ABOVE,
    /// <summary>
    /// Content with NEGLIGIBLE and LOW will be allowed.
    /// </summary>
    BLOCK_MEDIUM_AND_ABOVE,
    /// <summary>
    /// Content with NEGLIGIBLE, LOW, and MEDIUM will be allowed.
    /// </summary>
    BLOCK_ONLY_HIGH,
    /// <summary>
    /// All content will be allowed.
    /// </summary>
    BLOCK_NONE,
    /// <summary>
    /// Turn off the safety filter.
    /// </summary>
    OFF
  );

  /// <summary>
  /// Helper record for the <c>THarmBlockThreshold</c> enumeration, providing utility methods for converting
  /// between <c>THarmBlockThreshold</c> values and their string representations.
  /// </summary>
  THarmBlockThresholdHelper = record helper for THarmBlockThreshold
    /// <summary>
    /// Converts the current <c>THarmBlockThreshold</c> value to its corresponding string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>THarmBlockThreshold</c> value.
    /// </returns>
    function ToString: string;
  end;

  /// <summary>
  /// The category of a rating.
  /// </summary>
  /// <remarks>
  /// These categories cover various kinds of harms that developers may wish to adjust.
  /// </remarks>
  THarmCategory = (
    /// <summary>
    /// Harassment content.
    /// </summary>
    /// <remarks>
    /// Works only with a Gemini-type model.
    /// </remarks>
    HARM_CATEGORY_HARASSMENT,
    /// <summary>
    /// Hate speech and content.
    /// </summary>
    /// <remarks>
    /// Works only with a Gemini-type model.
    /// </remarks>
    HARM_CATEGORY_HATE_SPEECH,
    /// <summary>
    /// Sexually explicit content.
    /// </summary>
    /// <remarks>
    /// Works only with a Gemini-type model.
    /// </remarks>
    HARM_CATEGORY_SEXUALLY_EXPLICIT,
    /// <summary>
    /// Dangerous content.
    /// </summary>
    /// <remarks>
    /// Works only with a Gemini-type model.
    /// </remarks>
    HARM_CATEGORY_DANGEROUS_CONTENT,
    /// <summary>
    /// Content that may be used to harm civic integrity.
    /// </summary>
    /// <remarks>
    /// Works only with a Gemini-type model.
    /// </remarks>
    HARM_CATEGORY_CIVIC_INTEGRITY
  );

  /// <summary>
  /// Helper record for the <c>THarmCategory</c> enumeration, providing utility methods for converting
  /// between <c>THarmCategory</c> values and their string representations.
  /// </summary>
  THarmCategoryHelper = record helper for THarmCategory
    /// <summary>
    /// Converts the current <c>THarmCategory</c> value to its corresponding string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>THarmCategory</c> value.
    /// </returns>
    function ToString: string;
    /// <summary>
    /// Converts a string representation of a <c>THarmCategory</c> into its corresponding enumeration value.
    /// </summary>
    /// <param name="Value">
    /// The string representing a <c>THarmCategory</c>.
    /// </param>
    /// <returns>
    /// The <c>THarmCategory</c> enumeration value that corresponds to the provided string.
    /// </returns>
    class function Create(const Value: string): THarmCategory; static;
  end;

  /// <summary>
  /// Interceptor class for converting <c>THarmCategory</c> values to and from their string representations in JSON serialization and deserialization.
  /// </summary>
  /// <remarks>
  /// This class is used to facilitate the conversion between the <c>THarmCategory</c> enum and its string equivalents during JSON processing.
  /// It extends the <c>TJSONInterceptorStringToString</c> class to override the necessary methods for custom conversion logic.
  /// </remarks>
  THarmCategoryInterceptor = class(TJSONInterceptorStringToString)
    /// <summary>
    /// Converts the <c>THarmCategory</c> value of the specified field to a string during JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be converted.
    /// </param>
    /// <param name="Field">
    /// The field name representing the <c>THarmCategory</c> value.
    /// </param>
    /// <returns>
    /// The string representation of the <c>THarmCategory</c> value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string back to a <c>THarmCategory</c> value for the specified field during JSON deserialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be set.
    /// </param>
    /// <param name="Field">
    /// The field name where the <c>THarmCategory</c> value will be set.
    /// </param>
    /// <param name="Arg">
    /// The string representation of the <c>THarmCategory</c> to be converted back.
    /// </param>
    /// <remarks>
    /// This method converts the string argument back to the corresponding <c>THarmCategory</c> value and assigns it to the specified field in the object.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Specifies the reason why the prompt was blocked.
  /// </summary>
  TBlockReason = (
    /// <summary>
    /// Default value. This value is unused.
    /// </summary>
    BLOCK_REASON_UNSPECIFIED,
    /// <summary>
    /// Prompt was blocked due to safety reasons. Inspect safetyRatings to understand which safety category blocked it.
    /// </summary>
    SAFETY,
    /// <summary>
    /// Prompt was blocked due to unknown reasons.
    /// </summary>
    OTHER,
    /// <summary>
    /// Prompt was blocked due to the terms which are included from the terminology blocklist.
    /// </summary>
    BLOCKLIST,
    /// <summary>
    /// Prompt was blocked due to prohibited content.
    /// </summary>
    PROHIBITED_CONTENT
  );

  /// <summary>
  /// Helper record for the <c>TBlockReason</c> enumeration, providing utility methods for converting
  /// between <c>TBlockReason</c> values and their string representations.
  /// </summary>
  TBlockReasonHelper = record helper for TBlockReason
    /// <summary>
    /// Converts the current <c>TBlockReason</c> value to its corresponding string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>TBlockReason</c> value.
    /// </returns>
    function ToString: string;
    /// <summary>
    /// Converts a string representation of a <c>TBlockReason</c> into its corresponding enumeration value.
    /// </summary>
    /// <param name="Value">
    /// The string representing a <c>TBlockReason</c>.
    /// </param>
    /// <returns>
    /// The <c>TBlockReason</c> enumeration value that corresponds to the provided string.
    /// </returns>
    class function Create(const Value: string): TBlockReason; static;
  end;

  /// <summary>
  /// Interceptor class for converting <c>TBlockReason</c> values to and from their string representations in JSON serialization and deserialization.
  /// </summary>
  /// <remarks>
  /// This class is used to facilitate the conversion between the <c>TBlockReason</c> enum and its string equivalents during JSON processing.
  /// It extends the <c>TJSONInterceptorStringToString</c> class to override the necessary methods for custom conversion logic.
  /// </remarks>
  TBlockReasonInterceptor = class(TJSONInterceptorStringToString)
    /// <summary>
    /// Converts the <c>TBlockReason</c> value of the specified field to a string during JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be converted.
    /// </param>
    /// <param name="Field">
    /// The field name representing the <c>TBlockReason</c> value.
    /// </param>
    /// <returns>
    /// The string representation of the <c>TBlockReason</c> value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string back to a <c>TBlockReason</c> value for the specified field during JSON deserialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be set.
    /// </param>
    /// <param name="Field">
    /// The field name where the <c>TBlockReason</c> value will be set.
    /// </param>
    /// <param name="Arg">
    /// The string representation of the <c>TBlockReason</c> to be converted back.
    /// </param>
    /// <remarks>
    /// This method converts the string argument back to the corresponding <c>TBlockReason</c> value and assigns it to the specified field in the object.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// The probability that a piece of content is harmful.
  /// </summary>
  /// <remarks>
  /// The classification system gives the probability of the content being unsafe. This does not indicate the severity of harm for a piece of content.
  /// </remarks>
  THarmProbability = (
    /// <summary>
    /// Probability is unspecified.
    /// </summary>
    HARM_PROBABILITY_UNSPECIFIED,
    /// <summary>
    /// Content has a negligible chance of being unsafe.
    /// </summary>
    NEGLIGIBLE,
    /// <summary>
    /// Content has a low chance of being unsafe.
    /// </summary>
    LOW,
    /// <summary>
    /// Content has a medium chance of being unsafe.
    /// </summary>
    MEDIUM,
    /// <summary>
    /// Content has a high chance of being unsafe.
    /// </summary>
    HIGH
  );

  /// <summary>
  /// Helper record for the <c>THarmProbability</c> enumeration, providing utility methods for converting
  /// between <c>THarmProbability</c> values and their string representations.
  /// </summary>
  THarmProbabilityHelper = record helper for THarmProbability
    /// <summary>
    /// Converts the current <c>THarmProbability</c> value to its corresponding string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>THarmProbability</c> value.
    /// </returns>
    function ToString: string;
    /// <summary>
    /// Converts a string representation of a <c>THarmProbability</c> into its corresponding enumeration value.
    /// </summary>
    /// <param name="Value">
    /// The string representing a <c>THarmProbability</c>.
    /// </param>
    /// <returns>
    /// The <c>THarmProbability</c> enumeration value that corresponds to the provided string.
    /// </returns>
    class function Create(const Value: string): THarmProbability; static;
  end;

  /// <summary>
  /// Interceptor class for converting <c>THarmProbability</c> values to and from their string representations in JSON serialization and deserialization.
  /// </summary>
  /// <remarks>
  /// This class is used to facilitate the conversion between the <c>THarmProbability</c> enum and its string equivalents during JSON processing.
  /// It extends the <c>TJSONInterceptorStringToString</c> class to override the necessary methods for custom conversion logic.
  /// </remarks>
  THarmProbabilityInterceptor = class(TJSONInterceptorStringToString)
    /// <summary>
    /// Converts the <c>THarmProbability</c> value of the specified field to a string during JSON serialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be converted.
    /// </param>
    /// <param name="Field">
    /// The field name representing the <c>THarmProbability</c> value.
    /// </param>
    /// <returns>
    /// The string representation of the <c>THarmProbability</c> value.
    /// </returns>
    function StringConverter(Data: TObject; Field: string): string; override;
    /// <summary>
    /// Converts a string back to a <c>THarmProbability</c> value for the specified field during JSON deserialization.
    /// </summary>
    /// <param name="Data">
    /// The object containing the field to be set.
    /// </param>
    /// <param name="Field">
    /// The field name where the <c>THarmProbability</c> value will be set.
    /// </param>
    /// <param name="Arg">
    /// The string representation of the <c>THarmProbability</c> to be converted back.
    /// </param>
    /// <remarks>
    /// This method converts the string argument back to the corresponding <c>THarmProbability</c> value and assigns it to the specified field in the object.
    /// </remarks>
    procedure StringReverter(Data: TObject; Field: string; Arg: string); override;
  end;

  /// <summary>
  /// Represents a safety setting that affects the safety-blocking behavior.
  /// </summary>
  /// <remarks>
  /// By setting safety configurations for specific categories, you can adjust the allowed probability that content is blocked based on harm categories.
  /// </remarks>
  TSafety = record
  private
    FCategory: THarmCategory;
    FThreshold: THarmBlockThreshold;
  public
    /// <summary>
    /// Sets the category for this safety setting.
    /// </summary>
    /// <param name="Value">
    /// The harm category to set.
    /// </param>
    /// <returns>
    /// The updated <c>TSafety</c> record with the specified category.
    /// </returns>
    function Category(Value: THarmCategory): TSafety;
    /// <summary>
    /// Sets the probability threshold at which harm is blocked for this safety setting.
    /// </summary>
    /// <param name="Value">
    /// The harm block threshold to set.
    /// </param>
    /// <returns>
    /// The updated <c>TSafety</c> record with the specified threshold.
    /// </returns>
    function Threshold(Value: THarmBlockThreshold): TSafety;
    /// <summary>
    /// Converts this <c>TSafety</c> record to a JSON object.
    /// </summary>
    /// <returns>
    /// A <c>TJSONObject</c> representing this safety setting.
    /// </returns>
    function ToJson: TJSONObject;
    /// <summary>
    /// Creates a new <c>TSafety</c> record with the specified category and threshold.
    /// </summary>
    /// <param name="Category">
    /// The harm category to set.
    /// </param>
    /// <param name="Threshold">
    /// The harm block threshold to set.
    /// </param>
    /// <returns>
    /// A new <c>TSafety</c> record with the specified category and threshold.
    /// </returns>
    class function New(Category: THarmCategory; Threshold: THarmBlockThreshold): TSafety; static;
    /// <summary>
    /// Returns an array of <c>TSafety</c> settings that do not block any content.
    /// </summary>
    /// <returns>
    /// An array of <c>TSafety</c> records with all categories set to <c>BLOCK_NONE</c>.
    /// </returns>
    class function DontBlock: TArray<TSafety>; static;
    /// <summary>
    /// Creates a <c>TSafety</c> setting for the Sexually Explicit category with the specified threshold.
    /// </summary>
    /// <param name="Value">
    /// The harm block threshold to set for the Sexually Explicit category.
    /// </param>
    /// <returns>
    /// A <c>TSafety</c> record for the Sexually Explicit category with the specified threshold.
    /// </returns>
    class function SexuallyExplicit(const Value: THarmBlockThreshold): TSafety; static;
    /// <summary>
    /// Creates a <c>TSafety</c> setting for the Hate Speech category with the specified threshold.
    /// </summary>
    /// <param name="Value">
    /// The harm block threshold to set for the Hate Speech category.
    /// </param>
    /// <returns>
    /// A <c>TSafety</c> record for the Hate Speech category with the specified threshold.
    /// </returns>
    class function HateSpeech(const Value: THarmBlockThreshold): TSafety; static;
    /// <summary>
    /// Creates a <c>TSafety</c> setting for the Harassment category with the specified threshold.
    /// </summary>
    /// <param name="Value">
    /// The harm block threshold to set for the Harassment category.
    /// </param>
    /// <returns>
    /// A <c>TSafety</c> record for the Harassment category with the specified threshold.
    /// </returns>
    class function Harassment(const Value: THarmBlockThreshold): TSafety; static;
    /// <summary>
    /// Creates a <c>TSafety</c> setting for the Dangerous Content category with the specified threshold.
    /// </summary>
    /// <param name="Value">
    /// The harm block threshold to set for the Dangerous Content category.
    /// </param>
    /// <returns>
    /// A <c>TSafety</c> record for the Dangerous Content category with the specified threshold.
    /// </returns>
    class function DangerousContent(const Value: THarmBlockThreshold): TSafety; static;
    /// <summary>
    /// Creates a <c>TSafety</c> setting for the Civic Integrity category with the specified threshold.
    /// </summary>
    /// <param name="Value">
    /// The harm block threshold to set for the Civic Integrity category.
    /// </param>
    /// <returns>
    /// A <c>TSafety</c> record for the Civic Integrity category with the specified threshold.
    /// </returns>
    class function CivicIntegrity(const Value: THarmBlockThreshold): TSafety; static;
  end;

implementation

uses
  System.StrUtils, System.Rtti, Rest.Json;

{ THarmBlockThresholdHelper }

function THarmBlockThresholdHelper.ToString: string;
begin
  case Self of
    HARM_BLOCK_THRESHOLD_UNSPECIFIED:
      Exit('HARM_BLOCK_THRESHOLD_UNSPECIFIED');
    BLOCK_LOW_AND_ABOVE:
      Exit('BLOCK_LOW_AND_ABOVE');
    BLOCK_MEDIUM_AND_ABOVE:
      Exit('BLOCK_MEDIUM_AND_ABOVE');
    BLOCK_ONLY_HIGH:
      Exit('BLOCK_ONLY_HIGH');
    BLOCK_NONE:
      Exit('BLOCK_NONE');
    OFF:
      Exit('OFF');
  end;
end;

{ THarmCategoryHelper }

class function THarmCategoryHelper.Create(const Value: string): THarmCategory;
begin
  var Index := IndexStr(AnsiUpperCase(Value), [
        'HARM_CATEGORY_HARASSMENT', 'HARM_CATEGORY_HATE_SPEECH',
        'HARM_CATEGORY_SEXUALLY_EXPLICIT', 'HARM_CATEGORY_DANGEROUS_CONTENT',
        'HARM_CATEGORY_CIVIC_INTEGRITY' ]);
  if Index = -1 then
    raise Exception.CreateFmt('"HarmCategory" unknown : %s', [Value]);
  Result := THarmCategory(Index);
end;

function THarmCategoryHelper.ToString: string;
begin
  case Self of
    HARM_CATEGORY_HARASSMENT:
      Exit('HARM_CATEGORY_HARASSMENT');
    HARM_CATEGORY_HATE_SPEECH:
      Exit('HARM_CATEGORY_HATE_SPEECH');
    HARM_CATEGORY_SEXUALLY_EXPLICIT:
      Exit('HARM_CATEGORY_SEXUALLY_EXPLICIT');
    HARM_CATEGORY_DANGEROUS_CONTENT:
      Exit('HARM_CATEGORY_DANGEROUS_CONTENT');
    HARM_CATEGORY_CIVIC_INTEGRITY:
      Exit('HARM_CATEGORY_CIVIC_INTEGRITY');
  end;
end;

{ THarmCategoryInterceptor }

function THarmCategoryInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<THarmCategory>.ToString;
end;

procedure THarmCategoryInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(THarmCategory.Create(Arg)));
end;

{ TBlockReasonHelper }

class function TBlockReasonHelper.Create(const Value: string): TBlockReason;
begin
  var Index := IndexStr(AnsiUpperCase(Value), [
        'BLOCK_REASON_UNSPECIFIED', 'SAFETY', 'OTHER', 'BLOCKLIST', 'PROHIBITED_CONTENT' ]);
  if Index = -1 then
    raise Exception.CreateFmt('"BlockReason" unknown : %s', [Value]);
  Result := TBlockReason(Index);
end;

function TBlockReasonHelper.ToString: string;
begin
  case Self of
    BLOCK_REASON_UNSPECIFIED:
      Exit('BLOCK_REASON_UNSPECIFIED');
    SAFETY:
      Exit('SAFETY');
    OTHER:
      Exit('OTHER');
    BLOCKLIST:
      Exit('BLOCKLIST');
    PROHIBITED_CONTENT:
      Exit('PROHIBITED_CONTENT');
  end;
end;

{ TBlockReasonInterceptor }

function TBlockReasonInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<TBlockReason>.ToString;
end;

procedure TBlockReasonInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(TBlockReason.Create(Arg)));
end;

{ THarmProbabilityHelper }

class function THarmProbabilityHelper.Create(
  const Value: string): THarmProbability;
begin
  var Index := IndexStr(AnsiUpperCase(Value), [
         'HARM_PROBABILITY_UNSPECIFIED', 'NEGLIGIBLE', 'LOW', 'MEDIUM', 'HIGH']);
  if Index = -1 then
    raise Exception.CreateFmt('"HarmProbability" unknown : %s', [Value]);
  Result := THarmProbability(Index);
end;

function THarmProbabilityHelper.ToString: string;
begin
  case Self of
    HARM_PROBABILITY_UNSPECIFIED:
      Exit('HARM_PROBABILITY_UNSPECIFIED');
    NEGLIGIBLE:
      Exit('NEGLIGIBLE');
    LOW:
      Exit('LOW');
    MEDIUM:
      Exit('MEDIUM');
    HIGH:
      Exit('HIGH');
  end;
end;

{ THarmProbabilityInterceptor }

function THarmProbabilityInterceptor.StringConverter(Data: TObject;
  Field: string): string;
begin
  Result := RTTI.GetType(Data.ClassType).GetField(Field).GetValue(Data).AsType<THarmProbability>.ToString;
end;

procedure THarmProbabilityInterceptor.StringReverter(Data: TObject; Field,
  Arg: string);
begin
  RTTI.GetType(Data.ClassType).GetField(Field).SetValue(Data, TValue.From(THarmProbability.Create(Arg)));
end;

{ TSafety }

function TSafety.Category(Value: THarmCategory): TSafety;
begin
  FCategory := Value;
  Result := Self;
end;

class function TSafety.CivicIntegrity(
  const Value: THarmBlockThreshold): TSafety;
begin
  Result := TSafety.New(HARM_CATEGORY_CIVIC_INTEGRITY, Value);
end;

class function TSafety.DangerousContent(
  const Value: THarmBlockThreshold): TSafety;
begin
  Result := TSafety.New(HARM_CATEGORY_DANGEROUS_CONTENT, Value);
end;

class function TSafety.DontBlock: TArray<TSafety>;
begin
  Result := [
    SexuallyExplicit(BLOCK_NONE),
    HateSpeech(BLOCK_NONE),
    Harassment(BLOCK_NONE),
    DangerousContent(BLOCK_NONE),
    CivicIntegrity(BLOCK_NONE)];
end;

class function TSafety.Harassment(
  const Value: THarmBlockThreshold): TSafety;
begin
  Result := TSafety.New(HARM_CATEGORY_HARASSMENT, Value);
end;

class function TSafety.HateSpeech(
  const Value: THarmBlockThreshold): TSafety;
begin
  Result := TSafety.New(HARM_CATEGORY_HATE_SPEECH, Value);
end;

class function TSafety.New(Category: THarmCategory;
  Threshold: THarmBlockThreshold): TSafety;
begin
  Result := Result.Category(Category).Threshold(Threshold);
end;

class function TSafety.SexuallyExplicit(
  const Value: THarmBlockThreshold): TSafety;
begin
  Result := TSafety.New(HARM_CATEGORY_SEXUALLY_EXPLICIT, Value);
end;

function TSafety.Threshold(Value: THarmBlockThreshold): TSafety;
begin
  FThreshold := Value;
  Result := Self;
end;

function TSafety.ToJson: TJSONObject;
begin
  Result := TJSONObject.Create;
  Result.
    AddPair('category', FCategory.ToString).
    AddPair('threshold', FThreshold.ToString);
end;

end.

unit Gemini.Schema;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGemini
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, REST.Json.Types,
  Gemini.API.Params;

type
  /// <summary>
  /// Type contains the list of OpenAPI data types as defined by https://spec.openapis.org/oas/v3.0.3#data-types
  /// </summary>
  TSchemaType = (
    /// <summary>
    /// Not specified, should not be used.
    /// </summary>
    TYPE_UNSPECIFIED,
    /// <summary>
    /// String type.
    /// </summary>
    stSTRING,
    /// <summary>
    /// Number type.
    /// </summary>
    stNUMBER,
    /// <summary>
    /// Integer type.
    /// </summary>
    stINTEGER,
    /// <summary>
    /// Boolean type.
    /// </summary>
    stBOOLEAN,
    /// <summary>
    /// Array type.
    /// </summary>
    stARRAY,
    /// <summary>
    /// Object type.
    /// </summary>
    stOBJECT
  );

  /// <summary>
  /// Helper record for the <c>TSchemaType</c> enumeration, providing utility methods for converting
  /// between <c>TSchemaType</c> values and their string representations.
  /// </summary>
  TSchemaTypeHelper = record helper for TSchemaType
    /// <summary>
    /// Converts the current <c>TSchemaType</c> value to its corresponding string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>TSchemaType</c> value.
    /// </returns>
    function ToString: string;
  end;

  TSchemaParams = class;

  /// <summary>
  /// Provides helper methods for creating property items in OpenAPI schema definitions.
  /// </summary>
  /// <remarks>
  /// This record simplifies the creation of property entries when building schema objects,
  /// particularly for object properties in OpenAPI specifications.
  /// </remarks>
  TPropertyItem = record
  public
    /// <summary>
    /// Creates a JSON pair representing a property in a schema object.
    /// </summary>
    /// <param name="Key">The name of the property.</param>
    /// <param name="Value">The data type of the property as a <c>TSchemaType</c>.</param>
    /// <returns>A <c>TJSONPair</c> representing the property key-value pair.</returns>
    /// <remarks>
    /// This method facilitates the addition of properties to schema objects by creating
    /// a JSON pair with the specified key and data type.
    /// </remarks>
    class function Add(Key: string; Value: TSchemaType): TJSONPair; static;
  end;

  /// <summary>
  /// Represents the Schema Object in OpenAPI, enabling the definition of input and output data types.
  /// These types can be objects, primitives, or arrays. This class provides methods to build and
  /// configure schema definitions as per the OpenAPI 3.0 Specification.
  /// </summary>
  /// <remarks>
  /// The Schema Object allows the definition of input and output data types in the OpenAPI Specification.
  /// This class provides a fluent interface to construct schema definitions programmatically.
  /// </remarks>
  TSchemaParams = class(TJSONParam)
  public
    /// <summary>
    /// Sets the data type of the schema.
    /// </summary>
    /// <param name="Value">The data type to assign to the schema, specified as a <c>TSchemaType</c> value.</param>
    /// <returns>The current <c>TSchemaParams</c> instance to allow for method chaining.</returns>
    /// <remarks>
    /// The <c>type</c> keyword is required in the Schema Object to define the data type.
    /// Valid types include <c>string</c>, <c>number</c>, <c>integer</c>, <c>boolean</c>, <c>array</c>, and <c>object</c>.
    /// </remarks>
    function &Type(const Value: TSchemaType): TSchemaParams;
    /// <summary>
    /// Specifies the format of the data type.
    /// </summary>
    /// <param name="Value">The format of the data type, as a string.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>format</c> keyword is an optional modifier to provide more fine-grained data type information.
    /// Common formats include <c>int32</c>, <c>int64</c> for <c>integer</c> types; <c>float</c>, <c>double</c>
    /// for <c>number</c> types; and <c>byte</c>, <c>binary</c>, <c>date</c>, <c>date-time</c>, <c>password</c> for <c>string</c> types.
    /// </remarks>
    function Format(const Value: string): TSchemaParams;
    /// <summary>
    /// Adds a description to the schema.
    /// </summary>
    /// <param name="Value">A brief description of the schema. Supports Markdown for formatting.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>description</c> keyword provides a description of the schema and can include examples of use.
    /// This field supports Markdown syntax for rich text representation.
    /// </remarks>
    function Description(const Value: string): TSchemaParams;
    /// <summary>
    /// Specifies whether the schema's value can be null.
    /// </summary>
    /// <param name="Value">A boolean indicating if the schema allows null values.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>nullable</c> keyword is a boolean property that indicates if the value of the schema can be null.
    /// By default, this is false.
    /// </remarks>
    function Nullable(const Value: Boolean): TSchemaParams;
    /// <summary>
    /// Specifies an enumeration of possible values.
    /// </summary>
    /// <param name="Value">An array of string values that the schema can take.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>enum</c> keyword restricts the value of the schema to a fixed set of values.
    /// The schema's type must be <c>string</c> when using enum.
    /// </remarks>
    function Enum(const Value: TArray<string>): TSchemaParams;
    /// <summary>
    /// Specifies the maximum number of items allowed in an array schema.
    /// </summary>
    /// <param name="Value">The maximum number of items as a string.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>maxItems</c> keyword applies to schemas of type <c>array</c> and restricts the maximum number
    /// of items the array can contain.
    /// </remarks>
    function MaxItems(const Value: string): TSchemaParams;
    /// <summary>
    /// Specifies the minimum number of items required in an array schema.
    /// </summary>
    /// <param name="Value">The minimum number of items as a string.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>minItems</c> keyword applies to schemas of type <c>array</c> and defines the minimum number
    /// of items the array must contain.
    /// </remarks>
    function MinItems(const Value: string): TSchemaParams;
    /// <summary>
    /// Adds a property to an object schema.
    /// </summary>
    /// <param name="Key">The name of the property.</param>
    /// <param name="Value">A <c>TSchemaParams</c> instance defining the property's schema.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>properties</c> keyword is used to define the properties of an object schema.
    /// Each property is a key-value pair where the key is the property name and the value is a schema defining the property.
    /// </remarks>
    function Properties(const Key: string; const Value: TSchemaParams): TSchemaParams; overload;
    /// <summary>
    /// Adds a property to an object schema using a parameterized procedure to configure the property's schema.
    /// </summary>
    /// <param name="Key">The name of the property.</param>
    /// <param name="ParamProc">A procedure that takes a <c>TSchemaParams</c> instance to configure the property's schema.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// This overload allows you to define the property's schema inline using a procedural configuration.
    /// </remarks>
    function Properties(const Key: string; const ParamProc: TProcRef<TSchemaParams>): TSchemaParams; overload;
    /// <summary>
    /// Adds multiple properties to an object schema.
    /// </summary>
    /// <param name="Value">An array of <c>TJSONPair</c> instances representing the properties.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// This overload allows adding multiple properties at once to the object schema.
    /// </remarks>
    function Properties(const Value: TArray<TJSONPair>): TSchemaParams; overload;
    /// <summary>
    /// Specifies which properties are required in an object schema.
    /// </summary>
    /// <param name="Value">An array of property names that are required.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>required</c> keyword lists the property names that must be included when an object instance
    /// is validated against the schema.
    /// </remarks>
    function Required(const Value: TArray<string>): TSchemaParams;
    /// <summary>
    /// Specifies the schema of the items in an array schema.
    /// </summary>
    /// <param name="Value">A <c>TSchemaParams</c> instance defining the schema of the array items.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// The <c>items</c> keyword is used in array schemas to define the schema of each item in the array.
    /// </remarks>
    function Items(const Value: TSchemaParams): TSchemaParams; overload;
    /// <summary>
    /// Specifies the schema of the items in an array schema using a parameterized procedure.
    /// </summary>
    /// <param name="ParamProc">A procedure that configures a <c>TSchemaParams</c> instance to define the array items' schema.</param>
    /// <returns>The current <c>TSchemaParams</c> instance for method chaining.</returns>
    /// <remarks>
    /// This overload allows you to define the items' schema inline using a procedural configuration.
    /// </remarks>
    function Items(const ParamProc: TProcRef<TSchemaParams>): TSchemaParams; overload;
    /// <summary>
    /// Creates a new instance of <c>TSchemaParams</c>.
    /// </summary>
    /// <returns>A new <c>TSchemaParams</c> instance.</returns>
    class function New: TSchemaParams; overload;
    /// <summary>
    /// Creates and configures a new instance of <c>TSchemaParams</c> using a parameterized procedure.
    /// </summary>
    /// <param name="ParamProc">A procedure that configures the new <c>TSchemaParams</c> instance.</param>
    /// <returns>A new <c>TSchemaParams</c> instance.</returns>
    /// <remarks>
    /// This overload allows you to create and configure the instance inline.
    /// </remarks>
    class function New(const ParamProc: TProcRef<TSchemaParams>): TSchemaParams; overload;
  end;

implementation

uses
  System.StrUtils, System.Rtti, Rest.Json;

{ TSchemaTypeHelper }

function TSchemaTypeHelper.ToString: string;
begin
  case Self of
    TYPE_UNSPECIFIED:
      Exit('type_unspecified');
    stSTRING:
      Exit('string');
    stNUMBER:
      Exit('number');
    stINTEGER:
      Exit('integer');
    stBOOLEAN:
      Exit('boolean');
    stARRAY:
      Exit('array');
    stOBJECT:
      Exit('object');
  end;
end;

{ TSchemaParams }

function TSchemaParams.Description(const Value: string): TSchemaParams;
begin
  Result := TSchemaParams(Add('description', Value));
end;

function TSchemaParams.Enum(const Value: TArray<string>): TSchemaParams;
begin
  Result := TSchemaParams(Add('enum', Value));
end;

function TSchemaParams.Format(const Value: string): TSchemaParams;
begin
  Result := TSchemaParams(Add('format', Value));
end;

function TSchemaParams.Items(
  const ParamProc: TProcRef<TSchemaParams>): TSchemaParams;
begin
  if Assigned(ParamProc) then
    begin
      var Value := TSchemaParams.Create;
      ParamProc(Value);
      Result := Items(Value);
    end
  else Result := Self;
end;

function TSchemaParams.Items(const Value: TSchemaParams): TSchemaParams;
begin
  Result := TSchemaParams(Add('items', Value.Detach));
end;

function TSchemaParams.MaxItems(const Value: string): TSchemaParams;
begin
  Result := TSchemaParams(Add('maxItems', Value));
end;

function TSchemaParams.MinItems(const Value: string): TSchemaParams;
begin
  Result := TSchemaParams(Add('minItems', Value));
end;

class function TSchemaParams.New: TSchemaParams;
begin
  Result := TSchemaParams.Create;
end;

class function TSchemaParams.New(
  const ParamProc: TProcRef<TSchemaParams>): TSchemaParams;
begin
  Result := TSchemaParams.Create;
  if Assigned(ParamProc) then
    begin
      ParamProc(Result);
    end;
end;

function TSchemaParams.Nullable(const Value: Boolean): TSchemaParams;
begin
  Result := TSchemaParams(Add('nullable', Value.ToString));
end;

function TSchemaParams.Properties(
  const Value: TArray<TJSONPair>): TSchemaParams;
begin
  var JSONValue := TJSONObject.Create;
  for var Item in Value do
    begin
      JSONValue.AddPair(Item);
    end;
  Result := TSchemaParams(Add('properties', JSONValue));
end;

function TSchemaParams.Properties(const Key: string;
  const ParamProc: TProcRef<TSchemaParams>): TSchemaParams;
begin
  if Assigned(ParamProc) then
    begin
      var Value := TSchemaParams.Create;
      ParamProc(Value);
      Result := Properties(Key, Value);
    end
  else Result := Self;
end;

function TSchemaParams.Properties(const Key: string;
  const Value: TSchemaParams): TSchemaParams;
begin
  Result := TSchemaParams(Add(Key, Value.Detach));
end;

function TSchemaParams.Required(const Value: TArray<string>): TSchemaParams;
begin
  Result := TSchemaParams(Add('required', Value));
end;

function TSchemaParams.&Type(const Value: TSchemaType): TSchemaParams;
begin
  Result := TSchemaParams(Add('type', Value.ToString));
end;

{ TPropertyItem }

class function TPropertyItem.Add(Key: string; Value: TSchemaType): TJSONPair;
begin
  Result := TJSONPair.Create(Key, Value.ToString);
end;

end.

unit Gemini.Tools;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiGemini
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes, REST.JsonReflect, System.JSON, REST.Json.Types,
  Gemini.API.Params, Gemini.Schema, Gemini.Functions.Core;

type
  /// <summary>
  /// Defines the execution behavior for function calling by defining the execution mode.
  /// </summary>
  TToolMode = (
    /// <summary>
    /// Unspecified function calling mode. This value should not be used.
    /// </summary>
    MODE_UNSPECIFIED,
    /// <summary>
    /// Default model behavior, model decides to predict either a function call or a natural language response.
    /// </summary>
    AUTO,
    /// <summary>
    /// Model is constrained to always predicting a function call only. If "allowedFunctionNames" are set, the
    //// predicted function call will be limited to any one of "allowedFunctionNames", else the predicted function
    /// call will be any one of the provided "functionDeclarations".
    /// </summary>
    ANY,
    /// <summary>
    /// Model will not predict any function call. Model behavior is same as when not passing any function declarations.
    /// </summary>
    NONE
  );

  /// <summary>
  /// Helper record for the <c>TToolMode</c> enumeration, providing utility methods for converting
  /// between <c>TToolMode</c> values and their string representations.
  /// </summary>
  TToolModeHelper = record helper for TToolMode
    /// <summary>
    /// Converts the current <c>TToolMode</c> value to its corresponding string representation.
    /// </summary>
    /// <returns>
    /// A string representing the current <c>TToolMode</c> value.
    /// </returns>
    function ToString: string;
  end;

  /// <summary>
  /// Represents the parameters for a tool plugin, encapsulating a function core instance.
  /// </summary>
  /// <remarks>
  /// This record holds a function core instance that can be converted to a JSON object for integration with tool plugins.
  /// </remarks>
  TToolPluginParams = record
  private
    FFunction: IFunctionCore;
  public
    /// <summary>
    /// Converts the encapsulated function core instance to a JSON object.
    /// </summary>
    /// <returns>
    /// A <c>TJSONObject</c> representing the function core instance.
    /// </returns>
    /// <remarks>
    /// If an error occurs during conversion, the JSON object is deleted and the exception is re-raised.
    /// </remarks>
    function ToJson: TJSONObject;
    /// <summary>
    /// Gets or sets the function core instance.
    /// </summary>
    property &Function: IFunctionCore read FFunction write FFunction;
    /// <summary>
    /// Creates a new <c>TToolPluginParams</c> with the specified function core instance.
    /// </summary>
    /// <param name="AFunction">
    /// The function core instance to include in the plugin parameters.
    /// </param>
    /// <returns>
    /// A new <c>TToolPluginParams</c> containing the specified function core instance.
    /// </returns>
    class function Add(const AFunction: IFunctionCore): TToolPluginParams; static;
  end;

  /// <summary>
  /// Represents the Schema Object in OpenAPI, enabling the definition of input and output data types.
  /// These types can be objects, primitives, or arrays. This class provides methods to build and
  /// configure schema definitions as per the OpenAPI 3.0 Specification.
  /// </summary>
  /// <remarks>
  /// The Schema Object allows the definition of input and output data types in the OpenAPI Specification.
  /// This class provides a fluent interface to construct schema definitions programmatically.
  /// </remarks>
  TSchema = TSchemaParams;

  /// <summary>
  /// Structured representation of a function declaration as defined by the OpenAPI 3.03 specification.
  /// </summary>
  /// <remarks>
  /// Included in this declaration are the function name and parameters. This FunctionDeclaration is a representation of a block of code that can be used as a Tool by the model and executed by the client.
  /// </remarks>
  TFunctionDeclaration = class
  private
    FName: string;
    FDescription: string;
    FParameters: TSchema;
  public
    /// <summary>
    /// Required. The name of the function.
    /// </summary>
    /// <remarks>
    /// Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 63.
    /// </remarks>
    property Name: string read FName write FName;
    /// <summary>
    /// Required. A brief description of the function.
    /// </summary>
    property Description: string read FDescription write FDescription;
    /// <summary>
    /// Optional. Describes the parameters to this function.
    /// </summary>
    /// <remarks>
    /// Reflects the Open API 3.03 Parameter Object string Key: the name of the parameter. Parameter names are case sensitive. Schema Value: the Schema defining the type used for the parameter.
    /// </remarks>
    property Parameters: TSchema read FParameters write FParameters;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Tool details that the model may use to generate response.
  /// </summary>
  /// <remarks>
  /// A Tool is a piece of code that enables the system to interact with external systems to perform an action, or set of actions, outside of knowledge and scope of the model.
  /// </remarks>
  TTool = class
  private
    FFunctionDeclarations: TArray<TFunctionDeclaration>;
  public
    /// <summary>
    /// Optional. A list of FunctionDeclarations available to the model that can be used for function calling.
    /// </summary>
    /// <remarks>
    /// The model or system does not execute the function. Instead the defined function may be returned as a FunctionCall with arguments to the client side for execution. The model may decide to call a subset of these functions by populating FunctionCall in the response. The next conversation turn may contain a FunctionResponse with the Content.role "function" generation context for the next model turn.
    /// </remarks>
    property FunctionDeclarations: TArray<TFunctionDeclaration> read FFunctionDeclarations write FFunctionDeclarations;
    destructor Destroy; override;
  end;

  /// <summary>
  /// Configuration for specifying function calling behavior.
  /// </summary>
  TFunctionCallingConfig = class
  private
   FMode: string;
   FAllowedFunctionNames: TArray<string>;
  public
    /// <summary>
    /// Optional. Specifies the mode in which function calling should execute.
    /// </summary>
    /// <remarks>
    /// If unspecified, the default value will be set to AUTO.
    /// </remarks>
    property Mode: string read FMode write FMode;
    /// <summary>
    /// Optional. A set of function names that, when provided, limits the functions the model will call.
    /// </summary>
    /// <remarks>
    /// This should only be set when the Mode is ANY. Function names should match [FunctionDeclaration.name]. With mode set to ANY, model will predict a function call from the set of function names provided.
    /// </remarks>
    property AllowedFunctionNames: TArray<string> read FAllowedFunctionNames write FAllowedFunctionNames;
  end;

  /// <summary>
  /// The Tool configuration containing parameters for specifying Tool use in the request.
  /// </summary>
  TToolConfig = class
  private
    FFunctionCallingConfig: TFunctionCallingConfig;
  public
    /// <summary>
    /// Optional. Function calling config.
    /// </summary>
    property FunctionCallingConfig: TFunctionCallingConfig read FFunctionCallingConfig write FFunctionCallingConfig;
    destructor Destroy; override;
  end;

implementation

uses
  System.StrUtils;

{ TToolModeHelper }

function TToolModeHelper.ToString: string;
begin
  case Self of
    MODE_UNSPECIFIED:
      Exit('MODE_UNSPECIFIED');
    AUTO:
      Exit('AUTO');
    ANY:
      Exit('ANY');
    NONE:
      Exit('NONE');
  end;
end;

{ TToolPluginParams }

class function TToolPluginParams.Add(const AFunction: IFunctionCore): TToolPluginParams;
begin
  Result.&Function := AFunction;
end;

function TToolPluginParams.ToJson: TJSONObject;
begin
  Result := FFunction.ToJson;
end;

{ TTool }

destructor TTool.Destroy;
begin
  for var Item in FFunctionDeclarations do
    Item.Free;
  inherited;
end;

{ TFunctionDeclaration }

destructor TFunctionDeclaration.Destroy;
begin
  if Assigned(FParameters) then
    FParameters.Free;
  inherited;
end;

{ TToolConfig }

destructor TToolConfig.Destroy;
begin
  if Assigned(FFunctionCallingConfig) then
    FFunctionCallingConfig.Free;
  inherited;
end;

end.

